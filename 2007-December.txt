From fabricecolin at mail.berlios.de  Sat Dec  1 10:39:35 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 1 Dec 2007 10:39:35 +0100
Subject: [Pinot-svn] r1135 - in trunk: . IndexSearch IndexSearch/Google
	IndexSearch/Xapian
Message-ID: <200712010939.lB19dZcx027551@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-01 10:39:35 +0100 (Sat, 01 Dec 2007)
New Revision: 1135

Added:
   trunk/IndexSearch/Makefile.am
   trunk/IndexSearch/Xapian/Makefile.am
Modified:
   trunk/IndexSearch/Google/Makefile.am
   trunk/Makefile.am
   trunk/configure.in
Log:
Build and distribute contents of IndexSearch.
Configure now checks for gtkmm >= 2.10.


Modified: trunk/IndexSearch/Google/Makefile.am
===================================================================
--- trunk/IndexSearch/Google/Makefile.am	2007-12-01 09:36:25 UTC (rev 1134)
+++ trunk/IndexSearch/Google/Makefile.am	2007-12-01 09:39:35 UTC (rev 1135)
@@ -8,6 +8,7 @@
 	GoogleAPIEngine.h \
 	GoogleSearch.h
 
+if HAVE_SOAP
 noinst_LTLIBRARIES = libSearchGoogle.la
 
 libSearchGoogle_la_SOURCES = \
@@ -23,12 +24,12 @@
 	soapcpp2 -n -pGAPI -I /usr/include/gsoap/import GoogleSearch.h
 
 libSearchGoogle_la_CXXFLAGS = \
-	-I$(top_srcdir)/Search \
 	-I$(top_srcdir)/Utils \
 	-I$(top_srcdir)/Tokenize \
 	-I$(top_srcdir)/Tokenize/filters \
 	-I$(top_srcdir)/Collect \
-	-I$(top_srcdir)/Index \
+	-I$(top_srcdir)/IndexSearch \
 	@HTTP_CFLAGS@ @XML_CFLAGS@ @SOAP_CFLAGS@ \
 	@INDEX_CFLAGS@ @GMIME_CFLAGS@
+endif
 

Added: trunk/IndexSearch/Makefile.am
===================================================================
--- trunk/IndexSearch/Makefile.am	2007-12-01 09:36:25 UTC (rev 1134)
+++ trunk/IndexSearch/Makefile.am	2007-12-01 09:39:35 UTC (rev 1135)
@@ -0,0 +1,115 @@
+# Process this file with automake to produce Makefile.in
+
+noinst_HEADERS = \
+	DBusIndex.h \
+	FilterWrapper.h \
+	IndexFactory.h \
+	IndexInterface.h \
+	OpenSearchParser.h \
+	PluginParsers.h \
+	PluginWebEngine.h \
+	QueryProperties.h \
+	ResultsExporter.h \
+	SearchEngineFactory.h \
+	SearchEngineInterface.h \
+	SearchPluginProperties.h \
+	SherlockParser.h \
+	SOAPEnv.h \
+	SOAPEnvH.h \
+	SOAPEnvStub.h \
+	WebEngine.h
+
+if HAVE_SOAP
+noinst_LTLIBRARIES = libIndexSearch.la libSearchSOAP.la
+else
+noinst_LTLIBRARIES = libIndexSearch.la
+endif
+
+libIndexSearch_la_SOURCES = \
+	DBusIndex.cpp \
+	FilterWrapper.cpp \
+	IndexFactory.cpp \
+	OpenSearchParser.cpp \
+	PluginWebEngine.cpp \
+	QueryProperties.cpp \
+	ResultsExporter.cpp \
+	SearchEngineFactory.cpp \
+	SearchEngineInterface.cpp \
+	SearchPluginProperties.cpp \
+	WebEngine.cpp
+
+if HAVE_BOOST_SPIRIT
+libIndexSearch_la_SOURCES += SherlockParser.cpp
+endif
+
+if HAVE_SOAP
+libSearchSOAP_la_SOURCES = SOAPEnvC.cpp SOAPEnvNS.cpp
+endif
+
+bin_PROGRAMS = pinot-index pinot-label pinot-search
+
+pinot_index_LDADD = \
+	-L$(top_builddir)/Utils \
+	-L$(top_builddir)/Tokenize \
+	-L$(top_builddir)/Collect \
+	-L$(top_builddir)/IndexSearch/Xapian \
+	-lIndexSearch -lIndexSearchXapian -lCollect -lTokenize -lBasicUtils -lUtils \
+	@GLIBMM_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ @XML_LIBS@ \
+	@GMIME_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
+
+pinot_index_SOURCES = pinot-index.cpp
+
+pinot_index_DEPENDENCIES = libIndexSearch.la
+
+pinot_label_LDADD = \
+	-L$(top_builddir)/Utils \
+	-L$(top_builddir)/Tokenize \
+	-L$(top_builddir)/IndexSearch/Xapian \
+	-lIndexSearch -lIndexSearchXapian -lTokenize -lBasicUtils -lUtils \
+	@GLIBMM_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ \
+	@XML_LIBS@ @GMIME_LIBS@ @MISC_LIBS@
+
+pinot_label_SOURCES = pinot-label.cpp
+
+pinot_label_DEPENDENCIES = libIndexSearch.la
+
+pinot_search_LDADD = \
+	-L$(top_builddir)/Utils \
+	-L$(top_builddir)/Tokenize \
+	-L$(top_builddir)/Collect \
+	-L$(top_builddir)/IndexSearch/Google \
+	-L$(top_builddir)/IndexSearch/Xapian \
+	-L$(top_builddir)/IndexSearch/xesam \
+	-lIndexSearch -lIndexSearchXapian -lCollect -lTokenize -lUtils -lBasicUtils \
+	@GLIBMM_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ @SOAP_LIBS@ \
+	@XML_LIBS@ @GMIME_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
+
+pinot_search_SOURCES = \
+	pinot-search.cpp
+
+if HAVE_SOAP
+pinot_search_DEPENDENCIES = libIndexSearch.la libSearchSOAP.la
+else
+pinot_search_DEPENDENCIES = libIndexSearch.la
+endif
+
+if HAVE_SOAP
+SOAPEnvC.cpp : SOAPEnv.h
+	soapcpp2 -pSOAPEnv SOAPEnv.h
+endif
+
+AM_CXXFLAGS = \
+	-I$(top_srcdir)/Utils \
+	-I$(top_srcdir)/Tokenize \
+	-I$(top_srcdir)/Tokenize/filters \
+	-I$(top_srcdir)/Collect \
+	-I$(top_srcdir)/IndexSearch/Google \
+	-I$(top_srcdir)/IndexSearch/Xapian \
+	-I$(top_srcdir)/IndexSearch/xesam \
+	@HTTP_CFLAGS@ @GMIME_CFLAGS@ @XML_CFLAGS@ \
+	@DBUS_CFLAGS@ @INDEX_CFLAGS@ @GLIBMM_CFLAGS@
+
+if HAVE_BOOST_SPIRIT
+AM_CXXFLAGS += -DHAVE_BOOST_SPIRIT
+endif
+

Added: trunk/IndexSearch/Xapian/Makefile.am
===================================================================
--- trunk/IndexSearch/Xapian/Makefile.am	2007-12-01 09:36:25 UTC (rev 1134)
+++ trunk/IndexSearch/Xapian/Makefile.am	2007-12-01 09:39:35 UTC (rev 1135)
@@ -0,0 +1,46 @@
+# Process this file with automake to produce Makefile.in
+
+noinst_HEADERS = \
+	AbstractGenerator.h \
+	LanguageDetector.h \
+	XapianDatabase.h \
+	XapianDatabaseFactory.h \
+	XapianIndex.h \
+	XapianEngine.h \
+	$(top_srcdir)/IndexSearch/xesam/XapianQueryBuilder.h \
+	$(top_srcdir)/IndexSearch/xesam/XesamParser.h \
+	$(top_srcdir)/IndexSearch/xesam/XesamQLParser.h \
+	$(top_srcdir)/IndexSearch/xesam/XesamQueryBuilder.h \
+	$(top_srcdir)/IndexSearch/xesam/XesamULParser.h
+
+noinst_LTLIBRARIES = libIndexSearchXapian.la
+
+libIndexSearchXapian_la_SOURCES = \
+	AbstractGenerator.cpp \
+	LanguageDetector.cpp \
+	XapianDatabase.cpp \
+	XapianDatabaseFactory.cpp \
+	XapianIndex.cpp \
+	XapianEngine.cpp \
+	$(top_srcdir)/IndexSearch/xesam/XapianQueryBuilder.cc \
+	$(top_srcdir)/IndexSearch/xesam/XesamQLParser.cc \
+	$(top_srcdir)/IndexSearch/xesam/XesamQueryBuilder.cc
+
+if HAVE_BOOST_SPIRIT
+libIndexSearchXapian_la_SOURCES += $(top_srcdir)/IndexSearch/xesam/XesamULParser.cc
+endif
+
+AM_CXXFLAGS = \
+	-I$(top_srcdir)/Utils \
+	-I$(top_srcdir)/Tokenize \
+	-I$(top_srcdir)/Tokenize/filters \
+	-I$(top_srcdir)/Collect \
+	-I$(top_srcdir)/IndexSearch \
+	-I$(top_srcdir)/IndexSearch/xesam \
+	@HTTP_CFLAGS@ @GMIME_CFLAGS@ @XML_CFLAGS@ \
+	@INDEX_CFLAGS@ @GLIBMM_CFLAGS@
+
+if HAVE_BOOST_SPIRIT
+AM_CXXFLAGS += -DHAVE_BOOST_SPIRIT
+endif
+

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2007-12-01 09:36:25 UTC (rev 1134)
+++ trunk/Makefile.am	2007-12-01 09:39:35 UTC (rev 1135)
@@ -1,15 +1,16 @@
 
-SUBDIRS = po Utils Tokenize SQL Collect Index @SOAP_SUBDIRS@ Search Monitor UI/GTK2/src
+SUBDIRS = po Utils Tokenize SQL Collect IndexSearch/Google IndexSearch/Xapian IndexSearch Monitor UI/GTK2/src
 
 # TODO: Fix that when cleaning up for distcheck! - crazy -
 EXTRA_DIST = AUTHORS ChangeLog ChangeLog-dijon FAQ NEWS README TODO \
 	Tokenize/filters/external-filters.xml globalconfig.xml \
 	textcat_conf.txt textcat3_conf.txt \
 	pinot.desktop pinot-dbus-daemon.desktop pinot.spec \
-	Search/Plugins/*src Search/Plugins/*.xml \
-	Index/pinot-index.1 Index/pinot-label.1 Search/pinot-search.1 \
-	UI/GTK2/src/pinot.1 UI/GTK2/src/pinot-dbus-daemon.1 \
-	UI/GTK2/src/pinot-dbus-daemon.xml UI/GTK2/src/de.berlios.Pinot.service \
+	IndexSearch/Plugins/*src IndexSearch/Plugins/*.xml \
+	IndexSearch/pinot-index.1 IndexSearch/pinot-label.1 \
+	IndexSearch/pinot-search.1 UI/GTK2/src/pinot.1 \
+	UI/GTK2/src/pinot-dbus-daemon.1 UI/GTK2/src/pinot-dbus-daemon.xml \
+	UI/GTK2/src/de.berlios.Pinot.service \
 	UI/GTK2/xapian-powered.png UI/icons/48x48/pinot.png \
 	UI/icons/32x32/pinot.png UI/icons/24x24/pinot.png \
 	UI/icons/22x22/pinot.png UI/icons/16x16/pinot.png \
@@ -17,8 +18,8 @@
 	scripts/bash/pinot-enum-index.sh \
 	scripts/python/pinot-live.py scripts/python/pinot-module.py
 
-man_MANS = Index/pinot-index.1 Index/pinot-label.1 Search/pinot-search.1 \
-	UI/GTK2/src/pinot.1 UI/GTK2/src/pinot-dbus-daemon.1
+man_MANS = IndexSearch/pinot-index.1 IndexSearch/pinot-label.1 \
+	IndexSearch/pinot-search.1 UI/GTK2/src/pinot.1 UI/GTK2/src/pinot-dbus-daemon.1
 
 install-data-local:
 	@mkdir -p $(DESTDIR)$(sysconfdir)/pinot
@@ -33,9 +34,9 @@
 	$(INSTALL_DATA) $(srcdir)/UI/GTK2/src/pinot-dbus-daemon.xml $(DESTDIR)$(datadir)/pinot/pinot-dbus-daemon.xml
 	$(INSTALL_DATA) $(builddir)/UI/GTK2/src/de.berlios.Pinot.service $(DESTDIR)$(datadir)/dbus-1/services/de.berlios.Pinot.service
 	@mkdir -p $(DESTDIR)$(datadir)/pinot/engines
-	$(INSTALL_DATA) $(srcdir)/Search/Plugins/*.src $(DESTDIR)$(datadir)/pinot/engines/
+	$(INSTALL_DATA) $(srcdir)/IndexSearch/Plugins/*.src $(DESTDIR)$(datadir)/pinot/engines/
 	@mv $(DESTDIR)$(datadir)/pinot/engines/AmazonAPI.src $(DESTDIR)$(datadir)/pinot/
-	$(INSTALL_DATA) $(srcdir)/Search/Plugins/*.xml $(DESTDIR)$(datadir)/pinot/engines/
+	$(INSTALL_DATA) $(srcdir)/IndexSearch/Plugins/*.xml $(DESTDIR)$(datadir)/pinot/engines/
 	@mkdir -p $(DESTDIR)$(libdir)/pinot/filters
 	@rm $(DESTDIR)$(libdir)/lib*filter.a $(DESTDIR)$(libdir)/lib*filter.la
 	@mv $(DESTDIR)$(libdir)/lib*filter* $(DESTDIR)$(libdir)/pinot/filters/

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2007-12-01 09:36:25 UTC (rev 1134)
+++ trunk/configure.in	2007-12-01 09:39:35 UTC (rev 1135)
@@ -93,8 +93,6 @@
 if test "x$enable_soap" != "xyes"; then
    SOAP_CFLAGS=""
    SOAP_LIBS=""
-   SOAP_SUBDIRS=""
-   SEARCH_LIBS="-lSearch"
    enable_soap=no
 fi
 AC_MSG_RESULT($enable_soap)
@@ -103,14 +101,10 @@
    PKG_CHECK_MODULES(SOAP, gsoap)
    SOAP_CFLAGS="-DHAVE_GOOGLEAPI $SOAP_CFLAGS"
    AM_CONDITIONAL(HAVE_SOAP, true)
-   SOAP_LIBS="$SOAP_LIBS -lSearchSOAP"
-   SOAP_SUBDIRS="Search/Google"
-   SEARCH_LIBS="-lSearch -lSearchGoogle"
+   SOAP_LIBS="$SOAP_LIBS -lSearchSOAP -lSearchGoogle"
 fi
 AC_SUBST(SOAP_CFLAGS)
 AC_SUBST(SOAP_LIBS)
-AC_SUBST(SOAP_SUBDIRS)
-AC_SUBST(SEARCH_LIBS)
 
 dnl Neon or Curl ?
 AC_MSG_CHECKING(which HTTP library to use)
@@ -300,7 +294,7 @@
 PKG_CHECK_MODULES(GLIBMM, glibmm-2.4 >= 2.6 )
 AC_SUBST(GLIBMM_CFLAGS)
 AC_SUBST(GLIBMM_LIBS)
-PKG_CHECK_MODULES(UI, gtkmm-2.4 >= 2.6 )
+PKG_CHECK_MODULES(UI, gtkmm-2.4 >= 2.10 )
 AC_SUBST(UI_CFLAGS)
 AC_SUBST(UI_LIBS)
 
@@ -317,9 +311,7 @@
 AC_CHECK_FUNCS(sysctlbyname)
 
 AC_OUTPUT( pinot.spec UI/GTK2/src/de.berlios.Pinot.service Makefile \
-	Utils/Makefile Tokenize/Makefile SQL/Makefile po/Makefile.in Collect/Makefile )
-if test "$SOAP_SUBDIRS" != "" ; then
-AC_OUTPUT( Search/Google/Makefile )
-fi
-AC_OUTPUT( Search/Makefile Index/Makefile Monitor/Makefile UI/GTK2/src/Makefile )
+	Utils/Makefile Tokenize/Makefile SQL/Makefile po/Makefile.in Collect/Makefile \
+	IndexSearch/Google/Makefile IndexSearch/Xapian/Makefile IndexSearch/Makefile \
+	Monitor/Makefile UI/GTK2/src/Makefile )
 



From fabricecolin at mail.berlios.de  Sat Dec  1 10:50:06 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 1 Dec 2007 10:50:06 +0100
Subject: [Pinot-svn] r1136 - trunk/UI/GTK2/src
Message-ID: <200712010950.lB19o659027983@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-01 10:50:05 +0100 (Sat, 01 Dec 2007)
New Revision: 1136

Modified:
   trunk/UI/GTK2/src/DaemonState.cpp
   trunk/UI/GTK2/src/Makefile.am
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/ServerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/pinot-dbus-daemon.cc
   trunk/UI/GTK2/src/pinot.cc
Log:
Get headers and libraries from IndexSearch.
Obtain indexes from PinotSettings. Use new DBusIndex class.


Modified: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2007-12-01 09:39:35 UTC (rev 1135)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2007-12-01 09:50:05 UTC (rev 1136)
@@ -60,7 +60,6 @@
 #include "Url.h"
 #include "MonitorFactory.h"
 #include "CrawlHistory.h"
-#include "XapianIndex.h"
 #include "DaemonState.h"
 #include "OnDiskHandler.h"
 #include "PinotSettings.h"
@@ -408,9 +407,14 @@
 #endif
 
 		// Explicitely flush the index once a directory has been crawled
-		XapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
-		index.flush();
+		IndexInterface *pIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
+		if (pIndex != NULL)
+		{
+			pIndex->flush();
 
+			delete pIndex;
+		}
+
 		if (pScannerThread->isStopped() == false)
 		{
 			// Pop the queue

Modified: trunk/UI/GTK2/src/Makefile.am
===================================================================
--- trunk/UI/GTK2/src/Makefile.am	2007-12-01 09:39:35 UTC (rev 1135)
+++ trunk/UI/GTK2/src/Makefile.am	2007-12-01 09:50:05 UTC (rev 1136)
@@ -73,9 +73,9 @@
 	-I$(top_srcdir)/SQL \
 	-I$(top_srcdir)/Monitor \
 	-I$(top_srcdir)/Collect \
-	-I$(top_srcdir)/Index \
-	-I$(top_srcdir)/Search \
-	-I$(top_srcdir)/Search/Google \
+	-I$(top_srcdir)/IndexSearch \
+	-I$(top_srcdir)/IndexSearch/Google \
+	-I$(top_srcdir)/IndexSearch/Xapian \
 	@SQL_CFLAGS@ @HTTP_CFLAGS@ @GMIME_CFLAGS@ @XML_CFLAGS@ \
 	@SOAP_CFLAGS@ @DBUS_CFLAGS@ @INDEX_CFLAGS@ @UI_CFLAGS@
 
@@ -85,10 +85,10 @@
 	-L$(top_builddir)/SQL \
 	-L$(top_builddir)/Monitor \
 	-L$(top_builddir)/Collect \
-	-L$(top_builddir)/Index \
-	-L$(top_builddir)/Search \
-	-L$(top_srcdir)/Search/Google \
-	@SEARCH_LIBS@ -lIndex -lMonitor -lCollect -lSQL \
+	-L$(top_builddir)/IndexSearch \
+	-L$(top_builddir)/IndexSearch/Google \
+	-L$(top_builddir)/IndexSearch/Xapian \
+	-lIndexSearch -lIndexSearchXapian -lMonitor -lCollect -lSQL \
 	-lTokenize -lUtils -lBasicUtils @LIBS@ @UI_LIBS@ \
 	@INDEX_LIBS@ @DBUS_LIBS@ @SOAP_LIBS@ @XML_LIBS@ \
 	@GMIME_LIBS@ @HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
@@ -99,10 +99,10 @@
 	-L$(top_builddir)/SQL \
 	-L$(top_builddir)/Monitor \
 	-L$(top_builddir)/Collect \
-	-L$(top_builddir)/Index \
-	-L$(top_builddir)/Search \
-	-L$(top_srcdir)/Search/Google \
-	@SEARCH_LIBS@ -lIndex -lMonitor -lCollect -lSQL \
+	-L$(top_builddir)/IndexSearch \
+	-L$(top_builddir)/IndexSearch/Google \
+	-L$(top_builddir)/IndexSearch/Xapian \
+	-lIndexSearch -lIndexSearchXapian -lMonitor -lCollect -lSQL \
 	-lTokenize -lUtils -lBasicUtils @LIBS@ @GLIBMM_LIBS@ \
 	@INDEX_LIBS@ @DBUS_LIBS@ @SOAP_LIBS@ @XML_LIBS@ @GMIME_LIBS@ \
 	@HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@

Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2007-12-01 09:39:35 UTC (rev 1135)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2007-12-01 09:50:05 UTC (rev 1136)
@@ -1572,7 +1572,7 @@
 	else if ((m_clientMode == true) &&
 		(location == m_daemonIndexLocation))
 	{
-		return IndexFactory::getIndex("dbus", m_daemonIndexLocation);
+		return IndexFactory::getIndex("dbus-xapian", m_daemonIndexLocation);
 	}
 
 	return IndexFactory::getIndex("xapian", location);

Modified: trunk/UI/GTK2/src/ServerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/ServerThreads.cpp	2007-12-01 09:39:35 UTC (rev 1135)
+++ trunk/UI/GTK2/src/ServerThreads.cpp	2007-12-01 09:50:05 UTC (rev 1136)
@@ -35,8 +35,7 @@
 #include "TimeConverter.h"
 #include "Timer.h"
 #include "Url.h"
-#include "DBusXapianIndex.h"
-#include "XapianIndex.h"
+#include "DBusIndex.h"
 #include "SearchEngineFactory.h"
 #include "config.h"
 #include "NLS.h"
@@ -618,13 +617,14 @@
 
 void DBusServletThread::doWork(void)
 {
-	XapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
+	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
 	DBusError error;
 	bool processedMessage = true, updateLabelsCache = false, flushIndex = false;
 
 	if ((m_pServer == NULL) ||
 		(m_pConnection == NULL) ||
-		(m_pRequest == NULL))
+		(m_pRequest == NULL) ||
+		(pIndex == NULL))
 	{
 		return;
 	}
@@ -635,7 +635,7 @@
 	set<string> &labelsCache = PinotSettings::getInstance().m_labels;
 	if (labelsCache.empty() == true)
 	{
-		index.getLabels(labelsCache);
+		pIndex->getLabels(labelsCache);
 	}
 
 #ifdef DEBUG
@@ -654,7 +654,7 @@
 	{
 		CrawlHistory history(PinotSettings::getInstance().getHistoryDatabaseName());
 		unsigned int crawledFilesCount = history.getItemsCount(CrawlHistory::CRAWLED);
-		unsigned int docsCount = index.getDocumentsCount();
+		unsigned int docsCount = pIndex->getDocumentsCount();
 
 #ifdef DEBUG
 		cout << "DBusServletThread::doWork: received GetStatistics" << endl;
@@ -757,7 +757,7 @@
 				string labelName(pLabel);
 
 				// Add the label
-				flushIndex = index.addLabel(labelName);
+				flushIndex = pIndex->addLabel(labelName);
 				// Is this a known label ?
 				if (labelsCache.find(labelName) == labelsCache.end())
 				{
@@ -795,7 +795,7 @@
 				(pNewLabel != NULL))
 			{
 				// Rename the label
-				flushIndex = index.renameLabel(pOldLabel, pNewLabel);
+				flushIndex = pIndex->renameLabel(pOldLabel, pNewLabel);
 				// Update the labels list
 				set<string>::const_iterator oldLabelIter = labelsCache.find(pOldLabel);
 				if (oldLabelIter != labelsCache.end())
@@ -830,7 +830,7 @@
 			if (pLabel != NULL)
 			{
 				// Delete the label
-				flushIndex = index.deleteLabel(pLabel);
+				flushIndex = pIndex->deleteLabel(pLabel);
 				// Update the labels list
 				set<string>::const_iterator labelIter = labelsCache.find(pLabel);
 				if (labelIter != labelsCache.end())
@@ -863,7 +863,7 @@
 #ifdef DEBUG
 			cout << "DBusServletThread::doWork: received GetDocumentLabels " << docId << endl;
 #endif
-			if (index.getDocumentLabels(docId, labels) == true)
+			if (pIndex->getDocumentLabels(docId, labels) == true)
 			{
 				m_pArray = g_ptr_array_new();
 
@@ -932,7 +932,7 @@
 				<< ", " << labelsCount << " labels" << ", " << resetLabels << endl;
 #endif
 			// Set labels
-			flushIndex = index.setDocumentLabels(docId, labels, ((resetLabels == TRUE) ? true : false));
+			flushIndex = pIndex->setDocumentLabels(docId, labels, ((resetLabels == TRUE) ? true : false));
 
 			// Free container types
 			g_strfreev(ppLabels);
@@ -994,7 +994,7 @@
 				<< " IDs, " << labelsCount << " labels" << ", " << resetLabels << endl;
 #endif
 			// Set labels
-			if (index.setDocumentsLabels(docIds, labels, ((resetLabels == TRUE) ? true : false)) == true)
+			if (pIndex->setDocumentsLabels(docIds, labels, ((resetLabels == TRUE) ? true : false)) == true)
 			{
 				resetLabels = TRUE;
 				flushIndex = true;
@@ -1027,7 +1027,7 @@
 #ifdef DEBUG
 			cout << "DBusServletThread::doWork: received GetDocumentInfo on " << docId << endl;
 #endif
-			if (index.getDocumentInfo(docId, docInfo) == true)
+			if (pIndex->getDocumentInfo(docId, docInfo) == true)
 			{
 				// Prepare the reply
 				m_pReply = newDBusReply(m_pRequest);
@@ -1036,7 +1036,7 @@
 					DBusMessageIter iter;
 
 					dbus_message_iter_init_append(m_pReply, &iter);
-					if (DBusXapianIndex::documentInfoToDBus(&iter, 0, docInfo) == false)
+					if (DBusIndex::documentInfoToDBus(&iter, 0, docInfo) == false)
 					{
 						dbus_message_unref(m_pReply);
 						m_pReply = dbus_message_new_error(m_pRequest,
@@ -1060,7 +1060,7 @@
 		unsigned int docId = 0;
 
 		dbus_message_iter_init(m_pRequest, &iter);
-		if (DBusXapianIndex::documentInfoFromDBus(&iter, docId, docInfo) == false)
+		if (DBusIndex::documentInfoFromDBus(&iter, docId, docInfo) == false)
 		{
 			m_pReply = dbus_message_new_error(m_pRequest,
 				"de.berlios.Pinot.SetDocumentInfo",
@@ -1073,7 +1073,7 @@
 #endif
 
 			// Update the document info
-			flushIndex = index.updateDocumentInfo(docId, docInfo);
+			flushIndex = pIndex->updateDocumentInfo(docId, docInfo);
 
 			// Prepare the reply
 			m_pReply = newDBusReply(m_pRequest);
@@ -1155,7 +1155,7 @@
 #ifdef DEBUG
 			cout << "DBusServletThread::doWork: received UpdateDocument " << docId << endl;
 #endif
-			if (index.getDocumentInfo(docId, docInfo) == true)
+			if (pIndex->getDocumentInfo(docId, docInfo) == true)
 			{
 				// Update document
 				m_pServer->queue_index(docInfo);
@@ -1213,11 +1213,11 @@
 
 	// Set labels ?
 	if ((updateLabelsCache == true) &&
-		(index.setLabels(labelsCache) == false))
+		(pIndex->setLabels(labelsCache) == false))
 	{
 		// Updating failed... reset the cache
 		labelsCache.clear();
-		index.getLabels(labelsCache);
+		pIndex->getLabels(labelsCache);
 #ifdef DEBUG
 		cout << "DBusServletThread::doWork: failed to update labels" << endl;
 #endif
@@ -1239,7 +1239,9 @@
 	if (flushIndex == true)
 	{
 		// Flush now for the sake of the client application
-		index.flush();
+		pIndex->flush();
 	}
+
+	delete pIndex;
 }
 

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2007-12-01 09:39:35 UTC (rev 1135)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2007-12-01 09:50:05 UTC (rev 1136)
@@ -39,7 +39,7 @@
 #include "FilterFactory.h"
 #include "FilterUtils.h"
 #include "FilterWrapper.h"
-#include "DBusXapianIndex.h"
+#include "DBusIndex.h"
 #include "ActionQueue.h"
 #include "CrawlHistory.h"
 #include "QueryHistory.h"
@@ -1865,7 +1865,7 @@
 {
 	// Ask the daemon to reload its configuration
 	// Let D-Bus activate the service if necessary
-	DBusXapianIndex::reload();
+	DBusIndex::reload();
 }
 
 MonitorThread::MonitorThread(MonitorInterface *pMonitor, MonitorHandler *pHandler,

Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2007-12-01 09:39:35 UTC (rev 1135)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2007-12-01 09:50:05 UTC (rev 1136)
@@ -45,7 +45,6 @@
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "DownloaderInterface.h"
-#include "XapianIndex.h"
 #include "config.h"
 #include "NLS.h"
 #include "DaemonState.h"
@@ -542,29 +541,33 @@
 
 		try
 		{
-			XapianIndex index(settings.m_daemonIndexLocation);
 			set<string> labels;
-			string indexVersion(index.getVersion());
-			bool gotLabels = index.getLabels(labels);
+			bool gotLabels = false;
 			bool onBattery = false;
 
-			// What version is the index at ?
-			if (indexVersion < PINOT_INDEX_MIN_VERSION)
+			IndexInterface *pIndex = settings.getIndex(settings.m_daemonIndexLocation);
+			if (pIndex != NULL)
 			{
-				cout << "Upgrading index from version " << indexVersion << " to " << VERSION << endl;
+				string indexVersion(pIndex->getVersion());
+				gotLabels = pIndex->getLabels(labels);
+				// What version is the index at ?
+				if (indexVersion < PINOT_INDEX_MIN_VERSION)
+				{
+					cout << "Upgrading index from version " << indexVersion << " to " << VERSION << endl;
 
-				reindex = true;
-			}
-			if (reindex == true)
-			{
-				// Reset the index so that all documents are reindexed
-				index.reset();
+					reindex = true;
+				}
+				if (reindex == true)
+				{
+					// Reset the index so that all documents are reindexed
+					pIndex->reset();
 
-				cout << "Reset index" << endl;
+					cout << "Reset index" << endl;
 
-				resetHistory = resetLabels = true;
+					resetHistory = resetLabels = true;
+				}
+				pIndex->setVersion(VERSION);
 			}
-			index.setVersion(VERSION);
 
 			if (resetHistory == true)
 			{
@@ -583,23 +586,29 @@
 				cout << "Reset crawler history" << endl;
 			}
 
-			if (resetLabels == true)
+			if ((resetLabels == true) &&
+				(pIndex != NULL))
 			{
 				// Re-apply the labels list
 				if (gotLabels == false)
 				{
 					// If this is an upgrade from a version < 0.80, the labels list
 					// needs to be pulled from the configuration file
-					index.setLabels(settings.m_labels);
+					pIndex->setLabels(settings.m_labels);
 
 					cout << "Set labels as per the configuration file" << endl;
 				}
 				else
 				{
-					index.setLabels(labels);
+					pIndex->setLabels(labels);
 				}
 			}
 
+			if (pIndex != NULL)
+			{
+				delete pIndex;
+			}
+
 			// Connect to the quit signal
 			server.getQuitSignal().connect(sigc::ptr_fun(&quitAll));
 

Modified: trunk/UI/GTK2/src/pinot.cc
===================================================================
--- trunk/UI/GTK2/src/pinot.cc	2007-12-01 09:39:35 UTC (rev 1135)
+++ trunk/UI/GTK2/src/pinot.cc	2007-12-01 09:50:05 UTC (rev 1136)
@@ -50,7 +50,6 @@
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "DownloaderInterface.h"
-#include "XapianIndex.h"
 #include "NLS.h"
 #include "PinotSettings.h"
 #include "mainWindow.hh"
@@ -311,20 +310,25 @@
 
 	atexit(closeAll);
 
-	XapianIndex index(settings.m_docsIndexLocation);
-	string indexVersion(index.getVersion());
+	IndexInterface *pIndex = settings.getIndex(settings.m_docsIndexLocation);
+	if (pIndex != NULL)
+	{
+		string indexVersion(pIndex->getVersion());
 
-	// What version is the index at ?
-	// Is an upgrade necessary ?
-	if ((indexVersion < PINOT_INDEX_MIN_VERSION) &&
-		(index.getDocumentsCount() > 0))
-	{
-		warnAboutVersion = true;
-	}
+		// What version is the index at ?
+		// Is an upgrade necessary ?
+		if ((indexVersion < PINOT_INDEX_MIN_VERSION) &&
+			(pIndex->getDocumentsCount() > 0))
+		{
+			warnAboutVersion = true;
+		}
 #ifdef DEBUG
-	cout << "My Web Pages was set to version " << indexVersion << endl;
+		cout << "My Web Pages was set to version " << indexVersion << endl;
 #endif
-	index.setVersion(VERSION);
+		pIndex->setVersion(VERSION);
+
+		delete pIndex;
+	}
 	if (warnAboutVersion == true)
 	{
 		settings.m_warnAboutVersion = warnAboutVersion;



From fabricecolin at mail.berlios.de  Sat Dec  1 10:25:57 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 1 Dec 2007 10:25:57 +0100
Subject: [Pinot-svn] r1133 - in trunk: . Index IndexSearch
	IndexSearch/Xapian Search
Message-ID: <200712010925.lB19PvFA026934@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-01 10:25:54 +0100 (Sat, 01 Dec 2007)
New Revision: 1133

Added:
   trunk/IndexSearch/
   trunk/IndexSearch/DBusXapianIndex.cpp
   trunk/IndexSearch/DBusXapianIndex.h
   trunk/IndexSearch/FilterWrapper.cpp
   trunk/IndexSearch/FilterWrapper.h
   trunk/IndexSearch/Google/
   trunk/IndexSearch/IndexFactory.cpp
   trunk/IndexSearch/IndexFactory.h
   trunk/IndexSearch/IndexInterface.h
   trunk/IndexSearch/OpenSearchParser.cpp
   trunk/IndexSearch/OpenSearchParser.h
   trunk/IndexSearch/PluginParsers.h
   trunk/IndexSearch/PluginWebEngine.cpp
   trunk/IndexSearch/PluginWebEngine.h
   trunk/IndexSearch/Plugins/
   trunk/IndexSearch/QueryProperties.cpp
   trunk/IndexSearch/QueryProperties.h
   trunk/IndexSearch/ResultsExporter.cpp
   trunk/IndexSearch/ResultsExporter.h
   trunk/IndexSearch/SOAPEnv.h
   trunk/IndexSearch/SOAPEnvH.h
   trunk/IndexSearch/SOAPEnvNS.cpp
   trunk/IndexSearch/SOAPEnvStub.h
   trunk/IndexSearch/SearchEngineFactory.cpp
   trunk/IndexSearch/SearchEngineFactory.h
   trunk/IndexSearch/SearchEngineInterface.cpp
   trunk/IndexSearch/SearchEngineInterface.h
   trunk/IndexSearch/SearchPluginProperties.cpp
   trunk/IndexSearch/SearchPluginProperties.h
   trunk/IndexSearch/SherlockParser.cpp
   trunk/IndexSearch/SherlockParser.h
   trunk/IndexSearch/WebEngine.cpp
   trunk/IndexSearch/WebEngine.h
   trunk/IndexSearch/Xapian/
   trunk/IndexSearch/Xapian/AbstractGenerator.cpp
   trunk/IndexSearch/Xapian/AbstractGenerator.h
   trunk/IndexSearch/Xapian/LanguageDetector.cpp
   trunk/IndexSearch/Xapian/LanguageDetector.h
   trunk/IndexSearch/Xapian/XapianDatabase.cpp
   trunk/IndexSearch/Xapian/XapianDatabase.h
   trunk/IndexSearch/Xapian/XapianDatabaseFactory.cpp
   trunk/IndexSearch/Xapian/XapianDatabaseFactory.h
   trunk/IndexSearch/Xapian/XapianEngine.cpp
   trunk/IndexSearch/Xapian/XapianEngine.h
   trunk/IndexSearch/Xapian/XapianIndex.cpp
   trunk/IndexSearch/Xapian/XapianIndex.h
   trunk/IndexSearch/pinot-index.1
   trunk/IndexSearch/pinot-index.cpp
   trunk/IndexSearch/pinot-label.1
   trunk/IndexSearch/pinot-label.cpp
   trunk/IndexSearch/pinot-search.1
   trunk/IndexSearch/pinot-search.cpp
Removed:
   trunk/Index/DBusXapianIndex.cpp
   trunk/Index/DBusXapianIndex.h
   trunk/Index/FilterWrapper.cpp
   trunk/Index/FilterWrapper.h
   trunk/Index/IndexFactory.cpp
   trunk/Index/IndexFactory.h
   trunk/Index/IndexInterface.h
   trunk/Index/LanguageDetector.cpp
   trunk/Index/LanguageDetector.h
   trunk/Index/XapianDatabase.cpp
   trunk/Index/XapianDatabase.h
   trunk/Index/XapianDatabaseFactory.cpp
   trunk/Index/XapianDatabaseFactory.h
   trunk/Index/XapianIndex.cpp
   trunk/Index/XapianIndex.h
   trunk/Index/pinot-index.1
   trunk/Index/pinot-index.cpp
   trunk/Index/pinot-label.1
   trunk/Index/pinot-label.cpp
   trunk/Search/AbstractGenerator.cpp
   trunk/Search/AbstractGenerator.h
   trunk/Search/Google/
   trunk/Search/OpenSearchParser.cpp
   trunk/Search/OpenSearchParser.h
   trunk/Search/PluginParsers.h
   trunk/Search/PluginWebEngine.cpp
   trunk/Search/PluginWebEngine.h
   trunk/Search/Plugins/
   trunk/Search/QueryProperties.cpp
   trunk/Search/QueryProperties.h
   trunk/Search/ResultsExporter.cpp
   trunk/Search/ResultsExporter.h
   trunk/Search/SOAPEnv.h
   trunk/Search/SOAPEnvH.h
   trunk/Search/SOAPEnvNS.cpp
   trunk/Search/SOAPEnvStub.h
   trunk/Search/SearchEngineFactory.cpp
   trunk/Search/SearchEngineFactory.h
   trunk/Search/SearchEngineInterface.cpp
   trunk/Search/SearchEngineInterface.h
   trunk/Search/SearchPluginProperties.cpp
   trunk/Search/SearchPluginProperties.h
   trunk/Search/SherlockParser.cpp
   trunk/Search/SherlockParser.h
   trunk/Search/WebEngine.cpp
   trunk/Search/WebEngine.h
   trunk/Search/XapianEngine.cpp
   trunk/Search/XapianEngine.h
   trunk/Search/pinot-search.1
   trunk/Search/pinot-search.cpp
Log:
Moved index and search code under IndexSearch, with anything depending on
Xapian in IndexSearch/Xapian.


Deleted: trunk/Index/DBusXapianIndex.cpp
===================================================================
--- trunk/Index/DBusXapianIndex.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/DBusXapianIndex.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,990 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <iostream>
-
-#include "Languages.h"
-#include "XapianDatabaseFactory.h"
-#include "DBusXapianIndex.h"
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-using std::set;
-using std::map;
-using std::min;
-
-const char *g_fieldNames[] = { "caption", "url", "type", "language", "modtime", "size", NULL };
-
-static DBusGConnection *getBusConnection(void)
-{
-	GError *pError = NULL;
-	DBusGConnection *pBus = NULL;
-
-	pBus = dbus_g_bus_get(DBUS_BUS_SESSION, &pError);
-	if (pBus == NULL)
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex: couldn't connect to session bus: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	return pBus;
-}
-
-static DBusGProxy *getBusProxy(DBusGConnection *pBus)
-{
-	if (pBus == NULL)
-	{
-		return NULL;
-	}
-
-	return dbus_g_proxy_new_for_name(pBus,
-		"de.berlios.Pinot", "/de/berlios/Pinot", "de.berlios.Pinot");
-}
-
-DBusXapianIndex::DBusXapianIndex(const string &indexName) :
-	XapianIndex(indexName)
-{
-}
-
-DBusXapianIndex::DBusXapianIndex(const DBusXapianIndex &other) :
-	XapianIndex(other)
-{
-}
-
-DBusXapianIndex::~DBusXapianIndex()
-{
-}
-
-DBusXapianIndex &DBusXapianIndex::operator=(const DBusXapianIndex &other)
-{
-	if (this != &other)
-	{
-		XapianIndex::operator=(other);
-	}
-
-	return *this;
-}
-
-void DBusXapianIndex::reopen(void) const
-{
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase != NULL)
-	{
-		// Re-open the database to the latest available version
-		pDatabase->reopen();
-#ifdef DEBUG
-		cout << "DBusXapianIndex::reopen: done" << endl;
-#endif
-	}
-}
-
-/// Extracts docId and docInfo from a dbus message.
-bool DBusXapianIndex::documentInfoFromDBus(DBusMessageIter *iter, unsigned int &docId,
-	DocumentInfo &docInfo)
-{
-	DBusMessageIter array_iter;
-	DBusMessageIter struct_iter;
-
-	if (iter == NULL)
-	{
-		return false;
-	}
-
-	int type = dbus_message_iter_get_arg_type(iter);
-	if (type != DBUS_TYPE_UINT32)
-	{
-#ifdef DEBUG
-		cout << "DBusXapianIndex::documentInfoFromDBus: expected unsigned integer, got " << type << endl;
-#endif
-		return false;
-	}
-	dbus_message_iter_get_basic(iter, &docId);
-	dbus_message_iter_next(iter);
-	
-	type = dbus_message_iter_get_arg_type(iter);
-	if (type != DBUS_TYPE_ARRAY)
-	{
-#ifdef DEBUG
-		cout << "DBusXapianIndex::documentInfoFromDBus: expected array, got " << type << endl;
-#endif
-		return false;
-	}
-	dbus_message_iter_recurse(iter, &array_iter);
-
-	do
-	{
-		const gchar *pName = NULL;
-		const gchar *pValue = NULL;
-
-		type = dbus_message_iter_get_arg_type(&array_iter);
-		if (type != DBUS_TYPE_STRUCT)
-		{
-#ifdef DEBUG
-			cout << "DBusXapianIndex::documentInfoFromDBus: expected struct, got " << type << endl;
-#endif
-			return false;
-		}
-
-		dbus_message_iter_recurse(&array_iter, &struct_iter);
-		dbus_message_iter_get_basic(&struct_iter, &pName);
-		if (pName == NULL)
-		{
-#ifdef DEBUG
-			cout << "DBusXapianIndex::documentInfoFromDBus: invalid field name" << endl;
-#endif
-		}
-
-		dbus_message_iter_next(&struct_iter);
-		dbus_message_iter_get_basic(&struct_iter, &pValue);
-		if (pValue == NULL)
-		{
-#ifdef DEBUG
-			cout << "DBusXapianIndex::documentInfoFromDBus: invalid field value" << endl;
-#endif
-			continue;
-		}
-#ifdef DEBUG
-		cout << "DBusXapianIndex::documentInfoFromDBus: field " << pName << "=" << pValue << endl;
-#endif
-
-		// Populate docInfo
-		string fieldName(pName);
-		if (fieldName == g_fieldNames[0])
-		{
-			docInfo.setTitle(pValue);
-		}
-		else if (fieldName == g_fieldNames[1])
-		{
-			docInfo.setLocation(pValue);
-		}
-		else if (fieldName == g_fieldNames[2])
-		{
-			docInfo.setType(pValue);
-		}
-		else if (fieldName == g_fieldNames[3])
-		{
-			docInfo.setLanguage(Languages::toLocale(pValue));
-		}
-		else if (fieldName == g_fieldNames[4])
-		{
-			docInfo.setTimestamp(pValue);
-		}
-		else if (fieldName == g_fieldNames[5])
-		{
-			docInfo.setSize((off_t )atoi(pValue));
-		}
-	}
-	while (dbus_message_iter_next(&array_iter));
-
-	return true;
-}
-
-/// Converts docId and docInfo to a dbus message.
-bool DBusXapianIndex::documentInfoToDBus(DBusMessageIter *iter, unsigned int docId,
-	const DocumentInfo &docInfo)
-{
-        DBusMessageIter array_iter;
-	DBusMessageIter struct_iter;
-
-	if (iter == NULL)
-	{
-		return false;
-	}
-
-	// Append the document ID ?
-	if (docId != 0)
-	{
-		dbus_message_iter_append_basic(iter, DBUS_TYPE_UINT32, &docId);
-	}
-	if (!dbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,
-		DBUS_STRUCT_BEGIN_CHAR_AS_STRING \
-		DBUS_TYPE_STRING_AS_STRING \
-		DBUS_TYPE_STRING_AS_STRING \
-		DBUS_STRUCT_END_CHAR_AS_STRING, &array_iter))
-	{
-#ifdef DEBUG
-		cout << "DBusXapianIndex::documentInfoToDBus: couldn't open array container" << endl;
-#endif
-		return false;
-	}
-
-	for (unsigned int fieldNum = 0; g_fieldNames[fieldNum] != NULL; ++fieldNum)
-	{
-		const char *pValue = NULL;
-		char sizeStr[64];
-
-		if (!dbus_message_iter_open_container(&array_iter,
-			DBUS_TYPE_STRUCT, NULL, &struct_iter))
-		{
-#ifdef DEBUG
-			cout << "DBusXapianIndex::documentInfoToDBus: couldn't open struct container" << endl;
-#endif
-			return false;
-		}
-
-		dbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_STRING, &g_fieldNames[fieldNum]);
-		switch (fieldNum)
-		{
-			case 0:
-				pValue = docInfo.getTitle().c_str();
-				break;
-			case 1:
-				pValue = docInfo.getLocation().c_str();
-				break;
-			case 2:
-				pValue = docInfo.getType().c_str();
-				break;
-			case 3:
-				pValue = Languages::toEnglish(docInfo.getLanguage()).c_str();
-				break;
-			case 4:
-				pValue = docInfo.getTimestamp().c_str();
-				break;
-			case 5:
-			default:
-				snprintf(sizeStr, 64, "%u", docInfo.getSize());
-				pValue = sizeStr;
-				break;
-		}
-		dbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_STRING, &pValue);
-#ifdef DEBUG
-		cout << "DBusXapianIndex::documentInfoToDBus: field " << g_fieldNames[fieldNum] << "=" << pValue << endl;
-#endif
-
-		if (!dbus_message_iter_close_container(&array_iter, &struct_iter))
-		{
-#ifdef DEBUG
-			cout << "DBusXapianIndex::documentInfoToDBus: couldn't close struct container" << endl;
-#endif
-			return false;
-		}
-	}
-
-	if (!dbus_message_iter_close_container(iter, &array_iter))
-	{
-#ifdef DEBUG
-		cout << "DBusXapianIndex::documentInfoToDBus: couldn't close array container" << endl;
-#endif
-		return false;
-	}
-
-	return true;
-}
-
-/// Asks the D-Bus service to reload its configuration.
-bool DBusXapianIndex::reload(void)
-{
-	gboolean reloading = FALSE;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::reload: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	if (dbus_g_proxy_call(pBusProxy, "Reload", &pError,
-		G_TYPE_INVALID,
-		G_TYPE_BOOLEAN, &reloading,
-		G_TYPE_INVALID) == FALSE)
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::reload: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	if (reloading == TRUE)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-
-//
-// Implementation of IndexInterface
-//
-
-/// Sets the version number.
-bool DBusXapianIndex::setVersion(const string &version) const
-{
-	cerr << "DBusXapianIndex::setVersion: not allowed" << endl;
-	return false;
-}
-
-/// Returns a document's properties.
-bool DBusXapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentInfo(docId, docInfo);
-}
-
-/// Returns a document's terms count.
-unsigned int DBusXapianIndex::getDocumentTermsCount(unsigned int docId) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentTermsCount(docId);
-}
-
-/// Returns a document's terms.
-bool DBusXapianIndex::getDocumentTerms(unsigned int docId,
-	map<unsigned int, string> &wordsBuffer) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentTerms(docId, wordsBuffer);
-}
-
-/// Sets the list of known labels.
-bool DBusXapianIndex::setLabels(const set<string> &labels)
-{
-	// Not allowed here
-	return false;
-}
-
-/// Gets the list of known labels.
-bool DBusXapianIndex::getLabels(set<string> &labels) const
-{
-	reopen();
-
-	return XapianIndex::getLabels(labels);
-}
-
-/// Gets the list of known labels.
-bool DBusXapianIndex::getLabels(set<string> &labels, bool forceDBus) const
-{
-	bool gotLabels = false;
-
-	if (forceDBus == false)
-	{
-		// Call overload
-		return getLabels(labels);
-	}
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::getLabels: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	char **pLabels;
-
-	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
-	if (dbus_g_proxy_call(pBusProxy, "GetLabels", &pError,
-		G_TYPE_INVALID,
-		G_TYPE_STRV, &pLabels,
-		G_TYPE_INVALID) == TRUE)
-	{
-		for (char **pLabel = pLabels; (*pLabel) != NULL; ++pLabel)
-		{
-			labels.insert(*pLabel);
-		}
-
-		// Free the array
-		g_strfreev(pLabels);
-
-		gotLabels = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::getLabels: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return gotLabels;
-}
-
-/// Adds a label.
-bool DBusXapianIndex::addLabel(const string &name)
-{
-	bool addedLabel = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::addLabel: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	const char *pLabel = name.c_str();
-
-	if (dbus_g_proxy_call(pBusProxy, "AddLabel", &pError,
-		G_TYPE_STRING, pLabel,
-		G_TYPE_INVALID,
-		G_TYPE_STRING, &pLabel,
-		G_TYPE_INVALID) == TRUE)
-	{
-		addedLabel = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::addLabel: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return addedLabel;
-}
-
-/// Renames a label.
-bool DBusXapianIndex::renameLabel(const string &name, const string &newName)
-{
-	bool renamedLabel = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::renameLabel: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	const char *pOldLabel = name.c_str();
-	const char *pNewLabel = newName.c_str();
-
-	if (dbus_g_proxy_call(pBusProxy, "RenameLabel", &pError,
-		G_TYPE_STRING, pOldLabel,
-		G_TYPE_STRING, pNewLabel,
-		G_TYPE_INVALID,
-		G_TYPE_STRING, &pNewLabel,
-		G_TYPE_INVALID) == TRUE)
-	{
-		renamedLabel = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::renameLabel: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return renamedLabel;
-}
-
-/// Deletes all references to a label.
-bool DBusXapianIndex::deleteLabel(const string &name)
-{
-	bool deletedLabel = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::deleteLabel: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	const char *pLabel = name.c_str();
-
-	if (dbus_g_proxy_call(pBusProxy, "DeleteLabel", &pError,
-		G_TYPE_STRING, pLabel,
-		G_TYPE_INVALID,
-		G_TYPE_STRING, &pLabel,
-		G_TYPE_INVALID) == TRUE)
-	{
-		deletedLabel = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::deleteLabel: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return deletedLabel;
-}
-
-/// Determines whether a document has a label.
-bool DBusXapianIndex::hasLabel(unsigned int docId, const string &name) const
-{
-	reopen();
-
-	return XapianIndex::hasLabel(docId, name);
-}
-
-/// Returns a document's labels.
-bool DBusXapianIndex::getDocumentLabels(unsigned int docId, set<string> &labels) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentLabels(docId, labels);
-}
-
-/// Returns a document's labels.
-bool DBusXapianIndex::getDocumentLabels(unsigned int docId, set<string> &labels, bool forceDBus) const
-{
-	bool gotLabels = false;
-
-	if (forceDBus == false)
-	{
-		// Call overload
-		return getDocumentLabels(docId, labels);
-	}
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::getDocumentLabels: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	char **pLabels;
-
-	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
-	if (dbus_g_proxy_call(pBusProxy, "GetDocumentLabels", &pError,
-		G_TYPE_UINT, docId,
-		G_TYPE_INVALID,
-		G_TYPE_STRV, &pLabels,
-		G_TYPE_INVALID) == TRUE)
-	{
-		for (char **pLabel = pLabels; (*pLabel) != NULL; ++pLabel)
-		{
-			labels.insert(*pLabel);
-		}
-
-		// Free the array
-		g_strfreev(pLabels);
-
-		gotLabels = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::getDocumentLabels: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return gotLabels;
-}
-
-/// Sets a document's labels.
-bool DBusXapianIndex::setDocumentLabels(unsigned int docId, const set<string> &labels,
-	bool resetLabels)
-{
-	bool updatedLabels = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::setDocumentLabels: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	dbus_uint32_t labelsCount = labels.size();
-	char **pLabels;
-	unsigned int labelIndex = 0;
-
-	pLabels = g_new(char *, labelsCount + 1);
-	for (set<string>::const_iterator labelIter = labels.begin();
-		labelIter != labels.end(); ++labelIter)
-	{
-		pLabels[labelIndex] = g_strdup(labelIter->c_str());
-		++labelIndex;
-	}
-	pLabels[labelIndex] = NULL;
-
-	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
-	if (dbus_g_proxy_call(pBusProxy, "SetDocumentLabels", &pError,
-		G_TYPE_UINT, docId,
-		G_TYPE_STRV, pLabels,
-		G_TYPE_BOOLEAN, (resetLabels == true ? TRUE : FALSE),
-		G_TYPE_INVALID,
-		G_TYPE_UINT, &docId,
-		G_TYPE_INVALID) == TRUE)
-	{
-		updatedLabels = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::setDocumentLabels: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	// Free the array
-	g_strfreev(pLabels);
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return updatedLabels;
-}
-
-/// Sets documents' labels.
-bool DBusXapianIndex::setDocumentsLabels(const set<unsigned int> &docIds,
-	const set<string> &labels, bool resetLabels)
-{
-	gboolean updatedLabels = FALSE;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::setDocumentsLabels: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	dbus_uint32_t idsCount = docIds.size();
-	dbus_uint32_t labelsCount = labels.size();
-	char **pDocIds;
-	char **pLabels;
-	unsigned int idIndex = 0, labelIndex = 0;
-
-	pDocIds = g_new(char *, idsCount + 1);
-	pLabels = g_new(char *, labelsCount + 1);
-	for (set<unsigned int>::const_iterator idIter = docIds.begin();
-		idIter != docIds.end(); ++idIter)
-	{
-		pDocIds[idIndex] = g_strdup_printf("%u", *idIter); 
-#ifdef DEBUG
-		cout << "DBusXapianIndex::setDocumentsLabels: document " << pDocIds[idIndex] << endl;
-#endif
-		++idIndex;
-	}
-	pDocIds[idIndex] = NULL;
-	for (set<string>::const_iterator labelIter = labels.begin();
-		labelIter != labels.end(); ++labelIter)
-	{
-		pLabels[labelIndex] = g_strdup(labelIter->c_str());
-#ifdef DEBUG
-		cout << "DBusXapianIndex::setDocumentsLabels: label " << pLabels[labelIndex] << endl;
-#endif
-		++labelIndex;
-	}
-	pLabels[labelIndex] = NULL;
-
-	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
-	if (dbus_g_proxy_call(pBusProxy, "SetDocumentsLabels", &pError,
-		G_TYPE_STRV, pDocIds,
-		G_TYPE_STRV, pLabels,
-		G_TYPE_BOOLEAN, (resetLabels == true ? TRUE : FALSE),
-		G_TYPE_INVALID,
-		G_TYPE_BOOLEAN, &updatedLabels,
-		G_TYPE_INVALID) == FALSE)
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::setDocumentsLabels: " << pError->message << endl;
-			g_error_free(pError);
-		}
-		updatedLabels = FALSE;
-	}
-
-	// Free the arrays
-	g_strfreev(pDocIds);
-	g_strfreev(pLabels);
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	if (updatedLabels == TRUE)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-/// Checks whether the given URL is in the index.
-unsigned int DBusXapianIndex::hasDocument(const string &url) const
-{
-	reopen();
-
-	return XapianIndex::hasDocument(url);
-}
-
-/// Gets terms with the same root.
-unsigned int DBusXapianIndex::getCloseTerms(const string &term, set<string> &suggestions)
-{
-	reopen();
-
-	return XapianIndex::getCloseTerms(term, suggestions);
-}
-
-/// Returns the ID of the last document.
-unsigned int DBusXapianIndex::getLastDocumentID(void) const
-{
-	reopen();
-
-	return XapianIndex::getLastDocumentID();
-}
-
-/// Returns the number of documents.
-unsigned int DBusXapianIndex::getDocumentsCount(const string &labelName) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentsCount(labelName);
-}
-
-/// Lists documents.
-unsigned int DBusXapianIndex::listDocuments(set<unsigned int> &docIds,
-	unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	reopen();
-
-	return XapianIndex::listDocuments(docIds, maxDocsCount, startDoc);
-}
-
-/// Lists documents.
-bool DBusXapianIndex::listDocuments(const string &name, set<unsigned int> &docIds,
-	NameType type, unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	reopen();
-
-	return XapianIndex::listDocuments(name, docIds, type, maxDocsCount, startDoc);
-}
-
-/// Indexes the given data.
-bool DBusXapianIndex::indexDocument(const Document &doc, const set<string> &labels,
-	unsigned int &docId)
-{
-	cerr << "DBusXapianIndex::indexDocument: not allowed" << endl;
-	return false;
-}
-
-/// Updates the given document; true if success.
-bool DBusXapianIndex::updateDocument(unsigned int docId, const Document &doc)
-{
-	bool updated = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::updateDocument: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	if (dbus_g_proxy_call(pBusProxy, "UpdateDocument", &pError,
-		G_TYPE_UINT, docId,
-		G_TYPE_INVALID,
-		G_TYPE_UINT, &docId,
-		G_TYPE_INVALID) == TRUE)
-	{
-		updated = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::updateDocument: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return updated;
-}
-
-/// Updates a document's properties.
-bool DBusXapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo)
-{
-	DBusMessageIter iter;
-	bool updated = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	// FIXME: AFAIK we can't use DBusGProxy with message iterators
-	DBusMessage *pMsg = dbus_message_new_method_call("de.berlios.Pinot",
-		"/de/berlios/Pinot", "de.berlios.Pinot", "SetDocumentInfo");
-	if (pMsg == NULL)
-	{
-		cerr << "DBusXapianIndex::updateDocumentInfo: couldn't call method" << endl;
-		return false;
-	}
-
-	dbus_message_iter_init_append(pMsg, &iter);
-	if (DBusXapianIndex::documentInfoToDBus(&iter, docId, docInfo) == false)
-	{
-		dbus_message_unref(pMsg);
-	}
-	else
-	{
-		DBusError err;
-
-		dbus_error_init(&err);
-		DBusMessage *pReply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(pBus),
-			pMsg, 1000 * 10, &err);
-		dbus_message_unref(pMsg);
-
-		if (dbus_error_is_set(&err))
-		{
-			cerr << "DBusXapianIndex::updateDocumentInfo: " << err.message << endl;
-			dbus_error_free(&err);
-			return false;
-		}
-
-		if (pReply != NULL)
-		{
-			dbus_message_get_args(pReply, NULL,
-				DBUS_TYPE_UINT32, &docId,
-				DBUS_TYPE_INVALID);
-			updated = true;
-
-			dbus_message_unref(pReply);
-		}
-	}
-
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return updated;
-}
-
-/// Unindexes the given document; true if success.
-bool DBusXapianIndex::unindexDocument(unsigned int docId)
-{
-	cerr << "DBusXapianIndex::unindexDocument: not allowed" << endl;
-	return false;
-}
-
-/// Unindexes documents.
-bool DBusXapianIndex::unindexDocuments(const string &name, NameType type)
-{
-	cerr << "DBusXapianIndex::unindexDocuments: not allowed" << endl;
-	return false;
-}
-
-/// Unindexes all documents.
-bool DBusXapianIndex::unindexAllDocuments(void)
-{
-	cerr << "DBusXapianIndex::unindexDocuments: not allowed" << endl;
-	return false;
-}
-
-/// Flushes recent changes to the disk.
-bool DBusXapianIndex::flush(void)
-{
-	// The daemon knows best when to flush
-	return true;
-}
-
-/// Resets the index.
-bool DBusXapianIndex::reset(void)
-{
-	// This can't be done here
-	return false;
-}
-

Deleted: trunk/Index/DBusXapianIndex.h
===================================================================
--- trunk/Index/DBusXapianIndex.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/DBusXapianIndex.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,158 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _DBUS_XAPIAN_INDEX_H
-#define _DBUS_XAPIAN_INDEX_H
-
-#include <string>
-#include <set>
-#include <map>
-#include "config.h"
-extern "C"
-{
-#if DBUS_VERSION < 1000000
-#define DBUS_API_SUBJECT_TO_CHANGE
-#endif
-#include <dbus/dbus.h>
-#include <dbus/dbus-glib.h>
-#include <dbus/dbus-glib-lowlevel.h>
-}
-
-#include "XapianIndex.h"
-
-/// Allows to write to the daemon index via D-Bus. 
-class DBusXapianIndex : public XapianIndex
-{
-	public:
-		DBusXapianIndex(const std::string &indexName);
-		DBusXapianIndex(const DBusXapianIndex &other);
-		virtual ~DBusXapianIndex();
-
-		DBusXapianIndex &operator=(const DBusXapianIndex &other);
-
-		/// Extracts docId and docInfo from a dbus message.
-		static bool documentInfoFromDBus(DBusMessageIter *iter, unsigned int &docId,
-			DocumentInfo &docInfo);
-
-		/// Converts docId and docInfo to a dbus message.
-		static bool documentInfoToDBus(DBusMessageIter *iter, unsigned int docId,
-			const DocumentInfo &docInfo);
-
-		/// Asks the D-Bus service to reload its configuration.
-		static bool reload(void);
-
-		/// Sets the version number.
-		virtual bool setVersion(const std::string &version) const;
-
-		/// Returns a document's properties.
-		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const;
-
-		/// Returns a document's terms count.
-		virtual unsigned int getDocumentTermsCount(unsigned int docId) const;
-
-		/// Returns a document's terms.
-		virtual bool getDocumentTerms(unsigned int docId,
-			std::map<unsigned int, std::string> &wordsBuffer) const;
-
-		/// Sets the list of known labels.
-		virtual bool setLabels(const std::set<std::string> &labels);
-
-		/// Gets the list of known labels.
-		virtual bool getLabels(std::set<std::string> &labels) const;
-
-		/// Gets the list of known labels.
-		bool getLabels(std::set<std::string> &labels, bool forceDBus) const;
-
-		/// Adds a label.
-		virtual bool addLabel(const std::string &name);
-
-		/// Renames a label.
-		virtual bool renameLabel(const std::string &name, const std::string &newName);
-
-		/// Deletes all references to a label.
-		virtual bool deleteLabel(const std::string &name);
-
-		/// Determines whether a document has a label.
-		virtual bool hasLabel(unsigned int docId, const std::string &name) const;
-
-		/// Returns a document's labels.
-		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const;
-
-		/// Returns a document's labels.
-		bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels,
-			bool forceDBus) const;
-
-		/// Sets a document's labels.
-		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
-			bool resetLabels = true);
-
-		/// Sets documents' labels.
-		virtual bool setDocumentsLabels(const std::set<unsigned int> &docIds,
-			const std::set<std::string> &labels, bool resetLabels = true);
-
-		/// Checks whether the given URL is in the index.
-		virtual unsigned int hasDocument(const std::string &url) const;
-
-		/// Gets terms with the same root.
-		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions);
-
-		/// Returns the ID of the last document.
-		virtual unsigned int getLastDocumentID(void) const;
-
-		/// Returns the number of documents.
-		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const;
-
-		/// Lists documents.
-		virtual unsigned int listDocuments(std::set<unsigned int> &docIDList,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		/// Lists documents.
-		virtual bool listDocuments(const std::string &name, std::set<unsigned int> &docIds,
-			NameType type, unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		/// Indexes the given data.
-		virtual bool indexDocument(const Document &doc, const std::set<std::string> &labels,
-			unsigned int &docId);
-
-		/// Updates the given document.
-		virtual bool updateDocument(unsigned int docId, const Document &doc);
-
-		/// Updates a document's properties.
-		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo);
-
-		/// Unindexes the given document.
-		virtual bool unindexDocument(unsigned int docId);
-
-		/// Unindexes documents.
-		virtual bool unindexDocuments(const std::string &name, NameType type);
-
-		/// Unindexes all documents.
-		virtual bool unindexAllDocuments(void);
-
-		/// Flushes recent changes to the disk.
-		virtual bool flush(void);
-
-		/// Resets the index.
-		virtual bool reset(void);
-
-	protected:
-		void reopen(void) const;
-
-};
-
-#endif // _DBUS_XAPIAN_INDEX_H

Deleted: trunk/Index/FilterWrapper.cpp
===================================================================
--- trunk/Index/FilterWrapper.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/FilterWrapper.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,219 +0,0 @@
-/*
- *  Copyright 2007 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <time.h>
-#include <iostream>
-
-#include "Url.h"
-#include "FilterFactory.h"
-#include "TextFilter.h"
-#include "FilterUtils.h"
-#include "FilterWrapper.h"
-
-using std::cout;
-using std::endl;
-using std::string;
-using std::set;
-using namespace Dijon;
-
-FilterWrapper::FilterWrapper(IndexInterface *pIndex) :
-	m_pIndex(pIndex)
-{
-}
-
-FilterWrapper::~FilterWrapper()
-{
-}
-
-bool FilterWrapper::indexDocument(const Document &doc, const set<string> &labels, unsigned int &docId)
-{
-	string originalType(doc.getType());
-
-	if (m_pIndex == NULL)
-	{
-		return false;
-	}
-
-	unindexNestedDocuments(doc.getLocation());
-
-	return filterDocument(doc, originalType, labels, docId, false);
-}
-
-bool FilterWrapper::updateDocument(const Document &doc, unsigned int docId)
-{
-	set<string> labels;
-	string originalType(doc.getType());
-
-	if (m_pIndex == NULL)
-	{
-		return false;
-	}
-
-	unindexNestedDocuments(doc.getLocation());
-
-	return filterDocument(doc, originalType, labels, docId, true);
-}
-
-bool FilterWrapper::unindexDocument(const string &location)
-{
-	if (m_pIndex == NULL)
-	{
-		return false;
-	}
-
-	unindexNestedDocuments(location);
-
-	return m_pIndex->unindexDocument(location);
-}
-
-bool FilterWrapper::filterDocument(const Document &doc, const string &originalType,
-	const set<string> &labels, unsigned int &docId, bool doUpdate)
-{
-	Filter *pFilter = FilterUtils::getFilter(doc.getType());
-	bool fedFilter = false, docSuccess = false, finalSuccess = false;
-
-	if (pFilter != NULL)
-	{
-		fedFilter = FilterUtils::feedFilter(doc, pFilter);
-	}
-	else
-	{
-		// Chances are this type is not supported
-		pFilter = new TextFilter("text/plain");
-
-		Document emptyDoc(doc.getTitle(), doc.getLocation(), doc.getType(), doc.getLanguage());
-
-		emptyDoc.setTimestamp(doc.getTimestamp());
-		emptyDoc.setSize(doc.getSize());
-		emptyDoc.setData(" ", 1);
-
-#ifdef DEBUG
-		cout << "FilterWrapper::filterDocument: unsupported type " << doc.getType() << endl;
-#endif
-		fedFilter = FilterUtils::feedFilter(emptyDoc, pFilter);
-	}
-
-	if (fedFilter == false)
-	{
-		delete pFilter;
-
-		return false;
-	}
-
-	while (pFilter->has_documents() == true)
-	{
-		string actualType(originalType);
-		bool isNested = false;
-
-		if (pFilter->next_document() == false)
-		{
-#ifdef DEBUG
-			cout << "FilterWrapper::filterDocument: no more documents in " << doc.getLocation() << endl;
-#endif
-			break;
-		}
-
-		string originalTitle(doc.getTitle());
-		Document filteredDoc(originalTitle, doc.getLocation(), "text/plain", doc.getLanguage());
-
-		filteredDoc.setTimestamp(doc.getTimestamp());
-		filteredDoc.setSize(doc.getSize());
-		docSuccess = false;
-
-		if (FilterUtils::populateDocument(filteredDoc, pFilter) == false)
-		{
-			continue;
-		}
-
-		// Is this a nested document ?
-		if (filteredDoc.getLocation().length() > doc.getLocation().length())
-		{
-			actualType = filteredDoc.getType();
-#ifdef DEBUG
-			cout << "FilterWrapper::filterDocument: nested document of type " << actualType << endl;
-#endif
-			isNested = true;
-		}
-		else if (originalTitle.empty() == false)
-		{
-			// Preserve the top-level document's title
-			filteredDoc.setTitle(originalTitle);
-		}
-		else if (filteredDoc.getTitle().empty() == true)
-		{
-			Url urlObj(doc.getLocation());
-
-			// Default to the file name as title
-			filteredDoc.setTitle(urlObj.getFile());
-#ifdef DEBUG
-			cout << "FilterWrapper::filterDocument: set default title " << urlObj.getFile() << endl;
-#endif
-		}
-
-		// Pass it down to another filter ?
-		if ((filteredDoc.getType().length() >= 10) &&
-			(filteredDoc.getType().substr(0, 10) == "text/plain"))
-		{
-			// No, it's been reduced to plain text
-			filteredDoc.setType(actualType);
-
-			// Nested documents can't be updated because they are unindexed
-			// and the ID is that of the base document anyway
-			if ((doUpdate == true) &&
-				(isNested == false))
-			{
-				docSuccess = m_pIndex->updateDocument(docId, filteredDoc);
-			}
-			else
-			{
-				unsigned int newDocId = docId;
-
-				docSuccess = m_pIndex->indexDocument(filteredDoc, labels, newDocId);
-				// Make sure we return the base document's ID, not the last nested document's ID
-				if (isNested == false)
-				{
-					docId = newDocId;
-				}
-			}
-		}
-		else
-		{
-			docSuccess = filterDocument(filteredDoc, actualType, labels, docId, doUpdate);
-		}
-
-		// Consider indexing anything a success
-		if (docSuccess == true)
-		{
-			finalSuccess = true;
-		}
-	}
-
-	delete pFilter;
-
-#ifdef DEBUG
-	cout << "FilterWrapper::filterDocument: done with " << doc.getLocation() << " status " << finalSuccess << endl;
-#endif
-
-	return finalSuccess;
-}
-
-bool FilterWrapper::unindexNestedDocuments(const string &url)
-{
-	// Unindex all documents that stem from this file
-	return m_pIndex->unindexDocuments(url, IndexInterface::BY_FILE);
-}

Deleted: trunk/Index/FilterWrapper.h
===================================================================
--- trunk/Index/FilterWrapper.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/FilterWrapper.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,62 +0,0 @@
-/*
- *  Copyright 2007 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _FILTER_WRAPPER_H
-#define _FILTER_WRAPPER_H
-
-#include <string>
-#include <set>
-
-#include "Document.h"
-#include "Filter.h"
-#include "IndexInterface.h"
-
-/// A wrapper around Dijon filters.
-class FilterWrapper
-{
-	public:
-		/// Builds a FilterWrapper object.
-		FilterWrapper(IndexInterface *pIndex);
-		virtual ~FilterWrapper();
-
-		/// Indexes the given data.
-		bool indexDocument(const Document &doc, const std::set<std::string> &labels,
-			unsigned int &docId);
-
-		/// Updates the given document.
-		bool updateDocument(const Document &doc, unsigned int docId);
-
-		/// Unindexes document(s) at the given location.
-		bool unindexDocument(const std::string &location);
-
-	protected:
-		IndexInterface *m_pIndex;
-
-		bool filterDocument(const Document &doc, const std::string &originalType,
-			const std::set<std::string> &labels, unsigned int &docId,
-			bool doUpdate);
-
-		bool unindexNestedDocuments(const std::string &url);
-
-	private:
-		FilterWrapper(const FilterWrapper &other);
-		FilterWrapper &operator=(const FilterWrapper &other);
-
-};
-
-#endif // _FILTER_WRAPPER_H

Deleted: trunk/Index/IndexFactory.cpp
===================================================================
--- trunk/Index/IndexFactory.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/IndexFactory.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,50 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include "XapianIndex.h"
-#include "DBusXapianIndex.h"
-#include "IndexFactory.h"
-
-using std::string;
-
-IndexFactory::IndexFactory()
-{
-}
-
-IndexFactory::~IndexFactory()
-{
-}
-
-/// Returns an index of the specified type; NULL if unavailable.
-IndexInterface *IndexFactory::getIndex(const string &type, const string &option)
-{
-	IndexInterface *pIndex = NULL;
-
-	// Choice by type
-	if (type == "dbus")
-	{
-		pIndex = new DBusXapianIndex(option);
-	}
-	else if (type == "xapian")
-	{
-		pIndex = new XapianIndex(option);
-	}
-
-	return pIndex;
-}
-

Deleted: trunk/Index/IndexFactory.h
===================================================================
--- trunk/Index/IndexFactory.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/IndexFactory.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,44 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _INDEX_FACTORY_H
-#define _INDEX_FACTORY_H
-
-#include <string>
-
-#include "IndexInterface.h"
-
-/// Factory for indexes.
-class IndexFactory
-{
-	public:
-		virtual ~IndexFactory();
-
-		/// Returns an index of the specified type; NULL if unavailable.
-		static IndexInterface *getIndex(const std::string &type, const std::string &option);
-
-	protected:
-		IndexFactory();
-
-	private:
-		IndexFactory(const IndexFactory &other);
-		IndexFactory &operator=(const IndexFactory &other);
-
-};
-
-#endif // _INDEX_FACTORY_H

Deleted: trunk/Index/IndexInterface.h
===================================================================
--- trunk/Index/IndexInterface.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/IndexInterface.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,141 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
- 
-#ifndef _INDEX_INTERFACE_H
-#define _INDEX_INTERFACE_H
-
-#include <string>
-#include <set>
-#include <map>
-
-#include "Document.h"
-
-/// Interface implemented by indexes.
-class IndexInterface
-{
-	public:
-		IndexInterface(const IndexInterface &other) {};
-		virtual ~IndexInterface() {};
-
-		typedef enum { BY_LABEL = 0, BY_DIRECTORY, BY_FILE } NameType;
-
-		/// Returns false if the index couldn't be opened.
-		virtual bool isGood(void) const = 0;
-
-		/// Gets the version number.
-		virtual std::string getVersion(void) const = 0;
-
-		/// Sets the version number.
-		virtual bool setVersion(const std::string &version) const = 0;
-
-		/// Gets the index location.
-		virtual std::string getLocation(void) const = 0;
-
-		/// Returns a document's properties.
-		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const = 0;
-
-		/// Returns a document's terms count.
-		virtual unsigned int getDocumentTermsCount(unsigned int docId) const = 0;
-
-		/// Returns a document's terms.
-		virtual bool getDocumentTerms(unsigned int docId,
-			std::map<unsigned int, std::string> &wordsBuffer) const = 0;
-
-		/// Sets the list of known labels.
-		virtual bool setLabels(const std::set<std::string> &labels) = 0;
-
-		/// Gets the list of known labels.
-		virtual bool getLabels(std::set<std::string> &labels) const = 0;
-
-		/// Adds a label.
-		virtual bool addLabel(const std::string &name) = 0;
-
-		/// Renames a label.
-		virtual bool renameLabel(const std::string &name, const std::string &newName) = 0;
-
-		/// Deletes all references to a label.
-		virtual bool deleteLabel(const std::string &name) = 0;
-
-		/// Determines whether a document has a label.
-		virtual bool hasLabel(unsigned int docId, const std::string &name) const = 0;
-
-		/// Returns a document's labels.
-		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const = 0;
-
-		/// Sets a document's labels.
-		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
-			bool resetLabels = true) = 0;
-
-		/// Sets documents' labels.
-		virtual bool setDocumentsLabels(const std::set<unsigned int> &docIds,
-			const std::set<std::string> &labels, bool resetLabels = true) = 0;
-
-		/// Checks whether the given URL is in the index.
-		virtual unsigned int hasDocument(const std::string &url) const = 0;
-
-		/// Gets terms with the same root.
-		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions) = 0;
-
-		/// Returns the ID of the last document.
-		virtual unsigned int getLastDocumentID(void) const = 0;
-
-		/// Returns the number of documents.
-		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const = 0;
-
-		/// Lists documents.
-		virtual unsigned int listDocuments(std::set<unsigned int> &docIDList,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const = 0;
-
-		/// Lists documents.
-		virtual bool listDocuments(const std::string &name, std::set<unsigned int> &docIds,
-			NameType type, unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const = 0;
-
-		/// Indexes the given data.
-		virtual bool indexDocument(const Document &doc, const std::set<std::string> &labels,
-			unsigned int &docId) = 0;
-
-		/// Updates the given document.
-		virtual bool updateDocument(unsigned int docId, const Document &doc) = 0;
-
-		/// Updates a document's properties.
-		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo) = 0;
-
-		/// Unindexes the given document.
-		virtual bool unindexDocument(unsigned int docId) = 0;
-
-		/// Unindexes the given document.
-		virtual bool unindexDocument(const std::string &location) = 0;
-
-		/// Unindexes documents.
-		virtual bool unindexDocuments(const std::string &name, NameType type) = 0;
-
-		/// Unindexes all documents.
-		virtual bool unindexAllDocuments(void) = 0;
-
-		/// Flushes recent changes to the disk.
-		virtual bool flush(void) = 0;
-
-		/// Resets the index.
-		virtual bool reset(void) = 0;
-
-	protected:
-		IndexInterface() { };
-
-};
-
-#endif // _INDEX_INTERFACE_H

Deleted: trunk/Index/LanguageDetector.cpp
===================================================================
--- trunk/Index/LanguageDetector.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/LanguageDetector.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,179 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <strings.h>
-#include <sys/time.h>
-#include <iostream>
-#include <utility>
-
-#include "config.h"
-extern "C"
-{
-#ifdef HAVE_LIBTEXTCAT_TEXTCAT_H
-#include <libtextcat/textcat.h>
-#else
-#include <textcat.h>
-#endif
-}
-
-#include "StringManip.h"
-#include "Timer.h"
-#include "LanguageDetector.h"
-#include "config.h"
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-using std::vector;
-using std::min;
-
-unsigned int LanguageDetector::m_maxTextSize = 1000;
-
-LanguageDetector::LanguageDetector()
-{
-}
-
-LanguageDetector::~LanguageDetector()
-{
-}
-
-/**
-  * Attempts to guess the language.
-  * Returns a list of candidates, or "unknown" if detection failed.
-  */
-void LanguageDetector::guessLanguage(const char *pData, unsigned int dataLength,
-			std::vector<std::string> &candidates)
-{
-	string confFile(SYSCONFDIR);
-	char *textCatVersion = textcat_Version();
-#ifdef HAVE_TEXTCAT_CAT
-	const char *catResults[10];
-#endif
-
-	candidates.clear();
-
-	// What configuration file should we use ?
-	confFile += "/pinot/";
-#ifdef DEBUG
-	cout << "LanguageDetector::guessLanguage: detected " << textCatVersion << endl;
-#endif
-	if (strncasecmp(textCatVersion, "TextCat 3", 9) == 0)
-	{
-		// Version 3
-		confFile += "textcat3_conf.txt";
-	}
-	else
-	{
-		confFile += "textcat_conf.txt";
-	}
-
-	// Initialize
-	void *td = textcat_Init(confFile.c_str());
-	if (td == NULL)
-	{
-		candidates.push_back("unknown");
-		return;
-	}
-
-	// Classify
-#ifdef DEBUG
-	Timer timer;
-	timer.start();
-	cout << "LanguageDetector::guessLanguage: starting" << endl;
-#endif
-#ifdef HAVE_TEXTCAT_CAT
-	unsigned int resultNum = textcat_Cat(td, pData,
-		min(dataLength, m_maxTextSize), catResults, 10);
-	if (resultNum == 0 )
-	{
-		candidates.push_back("unknown");
-	}
-	else
-	{
-		for (unsigned int i=0; i<resultNum; ++i)
-		{
-			string language(StringManip::toLowerCase(catResults[i]));
-
-			// Remove the charset information
-			string::size_type dashPos = language.find('-');
-			if (dashPos != string::npos)
-			{
-				language.resize(dashPos);
-			}
-#ifdef DEBUG
-			cout << "LanguageDetector::guessLanguage: found language " << language << endl;
-#endif
-			candidates.push_back(language);
-		}
-	}
-#else
-	const char *languages = textcat_Classify(td, pData,
-		min(dataLength, m_maxTextSize));
-	if (languages == NULL)
-	{
-		candidates.push_back("unknown");
-	}
-	else
-	{
-		// The output will be either SHORT, or UNKNOWN or a list of languages in []
-		if ((strncasecmp(languages, "SHORT", 5) == 0) ||
-			(strncasecmp(languages, "UNKNOWN", 7) == 0))
-		{
-			candidates.push_back("unknown");
-		}
-		else
-		{
-			string languageList(languages);
-			string::size_type lastPos = 0, pos = languageList.find_first_of("[");
-
-			while (pos != string::npos)
-			{
-				++pos;
-				lastPos = languageList.find_first_of("]", pos);
-				if (lastPos == string::npos)
-				{
-					break;
-				}
-
-				string language(StringManip::toLowerCase(languageList.substr(pos, lastPos - pos)));
-				// Remove the charset information
-				string::size_type dashPos = language.find('-');
-				if (dashPos != string::npos)
-				{
-					language.resize(dashPos);
-				}
-#ifdef DEBUG
-				cout << "LanguageDetector::guessLanguage: found language " << language << endl;
-#endif
-				candidates.push_back(language);
-
-				// Next
-				pos = languageList.find_first_of("[", lastPos);
-			}
-		}
-	}
-#endif
-#ifdef DEBUG
-	cout << "LanguageDetector::guessLanguage: language guessing took "
-		<< timer.stop() << " ms" << endl;
-#endif
-
-	// Close the descriptor
-	textcat_Done(td);
-}

Deleted: trunk/Index/LanguageDetector.h
===================================================================
--- trunk/Index/LanguageDetector.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/LanguageDetector.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,48 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _LANGUAGE_DETECTOR_H
-#define _LANGUAGE_DETECTOR_H
-
-#include <string>
-#include <vector>
-
-/// Detects a document's language with libextcat.
-class LanguageDetector
-{
-	public:
-		LanguageDetector();
-		virtual ~LanguageDetector();
-
-		/**
-		  * Attempts to guess the language.
-		  * Returns a list of candidates, or "unknown" if detection failed.
-		  */
-		void guessLanguage(const char *pData, unsigned int dataLength,
-			std::vector<std::string> &candidates);
-
-	protected:
-		static unsigned int m_maxTextSize;
-
-	private:
-		LanguageDetector(const LanguageDetector &other);
-		LanguageDetector &operator=(const LanguageDetector &other);
-
-};
-
-#endif // _LANGUAGE_DETECTOR_H

Deleted: trunk/Index/XapianDatabase.cpp
===================================================================
--- trunk/Index/XapianDatabase.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/XapianDatabase.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,645 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <strings.h>
-#include <regex.h>
-#include <stdio.h>
-#include <iostream>
-
-#include "StringManip.h"
-#include "TimeConverter.h"
-#include "Url.h"
-#include "XapianDatabase.h"
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-
-// This puts a limit to terms length.
-const unsigned int XapianDatabase::m_maxTermLength = 230;
-
-XapianDatabase::XapianDatabase(const string &databaseName,
-	bool readOnly, bool overwrite) :
-	m_databaseName(databaseName),
-	m_withSpelling(true),
-	m_readOnly(readOnly),
-	m_overwrite(overwrite),
-	m_obsoleteFormat(false),
-	m_pDatabase(NULL),
-	m_isOpen(false),
-	m_merge(false),
-	m_pFirst(NULL),
-	m_pSecond(NULL)
-{
-	initializeLock();
-	openDatabase();
-}
-
-XapianDatabase::XapianDatabase(const string &databaseName, 
-	XapianDatabase *pFirst, XapianDatabase *pSecond) :
-	m_databaseName(databaseName),
-	m_withSpelling(true),
-	m_readOnly(true),
-	m_overwrite(false),
-	m_obsoleteFormat(false),
-	m_pDatabase(NULL),
-	m_isOpen(pFirst->m_isOpen),
-	m_merge(true),
-	m_pFirst(pFirst),
-	m_pSecond(pSecond)
-{
-	initializeLock();
-}
-
-XapianDatabase::XapianDatabase(const XapianDatabase &other) :
-	m_databaseName(other.m_databaseName),
-	m_withSpelling(other.m_withSpelling),
-	m_readOnly(other.m_readOnly),
-	m_overwrite(other.m_overwrite),
-	m_obsoleteFormat(other.m_obsoleteFormat),
-	m_pDatabase(NULL),
-	m_isOpen(other.m_isOpen),
-	m_merge(other.m_merge),
-	m_pFirst(other.m_pFirst),
-	m_pSecond(other.m_pSecond)
-{
-	initializeLock();
-	if (other.m_pDatabase != NULL)
-	{
-		m_pDatabase = new Xapian::Database(*other.m_pDatabase);
-	}
-}
-
-XapianDatabase::~XapianDatabase()
-{
-	if (m_pDatabase != NULL)
-	{
-		delete m_pDatabase;
-	}
-	pthread_mutex_destroy(&m_rwLock);
-#ifdef DEBUG
-	pthread_mutexattr_destroy(&m_rwLockAttr);
-#endif
-}
-
-XapianDatabase &XapianDatabase::operator=(const XapianDatabase &other)
-{
-	if (this != &other)
-	{
-		m_databaseName = other.m_databaseName;
-		m_withSpelling = other.m_withSpelling;
-		m_readOnly = other.m_readOnly;
-		m_overwrite = other.m_overwrite;
-		m_obsoleteFormat = other.m_obsoleteFormat;
-		if (m_pDatabase != NULL)
-		{
-			delete m_pDatabase;
-			m_pDatabase = NULL;
-		}
-		if (other.m_pDatabase != NULL)
-		{
-			m_pDatabase = new Xapian::Database(*other.m_pDatabase);
-		}
-		m_isOpen = other.m_isOpen;
-		m_merge = other.m_merge;
-		m_pFirst = other.m_pFirst;
-		m_pSecond = other.m_pSecond;
-	}
-
-	return *this;
-}
-
-void XapianDatabase::initializeLock(void)
-{
-#ifdef DEBUG
-	pthread_mutexattr_init(&m_rwLockAttr);
-	pthread_mutexattr_settype(&m_rwLockAttr, PTHREAD_MUTEX_ERRORCHECK);
-	pthread_mutex_init(&m_rwLock, &m_rwLockAttr);
-#else
-	pthread_mutex_init(&m_rwLock, NULL);
-#endif
-}
-
-void XapianDatabase::openDatabase(void)
-{
-	struct stat dbStat;
-	bool createDatabase = false;
-	bool tryAgain = false;
-
-	if (m_databaseName.empty() == true)
-	{
-		return;
-	}
-
-	// Should we build the spelling database ?
-	char *pEnvVar = getenv("PINOT_SPELLING_DB");
-	if ((pEnvVar != NULL) &&
-		(strncasecmp(pEnvVar, "no", 2) == 0))
-	{
-		// No
-		m_withSpelling = false;
-	}
-	else
-	{
-		// Yes
-		m_withSpelling = true;
-	}
-
-	// Assume things will fail
-	m_isOpen = false;
-
-	if (m_pDatabase != NULL)
-	{
-		delete m_pDatabase;
-		m_pDatabase = NULL;
-	}
-
-	// Is it a remote database ?
-	string::size_type slashPos = m_databaseName.find("/");
-	string::size_type colonPos = m_databaseName.find(":");
-	if (((slashPos == string::npos) ||
-		(slashPos > 0)) &&
-		(colonPos != string::npos))
-	{
-		Url urlObj(m_databaseName);
-
-		if (m_readOnly == false)
-		{
-			cerr << "XapianDatabase::openDatabase: remote databases " << m_databaseName << " are read-only" << endl;
-			return;
-		}
-
-		if (m_databaseName.find("://") == string::npos)
-		{
-			// It's an old style remote specification without the protocol
-			urlObj = Url("tcpsrv://" + m_databaseName);
-		}
-
-		string hostName(urlObj.getHost());
-		// A port number should be included
-		colonPos = hostName.find(":");
-		if (colonPos != string::npos)
-		{
-			string protocol(urlObj.getProtocol());
-			string portStr(hostName.substr(colonPos + 1));
-			unsigned int port = (unsigned int)atoi(portStr.c_str());
-
-			hostName.resize(colonPos);
-			try
-			{
-				if (protocol == "progsrv+ssh")
-				{
-					string args("-p");
-
-					args += " ";
-					args += portStr;
-					args += " -f ";
-					args += hostName;
-					args += " xapian-progsrv /";
-					args += urlObj.getLocation();
-					args += "/";
-					args += urlObj.getFile();
-#ifdef DEBUG
-					cout << "XapianDatabase::openDatabase: remote ssh access with ssh "
-						<< args << endl;
-#endif
-					Xapian::Database remoteDatabase = Xapian::Remote::open("ssh", args);
-					m_pDatabase = new Xapian::Database(remoteDatabase);
-				}
-				else
-				{
-#ifdef DEBUG
-					cout << "XapianDatabase::openDatabase: remote database at "
-						<< hostName << " " << port << endl;
-#endif
-					Xapian::Database remoteDatabase = Xapian::Remote::open(hostName, port);
-					m_pDatabase = new Xapian::Database(remoteDatabase);
-				}
-
-				if (m_pDatabase != NULL)
-				{
-					// Stop remote databases timing out
-					m_pDatabase->keep_alive();
-					m_isOpen = true;
-				}
-
-				return;
-			}
-			catch (const Xapian::Error &error)
-			{
-				cerr << "Error opening " << m_databaseName << ": " << error.get_type()
-					<< ": " << error.get_msg() << endl;
-			}
-		}
-#ifdef DEBUG
-		else cout << "XapianDatabase::openDatabase: invalid remote database at "
-			<< hostName << "/" << urlObj.getLocation() << "/" << urlObj.getFile() << endl;
-#endif
-
-		return;
-	}
-
-	// It's a local database : the specified path must be a directory
-	if (stat(m_databaseName.c_str(), &dbStat) == -1)
-	{
-#ifdef DEBUG
-		cout << "XapianDatabase::openDatabase: database " << m_databaseName
-			<< " doesn't exist" << endl;
-#endif
-
-		// Database directory doesn't exist, create it (mode 755)
-		if (mkdir(m_databaseName.c_str(), (mode_t)S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) != 0)
-		{
-			cerr << "XapianDatabase::openDatabase: couldn't create database directory "
-				<< m_databaseName << endl;
-			return;
-		}
-		createDatabase = true;
-	}
-	else if (!S_ISDIR(dbStat.st_mode))
-	{
-		cerr << "XapianDatabase::openDatabase: " << m_databaseName
-			<< " is not a directory" << endl;
-		return;
-	}
-
-	// Try opening it now, creating if if necessary
-	try
-	{
-		if (m_readOnly == true)
-		{
-			if (createDatabase == true)
-			{
-				// We have to create the whole thing in read-write mode first
-				Xapian::WritableDatabase *pTmpDatabase = new Xapian::WritableDatabase(m_databaseName, Xapian::DB_CREATE_OR_OPEN);
-				// ...then close and open again in read-only mode
-				delete pTmpDatabase;
-			}
-
-			m_pDatabase = new Xapian::Database(m_databaseName);
-		}
-		else
-		{
-			int openAction = Xapian::DB_CREATE_OR_OPEN;
-
-			if (m_overwrite == true)
-			{
-				// An existing database will be overwritten
-				openAction = Xapian::DB_CREATE_OR_OVERWRITE;
-			}
-
-			m_pDatabase = new Xapian::WritableDatabase(m_databaseName, openAction);
-		}
-
-		if (m_pDatabase != NULL)
-		{
-#ifdef DEBUG
-			cout << "XapianDatabase::openDatabase: opened " << m_databaseName
-				<< " " << m_pDatabase->get_description() << endl;
-#endif
-			m_isOpen = true;
-		}
-
-		return;
-	}
-#if XAPIAN_MAJOR_VERSION>0
-	catch (const Xapian::DatabaseVersionError &error)
-	{
-		cerr << "Error opening " << m_databaseName << ": " << error.get_type()
-			<< ": " << error.get_msg() << endl;
-
-		// This format is no longer supported
-		if (m_obsoleteFormat == false)
-		{
-			tryAgain = true;
-		}
-	}
-#endif
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Error opening " << m_databaseName << ": " << error.get_type()
-			<< ": " << error.get_msg() << endl;
-	}
-
-	// Give it another try ?
-	if (tryAgain == true)
-	{
-		cout << "XapianDatabase::openDatabase: trying again" << endl;
-
-		m_overwrite = true;
-		m_obsoleteFormat = true;
-		openDatabase();
-	}
-}
-
-/// Returns true if the database supports spelling.
-bool XapianDatabase::withSpelling(void)
-{
-	return m_withSpelling;
-}
-
-/// Returns false if the database couldn't be opened.
-bool XapianDatabase::isOpen(void) const
-{
-	return m_isOpen;
-}
-
-/// Returns false if the database was of an obsolete format.
-bool XapianDatabase::wasObsoleteFormat(void) const
-{
-	return m_obsoleteFormat;
-}
-
-/// Reopens the database.
-void XapianDatabase::reopen(void)
-{
-	// This is provided by Xapian::Database
-	// FIXME: get the write lock to make sure read operations are not in progress ?
-	if (pthread_mutex_lock(&m_rwLock) == 0)
-	{
-		if (m_pDatabase != NULL)
-		{
-			m_pDatabase->reopen();
-		}
-
-		pthread_mutex_unlock(&m_rwLock);
-	}
-}
-
-/// Attempts to lock and retrieve the database.
-Xapian::Database *XapianDatabase::readLock(void)
-{
-	if (m_merge == false)
-	{
-		if (pthread_mutex_lock(&m_rwLock) == 0)
-		{
-			if (m_pDatabase == NULL)
-			{
-				// Try again
-				openDatabase();
-			}
-			return m_pDatabase;
-		}
-#ifdef DEBUG
-		else cout << "XapianDatabase::readLock: failed" << endl;
-#endif
-	}
-	else
-	{
-		if ((m_pFirst == NULL) ||
-			(m_pFirst->isOpen() == false) ||
-			(m_pSecond == NULL) ||
-			(m_pSecond->isOpen() == false))
-		{
-			return NULL;
-		}
-
-		if (pthread_mutex_lock(&m_rwLock) == 0)
-		{
-			// Reopen the second index
-			m_pSecond->reopen();
-
-			// Lock both indexes
-			Xapian::Database *pFirstDatabase = m_pFirst->readLock();
-			Xapian::Database *pSecondDatabase = m_pSecond->readLock();
-			// Copy the first one
-			m_pDatabase = new Xapian::Database(*pFirstDatabase);
-			// Add the second index to it
-			if (pSecondDatabase != NULL)
-			{
-				m_pDatabase->add_database(*pSecondDatabase);
-			}
-			// Until unlock() is called, both indexes are read locked
-
-			return m_pDatabase;
-		}
-#ifdef DEBUG
-		else cout << "XapianDatabase::readLock: failed" << endl;
-#endif
-	}
-
-	return NULL;
-}
-
-/// Attempts to lock and retrieve the database.
-Xapian::WritableDatabase *XapianDatabase::writeLock(void)
-{
-	if ((m_readOnly == true) ||
-		(m_merge == true))
-	{
-		cerr << "Couldn't open read-only database " << m_databaseName
-			<< " for writing" << endl;
-		return NULL;
-	}
-
-	if (pthread_mutex_lock(&m_rwLock) == 0)
-	{
-		if (m_pDatabase == NULL)
-		{
-			// Try again
-			openDatabase();
-		}
-
-		return dynamic_cast<Xapian::WritableDatabase *>(m_pDatabase);
-	}
-#ifdef DEBUG
-	else cout << "XapianDatabase::writeLock: failed" << endl;
-#endif
-
-	return NULL;
-}
-
-/// Unlocks the database.
-void XapianDatabase::unlock(void)
-{
-	if (pthread_mutex_unlock(&m_rwLock) != 0)
-	{
-#ifdef DEBUG
-		cout << "XapianDatabase::unlock: failed" << endl;
-#endif
-	}
-
-	if (m_merge == true)
-	{
-		// Unlock the original indexes
-		if (m_pFirst != NULL)
-		{
-			m_pFirst->unlock();
-		}
-		if (m_pSecond != NULL)
-		{
-			m_pSecond->unlock();
-		}
-
-		// Delete merge
-		if (m_pDatabase != NULL)
-		{
-			delete m_pDatabase;
-			m_pDatabase = NULL;
-		}
-	}
-}
-
-bool XapianDatabase::badRecordField(const string &field)
-{
-	regex_t fieldRegex;
-	regmatch_t pFieldMatches[1];
-	bool isBadField = false;
-
-	// A bad field is one that includes one of our field delimiters
-	if (regcomp(&fieldRegex,
-		"(url|sample|caption|type|modtime|language|size)=",
-		REG_EXTENDED|REG_ICASE) == 0)
-	{
-		if (regexec(&fieldRegex, field.c_str(), 1,
-			pFieldMatches, REG_NOTBOL|REG_NOTEOL) == 0)
-		{
-			isBadField = true;
-		}
-	}
-	regfree(&fieldRegex);
-
-	return isBadField;
-}
-
-/// Returns a record for the document's properties.
-string XapianDatabase::propsToRecord(DocumentInfo *pDoc)
-{
-	if (pDoc == NULL)
-	{
-		return "";
-	}
-
-	string record("url=");
-	string title(pDoc->getTitle());
-	string timestamp(pDoc->getTimestamp());
-	time_t timeT = TimeConverter::fromTimestamp(timestamp);
-	char tmpStr[64];
-
-	// Set the document data omindex-style
-	record += pDoc->getLocation();
-	// The sample will be generated at query time
-	record += "\nsample=";
-	record += "\ncaption=";
-	if (badRecordField(title) == true)
-	{
-		// Modify the title if necessary
-		string::size_type pos = title.find("=");
-		while (pos != string::npos)
-		{
-			title[pos] = ' ';
-			pos = title.find("=", pos + 1);
-		}
-#ifdef DEBUG
-		cout << "XapianDatabase::propsToRecord: modified title" << endl;
-#endif
-	}
-	record += title;
-	record += "\ntype=";
-	record += pDoc->getType();
-	// Append a timestamp, in a format compatible with Omega
-	record += "\nmodtime=";
-	snprintf(tmpStr, 64, "%ld", timeT);
-	record += tmpStr;
-	// ...and the language
-	record += "\nlanguage=";
-	record += pDoc->getLanguage();
-	// ...and the file size
-	record += "\nsize=";
-	snprintf(tmpStr, 64, "%ld", pDoc->getSize());
-	record += tmpStr;
-#ifdef DEBUG
-	cout << "XapianDatabase::propsToRecord: document data is " << record << endl;
-#endif
-
-	return record;
-}
-
-/// Sets the document's properties acording to the record.
-void XapianDatabase::recordToProps(const string &record, DocumentInfo *pDoc)
-{
-	if (pDoc == NULL)
-	{
-		return;
-	}
-
-	// Get the title
-	pDoc->setTitle(StringManip::extractField(record, "caption=", "\n"));
-	// Get the URL
-	string url(StringManip::extractField(record, "url=", "\n"));
-	if (url.empty() == false)
-	{
-		url = Url::canonicalizeUrl(url);
-	}
-	pDoc->setLocation(url);
-	// Get the type
-	pDoc->setType(StringManip::extractField(record, "type=", "\n"));
-	// ... the language, if available
-	pDoc->setLanguage(StringManip::extractField(record, "language=", "\n"));
-	// ... and the timestamp
-	string modTime(StringManip::extractField(record, "modtime=", "\n"));
-	if (modTime.empty() == false)
-	{
-		time_t timeT = (time_t )atol(modTime.c_str());
-		pDoc->setTimestamp(TimeConverter::toTimestamp(timeT));
-	}
-	string bytesSize(StringManip::extractField(record, "size=", ""));
-	if (bytesSize.empty() == false)
-	{
-		pDoc->setSize((off_t)atol(bytesSize.c_str()));
-	}
-}
-
-/// Returns the URL for the given document in the given index.
-string XapianDatabase::buildUrl(const string &database, unsigned int docId)
-{
-	// Make up a pseudo URL
-	char docIdStr[64];
-	sprintf(docIdStr, "%u", docId);
-	string url = "xapian://localhost/";
-	url += database;
-	url += "/";
-	url += docIdStr;
-
-	return url;
-}
-
-/// Truncates or partially hashes a term.
-string XapianDatabase::limitTermLength(const string &term, bool makeUnique)
-{
-	if (term.length() > XapianDatabase::m_maxTermLength)
-	{
-		if (makeUnique == false)
-		{
-			// Truncate
-			return term.substr(0, XapianDatabase::m_maxTermLength);
-		}
-		else
-		{
-			return StringManip::hashString(term, XapianDatabase::m_maxTermLength);
-		}
-	}
-
-	return term;
-}

Deleted: trunk/Index/XapianDatabase.h
===================================================================
--- trunk/Index/XapianDatabase.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/XapianDatabase.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,100 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _XAPIAN_DATABASE_H
-#define _XAPIAN_DATABASE_H
-
-#include <string>
-#include <set>
-#include <pthread.h>
-#include <xapian.h>
-
-#include "DocumentInfo.h"
-
-/// Lockable Xapian database.
-class XapianDatabase
-{
-	public:
-		XapianDatabase(const std::string &databaseName,
-			bool readOnly = true, bool overwrite = false);
-		XapianDatabase(const std::string &databaseName,
-			XapianDatabase *pFirst, XapianDatabase *pSecond);
-		XapianDatabase(const XapianDatabase &other);
-		virtual ~XapianDatabase();
-
-		XapianDatabase &operator=(const XapianDatabase &other);
-
-		/// Returns false if the database couldn't be opened.
-		bool isOpen(void) const;
-
-		/// Returns true if the database supports spelling.
-		bool withSpelling(void);
-
-		/// Returns false if the database was of an obsolete format.
-		bool wasObsoleteFormat(void) const;
-
-		/// Reopens the database.
-		void reopen(void);
-
-		/// Attempts to lock and retrieve the database.
-		Xapian::Database *readLock(void);
-
-		/// Attempts to lock and retrieve the database.
-		Xapian::WritableDatabase *writeLock(void);
-
-		/// Unlocks the database.
-		void unlock(void);
-
-		/// Returns a record for the document's properties.
-		static std::string propsToRecord(DocumentInfo *pDoc);
-
-		/// Sets the document's properties acording to the record.
-		static void recordToProps(const std::string &record, DocumentInfo *pDoc);
-
-		/// Returns the URL for the given document in the given index.
-		static std::string buildUrl(const std::string &database, unsigned int docId);
-
-		/// Truncates or partially hashes a term.
-		static std::string limitTermLength(const std::string &term, bool makeUnique = false);
-
-	protected:
-		static const unsigned int m_maxTermLength;
-		std::string m_databaseName;
-		bool m_withSpelling;
-		bool m_readOnly;
-		bool m_overwrite;
-		bool m_obsoleteFormat;
-		pthread_mutex_t m_rwLock;
-#ifdef DEBUG
-		pthread_mutexattr_t m_rwLockAttr;
-#endif
-		Xapian::Database *m_pDatabase;
-		bool m_isOpen;
-		bool m_merge;
-		XapianDatabase *m_pFirst;
-		XapianDatabase *m_pSecond;
-
-		void initializeLock(void);
-
-		void openDatabase(void);
-
-		static bool badRecordField(const std::string &field);
-
-};
-
-#endif // _XAPIAN_DATABASE_H

Deleted: trunk/Index/XapianDatabaseFactory.cpp
===================================================================
--- trunk/Index/XapianDatabaseFactory.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/XapianDatabaseFactory.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,156 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <iostream>
-
-#include "XapianDatabaseFactory.h"
-
-using std::cout;
-using std::endl;
-using std::string;
-using std::map;
-using std::pair;
-
-pthread_mutex_t XapianDatabaseFactory::m_mutex = PTHREAD_MUTEX_INITIALIZER;
-map<string, XapianDatabase *> XapianDatabaseFactory::m_databases;
-
-XapianDatabaseFactory::XapianDatabaseFactory()
-{
-}
-
-XapianDatabaseFactory::~XapianDatabaseFactory()
-{
-}
-
-/// Merges two databases together and add the result to the list.
-bool XapianDatabaseFactory::mergeDatabases(const string &name,
-	XapianDatabase *pFirst, XapianDatabase *pSecond)
-{
-	map<string, XapianDatabase *>::iterator dbIter = m_databases.find(name);
-	if (dbIter != m_databases.end())
-	{
-		return false;
-	}
-
-	// Create the new database
-	XapianDatabase *pDb = new XapianDatabase(name, pFirst, pSecond);
-
-	// Insert it into the map
-	pair<map<string, XapianDatabase *>::iterator, bool> insertPair = m_databases.insert(pair<string, XapianDatabase *>(name, pDb));
-	// Was it inserted ?
-	if (insertPair.second == false)
-	{
-		// No, it wasn't : delete the object
-		delete pDb;
-
-		return false;
-	}
-
-	return true;
-}
-
-/// Returns a XapianDatabase pointer; NULL if unavailable.
-XapianDatabase *XapianDatabaseFactory::getDatabase(const string &location,
-	bool readOnly, bool overwrite)
-{
-	XapianDatabase *pDb = NULL;
-
-	if (location.empty() == true)
-	{
-		return NULL;
-	}
-
-	// Lock the map
-	if (pthread_mutex_lock(&m_mutex) != 0)
-	{
-		return NULL;
-	}
-
-	// Is the database already open ?
-	map<string, XapianDatabase *>::iterator dbIter = m_databases.find(location);
-	if (dbIter != m_databases.end())
-	{
-		pDb = dbIter->second;
-
-		// Overwrite the database ?
-		if (overwrite == true)
-		{
-			dbIter->second = NULL;
-#ifdef DEBUG
-			cout << "XapianDatabaseFactory::getDatabase: closing " << dbIter->first << endl;
-#endif
-			m_databases.erase(dbIter);
-			delete pDb;
-
-			dbIter = m_databases.end();
-		}
-	}
-
-	// Open the database ?
-	if (dbIter == m_databases.end())
-	{
-		// Create a new instance
-		pDb = new XapianDatabase(location, readOnly, overwrite);
-		// Insert it into the map
-		pair<map<string, XapianDatabase *>::iterator, bool> insertPair = m_databases.insert(pair<string, XapianDatabase *>(location, pDb));
-		// Was it inserted ?
-		if (insertPair.second == false)
-		{
-			// No, it wasn't : delete the object
-			delete pDb;
-			pDb = NULL;
-		}
-	}
-
-	// Unlock the map
-	pthread_mutex_unlock(&m_mutex);
-
-	return pDb;
-}
-
-/// Closes all databases.
-void XapianDatabaseFactory::closeAll(void)
-{
-	if (m_databases.empty() == true)
-	{
-		return;
-	}
-
-	// Lock the map
-	if (pthread_mutex_lock(&m_mutex) != 0)
-	{
-		return;
-	}
-
-	std::map<std::string, XapianDatabase *>::iterator dbIter = m_databases.begin();
-	while (dbIter != m_databases.end())
-	{
-		XapianDatabase *pDb = dbIter->second;
-		dbIter->second = NULL;
-#ifdef DEBUG
-		cout << "XapianDatabaseFactory::closeAll: closing " << dbIter->first << endl;
-#endif
-		m_databases.erase(dbIter);
-		delete pDb;
-
-		dbIter = m_databases.begin();
-	}
-
-	// Unlock the map
-	pthread_mutex_unlock(&m_mutex);
-}

Deleted: trunk/Index/XapianDatabaseFactory.h
===================================================================
--- trunk/Index/XapianDatabaseFactory.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/XapianDatabaseFactory.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,57 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _XAPIAN_DATABASE_FACTORY_H
-#define _XAPIAN_DATABASE_FACTORY_H
-
-#include <string>
-#include <map>
-#include <pthread.h>
-
-#include "XapianDatabase.h"
-
-/// Factory for Xapian database objects.
-class XapianDatabaseFactory
-{
-	public:
-		virtual ~XapianDatabaseFactory();
-
-		/// Merges two databases together and add the result to the list.
-		static bool mergeDatabases(const std::string &name,
-			XapianDatabase *pFirst, XapianDatabase *pSecond);
-
-		/// Returns a XapianDatabase pointer; NULL if unavailable.
-		static XapianDatabase *getDatabase(const std::string &location,
-			bool readOnly = true, bool overwrite = false);
-
-		/// Closes all databases.
-		static void closeAll(void);
-
-	protected:
-		static pthread_mutex_t m_mutex;
-		static std::map<std::string, XapianDatabase *> m_databases;
-
-		XapianDatabaseFactory();
-
-	private:
-		XapianDatabaseFactory(const XapianDatabaseFactory &other);
-		XapianDatabaseFactory &operator=(const XapianDatabaseFactory &other);
-
-};
-
-#endif // _XAPIAN_DATABASE_FACTORY_H

Deleted: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/XapianIndex.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,1957 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <fcntl.h>
-#include <ctype.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <strings.h>
-#include <time.h>
-#include <ctype.h>
-#include <iostream>
-#include <fstream>
-#include <algorithm>
-#include <utility>
-#include <xapian.h>
-
-#include "Languages.h"
-#include "StringManip.h"
-#include "TimeConverter.h"
-#include "Url.h"
-#include "LanguageDetector.h"
-#include "XapianDatabaseFactory.h"
-#include "XapianIndex.h"
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::ios;
-using std::ifstream;
-using std::ofstream;
-using std::string;
-using std::vector;
-using std::set;
-using std::map;
-using std::min;
-using std::max;
-
-static bool setVersionFile(const string &databaseName, const string &version)
-{
-	ofstream verFile;
-	string verFileName(databaseName + "/version");
-	bool setVer = false;
-
-	verFile.open(verFileName.c_str(), ios::trunc);
-	if (verFile.good() == true)
-	{
-		verFile << version;
-		setVer = true;
-	}
-	verFile.close();
-
-	return setVer;
-}
-
-static string getVersionFromFile(const string &databaseName)
-{
-	ifstream verFile;
-	string verFileName(databaseName + "/version");
-	string version;
-
-	verFile.open(verFileName.c_str());
-	if (verFile.good() == true)
-	{
-		verFile >> version;
-	}
-	verFile.close();
-
-	return version;
-}
-
-const string XapianIndex::MAGIC_TERM = "X-MetaSE-Doc";
-
-XapianIndex::XapianIndex(const string &indexName) :
-	IndexInterface(),
-	m_databaseName(indexName),
-	m_goodIndex(false),
-	m_doSpelling(true)
-{
-	// Open in read-only mode
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if ((pDatabase != NULL) &&
-		(pDatabase->isOpen() == true))
-	{
-		m_goodIndex = true;
-		m_doSpelling = pDatabase->withSpelling();
-	}
-}
-
-XapianIndex::XapianIndex(const XapianIndex &other) :
-	IndexInterface(other),
-	m_databaseName(other.m_databaseName),
-	m_goodIndex(other .m_goodIndex),
-	m_doSpelling(other.m_doSpelling),
-	m_stemLanguage(other.m_stemLanguage)
-{
-}
-
-XapianIndex::~XapianIndex()
-{
-}
-
-XapianIndex &XapianIndex::operator=(const XapianIndex &other)
-{
-	if (this != &other)
-	{
-		IndexInterface::operator=(other);
-		m_databaseName = other.m_databaseName;
-		m_goodIndex = other .m_goodIndex;
-		m_doSpelling = other.m_doSpelling;
-		m_stemLanguage = other.m_stemLanguage;
-	}
-
-	return *this;
-}
-
-bool XapianIndex::listDocumentsWithTerm(const string &term, set<unsigned int> &docIds,
-	unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	unsigned int docCount = 0;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return 0;
-	}
-
-	docIds.clear();
-	try
-	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-		if (pIndex != NULL)
-		{
-#ifdef DEBUG
-			cout << "XapianIndex::listDocumentsWithTerm: term " << term << endl;
-#endif
-			// Get a list of documents that have the term
-			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
-				(postingIter != pIndex->postlist_end(term)) &&
-					((maxDocsCount == 0) || (docIds.size() < maxDocsCount));
-				++postingIter)
-			{
-				Xapian::docid docId = *postingIter;
-
-				// We cannot use postingIter->skip_to() because startDoc isn't an ID
-				if (docCount >= startDoc)
-				{
-					docIds.insert(docId);
-				}
-				++docCount;
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't get document list: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't get document list, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return docIds.size();
-}
-
-void XapianIndex::addPostingsToDocument(const Xapian::Utf8Iterator &itor, Xapian::Document &doc,
-	const Xapian::WritableDatabase &db, const string &prefix, bool noStemming)
-{
-	Xapian::Stem *pStemmer = NULL;
-	Xapian::TermGenerator generator;
-
-	// Do we know what language to use for stemming ?
-	if ((noStemming == false) &&
-		(m_stemLanguage.empty() == false))
-	{
-		try
-		{
-			pStemmer = new Xapian::Stem(StringManip::toLowerCase(m_stemLanguage));
-		}
-		catch (const Xapian::Error &error)
-		{
-			cerr << "Couldn't create stemmer: " << error.get_type() << ": " << error.get_msg() << endl;
-		}
-
-		if (pStemmer != NULL)
-		{
-			generator.set_stemmer(*pStemmer);
-		}
-	}
-
-	try
-	{
-		// Older Xapian backends don't support spelling correction
-		if (m_doSpelling == true)
-		{
-			// The database is required for the spelling dictionary
-			generator.set_flags(Xapian::TermGenerator::FLAG_SPELLING);
-			generator.set_database(db);
-		}
-		generator.set_document(doc);
-		generator.index_text(itor, 1, prefix);
-	}
-	catch (const Xapian::UnimplementedError &error)
-	{
-		cerr << "Couldn't index with spelling correction: " << error.get_type() << ": " << error.get_msg() << endl;
-
-		if (m_doSpelling == true)
-		{
-			m_doSpelling = false;
-
-			// Try again without spelling correction
-			// Let the caller catch the exception
-			generator.set_flags(Xapian::TermGenerator::FLAG_SPELLING, Xapian::TermGenerator::FLAG_SPELLING);
-			generator.set_document(doc);
-			generator.index_text(itor, 1, prefix);
-		}
-	}
-
-	if (pStemmer != NULL)
-	{
-		delete pStemmer;
-	}
-}
-
-void XapianIndex::removePostingsFromDocument(const Xapian::Utf8Iterator &itor, Xapian::Document &doc,
-	const string &prefix, const string &language, bool noStemming) const
-{
-	Xapian::Document termsDoc;
-	Xapian::TermGenerator generator;
-	Xapian::Stem *pStemmer = NULL;
-	string stemPrefix("Z");
-	string term;
-
-	// Do we know what language to use for stemming ?
-	if ((noStemming == false) &&
-		(language.empty() == false))
-	{
-		try
-		{
-			pStemmer = new Xapian::Stem(StringManip::toLowerCase(m_stemLanguage));
-		}
-		catch (const Xapian::Error &error)
-		{
-			cerr << "Couldn't create stemmer: " << error.get_type() << ": " << error.get_msg() << endl;
-		}
-
-		if (pStemmer != NULL)
-		{
-			generator.set_stemmer(*pStemmer);
-		}
-	}
-
-	// This temporary document enables to get to the same terms
-	// that were added at indexing time
-	generator.set_document(termsDoc);
-	generator.index_text(itor, 1, prefix);
-
-	// Get the terms and remove the first posting for each
-	for (Xapian::TermIterator termListIter = termsDoc.termlist_begin();
-		termListIter != termsDoc.termlist_end(); ++termListIter)
-	{
-		Xapian::termcount postingsCount = termListIter.positionlist_count();
-		Xapian::termcount postingNum = 0;
-		bool removeTerm = false;
-
-#ifdef DEBUG
-		cout << "XapianIndex::removePostingsFromDocument: term " << *termListIter
-			<< " has " << postingsCount << " postings" << endl;
-#endif
-		// If a prefix is defined, or there are no postings, we can afford removing the term
-		if ((prefix.empty() == false) ||
-			(postingsCount == 0))
-		{
-			removeTerm = true;
-		}
-		else
-		{
-			// Check whether this term is in the original document and how many postings it has
-			Xapian::TermIterator termIter = doc.termlist_begin();
-			if (termIter != doc.termlist_end())
-			{
-				termIter.skip_to(*termListIter);
-				if (termIter != doc.termlist_end())
-				{
-					if (*termIter != *termListIter)
-					{
-						// This term doesn't exist in the document !
-#ifdef DEBUG
-						cout << "XapianIndex::removePostingsFromDocument: no such term" << endl;
-#endif
-						continue;
-					}
-
-					if (termIter.positionlist_count() <= postingsCount)
-					{
-						// All postings are to be removed, so we can remove the term
-#ifdef DEBUG
-						cout << "XapianIndex::removePostingsFromDocument: no extra posting" << endl;
-#endif
-						removeTerm = true;
-					}
-				}
-			}
-		}
-
-		if (removeTerm == true)
-		{
-			try
-			{
-				doc.remove_term(*termListIter);
-			}
-			catch (const Xapian::Error &error)
-			{
-#ifdef DEBUG
-				cout << "XapianIndex::removePostingsFromDocument: " << error.get_msg() << endl;
-#endif
-			}
-			continue;
-		}
-
-		// Otherwise, remove the first N postings
-		// FIXME: if all the postings are in the range associated with the metadata
-		// as opposed to the actual data, the term can be removed altogether
-		for (Xapian::PositionIterator firstPosIter = termListIter.positionlist_begin();
-			firstPosIter != termListIter.positionlist_end(); ++firstPosIter)
-		{
-			if (postingNum >= postingsCount)
-			{
-				break;
-			}
-			++postingNum;
-
-			try
-			{
-				doc.remove_posting(*termListIter, *firstPosIter);
-			}
-			catch (const Xapian::Error &error)
-			{
-				// This posting may have been removed already
-#ifdef DEBUG
-				cout << "XapianIndex::removePostingsFromDocument: " << error.get_msg() << endl;
-#endif
-			}
-		}
-	}
-
-	if (pStemmer != NULL)
-	{
-		delete pStemmer;
-	}
-}
-
-void XapianIndex::addCommonTerms(const DocumentInfo &info, Xapian::Document &doc,
-	const Xapian::WritableDatabase &db)
-{
-	string title(info.getTitle());
-	string location(info.getLocation());
-	Url urlObj(location);
-
-	// Add a magic term :-)
-	doc.add_term(MAGIC_TERM);
-
-	// Index the title with and without prefix S
-	if (title.empty() == false)
-	{
-		addPostingsToDocument(Xapian::Utf8Iterator(title), doc, db, "S", true);
-		addPostingsToDocument(Xapian::Utf8Iterator(title), doc, db, "", false);
-	}
-
-	// Index the full URL with prefix U
-	doc.add_term(string("U") + XapianDatabase::limitTermLength(Url::escapeUrl(location), true));
-	// ...the base file with XFILE:
-	string::size_type qmPos = location.find("?");
-	if ((urlObj.isLocal() == true) &&
-		(qmPos != string::npos))
-	{
-		string fileUrl(location.substr(0, qmPos));
-		string protocol(urlObj.getProtocol());
-
-		doc.add_term(string("XFILE:") + XapianDatabase::limitTermLength(Url::escapeUrl(fileUrl), true));
-		if ((urlObj.isLocal() == true) &&
-			(protocol != "file"))
-		{
-			// Add another term with file as protocol
-			fileUrl.replace(0, protocol.length(), "file");
-			doc.add_term(string("XFILE:") + XapianDatabase::limitTermLength(Url::escapeUrl(fileUrl), true));
-		}
-	}
-	// ...the host name and included domains with prefix H
-	string hostName(StringManip::toLowerCase(urlObj.getHost()));
-	if (hostName.empty() == false)
-	{
-		doc.add_term(string("H") + XapianDatabase::limitTermLength(hostName, true));
-		string::size_type dotPos = hostName.find('.');
-		while (dotPos != string::npos)
-		{
-			doc.add_term(string("H") + XapianDatabase::limitTermLength(hostName.substr(dotPos + 1), true));
-
-			// Next
-			dotPos = hostName.find('.', dotPos + 1);
-		}
-	}
-	// ...the location (as is) and all directories with prefix XDIR:
-	string tree(urlObj.getLocation());
-	if (tree.empty() == false)
-	{
-		doc.add_term(string("XDIR:") + XapianDatabase::limitTermLength(Url::escapeUrl(tree), true));
-		if (tree[0] == '/')
-		{
-			doc.add_term("XDIR:/");
-		}
-		string::size_type slashPos = tree.find('/', 1);
-		while (slashPos != string::npos)
-		{
-			doc.add_term(string("XDIR:") + XapianDatabase::limitTermLength(Url::escapeUrl(tree.substr(0, slashPos)), true));
-
-			// Next
-			slashPos = tree.find('/', slashPos + 1);
-		}
-	}
-	// ...and the file name with prefix P
-	string fileName(urlObj.getFile());
-	if (fileName.empty() == false)
-	{
-		string extension;
-
-		doc.add_term(string("P") + XapianDatabase::limitTermLength(Url::escapeUrl(fileName), true));
-
-		// Does it have an extension ?
-		string::size_type extPos = fileName.rfind('.');
-		if ((extPos != string::npos) &&
-			(extPos + 1 < fileName.length()))
-		{
-			extension = StringManip::toLowerCase(fileName.substr(extPos + 1));
-		}
-		doc.add_term(string("XEXT:") + XapianDatabase::limitTermLength(extension));
-	}
-	// Finally, add the language code with prefix L
-	doc.add_term(string("L") + Languages::toCode(m_stemLanguage));
-	// ...and the MIME type with prefix T
-	doc.add_term(string("T") + info.getType());
-}
-
-void XapianIndex::removeCommonTerms(Xapian::Document &doc)
-{
-	DocumentInfo docInfo;
-	set<string> commonTerms;
-	string record(doc.get_data());
-
-	// First, remove the magic term
-	commonTerms.insert(MAGIC_TERM);
-
-	if (record.empty() == true)
-        {
-		// Nothing else we can do
-		return;
-	}
-
-	string language(StringManip::extractField(record, "language=", "\n"));
-
-	docInfo = DocumentInfo(StringManip::extractField(record, "caption=", "\n"),
-		StringManip::extractField(record, "url=", "\n"),
-		StringManip::extractField(record, "type=", "\n"),
-		Languages::toLocale(language));
-	string modTime(StringManip::extractField(record, "modtime=", "\n"));
-	if (modTime.empty() == false)
-	{
-		time_t timeT = (time_t )atol(modTime.c_str());
-		docInfo.setTimestamp(TimeConverter::toTimestamp(timeT));
-	}
-	string bytesSize(StringManip::extractField(record, "size=", ""));
-	if (bytesSize.empty() == false)
-	{
-		docInfo.setSize((off_t )atol(bytesSize.c_str()));
-	}
-	Url urlObj(docInfo.getLocation());
-
-	// FIXME: remove terms extracted from the title if they don't have more than one posting
-	string title(docInfo.getTitle());
-	if (title.empty() == false)
-	{
-		removePostingsFromDocument(Xapian::Utf8Iterator(title), doc, "S", language, true);
-		removePostingsFromDocument(Xapian::Utf8Iterator(title), doc, "", language, false);
-	}
-
-	// Location 
-	string location(docInfo.getLocation());
-	commonTerms.insert(string("U") + XapianDatabase::limitTermLength(Url::escapeUrl(location), true));
-	// Base file
-	string::size_type qmPos = location.find("?");
-	if ((urlObj.isLocal() == true) &&
-		(qmPos != string::npos))
-	{
-		string fileUrl(location.substr(0, qmPos));
-		string protocol(urlObj.getProtocol());
-
-		commonTerms.insert(string("XFILE:") + XapianDatabase::limitTermLength(Url::escapeUrl(fileUrl), true));
-
-		if ((urlObj.isLocal() == true) &&
-			(protocol != "file"))
-		{
-			// Add another term with file as protocol
-			fileUrl.replace(0, protocol.length(), "file");
-			doc.add_term(string("XFILE:") + XapianDatabase::limitTermLength(Url::escapeUrl(fileUrl), true));
-		}
-	}
-	// Host name
-	string hostName(StringManip::toLowerCase(urlObj.getHost()));
-	if (hostName.empty() == false)
-	{
-		commonTerms.insert(string("H") + XapianDatabase::limitTermLength(hostName, true));
-		string::size_type dotPos = hostName.find('.');
-		while (dotPos != string::npos)
-		{
-			commonTerms.insert(string("H") + XapianDatabase::limitTermLength(hostName.substr(dotPos + 1), true));
-
-			// Next
-			dotPos = hostName.find('.', dotPos + 1);
-		}
-	}
-	// ...location
-	string tree(urlObj.getLocation());
-	if (tree.empty() == false)
-	{
-		commonTerms.insert(string("XDIR:") + XapianDatabase::limitTermLength(Url::escapeUrl(tree), true));
-		if (tree[0] == '/')
-		{
-			commonTerms.insert("XDIR:/");
-		}
-		string::size_type slashPos = tree.find('/', 1);
-		while (slashPos != string::npos)
-		{
-			commonTerms.insert(string("XDIR:") + XapianDatabase::limitTermLength(Url::escapeUrl(tree.substr(0, slashPos)), true));
-
-			// Next
-			slashPos = tree.find('/', slashPos + 1);
-		}
-	}
-	// ...and file name
-	string fileName(urlObj.getFile());
-	if (fileName.empty() == false)
-	{
-		string extension;
-
-		commonTerms.insert(string("P") + XapianDatabase::limitTermLength(Url::escapeUrl(fileName), true));
-
-		// Does it have an extension ?
-		string::size_type extPos = fileName.rfind('.');
-		if ((extPos != string::npos) &&
-			(extPos + 1 < fileName.length()))
-		{
-			extension = StringManip::toLowerCase(fileName.substr(extPos + 1));
-		}
-		commonTerms.insert(string("XEXT:") + XapianDatabase::limitTermLength(extension));
-	}
-	// Language code
-	commonTerms.insert(string("L") + Languages::toCode(language));
-	// MIME type
-	commonTerms.insert(string("T") + docInfo.getType());
-
-	for (set<string>::const_iterator termIter = commonTerms.begin(); termIter != commonTerms.end(); ++termIter)
-	{
-		try
-		{
-			doc.remove_term(*termIter);
-		}
-		catch (const Xapian::Error &error)
-		{
-#ifdef DEBUG
-			cout << "XapianIndex::removeCommonTerms: " << error.get_msg() << endl;
-#endif
-		}
-	}
-}
-
-string XapianIndex::scanDocument(const char *pData, unsigned int dataLength,
-	DocumentInfo &info)
-{
-	vector<string> candidates;
-	string language;
-
-	// Try to determine the document's language
-	LanguageDetector lang;
-	lang.guessLanguage(pData, max(dataLength, (unsigned int)2048), candidates);
-
-	// See which of these languages is suitable for stemming
-	for (vector<string>::iterator langIter = candidates.begin(); langIter != candidates.end(); ++langIter)
-	{
-		if (*langIter == "unknown")
-		{
-			continue;
-		}
-
-		try
-		{
-			Xapian::Stem stemmer(*langIter);
-		}
-		catch (const Xapian::Error &error)
-		{
-			cerr << "Couldn't create stemmer: " << error.get_type() << ": " << error.get_msg() << endl;
-			continue;
-		}
-
-		language = *langIter;
-		break;
-	}
-#ifdef DEBUG
-	cout << "XapianIndex::scanDocument: language " << language << endl;
-#endif
-
-	// Update the document's properties
-	info.setLanguage(language);
-
-	return language;
-}
-
-void XapianIndex::setDocumentData(const DocumentInfo &info, Xapian::Document &doc,
-	const string &language) const
-{
-	time_t timeT = TimeConverter::fromTimestamp(info.getTimestamp());
-	struct tm *tm = localtime(&timeT);
-	string yyyymmdd(TimeConverter::toYYYYMMDDString(tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday));
-	string hhmmss(TimeConverter::toHHMMSSString(tm->tm_hour, tm->tm_min, tm->tm_sec));
-
-	// Date
-	doc.add_value(0, yyyymmdd);
-	// FIXME: checksum in value 1
-	// Size
-	doc.add_value(2, Xapian::sortable_serialise((double )info.getSize()));
-	// Time
-	doc.add_value(3, hhmmss);
-	// Date and time, for results sorting
-	doc.add_value(4, yyyymmdd + hhmmss);
-
-	DocumentInfo docCopy(info);
-	// XapianDatabase expects the language in English, which is okay here
-	docCopy.setLanguage(language);
-	doc.set_data(XapianDatabase::propsToRecord(&docCopy));
-}
-
-bool XapianIndex::deleteDocuments(const string &term)
-{
-	bool unindexed = false;
-
-	if (term.empty() == true)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-#ifdef DEBUG
-			cout << "XapianIndex::deleteDocuments: term is " << term << endl;
-#endif
-
-			// Delete documents from the index
-			pIndex->delete_document(term);
-
-			unindexed = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't unindex documents: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't unindex documents, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return unindexed;
-}
-
-//
-// Implementation of IndexInterface
-//
-
-/// Returns false if the index couldn't be opened.
-bool XapianIndex::isGood(void) const
-{
-	return m_goodIndex;
-}
-
-/// Gets the version number.
-string XapianIndex::getVersion(void) const
-{
-	string version("0.00");
-
-#if ENABLE_XAPIAN_DB_METADATA>0
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-		if (pIndex != NULL)
-		{
-			// If this index type doesn't support metadata, no exception will be thrown
-			// We will just get an empty string
-			version = pIndex->get_metadata("version");
-			if (version.empty() == true)
-			{
-				// Is there a pre-0.80 version file ?
-				version = getVersionFromFile(m_databaseName);
-				if (version.empty() == true)
-				{
-					version = "0.00";
-				}
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't get database version: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't get database version, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-#else
-	version = getVersionFromFile(m_databaseName);
-#endif
-
-	return version;
-}
-
-/// Sets the version number.
-bool XapianIndex::setVersion(const string &version) const
-{
-	bool setVer = false;
-
-#if ENABLE_XAPIAN_DB_METADATA>0
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			pIndex->set_metadata("version", version);
-			setVer = true;
-		}
-	}
-	catch (const Xapian::UnimplementedError &error)
-	{
-		cerr << "Couldn't set database version, no support for metadata: " << error.get_type() << ": " << error.get_msg() << endl;
-		// Revert to a version file
-		setVer = setVersionFile(m_databaseName, version);
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't set database version: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't set database version, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-#else
-	setVer = setVersionFile(m_databaseName, version);
-#endif
-
-	// While we are at it, create a CACHEDIR.TAG file
-	// See the spec at http://www.brynosaurus.com/cachedir/
-	string cacheDirFileName(m_databaseName + "/CACHEDIR.TAG");
-	ofstream cacheDirFile;
-	cacheDirFile.open(cacheDirFileName.c_str(), ios::trunc);
-	if (cacheDirFile.good() == true)
-	{
-		cacheDirFile << "Signature: 8a477f597d28d172789f06886806bc55" << endl;
-		cacheDirFile << "# This file is a cache directory tag created by Pinot." << endl;
-		cacheDirFile << "# For information about cache directory tags, see:" << endl;
-		cacheDirFile << "# http://www.brynosaurus.com/cachedir/" << endl;
-	}
-	cacheDirFile.close();
-
-	return setVer;
-}
-
-/// Gets the index location.
-string XapianIndex::getLocation(void) const
-{
-	return m_databaseName;
-}
-
-/// Returns a document's properties.
-bool XapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
-{
-	bool foundDocument = false;
-
-	if (docId == 0)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc = pIndex->get_document(docId);
-			string record(doc.get_data());
-
-			// Get the current document data
-			if (record.empty() == false)
-			{
-				XapianDatabase::recordToProps(record, &docInfo);
-				// XapianDatabase stored the language in English
-				docInfo.setLanguage(Languages::toLocale(docInfo.getLanguage()));
-				foundDocument = true;
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't get document properties: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't get document properties, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return foundDocument;
-}
-
-/// Returns a document's terms count.
-unsigned int XapianIndex::getDocumentTermsCount(unsigned int docId) const
-{
-	unsigned int termsCount = 0;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return 0;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc = pIndex->get_document(docId);
-
-			termsCount = doc.termlist_count();
-#ifdef DEBUG
-			cout << "XapianIndex::getDocumentTermsCount: " << termsCount << " terms in document " << docId << endl;
-#endif
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't get document terms count: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't get document terms count, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return termsCount;
-}
-
-/// Returns a document's terms.
-bool XapianIndex::getDocumentTerms(unsigned int docId, map<unsigned int, string> &wordsBuffer) const
-{
-	vector<string> noPosTerms;
-	bool gotTerms = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-		if (pIndex != NULL)
-		{
-			unsigned int lastPos = 0;
-
-			// Go through the position list of each term
-			for (Xapian::TermIterator termIter = pIndex->termlist_begin(docId);
-				termIter != pIndex->termlist_end(docId); ++termIter)
-			{
-				string termName(*termIter);
-				char firstChar = termName[0];
-				bool hasPositions = false;
-
-				// Is it prefixed ?
-				if (isupper((int)firstChar) != 0)
-				{
-					// Skip X-prefixed terms
-					if (firstChar == 'X')
-					{
-#ifdef DEBUG
-						cout << "XapianIndex::getDocumentTerms: skipping " << termName << endl;
-#endif
-						continue;
-					}
-
-					// Keep other prefixed terms (S, U, H, P, L, T...)
-					termName.erase(0, 1);
-				}
-
-				for (Xapian::PositionIterator positionIter = pIndex->positionlist_begin(docId, *termIter);
-					positionIter != pIndex->positionlist_end(docId, *termIter); ++positionIter)
-				{
-					wordsBuffer[*positionIter] = termName;
-					if (*positionIter > lastPos)
-					{
-						lastPos = *positionIter;
-					}
-					hasPositions = true;
-				}
-
-				if (hasPositions == false)
-				{
-					noPosTerms.push_back(termName);
-				}
-
-				gotTerms = true;
-			}
-
-			// Append terms without positional information as if they were at the end of the document
-			for (vector<string>::const_iterator noPosIter = noPosTerms.begin();
-				noPosIter != noPosTerms.end(); ++noPosIter)
-			{
-				wordsBuffer[lastPos] = *noPosIter;
-				++lastPos;
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't get document terms: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't get document terms, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return gotTerms;
-}
-
-/// Sets the list of known labels.
-bool XapianIndex::setLabels(const set<string> &labels)
-{
-	bool setLabels = false;
-
-#if ENABLE_XAPIAN_DB_METADATA>0
-	string labelString;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	for (set<string>::const_iterator labelIter = labels.begin();
-		labelIter != labels.end(); ++labelIter)
-	{
-		// Prevent from setting internal labels
-		if (labelIter->substr(0, 2) == "X-")
-		{
-			continue;
-		}
-		labelString += "[";
-		labelString += Url::escapeUrl(*labelIter);
-		labelString += "]";
-	}
-
-	try
-	{
-#ifdef DEBUG
-		cout << "XapianIndex::setLabels: " << labels.size() << " labels" << endl;
-#endif
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			pIndex->set_metadata("labels", labelString);
-			setLabels = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't set database labels: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't set database labels, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-#endif
-
-	return setLabels;
-}
-
-/// Gets the list of known labels.
-bool XapianIndex::getLabels(set<string> &labels) const
-{
-#if ENABLE_XAPIAN_DB_METADATA>0
-	string labelsString;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-		if (pIndex != NULL)
-		{
-			labelsString = pIndex->get_metadata("labels");
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't get database labels: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't get database labels, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	if (labelsString.empty() == false)
-	{
-		string::size_type endPos = 0;
-		string label(StringManip::extractField(labelsString, "[", "]", endPos));
-
-		while (label.empty() == false)
-		{
-			labels.insert(Url::unescapeUrl(label));
-
-			if (endPos == string::npos)
-			{
-				break;
-			}
-			label = StringManip::extractField(labelsString, "[", "]", endPos);
-		}
-
-		return true;
-	}
-#endif
-
-	return false;
-}
-
-/// Adds a label.
-bool XapianIndex::addLabel(const string &name)
-{
-	// Nothing to do here
-	return false;
-}
-
-/// Renames a label.
-bool XapianIndex::renameLabel(const string &name, const string &newName)
-{
-	bool renamedLabel = false;
-
-	// Prevent from renaming or setting internal labels
-	if ((name.substr(0, 2) == "X-") ||
-		(newName.substr(0, 2) == "X-"))
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			string term("XLABEL:");
-
-			// Get documents that have this label
-			term += XapianDatabase::limitTermLength(Url::escapeUrl(name));
-			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
-				postingIter != pIndex->postlist_end(term); ++postingIter)
-			{
-				Xapian::docid docId = *postingIter;
-
-				// Get the document
-				Xapian::Document doc = pIndex->get_document(docId);
-				// Remove the term
-				doc.remove_term(term);
-				// ...add the new one
-				doc.add_term(string("XLABEL:") + XapianDatabase::limitTermLength(Url::escapeUrl(newName)));
-				// ...and update the document
-				pIndex->replace_document(docId, doc);
-			}
-
-			renamedLabel = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't delete label: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't delete label, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return renamedLabel;
-}
-
-/// Deletes all references to a label.
-bool XapianIndex::deleteLabel(const string &name)
-{
-	bool deletedLabel = false;
-
-	// Prevent from deleting internal labels
-	if (name.substr(0, 2) == "X-")
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			string term("XLABEL:");
-
-			// Get documents that have this label
-			term += XapianDatabase::limitTermLength(Url::escapeUrl(name));
-			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
-				postingIter != pIndex->postlist_end(term); ++postingIter)
-			{
-				Xapian::docid docId = *postingIter;
-
-				// Get the document
-				Xapian::Document doc = pIndex->get_document(docId);
-				// Remove the term
-				doc.remove_term(term);
-				// ...and update the document
-				pIndex->replace_document(docId, doc);
-			}
-			deletedLabel = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't delete label: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't delete label, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return deletedLabel;
-}
-
-/// Determines whether a document has a label.
-bool XapianIndex::hasLabel(unsigned int docId, const string &name) const
-{
-	bool foundLabel = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-		if (pIndex != NULL)
-		{
-			string term("XLABEL:");
-
-			// Get documents that have this label
-			// FIXME: would it be faster to get the document's terms ?
-			term += XapianDatabase::limitTermLength(Url::escapeUrl(name));
-			Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
-			if (postingIter != pIndex->postlist_end(term))
-			{
-				// Is this document in the list ?
-				postingIter.skip_to(docId);
-				if ((postingIter != pIndex->postlist_end(term)) &&
-					(docId == (*postingIter)))
-				{
-					foundLabel = true;
-				}
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't check document labels: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't check document labels, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return foundLabel;
-}
-
-/// Returns a document's labels.
-bool XapianIndex::getDocumentLabels(unsigned int docId, set<string> &labels) const
-{
-	bool gotLabels = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	labels.clear();
-	try
-	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-		if (pIndex != NULL)
-		{
-			Xapian::TermIterator termIter = pIndex->termlist_begin(docId);
-			if (termIter != pIndex->termlist_end(docId))
-			{
-				for (termIter.skip_to("XLABEL:");
-					termIter != pIndex->termlist_end(docId); ++termIter)
-				{
-					if ((*termIter).length() < 7)
-					{
-						break;
-					}
-
-					// Is this a label ?
-					if (strncasecmp((*termIter).c_str(), "XLABEL:", min(7, (int)(*termIter).length())) == 0)
-					{
-						labels.insert(Url::unescapeUrl((*termIter).substr(7)));
-					}
-				}
-				gotLabels = true;
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't get document's labels: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't get document's labels, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return gotLabels;
-}
-
-/// Sets a document's labels.
-bool XapianIndex::setDocumentLabels(unsigned int docId, const set<string> &labels,
-	bool resetLabels)
-{
-	set<unsigned int> docIds;
-
-	docIds.insert(docId);
-	return setDocumentsLabels(docIds, labels, resetLabels);
-}
-
-/// Sets documents' labels.
-bool XapianIndex::setDocumentsLabels(const set<unsigned int> &docIds,
-	const set<string> &labels, bool resetLabels)
-{
-	bool updatedLabels = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	for (set<unsigned int>::const_iterator docIter = docIds.begin();
-		docIter != docIds.end(); ++docIter)
-	{
-		try
-		{
-			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-			if (pIndex == NULL)
-			{
-				break;
-			}
-
-			unsigned int docId = (*docIter);
-			Xapian::Document doc = pIndex->get_document(docId);
-
-			// Reset existing labels ?
-			if (resetLabels == true)
-			{
-				Xapian::TermIterator termIter = pIndex->termlist_begin(docId);
-				if (termIter != pIndex->termlist_end(docId))
-				{
-					for (termIter.skip_to("XLABEL:");
-						termIter != pIndex->termlist_end(docId); ++termIter)
-					{
-						string term(*termIter);
-
-						// Is this a non-internal label ?
-						if ((strncasecmp(term.c_str(), "XLABEL:", min(7, (int)term.length())) == 0) &&
-							(strncasecmp(term.c_str(), "XLABEL:X-", min(9, (int)term.length())) != 0))
-						{
-							doc.remove_term(term);
-						}
-					}
-				}
-			}
-
-			// Set new labels
-			for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
-				++labelIter)
-			{
-				// Prevent from setting internal labels
-				if ((labelIter->empty() == false) &&
-					(labelIter->substr(0, 2) != "X-"))
-				{
-					doc.add_term(string("XLABEL:") + XapianDatabase::limitTermLength(Url::escapeUrl(*labelIter)));
-				}
-			}
-
-			pIndex->replace_document(docId, doc);
-			updatedLabels = true;
-		}
-		catch (const Xapian::Error &error)
-		{
-			cerr << "Couldn't update document's labels: " << error.get_type() << ": " << error.get_msg() << endl;
-		}
-		catch (...)
-		{
-			cerr << "Couldn't update document's labels, unknown exception occured" << endl;
-		}
-
-		pDatabase->unlock();
-	}
-
-	return updatedLabels;
-}
-
-/// Checks whether the given URL is in the index.
-unsigned int XapianIndex::hasDocument(const string &url) const
-{
-	unsigned int docId = 0;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return 0;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-		if (pIndex != NULL)
-		{
-			string term = string("U") + XapianDatabase::limitTermLength(Url::escapeUrl(Url::canonicalizeUrl(url)), true);
-
-			// Get documents that have this term
-			Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
-			if (postingIter != pIndex->postlist_end(term))
-			{
-				// This URL was indexed
-				docId = *postingIter;
-#ifdef DEBUG
-				cout << "XapianIndex::hasDocument: " << term << " in document "
-					<< docId << " " << postingIter.get_wdf() << " time(s)" << endl;
-#endif
-			}
-			// FIXME: what if the term exists in more than one document ?
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't look for document: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't look for document, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return docId;
-}
-
-/// Gets terms with the same root.
-unsigned int XapianIndex::getCloseTerms(const string &term, set<string> &suggestions)
-{
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return 0;
-	}
-
-	suggestions.clear();
-	try
-	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-		if (pIndex != NULL)
-		{
-			Xapian::TermIterator termIter = pIndex->allterms_begin();
-
-			if (termIter != pIndex->allterms_end())
-			{
-				string baseTerm(StringManip::toLowerCase(term));
-				unsigned int count = 0;
-
-				// Get the next 10 terms
-				for (termIter.skip_to(baseTerm);
-					(termIter != pIndex->allterms_end()) && (count < 10); ++termIter)
-				{
-					string suggestedTerm(*termIter);
-
-					if (suggestedTerm.find(baseTerm) != 0)
-					{
-						// This term doesn't have the same root
-#ifdef DEBUG
-						cout << "XapianIndex::getCloseTerms: not the same root" << endl;
-#endif
-						break;
-					}
-
-					suggestions.insert(suggestedTerm);
-					++count;
-				}
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't get terms: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't get terms, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return suggestions.size();
-}
-
-/// Returns the ID of the last document.
-unsigned int XapianIndex::getLastDocumentID(void) const
-{
-	unsigned int docId = 0;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return 0;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-		if (pIndex != NULL)
-		{
-			docId = pIndex->get_lastdocid();
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't get last document ID: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't get last document ID, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return docId;
-}
-
-/// Returns the number of documents.
-unsigned int XapianIndex::getDocumentsCount(const string &labelName) const
-{
-	unsigned int docCount = 0;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return 0;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-		if (pIndex != NULL)
-		{
-			if (labelName.empty() == true)
-			{
-				docCount = pIndex->get_doccount();
-			}
-			else
-			{
-				string term("XLABEL:");
-
-				// Each label appears only one per document so the collection frequency
-				// is the number of documents that have this label
-				term += XapianDatabase::limitTermLength(Url::escapeUrl(labelName));
-				docCount = pIndex->get_collection_freq(term);
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't count documents: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't count documents, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return docCount;
-}
-
-/// Lists document IDs.
-unsigned int XapianIndex::listDocuments(set<unsigned int> &docIds,
-	unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	// All documents have the magic term
-	return listDocumentsWithTerm("", docIds, maxDocsCount, startDoc);
-}
-
-/// Lists documents.
-bool XapianIndex::listDocuments(const string &name, set<unsigned int> &docIds,
-	NameType type, unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	string term;
-
-	if (type == BY_LABEL)
-	{
-		term = string("XLABEL:") + XapianDatabase::limitTermLength(Url::escapeUrl(name));
-	}
-	else if (type == BY_DIRECTORY)
-	{
-		term = string("XDIR:") + XapianDatabase::limitTermLength(Url::escapeUrl(name), true);
-	}
-	else if (type == BY_FILE)
-	{
-		term = string("XFILE:") + XapianDatabase::limitTermLength(Url::escapeUrl(name), true);
-	}
-
-	return listDocumentsWithTerm(term, docIds, maxDocsCount, startDoc);
-}
-
-/// Indexes the given data.
-bool XapianIndex::indexDocument(const Document &document, const std::set<std::string> &labels,
-	unsigned int &docId)
-{
-	bool indexed = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	// Cache the document's properties
-	DocumentInfo docInfo(document.getTitle(), document.getLocation(),
-		document.getType(), document.getLanguage());
-	docInfo.setTimestamp(document.getTimestamp());
-	docInfo.setSize(document.getSize());
-	docInfo.setLocation(Url::canonicalizeUrl(docInfo.getLocation()));
-
-	unsigned int dataLength = 0;
-	const char *pData = document.getData(dataLength);
-
-	if ((pData != NULL) &&
-		(dataLength > 0))
-	{
-		m_stemLanguage = scanDocument(pData, dataLength, docInfo);
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc;
-
-			// Populate the Xapian document
-			addCommonTerms(docInfo, doc, *pIndex);
-			if ((pData != NULL) &&
-				(dataLength > 0))
-			{
-				Xapian::Utf8Iterator itor(pData, dataLength);
-				addPostingsToDocument(itor, doc, *pIndex, "", false);
-			}
-
-			// Add labels
-			for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
-				++labelIter)
-			{
-				doc.add_term(string("XLABEL:") + XapianDatabase::limitTermLength(Url::escapeUrl(*labelIter)));
-			}
-#ifdef DEBUG
-			cout << "XapianIndex::indexDocument: " << labels.size() << " labels" << endl;
-#endif
-
-			// Set data
-			setDocumentData(docInfo, doc, m_stemLanguage);
-
-			// Add this document to the Xapian index
-			docId = pIndex->add_document(doc);
-			indexed = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't index document: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't index document, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return indexed;
-}
-
-/// Updates the given document; true if success.
-bool XapianIndex::updateDocument(unsigned int docId, const Document &document)
-{
-	bool updated = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	// Cache the document's properties
-	DocumentInfo docInfo(document.getTitle(), document.getLocation(),
-		document.getType(), document.getLanguage());
-	docInfo.setTimestamp(document.getTimestamp());
-	docInfo.setSize(document.getSize());
-	docInfo.setLocation(Url::canonicalizeUrl(docInfo.getLocation()));
-
-	unsigned int dataLength = 0;
-	const char *pData = document.getData(dataLength);
-
-	// Don't scan the document if a language is specified
-	m_stemLanguage = Languages::toEnglish(docInfo.getLanguage());
-	if (m_stemLanguage.empty() == true)
-	{
-		if ((pData != NULL) &&
-			(dataLength > 0))
-		{
-			m_stemLanguage = scanDocument(pData, dataLength, docInfo);
-		}
-	}
-
-	Xapian::WritableDatabase *pIndex = NULL;
-
-	try
-	{
-		set<string> labels;
-
-		// Get the document's labels
-		getDocumentLabels(docId, labels);
-
-		pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc;
-
-			// Populate the Xapian document
-			addCommonTerms(docInfo, doc, *pIndex);
-			if ((pData != NULL) &&
-				(dataLength > 0))
-			{
-				Xapian::Utf8Iterator itor(pData, dataLength);
-				addPostingsToDocument(itor, doc, *pIndex, "", false);
-			}
-
-			// Add labels
-			for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
-				++labelIter)
-			{
-				doc.add_term(string("XLABEL:") + XapianDatabase::limitTermLength(Url::escapeUrl(*labelIter)));
-			}
-
-			// Set data
-			setDocumentData(docInfo, doc, m_stemLanguage);
-
-			// Update the document in the database
-			pIndex->replace_document(docId, doc);
-			updated = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't update document: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't update document, unknown exception occured" << endl;
-	}
-	if (pIndex != NULL)
-	{
-		pDatabase->unlock();
-	}
-
-	return updated;
-}
-
-/// Updates a document's properties.
-bool XapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo)
-{
-	bool updated = false;
-
-	if (docId == 0)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc = pIndex->get_document(docId);
-
-			// Update the document data with the current language
-			m_stemLanguage = Languages::toEnglish(docInfo.getLanguage());
-			removeCommonTerms(doc);
-			addCommonTerms(docInfo, doc, *pIndex);
-			setDocumentData(docInfo, doc, m_stemLanguage);
-
-			pIndex->replace_document(docId, doc);
-			updated = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't update document properties: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't update document properties, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return updated;
-}
-
-/// Unindexes the given document; true if success.
-bool XapianIndex::unindexDocument(unsigned int docId)
-{
-	bool unindexed = false;
-
-	if (docId == 0)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			// Delete the document from the index
-			pIndex->delete_document(docId);
-			unindexed = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't unindex document: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't unindex document, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return unindexed;
-}
-
-/// Unindexes the given document.
-bool XapianIndex::unindexDocument(const string &location)
-{
-	string term(string("U") + XapianDatabase::limitTermLength(Url::escapeUrl(Url::canonicalizeUrl(location)), true));
-
-	return deleteDocuments(term);
-}
-
-/// Unindexes documents.
-bool XapianIndex::unindexDocuments(const string &name, NameType type)
-{
-	string term;
-
-	if (type == BY_LABEL)
-	{
-		term = string("XLABEL:") + XapianDatabase::limitTermLength(Url::escapeUrl(name));
-	}
-	else if (type == BY_DIRECTORY)
-	{
-		term = string("XDIR:") + XapianDatabase::limitTermLength(Url::escapeUrl(name), true);
-	}
-	else if (type == BY_FILE)
-	{
-		term = string("XFILE:") + XapianDatabase::limitTermLength(Url::escapeUrl(name), true);
-	}
-
-	return deleteDocuments(term);
-}
-
-/// Unindexes all documents.
-bool XapianIndex::unindexAllDocuments(void)
-{
-	// All documents have the magic term
-	return deleteDocuments(MAGIC_TERM);
-}
-
-/// Flushes recent changes to the disk.
-bool XapianIndex::flush(void)
-{
-	bool flushed = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			pIndex->flush();
-			flushed = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't flush database: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't flush database, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return flushed;
-}
-
-/// Resets the index.
-bool XapianIndex::reset(void)
-{
-	// Overwrite and reopen
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false, true);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	return true;
-}
-

Deleted: trunk/Index/XapianIndex.h
===================================================================
--- trunk/Index/XapianIndex.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/XapianIndex.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,179 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _XAPIAN_INDEX_H
-#define _XAPIAN_INDEX_H
-
-#include <string>
-#include <set>
-#include <map>
-
-#include "config.h"
-#include "XapianDatabase.h"
-#include "IndexInterface.h"
-
-#if !ENABLE_XAPIAN_DB_METADATA
-// Database metadata is only available in Xapian > 1.0.2
-#if XAPIAN_NUM_VERSION > 1000002
-#define ENABLE_XAPIAN_DB_METADATA 1
-#else
-#define ENABLE_XAPIAN_DB_METADATA 0
-#endif
-#endif
-
-/// A Xapian-based index.
-class XapianIndex : public IndexInterface
-{
-	public:
-		XapianIndex(const std::string &indexName);
-		XapianIndex(const XapianIndex &other);
-		virtual ~XapianIndex();
-
-		XapianIndex &operator=(const XapianIndex &other);
-
-		/// Returns false if the index couldn't be opened.
-		virtual bool isGood(void) const;
-
-		/// Gets the version number.
-		virtual std::string getVersion(void) const;
-
-		/// Sets the version number.
-		virtual bool setVersion(const std::string &version) const;
-
-		/// Gets the index location.
-		virtual std::string getLocation(void) const;
-
-		/// Returns a document's properties.
-		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const;
-
-		/// Returns a document's terms count.
-		virtual unsigned int getDocumentTermsCount(unsigned int docId) const;
-
-		/// Returns a document's terms.
-		virtual bool getDocumentTerms(unsigned int docId,
-			std::map<unsigned int, std::string> &wordsBuffer) const;
-
-		/// Sets the list of known labels.
-		virtual bool setLabels(const std::set<std::string> &labels);
-
-		/// Gets the list of known labels.
-		virtual bool getLabels(std::set<std::string> &labels) const;
-
-		/// Adds a label.
-		virtual bool addLabel(const std::string &name);
-
-		/// Renames a label.
-		virtual bool renameLabel(const std::string &name, const std::string &newName);
-
-		/// Deletes all references to a label.
-		virtual bool deleteLabel(const std::string &name);
-
-		/// Determines whether a document has a label.
-		virtual bool hasLabel(unsigned int docId, const std::string &name) const;
-
-		/// Returns a document's labels.
-		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const;
-
-		/// Sets a document's labels.
-		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
-			bool resetLabels = true);
-
-		/// Sets documents' labels.
-		virtual bool setDocumentsLabels(const std::set<unsigned int> &docIds,
-			const std::set<std::string> &labels, bool resetLabels = true);
-
-		/// Checks whether the given URL is in the index.
-		virtual unsigned int hasDocument(const std::string &url) const;
-
-		/// Gets terms with the same root.
-		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions);
-
-		/// Returns the ID of the last document.
-		virtual unsigned int getLastDocumentID(void) const;
-
-		/// Returns the number of documents.
-		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const;
-
-		/// Lists documents.
-		virtual unsigned int listDocuments(std::set<unsigned int> &docIDList,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		/// Lists documents.
-		virtual bool listDocuments(const std::string &name, std::set<unsigned int> &docIds,
-			NameType type, unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		/// Indexes the given data.
-		virtual bool indexDocument(const Document &doc, const std::set<std::string> &labels,
-			unsigned int &docId);
-
-		/// Updates the given document.
-		virtual bool updateDocument(unsigned int docId, const Document &doc);
-
-		/// Updates a document's properties.
-		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo);
-
-		/// Unindexes the given document.
-		virtual bool unindexDocument(unsigned int docId);
-
-		/// Unindexes the given document.
-		virtual bool unindexDocument(const std::string &location);
-
-		/// Unindexes documents.
-		virtual bool unindexDocuments(const std::string &name, NameType type);
-
-		/// Unindexes all documents.
-		virtual bool unindexAllDocuments(void);
-
-		/// Flushes recent changes to the disk.
-		virtual bool flush(void);
-
-		/// Resets the index.
-		virtual bool reset(void);
-
-	protected:
-		static const std::string MAGIC_TERM;
-		std::string m_databaseName;
-		bool m_goodIndex;
-		bool m_doSpelling;
-		std::string m_stemLanguage;
-
-		bool listDocumentsWithTerm(const std::string &term, std::set<unsigned int> &docIds,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		void addPostingsToDocument(const Xapian::Utf8Iterator &itor, Xapian::Document &doc,
-			const Xapian::WritableDatabase &db, const std::string &prefix, bool noStemming);
-
-		void removePostingsFromDocument(const Xapian::Utf8Iterator &itor, Xapian::Document &doc,
-			const std::string &prefix, const std::string &language, bool noStemming) const;
-
-		void addCommonTerms(const DocumentInfo &info, Xapian::Document &doc,
-			const Xapian::WritableDatabase &db);
-
-		void removeCommonTerms(Xapian::Document &doc);
-
-		std::string scanDocument(const char *pData, unsigned int dataLength,
-			DocumentInfo &info);
-
-		void setDocumentData(const DocumentInfo &info, Xapian::Document &doc,
-			const std::string &language) const;
-
-		bool deleteDocuments(const std::string &term);
-
-};
-
-#endif // _XAPIAN_INDEX_H

Deleted: trunk/Index/pinot-index.1
===================================================================
--- trunk/Index/pinot-index.1	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/pinot-index.1	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,47 +0,0 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-INDEX "1" "November 2007" "pinot-index - pinot 0.81" "User Commands"
-.SH NAME
-pinot-index \- Index documents from the command-line
-.SH SYNOPSIS
-.B pinot-index
-[\fIOPTIONS\fR] \fIURLS\fR
-.SH DESCRIPTION
-pinot\-index \- Index documents from the command\-line
-.SH OPTIONS
-.TP
-\fB\-c\fR, \fB\-\-check\fR
-check whether the given URL is in the index
-.TP
-\fB\-d\fR, \fB\-\-db\fR
-path to index to use (mandatory)
-.TP
-\fB\-h\fR, \fB\-\-help\fR
-display this help and exit
-.TP
-\fB\-i\fR, \fB\-\-index\fR
-index the given URL
-.TP
-\fB\-a\fR, \fB\-\-proxyaddress\fR
-proxy address
-.TP
-\fB\-p\fR, \fB\-\-proxyport\fR
-proxy port
-.TP
-\fB\-t\fR, \fB\-\-proxytype\fR
-proxy type (default HTTP, SOCKS4, SOCKS5)
-.TP
-\fB\-s\fR, \fB\-\-showinfo\fR
-show information about the document
-.TP
-\fB\-v\fR, \fB\-\-version\fR
-output version information and exit
-.SH EXAMPLES
-pinot\-index \fB\-\-check\fR \fB\-\-showinfo\fR \fB\-\-db\fR ~/.pinot/daemon file:///home/fabrice/Documents/Bozo.txt
-.PP
-pinot\-index \fB\-\-index\fR \fB\-\-db\fR ~/.pinot/index http://pinot.berlios.de/
-.SH "REPORTING BUGS"
-Report bugs to fabricecolin at users.berlios.de
-.PP
-This is free software.  You may redistribute copies of it under the terms of
-the GNU General Public License <http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html>.
-There is NO WARRANTY, to the extent permitted by law.

Deleted: trunk/Index/pinot-index.cpp
===================================================================
--- trunk/Index/pinot-index.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/pinot-index.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,338 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
- 
-#include <getopt.h>
-#include <cstdlib>
-#include <cstdio>
-#include <iostream>
-#include <string>
-#include <fstream>
-
-#include "Languages.h"
-#include "MIMEScanner.h"
-#include "Url.h"
-#include "FilterFactory.h"
-#include "XapianDatabaseFactory.h"
-#include "DownloaderFactory.h"
-#include "FilterWrapper.h"
-#include "IndexFactory.h"
-#include "config.h"
-
-using namespace std;
-
-static struct option g_longOptions[] = {
-	{"check", 0, 0, 'c'},
-	{"db", 1, 0, 'd'},
-	{"help", 0, 0, 'h'},
-	{"index", 0, 0, 'i'},
-	{"proxyaddress", 1, 0, 'a'},
-	{"proxyport", 1, 0, 'p'},
-	{"proxytype", 1, 0, 't'},
-	{"showinfo", 0, 0, 's'},
-	{"version", 0, 0, 'v'},
-	{0, 0, 0, 0}
-};
-
-static void printHelp(void)
-{
-	// Help
-	cout << "pinot-index - Index documents from the command-line\n\n"
-		<< "Usage: pinot-index [OPTIONS] URLS\n\n"
-		<< "Options:\n"
-		<< "  -c, --check               check whether the given URL is in the index\n"
-		<< "  -d, --db                  path to index to use (mandatory)\n"
-		<< "  -h, --help                display this help and exit\n"
-		<< "  -i, --index               index the given URL\n"
-		<< "  -a, --proxyaddress        proxy address\n"
-		<< "  -p, --proxyport           proxy port\n"
-		<< "  -t, --proxytype           proxy type (default HTTP, SOCKS4, SOCKS5)\n"
-		<< "  -s, --showinfo            show information about the document\n"
-		<< "  -v, --version             output version information and exit\n\n";
-	// Don't mention type dbus here as it doesn't support indexing and
-	// is identical to xapian when checking for URLs
-	cout << "Examples:\n"
-		<< "pinot-index --check --showinfo --db ~/.pinot/daemon file:///home/fabrice/Documents/Bozo.txt\n\n"
-		<< "pinot-index --index --db ~/.pinot/index http://pinot.berlios.de/\n\n"
-		<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
-}
-
-int main(int argc, char **argv)
-{
-	string type, option;
-	string databaseName, proxyAddress, proxyPort, proxyType;
-	int longOptionIndex = 0;
-	unsigned int docId = 0;
-	bool checkDocument = false, indexDocument = false, showInfo = false, success = false;
-
-	// Look at the options
-	int optionChar = getopt_long(argc, argv, "cd:hia:p:t:sv", g_longOptions, &longOptionIndex);
-	while (optionChar != -1)
-	{
-		set<string> engines;
-
-		switch (optionChar)
-		{
-			case 'a':
-				if (optarg != NULL)
-				{
-					proxyAddress = optarg;
-				}
-				break;
-			case 'c':
-				checkDocument = true;
-				break;
-			case 'd':
-				if (optarg != NULL)
-				{
-					databaseName = optarg;
-				}
-				break;
-			case 'h':
-				printHelp();
-				return EXIT_SUCCESS;
-			case 'i':
-				indexDocument = true;
-				break;
-			case 'p':
-				if (optarg != NULL)
-				{
-					proxyPort = optarg;
-				}
-				break;
-			case 's':
-				showInfo = true;
-				break;
-			case 't':
-				if (optarg != NULL)
-				{
-					proxyType = optarg;
-				}
-				break;
-			case 'v':
-				cout << "pinot-index - " << PACKAGE_STRING << "\n\n"
-					<< "This is free software.  You may redistribute copies of it under the terms of\n"
-					<< "the GNU General Public License <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>.\n"
-					<< "There is NO WARRANTY, to the extent permitted by law." << endl;
-				return EXIT_SUCCESS;
-			default:
-				return EXIT_FAILURE;
-		}
-
-		// Next option
-		optionChar = getopt_long(argc, argv, "cd:hia:p:t:sv", g_longOptions, &longOptionIndex);
-	}
-
-	if (argc == 1)
-	{
-		printHelp();
-		return EXIT_SUCCESS;
-	}
-
-	if ((argc < 2) ||
-		(argc - optind == 0))
-	{
-		cerr << "Not enough parameters" << endl;
-		return EXIT_FAILURE;
-	}
-
-	if (((indexDocument == false) &&
-		(checkDocument == false)) ||
-		(databaseName.empty() == true))
-	{
-		cerr << "Incorrect parameters" << endl;
-		return EXIT_FAILURE;
-	}
-
-	MIMEScanner::initialize("", "");
-	DownloaderInterface::initialize();
-	// Localize language names
-	Languages::setIntlName(0, "Unknown");
-	Languages::setIntlName(1, "Danish");
-	Languages::setIntlName(2, "Dutch");
-	Languages::setIntlName(3, "English");
-	Languages::setIntlName(4, "Finnish");
-	Languages::setIntlName(5, "French");
-	Languages::setIntlName(6, "German");
-	Languages::setIntlName(7, "Hungarian");
-	Languages::setIntlName(8, "Italian");
-	Languages::setIntlName(9, "Norwegian");
-	Languages::setIntlName(10, "Portuguese");
-	Languages::setIntlName(11, "Romanian");
-	Languages::setIntlName(12, "Russian");
-	Languages::setIntlName(13, "Spanish");
-	Languages::setIntlName(14, "Swedish");
-	Languages::setIntlName(15, "Turkish");
-	Dijon::HtmlFilter::initialize();
-	Dijon::FilterFactory::loadFilters(string(LIBDIR) + string("/pinot/filters"));
-
-	// Make sure the index is open in the correct mode
-	XapianDatabase *pDb = XapianDatabaseFactory::getDatabase(databaseName, (indexDocument ? false : true));
-	if (pDb == NULL)
-	{
-		cerr << "Couldn't open index " << databaseName << endl;
-
-		Dijon::FilterFactory::unloadFilters();
-		Dijon::HtmlFilter::shutdown();
-		DownloaderInterface::shutdown();
-		MIMEScanner::shutdown();
-
-		return EXIT_FAILURE;
-	}
-
-	// Get a read-write index of the given type
-	IndexInterface *pIndex = IndexFactory::getIndex("xapian", databaseName);
-	if (pIndex == NULL)
-	{
-		cerr << "Couldn't obtain index for " << databaseName << endl;
-
-		XapianDatabaseFactory::closeAll();
-		Dijon::FilterFactory::unloadFilters();
-		Dijon::HtmlFilter::shutdown();
-		DownloaderInterface::shutdown();
-		MIMEScanner::shutdown();
-
-		return EXIT_FAILURE;
-	}
-
-	while (optind < argc)
-	{
-		string urlParam(argv[optind]);
-
-		if (checkDocument == true)
-		{
-			if (pIndex->isGood() == true)
-			{
-				docId = pIndex->hasDocument(urlParam);
-				if (docId > 0)
-				{
-					cout << urlParam << ": document ID " << docId << endl;
-					success = true;
-				}
-			}
-		}
-		if (indexDocument == true)
-		{
-			Url thisUrl(urlParam);
-
-			// Which Downloader ?
-			DownloaderInterface *pDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
-			if (pDownloader == NULL)
-			{
-				cerr << "Couldn't obtain downloader for protocol " << thisUrl.getProtocol() << endl;
-
-				success = false;
-				continue;
-			}
-
-			// Set up the proxy
-			if ((proxyAddress.empty() == false) &&
-				(proxyPort.empty() == false))
-			{
-				pDownloader->setSetting("proxyaddress", proxyAddress);
-				pDownloader->setSetting("proxyport", proxyPort);
-				pDownloader->setSetting("proxytype", proxyType);
-			}
-
-			DocumentInfo docInfo("", urlParam, MIMEScanner::scanUrl(thisUrl), "");
-			Document *pDoc = pDownloader->retrieveUrl(docInfo);
-			if (pDoc == NULL)
-			{
-				cerr << "Couldn't download " << urlParam << endl;
-			}
-			else
-			{
-				FilterWrapper wrapFilter(pIndex);
-				set<string> labels;
-
-				// Update an existing document or add to the index ?
-				docId = pIndex->hasDocument(urlParam);
-				if (docId > 0)
-				{
-					// Update the document
-					if (wrapFilter.updateDocument(*pDoc, docId) == true)
-					{
-						success = true;
-					}
-				}
-				else
-				{
-					// Index the document
-					success = wrapFilter.indexDocument(*pDoc, labels, docId);
-				}
-
-				if (success == true)
-				{
-					// Flush the index
-					pIndex->flush();
-				}
-
-				delete pDoc;
-			}
-
-			delete pDownloader;
-		}
-		if ((showInfo == true) &&
-			(docId > 0))
-		{
-			DocumentInfo docInfo;
-			set<string> labels;
-
-			if (pIndex->getDocumentInfo(docId, docInfo) == true)
-			{
-				cout << "Location : '" << docInfo.getLocation() << "'" << endl;
-				cout << "Title    : " << docInfo.getTitle() << endl;
-				cout << "Type     : " << docInfo.getType() << endl;
-				cout << "Language : " << docInfo.getLanguage() << endl;
-				cout << "Date     : " << docInfo.getTimestamp() << endl;
-				cout << "Size     : " << docInfo.getSize() << endl;
-			}
-			if (pIndex->getDocumentLabels(docId, labels) == true)
-			{
-				cout << "Labels   : ";
-				for (set<string>::const_iterator labelIter = labels.begin();
-					labelIter != labels.end(); ++labelIter)
-				{
-					if (labelIter->substr(0, 2) == "X-")
-					{
-						continue;
-					}
-					cout << "[" << Url::escapeUrl(*labelIter) << "]";
-				}
-				cout << endl;
-			}
-		}
-
-		// Next
-		++optind;
-	}
-	delete pIndex;
-
-	XapianDatabaseFactory::closeAll();
-	Dijon::FilterFactory::unloadFilters();
-	Dijon::HtmlFilter::shutdown();
-	DownloaderInterface::shutdown();
-	MIMEScanner::shutdown();
-
-	// Did whatever operation we carried out succeed ?
-	if (success == true)
-	{
-		return EXIT_SUCCESS;
-	}
-
-	return EXIT_FAILURE;
-}

Deleted: trunk/Index/pinot-label.1
===================================================================
--- trunk/Index/pinot-label.1	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/pinot-label.1	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,37 +0,0 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-LABEL "1" "November 2007" "pinot-label - pinot 0.81" "User Commands"
-.SH NAME
-pinot-label \- Label files from the command-line
-.SH SYNOPSIS
-.B pinot-label
-[\fIOPTIONS\fR] [\fIFILES\fR]
-.SH DESCRIPTION
-pinot\-label \- Label files from the command\-line
-.SH OPTIONS
-.TP
-\fB\-g\fR, \fB\-\-get\fR
-get the labels list for the given file
-.TP
-\fB\-h\fR, \fB\-\-help\fR
-display this help and exit
-.TP
-\fB\-l\fR, \fB\-\-list\fR
-list known labels
-.TP
-\fB\-s\fR, \fB\-\-set\fR
-set labels on the given file
-.TP
-\fB\-v\fR, \fB\-\-version\fR
-output version information and exit
-.SH EXAMPLES
-pinot\-label \fB\-\-get\fR /home/fabrice/Documents/Bozo.txt
-.PP
-pinot\-label \fB\-\-list\fR
-.PP
-pinot\-label \fB\-\-set\fR "[Clowns][Fun][My Hero]" /home/fabrice/Documents/Bozo.txt
-.SH "REPORTING BUGS"
-Report bugs to fabricecolin at users.berlios.de
-.PP
-This is free software.  You may redistribute copies of it under the terms of
-the GNU General Public License <http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html>.
-There is NO WARRANTY, to the extent permitted by law.

Deleted: trunk/Index/pinot-label.cpp
===================================================================
--- trunk/Index/pinot-label.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/pinot-label.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,278 +0,0 @@
-/*
- *  Copyright 2007 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
- 
-#include <getopt.h>
-#include <sys/types.h>
-#include <pwd.h>
-#include <iostream>
-#include <string>
-#include <set>
-#include "config.h"
-extern "C"
-{
-#if DBUS_NUM_VERSION < 1000000
-#define DBUS_API_SUBJECT_TO_CHANGE
-#endif
-#include <dbus/dbus.h>
-#include <dbus/dbus-glib.h>
-#include <dbus/dbus-glib-lowlevel.h>
-}
-
-#include "StringManip.h"
-#include "MIMEScanner.h"
-#include "Url.h"
-#include "DBusXapianIndex.h"
-#include "XapianDatabaseFactory.h"
-
-using namespace std;
-
-static struct option g_longOptions[] = {
-	{"get", 0, 0, 'g'},
-	{"help", 0, 0, 'h'},
-	{"list", 0, 0, 'l'},
-	{"set", 1, 0, 's'},
-	{"version", 0, 0, 'v'},
-	{0, 0, 0, 0}
-};
-
-
-static void printLabels(const set<string> &labels, const string &fileName)
-{
-	if (fileName.empty() == false)
-	{
-		cout << fileName << endl;
-	}
-	cout << "Labels: ";
-
-	for (set<string>::const_iterator labelIter = labels.begin();
-		labelIter != labels.end(); ++labelIter)
-	{
-		if (labelIter->substr(0, 2) == "X-")
-		{
-			continue;
-		}
-		cout << "[" << Url::escapeUrl(*labelIter) << "]";
-	}
-	cout << endl;
-}
-
-static string getHomeDirectory(void)
-{
-	struct passwd *pPasswd = getpwuid(geteuid());
-
-	if ((pPasswd != NULL) &&
-		(pPasswd->pw_dir != NULL))
-	{
-		return pPasswd->pw_dir;
-	}
-	else
-	{
-		char *homeDir = getenv("HOME");
-		if (homeDir != NULL)
-		{
-			return homeDir;
-		}
-	}
-
-	return "~";
-}
-
-static void printHelp(void)
-{
-	// Help
-	cout << "pinot-label - Label files from the command-line\n\n"
-		<< "Usage: pinot-label [OPTIONS] [FILES]\n\n"
-		<< "Options:\n"
-		<< "  -g, --get                 get the labels list for the given file\n"
-		<< "  -h, --help                display this help and exit\n"
-		<< "  -l, --list                list known labels\n"
-		<< "  -s, --set                 set labels on the given file\n"
-		<< "  -v, --version             output version information and exit\n\n";
-	cout << "Examples:\n"
-		<< "pinot-label --get /home/fabrice/Documents/Bozo.txt\n\n"
-		<< "pinot-label --list\n\n"
-		<< "pinot-label --set \"[Clowns][Fun][My Hero]\" /home/fabrice/Documents/Bozo.txt\n\n"
-		<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
-}
-
-int main(int argc, char **argv)
-{
-	set<string> labels;
-	string labelsString;
-	int longOptionIndex = 0;
-	unsigned int docId = 0;
-	int minArgNum = 1;
-	bool getLabels = false, getDocumentLabels = false, setDocumentLabels = false, success = false;
-
-	// Look at the options
-	int optionChar = getopt_long(argc, argv, "ghls:v", g_longOptions, &longOptionIndex);
-	while (optionChar != -1)
-	{
-		set<string> engines;
-
-		switch (optionChar)
-		{
-			case 'g':
-				getDocumentLabels = true;
-				break;
-			case 'h':
-				printHelp();
-				return EXIT_SUCCESS;
-			case 'l':
-				minArgNum = 0;
-				getLabels = true;
-				break;
-			case 's':
-				setDocumentLabels = true;
-				if (optarg != NULL)
-				{
-					labelsString = optarg;
-				}
-				break;
-			case 'v':
-				cout << "pinot-label - " << PACKAGE_STRING << "\n\n"
-					<< "This is free software.  You may redistribute copies of it under the terms of\n"
-					<< "the GNU General Public License <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>.\n"
-					<< "There is NO WARRANTY, to the extent permitted by law." << endl;
-				return EXIT_SUCCESS;
-			default:
-				return EXIT_FAILURE;
-		}
-
-		// Next option
-		optionChar = getopt_long(argc, argv, "ghls:v", g_longOptions, &longOptionIndex);
-	}
-
-	if (argc == 1)
-	{
-		printHelp();
-		return EXIT_SUCCESS;
-	}
-
-	if ((argc < 2) ||
-		(argc - optind < minArgNum))
-	{
-		cerr << "Not enough parameters" << endl;
-		return EXIT_FAILURE;
-	}
-
-	if ((setDocumentLabels == true) &&
-		(labelsString.empty() == true))
-	{
-		cerr << "Incorrect parameters" << endl;
-		return EXIT_FAILURE;
-	}
-
-	// Initialize GType
-	g_type_init();
-
-	MIMEScanner::initialize("", "");
-
-	string indexLocation(getHomeDirectory() + "/.pinot/daemon");
-	DBusXapianIndex index(indexLocation);
-	if (index.isGood() == false)
-	{
-		cerr << "Couldn't obtain index for " << indexLocation << endl;
-
-		XapianDatabaseFactory::closeAll();
-		MIMEScanner::shutdown();
-
-		return EXIT_FAILURE;
-	}
-
-	if (getLabels == true)
-	{
-		if (index.getLabels(labels, true) == true)
-		{
-			printLabels(labels, "");
-
-			success = true;
-		}
-	}
-
-	while (optind < argc)
-	{
-		string fileParam(argv[optind]);
-
-		if ((getDocumentLabels == true) ||
-			(setDocumentLabels == true))
-		{
-			docId = index.hasDocument(string("file://") + fileParam);
-			if (docId == 0)
-			{
-				cerr << fileParam << " is not indexed" << endl;
-				success = false;
-
-				// Next
-				++optind;
-				continue;
-			}
-		}
-
-		if (getDocumentLabels == true)
-		{
-			labels.clear();
-
-			if (index.getDocumentLabels(docId, labels, true) == true)
-			{
-				printLabels(labels, fileParam);
-
-				success = true;
-			}
-		}
-
-		if (setDocumentLabels == true)
-		{
-			string::size_type endPos = 0;
-			string label(StringManip::extractField(labelsString, "[", "]", endPos));
-
-			labels.clear();
-
-			// Parse labels
-			while (label.empty() == false)
-			{
-				labels.insert(Url::unescapeUrl(label));
-
-				if (endPos == string::npos)
-				{
-					break;
-				}
-				label = StringManip::extractField(labelsString, "[", "]", endPos);
-			}
-
-#ifdef DEBUG
-			printLabels(labels, fileParam);
-#endif
-			success = index.setDocumentLabels(docId, labels);
-		}
-
-		// Next
-		++optind;
-	}
-
-	XapianDatabaseFactory::closeAll();
-	MIMEScanner::shutdown();
-
-	// Did whatever operation we carried out succeed ?
-	if (success == true)
-	{
-		return EXIT_SUCCESS;
-	}
-
-	return EXIT_FAILURE;
-}

Copied: trunk/IndexSearch/DBusXapianIndex.cpp (from rev 1132, trunk/Index/DBusXapianIndex.cpp)

Copied: trunk/IndexSearch/DBusXapianIndex.h (from rev 1132, trunk/Index/DBusXapianIndex.h)

Copied: trunk/IndexSearch/FilterWrapper.cpp (from rev 1132, trunk/Index/FilterWrapper.cpp)

Copied: trunk/IndexSearch/FilterWrapper.h (from rev 1132, trunk/Index/FilterWrapper.h)

Copied: trunk/IndexSearch/Google (from rev 1132, trunk/Search/Google)

Copied: trunk/IndexSearch/IndexFactory.cpp (from rev 1132, trunk/Index/IndexFactory.cpp)

Copied: trunk/IndexSearch/IndexFactory.h (from rev 1132, trunk/Index/IndexFactory.h)

Copied: trunk/IndexSearch/IndexInterface.h (from rev 1132, trunk/Index/IndexInterface.h)

Copied: trunk/IndexSearch/OpenSearchParser.cpp (from rev 1132, trunk/Search/OpenSearchParser.cpp)

Copied: trunk/IndexSearch/OpenSearchParser.h (from rev 1132, trunk/Search/OpenSearchParser.h)

Copied: trunk/IndexSearch/PluginParsers.h (from rev 1132, trunk/Search/PluginParsers.h)

Copied: trunk/IndexSearch/PluginWebEngine.cpp (from rev 1132, trunk/Search/PluginWebEngine.cpp)

Copied: trunk/IndexSearch/PluginWebEngine.h (from rev 1132, trunk/Search/PluginWebEngine.h)

Copied: trunk/IndexSearch/Plugins (from rev 1132, trunk/Search/Plugins)

Copied: trunk/IndexSearch/QueryProperties.cpp (from rev 1132, trunk/Search/QueryProperties.cpp)

Copied: trunk/IndexSearch/QueryProperties.h (from rev 1132, trunk/Search/QueryProperties.h)

Copied: trunk/IndexSearch/ResultsExporter.cpp (from rev 1132, trunk/Search/ResultsExporter.cpp)

Copied: trunk/IndexSearch/ResultsExporter.h (from rev 1132, trunk/Search/ResultsExporter.h)

Copied: trunk/IndexSearch/SOAPEnv.h (from rev 1132, trunk/Search/SOAPEnv.h)

Copied: trunk/IndexSearch/SOAPEnvH.h (from rev 1132, trunk/Search/SOAPEnvH.h)

Copied: trunk/IndexSearch/SOAPEnvNS.cpp (from rev 1132, trunk/Search/SOAPEnvNS.cpp)

Copied: trunk/IndexSearch/SOAPEnvStub.h (from rev 1132, trunk/Search/SOAPEnvStub.h)

Copied: trunk/IndexSearch/SearchEngineFactory.cpp (from rev 1132, trunk/Search/SearchEngineFactory.cpp)

Copied: trunk/IndexSearch/SearchEngineFactory.h (from rev 1132, trunk/Search/SearchEngineFactory.h)

Copied: trunk/IndexSearch/SearchEngineInterface.cpp (from rev 1132, trunk/Search/SearchEngineInterface.cpp)

Copied: trunk/IndexSearch/SearchEngineInterface.h (from rev 1132, trunk/Search/SearchEngineInterface.h)

Copied: trunk/IndexSearch/SearchPluginProperties.cpp (from rev 1132, trunk/Search/SearchPluginProperties.cpp)

Copied: trunk/IndexSearch/SearchPluginProperties.h (from rev 1132, trunk/Search/SearchPluginProperties.h)

Copied: trunk/IndexSearch/SherlockParser.cpp (from rev 1132, trunk/Search/SherlockParser.cpp)

Copied: trunk/IndexSearch/SherlockParser.h (from rev 1132, trunk/Search/SherlockParser.h)

Copied: trunk/IndexSearch/WebEngine.cpp (from rev 1132, trunk/Search/WebEngine.cpp)

Copied: trunk/IndexSearch/WebEngine.h (from rev 1132, trunk/Search/WebEngine.h)

Copied: trunk/IndexSearch/Xapian/AbstractGenerator.cpp (from rev 1132, trunk/Search/AbstractGenerator.cpp)

Copied: trunk/IndexSearch/Xapian/AbstractGenerator.h (from rev 1132, trunk/Search/AbstractGenerator.h)

Copied: trunk/IndexSearch/Xapian/LanguageDetector.cpp (from rev 1132, trunk/Index/LanguageDetector.cpp)

Copied: trunk/IndexSearch/Xapian/LanguageDetector.h (from rev 1132, trunk/Index/LanguageDetector.h)

Copied: trunk/IndexSearch/Xapian/XapianDatabase.cpp (from rev 1132, trunk/Index/XapianDatabase.cpp)

Copied: trunk/IndexSearch/Xapian/XapianDatabase.h (from rev 1132, trunk/Index/XapianDatabase.h)

Copied: trunk/IndexSearch/Xapian/XapianDatabaseFactory.cpp (from rev 1132, trunk/Index/XapianDatabaseFactory.cpp)

Copied: trunk/IndexSearch/Xapian/XapianDatabaseFactory.h (from rev 1132, trunk/Index/XapianDatabaseFactory.h)

Copied: trunk/IndexSearch/Xapian/XapianEngine.cpp (from rev 1132, trunk/Search/XapianEngine.cpp)

Copied: trunk/IndexSearch/Xapian/XapianEngine.h (from rev 1132, trunk/Search/XapianEngine.h)

Copied: trunk/IndexSearch/Xapian/XapianIndex.cpp (from rev 1132, trunk/Index/XapianIndex.cpp)

Copied: trunk/IndexSearch/Xapian/XapianIndex.h (from rev 1132, trunk/Index/XapianIndex.h)

Copied: trunk/IndexSearch/pinot-index.1 (from rev 1132, trunk/Index/pinot-index.1)

Copied: trunk/IndexSearch/pinot-index.cpp (from rev 1132, trunk/Index/pinot-index.cpp)

Copied: trunk/IndexSearch/pinot-label.1 (from rev 1132, trunk/Index/pinot-label.1)

Copied: trunk/IndexSearch/pinot-label.cpp (from rev 1132, trunk/Index/pinot-label.cpp)

Copied: trunk/IndexSearch/pinot-search.1 (from rev 1132, trunk/Search/pinot-search.1)

Copied: trunk/IndexSearch/pinot-search.cpp (from rev 1132, trunk/Search/pinot-search.cpp)

Deleted: trunk/Search/AbstractGenerator.cpp
===================================================================
--- trunk/Search/AbstractGenerator.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/AbstractGenerator.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,256 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <string.h>
-#include <ctype.h>
-#include <sys/time.h>
-#include <glib.h>
-#include <map>
-#include <algorithm>
-#include <iostream>
-#include <utility>
-
-#include "Timer.h"
-#include "AbstractGenerator.h"
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-using std::vector;
-using std::map;
-using std::find;
-
-unsigned int AbstractGenerator::m_maxSeedTerms = 5;
-unsigned int AbstractGenerator::m_minTermPositions = 10;
-
-AbstractGenerator::PositionWindow::PositionWindow() :
-	m_backWeight(0),
-	m_forwardWeight(0)
-{
-}
-
-AbstractGenerator::PositionWindow::~PositionWindow()
-{
-}
-
-AbstractGenerator::AbstractGenerator(const Xapian::Database *pIndex,
-	unsigned int wordsCount) :
-	m_pIndex(pIndex),
-	m_wordsCount(wordsCount)
-{
-}
-
-AbstractGenerator::~AbstractGenerator()
-{
-}
-
-/// Attempts to generate an abstract of wordsCount words.
-string AbstractGenerator::generateAbstract(Xapian::docid docId,
-	const vector<string> &seedTerms)
-{
-	map<Xapian::termpos, PositionWindow> abstractWindows;
-	map<Xapian::termpos, string> wordsBuffer;
-	string summary;
-	Xapian::termpos bestPosition = 0, startPosition = 0;
-	unsigned int seedTermsCount = 0, bestWeight = 0;
-	bool topTerm = true;
-
-	if ((m_pIndex == NULL) ||
-		(seedTerms.empty() == true))
-	{
-		return "";
-	}
-
-#ifdef DEBUG
-	Timer timer;
-	timer.start();
-#endif
-	for (vector<string>::const_iterator termIter = seedTerms.begin();
-		termIter != seedTerms.end(); ++termIter)
-	{
-		string termName(*termIter);
-
-		if (seedTermsCount >= m_maxSeedTerms)
-		{
-			// Enough terms
-			break;
-		}
-
-#ifdef DEBUG
-		cout << "AbstractGenerator::generateAbstract: term " << termName << endl;
-#endif
-		try
-		{
-			// Go through that term's position list in the document
-			for (Xapian::PositionIterator positionIter = m_pIndex->positionlist_begin(docId, termName);
-				positionIter != m_pIndex->positionlist_end(docId, termName); ++positionIter)
-			{
-				Xapian::termpos termPos = *positionIter;
-
-				// Take all the top term's positions into account, and some of 
-				// the other terms' too if the minimum number is not reached
-				if ((m_minTermPositions > abstractWindows.size()) ||
-					(topTerm == true))
-				{
-					abstractWindows[termPos] = PositionWindow();
-				}
-
-				// Look for other terms close to that position
-				for (map<Xapian::termpos, PositionWindow>::iterator winIter = abstractWindows.begin();
-					winIter != abstractWindows.end(); ++winIter)
-				{
-					// Is this within the number of words we are interested in ?
-					if (winIter->first > termPos)
-					{
-						if (winIter->first - termPos <= m_wordsCount)
-						{
-							++winIter->second.m_backWeight;
-						}
-					}
-					else
-					{
-						if (termPos - winIter->first <= m_wordsCount)
-						{
-							++winIter->second.m_forwardWeight;
-						}
-					}
-				}
-			}
-
-			topTerm = false;
-			++seedTermsCount;
-		}
-		catch (const Xapian::Error &error)
-		{
-#ifdef DEBUG
-			cout << "AbstractGenerator::generateAbstract: " << error.get_msg() << endl;
-#endif
-			continue;
-		}
-
-#ifdef DEBUG
-		cout << "AbstractGenerator::generateAbstract: " << abstractWindows.size()
-			<< " positions, " << seedTermsCount << " terms" << endl;
-#endif
-	}
-
-	// Go through positions and find out which one has the largest
-	// number of terms nearby
-	for (map<Xapian::termpos, PositionWindow>::iterator winIter = abstractWindows.begin();
-		winIter != abstractWindows.end(); ++winIter)
-	{
-		if (bestWeight < winIter->second.m_backWeight)
-		{
-			bestPosition = winIter->first;
-			startPosition = 0;
-			if (bestPosition > m_wordsCount)
-			{
-				startPosition = bestPosition - m_wordsCount;
-			}
-			bestWeight = winIter->second.m_backWeight;
-		}
-		if (bestWeight < winIter->second.m_forwardWeight)
-		{
-			bestPosition = startPosition = winIter->first;
-			bestWeight = winIter->second.m_forwardWeight;
-		}
-	}
-#ifdef DEBUG
-	cout << "AbstractGenerator::generateAbstract: best position is "
-		<< bestPosition << ":" << startPosition << " with weight " << bestWeight << endl;
-#endif
-
-	try
-	{
-		// Go through the position list of each term
-		for (Xapian::TermIterator termIter = m_pIndex->termlist_begin(docId);
-			termIter != m_pIndex->termlist_end(docId); ++termIter)
-		{
-			string termName(*termIter);
-
-			// Skip prefixed terms
-			if (isupper((int)termName[0]) != 0)
-			{
-				continue;
-			}
-
-			for (Xapian::PositionIterator positionIter = m_pIndex->positionlist_begin(docId, termName);
-				positionIter != m_pIndex->positionlist_end(docId, termName); ++positionIter)
-			{
-				Xapian::termpos termPos = *positionIter;
-
-				// ...and get those that fall in the abstract window
-				if ((startPosition <= termPos + 1) &&
-					(termPos < startPosition + m_wordsCount))
-				{
-					wordsBuffer[termPos] = termName;
-				}
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-#ifdef DEBUG
-		cout << "AbstractGenerator::generateAbstract: " << error.get_msg() << endl;
-#endif
-		return "";
-	}
-
-	// Generate the abstract
-	for (map<Xapian::termpos, string>::iterator wordIter = wordsBuffer.begin();
-		wordIter != wordsBuffer.end(); ++wordIter)
-	{
-		gchar *pEscToken = NULL;
-		gchar *pUTF8Token = NULL;
-		gsize bytesWritten = 0;
-
-		pUTF8Token = g_locale_to_utf8(wordIter->second.c_str(), wordIter->second.length(),
-			NULL, &bytesWritten, NULL);
-		if (pUTF8Token != NULL)
-		{
-			pEscToken = g_markup_escape_text(pUTF8Token, -1);
-			g_free(pUTF8Token);
-		}
-		if (pEscToken == NULL)
-		{
-			continue;
-		}
-
-		// Is this a seed term ?
-		if (find(seedTerms.begin(), seedTerms.end(), wordIter->second) != seedTerms.end())
-		{
-			summary += "<b>";
-			summary += pEscToken;
-			summary += "</b>";
-		}
-		else
-		{
-			summary += pEscToken;
-		}
-		summary += " ";
-
-		g_free(pEscToken);
-	}
-#ifdef DEBUG
-	cout << "AbstractGenerator::generateAbstract: summarized document "
-		<< docId << " in " << timer.stop() << " ms" << endl;
-#endif
-
-	return summary;
-}

Deleted: trunk/Search/AbstractGenerator.h
===================================================================
--- trunk/Search/AbstractGenerator.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/AbstractGenerator.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,61 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _ABSTRACT_GENERATOR_H
-#define _ABSTRACT_GENERATOR_H
-
-#include <string>
-#include <vector>
-
-#include <xapian.h>
-
-/// Generates abstracts for indexed documents.
-class AbstractGenerator
-{
-	public:
-		AbstractGenerator(const Xapian::Database *pIndex, unsigned int wordsCount);
-		virtual ~AbstractGenerator();
-
-		/// Attempts to generate an abstract of wordsCount words.
-		std::string generateAbstract(Xapian::docid docId,
-			const std::vector<std::string> &seedTerms);
-
-	protected:
-		static unsigned int m_maxSeedTerms;
-		static unsigned int m_minTermPositions;
-		const Xapian::Database *m_pIndex;
-		unsigned int m_wordsCount;
-
-		class PositionWindow
-		{
-			public:
-				PositionWindow();
-				~PositionWindow();
-
-				unsigned int m_backWeight;
-				unsigned int m_forwardWeight;
-
-		};
-
-	private:
-		AbstractGenerator(const AbstractGenerator &other);
-		AbstractGenerator &operator=(const AbstractGenerator &other);
-
-};
-
-#endif // _ABSTRACT_GENERATOR_H

Deleted: trunk/Search/OpenSearchParser.cpp
===================================================================
--- trunk/Search/OpenSearchParser.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/OpenSearchParser.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,564 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <iostream>
-#include <glibmm/thread.h>
-#include <glibmm/convert.h>
-#include <libxml/parserInternals.h>
-#include <libxml++/parsers/domparser.h>
-#include <libxml++/nodes/node.h>
-#include <libxml++/nodes/textnode.h>
-#include <libxml++/nodes/cdatanode.h>
-
-#include "StringManip.h"
-#include "OpenSearchParser.h"
-
-using namespace std;
-using namespace Glib;
-using namespace xmlpp;
-
-static ustring getNodeContent(const Node *pNode)
-{
-	if (pNode == NULL)
-	{
-		return "";
-	}
-
-	// Is it an element ?
-	const Element *pElem = dynamic_cast<const Element*>(pNode);
-	if (pElem != NULL)
-	{
-#ifdef HAS_LIBXMLPP026
-		const TextNode *pText = pElem->get_child_content();
-#else
-		const TextNode *pText = pElem->get_child_text();
-#endif
-		if (pText == NULL)
-		{
-			// Maybe the text is given as CDATA
-			const Node::NodeList childNodes = pNode->get_children();
-			if (childNodes.size() == 1)
-			{
-				// Is it CDATA ?
-				const CdataNode *pContent = dynamic_cast<const CdataNode*>(*childNodes.begin());
-				if (pContent != NULL)
-				{
-					return pContent->get_content();
-				}
-			}
-
-			return "";
-		}
-
-		return pText->get_content();
-	}
-
-	return "";
-}
-
-OpenSearchResponseParser::OpenSearchResponseParser(bool rssResponse) :
-	ResponseParserInterface(),
-	m_rssResponse(rssResponse)
-{
-}
-
-OpenSearchResponseParser::~OpenSearchResponseParser()
-{
-}
-
-bool OpenSearchResponseParser::parse(const ::Document *pResponseDoc, vector<DocumentInfo> &resultsList,
-	unsigned int &totalResults, unsigned int &firstResultIndex) const
-{
-	float pseudoScore = 100;
-	unsigned int contentLen = 0;
-	bool foundResult = false;
-
-	if ((pResponseDoc == NULL) ||
-		(pResponseDoc->getData(contentLen) == NULL) ||
-		(contentLen == 0))
-	{
-		return false;
-	}
-
-	// Make sure the response MIME type is sensible
-	string mimeType = pResponseDoc->getType();
-	if ((mimeType.empty() == false) &&
-		(mimeType.find("xml") == string::npos))
-	{
-		cerr << "OpenSearchResponseParser::parse: response is not XML" << endl;
-		return false;
-	}
-
-	const char *pContent = pResponseDoc->getData(contentLen);
-	try
-	{
-		bool loadFeed = false;
-
-		// Parse the configuration file
-		DomParser parser;
-		parser.set_substitute_entities(true);
-		parser.parse_memory_raw((const unsigned char *)pContent, (Parser::size_type)contentLen);
-		xmlpp::Document *pDocument = parser.get_document();
-		if (pDocument == NULL)
-		{
-			return false;
-		}
-
-		Node *pNode = pDocument->get_root_node();
-		Element *pRootElem = dynamic_cast<Element *>(pNode);
-		if (pRootElem == NULL)
-		{
-			return false;
-		}
-		// Check the top-level element is what we expect
-		ustring rootNodeName = pRootElem->get_name();
-		if (m_rssResponse == true)
-		{
-			if (rootNodeName == "rss")
-			{
-				const Node::NodeList rssChildNodes = pRootElem->get_children();
-				for (Node::NodeList::const_iterator rssIter = rssChildNodes.begin();
-					rssIter != rssChildNodes.end(); ++rssIter)
-				{
-					Node *pRssNode = (*rssIter);
-					Element *pRssElem = dynamic_cast<Element*>(pRssNode);
-					if (pRssElem != NULL)
-					{
-						if (pRssElem->get_name() == "channel")
-						{
-							pRootElem = pRssElem;
-							loadFeed = true;
-							break;
-						}
-					}
-				}
-			}
-		}
-		else
-		{
-			if (rootNodeName != "feed")
-			{
-				return false;
-			}
-			loadFeed = true;
-		}
-
-		if (loadFeed == false)
-		{
-#ifdef DEBUG
-			cout << "OpenSearchResponseParser::parse: error on root node "
-				<< rootNodeName << endl;
-#endif
-			return false;
-		}
-
-		// RSS
-		ustring itemNode("item");
-		ustring descriptionNode("description");
-		if (m_rssResponse == false)
-		{
-			// Atom
-			itemNode = "entry";
-			descriptionNode = "content";
-		}
-
-		// Go through the subnodes
-		const Node::NodeList childNodes = pRootElem->get_children();
-		for (Node::NodeList::const_iterator iter = childNodes.begin();
-			iter != childNodes.end(); ++iter)
-		{
-			Node *pChildNode = (*iter);
-			ustring nodeName(pChildNode->get_name());
-			ustring nodeContent(getNodeContent(pChildNode));
-
-			// Is this an OpenSearch extension ?
-			// FIXME: make sure namespace is opensearch
-			if (nodeName == "totalResults")
-			{
-				if (nodeContent.empty() == false)
-				{
-					totalResults = min((unsigned int)atoi(nodeContent.c_str()), totalResults);
-#ifdef DEBUG
-					cout << "OpenSearchResponseParser::parse: total results "
-						<< totalResults << endl;
-#endif
-				}
-			}
-			else if (nodeName == "startIndex")
-			{
-				if (nodeContent.empty() == false)
-				{
-					firstResultIndex = (unsigned int)atoi(nodeContent.c_str());
-#ifdef DEBUG
-					cout << "OpenSearchResponseParser::parse: first result index "
-						<< firstResultIndex << endl;
-#endif
-				}
-			}
-
-			if (nodeName != itemNode)
-			{
-				continue;
-			}
-
-			// Go through the item's subnodes
-			ustring title, url, extract;
-			const Node::NodeList itemChildNodes = pChildNode->get_children();
-			for (Node::NodeList::const_iterator itemIter = itemChildNodes.begin();
-				itemIter != itemChildNodes.end(); ++itemIter)
-			{
-				Node *pItemNode = (*itemIter);
-				Element *pItemElem = dynamic_cast<Element*>(pItemNode);
-				if (pItemElem == NULL)
-				{
-					continue;
-				}
-
-				ustring itemNodeName = pItemNode->get_name();
-				if (itemNodeName == "title")
-				{
-					title = getNodeContent(pItemNode);
-				}
-				else if (itemNodeName == "link")
-				{
-					if (m_rssResponse == true)
-					{
-						url = getNodeContent(pItemNode);
-					}
-					else
-					{
-						Attribute *pAttr = pItemElem->get_attribute("href");
-						if (pAttr != NULL)
-						{
-							url = pAttr->get_value();
-						}
-					}
-				}
-				else if (itemNodeName == descriptionNode)
-				{
-					extract = getNodeContent(pItemNode);
-				}
-			}
-
-			DocumentInfo result(title, url, "", "");
-			result.setExtract(extract);
-			result.setScore(pseudoScore);
-
-			resultsList.push_back(result);
-			--pseudoScore;
-			foundResult = true;
-			if (resultsList.size() >= totalResults)
-			{
-				// Enough results
-				break;
-			}
-		}
-	}
-	catch (const std::exception& ex)
-	{
-#ifdef DEBUG
-		cout << "OpenSearchResponseParser::parse: caught exception: " << ex.what() << endl;
-#endif
-		foundResult = false;
-	}
-
-	return foundResult;
-}
-
-OpenSearchParser::OpenSearchParser(const string &fileName) :
-	PluginParserInterface(fileName)
-{
-}
-
-OpenSearchParser::~OpenSearchParser()
-{
-}
-
-ResponseParserInterface *OpenSearchParser::parse(SearchPluginProperties &properties,
-	bool extractSearchParams)
-{
-	struct stat fileStat;
-	bool rssResponse = true, success = true;
-
-	if ((m_fileName.empty() == true) ||
-		(stat(m_fileName.c_str(), &fileStat) != 0) ||
-		(!S_ISREG(fileStat.st_mode)))
-	{
-		return NULL;
-	}
-
-	try
-	{
-		// Parse the configuration file
-		DomParser parser;
-		parser.set_substitute_entities(true);
-		parser.parse_file(m_fileName);
-		xmlpp::Document *pDocument = parser.get_document();
-		if (pDocument == NULL)
-		{
-			return NULL;
-		}
-
-		Node *pNode = pDocument->get_root_node();
-		Element *pRootElem = dynamic_cast<Element *>(pNode);
-		if (pRootElem == NULL)
-		{
-			return NULL;
-		}
-		// Check the top-level element is what we expect
-		// MozSearch is very much like OpenSearch Description
-		ustring rootNodeName = pRootElem->get_name();
-		if ((rootNodeName != "OpenSearchDescription") &&
-			(rootNodeName != "SearchPlugin"))
-		{
-#ifdef DEBUG
-			cout << "OpenSearchParser::parse: wrong root node " << rootNodeName << endl;
-#endif
-			return NULL;
-		}
-
-		// Go through the subnodes
-		const Node::NodeList childNodes = pRootElem->get_children();
-		if (childNodes.empty() == false)
-		{
-			for (Node::NodeList::const_iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-			{
-				Node *pChildNode = (*iter);
-				Element *pElem = dynamic_cast<Element*>(pChildNode);
-				if (pElem == NULL)
-				{
-					continue;
-				}
-
-				ustring nodeName(pChildNode->get_name());
-				ustring nodeContent(getNodeContent(pChildNode));
-
-				if (nodeName == "ShortName")
-				{
-					properties.m_name = nodeContent;
-				}
-				else if (nodeName == "Description")
-				{
-					properties.m_description = nodeContent;
-				}
-				else if (nodeName == "Url")
-				{
-					ustring url, type;
-					SearchPluginProperties::Response response = SearchPluginProperties::RSS_RESPONSE;
-					bool getMethod = true;
-
-					// Parse Query Syntax
-					Element::AttributeList attributes = pElem->get_attributes();
-					for (Element::AttributeList::const_iterator iter = attributes.begin();
-						iter != attributes.end(); ++iter)
-					{
-						Attribute *pAttr = (*iter);
-
-						if (pAttr != NULL)
-						{
-							ustring attrName = pAttr->get_name();
-							ustring attrContent = pAttr->get_value();
-
-							if (attrName == "template")
-							{
-								url = attrContent;
-							}
-							else if (attrName == "type")
-							{
-								type = attrContent;
-							}
-							else if (attrName == "method")
-							{
-								// GET is the default method
-								if (StringManip::toLowerCase(attrContent) != "get")
-								{
-									getMethod = false;
-								}
-							}
-						}
-					}
-
-					// Did we get the URL ?
-					if (url.empty() == true)
-					{
-						// It's probably provided as content, v1.0 style
-						url = nodeContent;
-					}
-
-					if (getMethod == true)
-					{
-						string::size_type startPos = 0, pos = url.find("?");
-
-						// Do we support that type ?
-						if (type == "application/atom+xml")
-						{
-							response = SearchPluginProperties::ATOM_RESPONSE;
-							rssResponse = false;
-						}
-						else if ((type.empty() == false) &&
-							(type != "application/rss+xml"))
-						{
-							response = SearchPluginProperties::UNKNOWN_RESPONSE;
-#ifdef DEBUG
-							cout << "OpenSearchParser::parse: unsupported response type "
-								<< type << endl;
-#endif
-							continue;
-						}
-	
-						// Break the URL down into base and parameters
-						if (pos != string::npos)
-						{
-							string params(url.substr(pos + 1));
-
-							// URL
-							properties.m_baseUrl = url.substr(0, pos);
-#ifdef DEBUG
-							cout << "OpenSearchParser::parse: URL is " << url << endl;
-#endif
-
-							// Split this into the actual parameters
-							params += "&";
-							pos = params.find("&");
-							while (pos != string::npos)
-							{
-								string parameter(params.substr(startPos, pos - startPos));
-
-								string::size_type equalPos = parameter.find("=");
-								if (equalPos != string::npos)
-								{
-									string paramName(parameter.substr(0, equalPos));
-									string paramValue(parameter.substr(equalPos + 1));
-									SearchPluginProperties::Parameter param = SearchPluginProperties::UNKNOWN_PARAM;
-
-									if (paramValue == "{searchTerms}")
-									{
-										param = SearchPluginProperties::SEARCH_TERMS_PARAM;
-									}
-									else if (paramValue == "{count}")
-									{
-										param = SearchPluginProperties::COUNT_PARAM;
-									}
-									else if (paramValue == "{startIndex}")
-									{
-										param = SearchPluginProperties::START_INDEX_PARAM;
-									}
-									else if (paramValue == "{startPage}")
-									{
-										param = SearchPluginProperties::START_PAGE_PARAM;
-									}
-									else if (paramValue == "{language}")
-									{
-										param = SearchPluginProperties::LANGUAGE_PARAM;
-									}
-									else if (paramValue == "{outputEncoding}")
-									{
-										param = SearchPluginProperties::OUTPUT_ENCODING_PARAM;
-									}
-									else if (paramValue == "{inputEncoding}")
-									{
-										param = SearchPluginProperties::INPUT_ENCODING_PARAM;
-									}
-
-									if (param != SearchPluginProperties::UNKNOWN_PARAM)
-									{
-										properties.m_parameters[param] = paramName;
-									}
-									else
-									{
-										// Append to the remainder
-										if (properties.m_parametersRemainder.empty() == false)
-										{
-											properties.m_parametersRemainder += "&";
-										}
-										properties.m_parametersRemainder += paramName;
-										properties.m_parametersRemainder += "=";
-										properties.m_parametersRemainder += paramValue;
-									}
-								}
-
-								// Next
-								startPos = pos + 1;
-								pos = params.find_first_of("&", startPos);
-							}
-						}
-
-						// Method
-						properties.m_method = SearchPluginProperties::GET_METHOD;
-						// Output type
-						properties.m_outputType = type;
-						// Response
-						properties.m_response = response;
-					}
-
-					// We ignore Param as we only support GET
-				}
-				else if (nodeName == "Tags")
-				{
-					// This is supposed to be a space-delimited list, but use the whole thing as channel
-					properties.m_channel = nodeContent;
-				}
-				else if (nodeName == "LongName")
-				{
-					properties.m_longName = nodeContent;
-				}
-				else if (nodeName == "Language")
-				{
-					properties.m_languages.insert(nodeContent);
-				}
-				else if (nodeName == "OutputEncoding")
-				{
-					properties.m_outputEncodings.insert(nodeContent);
-				}
-				else if (nodeName == "InputEncoding")
-				{
-					properties.m_inputEncodings.insert(nodeContent);
-				}
-			}
-		}
-	}
-	catch (const std::exception& ex)
-	{
-#ifdef DEBUG
-		cout << "OpenSearchParser::parse: caught exception: " << ex.what() << endl;
-#endif
-		success = false;
-	}
-
-	if (success == false)
-	{
-		return NULL;
-	}
-
-	// Scrolling
-	properties.m_nextIncrement = 1;
-	properties.m_nextBase = 1;
-	if (properties.m_parameters.find(SearchPluginProperties::START_PAGE_PARAM) != properties.m_parameters.end())
-	{
-		properties.m_scrolling = SearchPluginProperties::PER_PAGE;
-	}
-	else
-	{
-		properties.m_scrolling = SearchPluginProperties::PER_INDEX;
-	}
-
-	return new OpenSearchResponseParser(rssResponse);
-}

Deleted: trunk/Search/OpenSearchParser.h
===================================================================
--- trunk/Search/OpenSearchParser.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/OpenSearchParser.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,69 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _OPENSEARCH_PARSER_H
-#define _OPENSEARCH_PARSER_H
-
-#include <string>
-
-#include "Document.h"
-#include "PluginParsers.h"
-
-/// Parses OpenSearch Response.
-class OpenSearchResponseParser : public ResponseParserInterface
-{
-	public:
-		OpenSearchResponseParser(bool rssResponse);
-		virtual ~OpenSearchResponseParser();
-
-		/// Parses the response; false if not all could be parsed.
-		virtual bool parse(const Document *pResponseDoc, std::vector<DocumentInfo> &resultsList,
-			unsigned int &totalResults, unsigned int &firstResultIndex) const;
-
-	protected:
-		bool m_rssResponse;
-
-	private:
-		OpenSearchResponseParser(const OpenSearchResponseParser &other);
-		OpenSearchResponseParser& operator=(const OpenSearchResponseParser& other);
-
-};
-
-/** A parser for OpenSearch Description and Query Syntax, version 1.1.
-  * See http://opensearch.a9.com/spec/1.1/description/
-  * and http://opensearch.a9.com/spec/1.1/querysyntax/
-  * It can also parse MozSearch plugins.
-  * See http://developer.mozilla.org/en/docs/Creating_MozSearch_plugins
-  */
-class OpenSearchParser : public PluginParserInterface
-{
-	public:
-		OpenSearchParser(const std::string &fileName);
-		virtual ~OpenSearchParser();
-
-		/// Parses the plugin and returns a response parser.
-		virtual ResponseParserInterface *parse(SearchPluginProperties &properties,
-			bool extractSearchParams = false);
-
-	private:
-		OpenSearchParser(const OpenSearchParser &other);
-		OpenSearchParser& operator=(const OpenSearchParser& other);
-
-};
-
-#endif // _OPENSEARCH_PARSER_H

Deleted: trunk/Search/PluginParsers.h
===================================================================
--- trunk/Search/PluginParsers.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/PluginParsers.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,69 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _PLUGIN_PARSERS_H
-#define _PLUGIN_PARSERS_H
-
-#include <string>
-#include <vector>
-
-#include "Document.h"
-#include "SearchPluginProperties.h"
-
-/// Interface implemented by response parsers.
-class ResponseParserInterface
-{
-	public:
-		virtual ~ResponseParserInterface()
-		{
-		}
-
-		/// Parses the response; false if not all could be parsed.
-		virtual bool parse(const Document *pResponseDoc, std::vector<DocumentInfo> &resultsList,
-			unsigned int &totalResults, unsigned int &firstResultIndex) const = 0;
-
-	protected:
-		ResponseParserInterface()
-		{
-		}
-		
-};
-	
-/// Interface implemented by plugin parsers.
-class PluginParserInterface
-{
-	public:
-		virtual ~PluginParserInterface()
-		{
-		}
-
-		/// Parses the plugin and returns a response parser.
-		virtual ResponseParserInterface *parse(SearchPluginProperties &properties,
-			bool extractSearchParams = false) = 0;
-
-	protected:
-		std::string m_fileName;
-
-		PluginParserInterface(const std::string &fileName) :
-			m_fileName(fileName)
-		{
-		}
-
-};
-
-#endif // _PLUGIN_PARSERS_H

Deleted: trunk/Search/PluginWebEngine.cpp
===================================================================
--- trunk/Search/PluginWebEngine.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/PluginWebEngine.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,340 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <algorithm>
-#include <fstream>
-#include <iostream>
-
-#include "config.h"
-#include "Document.h"
-#include "StringManip.h"
-#include "OpenSearchParser.h"
-#ifdef HAVE_BOOST_SPIRIT
-#include "SherlockParser.h"
-#endif
-#include "PluginWebEngine.h"
-
-using std::cout;
-using std::cerr;
-using std::endl;
-
-PluginWebEngine::PluginWebEngine(const string &fileName) :
-	WebEngine(),
-	m_pResponseParser(NULL)
-{
-	load(fileName);
-}
-
-PluginWebEngine::~PluginWebEngine()
-{
-	if (m_pResponseParser != NULL)
-	{
-		delete m_pResponseParser;
-	}
-}
-
-void PluginWebEngine::load(const string &fileName)
-{
-	if (fileName.empty() == true)
-	{
-		return;
-	}
-
-	PluginParserInterface *pParser = getPluginParser(fileName);
-	if (pParser == NULL)
-	{
-		return;
-	}
-
-	m_pResponseParser = pParser->parse(m_properties);
-	delete pParser;
-}
-
-bool PluginWebEngine::getPage(const string &formattedQuery, unsigned int maxResultsCount)
-{
-	if ((m_pResponseParser == NULL) ||
-		(formattedQuery.empty() == true))
-	{
-		return false;
-	}
-
-	DocumentInfo docInfo("Results Page", formattedQuery,
-		"text/html", "");
-	Document *pResponseDoc = downloadPage(docInfo);
-	if (pResponseDoc == NULL)
-	{
-		cerr << "PluginWebEngine::getPage: couldn't download "
-			<< formattedQuery << endl;
-		return false;
-	}
-
-	unsigned int contentLen;
-	const char *pContent = pResponseDoc->getData(contentLen);
-	if ((pContent == NULL) ||
-		(contentLen == 0))
-	{
-#ifdef DEBUG
-		cout << "PluginWebEngine::getPage: downloaded empty page" << endl;
-#endif
-		delete pResponseDoc;
-		return false;
-	}
-#ifdef DEBUG
-	ofstream pageBackup("PluginWebEngine.html");
-	pageBackup.write(pContent, contentLen);
-	pageBackup.close();
-#endif
-
-	bool success = m_pResponseParser->parse(pResponseDoc, m_resultsList,
-		maxResultsCount, m_properties.m_nextBase);
-	vector<DocumentInfo>::iterator resultIter = m_resultsList.begin();
-	while (resultIter != m_resultsList.end())
-	{
-		if (processResult(formattedQuery, *resultIter) == false)
-		{
-			// Remove this result
-			if (resultIter == m_resultsList.begin())
-			{
-				m_resultsList.erase(resultIter);
-				resultIter = m_resultsList.begin();
-			}
-			else
-			{
-				vector<DocumentInfo>::iterator badResultIter = resultIter;
-				--resultIter;
-				m_resultsList.erase(badResultIter);
-			}
-		}
-		else
-		{
-			// Next
-			++resultIter;
-		}
-	}
-
-	delete pResponseDoc;
-
-	return success;
-}
-
-PluginParserInterface *PluginWebEngine::getPluginParser(const string &fileName)
-{
-	if (fileName.empty() == true)
-	{
-		return NULL;
-	}
-
-	// What type of plugin is it ?
-	// Look at the file extension
-	string::size_type pos = fileName.find_last_of(".");
-	if (pos == string::npos)
-	{
-		// No way to tell
-		return NULL;
-	}
-
-	string extension(fileName.substr(pos + 1));
-#ifdef HAVE_BOOST_SPIRIT_CORE_HPP
-	if (strncasecmp(extension.c_str(), "src", 3) == 0)
-	{
-		return new SherlockParser(fileName);
-	}
-	else
-#endif
-	if (strncasecmp(extension.c_str(), "xml", 3) == 0)
-	{
-		return new OpenSearchParser(fileName);
-	}
-
-	return NULL;
-}
-
-bool PluginWebEngine::getDetails(const string &fileName, string &name, string &channel)
-{
-	if (fileName.empty() == true)
-	{
-		return false;
-	}
-
-	PluginParserInterface *pParser = getPluginParser(fileName);
-	if (pParser == NULL)
-	{
-		return false;
-	}
-
-	SearchPluginProperties properties;
-	ResponseParserInterface *pResponseParser = pParser->parse(properties, true);
-	if (pResponseParser == NULL)
-	{
-		cerr << "PluginWebEngine::getDetails: couldn't parse "
-			<< fileName << endl;
-		delete pParser;
-
-		return false;
-	}
-	delete pResponseParser;
-	delete pParser;
-
-	if (properties.m_response == SearchPluginProperties::UNKNOWN_RESPONSE)
-	{
-#ifdef DEBUG
-		cout << "PluginWebEngine::getDetails: bad response type for "
-			<< fileName << endl;
-#endif
-		return false;
-	}
-
-	name = properties.m_name;
-	channel = properties.m_channel;
-
-	return true;
-}
-
-//
-// Implementation of SearchEngineInterface
-//
-
-/// Runs a query; true if success.
-bool PluginWebEngine::runQuery(QueryProperties& queryProps,
-	unsigned int startDoc)
-{
-	string queryString(queryProps.getFreeQuery(true));
-	char countStr[64];
-	unsigned int maxResultsCount(queryProps.getMaximumResultsCount());
-	unsigned int currentIncrement = 0, count = 0;
-
-	m_resultsList.clear();
-	m_resultsCountEstimate = 0;
-
-	if (queryProps.getType() != QueryProperties::XAPIAN_QP)
-	{
-		cerr << "PluginWebEngine::runQuery: query type not supported" << endl;
-		return false;
-	}
-
-	if (queryString.empty() == true)
-	{
-#ifdef DEBUG
-		cout << "PluginWebEngine::runQuery: query is empty" << endl;
-#endif
-		return false;
-	}
-
-	map<SearchPluginProperties::Parameter, string>::iterator paramIter = m_properties.m_parameters.find(SearchPluginProperties::SEARCH_TERMS_PARAM);
-	if (paramIter == m_properties.m_parameters.end())
-	{
-#ifdef DEBUG
-		cout << "PluginWebEngine::runQuery: no user input tag" << endl;
-#endif
-		return false;
-	}
-
-	string userInputTag(paramIter->second);
-	string formattedQuery = m_properties.m_baseUrl;
-	formattedQuery += "?";
-	formattedQuery += userInputTag;
-	formattedQuery += "=";
-	formattedQuery += queryString;
-	if (m_properties.m_parametersRemainder.empty() == false)
-	{
-		formattedQuery += "&";
-		formattedQuery += m_properties.m_parametersRemainder;
-	}
-
-	setQuery(queryProps);
-
-#ifdef DEBUG
-	cout << "PluginWebEngine::runQuery: querying "
-		<< m_properties.m_name << endl;
-#endif
-	while (count < maxResultsCount)
-	{
-		string pageQuery(formattedQuery);
-
-		// How do we scroll ?
-		if (m_properties.m_scrolling == SearchPluginProperties::PER_INDEX)
-		{
-			paramIter = m_properties.m_parameters.find(SearchPluginProperties::COUNT_PARAM);
-			if (paramIter != m_properties.m_parameters.end())
-			{
-				// Number of results requested
-				pageQuery += "&";
-				pageQuery += paramIter->second;
-				pageQuery += "=";
-				snprintf(countStr, 64, "%u", maxResultsCount);
-				pageQuery += countStr;
-			}
-
-			paramIter = m_properties.m_parameters.find(SearchPluginProperties::START_INDEX_PARAM);
-			if (paramIter != m_properties.m_parameters.end())
-			{
-				// The offset of the first result (typically 1 or 0)
-				pageQuery += "&";
-				pageQuery += paramIter->second;
-				pageQuery += "=";
-				snprintf(countStr, 64, "%u", count + m_properties.m_nextBase);
-				pageQuery += countStr;
-			}
-		}
-		else
-		{
-			paramIter = m_properties.m_parameters.find(SearchPluginProperties::START_PAGE_PARAM);
-			if (paramIter != m_properties.m_parameters.end())
-			{
-				// The offset of the page
-				pageQuery += "&";
-				pageQuery += paramIter->second;
-				pageQuery += "=";
-				snprintf(countStr, 64, "%u", currentIncrement + m_properties.m_nextBase);
-				pageQuery += countStr;
-			}
-		}
-
-		if (getPage(pageQuery, queryProps.getMaximumResultsCount()) == false)
-		{
-			break;
-		}
-
-		if (m_properties.m_nextIncrement == 0)
-		{
-			// That one page should have all the results...
-#ifdef DEBUG
-			cout << "PluginWebEngine::runQuery: performed one off call" << endl;
-#endif
-			break;
-		}
-		else
-		{
-			if (m_resultsList.size() < count + m_properties.m_nextIncrement)
-			{
-				// We got less than the maximum number of results per page
-				// so there's no point in requesting the next page
-#ifdef DEBUG
-				cout << "PluginWebEngine::runQuery: last page wasn't full" << endl;
-#endif
-				break;
-			}
-
-			// Increase factor
-			currentIncrement += m_properties.m_nextIncrement;
-		}
-		count = m_resultsList.size();
-	}
-
-	return true;
-}

Deleted: trunk/Search/PluginWebEngine.h
===================================================================
--- trunk/Search/PluginWebEngine.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/PluginWebEngine.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,58 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _XML_WEB_ENGINE_H
-#define _XML_WEB_ENGINE_H
-
-#include <string>
-
-#include "PluginParsers.h"
-#include "SearchPluginProperties.h"
-#include "WebEngine.h"
-
-/// A plugin-based search engine.
-class PluginWebEngine : public WebEngine
-{
-	public:
-		PluginWebEngine(const std::string &fileName);
-		virtual ~PluginWebEngine();
-
-		/// Utility method that returns a search plugin's name and channel.
-		static bool getDetails(const std::string &fileName, std::string &name, std::string &channel);
-
-		/// Runs a query; true if success.
-		virtual bool runQuery(QueryProperties& queryProps,
-			unsigned int startDoc = 0);
-
-	protected:
-		SearchPluginProperties m_properties;
-		ResponseParserInterface *m_pResponseParser;
-
-		void load(const std::string &fileName);
-
-		bool getPage(const std::string &formattedQuery, unsigned int maxResultsCount);
-
-		static PluginParserInterface *getPluginParser(const std::string &fileName);
-
-	private:
-		PluginWebEngine(const PluginWebEngine &other);
-		PluginWebEngine &operator=(const PluginWebEngine &other);
-
-};
-
-#endif // _XML_WEB_ENGINE_H

Deleted: trunk/Search/QueryProperties.cpp
===================================================================
--- trunk/Search/QueryProperties.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/QueryProperties.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,292 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <ctype.h>
-#include <set>
-#include <iostream>
-#include <algorithm>
-#include <utility>
-
-#include "Tokenizer.h"
-#include "QueryProperties.h"
-
-QueryProperties::QueryProperties() :
-	m_type(XAPIAN_QP),
-	m_order(RELEVANCE),
-	m_resultsCount(10),
-	m_indexResults(false)
-{
-}
-
-QueryProperties::QueryProperties(const string &name, const string &freeQuery,
-	QueryType type) :
-	m_name(name),
-	m_type(type),
-	m_order(RELEVANCE),
-	m_freeQuery(freeQuery),
-	m_resultsCount(10),
-	m_indexResults(false)
-{
-	removeFilters();
-}
-
-QueryProperties::QueryProperties(const QueryProperties &other) :
-	m_name(other.m_name),
-	m_type(other.m_type),
-	m_order(other.m_order),
-	m_freeQuery(other.m_freeQuery),
-	m_freeQueryWithoutFilters(other.m_freeQueryWithoutFilters),
-	m_resultsCount(other.m_resultsCount),
-	m_indexResults(other.m_indexResults),
-	m_labelName(other.m_labelName)
-{
-}
-
-QueryProperties::~QueryProperties()
-{
-}
-
-QueryProperties &QueryProperties::operator=(const QueryProperties &other)
-{
-	if (this != &other)
-	{
-		m_name = other.m_name;
-		m_type = other.m_type;
-		m_order = other.m_order;
-		m_freeQuery = other.m_freeQuery;
-		m_freeQueryWithoutFilters = other.m_freeQueryWithoutFilters;
-		m_resultsCount = other.m_resultsCount;
-		m_indexResults = other.m_indexResults;
-		m_labelName = other.m_labelName;
-	}
-
-	return *this;
-}
-
-bool QueryProperties::operator==(const QueryProperties &other) const
-{
-	if (m_name == other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-bool QueryProperties::operator<(const QueryProperties &other) const
-{
-	if (m_name < other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-void QueryProperties::removeFilters(void)
-{
-	m_freeQueryWithoutFilters.clear();
-
-	if (m_freeQuery.empty() == true)
-	{
-		return;
-	}
-
-	if (m_type != XAPIAN_QP)
-	{
-		m_freeQueryWithoutFilters = m_freeQuery.substr(0, min(20, (int)m_freeQuery.length()));
-		return;
-	}
-
-	Document doc;
-
-	doc.setData(m_freeQuery.c_str(), m_freeQuery.length());
-	Tokenizer tokens(&doc);
-
-	string token;
-	while (tokens.nextToken(token) == true)
-	{
-		if ((token.find(':') != string::npos) ||
-			(token.find("..") != string::npos))
-		{
-			// It's a filter or a range
-			continue;
-		}
-
-		if (m_freeQueryWithoutFilters.empty() == false)
-		{
-			m_freeQueryWithoutFilters += " ";
-		}
-		m_freeQueryWithoutFilters += token;
-	}
-}
-
-/// Sets the name.
-void QueryProperties::setName(const string &name)
-{
-	m_name = name;
-}
-
-/// Gets the name.
-string QueryProperties::getName(void) const
-{
-	return m_name;
-}
-
-/// Sets the type.
-void QueryProperties::setType(QueryType type)
-{
-	m_type = type;
-}
-
-/// Gets the type.
-QueryProperties::QueryType QueryProperties::getType(void) const
-{
-	return m_type;
-}
-
-/// Sets the sort order.
-void QueryProperties::setSortOrder(SortOrder order)
-{
-	m_order = order;
-}
-
-/// Gets the sort order.
-QueryProperties::SortOrder QueryProperties::getSortOrder(void) const
-{
-	return m_order;
-}
-
-/// Sets the query string.
-void QueryProperties::setFreeQuery(const string &freeQuery)
-{
-	m_freeQuery = freeQuery;
-	removeFilters();
-}
-
-/// Gets the query string.
-string QueryProperties::getFreeQuery(bool withoutFilters) const
-{
-	if (withoutFilters == false)
-	{
-		return m_freeQuery;
-	}
-
-#ifdef DEBUG
-	cout << "QueryProperties::getFreeQuery: " << m_freeQueryWithoutFilters << endl;
-#endif
-	return m_freeQueryWithoutFilters;
-}
-
-/// Gets the value of a specific filter.
-string QueryProperties::getFilter(const string &filterStr)
-{
-	if ((m_freeQuery.empty() == true) ||
-		(filterStr.empty() == true))
-	{
-		return "";
-	}
-
-	Document doc;
-
-	doc.setData(m_freeQuery.c_str(), m_freeQuery.length());
-	Tokenizer tokens(&doc, true);
-
-	string token;
-	while (tokens.nextToken(token) == true)
-	{
-		string::size_type langPos = token.find(filterStr + ":");
-
-		// Is it the language filter ?
-		if (langPos != string::npos)
-		{
-			string filterValue(token.substr(langPos + filterStr.length() + 1));
-
-#ifdef DEBUG
-			cout << "QueryProperties::getFilter: " << filterStr << "=" << filterValue << endl;
-#endif
-			return filterValue;
-		}
-	}
-
-	return "";
-}
-
-/// Sets the maximum number of results.
-void QueryProperties::setMaximumResultsCount(unsigned int count)
-{
-	m_resultsCount = count;
-}
-
-/// Gets the maximum number of results.
-unsigned int QueryProperties::getMaximumResultsCount(void) const
-{
-	return m_resultsCount;
-}
-
-/// Sets whether results should be indexed.
-void QueryProperties::setIndexResults(bool index)
-{
-	m_indexResults = index;
-}
-
-/// Gets whether results should be indexed
-bool QueryProperties::getIndexResults(void) const
-{
-	return m_indexResults;
-}
-
-/// Sets the name of the label to use for indexed documents.
-void QueryProperties::setLabelName(const string &labelName)
-{
-	m_labelName = labelName;
-}
-
-/// Gets the name of the label to use for indexed documents.
-string QueryProperties::getLabelName(void) const
-{
-	return m_labelName;
-}
-
-/// Returns the query's terms.
-void QueryProperties::getTerms(set<string> &terms) const
-{
-	Document doc;
-
-	doc.setData(m_freeQueryWithoutFilters.c_str(), m_freeQueryWithoutFilters.length());
-	Tokenizer tokens(&doc);
-
-	terms.clear();
-
-	string token;
-	while (tokens.nextToken(token) == true)
-	{
-		terms.insert(token);
-	}
-}
-
-/// Returns whether the query is empty.
-bool QueryProperties::isEmpty() const
-{
-	if (m_freeQuery.empty() == true)
-	{
-		return true;
-	}
-
-	return false;
-}

Deleted: trunk/Search/QueryProperties.h
===================================================================
--- trunk/Search/QueryProperties.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/QueryProperties.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,102 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _QUERY_PROPERTIES_H
-#define _QUERY_PROPERTIES_H
-
-#include <string>
-#include <set>
-
-using namespace std;
-
-/// This represents a query.
-class QueryProperties
-{
-	public:
-		typedef enum { XAPIAN_QP = 0, XESAM_QL, XESAM_UL } QueryType;
-		typedef enum { RELEVANCE = 0, DATE } SortOrder;
-
-		QueryProperties();
-		QueryProperties(const string &name, const string &freeQuery,
-			QueryType type = XAPIAN_QP);
-		QueryProperties(const QueryProperties &other);
-		~QueryProperties();
-
-		QueryProperties &operator=(const QueryProperties &other);
-		bool operator==(const QueryProperties &other) const;
-		bool operator<(const QueryProperties &other) const;
-
-		/// Sets the name.
-		void setName(const string &name);
-		/// Gets the name.
-		string getName(void) const;
-
-		/// Sets the type.
-		void setType(QueryType type);
-		/// Gets the type.
-		QueryType getType(void) const;
-
-		/// Sets the sort order.
-		void setSortOrder(SortOrder order);
-		/// Gets the sort order.
-		SortOrder getSortOrder(void) const;
-
-		/// Sets the query string.
-		void setFreeQuery(const string &freeQuery);
-		/// Gets the query string.
-		string getFreeQuery(bool withoutFilters = false) const;
-
-		/// Gets the value of a specific filter.
-		string getFilter(const string &filterStr);
-
-		/// Sets the maximum number of results.
-		void setMaximumResultsCount(unsigned int count);
-		/// Gets the maximum number of results.
-		unsigned int getMaximumResultsCount(void) const;
-
-		/// Sets whether results should be indexed.
-		void setIndexResults(bool index);
-		/// Gets whether results should be indexed
-		bool getIndexResults(void) const;
-
-		/// Sets the name of the label to use for indexed documents.
-		void setLabelName(const string &labelName);
-		/// Gets the name of the label to use for indexed documents.
-		string getLabelName(void) const;
-
-		/// Returns the query's terms.
-		void getTerms(set<string> &terms) const;
-
-		/// Returns whether the query is empty.
-		bool isEmpty() const;
-
-	protected:
-		string m_name;
-		QueryType m_type;
-		SortOrder m_order;
-		string m_freeQuery;
-		string m_freeQueryWithoutFilters;
-		unsigned int m_resultsCount;
-		bool m_indexResults;
-		string m_labelName;
-
-		void removeFilters(void);
-
-};
-
-#endif // _QUERY_PROPERTIES_H

Deleted: trunk/Search/ResultsExporter.cpp
===================================================================
--- trunk/Search/ResultsExporter.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/ResultsExporter.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,275 +0,0 @@
-/*
- *  Copyright 2007 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <iostream>
-#include <fstream>
-#include <libxml++/parsers/domparser.h>
-#include <libxml++/nodes/node.h>
-#include <libxml++/nodes/textnode.h>
-
-#include "StringManip.h"
-#include "FilterUtils.h"
-#include "ResultsExporter.h"
-
-using std::string;
-using std::vector;
-using std::ofstream;
-using std::endl;
-using xmlpp::Element;
-
-static Element *addChildElement(Element *pElem, const string &nodeName, const string &nodeContent)
-{
-	if (pElem == NULL)
-	{
-		return NULL;
-	}
-
-	Element *pSubElem = pElem->add_child(nodeName);
-	if (pSubElem != NULL)
-	{
-#ifdef HAS_LIBXMLPP026
-		pSubElem->set_child_content(nodeContent);
-#else
-		pSubElem->set_child_text(nodeContent);
-#endif
-	}
-
-	return pSubElem;
-}
-
-ResultsExporter::ResultsExporter(const string &fileName,
-	const QueryProperties &queryProps) :
-	m_fileName(fileName),
-	m_queryName(queryProps.getName()),
-	m_queryDetails(queryProps.getFreeQuery())
-{
-}
-
-ResultsExporter::~ResultsExporter()
-{
-}
-
-CSVExporter::CSVExporter(const string &fileName,
-	const QueryProperties &queryProps) :
-	ResultsExporter(fileName, queryProps)
-{
-}
-
-CSVExporter::~CSVExporter()
-{
-}
-
-bool CSVExporter::exportResults(const string &engineName, unsigned int maxResultsCount,
-	const vector<DocumentInfo> &resultsList)
-{
-	if ((resultsList.empty() == true) ||
-		(exportStart(engineName, maxResultsCount) == false))
-	{
-		return false;
-	}
-
-	for (vector<DocumentInfo>::const_iterator iter = resultsList.begin();
-		iter != resultsList.end(); ++iter)
-	{
-		exportResult(engineName, *iter);
-	}
-	exportEnd();
-
-	return true;
-}
-
-bool CSVExporter::exportStart(const string &engineName, unsigned int maxResultsCount)
-{
-	if (m_fileName.empty() == true)
-	{
-		return false;
-	}
-
-	m_outputFile.open(m_fileName.c_str());
-	if (m_outputFile.good() == false)
-	{
-		m_outputFile.close();
-
-		return false;
-	}
-
-	m_outputFile << "\"query\";\"engine\";\"caption\";\"url\";\"type\";\"language\";\"modtime\";\"size\";\"abstract\"" << endl;
-
-	return true;
-}
-
-bool CSVExporter::exportResult(const string &engineName, const DocumentInfo &docInfo)
-{
-	string title(FilterUtils::stripMarkup(docInfo.getTitle()));
-	string extract(FilterUtils::stripMarkup(docInfo.getExtract()));
-
-	if (m_outputFile.good() == false)
-	{
-		return false;
-	}
-
-	// Double double-quotes
-	m_outputFile << "\"" << StringManip::replaceSubString(m_queryName, "\"", "\"\"")
-		<< "\";\"" << StringManip::replaceSubString(engineName, "\"", "\"\"")
-		<< "\";\"" << StringManip::replaceSubString(title, "\"", "\"\"")
-		<< "\";\"" << StringManip::replaceSubString(docInfo.getLocation(), "\"", "\"\"")
-		<< "\";\"" << StringManip::replaceSubString(docInfo.getType(), "\"", "\"\"")
-		<< "\";\"" << StringManip::replaceSubString(docInfo.getLanguage(), "\"", "\"\"")
-		<< "\";\"" << StringManip::replaceSubString(docInfo.getTimestamp(), "\"", "\"\"")
-		<< "\";\"" << docInfo.getSize()
-		<< "\";\"" << StringManip::replaceSubString(extract, "\"", "\"\"")
-		<< "\"" << endl;
-
-	return true;
-}
-
-void CSVExporter::exportEnd(void)
-{
-	m_outputFile.close();
-}
-
-OpenSearchExporter::OpenSearchExporter(const string &fileName,
-	const QueryProperties &queryProps) :
-	ResultsExporter(fileName, queryProps),
-	m_pDoc(NULL),
-	m_pChannelElem(NULL)
-{
-}
-
-OpenSearchExporter::~OpenSearchExporter()
-{
-}
-
-bool OpenSearchExporter::exportResults(const string &engineName, unsigned int maxResultsCount,
-	const vector<DocumentInfo> &resultsList)
-{
-	if ((resultsList.empty() == true) ||
-		(exportStart(engineName, maxResultsCount) == false))
-	{
-		return false;
-	}
-
-	for (vector<DocumentInfo>::const_iterator iter = resultsList.begin();
-		iter != resultsList.end(); ++iter)
-	{
-		exportResult(engineName, *iter);
-	}
-	exportEnd();
-
-	return true;
-}
-
-bool OpenSearchExporter::exportStart(const string &engineName, unsigned int maxResultsCount)
-{
-	if (m_fileName.empty() == true)
-	{
-		return false;
-	}
-
-	if (m_pDoc != NULL)
-	{
-		delete m_pDoc;
-		m_pDoc = NULL;
-		m_pChannelElem = NULL;
-	}
-
-	Element *pRootElem = NULL;
-	string description("Search");
-	char numStr[64];
-
-	m_pDoc = new xmlpp::Document("1.0");
-
-	// Create a new node
-	pRootElem = m_pDoc->create_root_node("rss");
-	if (pRootElem == NULL)
-	{
-		return false;
-	}
-	pRootElem->set_attribute("version", "2.0");
-	pRootElem->set_attribute("xmlns:opensearch", "http://a9.com/-/spec/opensearch/1.1/");
-	pRootElem->set_attribute("xmlns:atom", "http://www.w3.org/2005/Atom");
-
-	// User interface position and size
-	m_pChannelElem = pRootElem->add_child("channel");
-	if (m_pChannelElem == NULL)
-	{
-		return false;
-	}
-	if (m_queryName.empty() == false)
-	{
-		addChildElement(m_pChannelElem, "title", m_queryName);
-	}
-	if (m_queryName.empty() == false)
-	{
-		description += " for \"";
-		description += m_queryName;
-		description += "\"";
-	}
-	if (engineName.empty() == false)
-	{
-		description += " on ";
-		description += engineName;
-	}
-	addChildElement(m_pChannelElem, "description", description);
-	sprintf(numStr, "%d", maxResultsCount);
-	addChildElement(m_pChannelElem, "opensearch:totalResults", numStr);
-	addChildElement(m_pChannelElem, "opensearch:itemsPerPage", numStr);
-	if (m_queryDetails.empty() == false)
-	{
-		Element *pQueryElem = addChildElement(m_pChannelElem, "opensearch:Query", "");
-		if (pQueryElem != NULL)
-		{
-			pQueryElem->set_attribute("role", "request");
-			pQueryElem->set_attribute("searchTerms", m_queryDetails);
-			pQueryElem->set_attribute("startPage", "1");
-		}
-	}
-
-	return true;
-}
-
-bool OpenSearchExporter::exportResult(const string &engineName, const DocumentInfo &docInfo)
-{
-	if (m_pChannelElem == NULL)
-	{
-		return false;
-	}
-
-	Element *pElem = m_pChannelElem->add_child("item");
-	addChildElement(pElem, "title", docInfo.getTitle());
-	addChildElement(pElem, "link", docInfo.getLocation());
-	addChildElement(pElem, "description", FilterUtils::stripMarkup(docInfo.getExtract()));
-
-	return true;
-}
-
-void OpenSearchExporter::exportEnd(void)
-{
-	if (m_pDoc == NULL)
-	{
-		return;
-	}
-
-	// Save to file
-	m_pDoc->write_to_file_formatted(m_fileName);
-
-	m_pChannelElem = NULL;
-	delete m_pDoc;
-	m_pDoc = NULL;
-}
-

Deleted: trunk/Search/ResultsExporter.h
===================================================================
--- trunk/Search/ResultsExporter.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/ResultsExporter.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,133 +0,0 @@
-/*
- *  Copyright 2007 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _RESULTS_EXPORTER_H
-#define _RESULTS_EXPORTER_H
-
-#include <string>
-#include <vector>
-#include <fstream>
-#include <libxml++/document.h>
-#include <libxml++/nodes/element.h>
-
-#include "DocumentInfo.h"
-#include "QueryProperties.h"
-
-/// Exports results to a given format.
-class ResultsExporter
-{
-	public:
-		ResultsExporter(const std::string &fileName,
-			const QueryProperties &queryProps);
-		virtual ~ResultsExporter();
-
-		/// Exports a list of results.
-		virtual bool exportResults(const std::string &engineName,
-			unsigned int maxResultsCount,
-			const std::vector<DocumentInfo> &resultsList) = 0;
-
-		/// Starts export.
-		virtual bool exportStart(const std::string &engineName,
-			unsigned int maxResultsCount) = 0;
-
-		/// Exports the given result.
-		virtual bool exportResult(const std::string &engineName,
-			const DocumentInfo &docInfo) = 0;
-
-		/// Ends export.
-		virtual void exportEnd(void) = 0;
-
-	protected:
-		std::string m_fileName;
-		std::string m_queryName;
-		std::string m_queryDetails;
-
-	private:
-		ResultsExporter(const ResultsExporter &other);
-		ResultsExporter& operator=(const ResultsExporter& other);
-
-};
-
-/// Exports results to CSV.
-class CSVExporter : public ResultsExporter
-{
-	public:
-		CSVExporter(const std::string &fileName,
-			const QueryProperties &queryProps);
-		virtual ~CSVExporter();
-
-		/// Exports the results; false if an error occured.
-		virtual bool exportResults(const std::string &engineName,
-			unsigned int maxResultsCount,
-			const std::vector<DocumentInfo> &resultsList);
-
-		/// Starts export.
-		virtual bool exportStart(const std::string &engineName,
-			unsigned int maxResultsCount);
-
-		/// Exports the given result.
-		virtual bool exportResult(const std::string &engineName,
-			const DocumentInfo &docInfo);
-
-		/// Ends export.
-		virtual void exportEnd(void);
-
-	protected:
-		std::ofstream m_outputFile;
-
-	private:
-		CSVExporter(const CSVExporter &other);
-		CSVExporter& operator=(const CSVExporter& other);
-
-};
-
-/// Exports results to OpenSearch response. 
-class OpenSearchExporter : public ResultsExporter
-{
-	public:
-		OpenSearchExporter(const std::string &fileName,
-			const QueryProperties &queryProps);
-		virtual ~OpenSearchExporter();
-
-		/// Exports the results; false if an error occured.
-		virtual bool exportResults(const std::string &engineName,
-			unsigned int maxResultsCount,
-			const std::vector<DocumentInfo> &resultsList);
-
-		/// Starts export.
-		virtual bool exportStart(const std::string &engineName,
-			unsigned int maxResultsCount);
-
-		/// Exports the given result.
-		virtual bool exportResult(const std::string &engineName,
-			const DocumentInfo &docInfo);
-
-		/// Ends export.
-		virtual void exportEnd(void);
-
-	protected:
-		xmlpp::Document *m_pDoc;
-		xmlpp::Element *m_pChannelElem;
-
-	private:
-		OpenSearchExporter(const OpenSearchExporter &other);
-		OpenSearchExporter& operator=(const OpenSearchExporter& other);
-
-};
-
-#endif // _RESULTS_EXPORTER_H

Deleted: trunk/Search/SOAPEnv.h
===================================================================

Deleted: trunk/Search/SOAPEnvH.h
===================================================================
--- trunk/Search/SOAPEnvH.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SOAPEnvH.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,201 +0,0 @@
-/* SOAPEnvH.h
-   Generated by gSOAP 2.7.9e from SOAPEnv.h
-   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
-   This part of the software is released under one of the following licenses:
-   GPL, the gSOAP public license, or Genivia's license for commercial use.
-*/
-
-#ifndef SOAPEnvH_H
-#define SOAPEnvH_H
-#include "SOAPEnvStub.h"
-#ifndef WITH_NOIDREF
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap*, const void*, int);
-SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap*, const void*, const char*, int, int);
-SOAP_FMAC3 void *SOAP_FMAC4 soap_getelement(struct soap*, int*);
-
-#ifdef __cplusplus
-}
-#endif
-SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap*);
-#endif
-SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap*);
-
-SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap*, int, const char*, const char*, size_t*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist*);
-SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap*, const char*, void*, int, size_t, const char*, const char*);
-
-#ifndef SOAP_TYPE_byte
-#define SOAP_TYPE_byte (2)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap*, char *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap*, const char *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap*, const char*, int, const char *, const char*);
-SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap*, char *, const char*, const char*);
-SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap*, const char*, char *, const char*);
-
-#ifndef SOAP_TYPE_int
-#define SOAP_TYPE_int (1)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap*, int *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap*, const int *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap*, const char*, int, const int *, const char*);
-SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap*, int *, const char*, const char*);
-SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap*, const char*, int *, const char*);
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_SOAP_ENV__Fault
-#define SOAP_TYPE_SOAP_ENV__Fault (13)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap*, const char*, int, const struct SOAP_ENV__Fault *, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap*, const char*, struct SOAP_ENV__Fault *, const char*);
-SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap*, int);
-SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault*);
-SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
-SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap*, int, int, void*, size_t, const void*, size_t);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_SOAP_ENV__Reason
-#define SOAP_TYPE_SOAP_ENV__Reason (12)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap*, const char*, int, const struct SOAP_ENV__Reason *, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason *, const char*);
-SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap*, int);
-SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason*);
-SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
-SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap*, int, int, void*, size_t, const void*, size_t);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_SOAP_ENV__Detail
-#define SOAP_TYPE_SOAP_ENV__Detail (11)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap*, const char*, int, const struct SOAP_ENV__Detail *, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail *, const char*);
-SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap*, int);
-SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail*);
-SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
-SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap*, int, int, void*, size_t, const void*, size_t);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_SOAP_ENV__Code
-#define SOAP_TYPE_SOAP_ENV__Code (9)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap*, const char*, int, const struct SOAP_ENV__Code *, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code *, const char*);
-SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap*, int);
-SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code*);
-SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
-SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap*, int, int, void*, size_t, const void*, size_t);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_SOAP_ENV__Header
-#define SOAP_TYPE_SOAP_ENV__Header (8)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap*, const char*, int, const struct SOAP_ENV__Header *, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap*, const char*, struct SOAP_ENV__Header *, const char*);
-SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap*, int);
-SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header*);
-SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
-SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap*, int, int, void*, size_t, const void*, size_t);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
-#define SOAP_TYPE_PointerToSOAP_ENV__Reason (15)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap*, const char *, int, struct SOAP_ENV__Reason *const*, const char *);
-SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason **, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason **, const char*);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
-#define SOAP_TYPE_PointerToSOAP_ENV__Detail (14)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap*, const char *, int, struct SOAP_ENV__Detail *const*, const char *);
-SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail **, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail **, const char*);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
-#define SOAP_TYPE_PointerToSOAP_ENV__Code (10)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap*, const char *, int, struct SOAP_ENV__Code *const*, const char *);
-SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code **, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code **, const char*);
-
-#endif
-
-#ifndef SOAP_TYPE__QName
-#define SOAP_TYPE__QName (5)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap*, char **);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap*, char *const*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap*, char *const*, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap*, const char*, int, char*const*, const char*);
-SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap*, char **, const char*, const char*);
-SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap*, const char*, char **, const char*);
-
-#ifndef SOAP_TYPE_string
-#define SOAP_TYPE_string (3)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap*, char **);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap*, char *const*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap*, char *const*, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap*, const char*, int, char*const*, const char*);
-SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap*, char **, const char*, const char*);
-SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap*, const char*, char **, const char*);
-
-#endif
-
-/* End of SOAPEnvH.h */

Deleted: trunk/Search/SOAPEnvNS.cpp
===================================================================
--- trunk/Search/SOAPEnvNS.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SOAPEnvNS.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1 +0,0 @@
-struct Namespace *namespaces;

Deleted: trunk/Search/SOAPEnvStub.h
===================================================================
--- trunk/Search/SOAPEnvStub.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SOAPEnvStub.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,151 +0,0 @@
-/* SOAPEnvStub.h
-   Generated by gSOAP 2.7.9e from SOAPEnv.h
-   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
-   This part of the software is released under one of the following licenses:
-   GPL, the gSOAP public license, or Genivia's license for commercial use.
-*/
-
-#ifndef SOAPEnvStub_H
-#define SOAPEnvStub_H
-#include "stdsoap2.h"
-
-/******************************************************************************\
- *                                                                            *
- * Enumerations                                                               *
- *                                                                            *
-\******************************************************************************/
-
-
-/******************************************************************************\
- *                                                                            *
- * Classes and Structs                                                        *
- *                                                                            *
-\******************************************************************************/
-
-
-#ifndef SOAP_TYPE_SOAP_ENV__Header
-#define SOAP_TYPE_SOAP_ENV__Header (8)
-/* SOAP Header: */
-struct SOAP_ENV__Header
-{
-public:
-	void *dummy;	/* transient */
-};
-#endif
-
-#ifndef SOAP_TYPE_SOAP_ENV__Code
-#define SOAP_TYPE_SOAP_ENV__Code (9)
-/* SOAP Fault Code: */
-struct SOAP_ENV__Code
-{
-public:
-	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
-	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
-};
-#endif
-
-#ifndef SOAP_TYPE_SOAP_ENV__Detail
-#define SOAP_TYPE_SOAP_ENV__Detail (11)
-/* SOAP-ENV:Detail */
-struct SOAP_ENV__Detail
-{
-public:
-	int __type;	/* any type of element <fault> (defined below) */
-	void *fault;	/* transient */
-	char *__any;
-};
-#endif
-
-#ifndef SOAP_TYPE_SOAP_ENV__Reason
-#define SOAP_TYPE_SOAP_ENV__Reason (12)
-/* SOAP-ENV:Reason */
-struct SOAP_ENV__Reason
-{
-public:
-	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
-};
-#endif
-
-#ifndef SOAP_TYPE_SOAP_ENV__Fault
-#define SOAP_TYPE_SOAP_ENV__Fault (13)
-/* SOAP Fault: */
-struct SOAP_ENV__Fault
-{
-public:
-	char *faultcode;	/* optional element of type xsd:QName */
-	char *faultstring;	/* optional element of type xsd:string */
-	char *faultactor;	/* optional element of type xsd:string */
-	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
-	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
-	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
-	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
-	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
-	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
-};
-#endif
-
-/******************************************************************************\
- *                                                                            *
- * Types with Custom Serializers                                              *
- *                                                                            *
-\******************************************************************************/
-
-
-/******************************************************************************\
- *                                                                            *
- * Typedefs                                                                   *
- *                                                                            *
-\******************************************************************************/
-
-#ifndef SOAP_TYPE__XML
-#define SOAP_TYPE__XML (4)
-typedef char *_XML;
-#endif
-
-#ifndef SOAP_TYPE__QName
-#define SOAP_TYPE__QName (5)
-typedef char *_QName;
-#endif
-
-
-/******************************************************************************\
- *                                                                            *
- * Typedef Synonyms                                                           *
- *                                                                            *
-\******************************************************************************/
-
-
-/******************************************************************************\
- *                                                                            *
- * Externals                                                                  *
- *                                                                            *
-\******************************************************************************/
-
-
-/******************************************************************************\
- *                                                                            *
- * Service Operations                                                         *
- *                                                                            *
-\******************************************************************************/
-
-
-/******************************************************************************\
- *                                                                            *
- * Stubs                                                                      *
- *                                                                            *
-\******************************************************************************/
-
-
-/******************************************************************************\
- *                                                                            *
- * Skeletons                                                                  *
- *                                                                            *
-\******************************************************************************/
-
-SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);
-
-SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);
-
-#endif
-
-/* End of SOAPEnvStub.h */

Deleted: trunk/Search/SearchEngineFactory.cpp
===================================================================
--- trunk/Search/SearchEngineFactory.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SearchEngineFactory.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,106 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifdef HAVE_GOOGLEAPI
-#include "GoogleAPIEngine.h"
-#endif
-#include "PluginWebEngine.h"
-#include "XapianEngine.h"
-#include "SearchEngineFactory.h"
-
-SearchEngineFactory::SearchEngineFactory()
-{
-}
-
-SearchEngineFactory::~SearchEngineFactory()
-{
-}
-
-SearchEngineInterface *SearchEngineFactory::getSearchEngine(const string &type, const string &option)
-{
-	SearchEngineInterface *myEngine = NULL;
-
-	// Choice by type
-	if ((type == "sherlock") ||
-		(type == "opensearch"))
-	{
-		myEngine = new PluginWebEngine(option);
-	}
-	else if (type == "xapian")
-	{
-		myEngine = new XapianEngine(option);
-	}
-#ifdef HAVE_GOOGLEAPI
-	else if (type == "googleapi")
-	{
-		myEngine = new GoogleAPIEngine(option);
-	}
-#endif
-
-	return myEngine;
-}
-
-string SearchEngineFactory::getSearchEngineName(const string &type, const string &option)
-{
-	if ((type == "sherlock") ||
-		(type == "opensearch"))
-	{
-		string name, channel;
-
-		if (PluginWebEngine::getDetails(option, name, channel) == true)
-		{
-			return name;
-		}
-
-		return "";
-	}
-	else if (type == "xapian")
-	{
-		return option;
-	}
-
-	return type;
-}
-
-void SearchEngineFactory::getSupportedEngines(set<string> &engines)
-{
-	engines.clear();
-
-	// List supported engines
-	engines.insert("sherlock");
-	engines.insert("opensearch");
-	engines.insert("xapian");
-#ifdef HAVE_GOOGLEAPI
-	engines.insert("googleapi");
-#endif
-}
-
-bool SearchEngineFactory::isSupported(const string &type)
-{
-	if (
-#ifdef HAVE_GOOGLEAPI
-		(type == "googleapi") ||
-#endif
-		(type == "sherlock") ||
-		(type == "xapian"))
-	{
-		return true;
-	}
-
-	return false;	
-}

Deleted: trunk/Search/SearchEngineFactory.h
===================================================================
--- trunk/Search/SearchEngineFactory.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SearchEngineFactory.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,59 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _SEARCHENGINE_FACTORY_H
-#define _SEARCHENGINE_FACTORY_H
-
-#include <string>
-#include <map>
-#include <set>
-
-#include "SearchEngineInterface.h"
-
-using std::string;
-using std::map;
-using std::set;
-
-/// Factory for search engines.
-class SearchEngineFactory
-{
-	public:
-		virtual ~SearchEngineFactory();
-
-		/// Returns a SearchEngine of the specified type; NULL if unavailable.
-		static SearchEngineInterface *getSearchEngine(const string &type, const string &option);
-
-		/// Returns the name of the given engine.
-		static string getSearchEngineName(const string &type, const string &option);
-
-		/// Returns all supported engines.
-		static void getSupportedEngines(set<string> &engines);
-
-		/// Indicates whether a search engine is supported or not.
-		static bool isSupported(const string &type);
-
-	protected:
-		SearchEngineFactory();
-
-	private:
-		SearchEngineFactory(const SearchEngineFactory &other);
-		SearchEngineFactory &operator=(const SearchEngineFactory &other);
-
-};
-
-#endif // _SEARCHENGINE_FACTORY_H

Deleted: trunk/Search/SearchEngineInterface.cpp
===================================================================
--- trunk/Search/SearchEngineInterface.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SearchEngineInterface.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,93 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <iostream>
-
-#include "Document.h"
-#include "StringManip.h"
-#include "Url.h"
-#include "SearchEngineInterface.h"
-
-using std::cout;
-using std::endl;
-
-SearchEngineInterface::SearchEngineInterface() :
-	m_defaultOperator(DEFAULT_OP_AND),
-	m_resultsCountEstimate(0)
-{
-}
-
-SearchEngineInterface::~SearchEngineInterface()
-{
-}
-
-/// Sets whether AND is the default operator.
-void SearchEngineInterface::setDefaultOperator(DefaultOperator op)
-{
-	m_defaultOperator = op;
-}
-
-/// Sets the set of documents to limit to.
-bool SearchEngineInterface::setLimitSet(const set<string> &docsSet)
-{
-	// Not all engines support this
-	return false;
-}
-
-/// Sets the set of documents to expand from.
-bool SearchEngineInterface::setExpandSet(const set<string> &docsSet)
-{
-	// Not all engines support this
-	return false;
-}
-
-/// Returns the downloader used if any.
-DownloaderInterface *SearchEngineInterface::getDownloader(void)
-{
-	return NULL;
-}
-
-/// Returns the results for the previous query.
-const vector<DocumentInfo> &SearchEngineInterface::getResults(void) const
-{
-	return m_resultsList;
-}
-
-/// Returns an estimate of the total number of results for the previous query.
-unsigned int SearchEngineInterface::getResultsCountEstimate(void) const
-{
-	return m_resultsCountEstimate;
-}
-
-/// Returns the charset for the previous query's results.
-string SearchEngineInterface::getResultsCharset(void) const
-{
-	return m_charset;
-}
-
-/// Suggests a spelling correction.
-string SearchEngineInterface::getSpellingCorrection(void) const
-{
-	return m_correctedFreeQuery;
-}
-
-/// Returns expand terms from the previous query.
-const set<string> &SearchEngineInterface::getExpandTerms(void) const
-{
-	return m_expandTerms;
-}

Deleted: trunk/Search/SearchEngineInterface.h
===================================================================
--- trunk/Search/SearchEngineInterface.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SearchEngineInterface.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,88 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _SEARCH_ENGINE_INTERFACE_H
-#define _SEARCH_ENGINE_INTERFACE_H
-
-#include <time.h>
-#include <string>
-#include <set>
-#include <vector>
-
-#include "DownloaderInterface.h"
-#include "QueryProperties.h"
-#include "DocumentInfo.h"
-
-using namespace std;
-
-/// Interface implemented by search engines.
-class SearchEngineInterface
-{
-	public:
-		typedef enum { DEFAULT_OP_AND = 0, DEFAULT_OP_OR } DefaultOperator;
-
-		virtual ~SearchEngineInterface();
-
-		/// Sets whether AND is the default operator.
-		virtual void setDefaultOperator(DefaultOperator op);
-
-		/// Sets the set of documents to limit to.
-		virtual bool setLimitSet(const set<string> &docsSet);
-
-		/// Sets the set of documents to expand from.
-		virtual bool setExpandSet(const set<string> &docsSet);
-
-		/// Returns the downloader used if any.
-		virtual DownloaderInterface *getDownloader(void);
-
-		/// Runs a query; true if success.
-		virtual bool runQuery(QueryProperties& queryProps,
-			unsigned int startDoc = 0) = 0;
-
-		/// Returns the results for the previous query.
-		virtual const vector<DocumentInfo> &getResults(void) const;
-
-		/// Returns an estimate of the total number of results for the previous query.
-		virtual unsigned int getResultsCountEstimate(void) const;
-
-		/// Returns the charset for the previous query's results.
-		virtual string getResultsCharset(void) const;
-
-		/// Suggests a spelling correction.
-		virtual string getSpellingCorrection(void) const;
-
-		/// Returns expand terms from the previous query.
-		virtual const set<string> &getExpandTerms(void) const;
-
-	protected:
-		DefaultOperator m_defaultOperator;
-		vector<DocumentInfo> m_resultsList;
-		unsigned int m_resultsCountEstimate;
-		string m_charset;
-		string m_correctedFreeQuery;
-		set<string> m_expandTerms;
-
-		SearchEngineInterface();
-
-	private:
-		SearchEngineInterface(const SearchEngineInterface &other);
-		SearchEngineInterface &operator=(const SearchEngineInterface &other);
-
-};
-
-#endif // _SEARCH_ENGINE_INTERFACE_H

Deleted: trunk/Search/SearchPluginProperties.cpp
===================================================================
--- trunk/Search/SearchPluginProperties.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SearchPluginProperties.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,114 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include "SearchPluginProperties.h"
-
-using std::string;
-using std::map;
-using std::set;
-
-SearchPluginProperties::SearchPluginProperties() :
-	m_method(GET_METHOD),
-	m_scrolling(PER_PAGE),
-	m_nextIncrement(0),
-	m_nextBase(0),
-	m_response(UNKNOWN_RESPONSE)
-{
-}
-
-SearchPluginProperties::SearchPluginProperties(const SearchPluginProperties &other) :
-	m_name(other.m_name),
-	m_longName(other.m_longName),
-	m_description(other.m_description),
-	m_channel(other.m_channel),
-	m_baseUrl(other.m_baseUrl),
-	m_method(other.m_method),
-	m_parametersRemainder(other.m_parametersRemainder),
-	m_outputType(other.m_outputType),
-	m_scrolling(other.m_scrolling),
-	m_nextIncrement(other.m_nextIncrement),
-	m_nextBase(other.m_nextBase),
-	m_response(other.m_response)
-{
-	copy(other.m_languages.begin(), other.m_languages.end(),
-		inserter(m_languages, m_languages.begin()));
-	copy(other.m_outputEncodings.begin(), other.m_outputEncodings.end(),
-		inserter(m_outputEncodings, m_outputEncodings.begin()));
-	copy(other.m_inputEncodings.begin(), other.m_inputEncodings.end(),
-		inserter(m_inputEncodings, m_inputEncodings.begin()));
-	copy(other.m_parameters.begin(), other.m_parameters.end(),
-		inserter(m_parameters, m_parameters.begin()));
-}
-
-SearchPluginProperties::~SearchPluginProperties()
-{
-}
-
-SearchPluginProperties& SearchPluginProperties::operator=(const SearchPluginProperties& other)
-{
-	if (this != &other)
-	{
-		m_name = other.m_name;
-		m_longName = other.m_longName;
-		m_description = other.m_description;
-		m_channel = other.m_channel;
-		m_baseUrl = other.m_baseUrl;
-		m_method = other.m_method;
-		m_parametersRemainder = other.m_parametersRemainder;
-		m_outputType = other.m_outputType;
-		m_scrolling = other.m_scrolling;
-		m_nextIncrement = other.m_nextIncrement;
-		m_nextBase = other.m_nextBase;
-		m_response = other.m_response;
-
-		m_languages.clear();
-		copy(other.m_languages.begin(), other.m_languages.end(),
-			inserter(m_languages, m_languages.begin()));
-		m_outputEncodings.clear();
-		copy(other.m_outputEncodings.begin(), other.m_outputEncodings.end(),
-			inserter(m_outputEncodings, m_outputEncodings.begin()));
-		m_inputEncodings.clear();
-		copy(other.m_inputEncodings.begin(), other.m_inputEncodings.end(),
-			inserter(m_inputEncodings, m_inputEncodings.begin()));
-		m_parameters.clear();
-		copy(other.m_parameters.begin(), other.m_parameters.end(),
-			inserter(m_parameters, m_parameters.begin()));
-	}
-
-	return *this;
-}
-
-bool SearchPluginProperties::operator==(const SearchPluginProperties &other) const
-{
-	if (m_name == other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-bool SearchPluginProperties::operator<(const SearchPluginProperties &other) const
-{
-	if (m_name < other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}

Deleted: trunk/Search/SearchPluginProperties.h
===================================================================
--- trunk/Search/SearchPluginProperties.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SearchPluginProperties.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,72 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _SEARCH_PLUGIN_PROPERTIES_H
-#define _SEARCH_PLUGIN_PROPERTIES_H
-
-#include <string>
-#include <map>
-#include <set>
-
-/// Properties of a search plugin.
-class SearchPluginProperties
-{
-	public:
-		SearchPluginProperties();
-		SearchPluginProperties(const SearchPluginProperties &other);
-		virtual ~SearchPluginProperties();
-
-		SearchPluginProperties& operator=(const SearchPluginProperties& other);
-		bool operator==(const SearchPluginProperties &other) const;
-		bool operator<(const SearchPluginProperties &other) const;
-
-		typedef enum { GET_METHOD = 0, POST_METHOD } Method;
-
-		typedef enum { UNKNOWN_PARAM = 0, SEARCH_TERMS_PARAM,
-			 COUNT_PARAM,START_INDEX_PARAM, START_PAGE_PARAM, LANGUAGE_PARAM,
-			OUTPUT_ENCODING_PARAM, INPUT_ENCODING_PARAM } Parameter;
-
-		typedef enum { PER_PAGE = 0, PER_INDEX } Scrolling;
-
-		typedef enum { UNKNOWN_RESPONSE = 0, HTML_RESPONSE,
-			RSS_RESPONSE, ATOM_RESPONSE } Response;
-
-		// Description
-		std::string m_name;
-		std::string m_longName;
-		std::string m_description;
-		std::string m_channel;
-		std::set<std::string> m_languages;
-		std::set<std::string> m_outputEncodings;
-		std::set<std::string> m_inputEncodings;
-		// Query
-		std::string m_baseUrl;
-		Method m_method;
-		std::map<Parameter, std::string> m_parameters;
-		std::string m_parametersRemainder;
-		std::string m_outputType;
-		// Scrolling
-		Scrolling m_scrolling;
-		unsigned int m_nextIncrement;
-		unsigned int m_nextBase;
-		// Response
-		Response m_response;
-
-};
-
-#endif // _SEARCH_PLUGIN_PROPERTIES_H

Deleted: trunk/Search/SherlockParser.cpp
===================================================================
--- trunk/Search/SherlockParser.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SherlockParser.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,744 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <stdlib.h>
-#include <map>
-#include <set>
-#include <iostream>
-#include <boost/spirit/core.hpp>
-#include <boost/spirit/actor/push_back_actor.hpp>
-#include <boost/spirit/actor/insert_at_actor.hpp>
-#include <boost/spirit/utility/confix.hpp>
-
-#include "StringManip.h"
-#include "Url.h"
-#include "HtmlFilter.h"
-#include "FilterFactory.h"
-#include "FileCollector.h"
-#include "FilterUtils.h"
-#include "SherlockParser.h"
-
-using std::cout;
-using std::endl;
-using std::string;
-using std::vector;
-using std::map;
-using std::set;
-using std::exception;
-
-using namespace boost::spirit;
-
-// A function object to lower case map keys with for_each()
-struct LowerAndCopy
-{
-	public:
-		LowerAndCopy(map<string, string> &other) :
-			m_other(other)
-		{
-		}
-
-		void operator()(map<string, string>::value_type &p)
-		{
-			m_other[StringManip::toLowerCase(p.first)] = p.second;
-		}
-
-		map<string, string> &m_other;
-
-};
-
-struct plugin_skip_grammar : public grammar<plugin_skip_grammar>
-{
-	template <typename ScannerT>
-	struct definition
-	{
-		definition(plugin_skip_grammar const &self)
-		{
-			// Skip all spaces and comments, starting with a #
-			// FIXME: make sure comments start at the beginning of the line !
-			skip = space_p | (ch_p('#') >> *(anychar_p - ch_p('\n')) >> ch_p('\n'));
-		}
-	
-		rule<ScannerT> skip;
-	
-		rule<ScannerT> const& start() const
-		{
-			return skip;
-		}
-	};
-};
-
-/**
-  * A minimal grammar for Sherlock plugins.
-  * This only checks for the existence of the SEARCH tag.
-  * It is used to quickly extract SEARCH attributes.
-  */
-struct plugin_min_grammar : public grammar<plugin_min_grammar>
-{
-	 plugin_min_grammar(map<string, string> &searchParams) :
-		m_searchParams(searchParams)
-	{
-	}
-
-	template <typename ScannerT>
-	struct definition
-	{
-		definition(plugin_min_grammar const &self)
-		{
-			// Start
-			search_plugin = search_header >> rest;
-
-			// All items have a name and an optionally-quoted value, separated by =
-			end_of_name = ch_p('=');
-			any_name = *(~ch_p('>') - end_of_name);
-			any_value_without_quotes = lexeme_d[*(~ch_p('>') - ch_p('\n'))];
-			any_value = ch_p('\'') >> (*(~ch_p('\'')))[assign_a(unquotedValue)] >> ch_p('\'') |
-				ch_p('"') >> (*(~ch_p('"')))[assign_a(unquotedValue)] >> ch_p('"') |
-				any_value_without_quotes[assign_a(unquotedValue)];
-
-			// SEARCH attributes are items
-			// There should be only one SEARCH tag
-			search_item = (any_name[assign_a(itemName)]
-				>> ch_p('=') >> any_value[assign_a(itemValue, unquotedValue)])
-				[insert_at_a(self.m_searchParams, itemName, itemValue)];
-
-			// SEARCH may have any number of attributes
-			search_header = ch_p('<') >> as_lower_d[str_p("search")] >> *search_item >> ch_p('>');
-
-			// Rest
-			rest = *anychar_p;
-		}
-
-		string unquotedValue, itemName, itemValue;		
-		rule<ScannerT> search_plugin, search_header, rest;
-		rule<ScannerT> end_of_name, any_name, any_value_without_quotes, any_value, search_item;
-
-		rule<ScannerT> const& start() const
-		{
-			return search_plugin;
-		}
-	};
-
-	map<string, string> &m_searchParams;
-
-};
-
-/**
-  * A complete but lax grammar for Sherlock plugins.
-  * For instance, it doesn't mind if INPUT has a NAME but no VALUE.
-  * More importantly, it doesn't enforce types, eg FACTOR should be an integer.
-  */
-struct plugin_grammar : public grammar<plugin_grammar>
-{
-	plugin_grammar(map<string, string> &searchParams,
-		map<string, string> &interpretParams,
-		map<string, string> &inputItems,
-		string &userInput, string &nextInput,
-		string &nextFactor,
-		string &nextValue) :
-		m_searchParams(searchParams),
-		m_interpretParams(interpretParams),
-		m_inputItems(inputItems),
-		m_userInput(userInput),
-		m_nextInput(nextInput),
-		m_nextFactor(nextFactor),
-		m_nextValue(nextValue)
-	{
-	}
-
-	template <typename ScannerT>
-	struct definition
-	{
-		definition(plugin_grammar const &self)
-		{
-			// Start
-			search_plugin = search_header >> input_elements >> search_footer >> rest;
-
-			// All items have a name and an optionally-quoted value, separated by =
-			end_of_name = ch_p('=');
-			any_name = *(~ch_p('>') - end_of_name);
-			any_value_without_quotes = lexeme_d[*(~ch_p('>') - ch_p('\n'))];
-			any_value = ch_p('\'') >> (*(~ch_p('\'')))[assign_a(unquotedValue)] >> ch_p('\'') |
-				ch_p('"') >> (*(~ch_p('"')))[assign_a(unquotedValue)] >> ch_p('"') |
-				any_value_without_quotes[assign_a(unquotedValue)];
-
-			// SEARCH attributes are items
-			// There should be only one SEARCH tag
-			search_item = (any_name[assign_a(itemName)]
-				>> ch_p('=') >> any_value[assign_a(itemValue, unquotedValue)])
-				[insert_at_a(self.m_searchParams, itemName, itemValue)];
-
-			// SEARCH may have any number of attributes
-			search_header = ch_p('<') >> as_lower_d[str_p("search")] >> *search_item >> ch_p('>');
-
-			// INPUT
-			input_item_name = as_lower_d[str_p("name")] >> ch_p('=')
-				>> any_value[assign_a(itemName, unquotedValue)];
-			input_item_value = as_lower_d[str_p("value")] >> ch_p('=')
-				>> any_value[assign_a(itemValue, unquotedValue)];
-			input_item_user = as_lower_d[str_p("user")];
-			input_item_factor = as_lower_d[str_p("factor")]
-				>> ch_p('=') >> any_value[assign_a(itemValue, unquotedValue)];
-
-			// INPUT tags have name and value items; one is marked with USER
-			input_item = input_item_name |
-				input_item_value |
-				input_item_user[assign_a(self.m_userInput, itemName)];
-
-			input_element = (ch_p('<') >> as_lower_d[str_p("input")] >> *input_item >> ch_p('>'))
-				[insert_at_a(self.m_inputItems, itemName, itemValue)];
-
-			// INPUTPREV tags have name and either factor or value items
-			// There should be only one INPUTPREV tag
-			// FIXME: save those
-			inputprev_item = input_item_name |
-				input_item_factor |
-				input_item_value;
-
-			inputprev_element = ch_p('<') >> as_lower_d[str_p("inputprev")] >> *inputprev_item >> ch_p('>');
-
-			// INPUTNEXT tags have name and either factor or value items
-			// There should be only one INPUTNEXT tag
-			inputnext_item = input_item_name[assign_a(self.m_nextInput, itemName)] |
-				input_item_factor[assign_a(self.m_nextFactor, itemValue)] |
-				input_item_value[assign_a(self.m_nextValue, itemValue)];
-
-			inputnext_element = ch_p('<') >> as_lower_d[str_p("inputnext")] >> *inputnext_item >> ch_p('>');
-
-			// INTERPRET tags have varied types of items
-			// There should be only one INTERPRET tag
-			interpret_item = (any_name[assign_a(itemName)]
-				>> ch_p('=') >> any_value[assign_a(itemValue, unquotedValue)])
-				[insert_at_a(self.m_interpretParams, itemName, itemValue)];
-
-			interpret_element = ch_p('<') >> as_lower_d[str_p("interpret")] >> *interpret_item >> ch_p('>');
-
-			// INPUT, INPUTNEXT and INTERPRET may appear in any order
-			input_elements = *(input_element |
-				inputprev_element |
-				inputnext_element |
-				interpret_element);
-
-			// SEARCH has a closing tag
-			search_footer =  ch_p('<') >> ch_p('/') >> as_lower_d[str_p("search")] >> ch_p('>');
-
-			// Rest
-			rest = *anychar_p;
-		}
-
-		string unquotedValue, itemName, itemValue;		
-		rule<ScannerT> search_plugin, search_header, search_footer, rest;
-		rule<ScannerT> end_of_name, any_name, any_value_without_quotes, any_value, search_item;
-		rule<ScannerT> input_elements, input_element, inputprev_element, inputnext_element, interpret_element;
-		rule<ScannerT> input_item_name, input_item_value, input_item_user, input_item_factor;
-		rule<ScannerT> input_item, inputprev_item, inputnext_item, interpret_item;
-
-		rule<ScannerT> const& start() const
-		{
-			return search_plugin;
-		}
-	};
-
-	map<string, string> &m_searchParams;
-	map<string, string> &m_interpretParams;
-	map<string, string> &m_inputItems;
-	string &m_userInput;
-	string &m_nextInput;
-	string &m_nextFactor;
-	string &m_nextValue;
-
-};
-
-SherlockResponseParser::SherlockResponseParser() :
-	ResponseParserInterface(),
-	m_skipLocal(true)
-{
-}
-
-SherlockResponseParser::~SherlockResponseParser()
-{
-}
-
-bool SherlockResponseParser::parse(const Document *pResponseDoc, vector<DocumentInfo> &resultsList,
-	unsigned int &totalResults, unsigned int &firstResultIndex) const
-{
-	float pseudoScore = 100;
-	unsigned int contentLen = 0;
-	bool foundResult = false;
-
-	if ((pResponseDoc == NULL) ||
-		(pResponseDoc->getData(contentLen) == NULL) ||
-		(contentLen == 0))
-	{
-		return false;
-	}
-
-	// These two are the minimum we need
-	if ((m_resultItemStart.empty() == true) ||
-		(m_resultItemEnd.empty() == true))
-	{
-#ifdef DEBUG
-		cout << "SherlockResponseParser::parse: incomplete properties" << endl;
-#endif
-		return false;
-	}
-
-	// Extract the results list
-#ifdef DEBUG
-	cout << "SherlockResponseParser::parse: getting results list ("
-		<< m_resultListStart << ", " << m_resultListEnd << ")" << endl;
-#endif
-	const char *pContent = pResponseDoc->getData(contentLen);
-	string resultList = StringManip::extractField(pContent, m_resultListStart, m_resultListEnd);
-	if (resultList.empty() == true)
-	{
-		resultList = string(pContent, contentLen);
-	}
-
-	// Extract results
-	string::size_type endPos = 0;
-#ifdef DEBUG
-	cout << "SherlockResponseParser::parse: getting first result ("
-		<< m_resultItemStart << ", " << m_resultItemEnd << ")" << endl;
-#endif
-	string resultItem = StringManip::extractField(resultList,
-		m_resultItemStart, m_resultItemEnd, endPos);
-	while (resultItem.empty() == false)
-	{
-		string contentType, url, name, extract;
-
-#ifdef DEBUG
-		cout << "SherlockResponseParser::parse: candidate chunk \""
-			<< resultItem << "\"" << endl;
-#endif
-		contentType = pResponseDoc->getType();
-		if (strncasecmp(contentType.c_str(), "text/html", 9) == 0)
-		{
-			Document chunkDoc("", "", contentType, "");
-			string htmlChunk(resultItem);
-
-			// The chunk may contain truncated tags, get rid of them !
-			string::size_type firstOpen = htmlChunk.find('<');
-			string::size_type firstClose = htmlChunk.find('>');
-			if (firstClose != string::npos)
-			{
-				if ((firstOpen == string::npos) ||
-					(firstClose < firstOpen))
-				{
-					htmlChunk.erase(0, firstClose + 1);
-				}
-			}
-			string::size_type lastClose = htmlChunk.find_last_of(">");
-			string::size_type lastOpen = htmlChunk.find_last_of("<");
-			if (lastOpen != string::npos)
-			{
-				if ((lastClose == string::npos) ||
-					(lastOpen > lastClose))
-				{
-					htmlChunk.erase(lastOpen);
-				}
-			}
-
-			// Wrap input
-			string dummyHtml("<html><head><meta HTTP-EQUIV=\"content-type\" CONTENT=\"");
-			dummyHtml += pResponseDoc->getType();
-			dummyHtml += "\"></head><body>";
-			dummyHtml += htmlChunk;
-			dummyHtml += "</body></html>";
-#ifdef DEBUG
-			cout << "SherlockResponseParser::parse: wrapped chunk \""
-				<< dummyHtml << "\"" << endl;
-#endif
-			chunkDoc.setData(dummyHtml.c_str(), dummyHtml.length());
-
-			// Feed this chunk to the filter
-			Dijon::HtmlFilter chunkFilter("text/html");
-			set<Dijon::Link> chunkLinks;
-			if ((FilterUtils::feedFilter(chunkDoc, &chunkFilter) == true) &&
-				(chunkFilter.get_links(chunkLinks) == true) &&
-				(chunkFilter.next_document() == true))
-			{
-				unsigned int endOfFirstLink = 0, startOfSecondLink = 0, endOfSecondLink = 0, startOfThirdLink = 0;
-
-				// The result's URL and title should be given by the first link
-				for (set<Dijon::Link>::iterator linkIter = chunkLinks.begin(); linkIter != chunkLinks.end(); ++linkIter)
-				{
-					if (linkIter->m_index == 0)
-					{
-						url = linkIter->m_url;
-						name = linkIter->m_name;
-#ifdef DEBUG
-						cout << "SherlockResponseParser::parse: first link in chunk is "
-							<< url << endl;
-#endif
-						endOfFirstLink = linkIter->m_endPos;
-					}
-					else if (linkIter->m_index == 1)
-					{
-						startOfSecondLink = linkIter->m_startPos;
-						endOfSecondLink = linkIter->m_endPos;
-					}
-					else if (linkIter->m_index == 2)
-					{
-						startOfThirdLink = linkIter->m_startPos;
-					}
-				}
-
-				// Any extract ?
-				const map<string, string> &metaData = chunkFilter.get_meta_data();
-				map<string, string>::const_iterator abstractIter = metaData.find("abstract");
-				if (abstractIter == metaData.end())
-				{
-					extract = FilterUtils::stripMarkup(resultItem);
-					StringManip::trimSpaces(extract);
-				}
-				else
-				{
-					extract = abstractIter->second;
-				}
-			}
-		}
-		else
-		{
-			// This is not HTML
-			// Use extended attributes
-			if ((m_resultTitleStart.empty() == false) &&
-				(m_resultTitleEnd.empty() == false))
-			{
-				name = StringManip::extractField(resultItem,
-					m_resultTitleStart, m_resultTitleEnd);
-			}
-
-			if ((m_resultLinkStart.empty() == false) &&
-				(m_resultLinkEnd.empty() == false))
-			{
-				url = StringManip::extractField(resultItem,
-					m_resultLinkStart, m_resultLinkEnd);
-			}
-
-			if ((m_resultExtractStart.empty() == false) &&
-				(m_resultExtractEnd.empty() == false))
-			{
-				extract = StringManip::extractField(resultItem,
-					m_resultExtractStart, m_resultExtractEnd);
-			}
-		}
-
-		if (url.empty() == false)
-		{
-			Url urlObj(url);
-
-			// Is this URL relative to the search engine's domain ?
-			// FIXME: look for a interpret/baseurl tag, see https://bugzilla.mozilla.org/show_bug.cgi?id=65453
-			// FIXME: obey m_skipLocal
-			if (urlObj.getHost().empty() == true)
-			{
-				Url baseUrlObj(pResponseDoc->getLocation());
-
-				string tmpUrl = baseUrlObj.getProtocol();
-				tmpUrl += "://";
-				tmpUrl += baseUrlObj.getHost();
-				if (url[0] != '/')
-				{
-					tmpUrl += "/";
-				}
-				tmpUrl += url;
-				url = tmpUrl;
-			}
-
-			DocumentInfo result(name, url, "", "");
-			result.setExtract(extract);
-			result.setScore(pseudoScore);
-
-			resultsList.push_back(result);
-			--pseudoScore;
-			foundResult = true;
-			if (resultsList.size() == totalResults)
-			{
-				// Enough results
-				break;
-			}
-		}
-
-		// Next
-		endPos += m_resultItemEnd.length();
-		resultItem = StringManip::extractField(resultList,
-			m_resultItemStart, m_resultItemEnd, endPos);
-	}
-
-	return foundResult;
-}
-
-pthread_mutex_t SherlockParser::m_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-SherlockParser::SherlockParser(const string &fileName) :
-	PluginParserInterface(fileName)
-{
-}
-
-SherlockParser::~SherlockParser()
-{
-}
-
-ResponseParserInterface *SherlockParser::parse(SearchPluginProperties &properties,
-	bool extractSearchParams)
-{
-	FileCollector fileCollect;
-	DocumentInfo docInfo("Sherlock Source", string("file://") + m_fileName,
-		"text/plain", "");
-
-	// Get the definition file
-	Document *pPluginDoc = fileCollect.retrieveUrl(docInfo);
-	if (pPluginDoc == NULL)
-	{
-#ifdef DEBUG
-		cout << "SherlockParser::parse: couldn't load " << m_fileName << endl;
-#endif
-		return NULL;
-	}
-
-	unsigned int dataLength;
-	const char *pData = pPluginDoc->getData(dataLength);
-	if ((pData == NULL) ||
-		(dataLength == 0))
-	{
-		delete pPluginDoc;
-		return NULL;
-	}
-
-	map<string, string> searchParams, interpretParams, inputItems;
-	string userInput, nextInput, nextFactor, nextValue;
-	bool parsedPlugin = false;
-
-	if (pthread_mutex_lock(&m_mutex) == 0)
-	{
-		try
-		{
-			if (extractSearchParams == false)
-			{
-				plugin_skip_grammar skip;
-				plugin_grammar plugin(searchParams, interpretParams, inputItems,
-					userInput, nextInput, nextFactor, nextValue);
-
-				parse_info<> parseInfo = boost::spirit::parse(pData, plugin, skip);
-				parsedPlugin = parseInfo.hit;
-			}
-			else
-			{
-				plugin_skip_grammar skip;
-				plugin_min_grammar plugin(searchParams);
-
-				parse_info<> parseInfo = boost::spirit::parse(pData, plugin, skip);
-				parsedPlugin = parseInfo.hit;
-			}
-		}
-		catch (const exception &e)
-		{
-#ifdef DEBUG
-			cout << "SherlockParser::parse: caught exception ! " << e.what() << endl;
-#endif
-			parsedPlugin = false;
-		}
-		catch (...)
-		{
-#ifdef DEBUG
-			cout << "SherlockParser::parse: caught unknown exception !" << endl;
-#endif
-			parsedPlugin = false;
-		}
-
-		pthread_mutex_unlock(&m_mutex);
-	}
-
-	// We are done with the document
-	delete pPluginDoc;
-
-	SherlockResponseParser *pResponseParser = NULL;
-
-	if (parsedPlugin == true)
-	{
-		map<string, string> lowSearchParams, lowInterpretParams, lowInputItems;
-
-		pResponseParser = new SherlockResponseParser();
-
-		LowerAndCopy lowCopy1(lowSearchParams);
-		for_each(searchParams.begin(), searchParams.end(), lowCopy1);
-		LowerAndCopy lowCopy2(lowInterpretParams);
-		for_each(interpretParams.begin(), interpretParams.end(), lowCopy2);
-		LowerAndCopy lowCopy3(lowInputItems);
-		for_each(inputItems.begin(), inputItems.end(), lowCopy3);
-
-		// Response
-		properties.m_response = SearchPluginProperties::HTML_RESPONSE;
-		// Method
-		properties.m_method = SearchPluginProperties::GET_METHOD;
-
-		// Name
-		map<string, string>::iterator mapIter = lowSearchParams.find("name");
-		if (mapIter != lowSearchParams.end())
-		{
-			properties.m_name = mapIter->second;
-		}
-
-		// Description
-		mapIter = lowSearchParams.find("description");
-		if (mapIter != lowSearchParams.end())
-		{
-			properties.m_description = mapIter->second;
-		}
-
-		// Channel
-		mapIter = lowSearchParams.find("routetype");
-		if (mapIter != lowSearchParams.end())
-		{
-			properties.m_channel = mapIter->second;
-		}
-
-		if (extractSearchParams == false)
-		{
-			if (userInput.empty() == false)
-			{
-				// Remove the user input tag from the input tags map
-				mapIter = lowInputItems.find(userInput);
-				if (mapIter != lowInputItems.end())
-				{
-					lowInputItems.erase(mapIter);
-				}
-
-				properties.m_parameters[SearchPluginProperties::SEARCH_TERMS_PARAM] = userInput;
-			}
-			for (map<string, string>::iterator iter = lowInputItems.begin();
-				iter != lowInputItems.end(); ++iter)
-			{
-				// Append to the remainder
-				if (properties.m_parametersRemainder.empty() == false)
-				{
-					properties.m_parametersRemainder += "&";
-				}
-				properties.m_parametersRemainder += iter->first;
-				properties.m_parametersRemainder += "=";
-				properties.m_parametersRemainder += iter->second;
-			}
-
-			// URL
-			mapIter = lowSearchParams.find("action");
-			if (mapIter != lowSearchParams.end())
-			{
-				properties.m_baseUrl = mapIter->second;
-			}
-
-			// Response
-			mapIter = lowInterpretParams.find("resultliststart");
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser->m_resultListStart = StringManip::replaceSubString(mapIter->second, "\\n", "\n");
-			}
-
-			mapIter = lowInterpretParams.find("resultlistend");
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser->m_resultListEnd = StringManip::replaceSubString(mapIter->second, "\\n", "\n");
-			}
-
-			mapIter = lowInterpretParams.find("resultitemstart");
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser->m_resultItemStart = StringManip::replaceSubString(mapIter->second, "\\n", "\n");
-			}
-
-			mapIter = lowInterpretParams.find("resultitemend");
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser->m_resultItemEnd = StringManip::replaceSubString(mapIter->second, "\\n", "\n");
-			}
-
-			mapIter = lowInterpretParams.find("resulttitlestart");
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser->m_resultTitleStart = mapIter->second;
-			}
-
-			mapIter = lowInterpretParams.find("resulttitleend");
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser->m_resultTitleEnd = mapIter->second;
-			}
-
-			mapIter = lowInterpretParams.find("resultlinkstart");
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser->m_resultLinkStart = mapIter->second;
-			}
-
-			mapIter = lowInterpretParams.find("resultlinkend");
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser->m_resultLinkEnd = mapIter->second;
-			}
-
-			mapIter = lowInterpretParams.find("resultextractstart");
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser->m_resultExtractStart = mapIter->second;
-			}
-
-			mapIter = lowInterpretParams.find("resultextractend");
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser->m_resultExtractEnd = mapIter->second;
-			}
-
-			mapIter = lowInterpretParams.find("skiplocal");
-			if (mapIter != lowInterpretParams.end())
-			{
-				if (mapIter->second == "false")
-				{
-					pResponseParser->m_skipLocal = false;
-				}
-			}
-
-			// Here we differ from how Mozilla uses these parameters
-			// Normally, either factor or value is used, but we use value
-			// as the parameter's initial value
-			if (nextFactor.empty() == false)
-			{
-				properties.m_parameters[SearchPluginProperties::START_PAGE_PARAM] = nextInput;
-				properties.m_scrolling = SearchPluginProperties::PER_PAGE;
-				// What Sherlock calls a factor is actually an increment
-				properties.m_nextIncrement = (unsigned int)atoi(nextFactor.c_str());
-			}
-			else
-			{
-				// Assume INPUTNEXT allows to specify a number of results
-				// Not sure if this is how Sherlock/Mozilla interpret this
-				properties.m_parameters[SearchPluginProperties::COUNT_PARAM] = nextInput;
-				properties.m_scrolling = SearchPluginProperties::PER_INDEX;
-				properties.m_nextIncrement = 0;
-			}
-			if (nextValue.empty() == false)
-			{
-				properties.m_nextBase = (unsigned int)atoi(nextValue.c_str());
-			}
-			else
-			{
-				properties.m_nextBase = 0;
-			}
-		}
-	}
-
-	return pResponseParser;
-}

Deleted: trunk/Search/SherlockParser.h
===================================================================
--- trunk/Search/SherlockParser.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SherlockParser.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,81 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _SHERLOCK_PARSER_H
-#define _SHERLOCK_PARSER_H
-
-#include <pthread.h>
-#include <string>
-#include <vector>
-
-#include "Document.h"
-#include "PluginParsers.h"
-
-/// Parses output of Sherlock-based search engines.
-class SherlockResponseParser : public ResponseParserInterface
-{
-	public:
-		SherlockResponseParser();
-		virtual ~SherlockResponseParser();
-
-		/// Parses the response; false if not all could be parsed.
-		virtual bool parse(const Document *pResponseDoc, std::vector<DocumentInfo> &resultsList,
-			unsigned int &totalResults, unsigned int &firstResultIndex) const;
-
-		std::string m_resultListStart;
-		std::string m_resultListEnd;
-		std::string m_resultItemStart;
-		std::string m_resultItemEnd;
-		std::string m_resultTitleStart;
-		std::string m_resultTitleEnd;
-		std::string m_resultLinkStart;
-		std::string m_resultLinkEnd;
-		std::string m_resultExtractStart;
-		std::string m_resultExtractEnd;
-		bool m_skipLocal;
-
-	private:
-		SherlockResponseParser(const SherlockResponseParser &other);
-		SherlockResponseParser& operator=(const SherlockResponseParser& other);
-
-};
-
-/** A parser for Sherlock plugin files.
-  * See http://developer.apple.com/technotes/tn/tn1141.html
-  * and http://mycroft.mozdev.org/deepdocs/deepdocs.html
-  */
-class SherlockParser : public PluginParserInterface
-{
-	public:
-		SherlockParser(const std::string &fileName);
-		virtual ~SherlockParser();
-
-		/// Parses the plugin and returns a response parser.
-		virtual ResponseParserInterface *parse(SearchPluginProperties &properties,
-			bool extractSearchParams = false);
-
-	protected:
-		static pthread_mutex_t m_mutex;
-
-	private:
-		SherlockParser(const SherlockParser &other);
-		SherlockParser& operator=(const SherlockParser& other);
-
-};
-
-#endif // _SHERLOCK_PARSER_H

Deleted: trunk/Search/WebEngine.cpp
===================================================================
--- trunk/Search/WebEngine.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/WebEngine.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,235 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <string.h>
-#include <sys/types.h>
-#include <glib.h>
-#include <string>
-#include <vector>
-#include <iostream>
-
-#include "StringManip.h"
-#include "Url.h"
-#include "HtmlFilter.h"
-#include "DownloaderFactory.h"
-#include "FilterUtils.h"
-#include "Tokenizer.h"
-#include "WebEngine.h"
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-using std::set;
-using std::vector;
-
-WebEngine::WebEngine() :
-	SearchEngineInterface(),
-	m_pDownloader(DownloaderFactory::getDownloader("http"))
-{
-}
-
-WebEngine::~WebEngine()
-{
-	if (m_pDownloader != NULL)
-	{
-		delete m_pDownloader;
-	}
-}
-
-Document *WebEngine::downloadPage(const DocumentInfo &docInfo)
-{
-	m_charset.clear();
-
-	if (m_pDownloader == NULL)
-	{
-		return NULL;
-	}
-
-	Document *pDoc = m_pDownloader->retrieveUrl(docInfo);
-	if (pDoc != NULL)
-	{
-		string contentType(pDoc->getType());
-
-		// Is a charset specified ?
-		string::size_type pos = contentType.find("charset=");
-		if (pos != string::npos)
-		{
-			m_charset = StringManip::removeQuotes(contentType.substr(pos + 8));
-		}
-		if (m_charset.empty() == true)
-		{
-			Dijon::HtmlFilter htmlFilter("text/html");
-
-			if (FilterUtils::feedFilter(*pDoc, &htmlFilter) == true)
-			{
-				const map<string, string> &metaData = htmlFilter.get_meta_data();
-				map<string, string>::const_iterator charsetIter = metaData.find("charset");
-
-				if (charsetIter != metaData.end())
-				{
-					m_charset = charsetIter->second;
-				}
-			}
-		}
-#ifdef DEBUG
-		cout << "WebEngine::downloadPage: charset is " << m_charset << endl;
-#endif
-	}
-
-	return pDoc;
-}
-
-void WebEngine::setQuery(const QueryProperties &queryProps)
-{
-	queryProps.getTerms(m_queryTerms);
-}
-
-bool WebEngine::processResult(const string &queryUrl, DocumentInfo &result)
-{
-	Url queryUrlObj(queryUrl);
-	string resultUrl(result.getLocation());
-	string queryHost(Url::reduceHost(queryUrlObj.getHost(), 2));
-
-	if (resultUrl.empty() == true)
-	{
-		return false;
-	}
-
-	if ((resultUrl[0] == '/') ||
-		((resultUrl.length() > 1) &&
-		(resultUrl[0] == '.') &&
-		(resultUrl[1] == '/')))
-	{
-		string fullResultUrl(queryUrlObj.getProtocol());
-
-		fullResultUrl += "://";
-		fullResultUrl += queryUrlObj.getHost();
-		if (resultUrl[0] == '.')
-		{
-			fullResultUrl += resultUrl.substr(1);
-		}
-		else
-		{
-			fullResultUrl += resultUrl;
-		}
-
-		resultUrl = fullResultUrl;
-	}
-
-	Url resultUrlObj(resultUrl);
-
-	// Is the result's host name the same as the search engine's ?
-	// FIXME: not all TLDs have leafs at level 2
-	if (queryHost == Url::reduceHost(resultUrlObj.getHost(), 2))
-	{
-		string protocol(resultUrlObj.getProtocol());
-
-		if (protocol.empty() == false)
-		{
-			string embeddedUrl;
-
-			string::size_type startPos = resultUrl.find(protocol, protocol.length());
-			if (startPos != string::npos)
-			{
-				string::size_type endPos = resultUrl.find("&amp;", startPos);
-				if (endPos != string::npos)
-				{
-					embeddedUrl = resultUrl.substr(startPos, endPos - startPos);
-				}
-				else
-				{
-					embeddedUrl = resultUrl.substr(startPos);
-				}
-
-				resultUrl = Url::unescapeUrl(embeddedUrl);
-			}
-#ifdef DEBUG
-			else cout << "WebEngine::processResult: no embedded URL" << endl;
-#endif
-		}
-#ifdef DEBUG
-		else cout << "WebEngine::processResult: no protocol" << endl;
-#endif
-	}
-
-	// Trim spaces
-	string trimmedUrl(resultUrl);
-	StringManip::trimSpaces(trimmedUrl);
-
-	// Make the URL canonical
-	result.setLocation(Url::canonicalizeUrl(trimmedUrl));
-
-	// Scan the extract for query terms
-	string extract(result.getExtract());
-	if (extract.empty() == true)
-	{
-		return true;
-	}
-
-	Document doc;
-	doc.setData(extract.c_str(), extract.length());
-	Tokenizer tokens(&doc);
-
-	extract.clear();
-
-	string token;
-	while (tokens.nextToken(token) == true)
-	{
-		gchar *pEscToken = NULL;
-		gchar *pUTF8Token = NULL;
-		gsize bytesWritten = 0;
-
-		pUTF8Token = g_locale_to_utf8(token.c_str(), token.length(),
-			NULL, &bytesWritten, NULL);
-		if (pUTF8Token != NULL)
-		{
-			pEscToken = g_markup_escape_text(pUTF8Token, -1);
-			g_free(pUTF8Token);
-		}
-		if (pEscToken == NULL)
-		{
-			continue;
-		}
-
-		// Is this a query term ?
-		if (m_queryTerms.find(StringManip::toLowerCase(token)) == m_queryTerms.end())
-		{
-			extract += pEscToken;
-		}
-		else
-		{
-			extract += "<b>";
-			extract += pEscToken;
-			extract += "</b>";
-		}
-		extract += " ";
-
-		g_free(pEscToken);
-
-		result.setExtract(extract);
-	}
-
-	return true;
-}
-
-/// Returns the downloader used if any.
-DownloaderInterface *WebEngine::getDownloader(void)
-{
-	return m_pDownloader;
-}

Deleted: trunk/Search/WebEngine.h
===================================================================
--- trunk/Search/WebEngine.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/WebEngine.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,59 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _WEB_ENGINE_H
-#define _WEB_ENGINE_H
-
-#include <string>
-#include <set>
-
-#include "Document.h"
-#include "QueryProperties.h"
-#include "SearchEngineInterface.h"
-
-/// Base class for all Web search engines.
-class WebEngine : public SearchEngineInterface
-{
-	public:
-		WebEngine();
-		virtual ~WebEngine();
-
-		/// Returns the downloader used if any.
-		virtual DownloaderInterface *getDownloader(void);
-
-	protected:
-		DownloaderInterface *m_pDownloader;
-		std::set<std::string> m_queryTerms;
-
-		Document *downloadPage(const DocumentInfo &docInfo);
-
-		void setHostNameFilter(const string &filter);
-
-		void setFileNameFilter(const string &filter);
-
-		void setQuery(const QueryProperties &queryProps);
-
-		virtual bool processResult(const string &queryUrl, DocumentInfo &result);
-
-	private:
-		WebEngine(const WebEngine &other);
-		WebEngine &operator=(const WebEngine &other);
-
-};
-
-#endif // _WEB_ENGINE_H

Deleted: trunk/Search/XapianEngine.cpp
===================================================================
--- trunk/Search/XapianEngine.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/XapianEngine.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,677 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <time.h>
-#include <string>
-#include <vector>
-#include <iostream>
-#include <algorithm>
-
-#include "Languages.h"
-#include "StringManip.h"
-#include "TimeConverter.h"
-#include "Timer.h"
-#include "Url.h"
-#include "XapianDatabaseFactory.h"
-#include "AbstractGenerator.h"
-#include "XapianEngine.h"
-#include "xesam/XapianQueryBuilder.h"
-#include "xesam/XesamQLParser.h"
-#ifdef HAVE_BOOST_SPIRIT
-#include "xesam/XesamULParser.h"
-#endif
-
-using std::string;
-using std::multimap;
-using std::vector;
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::inserter;
-using namespace Dijon;
-
-static void checkFilter(const string &freeQuery, string::size_type filterValueStart,
-	bool &escapeValue, bool &hashValue)
-{
-	string filterName;
-	string::size_type filterNameStart = freeQuery.rfind(' ', filterValueStart);
-
-	escapeValue = hashValue = false;
-
-	if (filterNameStart == string::npos)
-	{
-		filterName = freeQuery.substr(0, filterValueStart);
-	}
-	else
-	{
-		filterName = freeQuery.substr(filterNameStart + 1, filterValueStart - filterNameStart - 1);
-	}
-#ifdef DEBUG
-	cout << "checkFilter: filter " << filterName << endl;
-#endif
-
-	// In XapianIndex, these are escaped and hashed
-	if ((filterName == "file") ||
-		(filterName =="dir") ||
-		(filterName == "url"))
-	{
-		escapeValue = hashValue = true;
-	}
-	// except label which is only escaped
-	else if (filterName == "label")
-	{
-		escapeValue = true;
-	}
-}
-
-class TimeValueRangeProcessor : public Xapian::ValueRangeProcessor
-{
-	public:
-		TimeValueRangeProcessor(Xapian::valueno valueNumber) : Xapian::ValueRangeProcessor(), m_valueNumber(valueNumber) { }
-		~TimeValueRangeProcessor() { }
-
-		virtual Xapian::valueno operator()(string &begin, string &end)
-		{
-			if ((begin.size() == 6) &&
-					(end.size() == 6))
-			{
-				// HHMMSS
-#ifdef DEBUG
-				cout << "TimeValueRangeProcessor::operator: accepting " << begin << ".." << end << endl;
-#endif
-				return m_valueNumber;
-			}
-			if ((begin.size() == 8) && (end.size() == 8) &&
-					(begin[2] == begin[5]) && (end[2] == end[5]) && (begin[2] == end[2]) &&
-					(end[4] == ':'))
-			{
-				// HH:MM:SS
-				begin.erase(2, 1);
-				begin.erase(5, 1);
-				end.erase(2, 1);
-				end.erase(5, 1);
-#ifdef DEBUG
-				cout << "TimeValueRangeProcessor::operator: accepting " << begin << ".." << end << endl;
-#endif
-				return m_valueNumber;
-			}
-#ifdef DEBUG
-			cout << "TimeValueRangeProcessor::operator: rejecting " << begin << ".." << end << endl;
-#endif
-
-			return Xapian::BAD_VALUENO;
-		}
-
-	protected:
-		Xapian::valueno m_valueNumber;
-
-};
-
-class PrefixDecider : public Xapian::ExpandDecider
-{
-	public:
-		PrefixDecider(const string &allowedPrefixes) : Xapian::ExpandDecider(), m_allowedPrefixes(allowedPrefixes) { }
-		~PrefixDecider() { }
-
-		virtual bool operator()(const std::string &term) const
-		{
-			if ((isupper((int)(term[0])) == 0) ||
-				(m_allowedPrefixes.find(term[0]) != string::npos))
-			{
-				return true;
-			}
-#ifdef DEBUG
-			cout << "PrefixDecider::operator: rejecting " << term << endl;
-#endif
-
-			return false;
-		}
-
-	protected:
-		string m_allowedPrefixes;
-
-};
-
-XapianEngine::XapianEngine(const string &database) :
-	SearchEngineInterface()
-{
-	// If the database name ends with a slash, remove it
-	if (database[database.length() - 1] == '/')
-	{
-		m_databaseName = database.substr(0, database.length() - 1);
-	}
-	else
-	{
-		m_databaseName = database;
-	}
-}
-
-XapianEngine::~XapianEngine()
-{
-}
-
-Xapian::Query XapianEngine::parseQuery(Xapian::Database *pIndex, const QueryProperties &queryProps,
-	const string &stemLanguage, DefaultOperator defaultOperator,
-	const string &limitQuery, string &correctedFreeQuery, bool minimal)
-{
-	Xapian::QueryParser parser;
-	Xapian::Stem stemmer;
-	string freeQuery(StringManip::replaceSubString(queryProps.getFreeQuery(), "\n", " "));
-	unsigned int minDay, minMonth, minYear = 0;
-	unsigned int maxDay, maxMonth, maxYear = 0;
-
-	// Set things up
-	if ((minimal == false) &&
-		(stemLanguage.empty() == false))
-	{
-		try
-		{
-			stemmer = Xapian::Stem(StringManip::toLowerCase(stemLanguage));
-		}
-		catch (const Xapian::Error &error)
-		{
-			cerr << "Couldn't create stemmer: " << error.get_type() << ": " << error.get_msg() << endl;
-		}
-		parser.set_stemming_strategy(Xapian::QueryParser::STEM_ALL);
-		parser.set_stemmer(stemmer);
-	}
-	else
-	{
-		parser.set_stemming_strategy(Xapian::QueryParser::STEM_NONE);
-	}
-	// What's the default operator ?
-	if (defaultOperator == DEFAULT_OP_AND)
-	{
-		parser.set_default_op(Xapian::Query::OP_AND);
-	}
-	else
-	{
-		parser.set_default_op(Xapian::Query::OP_OR);
-	}
-	if (pIndex != NULL)
-	{
-		// The database is required for wildcards and spelling
-		parser.set_database(*pIndex);
-	}
-	// X prefixes should always include a colon
-	parser.add_boolean_prefix("site", "H");
-	parser.add_boolean_prefix("file", "P");
-	parser.add_boolean_prefix("ext", "XEXT:");
-	parser.add_prefix("title", "S");
-	parser.add_boolean_prefix("url", "U");
-	parser.add_boolean_prefix("dir", "XDIR:");
-	parser.add_boolean_prefix("lang", "L");
-	parser.add_boolean_prefix("type", "T");
-	parser.add_boolean_prefix("label", "XLABEL:");
-
-	// Any limit on what documents should be searched ?
-	if (limitQuery.empty() == false)
-	{
-		string limitedQuery(limitQuery);
-
-		limitedQuery += " AND ( ";
-		limitedQuery += freeQuery;
-		limitedQuery += " )";
-		freeQuery = limitedQuery;
-#ifdef DEBUG
-		cout << "XapianEngine::parseQuery: " << freeQuery << endl;
-#endif
-	}
-
-	// Date range
-	Xapian::DateValueRangeProcessor dateProcessor(0);
-	parser.add_valuerangeprocessor(&dateProcessor);
-
-	// Size with a "b" suffix, ie 1024..10240b
-#if XAPIAN_NUM_VERSION >= 1001000
-	Xapian::NumberValueRangeProcessor sizeProcessor(2, "b", false);
-	parser.add_valuerangeprocessor(&sizeProcessor);
-#elif XAPIAN_NUM_VERSION >= 1000002
-	// Xapian 1.02 is the bare minimum
-	Xapian::v102::NumberValueRangeProcessor sizeProcessor(2, "b", false);
-	parser.add_valuerangeprocessor(&sizeProcessor);
-#endif
-
-	// Time range
-	TimeValueRangeProcessor timeProcessor(3);
-	parser.add_valuerangeprocessor(&timeProcessor);
-
-	// What type of query is this ?
-	QueryProperties::QueryType type = queryProps.getType();
-	if (type != QueryProperties::XAPIAN_QP)
-	{
-		map<string, string> fieldMapping;
-
-		// Bare minimum mapping between Xesam fields and our prefixes 
-		fieldMapping["dc:title"] = "S";
-
-		XapianQueryBuilder builder(parser, fieldMapping);
-		XesamParser *pParser = NULL;
-
-		// Get a Xesam parser
-		if (type == QueryProperties::XESAM_QL)
-		{
-			pParser = new XesamQLParser();
-		}
-#ifdef HAVE_BOOST_SPIRIT_CORE_HPP
-		else if (type == QueryProperties::XESAM_UL)
-		{
-			pParser = new XesamULParser();
-		}
-#endif
-
-		if (pParser != NULL)
-		{
-			bool parsedQuery = pParser->parse(freeQuery, builder);
-
-			delete pParser;
-
-			if (parsedQuery == true)
-			{
-				return builder.get_query();
-			}
-		}
-
-		return Xapian::Query();
-	}
-
-	// Do some pre-processing : look for filters with quoted values
-	string::size_type escapedFilterEnd = 0;
-	string::size_type escapedFilterStart = freeQuery.find(":\"");
-	while ((escapedFilterStart != string::npos) &&
-		(escapedFilterStart < freeQuery.length() - 2))
-	{
-		escapedFilterEnd = freeQuery.find("\"", escapedFilterStart + 2);
-		if (escapedFilterEnd == string::npos)
-		{
-			break;
-		}
-
-		string filterValue = freeQuery.substr(escapedFilterStart + 2, escapedFilterEnd - escapedFilterStart - 2);
-		if (filterValue.empty() == false)
-		{
-			string escapedValue(Url::escapeUrl(filterValue));
-			bool escapeValue = false, hashValue = false;
-
-			// The value should be escaped and length-limited as done at indexing time
-			checkFilter(freeQuery, escapedFilterStart, escapeValue, hashValue);
-
-			if (escapeValue == false)
-			{
-				// No escaping
-				escapedValue = filterValue;
-			}
-			if (hashValue == true)
-			{
-				// Partially hash if necessary
-				escapedValue = XapianDatabase::limitTermLength(escapedValue, true);
-			}
-			else
-			{
-				escapedValue = XapianDatabase::limitTermLength(escapedValue);
-			}
-
-			freeQuery.replace(escapedFilterStart + 1, escapedFilterEnd - escapedFilterStart,
-				escapedValue);
-			escapedFilterEnd = escapedFilterEnd + escapedValue.length() - filterValue.length();
-		}
-		else
-		{
-			// No value !
-			freeQuery.replace(escapedFilterStart, escapedFilterEnd - escapedFilterStart + 1, ":");
-			escapedFilterEnd -= 2;
-		}
-#ifdef DEBUG
-		cout << "XapianEngine::parseQuery: replaced filter: " << freeQuery << endl;
-#endif
-
-		// Next
-		escapedFilterStart = freeQuery.find(":\"", escapedFilterEnd);
-	}
-
-	// Parse the query string with all necessary options
-	unsigned int flags = Xapian::QueryParser::FLAG_BOOLEAN|Xapian::QueryParser::FLAG_PHRASE|
-		Xapian::QueryParser::FLAG_LOVEHATE|Xapian::QueryParser::FLAG_BOOLEAN_ANY_CASE|
-		Xapian::QueryParser::FLAG_PURE_NOT;
-	if (minimal == false)
-	{
-		flags |= Xapian::QueryParser::FLAG_WILDCARD;
-#if ENABLE_XAPIAN_SPELLING_CORRECTION>0
-		flags |= Xapian::QueryParser::FLAG_SPELLING_CORRECTION;
-#endif
-	}
-	Xapian::Query parsedQuery = parser.parse_query(freeQuery, flags);
-	if (minimal == true)
-	{
-		return parsedQuery;
-	}
-
-#if ENABLE_XAPIAN_SPELLING_CORRECTION>0
-	// Any correction ?
-	correctedFreeQuery = parser.get_corrected_query_string();
-#ifdef DEBUG
-	if (correctedFreeQuery.empty() == false)
-	{
-		cout << "XapianEngine::parseQuery: corrected spelling to: " << correctedFreeQuery << endl;
-	}
-#endif
-#endif
-
-	return parsedQuery;
-}
-
-bool XapianEngine::queryDatabase(Xapian::Database *pIndex, Xapian::Query &query,
-	unsigned int startDoc, const QueryProperties &queryProps)
-{
-	Timer timer;
-	unsigned int maxResultsCount = queryProps.getMaximumResultsCount();
-	bool completedQuery = false;
-
-	if (pIndex == NULL)
-	{
-		return false;
-	}
-
-	// Start an enquire session on the database
-	Xapian::Enquire enquire(*pIndex);
-
-	timer.start();
-	try
-	{
-		AbstractGenerator abstractGen(pIndex, 50);
-		vector<string> seedTerms;
-
-		// Give the query object to the enquire session
-#ifdef DEBUG
-		cout << "XapianEngine::queryDatabase: enquiring about " << query.get_description() << endl;
-#endif
-		enquire.set_query(query);
-		// How should results be sorted ?
-		if (queryProps.getSortOrder() == QueryProperties::RELEVANCE)
-		{
-			// By relevance, only
-			enquire.set_sort_by_relevance_then_value(4);
-#ifdef DEBUG
-			cout << "XapianEngine::queryDatabase: sorting by relevance first" << endl;
-#endif
-		}
-		else if (queryProps.getSortOrder() == QueryProperties::DATE)
-		{
-			// By date, and then by relevance
-			enquire.set_sort_by_value_then_relevance(4);
-#ifdef DEBUG
-			cout << "XapianEngine::queryDatabase: sorting by date and time first" << endl;
-#endif
-		}
-
-		// Get the top results of the query
-		Xapian::MSet matches = enquire.get_mset(startDoc, maxResultsCount, (2 * maxResultsCount) + 1);
-		if (matches.empty() == false)
-		{
-			m_resultsCountEstimate = matches.get_matches_estimated();
-#ifdef DEBUG
-			cout << "XapianEngine::queryDatabase: found " << matches.size() << "/" << maxResultsCount
-				<< " results found from position " << startDoc << endl;
-			cout << "XapianEngine::queryDatabase: estimated " << matches.get_matches_lower_bound()
-				<< "/" << m_resultsCountEstimate << "/" << matches.get_matches_upper_bound() << endl;
-#endif
-
-			// Get the results
-			for (Xapian::MSetIterator mIter = matches.begin(); mIter != matches.end(); ++mIter)
-			{
-				Xapian::docid docId = *mIter;
-				Xapian::Document doc(mIter.get_document());
-
-				// What terms did this document match ?
-				seedTerms.clear();
-				for (Xapian::TermIterator termIter = enquire.get_matching_terms_begin(docId);
-					termIter != enquire.get_matching_terms_end(docId); ++termIter)
-				{
-					seedTerms.push_back(*termIter);
-				}
-
-				DocumentInfo thisResult;
-				thisResult.setExtract(abstractGen.generateAbstract(docId, seedTerms));
-				thisResult.setScore((float)mIter.get_percent());
-
-#ifdef DEBUG
-				cout << "XapianEngine::queryDatabase: found document ID " << docId << endl;
-#endif
-				XapianDatabase::recordToProps(doc.get_data(), &thisResult);
-				// XapianDatabase stored the language in English
-				thisResult.setLanguage(Languages::toLocale(thisResult.getLanguage()));
-
-				string url(thisResult.getLocation());
-				if (url.empty() == true)
-				{
-					// Hmmm this shouldn't be empty...
-					// Use this instead, even though the document isn't cached in the index
-					thisResult.setLocation(XapianDatabase::buildUrl(m_databaseName, docId));
-				}
-
-				// We don't know the index ID, just the document ID
-				thisResult.setIsIndexed(0, docId);
-
-				// Add this result
-				m_resultsList.push_back(thisResult);
-			}
-		}
-
-		completedQuery = true;
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "XapianEngine::queryDatabase: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	cout << "Ran query \"" << queryProps.getFreeQuery() << "\" in " << timer.stop() << " ms" << endl;
-
-	try
-	{
-		m_expandTerms.clear();
-
-		// Expand the query ?
-		if (m_expandDocuments.empty() == false)
-		{
-			Xapian::RSet expandDocs;
-			unsigned int count = 0;
-
-			for (set<string>::const_iterator docIter = m_expandDocuments.begin();
-				docIter != m_expandDocuments.end(); ++docIter)
-			{
-				string uniqueTerm(string("U") + XapianDatabase::limitTermLength(Url::escapeUrl(Url::canonicalizeUrl(*docIter)), true));
-
-				// Only one document may have this term
-				Xapian::PostingIterator postingIter = pIndex->postlist_begin(uniqueTerm);
-				if (postingIter != pIndex->postlist_end(uniqueTerm))
-				{
-					expandDocs.add_document(*postingIter);
-				}
-			}
-#ifdef DEBUG
-			cout << "XapianEngine::queryDatabase: expand from " << expandDocs.size() << " documents" << endl;
-#endif
-
-			// Get 10 non-prefixed terms
-			string allowedPrefixes("RSZ");
-			PrefixDecider expandDecider(allowedPrefixes);
-			Xapian::ESet expandTerms = enquire.get_eset(20, expandDocs, &expandDecider);
-#ifdef DEBUG
-			cout << "XapianEngine::queryDatabase: " << expandTerms.size() << " expand terms" << endl;
-#endif
-			for (Xapian::ESetIterator termIter = expandTerms.begin();
-				(termIter != expandTerms.end()) && (count < 10); ++termIter)
-			{
-				char firstChar = (*termIter)[0];
-
-				if (allowedPrefixes.find(firstChar) != string::npos)
-				{
-					m_expandTerms.insert((*termIter).substr(1));
-				}
-				else
-				{
-					m_expandTerms.insert(*termIter);
-				}
-				++count;
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "XapianEngine::queryDatabase: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-
-	// Be tolerant of errors as long as we got some results
-	if ((completedQuery == true) ||
-		(m_resultsList.empty() == false))
-	{
-		return true;
-	}
-
-	return false;
-}
-
-//
-// Implementation of SearchEngineInterface
-//
-
-/// Sets the set of documents to limit to.
-bool XapianEngine::setLimitSet(const set<string> &docsSet)
-{
-	unsigned int bracketsLevel = 1;
-	bool firstLocation = true;
-
-	m_limitQuery.clear();
-
-	if (docsSet.empty() == true)
-	{
-		return true;
-	}
-
-	// FIXME: there must be a better way !
-	m_limitQuery = "( ";
-	for (set<string>::const_iterator docIter = docsSet.begin();
-		docIter != docsSet.end(); ++docIter)
-	{
-		if (firstLocation == false)
-		{
-			m_limitQuery += " OR ( ";
-			++bracketsLevel;
-		}
-
-		m_limitQuery += "url:\"";
-		m_limitQuery += *docIter;
-		m_limitQuery += "\"";
-
-		firstLocation = false;
-	}
-	for (unsigned int count = 0; count < bracketsLevel; ++count)
-	{
-		m_limitQuery += " )";
-	}
-#ifdef DEBUG
-	cout << "XapianEngine::setLimitSet: " << m_limitQuery << endl;
-#endif
-
-	return true;
-}
-
-/// Sets the set of documents to expand from.
-bool XapianEngine::setExpandSet(const set<string> &docsSet)
-{
-	copy(docsSet.begin(), docsSet.end(),
-		inserter(m_expandDocuments, m_expandDocuments.begin()));
-#ifdef DEBUG
-	cout << "XapianEngine::setExpandSet: " << m_expandDocuments.size() << " documents" << endl;
-#endif
-
-	return true;
-}
-
-/// Runs a query; true if success.
-bool XapianEngine::runQuery(QueryProperties& queryProps,
-	unsigned int startDoc)
-{
-	// Clear the results list
-	m_resultsList.clear();
-	m_resultsCountEstimate = 0;
-	m_correctedFreeQuery.clear();
-
-	if (queryProps.isEmpty() == true)
-	{
-#ifdef DEBUG
-		cout << "XapianEngine::runQuery: query is empty" << endl;
-#endif
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, true);
-	if (pDatabase == NULL)
-	{
-		return false;
-	}
-
-	// Get the latest revision...
-	pDatabase->reopen();
-	Xapian::Database *pIndex = pDatabase->readLock();
-	try
-	{
-		string stemLanguage(queryProps.getFilter("lang"));
-		unsigned int searchStep = 1;
-
-		// Searches are run in this order :
-		// 1. don't stem terms
-		// 2. if no results, stem terms if a language is defined for the query
-		Xapian::Query fullQuery = parseQuery(pIndex, queryProps, "",
-			m_defaultOperator, m_limitQuery, m_correctedFreeQuery);
-		while (fullQuery.empty() == false)
-		{
-			// Query the database
-			if (queryDatabase(pIndex, fullQuery, startDoc, queryProps) == false)
-			{
-				break;
-			}
-
-			// The search did succeed but didn't return anything
-			if ((m_resultsList.empty() == true) &&
-				(searchStep == 1) &&
-				(stemLanguage.empty() == false))
-			{
-#ifdef DEBUG
-				cout << "XapianEngine::runQuery: trying again with stemming" << endl;
-#endif
-				fullQuery = parseQuery(pIndex, queryProps, Languages::toEnglish(stemLanguage),
-					m_defaultOperator, m_limitQuery, m_correctedFreeQuery);
-				++searchStep;
-				continue;
-			}
-
-			pDatabase->unlock();
-			return true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "XapianEngine::runQuery: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	pDatabase->unlock();
-
-	return false;
-}

Deleted: trunk/Search/XapianEngine.h
===================================================================
--- trunk/Search/XapianEngine.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/XapianEngine.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,77 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _XAPIAN_ENGINE_H
-#define _XAPIAN_ENGINE_H
-
-#include <string>
-#include <set>
-#include <vector>
-
-#include <xapian.h>
-
-#include "config.h"
-#include "SearchEngineInterface.h"
-#include "DownloaderFactory.h"
-
-#if !ENABLE_XAPIAN_SPELLING_CORRECTION
-// Spelling correction in Xapian 1.0.2 may cause a crash
-// See http://www.xapian.org/cgi-bin/bugzilla/show_bug.cgi?id=194
-#if XAPIAN_NUM_VERSION > 1000002
-#define ENABLE_XAPIAN_SPELLING_CORRECTION 1
-#else
-#define ENABLE_XAPIAN_SPELLING_CORRECTION 0
-#endif
-#endif
-
-/// Wraps Xapian's search funtionality.
-class XapianEngine : public SearchEngineInterface
-{
-	public:
-		XapianEngine(const std::string &database);
-		virtual ~XapianEngine();
-
-		/// Sets the set of documents to limit to.
-		virtual bool setLimitSet(const std::set<std::string> &docsSet);
-
-		/// Sets the set of documents to expand from.
-		virtual bool setExpandSet(const std::set<std::string> &docsSet);
-
-		/// Runs a query; true if success.
-		virtual bool runQuery(QueryProperties& queryProps,
-			unsigned int startDoc = 0);
-
-	protected:
-		std::string m_databaseName;
-		std::string m_limitQuery;
-		std::set<std::string> m_expandDocuments;
-
-		bool queryDatabase(Xapian::Database *pIndex, Xapian::Query &query,
-			unsigned int startDoc, const QueryProperties &queryProps);
-
-		static Xapian::Query parseQuery(Xapian::Database *pIndex, const QueryProperties &queryProps,
-			const string &stemLanguage, DefaultOperator defaultOperator,
-			const string &limitQuery, string &correctedFreeQuery, bool minimal = false);
-
-	private:
-		XapianEngine(const XapianEngine &other);
-		XapianEngine &operator=(const XapianEngine &other);
-
-};
-
-#endif // _XAPIAN_ENGINE_H

Deleted: trunk/Search/pinot-search.1
===================================================================
--- trunk/Search/pinot-search.1	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/pinot-search.1	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,58 +0,0 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-SEARCH "1" "November 2007" "pinot-search - pinot 0.81" "User Commands"
-.SH NAME
-pinot-search \- Query search engines from the command-line
-.SH SYNOPSIS
-.B pinot-search
-[\fIOPTIONS\fR] \fISEARCHENGINETYPE SEARCHENGINENAME|SEARCHENGINEOPTION QUERYINPUT\fR
-.SH DESCRIPTION
-pinot\-search \- Query search engines from the command\-line
-.SH OPTIONS
-.TP
-\fB\-h\fR, \fB\-\-help\fR
-display this help and exit
-.TP
-\fB\-m\fR, \fB\-\-max\fR
-maximum number of results (default 10)
-.TP
-\fB\-a\fR, \fB\-\-proxyaddress\fR
-proxy address
-.TP
-\fB\-p\fR, \fB\-\-proxyport\fR
-proxy port
-.TP
-\fB\-t\fR, \fB\-\-proxytype\fR
-proxy type (default HTTP, SOCKS4, SOCKS5)
-.TP
-\fB\-c\fR, \fB\-\-tocsv\fR
-file to export results in CSV format to
-.TP
-\fB\-x\fR, \fB\-\-toxml\fR
-file to export results in XML format to
-.TP
-\fB\-v\fR, \fB\-\-version\fR
-output version information and exit
-.TP
-\fB\-q\fR, \fB\-\-xesamql\fR
-query input is a file containing Xesam QL
-.TP
-\fB\-u\fR, \fB\-\-xesamul\fR
-query input is a file containing Xesam UL
-.PP
-Supported search engine types are googleapi opensearch sherlock xapian
-.SH EXAMPLES
-pinot\-search googleapi mygoogleapikey "clowns"
-.PP
-pinot\-search opensearch /usr/share/pinot/engines/KrustyDescription.xml "clowns"
-.PP
-pinot\-search \fB\-\-max\fR 20 sherlock /usr/share/pinot/engines/Bozo.src "clowns"
-.PP
-pinot\-search \fB\-\-max\fR 10 xapian ~/.pinot/index "clowns"
-.PP
-pinot\-search xapian somehostname:12345 "clowns"
-.SH "REPORTING BUGS"
-Report bugs to fabricecolin at users.berlios.de
-.PP
-This is free software.  You may redistribute copies of it under the terms of
-the GNU General Public License <http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html>.
-There is NO WARRANTY, to the extent permitted by law.

Deleted: trunk/Search/pinot-search.cpp
===================================================================
--- trunk/Search/pinot-search.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/pinot-search.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,344 +0,0 @@
-/*
- *  Copyright 2005,2006,2007 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <getopt.h>
-#include <iostream>
-#include <fstream>
-#include <string>
-
-#include "Languages.h"
-#include "MIMEScanner.h"
-#include "Url.h"
-#include "XapianDatabaseFactory.h"
-#include "SearchEngineFactory.h"
-#include "ResultsExporter.h"
-#include "DownloaderFactory.h"
-#include "config.h"
-
-using namespace std;
-
-static struct option g_longOptions[] = {
-	{"help", 0, 0, 'h'},
-	{"max", 1, 0, 'm'},
-	{"proxyaddress", 1, 0, 'a'},
-	{"proxyport", 1, 0, 'p'},
-	{"proxytype", 1, 0, 't'},
-	{"tocsv", 1, 0, 'c'},
-	{"toxml", 1, 0, 'x'},
-	{"version", 0, 0, 'v'},
-	{"xesamql", 0, 0, 'q'},
-	{"xesamul", 0, 0, 'u'},
-	{0, 0, 0, 0}
-};
-
-static bool loadFile(const string &xesamFile, string &fileContents)
-{
-	ifstream inputFile;
-	bool readFile = false;
-
-	inputFile.open(xesamFile.c_str());
-	if (inputFile.good() == true)
-	{
-		inputFile.seekg(0, ios::end);
-		int length = inputFile.tellg();
-		inputFile.seekg(0, ios::beg);
-
-		char *pFileBuffer = new char[length + 1];
-		inputFile.read(pFileBuffer, length);
-		if (inputFile.fail() == false)
-		{
-			pFileBuffer[length] = '\0';
-
-			fileContents = string(pFileBuffer, length);
-			readFile = true;
-		}
-		delete[] pFileBuffer;
-	}
-	inputFile.close();
-
-	return readFile;
-}
-
-static void printHelp(void)
-{
-	set<string> engines;
-
-	// Help
-	SearchEngineFactory::getSupportedEngines(engines);
-	cout << "pinot-search - Query search engines from the command-line\n\n"
-		<< "Usage: pinot-search [OPTIONS] SEARCHENGINETYPE SEARCHENGINENAME|SEARCHENGINEOPTION QUERYINPUT\n\n"
-		<< "Options:\n"
-		<< "  -h, --help                display this help and exit\n"
-		<< "  -m, --max                 maximum number of results (default 10)\n"
-		<< "  -a, --proxyaddress        proxy address\n"
-		<< "  -p, --proxyport           proxy port\n"
-		<< "  -t, --proxytype           proxy type (default HTTP, SOCKS4, SOCKS5)\n"
-		<< "  -c, --tocsv               file to export results in CSV format to\n"
-		<< "  -x, --toxml               file to export results in XML format to\n"
-		<< "  -v, --version             output version information and exit\n"
-		<< "  -q, --xesamql             query input is a file containing Xesam QL\n"
-		<< "  -u, --xesamul             query input is a file containing Xesam UL\n\n"
-		<< "Supported search engine types are";
-	for (set<string>::iterator engineIter = engines.begin(); engineIter != engines.end(); ++engineIter)
-	{
-		cout << " " << *engineIter;
-	}
-	cout << "\n\nExamples:\n"
-#ifdef HAVE_GOOGLEAPI
-		<< "pinot-search googleapi mygoogleapikey \"clowns\"\n\n"
-#endif
-		<< "pinot-search opensearch " << PREFIX << "/share/pinot/engines/KrustyDescription.xml \"clowns\"\n\n"
-		<< "pinot-search --max 20 sherlock " << PREFIX << "/share/pinot/engines/Bozo.src \"clowns\"\n\n"
-		<< "pinot-search --max 10 xapian ~/.pinot/index \"clowns\"\n\n"
-		<< "pinot-search xapian somehostname:12345 \"clowns\"\n\n"
-		<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
-}
-
-int main(int argc, char **argv)
-{
-	QueryProperties::QueryType queryType = QueryProperties::XAPIAN_QP;
-	string engineType, option, csvExport, xmlExport, proxyAddress, proxyPort, proxyType;
-	unsigned int maxResultsCount = 10; 
-	int longOptionIndex = 0;
-	bool printResults = true;
-
-	// Look at the options
-	int optionChar = getopt_long(argc, argv, "c:hm:a:p:qt:uvx:", g_longOptions, &longOptionIndex);
-	while (optionChar != -1)
-	{
-		switch (optionChar)
-		{
-			case 'a':
-				if (optarg != NULL)
-				{
-					proxyAddress = optarg;
-				}
-				break;
-			case 'c':
-				if (optarg != NULL)
-				{
-					csvExport = optarg;
-					printResults = false;
-				}
-				break;
-			case 'h':
-				printHelp();
-				return EXIT_SUCCESS;
-			case 'm':
-				if (optarg != NULL)
-				{
-					maxResultsCount = (unsigned int )atoi(optarg);
-				}
-				break;
-			case 'p':
-				if (optarg != NULL)
-				{
-					proxyPort = optarg;
-				}
-				break;
-			case 'q':
-				queryType = QueryProperties::XESAM_QL;
-				break;
-			case 't':
-				if (optarg != NULL)
-				{
-					proxyType = optarg;
-				}
-				break;
-			case 'u':
-				queryType = QueryProperties::XESAM_UL;
-				break;
-			case 'v':
-				cout << "pinot-search - " << PACKAGE_STRING << "\n\n"
-					<< "This is free software.  You may redistribute copies of it under the terms of\n"
-					<< "the GNU General Public License <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>.\n"
-					<< "There is NO WARRANTY, to the extent permitted by law." << endl;
-				return EXIT_SUCCESS;
-			case 'x':
-				if (optarg != NULL)
-				{
-					xmlExport = optarg;
-					printResults = false;
-				}
-				break;
-			default:
-				return EXIT_FAILURE;
-		}
-
-		// Next option
-		optionChar = getopt_long(argc, argv, "c:hm:a:p:qt:uvx:", g_longOptions, &longOptionIndex);
-	}
-
-	if (argc == 1)
-	{
-		printHelp();
-		return EXIT_SUCCESS;
-	}
-
-	if ((argc < 4) ||
-		(argc - optind != 3))
-	{
-		cerr << "Wrong number of parameters" << endl;
-		return EXIT_FAILURE;
-	}
-
-	MIMEScanner::initialize("", "");
-	DownloaderInterface::initialize();
-	// Localize language names
-	Languages::setIntlName(0, "Unknown");
-	Languages::setIntlName(1, "Danish");
-	Languages::setIntlName(2, "Dutch");
-	Languages::setIntlName(3, "English");
-	Languages::setIntlName(4, "Finnish");
-	Languages::setIntlName(5, "French");
-	Languages::setIntlName(6, "German");
-	Languages::setIntlName(7, "Hungarian");
-	Languages::setIntlName(8, "Italian");
-	Languages::setIntlName(9, "Norwegian");
-	Languages::setIntlName(10, "Portuguese");
-	Languages::setIntlName(11, "Romanian");
-	Languages::setIntlName(12, "Russian");
-	Languages::setIntlName(13, "Spanish");
-	Languages::setIntlName(14, "Swedish");
-	Languages::setIntlName(15, "Turkish");
-
-	engineType = argv[optind];
-	option = argv[optind + 1];
-	char *pQueryInput = argv[optind + 2];
-
-	// Which SearchEngine ?
-	SearchEngineInterface *pEngine = SearchEngineFactory::getSearchEngine(engineType, option);
-	if (pEngine == NULL)
-	{
-		cerr << "Couldn't obtain search engine instance" << endl;
-
-		DownloaderInterface::shutdown();
-		MIMEScanner::shutdown();
-
-		return EXIT_FAILURE;
-	}
-
-	// Set up the proxy
-	DownloaderInterface *pDownloader = pEngine->getDownloader();
-	if ((pDownloader != NULL) &&
-		(proxyAddress.empty() == false) &&
-		(proxyPort.empty() == false))
-	{
-		pDownloader->setSetting("proxyaddress", proxyAddress);
-		pDownloader->setSetting("proxyport", proxyPort);
-		pDownloader->setSetting("proxytype", proxyType);
-	}
-
-	// Set the query
-	QueryProperties queryProps("pinot-search", "", queryType);
-	if (queryType == QueryProperties::XAPIAN_QP)
-	{
-		queryProps.setFreeQuery(pQueryInput);
-	}
-	else
-	{
-		string fileContents;
-
-		// Load the query from file
-		if (loadFile(pQueryInput, fileContents) == false)
-		{
-			cerr << "Couldn't load query from file " << pQueryInput << endl;
-
-			DownloaderInterface::shutdown();
-			MIMEScanner::shutdown();
-
-			return EXIT_FAILURE;
-		}
-
-		queryProps.setFreeQuery(fileContents);
-	}
-
-	queryProps.setMaximumResultsCount(maxResultsCount);
-	pEngine->setDefaultOperator(SearchEngineInterface::DEFAULT_OP_AND);
-	if (pEngine->runQuery(queryProps) == true)
-	{
-		string resultsPage;
-
-		// Try getting a list of links
-		const vector<DocumentInfo> resultsList = pEngine->getResults();
-		if (resultsList.empty() == false)
-		{
-			if (printResults == true)
-			{
-				unsigned int count = 0;
-
-				cout << "Matching documents are :" << endl;
-
-				vector<DocumentInfo>::const_iterator resultIter = resultsList.begin();
-				while (resultIter != resultsList.end())
-				{
-					string rawUrl(resultIter->getLocation());
-
-					cout << count << " Location : '" << rawUrl << "'"<< endl;
-					cout << count << " Title    : " << resultIter->getTitle() << endl;
-					cout << count << " Type     : " << resultIter->getType() << endl;
-					cout << count << " Language : " << resultIter->getLanguage() << endl;
-					cout << count << " Date     : " << resultIter->getTimestamp() << endl;
-					cout << count << " Size     : " << resultIter->getSize() << endl;
-					cout << count << " Extract  : " << resultIter->getExtract() << endl;
-					cout << count << " Score    : " << resultIter->getScore() << endl;
-					count++;
-
-					// Next
-					resultIter++;
-				}
-			}
-			else
-			{
-				string engineName(SearchEngineFactory::getSearchEngineName(engineType, option));
-
-				if (csvExport.empty() == false)
-				{
-					CSVExporter exporter(csvExport, queryProps);
-
-					exporter.exportResults(engineName, maxResultsCount, resultsList);
-				}
-
-				if (xmlExport.empty() == false)
-				{
-					OpenSearchExporter exporter(xmlExport, queryProps);
-
-					exporter.exportResults(engineName, maxResultsCount, resultsList);
-				}
-			}
-		}
-		else
-		{
-			cerr << "Couldn't get a results list !" << endl;
-		}
-	}
-	else
-	{
-		cerr << "Couldn't run query on search engine " << engineType << endl;
-	}
-
-	delete pEngine;
-
-	XapianDatabaseFactory::closeAll();
-	DownloaderInterface::shutdown();
-	MIMEScanner::shutdown();
-
-	return EXIT_SUCCESS;
-}



From fabricecolin at mail.berlios.de  Sat Dec  1 10:36:26 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 1 Dec 2007 10:36:26 +0100
Subject: [Pinot-svn] r1134 - in trunk/IndexSearch: . Xapian
Message-ID: <200712010936.lB19aQ8e027447@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-01 10:36:25 +0100 (Sat, 01 Dec 2007)
New Revision: 1134

Added:
   trunk/IndexSearch/DBusIndex.cpp
   trunk/IndexSearch/DBusIndex.h
Removed:
   trunk/IndexSearch/DBusXapianIndex.cpp
   trunk/IndexSearch/DBusXapianIndex.h
Modified:
   trunk/IndexSearch/IndexFactory.cpp
   trunk/IndexSearch/IndexInterface.h
   trunk/IndexSearch/Xapian/XapianEngine.cpp
   trunk/IndexSearch/Xapian/XapianIndex.cpp
   trunk/IndexSearch/Xapian/XapianIndex.h
   trunk/IndexSearch/pinot-label.cpp
Log:
Added IndexInterface::reopen(). Replaced DBusXapianIndex with DBusIndex.
Used IndexFactory whenever possible.


Added: trunk/IndexSearch/DBusIndex.cpp
===================================================================
--- trunk/IndexSearch/DBusIndex.cpp	2007-12-01 09:25:54 UTC (rev 1133)
+++ trunk/IndexSearch/DBusIndex.cpp	2007-12-01 09:36:25 UTC (rev 1134)
@@ -0,0 +1,1012 @@
+/*
+ *  Copyright 2007 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+
+#include "Languages.h"
+#include "DBusIndex.h"
+
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+using std::set;
+using std::map;
+using std::min;
+
+static const char *g_fieldNames[] = { "caption", "url", "type", "language", "modtime", "size", NULL };
+
+static DBusGConnection *getBusConnection(void)
+{
+	GError *pError = NULL;
+	DBusGConnection *pBus = NULL;
+
+	pBus = dbus_g_bus_get(DBUS_BUS_SESSION, &pError);
+	if (pBus == NULL)
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusIndex: couldn't connect to session bus: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	return pBus;
+}
+
+static DBusGProxy *getBusProxy(DBusGConnection *pBus)
+{
+	if (pBus == NULL)
+	{
+		return NULL;
+	}
+
+	return dbus_g_proxy_new_for_name(pBus,
+		"de.berlios.Pinot", "/de/berlios/Pinot", "de.berlios.Pinot");
+}
+
+DBusIndex::DBusIndex(IndexInterface *pROIndex) :
+	IndexInterface(),
+	m_pROIndex(pROIndex)
+{
+}
+
+DBusIndex::DBusIndex(const DBusIndex &other) :
+	IndexInterface(other),
+	m_pROIndex(other.m_pROIndex)
+{
+}
+
+DBusIndex::~DBusIndex()
+{
+	// Noone else is going to delete this
+	delete m_pROIndex;
+}
+
+DBusIndex &DBusIndex::operator=(const DBusIndex &other)
+{
+	if (this != &other)
+	{
+		IndexInterface::operator=(other);
+		m_pROIndex = other.m_pROIndex;
+	}
+
+	return *this;
+}
+
+/// Extracts docId and docInfo from a dbus message.
+bool DBusIndex::documentInfoFromDBus(DBusMessageIter *iter, unsigned int &docId,
+	DocumentInfo &docInfo)
+{
+	DBusMessageIter array_iter;
+	DBusMessageIter struct_iter;
+
+	if (iter == NULL)
+	{
+		return false;
+	}
+
+	int type = dbus_message_iter_get_arg_type(iter);
+	if (type != DBUS_TYPE_UINT32)
+	{
+#ifdef DEBUG
+		cout << "DBusIndex::documentInfoFromDBus: expected unsigned integer, got " << type << endl;
+#endif
+		return false;
+	}
+	dbus_message_iter_get_basic(iter, &docId);
+	dbus_message_iter_next(iter);
+	
+	type = dbus_message_iter_get_arg_type(iter);
+	if (type != DBUS_TYPE_ARRAY)
+	{
+#ifdef DEBUG
+		cout << "DBusIndex::documentInfoFromDBus: expected array, got " << type << endl;
+#endif
+		return false;
+	}
+	dbus_message_iter_recurse(iter, &array_iter);
+
+	do
+	{
+		const gchar *pName = NULL;
+		const gchar *pValue = NULL;
+
+		type = dbus_message_iter_get_arg_type(&array_iter);
+		if (type != DBUS_TYPE_STRUCT)
+		{
+#ifdef DEBUG
+			cout << "DBusIndex::documentInfoFromDBus: expected struct, got " << type << endl;
+#endif
+			return false;
+		}
+
+		dbus_message_iter_recurse(&array_iter, &struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &pName);
+		if (pName == NULL)
+		{
+#ifdef DEBUG
+			cout << "DBusIndex::documentInfoFromDBus: invalid field name" << endl;
+#endif
+		}
+
+		dbus_message_iter_next(&struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &pValue);
+		if (pValue == NULL)
+		{
+#ifdef DEBUG
+			cout << "DBusIndex::documentInfoFromDBus: invalid field value" << endl;
+#endif
+			continue;
+		}
+#ifdef DEBUG
+		cout << "DBusIndex::documentInfoFromDBus: field " << pName << "=" << pValue << endl;
+#endif
+
+		// Populate docInfo
+		string fieldName(pName);
+		if (fieldName == g_fieldNames[0])
+		{
+			docInfo.setTitle(pValue);
+		}
+		else if (fieldName == g_fieldNames[1])
+		{
+			docInfo.setLocation(pValue);
+		}
+		else if (fieldName == g_fieldNames[2])
+		{
+			docInfo.setType(pValue);
+		}
+		else if (fieldName == g_fieldNames[3])
+		{
+			docInfo.setLanguage(Languages::toLocale(pValue));
+		}
+		else if (fieldName == g_fieldNames[4])
+		{
+			docInfo.setTimestamp(pValue);
+		}
+		else if (fieldName == g_fieldNames[5])
+		{
+			docInfo.setSize((off_t )atoi(pValue));
+		}
+	}
+	while (dbus_message_iter_next(&array_iter));
+
+	return true;
+}
+
+/// Converts docId and docInfo to a dbus message.
+bool DBusIndex::documentInfoToDBus(DBusMessageIter *iter, unsigned int docId,
+	const DocumentInfo &docInfo)
+{
+        DBusMessageIter array_iter;
+	DBusMessageIter struct_iter;
+
+	if (iter == NULL)
+	{
+		return false;
+	}
+
+	// Append the document ID ?
+	if (docId != 0)
+	{
+		dbus_message_iter_append_basic(iter, DBUS_TYPE_UINT32, &docId);
+	}
+	if (!dbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,
+		DBUS_STRUCT_BEGIN_CHAR_AS_STRING \
+		DBUS_TYPE_STRING_AS_STRING \
+		DBUS_TYPE_STRING_AS_STRING \
+		DBUS_STRUCT_END_CHAR_AS_STRING, &array_iter))
+	{
+#ifdef DEBUG
+		cout << "DBusIndex::documentInfoToDBus: couldn't open array container" << endl;
+#endif
+		return false;
+	}
+
+	for (unsigned int fieldNum = 0; g_fieldNames[fieldNum] != NULL; ++fieldNum)
+	{
+		const char *pValue = NULL;
+		char sizeStr[64];
+
+		if (!dbus_message_iter_open_container(&array_iter,
+			DBUS_TYPE_STRUCT, NULL, &struct_iter))
+		{
+#ifdef DEBUG
+			cout << "DBusIndex::documentInfoToDBus: couldn't open struct container" << endl;
+#endif
+			return false;
+		}
+
+		dbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_STRING, &g_fieldNames[fieldNum]);
+		switch (fieldNum)
+		{
+			case 0:
+				pValue = docInfo.getTitle().c_str();
+				break;
+			case 1:
+				pValue = docInfo.getLocation().c_str();
+				break;
+			case 2:
+				pValue = docInfo.getType().c_str();
+				break;
+			case 3:
+				pValue = Languages::toEnglish(docInfo.getLanguage()).c_str();
+				break;
+			case 4:
+				pValue = docInfo.getTimestamp().c_str();
+				break;
+			case 5:
+			default:
+				snprintf(sizeStr, 64, "%u", docInfo.getSize());
+				pValue = sizeStr;
+				break;
+		}
+		dbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_STRING, &pValue);
+#ifdef DEBUG
+		cout << "DBusIndex::documentInfoToDBus: field " << g_fieldNames[fieldNum] << "=" << pValue << endl;
+#endif
+
+		if (!dbus_message_iter_close_container(&array_iter, &struct_iter))
+		{
+#ifdef DEBUG
+			cout << "DBusIndex::documentInfoToDBus: couldn't close struct container" << endl;
+#endif
+			return false;
+		}
+	}
+
+	if (!dbus_message_iter_close_container(iter, &array_iter))
+	{
+#ifdef DEBUG
+		cout << "DBusIndex::documentInfoToDBus: couldn't close array container" << endl;
+#endif
+		return false;
+	}
+
+	return true;
+}
+
+/// Asks the D-Bus service to reload its configuration.
+bool DBusIndex::reload(void)
+{
+	gboolean reloading = FALSE;
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusIndex::reload: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	if (dbus_g_proxy_call(pBusProxy, "Reload", &pError,
+		G_TYPE_INVALID,
+		G_TYPE_BOOLEAN, &reloading,
+		G_TYPE_INVALID) == FALSE)
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusIndex::reload: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	if (reloading == TRUE)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+
+//
+// Implementation of IndexInterface
+//
+
+/// Returns false if the index couldn't be opened.
+bool DBusIndex::isGood(void) const
+{
+	return m_pROIndex->isGood();
+}
+
+/// Gets the version number.
+string DBusIndex::getVersion(void) const
+{
+	return m_pROIndex->getVersion();
+}
+
+/// Sets the version number.
+bool DBusIndex::setVersion(const string &version) const
+{
+	cerr << "DBusIndex::setVersion: not allowed" << endl;
+	return false;
+}
+
+/// Gets the index location.
+string DBusIndex::getLocation(void) const
+{
+	return m_pROIndex->getLocation();
+}
+
+/// Returns a document's properties.
+bool DBusIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
+{
+	reopen();
+
+	return m_pROIndex->getDocumentInfo(docId, docInfo);
+}
+
+/// Returns a document's terms count.
+unsigned int DBusIndex::getDocumentTermsCount(unsigned int docId) const
+{
+	reopen();
+
+	return m_pROIndex->getDocumentTermsCount(docId);
+}
+
+/// Returns a document's terms.
+bool DBusIndex::getDocumentTerms(unsigned int docId,
+	map<unsigned int, string> &wordsBuffer) const
+{
+	reopen();
+
+	return m_pROIndex->getDocumentTerms(docId, wordsBuffer);
+}
+
+/// Sets the list of known labels.
+bool DBusIndex::setLabels(const set<string> &labels)
+{
+	// Not allowed here
+	return false;
+}
+
+/// Gets the list of known labels.
+bool DBusIndex::getLabels(set<string> &labels) const
+{
+	reopen();
+
+	return m_pROIndex->getLabels(labels);
+}
+
+/// Gets the list of known labels.
+bool DBusIndex::getLabels(set<string> &labels, bool forceDBus) const
+{
+	bool gotLabels = false;
+
+	if (forceDBus == false)
+	{
+		// Call overload
+		return getLabels(labels);
+	}
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusIndex::getLabels: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	char **pLabels;
+
+	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
+	if (dbus_g_proxy_call(pBusProxy, "GetLabels", &pError,
+		G_TYPE_INVALID,
+		G_TYPE_STRV, &pLabels,
+		G_TYPE_INVALID) == TRUE)
+	{
+		for (char **pLabel = pLabels; (*pLabel) != NULL; ++pLabel)
+		{
+			labels.insert(*pLabel);
+		}
+
+		// Free the array
+		g_strfreev(pLabels);
+
+		gotLabels = true;
+	}
+	else
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusIndex::getLabels: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	return gotLabels;
+}
+
+/// Adds a label.
+bool DBusIndex::addLabel(const string &name)
+{
+	bool addedLabel = false;
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusIndex::addLabel: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	const char *pLabel = name.c_str();
+
+	if (dbus_g_proxy_call(pBusProxy, "AddLabel", &pError,
+		G_TYPE_STRING, pLabel,
+		G_TYPE_INVALID,
+		G_TYPE_STRING, &pLabel,
+		G_TYPE_INVALID) == TRUE)
+	{
+		addedLabel = true;
+	}
+	else
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusIndex::addLabel: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	return addedLabel;
+}
+
+/// Renames a label.
+bool DBusIndex::renameLabel(const string &name, const string &newName)
+{
+	bool renamedLabel = false;
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusIndex::renameLabel: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	const char *pOldLabel = name.c_str();
+	const char *pNewLabel = newName.c_str();
+
+	if (dbus_g_proxy_call(pBusProxy, "RenameLabel", &pError,
+		G_TYPE_STRING, pOldLabel,
+		G_TYPE_STRING, pNewLabel,
+		G_TYPE_INVALID,
+		G_TYPE_STRING, &pNewLabel,
+		G_TYPE_INVALID) == TRUE)
+	{
+		renamedLabel = true;
+	}
+	else
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusIndex::renameLabel: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	return renamedLabel;
+}
+
+/// Deletes all references to a label.
+bool DBusIndex::deleteLabel(const string &name)
+{
+	bool deletedLabel = false;
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusIndex::deleteLabel: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	const char *pLabel = name.c_str();
+
+	if (dbus_g_proxy_call(pBusProxy, "DeleteLabel", &pError,
+		G_TYPE_STRING, pLabel,
+		G_TYPE_INVALID,
+		G_TYPE_STRING, &pLabel,
+		G_TYPE_INVALID) == TRUE)
+	{
+		deletedLabel = true;
+	}
+	else
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusIndex::deleteLabel: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	return deletedLabel;
+}
+
+/// Determines whether a document has a label.
+bool DBusIndex::hasLabel(unsigned int docId, const string &name) const
+{
+	reopen();
+
+	return m_pROIndex->hasLabel(docId, name);
+}
+
+/// Returns a document's labels.
+bool DBusIndex::getDocumentLabels(unsigned int docId, set<string> &labels) const
+{
+	reopen();
+
+	return m_pROIndex->getDocumentLabels(docId, labels);
+}
+
+/// Returns a document's labels.
+bool DBusIndex::getDocumentLabels(unsigned int docId, set<string> &labels, bool forceDBus) const
+{
+	bool gotLabels = false;
+
+	if (forceDBus == false)
+	{
+		// Call overload
+		return getDocumentLabels(docId, labels);
+	}
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusIndex::getDocumentLabels: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	char **pLabels;
+
+	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
+	if (dbus_g_proxy_call(pBusProxy, "GetDocumentLabels", &pError,
+		G_TYPE_UINT, docId,
+		G_TYPE_INVALID,
+		G_TYPE_STRV, &pLabels,
+		G_TYPE_INVALID) == TRUE)
+	{
+		for (char **pLabel = pLabels; (*pLabel) != NULL; ++pLabel)
+		{
+			labels.insert(*pLabel);
+		}
+
+		// Free the array
+		g_strfreev(pLabels);
+
+		gotLabels = true;
+	}
+	else
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusIndex::getDocumentLabels: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	return gotLabels;
+}
+
+/// Sets a document's labels.
+bool DBusIndex::setDocumentLabels(unsigned int docId, const set<string> &labels,
+	bool resetLabels)
+{
+	bool updatedLabels = false;
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusIndex::setDocumentLabels: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	dbus_uint32_t labelsCount = labels.size();
+	char **pLabels;
+	unsigned int labelIndex = 0;
+
+	pLabels = g_new(char *, labelsCount + 1);
+	for (set<string>::const_iterator labelIter = labels.begin();
+		labelIter != labels.end(); ++labelIter)
+	{
+		pLabels[labelIndex] = g_strdup(labelIter->c_str());
+		++labelIndex;
+	}
+	pLabels[labelIndex] = NULL;
+
+	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
+	if (dbus_g_proxy_call(pBusProxy, "SetDocumentLabels", &pError,
+		G_TYPE_UINT, docId,
+		G_TYPE_STRV, pLabels,
+		G_TYPE_BOOLEAN, (resetLabels == true ? TRUE : FALSE),
+		G_TYPE_INVALID,
+		G_TYPE_UINT, &docId,
+		G_TYPE_INVALID) == TRUE)
+	{
+		updatedLabels = true;
+	}
+	else
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusIndex::setDocumentLabels: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	// Free the array
+	g_strfreev(pLabels);
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	return updatedLabels;
+}
+
+/// Sets documents' labels.
+bool DBusIndex::setDocumentsLabels(const set<unsigned int> &docIds,
+	const set<string> &labels, bool resetLabels)
+{
+	gboolean updatedLabels = FALSE;
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusIndex::setDocumentsLabels: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	dbus_uint32_t idsCount = docIds.size();
+	dbus_uint32_t labelsCount = labels.size();
+	char **pDocIds;
+	char **pLabels;
+	unsigned int idIndex = 0, labelIndex = 0;
+
+	pDocIds = g_new(char *, idsCount + 1);
+	pLabels = g_new(char *, labelsCount + 1);
+	for (set<unsigned int>::const_iterator idIter = docIds.begin();
+		idIter != docIds.end(); ++idIter)
+	{
+		pDocIds[idIndex] = g_strdup_printf("%u", *idIter); 
+#ifdef DEBUG
+		cout << "DBusIndex::setDocumentsLabels: document " << pDocIds[idIndex] << endl;
+#endif
+		++idIndex;
+	}
+	pDocIds[idIndex] = NULL;
+	for (set<string>::const_iterator labelIter = labels.begin();
+		labelIter != labels.end(); ++labelIter)
+	{
+		pLabels[labelIndex] = g_strdup(labelIter->c_str());
+#ifdef DEBUG
+		cout << "DBusIndex::setDocumentsLabels: label " << pLabels[labelIndex] << endl;
+#endif
+		++labelIndex;
+	}
+	pLabels[labelIndex] = NULL;
+
+	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
+	if (dbus_g_proxy_call(pBusProxy, "SetDocumentsLabels", &pError,
+		G_TYPE_STRV, pDocIds,
+		G_TYPE_STRV, pLabels,
+		G_TYPE_BOOLEAN, (resetLabels == true ? TRUE : FALSE),
+		G_TYPE_INVALID,
+		G_TYPE_BOOLEAN, &updatedLabels,
+		G_TYPE_INVALID) == FALSE)
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusIndex::setDocumentsLabels: " << pError->message << endl;
+			g_error_free(pError);
+		}
+		updatedLabels = FALSE;
+	}
+
+	// Free the arrays
+	g_strfreev(pDocIds);
+	g_strfreev(pLabels);
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	if (updatedLabels == TRUE)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+/// Checks whether the given URL is in the index.
+unsigned int DBusIndex::hasDocument(const string &url) const
+{
+	reopen();
+
+	return m_pROIndex->hasDocument(url);
+}
+
+/// Gets terms with the same root.
+unsigned int DBusIndex::getCloseTerms(const string &term, set<string> &suggestions)
+{
+	reopen();
+
+	return m_pROIndex->getCloseTerms(term, suggestions);
+}
+
+/// Returns the ID of the last document.
+unsigned int DBusIndex::getLastDocumentID(void) const
+{
+	reopen();
+
+	return m_pROIndex->getLastDocumentID();
+}
+
+/// Returns the number of documents.
+unsigned int DBusIndex::getDocumentsCount(const string &labelName) const
+{
+	reopen();
+
+	return m_pROIndex->getDocumentsCount(labelName);
+}
+
+/// Lists documents.
+unsigned int DBusIndex::listDocuments(set<unsigned int> &docIds,
+	unsigned int maxDocsCount, unsigned int startDoc) const
+{
+	reopen();
+
+	return m_pROIndex->listDocuments(docIds, maxDocsCount, startDoc);
+}
+
+/// Lists documents.
+bool DBusIndex::listDocuments(const string &name, set<unsigned int> &docIds,
+	NameType type, unsigned int maxDocsCount, unsigned int startDoc) const
+{
+	reopen();
+
+	return m_pROIndex->listDocuments(name, docIds, type, maxDocsCount, startDoc);
+}
+
+/// Indexes the given data.
+bool DBusIndex::indexDocument(const Document &doc, const set<string> &labels,
+	unsigned int &docId)
+{
+	cerr << "DBusIndex::indexDocument: not allowed" << endl;
+	return false;
+}
+
+/// Updates the given document; true if success.
+bool DBusIndex::updateDocument(unsigned int docId, const Document &doc)
+{
+	bool updated = false;
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusIndex::updateDocument: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	if (dbus_g_proxy_call(pBusProxy, "UpdateDocument", &pError,
+		G_TYPE_UINT, docId,
+		G_TYPE_INVALID,
+		G_TYPE_UINT, &docId,
+		G_TYPE_INVALID) == TRUE)
+	{
+		updated = true;
+	}
+	else
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusIndex::updateDocument: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	return updated;
+}
+
+/// Updates a document's properties.
+bool DBusIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo)
+{
+	DBusMessageIter iter;
+	bool updated = false;
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	// FIXME: AFAIK we can't use DBusGProxy with message iterators
+	DBusMessage *pMsg = dbus_message_new_method_call("de.berlios.Pinot",
+		"/de/berlios/Pinot", "de.berlios.Pinot", "SetDocumentInfo");
+	if (pMsg == NULL)
+	{
+		cerr << "DBusIndex::updateDocumentInfo: couldn't call method" << endl;
+		return false;
+	}
+
+	dbus_message_iter_init_append(pMsg, &iter);
+	if (DBusIndex::documentInfoToDBus(&iter, docId, docInfo) == false)
+	{
+		dbus_message_unref(pMsg);
+	}
+	else
+	{
+		DBusError err;
+
+		dbus_error_init(&err);
+		DBusMessage *pReply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(pBus),
+			pMsg, 1000 * 10, &err);
+		dbus_message_unref(pMsg);
+
+		if (dbus_error_is_set(&err))
+		{
+			cerr << "DBusIndex::updateDocumentInfo: " << err.message << endl;
+			dbus_error_free(&err);
+			return false;
+		}
+
+		if (pReply != NULL)
+		{
+			dbus_message_get_args(pReply, NULL,
+				DBUS_TYPE_UINT32, &docId,
+				DBUS_TYPE_INVALID);
+			updated = true;
+
+			dbus_message_unref(pReply);
+		}
+	}
+
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	return updated;
+}
+
+/// Unindexes the given document; true if success.
+bool DBusIndex::unindexDocument(unsigned int docId)
+{
+	cerr << "DBusIndex::unindexDocument: not allowed" << endl;
+	return false;
+}
+
+/// Unindexes the given document.
+bool DBusIndex::unindexDocument(const string &location)
+{
+	cerr << "DBusIndex::unindexDocument: not allowed" << endl;
+	return false;
+}
+
+/// Unindexes documents.
+bool DBusIndex::unindexDocuments(const string &name, NameType type)
+{
+	cerr << "DBusIndex::unindexDocuments: not allowed" << endl;
+	return false;
+}
+
+/// Unindexes all documents.
+bool DBusIndex::unindexAllDocuments(void)
+{
+	cerr << "DBusIndex::unindexDocuments: not allowed" << endl;
+	return false;
+}
+
+/// Flushes recent changes to the disk.
+bool DBusIndex::flush(void)
+{
+	// The daemon knows best when to flush
+	return true;
+}
+
+/// Reopens the index.
+bool DBusIndex::reopen(void) const
+{
+	return m_pROIndex->reopen();
+}
+
+/// Resets the index.
+bool DBusIndex::reset(void)
+{
+	// This can't be done here
+	return false;
+}
+

Added: trunk/IndexSearch/DBusIndex.h
===================================================================
--- trunk/IndexSearch/DBusIndex.h	2007-12-01 09:25:54 UTC (rev 1133)
+++ trunk/IndexSearch/DBusIndex.h	2007-12-01 09:36:25 UTC (rev 1134)
@@ -0,0 +1,173 @@
+/*
+ *  Copyright 2007 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DBUS_INDEX_H
+#define _DBUS_INDEX_H
+
+#include <string>
+#include <set>
+#include <map>
+#include "config.h"
+extern "C"
+{
+#if DBUS_VERSION < 1000000
+#define DBUS_API_SUBJECT_TO_CHANGE
+#endif
+#include <dbus/dbus.h>
+#include <dbus/dbus-glib.h>
+#include <dbus/dbus-glib-lowlevel.h>
+}
+
+#include "IndexInterface.h"
+
+/// Allows to write to the daemon index via D-Bus. 
+class DBusIndex : public IndexInterface
+{
+	public:
+		DBusIndex(IndexInterface *pROIndex);
+		DBusIndex(const DBusIndex &other);
+		virtual ~DBusIndex();
+
+		DBusIndex &operator=(const DBusIndex &other);
+
+		/// Extracts docId and docInfo from a dbus message.
+		static bool documentInfoFromDBus(DBusMessageIter *iter, unsigned int &docId,
+			DocumentInfo &docInfo);
+
+		/// Converts docId and docInfo to a dbus message.
+		static bool documentInfoToDBus(DBusMessageIter *iter, unsigned int docId,
+			const DocumentInfo &docInfo);
+
+		/// Asks the D-Bus service to reload its configuration.
+		static bool reload(void);
+
+		/// Returns false if the index couldn't be opened.
+		virtual bool isGood(void) const;
+
+		/// Gets the version number.
+		virtual std::string getVersion(void) const;
+
+		/// Sets the version number.
+		virtual bool setVersion(const std::string &version) const;
+
+		/// Gets the index location.
+		virtual std::string getLocation(void) const;
+
+		/// Returns a document's properties.
+		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const;
+
+		/// Returns a document's terms count.
+		virtual unsigned int getDocumentTermsCount(unsigned int docId) const;
+
+		/// Returns a document's terms.
+		virtual bool getDocumentTerms(unsigned int docId,
+			std::map<unsigned int, std::string> &wordsBuffer) const;
+
+		/// Sets the list of known labels.
+		virtual bool setLabels(const std::set<std::string> &labels);
+
+		/// Gets the list of known labels.
+		virtual bool getLabels(std::set<std::string> &labels) const;
+
+		/// Gets the list of known labels.
+		bool getLabels(std::set<std::string> &labels, bool forceDBus) const;
+
+		/// Adds a label.
+		virtual bool addLabel(const std::string &name);
+
+		/// Renames a label.
+		virtual bool renameLabel(const std::string &name, const std::string &newName);
+
+		/// Deletes all references to a label.
+		virtual bool deleteLabel(const std::string &name);
+
+		/// Determines whether a document has a label.
+		virtual bool hasLabel(unsigned int docId, const std::string &name) const;
+
+		/// Returns a document's labels.
+		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const;
+
+		/// Returns a document's labels.
+		bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels,
+			bool forceDBus) const;
+
+		/// Sets a document's labels.
+		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
+			bool resetLabels = true);
+
+		/// Sets documents' labels.
+		virtual bool setDocumentsLabels(const std::set<unsigned int> &docIds,
+			const std::set<std::string> &labels, bool resetLabels = true);
+
+		/// Checks whether the given URL is in the index.
+		virtual unsigned int hasDocument(const std::string &url) const;
+
+		/// Gets terms with the same root.
+		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions);
+
+		/// Returns the ID of the last document.
+		virtual unsigned int getLastDocumentID(void) const;
+
+		/// Returns the number of documents.
+		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const;
+
+		/// Lists documents.
+		virtual unsigned int listDocuments(std::set<unsigned int> &docIDList,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
+
+		/// Lists documents.
+		virtual bool listDocuments(const std::string &name, std::set<unsigned int> &docIds,
+			NameType type, unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
+
+		/// Indexes the given data.
+		virtual bool indexDocument(const Document &doc, const std::set<std::string> &labels,
+			unsigned int &docId);
+
+		/// Updates the given document.
+		virtual bool updateDocument(unsigned int docId, const Document &doc);
+
+		/// Updates a document's properties.
+		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo);
+
+		/// Unindexes the given document.
+		virtual bool unindexDocument(unsigned int docId);
+
+		/// Unindexes the given document.
+		virtual bool unindexDocument(const std::string &location);
+
+		/// Unindexes documents.
+		virtual bool unindexDocuments(const std::string &name, NameType type);
+
+		/// Unindexes all documents.
+		virtual bool unindexAllDocuments(void);
+
+		/// Flushes recent changes to the disk.
+		virtual bool flush(void);
+
+		/// Reopens the index.
+		virtual bool reopen(void) const;
+
+		/// Resets the index.
+		virtual bool reset(void);
+
+	protected:
+		IndexInterface *m_pROIndex;
+
+};
+
+#endif // _DBUS_INDEX_H

Deleted: trunk/IndexSearch/DBusXapianIndex.cpp
===================================================================
--- trunk/IndexSearch/DBusXapianIndex.cpp	2007-12-01 09:25:54 UTC (rev 1133)
+++ trunk/IndexSearch/DBusXapianIndex.cpp	2007-12-01 09:36:25 UTC (rev 1134)
@@ -1,990 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <iostream>
-
-#include "Languages.h"
-#include "XapianDatabaseFactory.h"
-#include "DBusXapianIndex.h"
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-using std::set;
-using std::map;
-using std::min;
-
-const char *g_fieldNames[] = { "caption", "url", "type", "language", "modtime", "size", NULL };
-
-static DBusGConnection *getBusConnection(void)
-{
-	GError *pError = NULL;
-	DBusGConnection *pBus = NULL;
-
-	pBus = dbus_g_bus_get(DBUS_BUS_SESSION, &pError);
-	if (pBus == NULL)
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex: couldn't connect to session bus: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	return pBus;
-}
-
-static DBusGProxy *getBusProxy(DBusGConnection *pBus)
-{
-	if (pBus == NULL)
-	{
-		return NULL;
-	}
-
-	return dbus_g_proxy_new_for_name(pBus,
-		"de.berlios.Pinot", "/de/berlios/Pinot", "de.berlios.Pinot");
-}
-
-DBusXapianIndex::DBusXapianIndex(const string &indexName) :
-	XapianIndex(indexName)
-{
-}
-
-DBusXapianIndex::DBusXapianIndex(const DBusXapianIndex &other) :
-	XapianIndex(other)
-{
-}
-
-DBusXapianIndex::~DBusXapianIndex()
-{
-}
-
-DBusXapianIndex &DBusXapianIndex::operator=(const DBusXapianIndex &other)
-{
-	if (this != &other)
-	{
-		XapianIndex::operator=(other);
-	}
-
-	return *this;
-}
-
-void DBusXapianIndex::reopen(void) const
-{
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase != NULL)
-	{
-		// Re-open the database to the latest available version
-		pDatabase->reopen();
-#ifdef DEBUG
-		cout << "DBusXapianIndex::reopen: done" << endl;
-#endif
-	}
-}
-
-/// Extracts docId and docInfo from a dbus message.
-bool DBusXapianIndex::documentInfoFromDBus(DBusMessageIter *iter, unsigned int &docId,
-	DocumentInfo &docInfo)
-{
-	DBusMessageIter array_iter;
-	DBusMessageIter struct_iter;
-
-	if (iter == NULL)
-	{
-		return false;
-	}
-
-	int type = dbus_message_iter_get_arg_type(iter);
-	if (type != DBUS_TYPE_UINT32)
-	{
-#ifdef DEBUG
-		cout << "DBusXapianIndex::documentInfoFromDBus: expected unsigned integer, got " << type << endl;
-#endif
-		return false;
-	}
-	dbus_message_iter_get_basic(iter, &docId);
-	dbus_message_iter_next(iter);
-	
-	type = dbus_message_iter_get_arg_type(iter);
-	if (type != DBUS_TYPE_ARRAY)
-	{
-#ifdef DEBUG
-		cout << "DBusXapianIndex::documentInfoFromDBus: expected array, got " << type << endl;
-#endif
-		return false;
-	}
-	dbus_message_iter_recurse(iter, &array_iter);
-
-	do
-	{
-		const gchar *pName = NULL;
-		const gchar *pValue = NULL;
-
-		type = dbus_message_iter_get_arg_type(&array_iter);
-		if (type != DBUS_TYPE_STRUCT)
-		{
-#ifdef DEBUG
-			cout << "DBusXapianIndex::documentInfoFromDBus: expected struct, got " << type << endl;
-#endif
-			return false;
-		}
-
-		dbus_message_iter_recurse(&array_iter, &struct_iter);
-		dbus_message_iter_get_basic(&struct_iter, &pName);
-		if (pName == NULL)
-		{
-#ifdef DEBUG
-			cout << "DBusXapianIndex::documentInfoFromDBus: invalid field name" << endl;
-#endif
-		}
-
-		dbus_message_iter_next(&struct_iter);
-		dbus_message_iter_get_basic(&struct_iter, &pValue);
-		if (pValue == NULL)
-		{
-#ifdef DEBUG
-			cout << "DBusXapianIndex::documentInfoFromDBus: invalid field value" << endl;
-#endif
-			continue;
-		}
-#ifdef DEBUG
-		cout << "DBusXapianIndex::documentInfoFromDBus: field " << pName << "=" << pValue << endl;
-#endif
-
-		// Populate docInfo
-		string fieldName(pName);
-		if (fieldName == g_fieldNames[0])
-		{
-			docInfo.setTitle(pValue);
-		}
-		else if (fieldName == g_fieldNames[1])
-		{
-			docInfo.setLocation(pValue);
-		}
-		else if (fieldName == g_fieldNames[2])
-		{
-			docInfo.setType(pValue);
-		}
-		else if (fieldName == g_fieldNames[3])
-		{
-			docInfo.setLanguage(Languages::toLocale(pValue));
-		}
-		else if (fieldName == g_fieldNames[4])
-		{
-			docInfo.setTimestamp(pValue);
-		}
-		else if (fieldName == g_fieldNames[5])
-		{
-			docInfo.setSize((off_t )atoi(pValue));
-		}
-	}
-	while (dbus_message_iter_next(&array_iter));
-
-	return true;
-}
-
-/// Converts docId and docInfo to a dbus message.
-bool DBusXapianIndex::documentInfoToDBus(DBusMessageIter *iter, unsigned int docId,
-	const DocumentInfo &docInfo)
-{
-        DBusMessageIter array_iter;
-	DBusMessageIter struct_iter;
-
-	if (iter == NULL)
-	{
-		return false;
-	}
-
-	// Append the document ID ?
-	if (docId != 0)
-	{
-		dbus_message_iter_append_basic(iter, DBUS_TYPE_UINT32, &docId);
-	}
-	if (!dbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,
-		DBUS_STRUCT_BEGIN_CHAR_AS_STRING \
-		DBUS_TYPE_STRING_AS_STRING \
-		DBUS_TYPE_STRING_AS_STRING \
-		DBUS_STRUCT_END_CHAR_AS_STRING, &array_iter))
-	{
-#ifdef DEBUG
-		cout << "DBusXapianIndex::documentInfoToDBus: couldn't open array container" << endl;
-#endif
-		return false;
-	}
-
-	for (unsigned int fieldNum = 0; g_fieldNames[fieldNum] != NULL; ++fieldNum)
-	{
-		const char *pValue = NULL;
-		char sizeStr[64];
-
-		if (!dbus_message_iter_open_container(&array_iter,
-			DBUS_TYPE_STRUCT, NULL, &struct_iter))
-		{
-#ifdef DEBUG
-			cout << "DBusXapianIndex::documentInfoToDBus: couldn't open struct container" << endl;
-#endif
-			return false;
-		}
-
-		dbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_STRING, &g_fieldNames[fieldNum]);
-		switch (fieldNum)
-		{
-			case 0:
-				pValue = docInfo.getTitle().c_str();
-				break;
-			case 1:
-				pValue = docInfo.getLocation().c_str();
-				break;
-			case 2:
-				pValue = docInfo.getType().c_str();
-				break;
-			case 3:
-				pValue = Languages::toEnglish(docInfo.getLanguage()).c_str();
-				break;
-			case 4:
-				pValue = docInfo.getTimestamp().c_str();
-				break;
-			case 5:
-			default:
-				snprintf(sizeStr, 64, "%u", docInfo.getSize());
-				pValue = sizeStr;
-				break;
-		}
-		dbus_message_iter_append_basic(&struct_iter, DBUS_TYPE_STRING, &pValue);
-#ifdef DEBUG
-		cout << "DBusXapianIndex::documentInfoToDBus: field " << g_fieldNames[fieldNum] << "=" << pValue << endl;
-#endif
-
-		if (!dbus_message_iter_close_container(&array_iter, &struct_iter))
-		{
-#ifdef DEBUG
-			cout << "DBusXapianIndex::documentInfoToDBus: couldn't close struct container" << endl;
-#endif
-			return false;
-		}
-	}
-
-	if (!dbus_message_iter_close_container(iter, &array_iter))
-	{
-#ifdef DEBUG
-		cout << "DBusXapianIndex::documentInfoToDBus: couldn't close array container" << endl;
-#endif
-		return false;
-	}
-
-	return true;
-}
-
-/// Asks the D-Bus service to reload its configuration.
-bool DBusXapianIndex::reload(void)
-{
-	gboolean reloading = FALSE;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::reload: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	if (dbus_g_proxy_call(pBusProxy, "Reload", &pError,
-		G_TYPE_INVALID,
-		G_TYPE_BOOLEAN, &reloading,
-		G_TYPE_INVALID) == FALSE)
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::reload: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	if (reloading == TRUE)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-
-//
-// Implementation of IndexInterface
-//
-
-/// Sets the version number.
-bool DBusXapianIndex::setVersion(const string &version) const
-{
-	cerr << "DBusXapianIndex::setVersion: not allowed" << endl;
-	return false;
-}
-
-/// Returns a document's properties.
-bool DBusXapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentInfo(docId, docInfo);
-}
-
-/// Returns a document's terms count.
-unsigned int DBusXapianIndex::getDocumentTermsCount(unsigned int docId) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentTermsCount(docId);
-}
-
-/// Returns a document's terms.
-bool DBusXapianIndex::getDocumentTerms(unsigned int docId,
-	map<unsigned int, string> &wordsBuffer) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentTerms(docId, wordsBuffer);
-}
-
-/// Sets the list of known labels.
-bool DBusXapianIndex::setLabels(const set<string> &labels)
-{
-	// Not allowed here
-	return false;
-}
-
-/// Gets the list of known labels.
-bool DBusXapianIndex::getLabels(set<string> &labels) const
-{
-	reopen();
-
-	return XapianIndex::getLabels(labels);
-}
-
-/// Gets the list of known labels.
-bool DBusXapianIndex::getLabels(set<string> &labels, bool forceDBus) const
-{
-	bool gotLabels = false;
-
-	if (forceDBus == false)
-	{
-		// Call overload
-		return getLabels(labels);
-	}
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::getLabels: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	char **pLabels;
-
-	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
-	if (dbus_g_proxy_call(pBusProxy, "GetLabels", &pError,
-		G_TYPE_INVALID,
-		G_TYPE_STRV, &pLabels,
-		G_TYPE_INVALID) == TRUE)
-	{
-		for (char **pLabel = pLabels; (*pLabel) != NULL; ++pLabel)
-		{
-			labels.insert(*pLabel);
-		}
-
-		// Free the array
-		g_strfreev(pLabels);
-
-		gotLabels = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::getLabels: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return gotLabels;
-}
-
-/// Adds a label.
-bool DBusXapianIndex::addLabel(const string &name)
-{
-	bool addedLabel = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::addLabel: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	const char *pLabel = name.c_str();
-
-	if (dbus_g_proxy_call(pBusProxy, "AddLabel", &pError,
-		G_TYPE_STRING, pLabel,
-		G_TYPE_INVALID,
-		G_TYPE_STRING, &pLabel,
-		G_TYPE_INVALID) == TRUE)
-	{
-		addedLabel = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::addLabel: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return addedLabel;
-}
-
-/// Renames a label.
-bool DBusXapianIndex::renameLabel(const string &name, const string &newName)
-{
-	bool renamedLabel = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::renameLabel: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	const char *pOldLabel = name.c_str();
-	const char *pNewLabel = newName.c_str();
-
-	if (dbus_g_proxy_call(pBusProxy, "RenameLabel", &pError,
-		G_TYPE_STRING, pOldLabel,
-		G_TYPE_STRING, pNewLabel,
-		G_TYPE_INVALID,
-		G_TYPE_STRING, &pNewLabel,
-		G_TYPE_INVALID) == TRUE)
-	{
-		renamedLabel = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::renameLabel: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return renamedLabel;
-}
-
-/// Deletes all references to a label.
-bool DBusXapianIndex::deleteLabel(const string &name)
-{
-	bool deletedLabel = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::deleteLabel: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	const char *pLabel = name.c_str();
-
-	if (dbus_g_proxy_call(pBusProxy, "DeleteLabel", &pError,
-		G_TYPE_STRING, pLabel,
-		G_TYPE_INVALID,
-		G_TYPE_STRING, &pLabel,
-		G_TYPE_INVALID) == TRUE)
-	{
-		deletedLabel = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::deleteLabel: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return deletedLabel;
-}
-
-/// Determines whether a document has a label.
-bool DBusXapianIndex::hasLabel(unsigned int docId, const string &name) const
-{
-	reopen();
-
-	return XapianIndex::hasLabel(docId, name);
-}
-
-/// Returns a document's labels.
-bool DBusXapianIndex::getDocumentLabels(unsigned int docId, set<string> &labels) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentLabels(docId, labels);
-}
-
-/// Returns a document's labels.
-bool DBusXapianIndex::getDocumentLabels(unsigned int docId, set<string> &labels, bool forceDBus) const
-{
-	bool gotLabels = false;
-
-	if (forceDBus == false)
-	{
-		// Call overload
-		return getDocumentLabels(docId, labels);
-	}
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::getDocumentLabels: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	char **pLabels;
-
-	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
-	if (dbus_g_proxy_call(pBusProxy, "GetDocumentLabels", &pError,
-		G_TYPE_UINT, docId,
-		G_TYPE_INVALID,
-		G_TYPE_STRV, &pLabels,
-		G_TYPE_INVALID) == TRUE)
-	{
-		for (char **pLabel = pLabels; (*pLabel) != NULL; ++pLabel)
-		{
-			labels.insert(*pLabel);
-		}
-
-		// Free the array
-		g_strfreev(pLabels);
-
-		gotLabels = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::getDocumentLabels: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return gotLabels;
-}
-
-/// Sets a document's labels.
-bool DBusXapianIndex::setDocumentLabels(unsigned int docId, const set<string> &labels,
-	bool resetLabels)
-{
-	bool updatedLabels = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::setDocumentLabels: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	dbus_uint32_t labelsCount = labels.size();
-	char **pLabels;
-	unsigned int labelIndex = 0;
-
-	pLabels = g_new(char *, labelsCount + 1);
-	for (set<string>::const_iterator labelIter = labels.begin();
-		labelIter != labels.end(); ++labelIter)
-	{
-		pLabels[labelIndex] = g_strdup(labelIter->c_str());
-		++labelIndex;
-	}
-	pLabels[labelIndex] = NULL;
-
-	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
-	if (dbus_g_proxy_call(pBusProxy, "SetDocumentLabels", &pError,
-		G_TYPE_UINT, docId,
-		G_TYPE_STRV, pLabels,
-		G_TYPE_BOOLEAN, (resetLabels == true ? TRUE : FALSE),
-		G_TYPE_INVALID,
-		G_TYPE_UINT, &docId,
-		G_TYPE_INVALID) == TRUE)
-	{
-		updatedLabels = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::setDocumentLabels: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	// Free the array
-	g_strfreev(pLabels);
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return updatedLabels;
-}
-
-/// Sets documents' labels.
-bool DBusXapianIndex::setDocumentsLabels(const set<unsigned int> &docIds,
-	const set<string> &labels, bool resetLabels)
-{
-	gboolean updatedLabels = FALSE;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::setDocumentsLabels: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	dbus_uint32_t idsCount = docIds.size();
-	dbus_uint32_t labelsCount = labels.size();
-	char **pDocIds;
-	char **pLabels;
-	unsigned int idIndex = 0, labelIndex = 0;
-
-	pDocIds = g_new(char *, idsCount + 1);
-	pLabels = g_new(char *, labelsCount + 1);
-	for (set<unsigned int>::const_iterator idIter = docIds.begin();
-		idIter != docIds.end(); ++idIter)
-	{
-		pDocIds[idIndex] = g_strdup_printf("%u", *idIter); 
-#ifdef DEBUG
-		cout << "DBusXapianIndex::setDocumentsLabels: document " << pDocIds[idIndex] << endl;
-#endif
-		++idIndex;
-	}
-	pDocIds[idIndex] = NULL;
-	for (set<string>::const_iterator labelIter = labels.begin();
-		labelIter != labels.end(); ++labelIter)
-	{
-		pLabels[labelIndex] = g_strdup(labelIter->c_str());
-#ifdef DEBUG
-		cout << "DBusXapianIndex::setDocumentsLabels: label " << pLabels[labelIndex] << endl;
-#endif
-		++labelIndex;
-	}
-	pLabels[labelIndex] = NULL;
-
-	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
-	if (dbus_g_proxy_call(pBusProxy, "SetDocumentsLabels", &pError,
-		G_TYPE_STRV, pDocIds,
-		G_TYPE_STRV, pLabels,
-		G_TYPE_BOOLEAN, (resetLabels == true ? TRUE : FALSE),
-		G_TYPE_INVALID,
-		G_TYPE_BOOLEAN, &updatedLabels,
-		G_TYPE_INVALID) == FALSE)
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::setDocumentsLabels: " << pError->message << endl;
-			g_error_free(pError);
-		}
-		updatedLabels = FALSE;
-	}
-
-	// Free the arrays
-	g_strfreev(pDocIds);
-	g_strfreev(pLabels);
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	if (updatedLabels == TRUE)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-/// Checks whether the given URL is in the index.
-unsigned int DBusXapianIndex::hasDocument(const string &url) const
-{
-	reopen();
-
-	return XapianIndex::hasDocument(url);
-}
-
-/// Gets terms with the same root.
-unsigned int DBusXapianIndex::getCloseTerms(const string &term, set<string> &suggestions)
-{
-	reopen();
-
-	return XapianIndex::getCloseTerms(term, suggestions);
-}
-
-/// Returns the ID of the last document.
-unsigned int DBusXapianIndex::getLastDocumentID(void) const
-{
-	reopen();
-
-	return XapianIndex::getLastDocumentID();
-}
-
-/// Returns the number of documents.
-unsigned int DBusXapianIndex::getDocumentsCount(const string &labelName) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentsCount(labelName);
-}
-
-/// Lists documents.
-unsigned int DBusXapianIndex::listDocuments(set<unsigned int> &docIds,
-	unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	reopen();
-
-	return XapianIndex::listDocuments(docIds, maxDocsCount, startDoc);
-}
-
-/// Lists documents.
-bool DBusXapianIndex::listDocuments(const string &name, set<unsigned int> &docIds,
-	NameType type, unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	reopen();
-
-	return XapianIndex::listDocuments(name, docIds, type, maxDocsCount, startDoc);
-}
-
-/// Indexes the given data.
-bool DBusXapianIndex::indexDocument(const Document &doc, const set<string> &labels,
-	unsigned int &docId)
-{
-	cerr << "DBusXapianIndex::indexDocument: not allowed" << endl;
-	return false;
-}
-
-/// Updates the given document; true if success.
-bool DBusXapianIndex::updateDocument(unsigned int docId, const Document &doc)
-{
-	bool updated = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr << "DBusXapianIndex::updateDocument: couldn't get bus proxy" << endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	if (dbus_g_proxy_call(pBusProxy, "UpdateDocument", &pError,
-		G_TYPE_UINT, docId,
-		G_TYPE_INVALID,
-		G_TYPE_UINT, &docId,
-		G_TYPE_INVALID) == TRUE)
-	{
-		updated = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr << "DBusXapianIndex::updateDocument: " << pError->message << endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return updated;
-}
-
-/// Updates a document's properties.
-bool DBusXapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo)
-{
-	DBusMessageIter iter;
-	bool updated = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	// FIXME: AFAIK we can't use DBusGProxy with message iterators
-	DBusMessage *pMsg = dbus_message_new_method_call("de.berlios.Pinot",
-		"/de/berlios/Pinot", "de.berlios.Pinot", "SetDocumentInfo");
-	if (pMsg == NULL)
-	{
-		cerr << "DBusXapianIndex::updateDocumentInfo: couldn't call method" << endl;
-		return false;
-	}
-
-	dbus_message_iter_init_append(pMsg, &iter);
-	if (DBusXapianIndex::documentInfoToDBus(&iter, docId, docInfo) == false)
-	{
-		dbus_message_unref(pMsg);
-	}
-	else
-	{
-		DBusError err;
-
-		dbus_error_init(&err);
-		DBusMessage *pReply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(pBus),
-			pMsg, 1000 * 10, &err);
-		dbus_message_unref(pMsg);
-
-		if (dbus_error_is_set(&err))
-		{
-			cerr << "DBusXapianIndex::updateDocumentInfo: " << err.message << endl;
-			dbus_error_free(&err);
-			return false;
-		}
-
-		if (pReply != NULL)
-		{
-			dbus_message_get_args(pReply, NULL,
-				DBUS_TYPE_UINT32, &docId,
-				DBUS_TYPE_INVALID);
-			updated = true;
-
-			dbus_message_unref(pReply);
-		}
-	}
-
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return updated;
-}
-
-/// Unindexes the given document; true if success.
-bool DBusXapianIndex::unindexDocument(unsigned int docId)
-{
-	cerr << "DBusXapianIndex::unindexDocument: not allowed" << endl;
-	return false;
-}
-
-/// Unindexes documents.
-bool DBusXapianIndex::unindexDocuments(const string &name, NameType type)
-{
-	cerr << "DBusXapianIndex::unindexDocuments: not allowed" << endl;
-	return false;
-}
-
-/// Unindexes all documents.
-bool DBusXapianIndex::unindexAllDocuments(void)
-{
-	cerr << "DBusXapianIndex::unindexDocuments: not allowed" << endl;
-	return false;
-}
-
-/// Flushes recent changes to the disk.
-bool DBusXapianIndex::flush(void)
-{
-	// The daemon knows best when to flush
-	return true;
-}
-
-/// Resets the index.
-bool DBusXapianIndex::reset(void)
-{
-	// This can't be done here
-	return false;
-}
-

Deleted: trunk/IndexSearch/DBusXapianIndex.h
===================================================================
--- trunk/IndexSearch/DBusXapianIndex.h	2007-12-01 09:25:54 UTC (rev 1133)
+++ trunk/IndexSearch/DBusXapianIndex.h	2007-12-01 09:36:25 UTC (rev 1134)
@@ -1,158 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _DBUS_XAPIAN_INDEX_H
-#define _DBUS_XAPIAN_INDEX_H
-
-#include <string>
-#include <set>
-#include <map>
-#include "config.h"
-extern "C"
-{
-#if DBUS_VERSION < 1000000
-#define DBUS_API_SUBJECT_TO_CHANGE
-#endif
-#include <dbus/dbus.h>
-#include <dbus/dbus-glib.h>
-#include <dbus/dbus-glib-lowlevel.h>
-}
-
-#include "XapianIndex.h"
-
-/// Allows to write to the daemon index via D-Bus. 
-class DBusXapianIndex : public XapianIndex
-{
-	public:
-		DBusXapianIndex(const std::string &indexName);
-		DBusXapianIndex(const DBusXapianIndex &other);
-		virtual ~DBusXapianIndex();
-
-		DBusXapianIndex &operator=(const DBusXapianIndex &other);
-
-		/// Extracts docId and docInfo from a dbus message.
-		static bool documentInfoFromDBus(DBusMessageIter *iter, unsigned int &docId,
-			DocumentInfo &docInfo);
-
-		/// Converts docId and docInfo to a dbus message.
-		static bool documentInfoToDBus(DBusMessageIter *iter, unsigned int docId,
-			const DocumentInfo &docInfo);
-
-		/// Asks the D-Bus service to reload its configuration.
-		static bool reload(void);
-
-		/// Sets the version number.
-		virtual bool setVersion(const std::string &version) const;
-
-		/// Returns a document's properties.
-		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const;
-
-		/// Returns a document's terms count.
-		virtual unsigned int getDocumentTermsCount(unsigned int docId) const;
-
-		/// Returns a document's terms.
-		virtual bool getDocumentTerms(unsigned int docId,
-			std::map<unsigned int, std::string> &wordsBuffer) const;
-
-		/// Sets the list of known labels.
-		virtual bool setLabels(const std::set<std::string> &labels);
-
-		/// Gets the list of known labels.
-		virtual bool getLabels(std::set<std::string> &labels) const;
-
-		/// Gets the list of known labels.
-		bool getLabels(std::set<std::string> &labels, bool forceDBus) const;
-
-		/// Adds a label.
-		virtual bool addLabel(const std::string &name);
-
-		/// Renames a label.
-		virtual bool renameLabel(const std::string &name, const std::string &newName);
-
-		/// Deletes all references to a label.
-		virtual bool deleteLabel(const std::string &name);
-
-		/// Determines whether a document has a label.
-		virtual bool hasLabel(unsigned int docId, const std::string &name) const;
-
-		/// Returns a document's labels.
-		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const;
-
-		/// Returns a document's labels.
-		bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels,
-			bool forceDBus) const;
-
-		/// Sets a document's labels.
-		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
-			bool resetLabels = true);
-
-		/// Sets documents' labels.
-		virtual bool setDocumentsLabels(const std::set<unsigned int> &docIds,
-			const std::set<std::string> &labels, bool resetLabels = true);
-
-		/// Checks whether the given URL is in the index.
-		virtual unsigned int hasDocument(const std::string &url) const;
-
-		/// Gets terms with the same root.
-		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions);
-
-		/// Returns the ID of the last document.
-		virtual unsigned int getLastDocumentID(void) const;
-
-		/// Returns the number of documents.
-		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const;
-
-		/// Lists documents.
-		virtual unsigned int listDocuments(std::set<unsigned int> &docIDList,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		/// Lists documents.
-		virtual bool listDocuments(const std::string &name, std::set<unsigned int> &docIds,
-			NameType type, unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		/// Indexes the given data.
-		virtual bool indexDocument(const Document &doc, const std::set<std::string> &labels,
-			unsigned int &docId);
-
-		/// Updates the given document.
-		virtual bool updateDocument(unsigned int docId, const Document &doc);
-
-		/// Updates a document's properties.
-		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo);
-
-		/// Unindexes the given document.
-		virtual bool unindexDocument(unsigned int docId);
-
-		/// Unindexes documents.
-		virtual bool unindexDocuments(const std::string &name, NameType type);
-
-		/// Unindexes all documents.
-		virtual bool unindexAllDocuments(void);
-
-		/// Flushes recent changes to the disk.
-		virtual bool flush(void);
-
-		/// Resets the index.
-		virtual bool reset(void);
-
-	protected:
-		void reopen(void) const;
-
-};
-
-#endif // _DBUS_XAPIAN_INDEX_H

Modified: trunk/IndexSearch/IndexFactory.cpp
===================================================================
--- trunk/IndexSearch/IndexFactory.cpp	2007-12-01 09:25:54 UTC (rev 1133)
+++ trunk/IndexSearch/IndexFactory.cpp	2007-12-01 09:36:25 UTC (rev 1134)
@@ -17,7 +17,7 @@
  */
 
 #include "XapianIndex.h"
-#include "DBusXapianIndex.h"
+#include "DBusIndex.h"
 #include "IndexFactory.h"
 
 using std::string;
@@ -36,11 +36,12 @@
 	IndexInterface *pIndex = NULL;
 
 	// Choice by type
-	if (type == "dbus")
+	if (type == "dbus-xapiam")
 	{
-		pIndex = new DBusXapianIndex(option);
+		pIndex = new DBusIndex(new XapianIndex(option));
 	}
-	else if (type == "xapian")
+	else if ((type == "xapian") ||
+		(type.empty() == true))
 	{
 		pIndex = new XapianIndex(option);
 	}

Modified: trunk/IndexSearch/IndexInterface.h
===================================================================
--- trunk/IndexSearch/IndexInterface.h	2007-12-01 09:25:54 UTC (rev 1133)
+++ trunk/IndexSearch/IndexInterface.h	2007-12-01 09:36:25 UTC (rev 1134)
@@ -130,6 +130,9 @@
 		/// Flushes recent changes to the disk.
 		virtual bool flush(void) = 0;
 
+		/// Reopens the index.
+		virtual bool reopen(void) const = 0;
+
 		/// Resets the index.
 		virtual bool reset(void) = 0;
 

Modified: trunk/IndexSearch/Xapian/XapianEngine.cpp
===================================================================
--- trunk/IndexSearch/Xapian/XapianEngine.cpp	2007-12-01 09:25:54 UTC (rev 1133)
+++ trunk/IndexSearch/Xapian/XapianEngine.cpp	2007-12-01 09:36:25 UTC (rev 1134)
@@ -25,6 +25,7 @@
 #include <iostream>
 #include <algorithm>
 
+#include "config.h"
 #include "Languages.h"
 #include "StringManip.h"
 #include "TimeConverter.h"

Modified: trunk/IndexSearch/Xapian/XapianIndex.cpp
===================================================================
--- trunk/IndexSearch/Xapian/XapianIndex.cpp	2007-12-01 09:25:54 UTC (rev 1133)
+++ trunk/IndexSearch/Xapian/XapianIndex.cpp	2007-12-01 09:36:25 UTC (rev 1134)
@@ -1941,6 +1941,20 @@
 	return flushed;
 }
 
+/// Reopens the index.
+bool XapianIndex::reopen(void) const
+{
+	// Reopen
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	return true;
+}
+
 /// Resets the index.
 bool XapianIndex::reset(void)
 {

Modified: trunk/IndexSearch/Xapian/XapianIndex.h
===================================================================
--- trunk/IndexSearch/Xapian/XapianIndex.h	2007-12-01 09:25:54 UTC (rev 1133)
+++ trunk/IndexSearch/Xapian/XapianIndex.h	2007-12-01 09:36:25 UTC (rev 1134)
@@ -142,6 +142,9 @@
 		/// Flushes recent changes to the disk.
 		virtual bool flush(void);
 
+		/// Reopens the index.
+		virtual bool reopen(void) const;
+
 		/// Resets the index.
 		virtual bool reset(void);
 

Modified: trunk/IndexSearch/pinot-label.cpp
===================================================================
--- trunk/IndexSearch/pinot-label.cpp	2007-12-01 09:25:54 UTC (rev 1133)
+++ trunk/IndexSearch/pinot-label.cpp	2007-12-01 09:36:25 UTC (rev 1134)
@@ -36,7 +36,8 @@
 #include "StringManip.h"
 #include "MIMEScanner.h"
 #include "Url.h"
-#include "DBusXapianIndex.h"
+#include "DBusIndex.h"
+#include "IndexFactory.h"
 #include "XapianDatabaseFactory.h"
 
 using namespace std;
@@ -183,8 +184,9 @@
 
 	MIMEScanner::initialize("", "");
 
+	// We need a DBusIndex object
 	string indexLocation(getHomeDirectory() + "/.pinot/daemon");
-	DBusXapianIndex index(indexLocation);
+	DBusIndex index(IndexFactory::getIndex("xapian", indexLocation));
 	if (index.isGood() == false)
 	{
 		cerr << "Couldn't obtain index for " << indexLocation << endl;



From fabricecolin at mail.berlios.de  Sat Dec  1 11:05:14 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 1 Dec 2007 11:05:14 +0100
Subject: [Pinot-svn] r1137 - trunk
Message-ID: <200712011005.lB1A5EJ4028540@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-01 11:05:14 +0100 (Sat, 01 Dec 2007)
New Revision: 1137

Removed:
   trunk/Index/
   trunk/Search/
Log:
Obsolete.




From fabricecolin at mail.berlios.de  Sat Dec  1 15:52:21 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 1 Dec 2007 15:52:21 +0100
Subject: [Pinot-svn] r1138 - trunk
Message-ID: <200712011452.lB1EqLKL032742@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-01 15:52:21 +0100 (Sat, 01 Dec 2007)
New Revision: 1138

Modified:
   trunk/pinot.spec.in
Log:
Now requires gtkmm24 >= 2.10.


Modified: trunk/pinot.spec.in
===================================================================
--- trunk/pinot.spec.in	2007-12-01 10:05:14 UTC (rev 1137)
+++ trunk/pinot.spec.in	2007-12-01 14:52:21 UTC (rev 1138)
@@ -25,11 +25,11 @@
 URL: http://pinot.berlios.de/
 BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)
 Requires: xapian-core-libs >= 1.0.3, libtextcat >= 2.2, sqlite >= 3.3.1, curl >= 7.13, gmime >= 2.1
-Requires: gtkmm24 >= 2.6, libxml++ >= 2.12, %{dbus_pkg} >= 0.60, shared-mime-info
+Requires: gtkmm24 >= 2.10, libxml++ >= 2.12, %{dbus_pkg} >= 0.60, shared-mime-info
 Requires: taglib >= 1.4, unzip, antiword, unrtf, %{pftotext_pkg}
 #Suggests: xapian-omega
 BuildRequires: xapian-core-devel >= 1.0.3, libtextcat-devel >= 2.2, sqlite-devel >= 3.3.1, curl-devel >= 7.13, gmime-devel >= 2.1, boost-devel >= 1.32
-BuildRequires: gtkmm24-devel >= 2.6, libxml++-devel >= 2.12, %{dbus_dev_pkg} >= 0.60, gettext-devel, desktop-file-utils
+BuildRequires: gtkmm24-devel >= 2.10, libxml++-devel >= 2.12, %{dbus_dev_pkg} >= 0.60, gettext-devel, desktop-file-utils
 BuildRequires: taglib-devel >= 1.4
 BuildRequires: gcc-c++
 %if 0%{?_with_soap:1}



From fabricecolin at mail.berlios.de  Mon Dec  3 16:48:27 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Mon, 3 Dec 2007 16:48:27 +0100
Subject: [Pinot-svn] r1139 - in trunk: IndexSearch/Xapian UI/GTK2/src
Message-ID: <200712031548.lB3FmRMb023418@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-03 16:48:26 +0100 (Mon, 03 Dec 2007)
New Revision: 1139

Modified:
   trunk/IndexSearch/Xapian/XapianEngine.h
   trunk/UI/GTK2/src/OnDiskHandler.cpp
   trunk/UI/GTK2/src/OnDiskHandler.h
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/propertiesDialog.cc
Log:
Removed superfluous includes, replaced instances of XapianIndex with an object
obtained from PinotSettings::getIndex().


Modified: trunk/IndexSearch/Xapian/XapianEngine.h
===================================================================
--- trunk/IndexSearch/Xapian/XapianEngine.h	2007-12-01 14:52:21 UTC (rev 1138)
+++ trunk/IndexSearch/Xapian/XapianEngine.h	2007-12-03 15:48:26 UTC (rev 1139)
@@ -27,7 +27,6 @@
 
 #include "config.h"
 #include "SearchEngineInterface.h"
-#include "DownloaderFactory.h"
 
 #if !ENABLE_XAPIAN_SPELLING_CORRECTION
 // Spelling correction in Xapian 1.0.2 may cause a crash

Modified: trunk/UI/GTK2/src/OnDiskHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.cpp	2007-12-01 14:52:21 UTC (rev 1138)
+++ trunk/UI/GTK2/src/OnDiskHandler.cpp	2007-12-03 15:48:26 UTC (rev 1139)
@@ -37,7 +37,7 @@
 OnDiskHandler::OnDiskHandler() :
 	MonitorHandler(),
 	m_history(PinotSettings::getInstance().getHistoryDatabaseName()),
-	m_index(PinotSettings::getInstance().m_daemonIndexLocation)
+	m_pIndex(PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation))
 {
 	pthread_mutex_init(&m_mutex, NULL);
 }
@@ -57,6 +57,11 @@
 			slotIter->disconnect();
 		}
 	}
+
+	if (m_pIndex != NULL)
+	{
+		delete m_pIndex;
+	}
 }
 
 bool OnDiskHandler::fileMoved(const string &fileName, const string &previousFileName,
@@ -68,18 +73,23 @@
 #ifdef DEBUG
 	cout << "OnDiskHandler::fileMoved: " << fileName << endl;
 #endif
+	if (m_pIndex == NULL)
+	{
+		return false;
+	}
+
 	pthread_mutex_lock(&m_mutex);
 	// Get a list of documents in that directory/file
 	if (type == IndexInterface::BY_FILE)
 	{
-		m_index.listDocuments(string("file://") + previousFileName, docIdList, type);
+		m_pIndex->listDocuments(string("file://") + previousFileName, docIdList, type);
 	}
 	else
 	{
-		m_index.listDocuments(previousFileName, docIdList, type);
+		m_pIndex->listDocuments(previousFileName, docIdList, type);
 	}
 	// ...and the directory/file itself
-	unsigned int baseDocId = m_index.hasDocument(string("file://") + previousFileName);
+	unsigned int baseDocId = m_pIndex->hasDocument(string("file://") + previousFileName);
 	if (baseDocId > 0)
 	{
 		docIdList.insert(baseDocId);
@@ -94,7 +104,7 @@
 #ifdef DEBUG
 			cout << "OnDiskHandler::fileMoved: moving " << *iter << endl;
 #endif
-			if (m_index.getDocumentInfo(*iter, docInfo) == true)
+			if (m_pIndex->getDocumentInfo(*iter, docInfo) == true)
 			{
 				string newLocation(docInfo.getLocation());
 
@@ -145,20 +155,25 @@
 #ifdef DEBUG
 	cout << "OnDiskHandler::fileDeleted: " << fileName << endl;
 #endif
+	if (m_pIndex == NULL)
+	{
+		return false;
+	}
+
 	pthread_mutex_lock(&m_mutex);
 	// Unindex all of the directory/file's documents
 	if (type == IndexInterface::BY_FILE)
 	{
-		unindexedDocs = m_index.unindexDocuments(location, type);
+		unindexedDocs = m_pIndex->unindexDocuments(location, type);
 	}
 	else
 	{
-		unindexedDocs = m_index.unindexDocuments(fileName, type);
+		unindexedDocs = m_pIndex->unindexDocuments(fileName, type);
 	}
 	if (unindexedDocs == true)
 	{
 		// ...as well as the actual directory/file
-		m_index.unindexDocument(location);
+		m_pIndex->unindexDocument(location);
 
 		m_history.deleteItems(location);
 		handledEvent = true;
@@ -215,13 +230,17 @@
 
 bool OnDiskHandler::replaceFile(unsigned int docId, DocumentInfo &docInfo)
 {
-	FilterWrapper wrapFilter(&m_index);
+	if (m_pIndex == NULL)
+	{
+		return false;
+	}
 
 	// Unindex the destination file
+	FilterWrapper wrapFilter(m_pIndex);
 	wrapFilter.unindexDocument(docInfo.getLocation());
 
 	// Update the document info
-	return m_index.updateDocumentInfo(docId, docInfo);
+	return m_pIndex->updateDocumentInfo(docId, docInfo);
 }
 
 void OnDiskHandler::initialize(void)
@@ -262,7 +281,8 @@
 					<< ", source " << sourceId << " was removed" << endl;
 #endif
 				// All documents with this label will be unindexed
-				if (m_index.unindexDocuments(labelStr, IndexInterface::BY_LABEL) == true)
+				if ((m_pIndex != NULL) &&
+					(m_pIndex->unindexDocuments(labelStr, IndexInterface::BY_LABEL) == true))
 				{
 					// Delete the source itself and all its items
 					m_history.deleteSource(sourceId);
@@ -280,7 +300,10 @@
 void OnDiskHandler::flushIndex(void)
 {
 	pthread_mutex_lock(&m_mutex);
-	m_index.flush();
+	if (m_pIndex != NULL)
+	{
+		m_pIndex->flush();
+	}
 	pthread_mutex_unlock(&m_mutex);
 }
 

Modified: trunk/UI/GTK2/src/OnDiskHandler.h
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.h	2007-12-01 14:52:21 UTC (rev 1138)
+++ trunk/UI/GTK2/src/OnDiskHandler.h	2007-12-03 15:48:26 UTC (rev 1139)
@@ -26,8 +26,8 @@
 #include <sigc++/sigc++.h>
 
 #include "CrawlHistory.h"
+#include "IndexInterface.h"
 #include "MonitorHandler.h"
-#include "XapianIndex.h"
 #include "PinotSettings.h"
 
 class OnDiskHandler : public MonitorHandler
@@ -75,7 +75,7 @@
 		sigc::signal3<void, const DocumentInfo&, const std::string&, bool> m_signalFileFound;
 		std::map<unsigned int, std::string> m_fileSources;
 		CrawlHistory m_history;
-		XapianIndex m_index;
+		IndexInterface *m_pIndex;
 
 		bool fileMoved(const std::string &fileName,
 			const std::string &previousFileName,

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2007-12-01 14:52:21 UTC (rev 1138)
+++ trunk/UI/GTK2/src/mainWindow.cc	2007-12-03 15:48:26 UTC (rev 1139)
@@ -36,6 +36,8 @@
 #include <gtkmm/recentmanager.h>
 #include <gtkmm/main.h>
 
+#include "config.h"
+#include "NLS.h"
 #include "CommandLine.h"
 #include "StringManip.h"
 #include "TimeConverter.h"
@@ -44,10 +46,6 @@
 #include "MonitorFactory.h"
 #include "QueryHistory.h"
 #include "ViewHistory.h"
-#include "DownloaderFactory.h"
-#include "SearchEngineFactory.h"
-#include "config.h"
-#include "NLS.h"
 #include "PinotUtils.h"
 #include "mainWindow.hh"
 #include "importDialog.hh"

Modified: trunk/UI/GTK2/src/propertiesDialog.cc
===================================================================
--- trunk/UI/GTK2/src/propertiesDialog.cc	2007-12-01 14:52:21 UTC (rev 1138)
+++ trunk/UI/GTK2/src/propertiesDialog.cc	2007-12-03 15:48:26 UTC (rev 1139)
@@ -25,7 +25,6 @@
 #include "Languages.h"
 #include "StringManip.h"
 #include "NLS.h"
-#include "XapianIndex.h"
 #include "PinotSettings.h"
 #include "PinotUtils.h"
 #include "propertiesDialog.hh"



From fabricecolin at mail.berlios.de  Tue Dec 11 16:34:47 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Tue, 11 Dec 2007 16:34:47 +0100
Subject: [Pinot-svn] r1140 - trunk/UI/GTK2/src
Message-ID: <200712111534.lBBFYlWU014617@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-11 16:34:47 +0100 (Tue, 11 Dec 2007)
New Revision: 1140

Modified:
   trunk/UI/GTK2/src/queryDialog.cc
Log:
Removed unused include.


Modified: trunk/UI/GTK2/src/queryDialog.cc
===================================================================
--- trunk/UI/GTK2/src/queryDialog.cc	2007-12-03 15:48:26 UTC (rev 1139)
+++ trunk/UI/GTK2/src/queryDialog.cc	2007-12-11 15:34:47 UTC (rev 1140)
@@ -22,7 +22,6 @@
 #include <gtkmm/menu.h>
 
 #include "config.h"
-#include "Languages.h"
 #include "NLS.h"
 #include "TimeConverter.h"
 #include "PinotUtils.h"



From fabricecolin at mail.berlios.de  Wed Dec 19 13:15:55 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 19 Dec 2007 13:15:55 +0100
Subject: [Pinot-svn] r1141 - trunk/Monitor
Message-ID: <200712191215.lBJCFt97020580@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-19 13:15:54 +0100 (Wed, 19 Dec 2007)
New Revision: 1141

Modified:
   trunk/Monitor/INotifyMonitor.cpp
   trunk/Monitor/INotifyMonitor.h
Log:
Remember whether inotify_add_watch() failed with ENOSPC.


Modified: trunk/Monitor/INotifyMonitor.cpp
===================================================================
--- trunk/Monitor/INotifyMonitor.cpp	2007-12-11 15:34:47 UTC (rev 1140)
+++ trunk/Monitor/INotifyMonitor.cpp	2007-12-19 12:15:54 UTC (rev 1141)
@@ -44,7 +44,8 @@
 using std::endl;
 
 INotifyMonitor::INotifyMonitor() :
-	MonitorInterface()
+	MonitorInterface(),
+	m_noWatchesLeft(false)
 {
 	pthread_mutex_init(&m_mutex, NULL);
 	m_monitorFd = inotify_init();
@@ -72,6 +73,8 @@
 	if (locationIter != m_locations.end())
 	{
 		inotify_rm_watch(m_monitorFd, locationIter->second);
+		m_noWatchesLeft = false;
+
 		map<int, string>::iterator watchIter = m_watches.find(locationIter->second);
 		if (watchIter != m_watches.end())
 		{
@@ -97,7 +100,8 @@
 
 	if ((location.empty() == true) ||
 		(location == "/") ||
-		(m_monitorFd < 0))
+		(m_monitorFd < 0) ||
+		(m_noWatchesLeft == true))
 	{
 		return false;
 	}
@@ -140,6 +144,10 @@
 		}
 		else
 		{
+			if (errno == ENOSPC)
+			{
+				m_noWatchesLeft = true;
+			}
 			cerr << "Couldn't monitor " << location << endl;
 		}
 	}

Modified: trunk/Monitor/INotifyMonitor.h
===================================================================
--- trunk/Monitor/INotifyMonitor.h	2007-12-11 15:34:47 UTC (rev 1140)
+++ trunk/Monitor/INotifyMonitor.h	2007-12-19 12:15:54 UTC (rev 1141)
@@ -47,6 +47,7 @@
 		std::queue<MonitorEvent> m_internalEvents;
 		std::map<std::string, int> m_locations;
 		std::map<uint32_t, MonitorEvent> m_movedFrom;
+		bool m_noWatchesLeft;
 
 		bool removeWatch(const std::string &location);
 



From fabricecolin at mail.berlios.de  Wed Dec 19 13:19:02 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 19 Dec 2007 13:19:02 +0100
Subject: [Pinot-svn] r1142 - trunk/IndexSearch
Message-ID: <200712191219.lBJCJ2nG032257@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-19 13:19:00 +0100 (Wed, 19 Dec 2007)
New Revision: 1142

Modified:
   trunk/IndexSearch/DBusIndex.cpp
   trunk/IndexSearch/DBusIndex.h
Log:
DBus-enabled overloads are used automatically if there's no nested Index.


Modified: trunk/IndexSearch/DBusIndex.cpp
===================================================================
--- trunk/IndexSearch/DBusIndex.cpp	2007-12-19 12:15:54 UTC (rev 1141)
+++ trunk/IndexSearch/DBusIndex.cpp	2007-12-19 12:19:00 UTC (rev 1142)
@@ -74,8 +74,11 @@
 
 DBusIndex::~DBusIndex()
 {
-	// Noone else is going to delete this
-	delete m_pROIndex;
+	if (m_pROIndex != NULL)
+	{
+		// Noone else is going to delete this
+		delete m_pROIndex;
+	}
 }
 
 DBusIndex &DBusIndex::operator=(const DBusIndex &other)
@@ -332,12 +335,22 @@
 /// Returns false if the index couldn't be opened.
 bool DBusIndex::isGood(void) const
 {
+	if (m_pROIndex == NULL)
+	{
+		return false;
+	}
+
 	return m_pROIndex->isGood();
 }
 
 /// Gets the version number.
 string DBusIndex::getVersion(void) const
 {
+	if (m_pROIndex == NULL)
+	{
+		return "";
+	}
+
 	return m_pROIndex->getVersion();
 }
 
@@ -351,12 +364,22 @@
 /// Gets the index location.
 string DBusIndex::getLocation(void) const
 {
+	if (m_pROIndex == NULL)
+	{
+		return "";
+	}
+
 	return m_pROIndex->getLocation();
 }
 
 /// Returns a document's properties.
 bool DBusIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
 {
+	if (m_pROIndex == NULL)
+	{
+		return false;
+	}
+
 	reopen();
 
 	return m_pROIndex->getDocumentInfo(docId, docInfo);
@@ -365,6 +388,11 @@
 /// Returns a document's terms count.
 unsigned int DBusIndex::getDocumentTermsCount(unsigned int docId) const
 {
+	if (m_pROIndex == NULL)
+	{
+		return false;
+	}
+
 	reopen();
 
 	return m_pROIndex->getDocumentTermsCount(docId);
@@ -374,6 +402,11 @@
 bool DBusIndex::getDocumentTerms(unsigned int docId,
 	map<unsigned int, string> &wordsBuffer) const
 {
+	if (m_pROIndex == NULL)
+	{
+		return false;
+	}
+
 	reopen();
 
 	return m_pROIndex->getDocumentTerms(docId, wordsBuffer);
@@ -389,20 +422,13 @@
 /// Gets the list of known labels.
 bool DBusIndex::getLabels(set<string> &labels) const
 {
-	reopen();
-
-	return m_pROIndex->getLabels(labels);
-}
-
-/// Gets the list of known labels.
-bool DBusIndex::getLabels(set<string> &labels, bool forceDBus) const
-{
 	bool gotLabels = false;
 
-	if (forceDBus == false)
+	if (m_pROIndex != NULL)
 	{
-		// Call overload
-		return getLabels(labels);
+		reopen();
+
+		return m_pROIndex->getLabels(labels);
 	}
 
 	DBusGConnection *pBus = getBusConnection();
@@ -589,6 +615,11 @@
 /// Determines whether a document has a label.
 bool DBusIndex::hasLabel(unsigned int docId, const string &name) const
 {
+	if (m_pROIndex == NULL)
+	{
+		return false;
+	}
+
 	reopen();
 
 	return m_pROIndex->hasLabel(docId, name);
@@ -597,20 +628,13 @@
 /// Returns a document's labels.
 bool DBusIndex::getDocumentLabels(unsigned int docId, set<string> &labels) const
 {
-	reopen();
-
-	return m_pROIndex->getDocumentLabels(docId, labels);
-}
-
-/// Returns a document's labels.
-bool DBusIndex::getDocumentLabels(unsigned int docId, set<string> &labels, bool forceDBus) const
-{
 	bool gotLabels = false;
 
-	if (forceDBus == false)
+	if (m_pROIndex != NULL)
 	{
-		// Call overload
-		return getDocumentLabels(docId, labels);
+		reopen();
+
+		return m_pROIndex->getDocumentLabels(docId, labels);
 	}
 
 	DBusGConnection *pBus = getBusConnection();
@@ -807,6 +831,11 @@
 /// Checks whether the given URL is in the index.
 unsigned int DBusIndex::hasDocument(const string &url) const
 {
+	if (m_pROIndex == NULL)
+	{
+		return false;
+	}
+
 	reopen();
 
 	return m_pROIndex->hasDocument(url);
@@ -815,6 +844,11 @@
 /// Gets terms with the same root.
 unsigned int DBusIndex::getCloseTerms(const string &term, set<string> &suggestions)
 {
+	if (m_pROIndex == NULL)
+	{
+		return false;
+	}
+
 	reopen();
 
 	return m_pROIndex->getCloseTerms(term, suggestions);
@@ -823,6 +857,11 @@
 /// Returns the ID of the last document.
 unsigned int DBusIndex::getLastDocumentID(void) const
 {
+	if (m_pROIndex == NULL)
+	{
+		return false;
+	}
+
 	reopen();
 
 	return m_pROIndex->getLastDocumentID();
@@ -831,6 +870,11 @@
 /// Returns the number of documents.
 unsigned int DBusIndex::getDocumentsCount(const string &labelName) const
 {
+	if (m_pROIndex == NULL)
+	{
+		return false;
+	}
+
 	reopen();
 
 	return m_pROIndex->getDocumentsCount(labelName);
@@ -840,6 +884,11 @@
 unsigned int DBusIndex::listDocuments(set<unsigned int> &docIds,
 	unsigned int maxDocsCount, unsigned int startDoc) const
 {
+	if (m_pROIndex == NULL)
+	{
+		return false;
+	}
+
 	reopen();
 
 	return m_pROIndex->listDocuments(docIds, maxDocsCount, startDoc);
@@ -849,6 +898,11 @@
 bool DBusIndex::listDocuments(const string &name, set<unsigned int> &docIds,
 	NameType type, unsigned int maxDocsCount, unsigned int startDoc) const
 {
+	if (m_pROIndex == NULL)
+	{
+		return false;
+	}
+
 	reopen();
 
 	return m_pROIndex->listDocuments(name, docIds, type, maxDocsCount, startDoc);
@@ -1000,6 +1054,11 @@
 /// Reopens the index.
 bool DBusIndex::reopen(void) const
 {
+	if (m_pROIndex == NULL)
+	{
+		return false;
+	}
+
 	return m_pROIndex->reopen();
 }
 

Modified: trunk/IndexSearch/DBusIndex.h
===================================================================
--- trunk/IndexSearch/DBusIndex.h	2007-12-19 12:15:54 UTC (rev 1141)
+++ trunk/IndexSearch/DBusIndex.h	2007-12-19 12:19:00 UTC (rev 1142)
@@ -84,9 +84,6 @@
 		/// Gets the list of known labels.
 		virtual bool getLabels(std::set<std::string> &labels) const;
 
-		/// Gets the list of known labels.
-		bool getLabels(std::set<std::string> &labels, bool forceDBus) const;
-
 		/// Adds a label.
 		virtual bool addLabel(const std::string &name);
 
@@ -102,10 +99,6 @@
 		/// Returns a document's labels.
 		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const;
 
-		/// Returns a document's labels.
-		bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels,
-			bool forceDBus) const;
-
 		/// Sets a document's labels.
 		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
 			bool resetLabels = true);



From fabricecolin at mail.berlios.de  Wed Dec 19 13:21:09 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 19 Dec 2007 13:21:09 +0100
Subject: [Pinot-svn] r1143 - trunk/IndexSearch
Message-ID: <200712191221.lBJCL9Jl008324@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-19 13:21:09 +0100 (Wed, 19 Dec 2007)
New Revision: 1143

Modified:
   trunk/IndexSearch/QueryProperties.cpp
   trunk/IndexSearch/QueryProperties.h
   trunk/IndexSearch/SearchEngineInterface.cpp
   trunk/IndexSearch/SearchEngineInterface.h
   trunk/IndexSearch/WebEngine.h
Log:
Method getDownloader() is now specific to WebEngine.
QueryProperties has a modified flag to record automatic alterations.


Modified: trunk/IndexSearch/QueryProperties.cpp
===================================================================
--- trunk/IndexSearch/QueryProperties.cpp	2007-12-19 12:19:00 UTC (rev 1142)
+++ trunk/IndexSearch/QueryProperties.cpp	2007-12-19 12:21:09 UTC (rev 1143)
@@ -29,7 +29,8 @@
 	m_type(XAPIAN_QP),
 	m_order(RELEVANCE),
 	m_resultsCount(10),
-	m_indexResults(false)
+	m_indexResults(false),
+	m_modified(false)
 {
 }
 
@@ -40,7 +41,8 @@
 	m_order(RELEVANCE),
 	m_freeQuery(freeQuery),
 	m_resultsCount(10),
-	m_indexResults(false)
+	m_indexResults(false),
+	m_modified(false)
 {
 	removeFilters();
 }
@@ -53,7 +55,8 @@
 	m_freeQueryWithoutFilters(other.m_freeQueryWithoutFilters),
 	m_resultsCount(other.m_resultsCount),
 	m_indexResults(other.m_indexResults),
-	m_labelName(other.m_labelName)
+	m_labelName(other.m_labelName),
+	m_modified(other.m_modified)
 {
 }
 
@@ -73,6 +76,7 @@
 		m_resultsCount = other.m_resultsCount;
 		m_indexResults = other.m_indexResults;
 		m_labelName = other.m_labelName;
+		m_modified = other.m_modified;
 	}
 
 	return *this;
@@ -263,6 +267,18 @@
 	return m_labelName;
 }
 
+/// Sets whether the query was modified in some way.
+void QueryProperties::setModified(bool isModified)
+{
+	m_modified = isModified;
+}
+
+/// Gets whether the query was modified in some way.
+bool QueryProperties::getModified(void) const
+{
+	return m_modified;
+}
+
 /// Returns the query's terms.
 void QueryProperties::getTerms(set<string> &terms) const
 {

Modified: trunk/IndexSearch/QueryProperties.h
===================================================================
--- trunk/IndexSearch/QueryProperties.h	2007-12-19 12:19:00 UTC (rev 1142)
+++ trunk/IndexSearch/QueryProperties.h	2007-12-19 12:21:09 UTC (rev 1143)
@@ -79,6 +79,11 @@
 		/// Gets the name of the label to use for indexed documents.
 		string getLabelName(void) const;
 
+		/// Sets whether the query was modified in some way.
+		void setModified(bool isModified);
+		/// Gets whether the query was modified in some way.
+		bool getModified(void) const;
+
 		/// Returns the query's terms.
 		void getTerms(set<string> &terms) const;
 
@@ -94,6 +99,7 @@
 		unsigned int m_resultsCount;
 		bool m_indexResults;
 		string m_labelName;
+		bool m_modified;
 
 		void removeFilters(void);
 

Modified: trunk/IndexSearch/SearchEngineInterface.cpp
===================================================================
--- trunk/IndexSearch/SearchEngineInterface.cpp	2007-12-19 12:19:00 UTC (rev 1142)
+++ trunk/IndexSearch/SearchEngineInterface.cpp	2007-12-19 12:21:09 UTC (rev 1143)
@@ -56,12 +56,6 @@
 	return false;
 }
 
-/// Returns the downloader used if any.
-DownloaderInterface *SearchEngineInterface::getDownloader(void)
-{
-	return NULL;
-}
-
 /// Returns the results for the previous query.
 const vector<DocumentInfo> &SearchEngineInterface::getResults(void) const
 {

Modified: trunk/IndexSearch/SearchEngineInterface.h
===================================================================
--- trunk/IndexSearch/SearchEngineInterface.h	2007-12-19 12:19:00 UTC (rev 1142)
+++ trunk/IndexSearch/SearchEngineInterface.h	2007-12-19 12:21:09 UTC (rev 1143)
@@ -24,7 +24,6 @@
 #include <set>
 #include <vector>
 
-#include "DownloaderInterface.h"
 #include "QueryProperties.h"
 #include "DocumentInfo.h"
 
@@ -47,9 +46,6 @@
 		/// Sets the set of documents to expand from.
 		virtual bool setExpandSet(const set<string> &docsSet);
 
-		/// Returns the downloader used if any.
-		virtual DownloaderInterface *getDownloader(void);
-
 		/// Runs a query; true if success.
 		virtual bool runQuery(QueryProperties& queryProps,
 			unsigned int startDoc = 0) = 0;

Modified: trunk/IndexSearch/WebEngine.h
===================================================================
--- trunk/IndexSearch/WebEngine.h	2007-12-19 12:19:00 UTC (rev 1142)
+++ trunk/IndexSearch/WebEngine.h	2007-12-19 12:21:09 UTC (rev 1143)
@@ -23,6 +23,7 @@
 #include <set>
 
 #include "Document.h"
+#include "DownloaderInterface.h"
 #include "QueryProperties.h"
 #include "SearchEngineInterface.h"
 
@@ -34,7 +35,7 @@
 		virtual ~WebEngine();
 
 		/// Returns the downloader used if any.
-		virtual DownloaderInterface *getDownloader(void);
+		DownloaderInterface *getDownloader(void);
 
 	protected:
 		DownloaderInterface *m_pDownloader;



From fabricecolin at mail.berlios.de  Wed Dec 19 13:26:57 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 19 Dec 2007 13:26:57 +0100
Subject: [Pinot-svn] r1144 - trunk/IndexSearch
Message-ID: <200712191226.lBJCQvXx009277@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-19 13:26:57 +0100 (Wed, 19 Dec 2007)
New Revision: 1144

Added:
   trunk/IndexSearch/ModuleFactory.cpp
   trunk/IndexSearch/ModuleFactory.h
Log:
A class to eventuall replace Index and SearchEngine factories that can be
extended through dynamically-loaded modules.


Added: trunk/IndexSearch/ModuleFactory.cpp
===================================================================
--- trunk/IndexSearch/ModuleFactory.cpp	2007-12-19 12:21:09 UTC (rev 1143)
+++ trunk/IndexSearch/ModuleFactory.cpp	2007-12-19 12:26:57 UTC (rev 1144)
@@ -0,0 +1,433 @@
+/*
+ *  Copyright 2007 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <dlfcn.h>
+#include <iostream>
+
+#include "DBusIndex.h"
+#ifdef HAVE_GOOGLEAPI
+#include "GoogleAPIEngine.h"
+#endif
+#include "PluginWebEngine.h"
+#include "ModuleFactory.h"
+#if 0
+#include "XapianDatabaseFactory.h"
+#include "XapianIndex.h"
+#include "XapianEngine.h"
+#endif
+
+#ifdef __CYGWIN__
+#define DLOPEN_FLAGS RTLD_NOW
+#else
+#define DLOPEN_FLAGS (RTLD_NOW|RTLD_LOCAL)
+#endif
+
+#define GETMODULETYPEFUNC	"getModuleType"
+#define OPENORCREATEINDEXFUNC	"openOrCreateIndex"
+#define MERGEINDEXESFUNC	"mergeIndexes"
+#define GETINDEXFUNC		"getIndex"
+#define GETSEARCHENGINEFUNC	"getSearchEngine"
+#define CLOSEALLFUNC		"closeAll"
+
+typedef string (getModuleTypeFunc)(void);
+typedef bool (openOrCreateIndexFunc)(const string &, bool &, bool, bool);
+typedef bool (mergeIndexesFunc)(const string &, const string &, const string &);
+typedef IndexInterface *(getIndexFunc)(const string &);
+typedef SearchEngineInterface *(getSearchEngineFunc)(const string &);
+typedef void (closeAllFunc)(void);
+
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+using std::map;
+using std::set;
+
+map<string, string> ModuleFactory::m_types;
+map<string, void *> ModuleFactory::m_handles;
+
+ModuleFactory::ModuleFactory()
+{
+}
+
+ModuleFactory::~ModuleFactory()
+{
+}
+
+IndexInterface *ModuleFactory::getLibraryIndex(const string &type, const string &option)
+{
+	void *pHandle = NULL;
+
+	map<string, string>::iterator typeIter = m_types.find(type);
+	if (typeIter == m_types.end())
+	{
+		// We don't know about this type
+		return NULL;
+	}
+	map<string, void *>::iterator handleIter = m_handles.find(typeIter->second);
+	if (handleIter == m_handles.end())
+	{
+		// We don't know about this library
+		return NULL;
+	}
+	pHandle = handleIter->second;
+	if (pHandle == NULL)
+	{
+		return NULL;
+	}
+
+	getIndexFunc *pFunc = (getIndexFunc *)dlsym(pHandle,
+		GETINDEXFUNC);
+	if (pFunc != NULL)
+	{
+		return (*pFunc)(option);
+	}
+#ifdef DEBUG
+	cout << "ModuleFactory::getLibraryIndex: couldn't find export getIndex" << endl;
+#endif
+
+	return NULL;
+}
+
+SearchEngineInterface *ModuleFactory::getLibrarySearchEngine(const string &type, const string &option)
+{
+	void *pHandle = NULL;
+
+	map<string, string>::iterator typeIter = m_types.find(type);
+	if (typeIter == m_types.end())
+	{
+		// We don't know about this type
+		return NULL;
+	}
+	map<string, void *>::iterator handleIter = m_handles.find(typeIter->second);
+	if (handleIter == m_handles.end())
+	{
+		// We don't know about this library
+		return NULL;
+	}
+	pHandle = handleIter->second;
+	if (pHandle == NULL)
+	{
+		return NULL;
+	}
+
+	getSearchEngineFunc *pFunc = (getSearchEngineFunc *)dlsym(pHandle,
+		GETSEARCHENGINEFUNC);
+	if (pFunc != NULL)
+	{
+		return (*pFunc)(option);
+	}
+#ifdef DEBUG
+	cout << "ModuleFactory::getLibrarySearchEngine: couldn't find export getSearchEngine" << endl;
+#endif
+
+	return NULL;
+}
+
+unsigned int ModuleFactory::loadModules(const string &directory)
+{
+	struct stat fileStat;
+	unsigned int count = 0;
+
+	if (directory.empty() == true)
+	{
+		return 0;
+	}
+
+	// Is it a directory ?
+	if ((stat(directory.c_str(), &fileStat) == -1) ||
+		(!S_ISDIR(fileStat.st_mode)))
+	{
+		cerr << "ModuleFactory::loadModules: " << directory << " is not a directory" << endl;
+		return 0;
+	}
+
+	// Scan it
+	DIR *pDir = opendir(directory.c_str());
+	if (pDir == NULL)
+	{
+		return 0;
+	}
+
+	// Iterate through this directory's entries
+	struct dirent *pDirEntry = readdir(pDir);
+	while (pDirEntry != NULL)
+	{
+		char *pEntryName = pDirEntry->d_name;
+		if (pEntryName != NULL)
+		{
+			string fileName = pEntryName;
+			string::size_type extPos = fileName.find_last_of(".");
+
+			if ((extPos == string::npos) ||
+				(fileName.substr(extPos) != ".so"))
+			{
+				// Next entry
+				pDirEntry = readdir(pDir);
+				continue;
+			}
+
+			fileName = directory;
+			fileName += "/";
+			fileName += pEntryName;
+
+			// Check this entry
+			if ((stat(fileName.c_str(), &fileStat) == 0) &&
+				(S_ISREG(fileStat.st_mode)))
+			{
+				void *pHandle = dlopen(fileName.c_str(), DLOPEN_FLAGS);
+				if (pHandle != NULL)
+				{
+					// What type does this export ?
+					getModuleTypeFunc *pTypeFunc = (getModuleTypeFunc *)dlsym(pHandle,
+						GETMODULETYPEFUNC);
+					if (pTypeFunc != NULL)
+					{
+						string moduleType((*pTypeFunc)());
+
+						// Add a record for this module
+						m_types[moduleType] = fileName;
+#ifdef DEBUG
+						cout << "ModuleFactory::loadModules: type " << moduleType
+							<< " is supported by " << pEntryName << endl;
+#endif
+						m_handles[fileName] = pHandle;
+					}
+					else cerr << "ModuleFactory::loadModules: " << dlerror() << endl;
+				}
+				else cerr << "ModuleFactory::loadModules: " << dlerror() << endl;
+			}
+#ifdef DEBUG
+			else cout << "ModuleFactory::loadModules: "
+				<< pEntryName << " is not a file" << endl;
+#endif
+		}
+
+		// Next entry
+		pDirEntry = readdir(pDir);
+	}
+	closedir(pDir);
+
+	return count;
+}
+
+bool ModuleFactory::openOrCreateIndex(const string &type, const string &option,
+	bool &obsoleteFormat, bool readOnly, bool overwrite)
+{
+	void *pHandle = NULL;
+
+	map<string, string>::iterator typeIter = m_types.find(type);
+	if (typeIter == m_types.end())
+	{
+		// We don't know about this type
+		return false;
+	}
+	map<string, void *>::iterator handleIter = m_handles.find(typeIter->second);
+	if (handleIter == m_handles.end())
+	{
+		// We don't know about this library
+		return false;
+	}
+	pHandle = handleIter->second;
+	if (pHandle == NULL)
+	{
+		return false;
+	}
+
+	openOrCreateIndexFunc *pFunc = (openOrCreateIndexFunc *)dlsym(pHandle,
+		OPENORCREATEINDEXFUNC);
+	if (pFunc != NULL)
+	{
+		return (*pFunc)(option, obsoleteFormat, readOnly, overwrite);
+	}
+#ifdef DEBUG
+	cout << "ModuleFactory::openOrCreateIndex: couldn't find export openOrCreateIndex" << endl;
+#endif
+
+	return false;
+}
+
+bool ModuleFactory::mergeIndexes(const string &type, const string &option0,
+	const string &option1, const string &option2)
+{
+	void *pHandle = NULL;
+
+	map<string, string>::iterator typeIter = m_types.find(type);
+	if (typeIter == m_types.end())
+	{
+		// We don't know about this type
+		return false;
+	}
+	map<string, void *>::iterator handleIter = m_handles.find(typeIter->second);
+	if (handleIter == m_handles.end())
+	{
+		// We don't know about this library
+		return false;
+	}
+	pHandle = handleIter->second;
+	if (pHandle == NULL)
+	{
+		return false;
+	}
+
+	mergeIndexesFunc *pFunc = (mergeIndexesFunc *)dlsym(pHandle,
+		MERGEINDEXESFUNC);
+	if (pFunc != NULL)
+	{
+		return (*pFunc)(option0, option1, option2);
+	}
+#ifdef DEBUG
+	cout << "ModuleFactory::mergeIndexes: couldn't find export mergeIndexes" << endl;
+#endif
+
+	return false;
+}
+
+IndexInterface *ModuleFactory::getIndex(const string &type, const string &option)
+{
+	IndexInterface *pIndex = NULL;
+
+	// Choice by type
+	// Do we need to nest it in a DBusIndex ?
+	if (type.substr(0, 5) == "dbus-")
+	{
+#ifdef DEBUG
+		cout << "ModuleFactory::mergeIndexes: sub-type " << type.substr(5) << endl;
+#endif
+		pIndex = getLibraryIndex(type.substr(5), option);
+		if (pIndex != NULL)
+		{
+			return new DBusIndex(pIndex);
+		}
+
+		return NULL;
+	}
+
+	return getLibraryIndex(type, option);
+}
+
+SearchEngineInterface *ModuleFactory::getSearchEngine(const string &type, const string &option)
+{
+	SearchEngineInterface *pEngine = NULL;
+
+	// Choice by type
+	if ((type == "sherlock") ||
+		(type == "opensearch"))
+	{
+		pEngine = new PluginWebEngine(option);
+	}
+#ifdef HAVE_GOOGLEAPI
+	else if (type == "googleapi")
+	{
+		pEngine = new GoogleAPIEngine(option);
+	}
+#endif
+
+	if (pEngine != NULL)
+	{
+		return pEngine;
+	}
+
+	return getLibrarySearchEngine(type, option);
+}
+
+string ModuleFactory::getSearchEngineName(const string &type, const string &option)
+{
+	if ((type == "sherlock") ||
+		(type == "opensearch"))
+	{
+		string name, channel;
+
+		if (PluginWebEngine::getDetails(option, name, channel) == true)
+		{
+			return name;
+		}
+
+		return "";
+	}
+	else
+	{
+		return option;
+	}
+
+	return type;
+}
+
+void ModuleFactory::getSupportedEngines(set<string> &engines)
+{
+	engines.clear();
+
+	// Built-in engines
+	engines.insert("sherlock");
+	engines.insert("opensearch");
+#ifdef HAVE_GOOGLEAPI
+	engines.insert("googleapi");
+#endif
+	// Library-handled engines
+	for (map<string, string>::iterator typeIter = m_types.begin();
+		typeIter != m_types.end(); ++typeIter)
+	{
+		engines.insert(typeIter->first);
+	}
+}
+
+bool ModuleFactory::isSupported(const string &type)
+{
+	if (
+#ifdef HAVE_GOOGLEAPI
+		(type == "googleapi") ||
+#endif
+		(type == "sherlock") ||
+		(m_types.find(type) != m_types.end()))
+	{
+		return true;
+	}
+
+	return false;	
+}
+
+void ModuleFactory::unloadModules(void)
+{
+	for (map<string, void*>::iterator iter = m_handles.begin(); iter != m_handles.end(); ++iter)
+	{
+		void *pHandle = iter->second;
+
+		closeAllFunc *pFunc = (closeAllFunc *)dlsym(pHandle, CLOSEALLFUNC);
+		if (pFunc != NULL)
+		{
+			(*pFunc)();
+		}
+#ifdef DEBUG
+		else cout << "ModuleFactory::unloadModules: couldn't find export closeAll" << endl;
+#endif
+
+		if (dlclose(pHandle) != 0)
+		{
+#ifdef DEBUG
+			cout << "ModuleFactory::unloadModules: failed on " << iter->first << endl;
+#endif
+		}
+	}
+
+	m_types.clear();
+	m_handles.clear();
+}
+

Added: trunk/IndexSearch/ModuleFactory.h
===================================================================
--- trunk/IndexSearch/ModuleFactory.h	2007-12-19 12:21:09 UTC (rev 1143)
+++ trunk/IndexSearch/ModuleFactory.h	2007-12-19 12:26:57 UTC (rev 1144)
@@ -0,0 +1,80 @@
+/*
+ *  Copyright 2007 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MODULE_FACTORY_H
+#define _MODULE_FACTORY_H
+
+#include <string>
+#include <map>
+#include <set>
+
+#include "IndexInterface.h"
+#include "SearchEngineInterface.h"
+
+/// Factory for search engines.
+class ModuleFactory
+{
+	public:
+		virtual ~ModuleFactory();
+
+		/// Loads the libraries found in the given directory.
+		static unsigned int loadModules(const std::string &directory);
+
+		/// Makes sure the index exists in the desired mode.
+		static bool openOrCreateIndex(const std::string &type, const std::string &option,
+			bool &obsoleteFormat, bool readOnly = true, bool overwrite = false);
+
+		/// Merges two physical indexes in a logical one.
+		static bool mergeIndexes(const std::string &type, const std::string &option0,
+			const std::string &option1, const std::string &option2);
+
+		/// Returns an index of the specified type; NULL if unavailable.
+		static IndexInterface *getIndex(const std::string &type, const std::string &option);
+
+		/// Returns a SearchEngine of the specified type; NULL if unavailable.
+		static SearchEngineInterface *getSearchEngine(const std::string &type, const std::string &option);
+
+		/// Returns the name of the given engine.
+		static string getSearchEngineName(const std::string &type, const std::string &option);
+
+		/// Returns all supported engines.
+		static void getSupportedEngines(std::set<string> &engines);
+
+		/// Indicates whether a search engine is supported or not.
+		static bool isSupported(const std::string &type);
+
+		/// Unloads all libraries.
+		static void unloadModules(void);
+
+	protected:
+		static std::map<std::string, std::string> m_types;
+		static std::map<std::string, void *> m_handles;
+
+		ModuleFactory();
+
+		static IndexInterface *getLibraryIndex(const std::string &type, const std::string &option);
+
+		static SearchEngineInterface *getLibrarySearchEngine(const std::string &type, const std::string &option);
+
+	private:
+		ModuleFactory(const ModuleFactory &other);
+		ModuleFactory &operator=(const ModuleFactory &other);
+
+};
+
+#endif // _MODULE_FACTORY_H



From fabricecolin at mail.berlios.de  Wed Dec 19 13:31:35 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 19 Dec 2007 13:31:35 +0100
Subject: [Pinot-svn] r1145 - in trunk: . Collect IndexSearch
	IndexSearch/Google IndexSearch/Xapian Tokenize UI/GTK2/src Utils
Message-ID: <200712191231.lBJCVZqH009595@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-19 13:31:34 +0100 (Wed, 19 Dec 2007)
New Revision: 1145

Modified:
   trunk/Collect/Makefile.am
   trunk/IndexSearch/Google/Makefile.am
   trunk/IndexSearch/Makefile.am
   trunk/IndexSearch/Xapian/Makefile.am
   trunk/Makefile.am
   trunk/Tokenize/Makefile.am
   trunk/UI/GTK2/src/Makefile.am
   trunk/Utils/Makefile.am
   trunk/configure.in
Log:
Build IndexSearch/Xapian as a dynamic library, link programs with -rdynamic.
The libUtils library has only got classes with static data, the rest goes into
libBasicUtils.
Only link to necessary libraries, eg only the mbox filter needs to link against
GMime.


Modified: trunk/Collect/Makefile.am
===================================================================
--- trunk/Collect/Makefile.am	2007-12-19 12:26:57 UTC (rev 1144)
+++ trunk/Collect/Makefile.am	2007-12-19 12:31:34 UTC (rev 1145)
@@ -22,5 +22,5 @@
 	-I$(top_srcdir)/Tokenize \
 	-I$(top_srcdir)/Tokenize/filters \
 	@INDEX_CFLAGS@ @XML_CFLAGS@ @HTTP_CFLAGS@ \
-	@GMIME_CFLAGS@ @GLIBMM_CFLAGS@
+	@GLIBMM_CFLAGS@
 

Modified: trunk/IndexSearch/Google/Makefile.am
===================================================================
--- trunk/IndexSearch/Google/Makefile.am	2007-12-19 12:26:57 UTC (rev 1144)
+++ trunk/IndexSearch/Google/Makefile.am	2007-12-19 12:31:34 UTC (rev 1145)
@@ -30,6 +30,6 @@
 	-I$(top_srcdir)/Collect \
 	-I$(top_srcdir)/IndexSearch \
 	@HTTP_CFLAGS@ @XML_CFLAGS@ @SOAP_CFLAGS@ \
-	@INDEX_CFLAGS@ @GMIME_CFLAGS@
+	@INDEX_CFLAGS@
 endif
 

Modified: trunk/IndexSearch/Makefile.am
===================================================================
--- trunk/IndexSearch/Makefile.am	2007-12-19 12:26:57 UTC (rev 1144)
+++ trunk/IndexSearch/Makefile.am	2007-12-19 12:31:34 UTC (rev 1145)
@@ -3,14 +3,13 @@
 noinst_HEADERS = \
 	DBusIndex.h \
 	FilterWrapper.h \
-	IndexFactory.h \
 	IndexInterface.h \
+	ModuleFactory.h \
 	OpenSearchParser.h \
 	PluginParsers.h \
 	PluginWebEngine.h \
 	QueryProperties.h \
 	ResultsExporter.h \
-	SearchEngineFactory.h \
 	SearchEngineInterface.h \
 	SearchPluginProperties.h \
 	SherlockParser.h \
@@ -28,12 +27,11 @@
 libIndexSearch_la_SOURCES = \
 	DBusIndex.cpp \
 	FilterWrapper.cpp \
-	IndexFactory.cpp \
+	ModuleFactory.cpp \
 	OpenSearchParser.cpp \
 	PluginWebEngine.cpp \
 	QueryProperties.cpp \
 	ResultsExporter.cpp \
-	SearchEngineFactory.cpp \
 	SearchEngineInterface.cpp \
 	SearchPluginProperties.cpp \
 	WebEngine.cpp
@@ -48,41 +46,48 @@
 
 bin_PROGRAMS = pinot-index pinot-label pinot-search
 
+pinot_index_LDFLAGS = \
+	-rdynamic
+
 pinot_index_LDADD = \
 	-L$(top_builddir)/Utils \
 	-L$(top_builddir)/Tokenize \
 	-L$(top_builddir)/Collect \
-	-L$(top_builddir)/IndexSearch/Xapian \
-	-lIndexSearch -lIndexSearchXapian -lCollect -lTokenize -lBasicUtils -lUtils \
-	@GLIBMM_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ @XML_LIBS@ \
-	@GMIME_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
+	-lIndexSearch -lCollect -lTokenize -lUtils -lBasicUtils \
+	@GLIBMM_LIBS@ @DBUS_LIBS@ @XML_LIBS@ \
+	@HTTP_LIBS@ @MISC_LIBS@
 
 pinot_index_SOURCES = pinot-index.cpp
 
 pinot_index_DEPENDENCIES = libIndexSearch.la
 
+pinot_label_LDFLAGS = \
+	-rdynamic
+
 pinot_label_LDADD = \
 	-L$(top_builddir)/Utils \
 	-L$(top_builddir)/Tokenize \
-	-L$(top_builddir)/IndexSearch/Xapian \
-	-lIndexSearch -lIndexSearchXapian -lTokenize -lBasicUtils -lUtils \
-	@GLIBMM_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ \
-	@XML_LIBS@ @GMIME_LIBS@ @MISC_LIBS@
+	-L$(top_builddir)/Collect \
+	-lIndexSearch -lCollect -lTokenize -lUtils -lBasicUtils \
+	@GLIBMM_LIBS@ @DBUS_LIBS@ @XML_LIBS@ \
+	@HTTP_LIBS@ @MISC_LIBS@
 
 pinot_label_SOURCES = pinot-label.cpp
 
 pinot_label_DEPENDENCIES = libIndexSearch.la
 
+pinot_search_LDFLAGS = \
+	-rdynamic
+
 pinot_search_LDADD = \
 	-L$(top_builddir)/Utils \
 	-L$(top_builddir)/Tokenize \
 	-L$(top_builddir)/Collect \
 	-L$(top_builddir)/IndexSearch/Google \
-	-L$(top_builddir)/IndexSearch/Xapian \
 	-L$(top_builddir)/IndexSearch/xesam \
-	-lIndexSearch -lIndexSearchXapian -lCollect -lTokenize -lUtils -lBasicUtils \
-	@GLIBMM_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ @SOAP_LIBS@ \
-	@XML_LIBS@ @GMIME_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
+	-lIndexSearch -lCollect -lTokenize -lUtils -lBasicUtils \
+	@GLIBMM_LIBS@ @DBUS_LIBS@ @SOAP_LIBS@ \
+	@XML_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
 
 pinot_search_SOURCES = \
 	pinot-search.cpp
@@ -104,9 +109,8 @@
 	-I$(top_srcdir)/Tokenize/filters \
 	-I$(top_srcdir)/Collect \
 	-I$(top_srcdir)/IndexSearch/Google \
-	-I$(top_srcdir)/IndexSearch/Xapian \
 	-I$(top_srcdir)/IndexSearch/xesam \
-	@HTTP_CFLAGS@ @GMIME_CFLAGS@ @XML_CFLAGS@ \
+	@HTTP_CFLAGS@ @XML_CFLAGS@ \
 	@DBUS_CFLAGS@ @INDEX_CFLAGS@ @GLIBMM_CFLAGS@
 
 if HAVE_BOOST_SPIRIT

Modified: trunk/IndexSearch/Xapian/Makefile.am
===================================================================
--- trunk/IndexSearch/Xapian/Makefile.am	2007-12-19 12:26:57 UTC (rev 1144)
+++ trunk/IndexSearch/Xapian/Makefile.am	2007-12-19 12:31:34 UTC (rev 1145)
@@ -13,11 +13,12 @@
 	$(top_srcdir)/IndexSearch/xesam/XesamQueryBuilder.h \
 	$(top_srcdir)/IndexSearch/xesam/XesamULParser.h
 
-noinst_LTLIBRARIES = libIndexSearchXapian.la
+lib_LTLIBRARIES = libxapianmodule.la
 
-libIndexSearchXapian_la_SOURCES = \
+libxapianmodule_la_SOURCES = \
 	AbstractGenerator.cpp \
 	LanguageDetector.cpp \
+	ModuleExports.cc \
 	XapianDatabase.cpp \
 	XapianDatabaseFactory.cpp \
 	XapianIndex.cpp \
@@ -27,18 +28,28 @@
 	$(top_srcdir)/IndexSearch/xesam/XesamQueryBuilder.cc
 
 if HAVE_BOOST_SPIRIT
-libIndexSearchXapian_la_SOURCES += $(top_srcdir)/IndexSearch/xesam/XesamULParser.cc
+libxapianmodule_la_SOURCES += $(top_srcdir)/IndexSearch/xesam/XesamULParser.cc
 endif
 
+libxapianmodule_la_LDFLAGS = -module -shared -nostartfiles @XML_CFLAGS@
+
+libxapianmodule_la_LIBADD = \
+	@INDEX_LIBS@ \
+	-L$(top_builddir)/Utils \
+	-lBasicUtils 
+#-L$(top_srcdir)/Tokenize 
+#-L$(top_builddir)/IndexSearch 
+#-lTokenize -lUtils
+## @GLIBMM_LIBS@ @INDEX_LIBS@ @XML_LIBS@ @MISC_LIBS@
+
 AM_CXXFLAGS = \
+	-fPIC \
 	-I$(top_srcdir)/Utils \
 	-I$(top_srcdir)/Tokenize \
 	-I$(top_srcdir)/Tokenize/filters \
-	-I$(top_srcdir)/Collect \
 	-I$(top_srcdir)/IndexSearch \
 	-I$(top_srcdir)/IndexSearch/xesam \
-	@HTTP_CFLAGS@ @GMIME_CFLAGS@ @XML_CFLAGS@ \
-	@INDEX_CFLAGS@ @GLIBMM_CFLAGS@
+	@XML_CFLAGS@ @INDEX_CFLAGS@ @GLIBMM_CFLAGS@
 
 if HAVE_BOOST_SPIRIT
 AM_CXXFLAGS += -DHAVE_BOOST_SPIRIT

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2007-12-19 12:26:57 UTC (rev 1144)
+++ trunk/Makefile.am	2007-12-19 12:31:34 UTC (rev 1145)
@@ -1,5 +1,5 @@
 
-SUBDIRS = po Utils Tokenize SQL Collect IndexSearch/Google IndexSearch/Xapian IndexSearch Monitor UI/GTK2/src
+SUBDIRS = po Utils Tokenize SQL Collect IndexSearch/Google IndexSearch IndexSearch/Xapian Monitor UI/GTK2/src
 
 # TODO: Fix that when cleaning up for distcheck! - crazy -
 EXTRA_DIST = AUTHORS ChangeLog ChangeLog-dijon FAQ NEWS README TODO \
@@ -40,6 +40,9 @@
 	@mkdir -p $(DESTDIR)$(libdir)/pinot/filters
 	@rm $(DESTDIR)$(libdir)/lib*filter.a $(DESTDIR)$(libdir)/lib*filter.la
 	@mv $(DESTDIR)$(libdir)/lib*filter* $(DESTDIR)$(libdir)/pinot/filters/
+	@mkdir -p $(DESTDIR)$(libdir)/pinot/modules
+	@rm $(DESTDIR)$(libdir)/lib*module.a $(DESTDIR)$(libdir)/lib*module.la
+	@mv $(DESTDIR)$(libdir)/lib*module* $(DESTDIR)$(libdir)/pinot/modules/
 	@mkdir -p $(DESTDIR)$(datadir)/icons/hicolor/48x48/apps/
 	$(INSTALL_DATA) $(srcdir)/UI/icons/48x48/pinot.png $(DESTDIR)$(datadir)/icons/hicolor/48x48/apps/pinot.png
 	@mkdir -p $(DESTDIR)$(datadir)/icons/hicolor/32x32/apps/

Modified: trunk/Tokenize/Makefile.am
===================================================================
--- trunk/Tokenize/Makefile.am	2007-12-19 12:26:57 UTC (rev 1144)
+++ trunk/Tokenize/Makefile.am	2007-12-19 12:31:34 UTC (rev 1145)
@@ -20,7 +20,7 @@
 	$(top_srcdir)/Tokenize/filters/Filter.cc \
 	$(top_srcdir)/Tokenize/filters/ExternalFilter.cc
 
-libexternalfilter_la_LDFLAGS = -module @XML_CFLAGS@
+libexternalfilter_la_LDFLAGS = -module @XML_LIBS@
 
 libexternalfilter_la_LIBADD =
 
@@ -28,7 +28,7 @@
 	$(top_srcdir)/Tokenize/filters/Filter.cc \
 	$(top_srcdir)/Tokenize/filters/GMimeMboxFilter.cc
 
-libmboxfilter_la_LDFLAGS = -module @GMIME_CFLAGS@
+libmboxfilter_la_LDFLAGS = -module @GMIME_LIBS@
 
 libmboxfilter_la_LIBADD =
 

Modified: trunk/UI/GTK2/src/Makefile.am
===================================================================
--- trunk/UI/GTK2/src/Makefile.am	2007-12-19 12:26:57 UTC (rev 1144)
+++ trunk/UI/GTK2/src/Makefile.am	2007-12-19 12:31:34 UTC (rev 1145)
@@ -75,10 +75,12 @@
 	-I$(top_srcdir)/Collect \
 	-I$(top_srcdir)/IndexSearch \
 	-I$(top_srcdir)/IndexSearch/Google \
-	-I$(top_srcdir)/IndexSearch/Xapian \
-	@SQL_CFLAGS@ @HTTP_CFLAGS@ @GMIME_CFLAGS@ @XML_CFLAGS@ \
-	@SOAP_CFLAGS@ @DBUS_CFLAGS@ @INDEX_CFLAGS@ @UI_CFLAGS@
+	@SQL_CFLAGS@ @HTTP_CFLAGS@ @XML_CFLAGS@ @SOAP_CFLAGS@ \
+	@DBUS_CFLAGS@ @INDEX_CFLAGS@ @GTHREAD_CFLAGS@ @GTKMM_CFLAGS@
 
+pinot_LDFLAGS = \
+	-rdynamic
+
 pinot_LDADD = \
 	-L$(top_builddir)/Utils \
 	-L$(top_builddir)/Tokenize \
@@ -87,12 +89,14 @@
 	-L$(top_builddir)/Collect \
 	-L$(top_builddir)/IndexSearch \
 	-L$(top_builddir)/IndexSearch/Google \
-	-L$(top_builddir)/IndexSearch/Xapian \
-	-lIndexSearch -lIndexSearchXapian -lMonitor -lCollect -lSQL \
-	-lTokenize -lUtils -lBasicUtils @LIBS@ @UI_LIBS@ \
-	@INDEX_LIBS@ @DBUS_LIBS@ @SOAP_LIBS@ @XML_LIBS@ \
-	@GMIME_LIBS@ @HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
+	-lIndexSearch -lMonitor -lCollect -lSQL \
+	-lTokenize -lUtils -lBasicUtils @LIBS@ \
+	@GTKMM_LIBS@ @DBUS_LIBS@ @GTHREAD_LIBS@ @SOAP_LIBS@ @XML_LIBS@ \
+	@HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
 
+pinot_dbus_daemon_LDFLAGS = \
+	-rdynamic
+
 pinot_dbus_daemon_LDADD = \
 	-L$(top_builddir)/Utils \
 	-L$(top_builddir)/Tokenize \
@@ -101,9 +105,8 @@
 	-L$(top_builddir)/Collect \
 	-L$(top_builddir)/IndexSearch \
 	-L$(top_builddir)/IndexSearch/Google \
-	-L$(top_builddir)/IndexSearch/Xapian \
-	-lIndexSearch -lIndexSearchXapian -lMonitor -lCollect -lSQL \
-	-lTokenize -lUtils -lBasicUtils @LIBS@ @GLIBMM_LIBS@ \
-	@INDEX_LIBS@ @DBUS_LIBS@ @SOAP_LIBS@ @XML_LIBS@ @GMIME_LIBS@ \
+	-lIndexSearch -lMonitor -lCollect -lSQL \
+	-lTokenize -lUtils -lBasicUtils @LIBS@ \
+	@GLIBMM_LIBS@ @DBUS_LIBS@ @GTHREAD_LIBS@ @SOAP_LIBS@ @XML_LIBS@ \
 	@HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
 

Modified: trunk/Utils/Makefile.am
===================================================================
--- trunk/Utils/Makefile.am	2007-12-19 12:26:57 UTC (rev 1144)
+++ trunk/Utils/Makefile.am	2007-12-19 12:31:34 UTC (rev 1145)
@@ -27,12 +27,12 @@
 	DocumentInfo.cpp \
 	StringManip.cpp \
 	TimeConverter.cpp \
+	Timer.cpp \
 	Url.cpp
 
 libUtils_la_SOURCES = \
 	Languages.cpp \
 	MIMEScanner.cpp \
-	Timer.cpp \
 	$(top_srcdir)/Utils/xdgmime/xdgmimealias.c \
 	$(top_srcdir)/Utils/xdgmime/xdgmime.c \
 	$(top_srcdir)/Utils/xdgmime/xdgmimecache.c \
@@ -42,5 +42,5 @@
 	$(top_srcdir)/Utils/xdgmime/xdgmimeparent.c
 
 AM_CFLAGS = -fPIC -DXDG_PREFIX=pinot_xdg
-AM_CXXFLAGS = -fPIC @HTTP_CFLAGS@ @INDEX_CFLAGS@ @GMIME_CFLAGS@ @GLIBMM_CFLAGS@ -DXDG_PREFIX=pinot_xdg
+AM_CXXFLAGS = -fPIC @HTTP_CFLAGS@ @INDEX_CFLAGS@ @GLIBMM_CFLAGS@ -DXDG_PREFIX=pinot_xdg
 

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2007-12-19 12:26:57 UTC (rev 1144)
+++ trunk/configure.in	2007-12-19 12:31:34 UTC (rev 1145)
@@ -291,12 +291,15 @@
 PKG_CHECK_MODULES(SIGCPP, sigc++-2.0 >= 2.0 )
 AC_SUBST(SIGCPP_CFLAGS)
 AC_SUBST(SIGCPP_LIBS)
+PKG_CHECK_MODULES(GTHREAD, gthread-2.0 >= 2.6 )
+AC_SUBST(GTHREAD_CFLAGS)
+AC_SUBST(GTHREAD_LIBS)
 PKG_CHECK_MODULES(GLIBMM, glibmm-2.4 >= 2.6 )
 AC_SUBST(GLIBMM_CFLAGS)
 AC_SUBST(GLIBMM_LIBS)
-PKG_CHECK_MODULES(UI, gtkmm-2.4 >= 2.10 )
-AC_SUBST(UI_CFLAGS)
-AC_SUBST(UI_LIBS)
+PKG_CHECK_MODULES(GTKMM, gtkmm-2.4 >= 2.10 )
+AC_SUBST(GTKMM_CFLAGS)
+AC_SUBST(GTKMM_LIBS)
 
 dnl Check for specific functions
 AC_CHECK_FUNCS(gettimeofday)



From fabricecolin at mail.berlios.de  Wed Dec 19 13:39:41 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 19 Dec 2007 13:39:41 +0100
Subject: [Pinot-svn] r1146 - in trunk: IndexSearch UI/GTK2/src
Message-ID: <200712191239.lBJCdfKc010351@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-19 13:39:39 +0100 (Wed, 19 Dec 2007)
New Revision: 1146

Modified:
   trunk/IndexSearch/pinot-index.cpp
   trunk/IndexSearch/pinot-label.cpp
   trunk/IndexSearch/pinot-search.cpp
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/ServerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/pinot-dbus-daemon.cc
   trunk/UI/GTK2/src/pinot.cc
   trunk/UI/GTK2/src/prefsDialog.cc
Log:
Rely on ModuleFactory instead of other other factories, load modules.
pinot-label uses a pure DBusIndex object, pinot-search sets proxy options only
if the engine is a WebEngine.
Added .a .la .o .so and backup files to blacklist in PinotSettings.
Don't aapply spelling correction to More Like and previously corrected queries.


Modified: trunk/IndexSearch/pinot-index.cpp
===================================================================
--- trunk/IndexSearch/pinot-index.cpp	2007-12-19 12:31:34 UTC (rev 1145)
+++ trunk/IndexSearch/pinot-index.cpp	2007-12-19 12:39:39 UTC (rev 1146)
@@ -23,14 +23,14 @@
 #include <string>
 #include <fstream>
 
+#include "config.h"
 #include "Languages.h"
 #include "MIMEScanner.h"
 #include "Url.h"
 #include "FilterFactory.h"
-#include "XapianDatabaseFactory.h"
 #include "DownloaderFactory.h"
 #include "FilterWrapper.h"
-#include "IndexFactory.h"
+#include "ModuleFactory.h"
 #include "config.h"
 
 using namespace std;
@@ -160,29 +160,31 @@
 
 	MIMEScanner::initialize("", "");
 	DownloaderInterface::initialize();
-	// Localize language names
-	Languages::setIntlName(0, "Unknown");
-	Languages::setIntlName(1, "Danish");
-	Languages::setIntlName(2, "Dutch");
-	Languages::setIntlName(3, "English");
-	Languages::setIntlName(4, "Finnish");
-	Languages::setIntlName(5, "French");
-	Languages::setIntlName(6, "German");
-	Languages::setIntlName(7, "Hungarian");
-	Languages::setIntlName(8, "Italian");
-	Languages::setIntlName(9, "Norwegian");
-	Languages::setIntlName(10, "Portuguese");
-	Languages::setIntlName(11, "Romanian");
-	Languages::setIntlName(12, "Russian");
-	Languages::setIntlName(13, "Spanish");
-	Languages::setIntlName(14, "Swedish");
-	Languages::setIntlName(15, "Turkish");
 	Dijon::HtmlFilter::initialize();
 	Dijon::FilterFactory::loadFilters(string(LIBDIR) + string("/pinot/filters"));
+	ModuleFactory::loadModules(string(LIBDIR) + string("/pinot/modules"));
 
+	// Localize language names
+	Languages::setIntlName (0, "Unknown");
+	Languages::setIntlName (1, "Danish");
+	Languages::setIntlName (2, "Dutch");
+	Languages::setIntlName (3, "English");
+	Languages::setIntlName (4, "Finnish");
+	Languages::setIntlName (5, "French");
+	Languages::setIntlName (6, "German");
+	Languages::setIntlName (7, "Hungarian");
+	Languages::setIntlName (8, "Italian");
+	Languages::setIntlName (9, "Norwegian");
+	Languages::setIntlName (10, "Portuguese");
+	Languages::setIntlName (11, "Romanian");
+	Languages::setIntlName (12, "Russian");
+	Languages::setIntlName (13, "Spanish");
+	Languages::setIntlName (14, "Swedish");
+	Languages::setIntlName (15, "Turkish");
+
 	// Make sure the index is open in the correct mode
-	XapianDatabase *pDb = XapianDatabaseFactory::getDatabase(databaseName, (indexDocument ? false : true));
-	if (pDb == NULL)
+	bool wasObsoleteFormat = false;
+	if (ModuleFactory::openOrCreateIndex("xapian", databaseName, wasObsoleteFormat, (indexDocument ? false : true)) == false)
 	{
 		cerr << "Couldn't open index " << databaseName << endl;
 
@@ -195,12 +197,12 @@
 	}
 
 	// Get a read-write index of the given type
-	IndexInterface *pIndex = IndexFactory::getIndex("xapian", databaseName);
+	IndexInterface *pIndex = ModuleFactory::getIndex("xapian", databaseName);
 	if (pIndex == NULL)
 	{
 		cerr << "Couldn't obtain index for " << databaseName << endl;
 
-		XapianDatabaseFactory::closeAll();
+		ModuleFactory::unloadModules();
 		Dijon::FilterFactory::unloadFilters();
 		Dijon::HtmlFilter::shutdown();
 		DownloaderInterface::shutdown();
@@ -322,7 +324,7 @@
 	}
 	delete pIndex;
 
-	XapianDatabaseFactory::closeAll();
+	ModuleFactory::unloadModules();
 	Dijon::FilterFactory::unloadFilters();
 	Dijon::HtmlFilter::shutdown();
 	DownloaderInterface::shutdown();

Modified: trunk/IndexSearch/pinot-label.cpp
===================================================================
--- trunk/IndexSearch/pinot-label.cpp	2007-12-19 12:31:34 UTC (rev 1145)
+++ trunk/IndexSearch/pinot-label.cpp	2007-12-19 12:39:39 UTC (rev 1146)
@@ -22,23 +22,12 @@
 #include <iostream>
 #include <string>
 #include <set>
-#include "config.h"
-extern "C"
-{
-#if DBUS_NUM_VERSION < 1000000
-#define DBUS_API_SUBJECT_TO_CHANGE
-#endif
-#include <dbus/dbus.h>
-#include <dbus/dbus-glib.h>
-#include <dbus/dbus-glib-lowlevel.h>
-}
 
+#include "config.h"
 #include "StringManip.h"
 #include "MIMEScanner.h"
 #include "Url.h"
 #include "DBusIndex.h"
-#include "IndexFactory.h"
-#include "XapianDatabaseFactory.h"
 
 using namespace std;
 
@@ -184,22 +173,12 @@
 
 	MIMEScanner::initialize("", "");
 
-	// We need a DBusIndex object
-	string indexLocation(getHomeDirectory() + "/.pinot/daemon");
-	DBusIndex index(IndexFactory::getIndex("xapian", indexLocation));
-	if (index.isGood() == false)
-	{
-		cerr << "Couldn't obtain index for " << indexLocation << endl;
+	// We need a pure DBusIndex object
+	DBusIndex index(NULL);
 
-		XapianDatabaseFactory::closeAll();
-		MIMEScanner::shutdown();
-
-		return EXIT_FAILURE;
-	}
-
 	if (getLabels == true)
 	{
-		if (index.getLabels(labels, true) == true)
+		if (index.getLabels(labels) == true)
 		{
 			printLabels(labels, "");
 
@@ -230,7 +209,7 @@
 		{
 			labels.clear();
 
-			if (index.getDocumentLabels(docId, labels, true) == true)
+			if (index.getDocumentLabels(docId, labels) == true)
 			{
 				printLabels(labels, fileParam);
 
@@ -267,7 +246,6 @@
 		++optind;
 	}
 
-	XapianDatabaseFactory::closeAll();
 	MIMEScanner::shutdown();
 
 	// Did whatever operation we carried out succeed ?

Modified: trunk/IndexSearch/pinot-search.cpp
===================================================================
--- trunk/IndexSearch/pinot-search.cpp	2007-12-19 12:31:34 UTC (rev 1145)
+++ trunk/IndexSearch/pinot-search.cpp	2007-12-19 12:39:39 UTC (rev 1146)
@@ -23,14 +23,14 @@
 #include <fstream>
 #include <string>
 
+#include "config.h"
 #include "Languages.h"
 #include "MIMEScanner.h"
 #include "Url.h"
-#include "XapianDatabaseFactory.h"
-#include "SearchEngineFactory.h"
+#include "DownloaderFactory.h"
+#include "ModuleFactory.h"
 #include "ResultsExporter.h"
-#include "DownloaderFactory.h"
-#include "config.h"
+#include "WebEngine.h"
 
 using namespace std;
 
@@ -81,7 +81,9 @@
 	set<string> engines;
 
 	// Help
-	SearchEngineFactory::getSupportedEngines(engines);
+	ModuleFactory::loadModules(string(LIBDIR) + string("/pinot/modules"));
+	ModuleFactory::getSupportedEngines(engines);
+	ModuleFactory::unloadModules();
 	cout << "pinot-search - Query search engines from the command-line\n\n"
 		<< "Usage: pinot-search [OPTIONS] SEARCHENGINETYPE SEARCHENGINENAME|SEARCHENGINEOPTION QUERYINPUT\n\n"
 		<< "Options:\n"
@@ -106,7 +108,7 @@
 #endif
 		<< "pinot-search opensearch " << PREFIX << "/share/pinot/engines/KrustyDescription.xml \"clowns\"\n\n"
 		<< "pinot-search --max 20 sherlock " << PREFIX << "/share/pinot/engines/Bozo.src \"clowns\"\n\n"
-		<< "pinot-search --max 10 xapian ~/.pinot/index \"clowns\"\n\n"
+		<< "pinot-search xapian ~/.pinot/index \"label:Clowns\"\n\n"
 		<< "pinot-search xapian somehostname:12345 \"clowns\"\n\n"
 		<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
 }
@@ -201,6 +203,8 @@
 
 	MIMEScanner::initialize("", "");
 	DownloaderInterface::initialize();
+	ModuleFactory::loadModules(string(LIBDIR) + string("/pinot/modules"));
+
 	// Localize language names
 	Languages::setIntlName(0, "Unknown");
 	Languages::setIntlName(1, "Danish");
@@ -224,7 +228,7 @@
 	char *pQueryInput = argv[optind + 2];
 
 	// Which SearchEngine ?
-	SearchEngineInterface *pEngine = SearchEngineFactory::getSearchEngine(engineType, option);
+	SearchEngineInterface *pEngine = ModuleFactory::getSearchEngine(engineType, option);
 	if (pEngine == NULL)
 	{
 		cerr << "Couldn't obtain search engine instance" << endl;
@@ -236,14 +240,18 @@
 	}
 
 	// Set up the proxy
-	DownloaderInterface *pDownloader = pEngine->getDownloader();
-	if ((pDownloader != NULL) &&
-		(proxyAddress.empty() == false) &&
-		(proxyPort.empty() == false))
+	WebEngine *pWebEngine = dynamic_cast<WebEngine *>(pEngine);
+	if (pWebEngine != NULL)
 	{
-		pDownloader->setSetting("proxyaddress", proxyAddress);
-		pDownloader->setSetting("proxyport", proxyPort);
-		pDownloader->setSetting("proxytype", proxyType);
+		DownloaderInterface *pDownloader = pWebEngine->getDownloader();
+		if ((pDownloader != NULL) &&
+			(proxyAddress.empty() == false) &&
+			(proxyPort.empty() == false))
+		{
+			pDownloader->setSetting("proxyaddress", proxyAddress);
+			pDownloader->setSetting("proxyport", proxyPort);
+			pDownloader->setSetting("proxytype", proxyType);
+		}
 	}
 
 	// Set the query
@@ -307,7 +315,7 @@
 			}
 			else
 			{
-				string engineName(SearchEngineFactory::getSearchEngineName(engineType, option));
+				string engineName(ModuleFactory::getSearchEngineName(engineType, option));
 
 				if (csvExport.empty() == false)
 				{
@@ -336,7 +344,7 @@
 
 	delete pEngine;
 
-	XapianDatabaseFactory::closeAll();
+	ModuleFactory::unloadModules();
 	DownloaderInterface::shutdown();
 	MIMEScanner::shutdown();
 

Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2007-12-19 12:31:34 UTC (rev 1145)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2007-12-19 12:39:39 UTC (rev 1146)
@@ -34,11 +34,10 @@
 #include <libxml++/nodes/textnode.h>
 
 #include "config.h"
+#include "NLS.h"
 #include "CommandLine.h"
-#include "Languages.h"
-#include "NLS.h"
 #include "StringManip.h"
-#include "IndexFactory.h"
+#include "ModuleFactory.h"
 #include "PluginWebEngine.h"
 #include "PinotSettings.h"
 
@@ -329,21 +328,26 @@
 		m_labels.insert(_("New"));
 		m_labels.insert(_("Personal"));
 		// Skip common image, video and archive types
+		m_filePatternsList.insert("*~");
 		m_filePatternsList.insert("*.Z");
+		m_filePatternsList.insert("*.a");
 		m_filePatternsList.insert("*.avi");
 		m_filePatternsList.insert("*.asf");
 		m_filePatternsList.insert("*.gif");
 		m_filePatternsList.insert("*.iso");
 		m_filePatternsList.insert("*.jpeg");
 		m_filePatternsList.insert("*.jpg");
+		m_filePatternsList.insert("*.la");
 		m_filePatternsList.insert("*.lha");
 		m_filePatternsList.insert("*.mov");
 		m_filePatternsList.insert("*.msf");
 		m_filePatternsList.insert("*.mpeg");
 		m_filePatternsList.insert("*.mpg");
+		m_filePatternsList.insert("*.o");
 		m_filePatternsList.insert("*.png");
 		m_filePatternsList.insert("*.rar");
 		m_filePatternsList.insert("*.sh");
+		m_filePatternsList.insert("*.so");
 		m_filePatternsList.insert("*.tiff");
 		m_filePatternsList.insert("*.wmv");
 		m_filePatternsList.insert("*.xbm");
@@ -1567,15 +1571,15 @@
 {
 	if (location == m_docsIndexLocation)
 	{
-		return IndexFactory::getIndex("xapian", m_docsIndexLocation);
+		return ModuleFactory::getIndex("xapian", m_docsIndexLocation);
 	}
 	else if ((m_clientMode == true) &&
 		(location == m_daemonIndexLocation))
 	{
-		return IndexFactory::getIndex("dbus-xapian", m_daemonIndexLocation);
+		return ModuleFactory::getIndex("dbus-xapian", m_daemonIndexLocation);
 	}
 
-	return IndexFactory::getIndex("xapian", location);
+	return ModuleFactory::getIndex("xapian", location);
 }
 
 /// Returns the search engines set.

Modified: trunk/UI/GTK2/src/ServerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/ServerThreads.cpp	2007-12-19 12:31:34 UTC (rev 1145)
+++ trunk/UI/GTK2/src/ServerThreads.cpp	2007-12-19 12:39:39 UTC (rev 1146)
@@ -30,15 +30,14 @@
 #include <fstream>
 #include <glibmm/miscutils.h>
 
-#include "Languages.h"
+#include "config.h"
+#include "NLS.h"
 #include "MIMEScanner.h"
 #include "TimeConverter.h"
 #include "Timer.h"
 #include "Url.h"
 #include "DBusIndex.h"
-#include "SearchEngineFactory.h"
-#include "config.h"
-#include "NLS.h"
+#include "ModuleFactory.h"
 #include "DaemonState.h"
 #include "PinotSettings.h"
 #include "ServerThreads.h"
@@ -314,7 +313,12 @@
 				if (m_pMonitor != NULL)
 				{
 					// Monitor first so that we don't miss events
-					m_pMonitor->addLocation(entryName, true);
+					// If monitoring is not possible, record the first case
+					if ((m_pMonitor->addLocation(entryName, true) == false) &&
+						(entryStatus != MONITORING_FAILED))
+					{
+						entryStatus = MONITORING_FAILED;
+					}
 				}
 
 				// Iterate through this directory's entries
@@ -377,27 +381,14 @@
 		scanSuccess = false;
 	}
 
-	// Did an error occur ?
-	if (scanSuccess == false)
+	// If a major error occured, this won't be true
+	if (reportFile == true)
 	{
-		time_t timeNow = time(NULL);
-
-		// Record this error
 		if (itemExists == false)
 		{
-			history.insertItem(location, CrawlHistory::ERROR, m_sourceId, timeNow, entryStatus);
-		}
-		else
-		{
-			history.updateItem(location, CrawlHistory::ERROR, timeNow, entryStatus);
-		}
-	}
-	else if (reportFile == true)
-	{
-		if (itemExists == false)
-		{
 			// Record it
 			history.insertItem(location, CrawlHistory::CRAWLED, m_sourceId, fileStat.st_mtime);
+			itemExists = true;
 #ifdef DEBUG
 			cout << "DirectoryScannerThread::scanEntry: reporting new file " << entryName << endl;
 #endif
@@ -445,6 +436,22 @@
 		}
 	}
 
+	// Did an error occur ?
+	if (entryStatus != 0)
+	{
+		time_t timeNow = time(NULL);
+
+		// Record this error
+		if (itemExists == false)
+		{
+			history.insertItem(location, CrawlHistory::ERROR, m_sourceId, timeNow, entryStatus);
+		}
+		else
+		{
+			history.updateItem(location, CrawlHistory::ERROR, timeNow, entryStatus);
+		}
+	}
+
 	return scanSuccess;
 }
 
@@ -562,7 +569,7 @@
 {
 	docIds.clear();
 
-	SearchEngineInterface *pEngine = SearchEngineFactory::getSearchEngine("xapian",
+	SearchEngineInterface *pEngine = ModuleFactory::getSearchEngine("xapian",
 		PinotSettings::getInstance().m_daemonIndexLocation);
 	if (pEngine == NULL)
 	{

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2007-12-19 12:31:34 UTC (rev 1145)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2007-12-19 12:39:39 UTC (rev 1146)
@@ -31,22 +31,22 @@
 #include <glibmm/miscutils.h>
 #include <glibmm/exception.h>
 
+#include "config.h"
+#include "NLS.h"
 #include "MIMEScanner.h"
 #include "StringManip.h"
 #include "TimeConverter.h"
 #include "Url.h"
 #include "HtmlFilter.h"
-#include "FilterFactory.h"
 #include "FilterUtils.h"
-#include "FilterWrapper.h"
-#include "DBusIndex.h"
 #include "ActionQueue.h"
 #include "CrawlHistory.h"
 #include "QueryHistory.h"
 #include "DownloaderFactory.h"
-#include "SearchEngineFactory.h"
-#include "config.h"
-#include "NLS.h"
+#include "FilterWrapper.h"
+#include "DBusIndex.h"
+#include "ModuleFactory.h"
+#include "WebEngine.h"
 #include "PinotSettings.h"
 #include "WorkerThreads.h"
 
@@ -101,7 +101,7 @@
 		case DOWNLOAD_FAILED:
 			return _("Couldn't retrieve document");
 		case MONITORING_FAILED:
-			return _("Couldn't initialize file monitor");
+			return _("File monitor error");
 		case OPENDIR_FAILED:
 			return _("Couldn't open directory");
 		case UNKNOWN_INDEX:
@@ -1040,7 +1040,7 @@
 	PinotSettings &settings = PinotSettings::getInstance();
 
 	// Get the SearchEngine
-	SearchEngineInterface *pEngine = SearchEngineFactory::getSearchEngine(m_engineName, m_engineOption);
+	SearchEngineInterface *pEngine = ModuleFactory::getSearchEngine(m_engineName, m_engineOption);
 	if (pEngine == NULL)
 	{
 		m_errorNum = UNKNOWN_ENGINE;
@@ -1049,17 +1049,21 @@
 	}
 
 	// Set up the proxy
-	DownloaderInterface *pDownloader = pEngine->getDownloader();
-	if ((pDownloader != NULL) &&
-		(settings.m_proxyEnabled == true) &&
-		(settings.m_proxyAddress.empty() == false))
+	WebEngine *pWebEngine = dynamic_cast<WebEngine *>(pEngine);
+	if (pWebEngine != NULL)
 	{
-		char portStr[64];
+		DownloaderInterface *pDownloader = pWebEngine->getDownloader();
+		if ((pDownloader != NULL) &&
+			(settings.m_proxyEnabled == true) &&
+			(settings.m_proxyAddress.empty() == false))
+		{
+			char portStr[64];
 
-		pDownloader->setSetting("proxyaddress", settings.m_proxyAddress);
-		snprintf(portStr, 64, "%u", settings.m_proxyPort);
-		pDownloader->setSetting("proxyport", portStr);
-		pDownloader->setSetting("proxytype", settings.m_proxyType);
+			pDownloader->setSetting("proxyaddress", settings.m_proxyAddress);
+			snprintf(portStr, 64, "%u", settings.m_proxyPort);
+			pDownloader->setSetting("proxyport", portStr);
+			pDownloader->setSetting("proxytype", settings.m_proxyType);
+		}
 	}
 
 	if (m_listingIndex == false)
@@ -1097,12 +1101,17 @@
 				PinotSettings::getInstance().getIndexIdByName(m_engineDisplayableName));
 		}
 
-		// Any spelling correction ?
-		string correctedFreeQuery(pEngine->getSpellingCorrection());
-		if (correctedFreeQuery.empty() == false)
+		// Don't spellcheck if the query was modified in any way
+		if (m_queryProps.getModified() == false)
 		{
-			m_correctedSpelling = true;
-			m_queryProps.setFreeQuery(correctedFreeQuery);
+			string correctedFreeQuery(pEngine->getSpellingCorrection());
+
+			// Any spelling correction ?
+			if (correctedFreeQuery.empty() == false)
+			{
+				m_correctedSpelling = true;
+				m_queryProps.setFreeQuery(correctedFreeQuery);
+			}
 		}
 	}
 
@@ -1173,7 +1182,7 @@
 void ExpandQueryThread::doWork(void)
 {
 	// Get the SearchEngine
-	SearchEngineInterface *pEngine = SearchEngineFactory::getSearchEngine("xapian", "MERGED");
+	SearchEngineInterface *pEngine = ModuleFactory::getSearchEngine("xapian", "MERGED");
 	if (pEngine == NULL)
 	{
 		m_errorNum = UNKNOWN_ENGINE;

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2007-12-19 12:31:34 UTC (rev 1145)
+++ trunk/UI/GTK2/src/mainWindow.cc	2007-12-19 12:39:39 UTC (rev 1146)
@@ -1284,6 +1284,7 @@
 				correctedQueryName += queryName;
 			}
 			queryProps.setName(correctedQueryName);
+			queryProps.setModified(true);
 
 			add_query(queryProps, true);
 		}
@@ -1391,6 +1392,7 @@
 			moreLike += *termIter;
 		}
 		queryProps.setFreeQuery(queryProps.getFreeQuery() + moreLike);
+		queryProps.setModified(true);
 
 		add_query(queryProps, false);
 	}

Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2007-12-19 12:31:34 UTC (rev 1145)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2007-12-19 12:39:39 UTC (rev 1146)
@@ -35,18 +35,17 @@
 #include <glibmm/object.h>
 #include <glibmm/main.h>
 
+#include "config.h"
+#include "NLS.h"
 #include "FilterFactory.h"
 #include "Languages.h"
 #include "MIMEScanner.h"
-#include "XapianDatabase.h"
-#include "XapianDatabaseFactory.h"
+#include "ModuleFactory.h"
 #include "ActionQueue.h"
 #include "CrawlHistory.h"
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "DownloaderInterface.h"
-#include "config.h"
-#include "NLS.h"
 #include "DaemonState.h"
 #include "PinotSettings.h"
 #include "ServerThreads.h"
@@ -80,10 +79,8 @@
 {
 	cout << "Exiting..." << endl;
 
-	// Close all indexes we may have opened
-	XapianDatabaseFactory::closeAll();
-
-	// Close the tokenizer libraries
+	// Close everything
+	ModuleFactory::unloadModules();
 	Dijon::FilterFactory::unloadFilters();
 	Dijon::HtmlFilter::shutdown();
 
@@ -398,6 +395,13 @@
 		cerr << "Couldn't load MIME settings" << endl;
 	}
 	DownloaderInterface::initialize();
+	// Load tokenizer libraries, if any
+	Dijon::HtmlFilter::initialize();
+	Dijon::FilterFactory::loadFilters(string(LIBDIR) + "/pinot/filters");
+	Dijon::FilterFactory::loadFilters(confDirectory + "/filters");
+	// Load modules, if any
+	ModuleFactory::loadModules(string(LIBDIR) + "/pinot/modules");
+	ModuleFactory::loadModules(confDirectory + "/modules");
 
 	// Localize language names
 	Languages::setIntlName(0, _("Unknown"));
@@ -417,10 +421,6 @@
 	Languages::setIntlName(14, _("Swedish"));
 	Languages::setIntlName(15, _("Turkish"));
 
-	// Load tokenizer libraries, if any
-	Dijon::HtmlFilter::initialize();
-	Dijon::FilterFactory::loadFilters(string(LIBDIR) + "/pinot/filters");
-	Dijon::FilterFactory::loadFilters(confDirectory + "/filters");
 	// Load the settings
 	settings.loadGlobal(string(SYSCONFDIR) + "/pinot/globalconfig.xml");
 	settings.load();
@@ -434,14 +434,13 @@
 	sigaction(SIGQUIT, &newAction, NULL);
 
 	// Open the daemon index in read-write mode 
-	XapianDatabase *pDb = XapianDatabaseFactory::getDatabase(settings.m_daemonIndexLocation, false);
-	if ((pDb == NULL) ||
-		(pDb->isOpen() == false))
+	bool wasObsoleteFormat = false;
+	if (ModuleFactory::openOrCreateIndex("xapian", settings.m_daemonIndexLocation, wasObsoleteFormat, false) == false)
 	{
 		cerr << "Couldn't open index " << settings.m_daemonIndexLocation << endl;
 		return EXIT_FAILURE;
 	}
-	if (pDb->wasObsoleteFormat() == true)
+	if (wasObsoleteFormat == true)
 	{
 		resetHistory = resetLabels = true;
 	}

Modified: trunk/UI/GTK2/src/pinot.cc
===================================================================
--- trunk/UI/GTK2/src/pinot.cc	2007-12-19 12:31:34 UTC (rev 1145)
+++ trunk/UI/GTK2/src/pinot.cc	2007-12-19 12:39:39 UTC (rev 1146)
@@ -41,16 +41,15 @@
 }
 #include <gtkmm/main.h>
 
+#include "NLS.h"
 #include "FilterFactory.h"
 #include "Languages.h"
 #include "MIMEScanner.h"
-#include "XapianDatabase.h"
-#include "XapianDatabaseFactory.h"
+#include "ModuleFactory.h"
 #include "ActionQueue.h"
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "DownloaderInterface.h"
-#include "NLS.h"
 #include "PinotSettings.h"
 #include "mainWindow.hh"
 
@@ -76,10 +75,8 @@
 		cerr << "Couldn't save configuration file" << endl;
 	}
 
-	// Close all indexes we may have opened
-	XapianDatabaseFactory::closeAll();
-
-	// Close the tokenizer libraries
+	// Close everything
+	ModuleFactory::unloadModules();
 	Dijon::FilterFactory::unloadFilters();
 	Dijon::HtmlFilter::shutdown();
 
@@ -226,8 +223,15 @@
 	{
 		cerr << "Couldn't load MIME settings" << endl;
 	}
-
 	DownloaderInterface::initialize();
+	// Load tokenizer libraries, if any
+	Dijon::HtmlFilter::initialize();
+	Dijon::FilterFactory::loadFilters(string(LIBDIR) + "/pinot/filters");
+	Dijon::FilterFactory::loadFilters(confDirectory + "/filters");
+	// Load modules, if any
+	ModuleFactory::loadModules(string(LIBDIR) + "/pinot/modules");
+	ModuleFactory::loadModules(confDirectory + "/modules");
+
 	// Localize language names
 	Languages::setIntlName(0, _("Unknown"));
 	Languages::setIntlName(1, _("Danish"));
@@ -249,10 +253,6 @@
 	// Load search engines
 	settings.loadSearchEngines(prefixDir + "/share/pinot/engines");
 	settings.loadSearchEngines(confDirectory + "/engines");
-	// Load tokenizer libraries, if any
-	Dijon::HtmlFilter::initialize();
-	Dijon::FilterFactory::loadFilters(string(LIBDIR) + "/pinot/filters");
-	Dijon::FilterFactory::loadFilters(confDirectory + "/filters");
 	// Load the settings
 	settings.loadGlobal(string(SYSCONFDIR) + "/pinot/globalconfig.xml");
 	settings.load();
@@ -265,9 +265,8 @@
 	sigaction(SIGQUIT, &newAction, NULL);
 
 	// Open this index read-write
-	XapianDatabase *pFirstDb = XapianDatabaseFactory::getDatabase(settings.m_docsIndexLocation, false);
-	if ((pFirstDb == NULL) ||
-		(pFirstDb->isOpen() == false))
+	bool wasObsoleteFormat = false;
+	if (ModuleFactory::openOrCreateIndex("xapian", settings.m_docsIndexLocation, wasObsoleteFormat, false) == false)
 	{
 		errorMsg = _("Couldn't open index");
 		errorMsg += " ";
@@ -275,13 +274,13 @@
 	}
 	else
 	{
-		warnAboutVersion = pFirstDb->wasObsoleteFormat();
+		warnAboutVersion = wasObsoleteFormat;
 	}
 	// ...and the daemon index in read-only mode
 	// If it can't be open, it just means the daemon has not yet created it
-	XapianDatabase *pSecondDb = XapianDatabaseFactory::getDatabase(settings.m_daemonIndexLocation);
+	ModuleFactory::openOrCreateIndex("xapian", settings.m_daemonIndexLocation, wasObsoleteFormat, true);
 	// Merge these two, this will be useful later
-	XapianDatabaseFactory::mergeDatabases("MERGED", pFirstDb, pSecondDb);
+	ModuleFactory::mergeIndexes("xapian", "MERGED", settings.m_docsIndexLocation, settings.m_daemonIndexLocation);
 
 	// Do the same for the history database
 	string historyDatabase(settings.getHistoryDatabaseName());

Modified: trunk/UI/GTK2/src/prefsDialog.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.cc	2007-12-19 12:31:34 UTC (rev 1145)
+++ trunk/UI/GTK2/src/prefsDialog.cc	2007-12-19 12:39:39 UTC (rev 1146)
@@ -28,7 +28,7 @@
 #include "config.h"
 #include "NLS.h"
 #include "StringManip.h"
-#include "SearchEngineFactory.h"
+#include "ModuleFactory.h"
 #include "PinotUtils.h"
 #include "prefsDialog.hh"
 
@@ -103,7 +103,7 @@
 	populate_patternsTreeview();
 
 	// Hide the Google API entry field ?
-	if (SearchEngineFactory::isSupported("googleapi") == false)
+	if (ModuleFactory::isSupported("googleapi") == false)
 	{
 		apiKeyLabel->hide();
 		apiKeyEntry->hide();



From fabricecolin at mail.berlios.de  Wed Dec 19 13:41:48 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 19 Dec 2007 13:41:48 +0100
Subject: [Pinot-svn] r1147 - trunk/IndexSearch/Plugins
Message-ID: <200712191241.lBJCfmR4010515@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-19 13:41:48 +0100 (Wed, 19 Dec 2007)
New Revision: 1147

Removed:
   trunk/IndexSearch/Plugins/WiseNut.src
Log:
Removing WiseNut plugin.


Deleted: trunk/IndexSearch/Plugins/WiseNut.src
===================================================================
--- trunk/IndexSearch/Plugins/WiseNut.src	2007-12-19 12:39:39 UTC (rev 1146)
+++ trunk/IndexSearch/Plugins/WiseNut.src	2007-12-19 12:41:48 UTC (rev 1147)
@@ -1,23 +0,0 @@
-# WiseNut Search Plugin
-
-<SEARCH
-	version="1.0"
-	name="WiseNut"
-	description="WiseNut.com"
-	method="GET"
-	action="http://www.wisenut.com/search/query.dll"
-	routeType="The Web"
->
-
-<INPUT NAME="q" USER>
-<INPUT NAME="c" VALUE="10">
-<INPUTNEXT NAME="p" FACTOR="1">
-
-<INTERPRET
-resultListStart=""
-resultListEnd=""
-resultItemStart="<TD class=m1> <b>"
-resultItemEnd="</TD></TR>"
->
-
-</SEARCH>



From fabricecolin at mail.berlios.de  Wed Dec 19 13:46:37 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 19 Dec 2007 13:46:37 +0100
Subject: [Pinot-svn] r1148 - trunk
Message-ID: <200712191246.lBJCkbEo010816@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-19 13:46:37 +0100 (Wed, 19 Dec 2007)
New Revision: 1148

Modified:
   trunk/README
   trunk/TODO
   trunk/pinot.spec.in
Log:
Gtkmm 2.10 is needed. Updated TODO list. Spec file installs new Xapian module.


Modified: trunk/README
===================================================================
--- trunk/README	2007-12-19 12:41:48 UTC (rev 1147)
+++ trunk/README	2007-12-19 12:46:37 UTC (rev 1148)
@@ -462,7 +462,7 @@
  gSOAP (2)						2.7.9e
  http://www.cs.fsu.edu/~engelen/soap.html
 
-gtkmm							2.6.2
+gtkmm							2.10
 http://www.gtkmm.org/
 
 libxml++						2.12.0

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2007-12-19 12:41:48 UTC (rev 1147)
+++ trunk/TODO	2007-12-19 12:46:37 UTC (rev 1148)
@@ -13,7 +13,6 @@
 - Advertise service via Rendezvous
 - Extend metadata beyond title,location,language,type,timestamp,size
 - Don't package gmo files, they are platform dependent
-- Check for http_proxy and such in the environment and initialize Network params
 
 Deskbar
 - Update to a module
@@ -23,6 +22,7 @@
 - PDF filter with poppler
 - WordPerfect filter with libwpd
 - Office filter with libgst
+- TeX filter
 - Check whether pdftotext flattens text in PDF documents that have columns
 - HtmlFilter should skip htdig_noindex blocks (http://www.htdig.org/attrs.html#noindex_start)
 - HtmlFilter to look for META tags Author, Creator, Publisher and CreationDate
@@ -70,6 +70,7 @@
 - After indexing or updating a document, a call to getDocumentInfo() shouldn't be necessary
 - Labels and the rest of DocumentInfo are handled separately, they shouldn't be
 - Indexes have no knowledge of indexId's
+- Classify files (images, videos, etc...)
 
 Mail
 - Find out what kind of locking scheme Mozilla uses (POSIX lock ?) and use that
@@ -89,9 +90,8 @@
 - Export term suggestion over D-Bus
 - There's currently no easy way to get a document's ID without running a search
 - Follow updates to Xesam specs
-- Suspend indexing on battery use (/proc/acpi/ac_adapter/AC/state, AC0/state,
- ADp1/state or ACAD/state)
 - Preserve user set metadata on reindexing
+- Generate warning if we run out of inotify watch
 
 UI
 - Show which threads are running, what they are doing, and allow to stop them
@@ -115,6 +115,5 @@
 - Let queries index only new results
 - Query expansion should be interactive
 - Default cache provider should be configurable
-- Keep warning about the old index version until silenced by the user, or until
- documents are updated
+- Reload documents info after importing them into the My Web Pages index
 

Modified: trunk/pinot.spec.in
===================================================================
--- trunk/pinot.spec.in	2007-12-19 12:41:48 UTC (rev 1147)
+++ trunk/pinot.spec.in	2007-12-19 12:46:37 UTC (rev 1148)
@@ -44,7 +44,6 @@
 for changes, as well as a GTK-based user interface that enables to query
 the index built by the service and your favourite Web engines, and display and
 analyze the results.
-A plugin for DeskbarApplet is included.
 
 %package deskbar
 Summary: Pinot plugin for DeskbarApplet
@@ -94,6 +93,7 @@
 %{_libdir}/pinot/filters/libexternalfilter.so*
 %{_libdir}/pinot/filters/libmboxfilter.so*
 %{_libdir}/pinot/filters/libtaglibfilter.so*
+%{_libdir}/pinot/modules/libxapianmodule.so*
 %{_datadir}/dbus-1/services/de.berlios.Pinot.service
 %{_datadir}/pinot/
 %{_datadir}/icons/hicolor/48x48/apps/pinot.png



From fabricecolin at mail.berlios.de  Wed Dec 19 13:49:27 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 19 Dec 2007 13:49:27 +0100
Subject: [Pinot-svn] r1149 - in trunk: . IndexSearch
Message-ID: <200712191249.lBJCnRal010935@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-19 13:49:27 +0100 (Wed, 19 Dec 2007)
New Revision: 1149

Modified:
   trunk/AUTHORS
   trunk/IndexSearch/SherlockParser.cpp
Log:
The user input item, if not all lower case, wasn't removed from the input items
list and would thus appear twice in the URL.
This issue was reported by Claudio Bustos Navarrete.


Modified: trunk/AUTHORS
===================================================================
--- trunk/AUTHORS	2007-12-19 12:46:37 UTC (rev 1148)
+++ trunk/AUTHORS	2007-12-19 12:49:27 UTC (rev 1149)
@@ -19,6 +19,7 @@
 	Lee Marks <ana_cata_hylo at yahoo dot com>
 	Adel Gadllah <adel dot gadllah at gmail dot com>
 	Andreas Wagner <A dot Wagner at stud dot uni-frankfurt dot de>
+	Claudio Bustos Navarrete <clbustos at surnet dot cl>
 
 The file Monitor/linux-inotify-syscalls.h is originally from libinotify
 (Copyright ? 2005 Ryan Lortie <desrt at desrt dot ca>).

Modified: trunk/IndexSearch/SherlockParser.cpp
===================================================================
--- trunk/IndexSearch/SherlockParser.cpp	2007-12-19 12:46:37 UTC (rev 1148)
+++ trunk/IndexSearch/SherlockParser.cpp	2007-12-19 12:49:27 UTC (rev 1149)
@@ -612,14 +612,19 @@
 		{
 			if (userInput.empty() == false)
 			{
+				string lowUserInput(StringManip::toLowerCase(userInput));
+
 				// Remove the user input tag from the input tags map
-				mapIter = lowInputItems.find(userInput);
+				mapIter = lowInputItems.find(lowUserInput);
 				if (mapIter != lowInputItems.end())
 				{
 					lowInputItems.erase(mapIter);
 				}
+#ifdef DEBUG
+				else cout << "SherlockParser::parse: couldn't remove user input item" << endl;
+#endif
 
-				properties.m_parameters[SearchPluginProperties::SEARCH_TERMS_PARAM] = userInput;
+				properties.m_parameters[SearchPluginProperties::SEARCH_TERMS_PARAM] = lowUserInput;
 			}
 			for (map<string, string>::iterator iter = lowInputItems.begin();
 				iter != lowInputItems.end(); ++iter)
@@ -632,6 +637,9 @@
 				properties.m_parametersRemainder += iter->first;
 				properties.m_parametersRemainder += "=";
 				properties.m_parametersRemainder += iter->second;
+#ifdef DEBUG
+				cout << "SherlockParser::parse: input item " << iter->first << endl;
+#endif
 			}
 
 			// URL



From fabricecolin at mail.berlios.de  Sat Dec 22 18:21:17 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 22 Dec 2007 18:21:17 +0100
Subject: [Pinot-svn] r1150 - trunk/IndexSearch
Message-ID: <200712221721.lBMHLHob014115@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-22 18:21:14 +0100 (Sat, 22 Dec 2007)
New Revision: 1150

Modified:
   trunk/IndexSearch/ModuleFactory.cpp
Log:
Disable sherlock if HAVE_BOOST_SPIRIT is not defined.


Modified: trunk/IndexSearch/ModuleFactory.cpp
===================================================================
--- trunk/IndexSearch/ModuleFactory.cpp	2007-12-19 12:49:27 UTC (rev 1149)
+++ trunk/IndexSearch/ModuleFactory.cpp	2007-12-22 17:21:14 UTC (rev 1150)
@@ -329,7 +329,10 @@
 	SearchEngineInterface *pEngine = NULL;
 
 	// Choice by type
-	if ((type == "sherlock") ||
+	if (
+#ifdef HAVE_BOOST_SPIRIT
+		(type == "sherlock") ||
+#endif
 		(type == "opensearch"))
 	{
 		pEngine = new PluginWebEngine(option);
@@ -351,7 +354,10 @@
 
 string ModuleFactory::getSearchEngineName(const string &type, const string &option)
 {
-	if ((type == "sherlock") ||
+	if (
+#ifdef HAVE_BOOST_SPIRIT
+		(type == "sherlock") ||
+#endif
 		(type == "opensearch"))
 	{
 		string name, channel;
@@ -376,7 +382,9 @@
 	engines.clear();
 
 	// Built-in engines
+#ifdef HAVE_BOOST_SPIRIT
 	engines.insert("sherlock");
+#endif
 	engines.insert("opensearch");
 #ifdef HAVE_GOOGLEAPI
 	engines.insert("googleapi");
@@ -395,7 +403,10 @@
 #ifdef HAVE_GOOGLEAPI
 		(type == "googleapi") ||
 #endif
+#ifdef HAVE_BOOST_SPIRIT
 		(type == "sherlock") ||
+#endif
+		(type == "opensearch") ||
 		(m_types.find(type) != m_types.end()))
 	{
 		return true;



From fabricecolin at mail.berlios.de  Sat Dec 22 18:23:20 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 22 Dec 2007 18:23:20 +0100
Subject: [Pinot-svn] r1151 - trunk/UI/GTK2/src
Message-ID: <200712221723.lBMHNK0U014344@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-22 18:23:20 +0100 (Sat, 22 Dec 2007)
New Revision: 1151

Modified:
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/ServerThreads.cpp
   trunk/UI/GTK2/src/statisticsDialog.cc
   trunk/UI/GTK2/src/statisticsDialog.hh
Log:
Save and load queries' modified flag.
The status window now shows which engines are available. Some other minor mod.


Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2007-12-22 17:21:14 UTC (rev 1150)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2007-12-22 17:23:20 UTC (rev 1151)
@@ -873,6 +873,13 @@
 		{
 			queryProps.setLabelName(nodeContent);
 		}
+		else if (nodeName == "modified")
+		{
+			if (nodeContent == "YES")
+			{
+				queryProps.setModified(true);
+			}
+		}
 	}
 
 	// Are pre-0.80 dates specified ?
@@ -1360,6 +1367,7 @@
 			addChildElement(pElem, "maxresults", numStr);
 			addChildElement(pElem, "index", (queryIter->second.getIndexResults() ? "ALL" : "NONE"));
 			addChildElement(pElem, "label", queryIter->second.getLabelName());
+			addChildElement(pElem, "modified", (queryIter->second.getModified() ? "YES" : "NO"));
 		}
 		// Labels
 		for (set<string>::iterator labelIter = m_labels.begin(); labelIter != m_labels.end(); ++labelIter)

Modified: trunk/UI/GTK2/src/ServerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/ServerThreads.cpp	2007-12-22 17:21:14 UTC (rev 1150)
+++ trunk/UI/GTK2/src/ServerThreads.cpp	2007-12-22 17:23:20 UTC (rev 1151)
@@ -269,11 +269,11 @@
 
 	if (entryStatus == -1)
 	{
+		entryStatus = errno;
+		scanSuccess = false;
 #ifdef DEBUG
-		cout << "DirectoryScannerThread::scanEntry: stat failed with error " << errno << endl;
+		cout << "DirectoryScannerThread::scanEntry: stat failed with error " << entryStatus << endl;
 #endif
-		entryStatus = errno;
-		scanSuccess = false;
 	}
 	// Is it a file or a directory ?
 	else if (S_ISLNK(fileStat.st_mode))
@@ -364,11 +364,11 @@
 			}
 			else
 			{
+				entryStatus = errno;
+				scanSuccess = false;
 #ifdef DEBUG
-				cout << "DirectoryScannerThread::scanEntry: opendir failed with error " << errno << endl;
+				cout << "DirectoryScannerThread::scanEntry: opendir failed with error " << entryStatus << endl;
 #endif
-				entryStatus = errno;
-				scanSuccess = false;
 			}
 		}
 	}

Modified: trunk/UI/GTK2/src/statisticsDialog.cc
===================================================================
--- trunk/UI/GTK2/src/statisticsDialog.cc	2007-12-22 17:21:14 UTC (rev 1150)
+++ trunk/UI/GTK2/src/statisticsDialog.cc	2007-12-22 17:23:20 UTC (rev 1151)
@@ -29,6 +29,7 @@
 #include "Url.h"
 #include "CrawlHistory.h"
 #include "ViewHistory.h"
+#include "ModuleFactory.h"
 #include "PinotSettings.h"
 #include "PinotUtils.h"
 #include "WorkerThreads.h"
@@ -69,33 +70,50 @@
 {
 	TreeModel::iterator folderIter = m_refStore->append();
 	TreeModel::Row row = *folderIter;
+	set<string> engines;
+
+	// Indexes
+	statisticsTreeview->get_selection()->select(folderIter);
 	row[m_statsColumns.m_name] = _("Indexes");
-	statisticsTreeview->get_selection()->select(folderIter);
-
 	TreeModel::iterator statIter = m_refStore->append(folderIter->children());
 	row = *statIter;
 	row[m_statsColumns.m_name] = _("My Web Pages");
 	m_myWebPagesIter = m_refStore->append(statIter->children());
-
 	statIter = m_refStore->append(folderIter->children());
 	row = *statIter;
 	row[m_statsColumns.m_name] = _("My Documents");
 	m_myDocumentsIter = m_refStore->append(statIter->children());
 
+	// Search engines
+	TreeModel::iterator enginesIter = m_refStore->append();
+	row = *enginesIter;
+	row[m_statsColumns.m_name] = _("Search Engines");
+	ModuleFactory::getSupportedEngines(engines);
+	for (set<string>::const_iterator engineIter = engines.begin();
+		engineIter != engines.end(); ++engineIter)
+	{
+		TreeModel::iterator statIter = m_refStore->append(enginesIter->children());
+		row = *statIter;
+		row[m_statsColumns.m_name] = *engineIter;
+	}
+
+	// History
 	folderIter = m_refStore->append();
 	row = *folderIter;
 	row[m_statsColumns.m_name] = _("History");
 	m_viewStatIter = m_refStore->append(folderIter->children());
+	m_crawledStatIter = m_refStore->append(folderIter->children());
 
+	// Daemon
 	m_daemonIter = m_refStore->append();
 	row = *m_daemonIter;
 	row[m_statsColumns.m_name] = _("Daemon");
-	m_daemonStatIter = m_refStore->append(m_daemonIter->children());
+	m_daemonProcIter = m_refStore->append(m_daemonIter->children());
 
-	m_crawledStatIter = m_refStore->append(folderIter->children());
-
 	// Expand everything
 	statisticsTreeview->expand_all();
+	TreeModel::Path enginesPath = m_refStore->get_path(enginesIter);
+	statisticsTreeview->collapse_row(enginesPath);
 
 	Adjustment *pAdjustement = statisticsScrolledwindow->get_hadjustment();
 #ifdef DEBUG
@@ -155,6 +173,12 @@
 	row = *m_viewStatIter;
 	row[m_statsColumns.m_name] = ustring(_("Viewed")) + " " + countStr + " " + _("results");
 
+	// Show crawler statistics
+	unsigned int crawledFilesCount = crawlerHistory.getItemsCount(CrawlHistory::CRAWLED);
+	snprintf(countStr, 64, "%u", crawledFilesCount);
+	row = *m_crawledStatIter;
+	row[m_statsColumns.m_name] = ustring(_("Crawled")) + " " + countStr + " " + _("files");
+
 	// Is the daemon still running ?
 	string pidFileName(PinotSettings::getInstance().getConfigurationDirectory() + "/pinot-dbus-daemon.pid");
 	pid_t daemonPID = 0;
@@ -166,7 +190,7 @@
 		pidFile.close();
 	}
 	snprintf(countStr, 64, "%u", daemonPID);
-	row = *m_daemonStatIter;
+	row = *m_daemonProcIter;
 	if (daemonPID > 0)
 	{
 		// FIXME: check whether it's actually running !
@@ -177,12 +201,6 @@
 		row[m_statsColumns.m_name] = ustring(_("Currently not running"));
 	}
 
-	// Show crawler statistics
-	unsigned int crawledFilesCount = crawlerHistory.getItemsCount(CrawlHistory::CRAWLED);
-	snprintf(countStr, 64, "%u", crawledFilesCount);
-	row = *m_crawledStatIter;
-	row[m_statsColumns.m_name] = ustring(_("Crawled")) + " " + countStr + " " + _("files");
-
 	// Show errors
 	crawlerHistory.getSources(sources);
 	for (std::map<unsigned int, string>::iterator sourceIter = sources.begin();

Modified: trunk/UI/GTK2/src/statisticsDialog.hh
===================================================================
--- trunk/UI/GTK2/src/statisticsDialog.hh	2007-12-22 17:21:14 UTC (rev 1150)
+++ trunk/UI/GTK2/src/statisticsDialog.hh	2007-12-22 17:23:20 UTC (rev 1151)
@@ -41,7 +41,7 @@
 	Gtk::TreeModel::iterator m_myDocumentsIter;
 	Gtk::TreeModel::iterator m_viewStatIter;
 	Gtk::TreeModel::iterator m_daemonIter;
-	Gtk::TreeModel::iterator m_daemonStatIter;
+	Gtk::TreeModel::iterator m_daemonProcIter;
 	Gtk::TreeModel::iterator m_crawledStatIter;
 	Gtk::TreeModel::iterator m_errorsTopIter;
 	std::map<int, Gtk::TreeModel::iterator> m_errorsIters;



From fabricecolin at mail.berlios.de  Sun Dec 30 23:16:37 2007
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sun, 30 Dec 2007 23:16:37 +0100
Subject: [Pinot-svn] r1152 - trunk/IndexSearch/Xapian
Message-ID: <200712302216.lBUMGbPO008622@sheep.berlios.de>

Author: fabricecolin
Date: 2007-12-30 23:16:37 +0100 (Sun, 30 Dec 2007)
New Revision: 1152

Modified:
   trunk/IndexSearch/Xapian/AbstractGenerator.cpp
   trunk/IndexSearch/Xapian/XapianEngine.cpp
Log:
Fixed query stemming. We should have used STEM_SOME at least since moving to
Xapian 1.0.
Ignore spelling suggestions if the query returned results.
Ignore prefixed terms when seeding the abstracts generator. The latter doesn't
mind if there are no seed terms.
Ignore stems in query expansion.


Modified: trunk/IndexSearch/Xapian/AbstractGenerator.cpp
===================================================================
--- trunk/IndexSearch/Xapian/AbstractGenerator.cpp	2007-12-22 17:23:20 UTC (rev 1151)
+++ trunk/IndexSearch/Xapian/AbstractGenerator.cpp	2007-12-30 22:16:37 UTC (rev 1152)
@@ -71,8 +71,7 @@
 	unsigned int seedTermsCount = 0, bestWeight = 0;
 	bool topTerm = true;
 
-	if ((m_pIndex == NULL) ||
-		(seedTerms.empty() == true))
+	if (m_pIndex == NULL)
 	{
 		return "";
 	}

Modified: trunk/IndexSearch/Xapian/XapianEngine.cpp
===================================================================
--- trunk/IndexSearch/Xapian/XapianEngine.cpp	2007-12-22 17:23:20 UTC (rev 1151)
+++ trunk/IndexSearch/Xapian/XapianEngine.cpp	2007-12-30 22:16:37 UTC (rev 1152)
@@ -179,10 +179,19 @@
 	unsigned int minDay, minMonth, minYear = 0;
 	unsigned int maxDay, maxMonth, maxYear = 0;
 
+	if (pIndex != NULL)
+	{
+		// The database is required for wildcards and spelling
+		parser.set_database(*pIndex);
+	}
+
 	// Set things up
 	if ((minimal == false) &&
 		(stemLanguage.empty() == false))
 	{
+#ifdef DEBUG
+		cout << "XapianEngine::parseQuery: " << stemLanguage << " stemming" << endl;
+#endif
 		try
 		{
 			stemmer = Xapian::Stem(StringManip::toLowerCase(stemLanguage));
@@ -191,11 +200,14 @@
 		{
 			cerr << "Couldn't create stemmer: " << error.get_type() << ": " << error.get_msg() << endl;
 		}
-		parser.set_stemming_strategy(Xapian::QueryParser::STEM_ALL);
 		parser.set_stemmer(stemmer);
+		parser.set_stemming_strategy(Xapian::QueryParser::STEM_SOME);
 	}
 	else
 	{
+#ifdef DEBUG
+		cout << "XapianEngine::parseQuery: no stemming" << endl;
+#endif
 		parser.set_stemming_strategy(Xapian::QueryParser::STEM_NONE);
 	}
 	// What's the default operator ?
@@ -207,11 +219,6 @@
 	{
 		parser.set_default_op(Xapian::Query::OP_OR);
 	}
-	if (pIndex != NULL)
-	{
-		// The database is required for wildcards and spelling
-		parser.set_database(*pIndex);
-	}
 	// X prefixes should always include a colon
 	parser.add_boolean_prefix("site", "H");
 	parser.add_boolean_prefix("file", "P");
@@ -364,6 +371,9 @@
 	{
 		return parsedQuery;
 	}
+#ifdef DEBUG
+	cout << "XapianEngine::parseQuery: " << parsedQuery.get_description() << endl;
+#endif
 
 #if ENABLE_XAPIAN_SPELLING_CORRECTION>0
 	// Any correction ?
@@ -401,9 +411,6 @@
 		vector<string> seedTerms;
 
 		// Give the query object to the enquire session
-#ifdef DEBUG
-		cout << "XapianEngine::queryDatabase: enquiring about " << query.get_description() << endl;
-#endif
 		enquire.set_query(query);
 		// How should results be sorted ?
 		if (queryProps.getSortOrder() == QueryProperties::RELEVANCE)
@@ -446,7 +453,15 @@
 				for (Xapian::TermIterator termIter = enquire.get_matching_terms_begin(docId);
 					termIter != enquire.get_matching_terms_end(docId); ++termIter)
 				{
-					seedTerms.push_back(*termIter);
+					char firstChar = (*termIter)[0];
+
+					if (isupper(((int)firstChar)) == 0)
+					{
+						seedTerms.push_back(*termIter);
+#ifdef DEBUG
+						cout << "XapianEngine::queryDatabase: matched term " << *termIter << endl;
+#endif
+					}
 				}
 
 				DocumentInfo thisResult;
@@ -511,7 +526,7 @@
 #endif
 
 			// Get 10 non-prefixed terms
-			string allowedPrefixes("RSZ");
+			string allowedPrefixes("RS");
 			PrefixDecider expandDecider(allowedPrefixes);
 			Xapian::ESet expandTerms = enquire.get_eset(20, expandDocs, &expandDecider);
 #ifdef DEBUG
@@ -634,7 +649,7 @@
 	Xapian::Database *pIndex = pDatabase->readLock();
 	try
 	{
-		string stemLanguage(queryProps.getFilter("lang"));
+		string stemLanguage(Languages::toEnglish(queryProps.getStemmingLanguage()));
 		unsigned int searchStep = 1;
 
 		// Searches are run in this order :
@@ -650,19 +665,26 @@
 				break;
 			}
 
-			// The search did succeed but didn't return anything
-			if ((m_resultsList.empty() == true) &&
-				(searchStep == 1) &&
-				(stemLanguage.empty() == false))
+			if (m_resultsList.empty() == true)
 			{
+				// The search did succeed but didn't return anything
+				if ((searchStep == 1) &&
+					(stemLanguage.empty() == false))
+				{
 #ifdef DEBUG
-				cout << "XapianEngine::runQuery: trying again with stemming" << endl;
+					cout << "XapianEngine::runQuery: trying again with stemming" << endl;
 #endif
-				fullQuery = parseQuery(pIndex, queryProps, Languages::toEnglish(stemLanguage),
-					m_defaultOperator, m_limitQuery, m_correctedFreeQuery);
-				++searchStep;
-				continue;
+					fullQuery = parseQuery(pIndex, queryProps, stemLanguage,
+						m_defaultOperator, m_limitQuery, m_correctedFreeQuery);
+					++searchStep;
+					continue;
+				}
 			}
+			else
+			{
+				// We have results, don't bother about correcting the query
+				m_correctedFreeQuery.clear();
+			}
 
 			pDatabase->unlock();
 			return true;



