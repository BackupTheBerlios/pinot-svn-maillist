<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Pinot-svn] r1133 - in trunk: . Index IndexSearch	IndexSearch/Xapian Search
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/pinot-svn/2007-December/index.html" >
   <LINK REL="made" HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r1133%20-%20in%20trunk%3A%20.%20Index%20IndexSearch%0A%09IndexSearch/Xapian%20Search&In-Reply-To=%3C200712010925.lB19PvFA026934%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="001130.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Pinot-svn] r1133 - in trunk: . Index IndexSearch	IndexSearch/Xapian Search</H1>
    <B>fabricecolin at BerliOS</B> 
    <A HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r1133%20-%20in%20trunk%3A%20.%20Index%20IndexSearch%0A%09IndexSearch/Xapian%20Search&In-Reply-To=%3C200712010925.lB19PvFA026934%40sheep.berlios.de%3E"
       TITLE="[Pinot-svn] r1133 - in trunk: . Index IndexSearch	IndexSearch/Xapian Search">fabricecolin at mail.berlios.de
       </A><BR>
    <I>Sat Dec  1 10:25:57 CET 2007</I>
    <P><UL>
        
        <LI>Next message: <A HREF="001130.html">[Pinot-svn] r1134 - in trunk/IndexSearch: . Xapian
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1129">[ date ]</a>
              <a href="thread.html#1129">[ thread ]</a>
              <a href="subject.html#1129">[ subject ]</a>
              <a href="author.html#1129">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fabricecolin
Date: 2007-12-01 10:25:54 +0100 (Sat, 01 Dec 2007)
New Revision: 1133

Added:
   trunk/IndexSearch/
   trunk/IndexSearch/DBusXapianIndex.cpp
   trunk/IndexSearch/DBusXapianIndex.h
   trunk/IndexSearch/FilterWrapper.cpp
   trunk/IndexSearch/FilterWrapper.h
   trunk/IndexSearch/Google/
   trunk/IndexSearch/IndexFactory.cpp
   trunk/IndexSearch/IndexFactory.h
   trunk/IndexSearch/IndexInterface.h
   trunk/IndexSearch/OpenSearchParser.cpp
   trunk/IndexSearch/OpenSearchParser.h
   trunk/IndexSearch/PluginParsers.h
   trunk/IndexSearch/PluginWebEngine.cpp
   trunk/IndexSearch/PluginWebEngine.h
   trunk/IndexSearch/Plugins/
   trunk/IndexSearch/QueryProperties.cpp
   trunk/IndexSearch/QueryProperties.h
   trunk/IndexSearch/ResultsExporter.cpp
   trunk/IndexSearch/ResultsExporter.h
   trunk/IndexSearch/SOAPEnv.h
   trunk/IndexSearch/SOAPEnvH.h
   trunk/IndexSearch/SOAPEnvNS.cpp
   trunk/IndexSearch/SOAPEnvStub.h
   trunk/IndexSearch/SearchEngineFactory.cpp
   trunk/IndexSearch/SearchEngineFactory.h
   trunk/IndexSearch/SearchEngineInterface.cpp
   trunk/IndexSearch/SearchEngineInterface.h
   trunk/IndexSearch/SearchPluginProperties.cpp
   trunk/IndexSearch/SearchPluginProperties.h
   trunk/IndexSearch/SherlockParser.cpp
   trunk/IndexSearch/SherlockParser.h
   trunk/IndexSearch/WebEngine.cpp
   trunk/IndexSearch/WebEngine.h
   trunk/IndexSearch/Xapian/
   trunk/IndexSearch/Xapian/AbstractGenerator.cpp
   trunk/IndexSearch/Xapian/AbstractGenerator.h
   trunk/IndexSearch/Xapian/LanguageDetector.cpp
   trunk/IndexSearch/Xapian/LanguageDetector.h
   trunk/IndexSearch/Xapian/XapianDatabase.cpp
   trunk/IndexSearch/Xapian/XapianDatabase.h
   trunk/IndexSearch/Xapian/XapianDatabaseFactory.cpp
   trunk/IndexSearch/Xapian/XapianDatabaseFactory.h
   trunk/IndexSearch/Xapian/XapianEngine.cpp
   trunk/IndexSearch/Xapian/XapianEngine.h
   trunk/IndexSearch/Xapian/XapianIndex.cpp
   trunk/IndexSearch/Xapian/XapianIndex.h
   trunk/IndexSearch/pinot-index.1
   trunk/IndexSearch/pinot-index.cpp
   trunk/IndexSearch/pinot-label.1
   trunk/IndexSearch/pinot-label.cpp
   trunk/IndexSearch/pinot-search.1
   trunk/IndexSearch/pinot-search.cpp
Removed:
   trunk/Index/DBusXapianIndex.cpp
   trunk/Index/DBusXapianIndex.h
   trunk/Index/FilterWrapper.cpp
   trunk/Index/FilterWrapper.h
   trunk/Index/IndexFactory.cpp
   trunk/Index/IndexFactory.h
   trunk/Index/IndexInterface.h
   trunk/Index/LanguageDetector.cpp
   trunk/Index/LanguageDetector.h
   trunk/Index/XapianDatabase.cpp
   trunk/Index/XapianDatabase.h
   trunk/Index/XapianDatabaseFactory.cpp
   trunk/Index/XapianDatabaseFactory.h
   trunk/Index/XapianIndex.cpp
   trunk/Index/XapianIndex.h
   trunk/Index/pinot-index.1
   trunk/Index/pinot-index.cpp
   trunk/Index/pinot-label.1
   trunk/Index/pinot-label.cpp
   trunk/Search/AbstractGenerator.cpp
   trunk/Search/AbstractGenerator.h
   trunk/Search/Google/
   trunk/Search/OpenSearchParser.cpp
   trunk/Search/OpenSearchParser.h
   trunk/Search/PluginParsers.h
   trunk/Search/PluginWebEngine.cpp
   trunk/Search/PluginWebEngine.h
   trunk/Search/Plugins/
   trunk/Search/QueryProperties.cpp
   trunk/Search/QueryProperties.h
   trunk/Search/ResultsExporter.cpp
   trunk/Search/ResultsExporter.h
   trunk/Search/SOAPEnv.h
   trunk/Search/SOAPEnvH.h
   trunk/Search/SOAPEnvNS.cpp
   trunk/Search/SOAPEnvStub.h
   trunk/Search/SearchEngineFactory.cpp
   trunk/Search/SearchEngineFactory.h
   trunk/Search/SearchEngineInterface.cpp
   trunk/Search/SearchEngineInterface.h
   trunk/Search/SearchPluginProperties.cpp
   trunk/Search/SearchPluginProperties.h
   trunk/Search/SherlockParser.cpp
   trunk/Search/SherlockParser.h
   trunk/Search/WebEngine.cpp
   trunk/Search/WebEngine.h
   trunk/Search/XapianEngine.cpp
   trunk/Search/XapianEngine.h
   trunk/Search/pinot-search.1
   trunk/Search/pinot-search.cpp
Log:
Moved index and search code under IndexSearch, with anything depending on
Xapian in IndexSearch/Xapian.


Deleted: trunk/Index/DBusXapianIndex.cpp
===================================================================
--- trunk/Index/DBusXapianIndex.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/DBusXapianIndex.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,990 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;iostream&gt;
-
-#include &quot;Languages.h&quot;
-#include &quot;XapianDatabaseFactory.h&quot;
-#include &quot;DBusXapianIndex.h&quot;
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-using std::set;
-using std::map;
-using std::min;
-
-const char *g_fieldNames[] = { &quot;caption&quot;, &quot;url&quot;, &quot;type&quot;, &quot;language&quot;, &quot;modtime&quot;, &quot;size&quot;, NULL };
-
-static DBusGConnection *getBusConnection(void)
-{
-	GError *pError = NULL;
-	DBusGConnection *pBus = NULL;
-
-	pBus = dbus_g_bus_get(DBUS_BUS_SESSION, &amp;pError);
-	if (pBus == NULL)
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;DBusXapianIndex: couldn't connect to session bus: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			g_error_free(pError);
-		}
-	}
-
-	return pBus;
-}
-
-static DBusGProxy *getBusProxy(DBusGConnection *pBus)
-{
-	if (pBus == NULL)
-	{
-		return NULL;
-	}
-
-	return dbus_g_proxy_new_for_name(pBus,
-		&quot;de.berlios.Pinot&quot;, &quot;/de/berlios/Pinot&quot;, &quot;de.berlios.Pinot&quot;);
-}
-
-DBusXapianIndex::DBusXapianIndex(const string &amp;indexName) :
-	XapianIndex(indexName)
-{
-}
-
-DBusXapianIndex::DBusXapianIndex(const DBusXapianIndex &amp;other) :
-	XapianIndex(other)
-{
-}
-
-DBusXapianIndex::~DBusXapianIndex()
-{
-}
-
-DBusXapianIndex &amp;DBusXapianIndex::operator=(const DBusXapianIndex &amp;other)
-{
-	if (this != &amp;other)
-	{
-		XapianIndex::operator=(other);
-	}
-
-	return *this;
-}
-
-void DBusXapianIndex::reopen(void) const
-{
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase != NULL)
-	{
-		// Re-open the database to the latest available version
-		pDatabase-&gt;reopen();
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusXapianIndex::reopen: done&quot; &lt;&lt; endl;
-#endif
-	}
-}
-
-/// Extracts docId and docInfo from a dbus message.
-bool DBusXapianIndex::documentInfoFromDBus(DBusMessageIter *iter, unsigned int &amp;docId,
-	DocumentInfo &amp;docInfo)
-{
-	DBusMessageIter array_iter;
-	DBusMessageIter struct_iter;
-
-	if (iter == NULL)
-	{
-		return false;
-	}
-
-	int type = dbus_message_iter_get_arg_type(iter);
-	if (type != DBUS_TYPE_UINT32)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusXapianIndex::documentInfoFromDBus: expected unsigned integer, got &quot; &lt;&lt; type &lt;&lt; endl;
-#endif
-		return false;
-	}
-	dbus_message_iter_get_basic(iter, &amp;docId);
-	dbus_message_iter_next(iter);
-	
-	type = dbus_message_iter_get_arg_type(iter);
-	if (type != DBUS_TYPE_ARRAY)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusXapianIndex::documentInfoFromDBus: expected array, got &quot; &lt;&lt; type &lt;&lt; endl;
-#endif
-		return false;
-	}
-	dbus_message_iter_recurse(iter, &amp;array_iter);
-
-	do
-	{
-		const gchar *pName = NULL;
-		const gchar *pValue = NULL;
-
-		type = dbus_message_iter_get_arg_type(&amp;array_iter);
-		if (type != DBUS_TYPE_STRUCT)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusXapianIndex::documentInfoFromDBus: expected struct, got &quot; &lt;&lt; type &lt;&lt; endl;
-#endif
-			return false;
-		}
-
-		dbus_message_iter_recurse(&amp;array_iter, &amp;struct_iter);
-		dbus_message_iter_get_basic(&amp;struct_iter, &amp;pName);
-		if (pName == NULL)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusXapianIndex::documentInfoFromDBus: invalid field name&quot; &lt;&lt; endl;
-#endif
-		}
-
-		dbus_message_iter_next(&amp;struct_iter);
-		dbus_message_iter_get_basic(&amp;struct_iter, &amp;pValue);
-		if (pValue == NULL)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusXapianIndex::documentInfoFromDBus: invalid field value&quot; &lt;&lt; endl;
-#endif
-			continue;
-		}
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusXapianIndex::documentInfoFromDBus: field &quot; &lt;&lt; pName &lt;&lt; &quot;=&quot; &lt;&lt; pValue &lt;&lt; endl;
-#endif
-
-		// Populate docInfo
-		string fieldName(pName);
-		if (fieldName == g_fieldNames[0])
-		{
-			docInfo.setTitle(pValue);
-		}
-		else if (fieldName == g_fieldNames[1])
-		{
-			docInfo.setLocation(pValue);
-		}
-		else if (fieldName == g_fieldNames[2])
-		{
-			docInfo.setType(pValue);
-		}
-		else if (fieldName == g_fieldNames[3])
-		{
-			docInfo.setLanguage(Languages::toLocale(pValue));
-		}
-		else if (fieldName == g_fieldNames[4])
-		{
-			docInfo.setTimestamp(pValue);
-		}
-		else if (fieldName == g_fieldNames[5])
-		{
-			docInfo.setSize((off_t )atoi(pValue));
-		}
-	}
-	while (dbus_message_iter_next(&amp;array_iter));
-
-	return true;
-}
-
-/// Converts docId and docInfo to a dbus message.
-bool DBusXapianIndex::documentInfoToDBus(DBusMessageIter *iter, unsigned int docId,
-	const DocumentInfo &amp;docInfo)
-{
-        DBusMessageIter array_iter;
-	DBusMessageIter struct_iter;
-
-	if (iter == NULL)
-	{
-		return false;
-	}
-
-	// Append the document ID ?
-	if (docId != 0)
-	{
-		dbus_message_iter_append_basic(iter, DBUS_TYPE_UINT32, &amp;docId);
-	}
-	if (!dbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,
-		DBUS_STRUCT_BEGIN_CHAR_AS_STRING \
-		DBUS_TYPE_STRING_AS_STRING \
-		DBUS_TYPE_STRING_AS_STRING \
-		DBUS_STRUCT_END_CHAR_AS_STRING, &amp;array_iter))
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusXapianIndex::documentInfoToDBus: couldn't open array container&quot; &lt;&lt; endl;
-#endif
-		return false;
-	}
-
-	for (unsigned int fieldNum = 0; g_fieldNames[fieldNum] != NULL; ++fieldNum)
-	{
-		const char *pValue = NULL;
-		char sizeStr[64];
-
-		if (!dbus_message_iter_open_container(&amp;array_iter,
-			DBUS_TYPE_STRUCT, NULL, &amp;struct_iter))
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusXapianIndex::documentInfoToDBus: couldn't open struct container&quot; &lt;&lt; endl;
-#endif
-			return false;
-		}
-
-		dbus_message_iter_append_basic(&amp;struct_iter, DBUS_TYPE_STRING, &amp;g_fieldNames[fieldNum]);
-		switch (fieldNum)
-		{
-			case 0:
-				pValue = docInfo.getTitle().c_str();
-				break;
-			case 1:
-				pValue = docInfo.getLocation().c_str();
-				break;
-			case 2:
-				pValue = docInfo.getType().c_str();
-				break;
-			case 3:
-				pValue = Languages::toEnglish(docInfo.getLanguage()).c_str();
-				break;
-			case 4:
-				pValue = docInfo.getTimestamp().c_str();
-				break;
-			case 5:
-			default:
-				snprintf(sizeStr, 64, &quot;%u&quot;, docInfo.getSize());
-				pValue = sizeStr;
-				break;
-		}
-		dbus_message_iter_append_basic(&amp;struct_iter, DBUS_TYPE_STRING, &amp;pValue);
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusXapianIndex::documentInfoToDBus: field &quot; &lt;&lt; g_fieldNames[fieldNum] &lt;&lt; &quot;=&quot; &lt;&lt; pValue &lt;&lt; endl;
-#endif
-
-		if (!dbus_message_iter_close_container(&amp;array_iter, &amp;struct_iter))
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusXapianIndex::documentInfoToDBus: couldn't close struct container&quot; &lt;&lt; endl;
-#endif
-			return false;
-		}
-	}
-
-	if (!dbus_message_iter_close_container(iter, &amp;array_iter))
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusXapianIndex::documentInfoToDBus: couldn't close array container&quot; &lt;&lt; endl;
-#endif
-		return false;
-	}
-
-	return true;
-}
-
-/// Asks the D-Bus service to reload its configuration.
-bool DBusXapianIndex::reload(void)
-{
-	gboolean reloading = FALSE;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr &lt;&lt; &quot;DBusXapianIndex::reload: couldn't get bus proxy&quot; &lt;&lt; endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	if (dbus_g_proxy_call(pBusProxy, &quot;Reload&quot;, &amp;pError,
-		G_TYPE_INVALID,
-		G_TYPE_BOOLEAN, &amp;reloading,
-		G_TYPE_INVALID) == FALSE)
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;DBusXapianIndex::reload: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	if (reloading == TRUE)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-
-//
-// Implementation of IndexInterface
-//
-
-/// Sets the version number.
-bool DBusXapianIndex::setVersion(const string &amp;version) const
-{
-	cerr &lt;&lt; &quot;DBusXapianIndex::setVersion: not allowed&quot; &lt;&lt; endl;
-	return false;
-}
-
-/// Returns a document's properties.
-bool DBusXapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &amp;docInfo) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentInfo(docId, docInfo);
-}
-
-/// Returns a document's terms count.
-unsigned int DBusXapianIndex::getDocumentTermsCount(unsigned int docId) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentTermsCount(docId);
-}
-
-/// Returns a document's terms.
-bool DBusXapianIndex::getDocumentTerms(unsigned int docId,
-	map&lt;unsigned int, string&gt; &amp;wordsBuffer) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentTerms(docId, wordsBuffer);
-}
-
-/// Sets the list of known labels.
-bool DBusXapianIndex::setLabels(const set&lt;string&gt; &amp;labels)
-{
-	// Not allowed here
-	return false;
-}
-
-/// Gets the list of known labels.
-bool DBusXapianIndex::getLabels(set&lt;string&gt; &amp;labels) const
-{
-	reopen();
-
-	return XapianIndex::getLabels(labels);
-}
-
-/// Gets the list of known labels.
-bool DBusXapianIndex::getLabels(set&lt;string&gt; &amp;labels, bool forceDBus) const
-{
-	bool gotLabels = false;
-
-	if (forceDBus == false)
-	{
-		// Call overload
-		return getLabels(labels);
-	}
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr &lt;&lt; &quot;DBusXapianIndex::getLabels: couldn't get bus proxy&quot; &lt;&lt; endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	char **pLabels;
-
-	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
-	if (dbus_g_proxy_call(pBusProxy, &quot;GetLabels&quot;, &amp;pError,
-		G_TYPE_INVALID,
-		G_TYPE_STRV, &amp;pLabels,
-		G_TYPE_INVALID) == TRUE)
-	{
-		for (char **pLabel = pLabels; (*pLabel) != NULL; ++pLabel)
-		{
-			labels.insert(*pLabel);
-		}
-
-		// Free the array
-		g_strfreev(pLabels);
-
-		gotLabels = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;DBusXapianIndex::getLabels: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return gotLabels;
-}
-
-/// Adds a label.
-bool DBusXapianIndex::addLabel(const string &amp;name)
-{
-	bool addedLabel = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr &lt;&lt; &quot;DBusXapianIndex::addLabel: couldn't get bus proxy&quot; &lt;&lt; endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	const char *pLabel = name.c_str();
-
-	if (dbus_g_proxy_call(pBusProxy, &quot;AddLabel&quot;, &amp;pError,
-		G_TYPE_STRING, pLabel,
-		G_TYPE_INVALID,
-		G_TYPE_STRING, &amp;pLabel,
-		G_TYPE_INVALID) == TRUE)
-	{
-		addedLabel = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;DBusXapianIndex::addLabel: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return addedLabel;
-}
-
-/// Renames a label.
-bool DBusXapianIndex::renameLabel(const string &amp;name, const string &amp;newName)
-{
-	bool renamedLabel = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr &lt;&lt; &quot;DBusXapianIndex::renameLabel: couldn't get bus proxy&quot; &lt;&lt; endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	const char *pOldLabel = name.c_str();
-	const char *pNewLabel = newName.c_str();
-
-	if (dbus_g_proxy_call(pBusProxy, &quot;RenameLabel&quot;, &amp;pError,
-		G_TYPE_STRING, pOldLabel,
-		G_TYPE_STRING, pNewLabel,
-		G_TYPE_INVALID,
-		G_TYPE_STRING, &amp;pNewLabel,
-		G_TYPE_INVALID) == TRUE)
-	{
-		renamedLabel = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;DBusXapianIndex::renameLabel: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return renamedLabel;
-}
-
-/// Deletes all references to a label.
-bool DBusXapianIndex::deleteLabel(const string &amp;name)
-{
-	bool deletedLabel = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr &lt;&lt; &quot;DBusXapianIndex::deleteLabel: couldn't get bus proxy&quot; &lt;&lt; endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	const char *pLabel = name.c_str();
-
-	if (dbus_g_proxy_call(pBusProxy, &quot;DeleteLabel&quot;, &amp;pError,
-		G_TYPE_STRING, pLabel,
-		G_TYPE_INVALID,
-		G_TYPE_STRING, &amp;pLabel,
-		G_TYPE_INVALID) == TRUE)
-	{
-		deletedLabel = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;DBusXapianIndex::deleteLabel: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return deletedLabel;
-}
-
-/// Determines whether a document has a label.
-bool DBusXapianIndex::hasLabel(unsigned int docId, const string &amp;name) const
-{
-	reopen();
-
-	return XapianIndex::hasLabel(docId, name);
-}
-
-/// Returns a document's labels.
-bool DBusXapianIndex::getDocumentLabels(unsigned int docId, set&lt;string&gt; &amp;labels) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentLabels(docId, labels);
-}
-
-/// Returns a document's labels.
-bool DBusXapianIndex::getDocumentLabels(unsigned int docId, set&lt;string&gt; &amp;labels, bool forceDBus) const
-{
-	bool gotLabels = false;
-
-	if (forceDBus == false)
-	{
-		// Call overload
-		return getDocumentLabels(docId, labels);
-	}
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr &lt;&lt; &quot;DBusXapianIndex::getDocumentLabels: couldn't get bus proxy&quot; &lt;&lt; endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	char **pLabels;
-
-	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
-	if (dbus_g_proxy_call(pBusProxy, &quot;GetDocumentLabels&quot;, &amp;pError,
-		G_TYPE_UINT, docId,
-		G_TYPE_INVALID,
-		G_TYPE_STRV, &amp;pLabels,
-		G_TYPE_INVALID) == TRUE)
-	{
-		for (char **pLabel = pLabels; (*pLabel) != NULL; ++pLabel)
-		{
-			labels.insert(*pLabel);
-		}
-
-		// Free the array
-		g_strfreev(pLabels);
-
-		gotLabels = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;DBusXapianIndex::getDocumentLabels: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return gotLabels;
-}
-
-/// Sets a document's labels.
-bool DBusXapianIndex::setDocumentLabels(unsigned int docId, const set&lt;string&gt; &amp;labels,
-	bool resetLabels)
-{
-	bool updatedLabels = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr &lt;&lt; &quot;DBusXapianIndex::setDocumentLabels: couldn't get bus proxy&quot; &lt;&lt; endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	dbus_uint32_t labelsCount = labels.size();
-	char **pLabels;
-	unsigned int labelIndex = 0;
-
-	pLabels = g_new(char *, labelsCount + 1);
-	for (set&lt;string&gt;::const_iterator labelIter = labels.begin();
-		labelIter != labels.end(); ++labelIter)
-	{
-		pLabels[labelIndex] = g_strdup(labelIter-&gt;c_str());
-		++labelIndex;
-	}
-	pLabels[labelIndex] = NULL;
-
-	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
-	if (dbus_g_proxy_call(pBusProxy, &quot;SetDocumentLabels&quot;, &amp;pError,
-		G_TYPE_UINT, docId,
-		G_TYPE_STRV, pLabels,
-		G_TYPE_BOOLEAN, (resetLabels == true ? TRUE : FALSE),
-		G_TYPE_INVALID,
-		G_TYPE_UINT, &amp;docId,
-		G_TYPE_INVALID) == TRUE)
-	{
-		updatedLabels = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;DBusXapianIndex::setDocumentLabels: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			g_error_free(pError);
-		}
-	}
-
-	// Free the array
-	g_strfreev(pLabels);
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return updatedLabels;
-}
-
-/// Sets documents' labels.
-bool DBusXapianIndex::setDocumentsLabels(const set&lt;unsigned int&gt; &amp;docIds,
-	const set&lt;string&gt; &amp;labels, bool resetLabels)
-{
-	gboolean updatedLabels = FALSE;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr &lt;&lt; &quot;DBusXapianIndex::setDocumentsLabels: couldn't get bus proxy&quot; &lt;&lt; endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	dbus_uint32_t idsCount = docIds.size();
-	dbus_uint32_t labelsCount = labels.size();
-	char **pDocIds;
-	char **pLabels;
-	unsigned int idIndex = 0, labelIndex = 0;
-
-	pDocIds = g_new(char *, idsCount + 1);
-	pLabels = g_new(char *, labelsCount + 1);
-	for (set&lt;unsigned int&gt;::const_iterator idIter = docIds.begin();
-		idIter != docIds.end(); ++idIter)
-	{
-		pDocIds[idIndex] = g_strdup_printf(&quot;%u&quot;, *idIter); 
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusXapianIndex::setDocumentsLabels: document &quot; &lt;&lt; pDocIds[idIndex] &lt;&lt; endl;
-#endif
-		++idIndex;
-	}
-	pDocIds[idIndex] = NULL;
-	for (set&lt;string&gt;::const_iterator labelIter = labels.begin();
-		labelIter != labels.end(); ++labelIter)
-	{
-		pLabels[labelIndex] = g_strdup(labelIter-&gt;c_str());
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusXapianIndex::setDocumentsLabels: label &quot; &lt;&lt; pLabels[labelIndex] &lt;&lt; endl;
-#endif
-		++labelIndex;
-	}
-	pLabels[labelIndex] = NULL;
-
-	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
-	if (dbus_g_proxy_call(pBusProxy, &quot;SetDocumentsLabels&quot;, &amp;pError,
-		G_TYPE_STRV, pDocIds,
-		G_TYPE_STRV, pLabels,
-		G_TYPE_BOOLEAN, (resetLabels == true ? TRUE : FALSE),
-		G_TYPE_INVALID,
-		G_TYPE_BOOLEAN, &amp;updatedLabels,
-		G_TYPE_INVALID) == FALSE)
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;DBusXapianIndex::setDocumentsLabels: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			g_error_free(pError);
-		}
-		updatedLabels = FALSE;
-	}
-
-	// Free the arrays
-	g_strfreev(pDocIds);
-	g_strfreev(pLabels);
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	if (updatedLabels == TRUE)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-/// Checks whether the given URL is in the index.
-unsigned int DBusXapianIndex::hasDocument(const string &amp;url) const
-{
-	reopen();
-
-	return XapianIndex::hasDocument(url);
-}
-
-/// Gets terms with the same root.
-unsigned int DBusXapianIndex::getCloseTerms(const string &amp;term, set&lt;string&gt; &amp;suggestions)
-{
-	reopen();
-
-	return XapianIndex::getCloseTerms(term, suggestions);
-}
-
-/// Returns the ID of the last document.
-unsigned int DBusXapianIndex::getLastDocumentID(void) const
-{
-	reopen();
-
-	return XapianIndex::getLastDocumentID();
-}
-
-/// Returns the number of documents.
-unsigned int DBusXapianIndex::getDocumentsCount(const string &amp;labelName) const
-{
-	reopen();
-
-	return XapianIndex::getDocumentsCount(labelName);
-}
-
-/// Lists documents.
-unsigned int DBusXapianIndex::listDocuments(set&lt;unsigned int&gt; &amp;docIds,
-	unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	reopen();
-
-	return XapianIndex::listDocuments(docIds, maxDocsCount, startDoc);
-}
-
-/// Lists documents.
-bool DBusXapianIndex::listDocuments(const string &amp;name, set&lt;unsigned int&gt; &amp;docIds,
-	NameType type, unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	reopen();
-
-	return XapianIndex::listDocuments(name, docIds, type, maxDocsCount, startDoc);
-}
-
-/// Indexes the given data.
-bool DBusXapianIndex::indexDocument(const Document &amp;doc, const set&lt;string&gt; &amp;labels,
-	unsigned int &amp;docId)
-{
-	cerr &lt;&lt; &quot;DBusXapianIndex::indexDocument: not allowed&quot; &lt;&lt; endl;
-	return false;
-}
-
-/// Updates the given document; true if success.
-bool DBusXapianIndex::updateDocument(unsigned int docId, const Document &amp;doc)
-{
-	bool updated = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = getBusProxy(pBus);
-	if (pBusProxy == NULL)
-	{
-		cerr &lt;&lt; &quot;DBusXapianIndex::updateDocument: couldn't get bus proxy&quot; &lt;&lt; endl;
-		return false;
-	}
-
-	GError *pError = NULL;
-	if (dbus_g_proxy_call(pBusProxy, &quot;UpdateDocument&quot;, &amp;pError,
-		G_TYPE_UINT, docId,
-		G_TYPE_INVALID,
-		G_TYPE_UINT, &amp;docId,
-		G_TYPE_INVALID) == TRUE)
-	{
-		updated = true;
-	}
-	else
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;DBusXapianIndex::updateDocument: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			g_error_free(pError);
-		}
-	}
-
-	g_object_unref(pBusProxy);
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return updated;
-}
-
-/// Updates a document's properties.
-bool DBusXapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &amp;docInfo)
-{
-	DBusMessageIter iter;
-	bool updated = false;
-
-	DBusGConnection *pBus = getBusConnection();
-	if (pBus == NULL)
-	{
-		return false;
-	}
-
-	// FIXME: AFAIK we can't use DBusGProxy with message iterators
-	DBusMessage *pMsg = dbus_message_new_method_call(&quot;de.berlios.Pinot&quot;,
-		&quot;/de/berlios/Pinot&quot;, &quot;de.berlios.Pinot&quot;, &quot;SetDocumentInfo&quot;);
-	if (pMsg == NULL)
-	{
-		cerr &lt;&lt; &quot;DBusXapianIndex::updateDocumentInfo: couldn't call method&quot; &lt;&lt; endl;
-		return false;
-	}
-
-	dbus_message_iter_init_append(pMsg, &amp;iter);
-	if (DBusXapianIndex::documentInfoToDBus(&amp;iter, docId, docInfo) == false)
-	{
-		dbus_message_unref(pMsg);
-	}
-	else
-	{
-		DBusError err;
-
-		dbus_error_init(&amp;err);
-		DBusMessage *pReply = dbus_connection_send_with_reply_and_block(dbus_g_connection_get_connection(pBus),
-			pMsg, 1000 * 10, &amp;err);
-		dbus_message_unref(pMsg);
-
-		if (dbus_error_is_set(&amp;err))
-		{
-			cerr &lt;&lt; &quot;DBusXapianIndex::updateDocumentInfo: &quot; &lt;&lt; err.message &lt;&lt; endl;
-			dbus_error_free(&amp;err);
-			return false;
-		}
-
-		if (pReply != NULL)
-		{
-			dbus_message_get_args(pReply, NULL,
-				DBUS_TYPE_UINT32, &amp;docId,
-				DBUS_TYPE_INVALID);
-			updated = true;
-
-			dbus_message_unref(pReply);
-		}
-	}
-
-	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
-
-	return updated;
-}
-
-/// Unindexes the given document; true if success.
-bool DBusXapianIndex::unindexDocument(unsigned int docId)
-{
-	cerr &lt;&lt; &quot;DBusXapianIndex::unindexDocument: not allowed&quot; &lt;&lt; endl;
-	return false;
-}
-
-/// Unindexes documents.
-bool DBusXapianIndex::unindexDocuments(const string &amp;name, NameType type)
-{
-	cerr &lt;&lt; &quot;DBusXapianIndex::unindexDocuments: not allowed&quot; &lt;&lt; endl;
-	return false;
-}
-
-/// Unindexes all documents.
-bool DBusXapianIndex::unindexAllDocuments(void)
-{
-	cerr &lt;&lt; &quot;DBusXapianIndex::unindexDocuments: not allowed&quot; &lt;&lt; endl;
-	return false;
-}
-
-/// Flushes recent changes to the disk.
-bool DBusXapianIndex::flush(void)
-{
-	// The daemon knows best when to flush
-	return true;
-}
-
-/// Resets the index.
-bool DBusXapianIndex::reset(void)
-{
-	// This can't be done here
-	return false;
-}
-

Deleted: trunk/Index/DBusXapianIndex.h
===================================================================
--- trunk/Index/DBusXapianIndex.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/DBusXapianIndex.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,158 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _DBUS_XAPIAN_INDEX_H
-#define _DBUS_XAPIAN_INDEX_H
-
-#include &lt;string&gt;
-#include &lt;set&gt;
-#include &lt;map&gt;
-#include &quot;config.h&quot;
-extern &quot;C&quot;
-{
-#if DBUS_VERSION &lt; 1000000
-#define DBUS_API_SUBJECT_TO_CHANGE
-#endif
-#include &lt;dbus/dbus.h&gt;
-#include &lt;dbus/dbus-glib.h&gt;
-#include &lt;dbus/dbus-glib-lowlevel.h&gt;
-}
-
-#include &quot;XapianIndex.h&quot;
-
-/// Allows to write to the daemon index via D-Bus. 
-class DBusXapianIndex : public XapianIndex
-{
-	public:
-		DBusXapianIndex(const std::string &amp;indexName);
-		DBusXapianIndex(const DBusXapianIndex &amp;other);
-		virtual ~DBusXapianIndex();
-
-		DBusXapianIndex &amp;operator=(const DBusXapianIndex &amp;other);
-
-		/// Extracts docId and docInfo from a dbus message.
-		static bool documentInfoFromDBus(DBusMessageIter *iter, unsigned int &amp;docId,
-			DocumentInfo &amp;docInfo);
-
-		/// Converts docId and docInfo to a dbus message.
-		static bool documentInfoToDBus(DBusMessageIter *iter, unsigned int docId,
-			const DocumentInfo &amp;docInfo);
-
-		/// Asks the D-Bus service to reload its configuration.
-		static bool reload(void);
-
-		/// Sets the version number.
-		virtual bool setVersion(const std::string &amp;version) const;
-
-		/// Returns a document's properties.
-		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &amp;docInfo) const;
-
-		/// Returns a document's terms count.
-		virtual unsigned int getDocumentTermsCount(unsigned int docId) const;
-
-		/// Returns a document's terms.
-		virtual bool getDocumentTerms(unsigned int docId,
-			std::map&lt;unsigned int, std::string&gt; &amp;wordsBuffer) const;
-
-		/// Sets the list of known labels.
-		virtual bool setLabels(const std::set&lt;std::string&gt; &amp;labels);
-
-		/// Gets the list of known labels.
-		virtual bool getLabels(std::set&lt;std::string&gt; &amp;labels) const;
-
-		/// Gets the list of known labels.
-		bool getLabels(std::set&lt;std::string&gt; &amp;labels, bool forceDBus) const;
-
-		/// Adds a label.
-		virtual bool addLabel(const std::string &amp;name);
-
-		/// Renames a label.
-		virtual bool renameLabel(const std::string &amp;name, const std::string &amp;newName);
-
-		/// Deletes all references to a label.
-		virtual bool deleteLabel(const std::string &amp;name);
-
-		/// Determines whether a document has a label.
-		virtual bool hasLabel(unsigned int docId, const std::string &amp;name) const;
-
-		/// Returns a document's labels.
-		virtual bool getDocumentLabels(unsigned int docId, std::set&lt;std::string&gt; &amp;labels) const;
-
-		/// Returns a document's labels.
-		bool getDocumentLabels(unsigned int docId, std::set&lt;std::string&gt; &amp;labels,
-			bool forceDBus) const;
-
-		/// Sets a document's labels.
-		virtual bool setDocumentLabels(unsigned int docId, const std::set&lt;std::string&gt; &amp;labels,
-			bool resetLabels = true);
-
-		/// Sets documents' labels.
-		virtual bool setDocumentsLabels(const std::set&lt;unsigned int&gt; &amp;docIds,
-			const std::set&lt;std::string&gt; &amp;labels, bool resetLabels = true);
-
-		/// Checks whether the given URL is in the index.
-		virtual unsigned int hasDocument(const std::string &amp;url) const;
-
-		/// Gets terms with the same root.
-		virtual unsigned int getCloseTerms(const std::string &amp;term, std::set&lt;std::string&gt; &amp;suggestions);
-
-		/// Returns the ID of the last document.
-		virtual unsigned int getLastDocumentID(void) const;
-
-		/// Returns the number of documents.
-		virtual unsigned int getDocumentsCount(const std::string &amp;labelName = &quot;&quot;) const;
-
-		/// Lists documents.
-		virtual unsigned int listDocuments(std::set&lt;unsigned int&gt; &amp;docIDList,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		/// Lists documents.
-		virtual bool listDocuments(const std::string &amp;name, std::set&lt;unsigned int&gt; &amp;docIds,
-			NameType type, unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		/// Indexes the given data.
-		virtual bool indexDocument(const Document &amp;doc, const std::set&lt;std::string&gt; &amp;labels,
-			unsigned int &amp;docId);
-
-		/// Updates the given document.
-		virtual bool updateDocument(unsigned int docId, const Document &amp;doc);
-
-		/// Updates a document's properties.
-		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &amp;docInfo);
-
-		/// Unindexes the given document.
-		virtual bool unindexDocument(unsigned int docId);
-
-		/// Unindexes documents.
-		virtual bool unindexDocuments(const std::string &amp;name, NameType type);
-
-		/// Unindexes all documents.
-		virtual bool unindexAllDocuments(void);
-
-		/// Flushes recent changes to the disk.
-		virtual bool flush(void);
-
-		/// Resets the index.
-		virtual bool reset(void);
-
-	protected:
-		void reopen(void) const;
-
-};
-
-#endif // _DBUS_XAPIAN_INDEX_H

Deleted: trunk/Index/FilterWrapper.cpp
===================================================================
--- trunk/Index/FilterWrapper.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/FilterWrapper.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,219 +0,0 @@
-/*
- *  Copyright 2007 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;time.h&gt;
-#include &lt;iostream&gt;
-
-#include &quot;Url.h&quot;
-#include &quot;FilterFactory.h&quot;
-#include &quot;TextFilter.h&quot;
-#include &quot;FilterUtils.h&quot;
-#include &quot;FilterWrapper.h&quot;
-
-using std::cout;
-using std::endl;
-using std::string;
-using std::set;
-using namespace Dijon;
-
-FilterWrapper::FilterWrapper(IndexInterface *pIndex) :
-	m_pIndex(pIndex)
-{
-}
-
-FilterWrapper::~FilterWrapper()
-{
-}
-
-bool FilterWrapper::indexDocument(const Document &amp;doc, const set&lt;string&gt; &amp;labels, unsigned int &amp;docId)
-{
-	string originalType(doc.getType());
-
-	if (m_pIndex == NULL)
-	{
-		return false;
-	}
-
-	unindexNestedDocuments(doc.getLocation());
-
-	return filterDocument(doc, originalType, labels, docId, false);
-}
-
-bool FilterWrapper::updateDocument(const Document &amp;doc, unsigned int docId)
-{
-	set&lt;string&gt; labels;
-	string originalType(doc.getType());
-
-	if (m_pIndex == NULL)
-	{
-		return false;
-	}
-
-	unindexNestedDocuments(doc.getLocation());
-
-	return filterDocument(doc, originalType, labels, docId, true);
-}
-
-bool FilterWrapper::unindexDocument(const string &amp;location)
-{
-	if (m_pIndex == NULL)
-	{
-		return false;
-	}
-
-	unindexNestedDocuments(location);
-
-	return m_pIndex-&gt;unindexDocument(location);
-}
-
-bool FilterWrapper::filterDocument(const Document &amp;doc, const string &amp;originalType,
-	const set&lt;string&gt; &amp;labels, unsigned int &amp;docId, bool doUpdate)
-{
-	Filter *pFilter = FilterUtils::getFilter(doc.getType());
-	bool fedFilter = false, docSuccess = false, finalSuccess = false;
-
-	if (pFilter != NULL)
-	{
-		fedFilter = FilterUtils::feedFilter(doc, pFilter);
-	}
-	else
-	{
-		// Chances are this type is not supported
-		pFilter = new TextFilter(&quot;text/plain&quot;);
-
-		Document emptyDoc(doc.getTitle(), doc.getLocation(), doc.getType(), doc.getLanguage());
-
-		emptyDoc.setTimestamp(doc.getTimestamp());
-		emptyDoc.setSize(doc.getSize());
-		emptyDoc.setData(&quot; &quot;, 1);
-
-#ifdef DEBUG
-		cout &lt;&lt; &quot;FilterWrapper::filterDocument: unsupported type &quot; &lt;&lt; doc.getType() &lt;&lt; endl;
-#endif
-		fedFilter = FilterUtils::feedFilter(emptyDoc, pFilter);
-	}
-
-	if (fedFilter == false)
-	{
-		delete pFilter;
-
-		return false;
-	}
-
-	while (pFilter-&gt;has_documents() == true)
-	{
-		string actualType(originalType);
-		bool isNested = false;
-
-		if (pFilter-&gt;next_document() == false)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;FilterWrapper::filterDocument: no more documents in &quot; &lt;&lt; doc.getLocation() &lt;&lt; endl;
-#endif
-			break;
-		}
-
-		string originalTitle(doc.getTitle());
-		Document filteredDoc(originalTitle, doc.getLocation(), &quot;text/plain&quot;, doc.getLanguage());
-
-		filteredDoc.setTimestamp(doc.getTimestamp());
-		filteredDoc.setSize(doc.getSize());
-		docSuccess = false;
-
-		if (FilterUtils::populateDocument(filteredDoc, pFilter) == false)
-		{
-			continue;
-		}
-
-		// Is this a nested document ?
-		if (filteredDoc.getLocation().length() &gt; doc.getLocation().length())
-		{
-			actualType = filteredDoc.getType();
-#ifdef DEBUG
-			cout &lt;&lt; &quot;FilterWrapper::filterDocument: nested document of type &quot; &lt;&lt; actualType &lt;&lt; endl;
-#endif
-			isNested = true;
-		}
-		else if (originalTitle.empty() == false)
-		{
-			// Preserve the top-level document's title
-			filteredDoc.setTitle(originalTitle);
-		}
-		else if (filteredDoc.getTitle().empty() == true)
-		{
-			Url urlObj(doc.getLocation());
-
-			// Default to the file name as title
-			filteredDoc.setTitle(urlObj.getFile());
-#ifdef DEBUG
-			cout &lt;&lt; &quot;FilterWrapper::filterDocument: set default title &quot; &lt;&lt; urlObj.getFile() &lt;&lt; endl;
-#endif
-		}
-
-		// Pass it down to another filter ?
-		if ((filteredDoc.getType().length() &gt;= 10) &amp;&amp;
-			(filteredDoc.getType().substr(0, 10) == &quot;text/plain&quot;))
-		{
-			// No, it's been reduced to plain text
-			filteredDoc.setType(actualType);
-
-			// Nested documents can't be updated because they are unindexed
-			// and the ID is that of the base document anyway
-			if ((doUpdate == true) &amp;&amp;
-				(isNested == false))
-			{
-				docSuccess = m_pIndex-&gt;updateDocument(docId, filteredDoc);
-			}
-			else
-			{
-				unsigned int newDocId = docId;
-
-				docSuccess = m_pIndex-&gt;indexDocument(filteredDoc, labels, newDocId);
-				// Make sure we return the base document's ID, not the last nested document's ID
-				if (isNested == false)
-				{
-					docId = newDocId;
-				}
-			}
-		}
-		else
-		{
-			docSuccess = filterDocument(filteredDoc, actualType, labels, docId, doUpdate);
-		}
-
-		// Consider indexing anything a success
-		if (docSuccess == true)
-		{
-			finalSuccess = true;
-		}
-	}
-
-	delete pFilter;
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;FilterWrapper::filterDocument: done with &quot; &lt;&lt; doc.getLocation() &lt;&lt; &quot; status &quot; &lt;&lt; finalSuccess &lt;&lt; endl;
-#endif
-
-	return finalSuccess;
-}
-
-bool FilterWrapper::unindexNestedDocuments(const string &amp;url)
-{
-	// Unindex all documents that stem from this file
-	return m_pIndex-&gt;unindexDocuments(url, IndexInterface::BY_FILE);
-}

Deleted: trunk/Index/FilterWrapper.h
===================================================================
--- trunk/Index/FilterWrapper.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/FilterWrapper.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,62 +0,0 @@
-/*
- *  Copyright 2007 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _FILTER_WRAPPER_H
-#define _FILTER_WRAPPER_H
-
-#include &lt;string&gt;
-#include &lt;set&gt;
-
-#include &quot;Document.h&quot;
-#include &quot;Filter.h&quot;
-#include &quot;IndexInterface.h&quot;
-
-/// A wrapper around Dijon filters.
-class FilterWrapper
-{
-	public:
-		/// Builds a FilterWrapper object.
-		FilterWrapper(IndexInterface *pIndex);
-		virtual ~FilterWrapper();
-
-		/// Indexes the given data.
-		bool indexDocument(const Document &amp;doc, const std::set&lt;std::string&gt; &amp;labels,
-			unsigned int &amp;docId);
-
-		/// Updates the given document.
-		bool updateDocument(const Document &amp;doc, unsigned int docId);
-
-		/// Unindexes document(s) at the given location.
-		bool unindexDocument(const std::string &amp;location);
-
-	protected:
-		IndexInterface *m_pIndex;
-
-		bool filterDocument(const Document &amp;doc, const std::string &amp;originalType,
-			const std::set&lt;std::string&gt; &amp;labels, unsigned int &amp;docId,
-			bool doUpdate);
-
-		bool unindexNestedDocuments(const std::string &amp;url);
-
-	private:
-		FilterWrapper(const FilterWrapper &amp;other);
-		FilterWrapper &amp;operator=(const FilterWrapper &amp;other);
-
-};
-
-#endif // _FILTER_WRAPPER_H

Deleted: trunk/Index/IndexFactory.cpp
===================================================================
--- trunk/Index/IndexFactory.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/IndexFactory.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,50 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &quot;XapianIndex.h&quot;
-#include &quot;DBusXapianIndex.h&quot;
-#include &quot;IndexFactory.h&quot;
-
-using std::string;
-
-IndexFactory::IndexFactory()
-{
-}
-
-IndexFactory::~IndexFactory()
-{
-}
-
-/// Returns an index of the specified type; NULL if unavailable.
-IndexInterface *IndexFactory::getIndex(const string &amp;type, const string &amp;option)
-{
-	IndexInterface *pIndex = NULL;
-
-	// Choice by type
-	if (type == &quot;dbus&quot;)
-	{
-		pIndex = new DBusXapianIndex(option);
-	}
-	else if (type == &quot;xapian&quot;)
-	{
-		pIndex = new XapianIndex(option);
-	}
-
-	return pIndex;
-}
-

Deleted: trunk/Index/IndexFactory.h
===================================================================
--- trunk/Index/IndexFactory.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/IndexFactory.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,44 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _INDEX_FACTORY_H
-#define _INDEX_FACTORY_H
-
-#include &lt;string&gt;
-
-#include &quot;IndexInterface.h&quot;
-
-/// Factory for indexes.
-class IndexFactory
-{
-	public:
-		virtual ~IndexFactory();
-
-		/// Returns an index of the specified type; NULL if unavailable.
-		static IndexInterface *getIndex(const std::string &amp;type, const std::string &amp;option);
-
-	protected:
-		IndexFactory();
-
-	private:
-		IndexFactory(const IndexFactory &amp;other);
-		IndexFactory &amp;operator=(const IndexFactory &amp;other);
-
-};
-
-#endif // _INDEX_FACTORY_H

Deleted: trunk/Index/IndexInterface.h
===================================================================
--- trunk/Index/IndexInterface.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/IndexInterface.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,141 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
- 
-#ifndef _INDEX_INTERFACE_H
-#define _INDEX_INTERFACE_H
-
-#include &lt;string&gt;
-#include &lt;set&gt;
-#include &lt;map&gt;
-
-#include &quot;Document.h&quot;
-
-/// Interface implemented by indexes.
-class IndexInterface
-{
-	public:
-		IndexInterface(const IndexInterface &amp;other) {};
-		virtual ~IndexInterface() {};
-
-		typedef enum { BY_LABEL = 0, BY_DIRECTORY, BY_FILE } NameType;
-
-		/// Returns false if the index couldn't be opened.
-		virtual bool isGood(void) const = 0;
-
-		/// Gets the version number.
-		virtual std::string getVersion(void) const = 0;
-
-		/// Sets the version number.
-		virtual bool setVersion(const std::string &amp;version) const = 0;
-
-		/// Gets the index location.
-		virtual std::string getLocation(void) const = 0;
-
-		/// Returns a document's properties.
-		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &amp;docInfo) const = 0;
-
-		/// Returns a document's terms count.
-		virtual unsigned int getDocumentTermsCount(unsigned int docId) const = 0;
-
-		/// Returns a document's terms.
-		virtual bool getDocumentTerms(unsigned int docId,
-			std::map&lt;unsigned int, std::string&gt; &amp;wordsBuffer) const = 0;
-
-		/// Sets the list of known labels.
-		virtual bool setLabels(const std::set&lt;std::string&gt; &amp;labels) = 0;
-
-		/// Gets the list of known labels.
-		virtual bool getLabels(std::set&lt;std::string&gt; &amp;labels) const = 0;
-
-		/// Adds a label.
-		virtual bool addLabel(const std::string &amp;name) = 0;
-
-		/// Renames a label.
-		virtual bool renameLabel(const std::string &amp;name, const std::string &amp;newName) = 0;
-
-		/// Deletes all references to a label.
-		virtual bool deleteLabel(const std::string &amp;name) = 0;
-
-		/// Determines whether a document has a label.
-		virtual bool hasLabel(unsigned int docId, const std::string &amp;name) const = 0;
-
-		/// Returns a document's labels.
-		virtual bool getDocumentLabels(unsigned int docId, std::set&lt;std::string&gt; &amp;labels) const = 0;
-
-		/// Sets a document's labels.
-		virtual bool setDocumentLabels(unsigned int docId, const std::set&lt;std::string&gt; &amp;labels,
-			bool resetLabels = true) = 0;
-
-		/// Sets documents' labels.
-		virtual bool setDocumentsLabels(const std::set&lt;unsigned int&gt; &amp;docIds,
-			const std::set&lt;std::string&gt; &amp;labels, bool resetLabels = true) = 0;
-
-		/// Checks whether the given URL is in the index.
-		virtual unsigned int hasDocument(const std::string &amp;url) const = 0;
-
-		/// Gets terms with the same root.
-		virtual unsigned int getCloseTerms(const std::string &amp;term, std::set&lt;std::string&gt; &amp;suggestions) = 0;
-
-		/// Returns the ID of the last document.
-		virtual unsigned int getLastDocumentID(void) const = 0;
-
-		/// Returns the number of documents.
-		virtual unsigned int getDocumentsCount(const std::string &amp;labelName = &quot;&quot;) const = 0;
-
-		/// Lists documents.
-		virtual unsigned int listDocuments(std::set&lt;unsigned int&gt; &amp;docIDList,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const = 0;
-
-		/// Lists documents.
-		virtual bool listDocuments(const std::string &amp;name, std::set&lt;unsigned int&gt; &amp;docIds,
-			NameType type, unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const = 0;
-
-		/// Indexes the given data.
-		virtual bool indexDocument(const Document &amp;doc, const std::set&lt;std::string&gt; &amp;labels,
-			unsigned int &amp;docId) = 0;
-
-		/// Updates the given document.
-		virtual bool updateDocument(unsigned int docId, const Document &amp;doc) = 0;
-
-		/// Updates a document's properties.
-		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &amp;docInfo) = 0;
-
-		/// Unindexes the given document.
-		virtual bool unindexDocument(unsigned int docId) = 0;
-
-		/// Unindexes the given document.
-		virtual bool unindexDocument(const std::string &amp;location) = 0;
-
-		/// Unindexes documents.
-		virtual bool unindexDocuments(const std::string &amp;name, NameType type) = 0;
-
-		/// Unindexes all documents.
-		virtual bool unindexAllDocuments(void) = 0;
-
-		/// Flushes recent changes to the disk.
-		virtual bool flush(void) = 0;
-
-		/// Resets the index.
-		virtual bool reset(void) = 0;
-
-	protected:
-		IndexInterface() { };
-
-};
-
-#endif // _INDEX_INTERFACE_H

Deleted: trunk/Index/LanguageDetector.cpp
===================================================================
--- trunk/Index/LanguageDetector.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/LanguageDetector.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,179 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;strings.h&gt;
-#include &lt;sys/time.h&gt;
-#include &lt;iostream&gt;
-#include &lt;utility&gt;
-
-#include &quot;config.h&quot;
-extern &quot;C&quot;
-{
-#ifdef HAVE_LIBTEXTCAT_TEXTCAT_H
-#include &lt;libtextcat/textcat.h&gt;
-#else
-#include &lt;textcat.h&gt;
-#endif
-}
-
-#include &quot;StringManip.h&quot;
-#include &quot;Timer.h&quot;
-#include &quot;LanguageDetector.h&quot;
-#include &quot;config.h&quot;
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-using std::vector;
-using std::min;
-
-unsigned int LanguageDetector::m_maxTextSize = 1000;
-
-LanguageDetector::LanguageDetector()
-{
-}
-
-LanguageDetector::~LanguageDetector()
-{
-}
-
-/**
-  * Attempts to guess the language.
-  * Returns a list of candidates, or &quot;unknown&quot; if detection failed.
-  */
-void LanguageDetector::guessLanguage(const char *pData, unsigned int dataLength,
-			std::vector&lt;std::string&gt; &amp;candidates)
-{
-	string confFile(SYSCONFDIR);
-	char *textCatVersion = textcat_Version();
-#ifdef HAVE_TEXTCAT_CAT
-	const char *catResults[10];
-#endif
-
-	candidates.clear();
-
-	// What configuration file should we use ?
-	confFile += &quot;/pinot/&quot;;
-#ifdef DEBUG
-	cout &lt;&lt; &quot;LanguageDetector::guessLanguage: detected &quot; &lt;&lt; textCatVersion &lt;&lt; endl;
-#endif
-	if (strncasecmp(textCatVersion, &quot;TextCat 3&quot;, 9) == 0)
-	{
-		// Version 3
-		confFile += &quot;textcat3_conf.txt&quot;;
-	}
-	else
-	{
-		confFile += &quot;textcat_conf.txt&quot;;
-	}
-
-	// Initialize
-	void *td = textcat_Init(confFile.c_str());
-	if (td == NULL)
-	{
-		candidates.push_back(&quot;unknown&quot;);
-		return;
-	}
-
-	// Classify
-#ifdef DEBUG
-	Timer timer;
-	timer.start();
-	cout &lt;&lt; &quot;LanguageDetector::guessLanguage: starting&quot; &lt;&lt; endl;
-#endif
-#ifdef HAVE_TEXTCAT_CAT
-	unsigned int resultNum = textcat_Cat(td, pData,
-		min(dataLength, m_maxTextSize), catResults, 10);
-	if (resultNum == 0 )
-	{
-		candidates.push_back(&quot;unknown&quot;);
-	}
-	else
-	{
-		for (unsigned int i=0; i&lt;resultNum; ++i)
-		{
-			string language(StringManip::toLowerCase(catResults[i]));
-
-			// Remove the charset information
-			string::size_type dashPos = language.find('-');
-			if (dashPos != string::npos)
-			{
-				language.resize(dashPos);
-			}
-#ifdef DEBUG
-			cout &lt;&lt; &quot;LanguageDetector::guessLanguage: found language &quot; &lt;&lt; language &lt;&lt; endl;
-#endif
-			candidates.push_back(language);
-		}
-	}
-#else
-	const char *languages = textcat_Classify(td, pData,
-		min(dataLength, m_maxTextSize));
-	if (languages == NULL)
-	{
-		candidates.push_back(&quot;unknown&quot;);
-	}
-	else
-	{
-		// The output will be either SHORT, or UNKNOWN or a list of languages in []
-		if ((strncasecmp(languages, &quot;SHORT&quot;, 5) == 0) ||
-			(strncasecmp(languages, &quot;UNKNOWN&quot;, 7) == 0))
-		{
-			candidates.push_back(&quot;unknown&quot;);
-		}
-		else
-		{
-			string languageList(languages);
-			string::size_type lastPos = 0, pos = languageList.find_first_of(&quot;[&quot;);
-
-			while (pos != string::npos)
-			{
-				++pos;
-				lastPos = languageList.find_first_of(&quot;]&quot;, pos);
-				if (lastPos == string::npos)
-				{
-					break;
-				}
-
-				string language(StringManip::toLowerCase(languageList.substr(pos, lastPos - pos)));
-				// Remove the charset information
-				string::size_type dashPos = language.find('-');
-				if (dashPos != string::npos)
-				{
-					language.resize(dashPos);
-				}
-#ifdef DEBUG
-				cout &lt;&lt; &quot;LanguageDetector::guessLanguage: found language &quot; &lt;&lt; language &lt;&lt; endl;
-#endif
-				candidates.push_back(language);
-
-				// Next
-				pos = languageList.find_first_of(&quot;[&quot;, lastPos);
-			}
-		}
-	}
-#endif
-#ifdef DEBUG
-	cout &lt;&lt; &quot;LanguageDetector::guessLanguage: language guessing took &quot;
-		&lt;&lt; timer.stop() &lt;&lt; &quot; ms&quot; &lt;&lt; endl;
-#endif
-
-	// Close the descriptor
-	textcat_Done(td);
-}

Deleted: trunk/Index/LanguageDetector.h
===================================================================
--- trunk/Index/LanguageDetector.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/LanguageDetector.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,48 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _LANGUAGE_DETECTOR_H
-#define _LANGUAGE_DETECTOR_H
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-/// Detects a document's language with libextcat.
-class LanguageDetector
-{
-	public:
-		LanguageDetector();
-		virtual ~LanguageDetector();
-
-		/**
-		  * Attempts to guess the language.
-		  * Returns a list of candidates, or &quot;unknown&quot; if detection failed.
-		  */
-		void guessLanguage(const char *pData, unsigned int dataLength,
-			std::vector&lt;std::string&gt; &amp;candidates);
-
-	protected:
-		static unsigned int m_maxTextSize;
-
-	private:
-		LanguageDetector(const LanguageDetector &amp;other);
-		LanguageDetector &amp;operator=(const LanguageDetector &amp;other);
-
-};
-
-#endif // _LANGUAGE_DETECTOR_H

Deleted: trunk/Index/XapianDatabase.cpp
===================================================================
--- trunk/Index/XapianDatabase.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/XapianDatabase.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,645 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;strings.h&gt;
-#include &lt;regex.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;iostream&gt;
-
-#include &quot;StringManip.h&quot;
-#include &quot;TimeConverter.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;XapianDatabase.h&quot;
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-
-// This puts a limit to terms length.
-const unsigned int XapianDatabase::m_maxTermLength = 230;
-
-XapianDatabase::XapianDatabase(const string &amp;databaseName,
-	bool readOnly, bool overwrite) :
-	m_databaseName(databaseName),
-	m_withSpelling(true),
-	m_readOnly(readOnly),
-	m_overwrite(overwrite),
-	m_obsoleteFormat(false),
-	m_pDatabase(NULL),
-	m_isOpen(false),
-	m_merge(false),
-	m_pFirst(NULL),
-	m_pSecond(NULL)
-{
-	initializeLock();
-	openDatabase();
-}
-
-XapianDatabase::XapianDatabase(const string &amp;databaseName, 
-	XapianDatabase *pFirst, XapianDatabase *pSecond) :
-	m_databaseName(databaseName),
-	m_withSpelling(true),
-	m_readOnly(true),
-	m_overwrite(false),
-	m_obsoleteFormat(false),
-	m_pDatabase(NULL),
-	m_isOpen(pFirst-&gt;m_isOpen),
-	m_merge(true),
-	m_pFirst(pFirst),
-	m_pSecond(pSecond)
-{
-	initializeLock();
-}
-
-XapianDatabase::XapianDatabase(const XapianDatabase &amp;other) :
-	m_databaseName(other.m_databaseName),
-	m_withSpelling(other.m_withSpelling),
-	m_readOnly(other.m_readOnly),
-	m_overwrite(other.m_overwrite),
-	m_obsoleteFormat(other.m_obsoleteFormat),
-	m_pDatabase(NULL),
-	m_isOpen(other.m_isOpen),
-	m_merge(other.m_merge),
-	m_pFirst(other.m_pFirst),
-	m_pSecond(other.m_pSecond)
-{
-	initializeLock();
-	if (other.m_pDatabase != NULL)
-	{
-		m_pDatabase = new Xapian::Database(*other.m_pDatabase);
-	}
-}
-
-XapianDatabase::~XapianDatabase()
-{
-	if (m_pDatabase != NULL)
-	{
-		delete m_pDatabase;
-	}
-	pthread_mutex_destroy(&amp;m_rwLock);
-#ifdef DEBUG
-	pthread_mutexattr_destroy(&amp;m_rwLockAttr);
-#endif
-}
-
-XapianDatabase &amp;XapianDatabase::operator=(const XapianDatabase &amp;other)
-{
-	if (this != &amp;other)
-	{
-		m_databaseName = other.m_databaseName;
-		m_withSpelling = other.m_withSpelling;
-		m_readOnly = other.m_readOnly;
-		m_overwrite = other.m_overwrite;
-		m_obsoleteFormat = other.m_obsoleteFormat;
-		if (m_pDatabase != NULL)
-		{
-			delete m_pDatabase;
-			m_pDatabase = NULL;
-		}
-		if (other.m_pDatabase != NULL)
-		{
-			m_pDatabase = new Xapian::Database(*other.m_pDatabase);
-		}
-		m_isOpen = other.m_isOpen;
-		m_merge = other.m_merge;
-		m_pFirst = other.m_pFirst;
-		m_pSecond = other.m_pSecond;
-	}
-
-	return *this;
-}
-
-void XapianDatabase::initializeLock(void)
-{
-#ifdef DEBUG
-	pthread_mutexattr_init(&amp;m_rwLockAttr);
-	pthread_mutexattr_settype(&amp;m_rwLockAttr, PTHREAD_MUTEX_ERRORCHECK);
-	pthread_mutex_init(&amp;m_rwLock, &amp;m_rwLockAttr);
-#else
-	pthread_mutex_init(&amp;m_rwLock, NULL);
-#endif
-}
-
-void XapianDatabase::openDatabase(void)
-{
-	struct stat dbStat;
-	bool createDatabase = false;
-	bool tryAgain = false;
-
-	if (m_databaseName.empty() == true)
-	{
-		return;
-	}
-
-	// Should we build the spelling database ?
-	char *pEnvVar = getenv(&quot;PINOT_SPELLING_DB&quot;);
-	if ((pEnvVar != NULL) &amp;&amp;
-		(strncasecmp(pEnvVar, &quot;no&quot;, 2) == 0))
-	{
-		// No
-		m_withSpelling = false;
-	}
-	else
-	{
-		// Yes
-		m_withSpelling = true;
-	}
-
-	// Assume things will fail
-	m_isOpen = false;
-
-	if (m_pDatabase != NULL)
-	{
-		delete m_pDatabase;
-		m_pDatabase = NULL;
-	}
-
-	// Is it a remote database ?
-	string::size_type slashPos = m_databaseName.find(&quot;/&quot;);
-	string::size_type colonPos = m_databaseName.find(&quot;:&quot;);
-	if (((slashPos == string::npos) ||
-		(slashPos &gt; 0)) &amp;&amp;
-		(colonPos != string::npos))
-	{
-		Url urlObj(m_databaseName);
-
-		if (m_readOnly == false)
-		{
-			cerr &lt;&lt; &quot;XapianDatabase::openDatabase: remote databases &quot; &lt;&lt; m_databaseName &lt;&lt; &quot; are read-only&quot; &lt;&lt; endl;
-			return;
-		}
-
-		if (m_databaseName.find(&quot;://&quot;) == string::npos)
-		{
-			// It's an old style remote specification without the protocol
-			urlObj = Url(&quot;<A HREF="tcpsrv://">tcpsrv://</A>&quot; + m_databaseName);
-		}
-
-		string hostName(urlObj.getHost());
-		// A port number should be included
-		colonPos = hostName.find(&quot;:&quot;);
-		if (colonPos != string::npos)
-		{
-			string protocol(urlObj.getProtocol());
-			string portStr(hostName.substr(colonPos + 1));
-			unsigned int port = (unsigned int)atoi(portStr.c_str());
-
-			hostName.resize(colonPos);
-			try
-			{
-				if (protocol == &quot;progsrv+ssh&quot;)
-				{
-					string args(&quot;-p&quot;);
-
-					args += &quot; &quot;;
-					args += portStr;
-					args += &quot; -f &quot;;
-					args += hostName;
-					args += &quot; xapian-progsrv /&quot;;
-					args += urlObj.getLocation();
-					args += &quot;/&quot;;
-					args += urlObj.getFile();
-#ifdef DEBUG
-					cout &lt;&lt; &quot;XapianDatabase::openDatabase: remote ssh access with ssh &quot;
-						&lt;&lt; args &lt;&lt; endl;
-#endif
-					Xapian::Database remoteDatabase = Xapian::Remote::open(&quot;ssh&quot;, args);
-					m_pDatabase = new Xapian::Database(remoteDatabase);
-				}
-				else
-				{
-#ifdef DEBUG
-					cout &lt;&lt; &quot;XapianDatabase::openDatabase: remote database at &quot;
-						&lt;&lt; hostName &lt;&lt; &quot; &quot; &lt;&lt; port &lt;&lt; endl;
-#endif
-					Xapian::Database remoteDatabase = Xapian::Remote::open(hostName, port);
-					m_pDatabase = new Xapian::Database(remoteDatabase);
-				}
-
-				if (m_pDatabase != NULL)
-				{
-					// Stop remote databases timing out
-					m_pDatabase-&gt;keep_alive();
-					m_isOpen = true;
-				}
-
-				return;
-			}
-			catch (const Xapian::Error &amp;error)
-			{
-				cerr &lt;&lt; &quot;Error opening &quot; &lt;&lt; m_databaseName &lt;&lt; &quot;: &quot; &lt;&lt; error.get_type()
-					&lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-			}
-		}
-#ifdef DEBUG
-		else cout &lt;&lt; &quot;XapianDatabase::openDatabase: invalid remote database at &quot;
-			&lt;&lt; hostName &lt;&lt; &quot;/&quot; &lt;&lt; urlObj.getLocation() &lt;&lt; &quot;/&quot; &lt;&lt; urlObj.getFile() &lt;&lt; endl;
-#endif
-
-		return;
-	}
-
-	// It's a local database : the specified path must be a directory
-	if (stat(m_databaseName.c_str(), &amp;dbStat) == -1)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;XapianDatabase::openDatabase: database &quot; &lt;&lt; m_databaseName
-			&lt;&lt; &quot; doesn't exist&quot; &lt;&lt; endl;
-#endif
-
-		// Database directory doesn't exist, create it (mode 755)
-		if (mkdir(m_databaseName.c_str(), (mode_t)S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) != 0)
-		{
-			cerr &lt;&lt; &quot;XapianDatabase::openDatabase: couldn't create database directory &quot;
-				&lt;&lt; m_databaseName &lt;&lt; endl;
-			return;
-		}
-		createDatabase = true;
-	}
-	else if (!S_ISDIR(dbStat.st_mode))
-	{
-		cerr &lt;&lt; &quot;XapianDatabase::openDatabase: &quot; &lt;&lt; m_databaseName
-			&lt;&lt; &quot; is not a directory&quot; &lt;&lt; endl;
-		return;
-	}
-
-	// Try opening it now, creating if if necessary
-	try
-	{
-		if (m_readOnly == true)
-		{
-			if (createDatabase == true)
-			{
-				// We have to create the whole thing in read-write mode first
-				Xapian::WritableDatabase *pTmpDatabase = new Xapian::WritableDatabase(m_databaseName, Xapian::DB_CREATE_OR_OPEN);
-				// ...then close and open again in read-only mode
-				delete pTmpDatabase;
-			}
-
-			m_pDatabase = new Xapian::Database(m_databaseName);
-		}
-		else
-		{
-			int openAction = Xapian::DB_CREATE_OR_OPEN;
-
-			if (m_overwrite == true)
-			{
-				// An existing database will be overwritten
-				openAction = Xapian::DB_CREATE_OR_OVERWRITE;
-			}
-
-			m_pDatabase = new Xapian::WritableDatabase(m_databaseName, openAction);
-		}
-
-		if (m_pDatabase != NULL)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;XapianDatabase::openDatabase: opened &quot; &lt;&lt; m_databaseName
-				&lt;&lt; &quot; &quot; &lt;&lt; m_pDatabase-&gt;get_description() &lt;&lt; endl;
-#endif
-			m_isOpen = true;
-		}
-
-		return;
-	}
-#if XAPIAN_MAJOR_VERSION&gt;0
-	catch (const Xapian::DatabaseVersionError &amp;error)
-	{
-		cerr &lt;&lt; &quot;Error opening &quot; &lt;&lt; m_databaseName &lt;&lt; &quot;: &quot; &lt;&lt; error.get_type()
-			&lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-
-		// This format is no longer supported
-		if (m_obsoleteFormat == false)
-		{
-			tryAgain = true;
-		}
-	}
-#endif
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Error opening &quot; &lt;&lt; m_databaseName &lt;&lt; &quot;: &quot; &lt;&lt; error.get_type()
-			&lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-
-	// Give it another try ?
-	if (tryAgain == true)
-	{
-		cout &lt;&lt; &quot;XapianDatabase::openDatabase: trying again&quot; &lt;&lt; endl;
-
-		m_overwrite = true;
-		m_obsoleteFormat = true;
-		openDatabase();
-	}
-}
-
-/// Returns true if the database supports spelling.
-bool XapianDatabase::withSpelling(void)
-{
-	return m_withSpelling;
-}
-
-/// Returns false if the database couldn't be opened.
-bool XapianDatabase::isOpen(void) const
-{
-	return m_isOpen;
-}
-
-/// Returns false if the database was of an obsolete format.
-bool XapianDatabase::wasObsoleteFormat(void) const
-{
-	return m_obsoleteFormat;
-}
-
-/// Reopens the database.
-void XapianDatabase::reopen(void)
-{
-	// This is provided by Xapian::Database
-	// FIXME: get the write lock to make sure read operations are not in progress ?
-	if (pthread_mutex_lock(&amp;m_rwLock) == 0)
-	{
-		if (m_pDatabase != NULL)
-		{
-			m_pDatabase-&gt;reopen();
-		}
-
-		pthread_mutex_unlock(&amp;m_rwLock);
-	}
-}
-
-/// Attempts to lock and retrieve the database.
-Xapian::Database *XapianDatabase::readLock(void)
-{
-	if (m_merge == false)
-	{
-		if (pthread_mutex_lock(&amp;m_rwLock) == 0)
-		{
-			if (m_pDatabase == NULL)
-			{
-				// Try again
-				openDatabase();
-			}
-			return m_pDatabase;
-		}
-#ifdef DEBUG
-		else cout &lt;&lt; &quot;XapianDatabase::readLock: failed&quot; &lt;&lt; endl;
-#endif
-	}
-	else
-	{
-		if ((m_pFirst == NULL) ||
-			(m_pFirst-&gt;isOpen() == false) ||
-			(m_pSecond == NULL) ||
-			(m_pSecond-&gt;isOpen() == false))
-		{
-			return NULL;
-		}
-
-		if (pthread_mutex_lock(&amp;m_rwLock) == 0)
-		{
-			// Reopen the second index
-			m_pSecond-&gt;reopen();
-
-			// Lock both indexes
-			Xapian::Database *pFirstDatabase = m_pFirst-&gt;readLock();
-			Xapian::Database *pSecondDatabase = m_pSecond-&gt;readLock();
-			// Copy the first one
-			m_pDatabase = new Xapian::Database(*pFirstDatabase);
-			// Add the second index to it
-			if (pSecondDatabase != NULL)
-			{
-				m_pDatabase-&gt;add_database(*pSecondDatabase);
-			}
-			// Until unlock() is called, both indexes are read locked
-
-			return m_pDatabase;
-		}
-#ifdef DEBUG
-		else cout &lt;&lt; &quot;XapianDatabase::readLock: failed&quot; &lt;&lt; endl;
-#endif
-	}
-
-	return NULL;
-}
-
-/// Attempts to lock and retrieve the database.
-Xapian::WritableDatabase *XapianDatabase::writeLock(void)
-{
-	if ((m_readOnly == true) ||
-		(m_merge == true))
-	{
-		cerr &lt;&lt; &quot;Couldn't open read-only database &quot; &lt;&lt; m_databaseName
-			&lt;&lt; &quot; for writing&quot; &lt;&lt; endl;
-		return NULL;
-	}
-
-	if (pthread_mutex_lock(&amp;m_rwLock) == 0)
-	{
-		if (m_pDatabase == NULL)
-		{
-			// Try again
-			openDatabase();
-		}
-
-		return dynamic_cast&lt;Xapian::WritableDatabase *&gt;(m_pDatabase);
-	}
-#ifdef DEBUG
-	else cout &lt;&lt; &quot;XapianDatabase::writeLock: failed&quot; &lt;&lt; endl;
-#endif
-
-	return NULL;
-}
-
-/// Unlocks the database.
-void XapianDatabase::unlock(void)
-{
-	if (pthread_mutex_unlock(&amp;m_rwLock) != 0)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;XapianDatabase::unlock: failed&quot; &lt;&lt; endl;
-#endif
-	}
-
-	if (m_merge == true)
-	{
-		// Unlock the original indexes
-		if (m_pFirst != NULL)
-		{
-			m_pFirst-&gt;unlock();
-		}
-		if (m_pSecond != NULL)
-		{
-			m_pSecond-&gt;unlock();
-		}
-
-		// Delete merge
-		if (m_pDatabase != NULL)
-		{
-			delete m_pDatabase;
-			m_pDatabase = NULL;
-		}
-	}
-}
-
-bool XapianDatabase::badRecordField(const string &amp;field)
-{
-	regex_t fieldRegex;
-	regmatch_t pFieldMatches[1];
-	bool isBadField = false;
-
-	// A bad field is one that includes one of our field delimiters
-	if (regcomp(&amp;fieldRegex,
-		&quot;(url|sample|caption|type|modtime|language|size)=&quot;,
-		REG_EXTENDED|REG_ICASE) == 0)
-	{
-		if (regexec(&amp;fieldRegex, field.c_str(), 1,
-			pFieldMatches, REG_NOTBOL|REG_NOTEOL) == 0)
-		{
-			isBadField = true;
-		}
-	}
-	regfree(&amp;fieldRegex);
-
-	return isBadField;
-}
-
-/// Returns a record for the document's properties.
-string XapianDatabase::propsToRecord(DocumentInfo *pDoc)
-{
-	if (pDoc == NULL)
-	{
-		return &quot;&quot;;
-	}
-
-	string record(&quot;url=&quot;);
-	string title(pDoc-&gt;getTitle());
-	string timestamp(pDoc-&gt;getTimestamp());
-	time_t timeT = TimeConverter::fromTimestamp(timestamp);
-	char tmpStr[64];
-
-	// Set the document data omindex-style
-	record += pDoc-&gt;getLocation();
-	// The sample will be generated at query time
-	record += &quot;\nsample=&quot;;
-	record += &quot;\ncaption=&quot;;
-	if (badRecordField(title) == true)
-	{
-		// Modify the title if necessary
-		string::size_type pos = title.find(&quot;=&quot;);
-		while (pos != string::npos)
-		{
-			title[pos] = ' ';
-			pos = title.find(&quot;=&quot;, pos + 1);
-		}
-#ifdef DEBUG
-		cout &lt;&lt; &quot;XapianDatabase::propsToRecord: modified title&quot; &lt;&lt; endl;
-#endif
-	}
-	record += title;
-	record += &quot;\ntype=&quot;;
-	record += pDoc-&gt;getType();
-	// Append a timestamp, in a format compatible with Omega
-	record += &quot;\nmodtime=&quot;;
-	snprintf(tmpStr, 64, &quot;%ld&quot;, timeT);
-	record += tmpStr;
-	// ...and the language
-	record += &quot;\nlanguage=&quot;;
-	record += pDoc-&gt;getLanguage();
-	// ...and the file size
-	record += &quot;\nsize=&quot;;
-	snprintf(tmpStr, 64, &quot;%ld&quot;, pDoc-&gt;getSize());
-	record += tmpStr;
-#ifdef DEBUG
-	cout &lt;&lt; &quot;XapianDatabase::propsToRecord: document data is &quot; &lt;&lt; record &lt;&lt; endl;
-#endif
-
-	return record;
-}
-
-/// Sets the document's properties acording to the record.
-void XapianDatabase::recordToProps(const string &amp;record, DocumentInfo *pDoc)
-{
-	if (pDoc == NULL)
-	{
-		return;
-	}
-
-	// Get the title
-	pDoc-&gt;setTitle(StringManip::extractField(record, &quot;caption=&quot;, &quot;\n&quot;));
-	// Get the URL
-	string url(StringManip::extractField(record, &quot;url=&quot;, &quot;\n&quot;));
-	if (url.empty() == false)
-	{
-		url = Url::canonicalizeUrl(url);
-	}
-	pDoc-&gt;setLocation(url);
-	// Get the type
-	pDoc-&gt;setType(StringManip::extractField(record, &quot;type=&quot;, &quot;\n&quot;));
-	// ... the language, if available
-	pDoc-&gt;setLanguage(StringManip::extractField(record, &quot;language=&quot;, &quot;\n&quot;));
-	// ... and the timestamp
-	string modTime(StringManip::extractField(record, &quot;modtime=&quot;, &quot;\n&quot;));
-	if (modTime.empty() == false)
-	{
-		time_t timeT = (time_t )atol(modTime.c_str());
-		pDoc-&gt;setTimestamp(TimeConverter::toTimestamp(timeT));
-	}
-	string bytesSize(StringManip::extractField(record, &quot;size=&quot;, &quot;&quot;));
-	if (bytesSize.empty() == false)
-	{
-		pDoc-&gt;setSize((off_t)atol(bytesSize.c_str()));
-	}
-}
-
-/// Returns the URL for the given document in the given index.
-string XapianDatabase::buildUrl(const string &amp;database, unsigned int docId)
-{
-	// Make up a pseudo URL
-	char docIdStr[64];
-	sprintf(docIdStr, &quot;%u&quot;, docId);
-	string url = &quot;<A HREF="xapian://localhost/">xapian://localhost/</A>&quot;;
-	url += database;
-	url += &quot;/&quot;;
-	url += docIdStr;
-
-	return url;
-}
-
-/// Truncates or partially hashes a term.
-string XapianDatabase::limitTermLength(const string &amp;term, bool makeUnique)
-{
-	if (term.length() &gt; XapianDatabase::m_maxTermLength)
-	{
-		if (makeUnique == false)
-		{
-			// Truncate
-			return term.substr(0, XapianDatabase::m_maxTermLength);
-		}
-		else
-		{
-			return StringManip::hashString(term, XapianDatabase::m_maxTermLength);
-		}
-	}
-
-	return term;
-}

Deleted: trunk/Index/XapianDatabase.h
===================================================================
--- trunk/Index/XapianDatabase.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/XapianDatabase.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,100 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _XAPIAN_DATABASE_H
-#define _XAPIAN_DATABASE_H
-
-#include &lt;string&gt;
-#include &lt;set&gt;
-#include &lt;pthread.h&gt;
-#include &lt;xapian.h&gt;
-
-#include &quot;DocumentInfo.h&quot;
-
-/// Lockable Xapian database.
-class XapianDatabase
-{
-	public:
-		XapianDatabase(const std::string &amp;databaseName,
-			bool readOnly = true, bool overwrite = false);
-		XapianDatabase(const std::string &amp;databaseName,
-			XapianDatabase *pFirst, XapianDatabase *pSecond);
-		XapianDatabase(const XapianDatabase &amp;other);
-		virtual ~XapianDatabase();
-
-		XapianDatabase &amp;operator=(const XapianDatabase &amp;other);
-
-		/// Returns false if the database couldn't be opened.
-		bool isOpen(void) const;
-
-		/// Returns true if the database supports spelling.
-		bool withSpelling(void);
-
-		/// Returns false if the database was of an obsolete format.
-		bool wasObsoleteFormat(void) const;
-
-		/// Reopens the database.
-		void reopen(void);
-
-		/// Attempts to lock and retrieve the database.
-		Xapian::Database *readLock(void);
-
-		/// Attempts to lock and retrieve the database.
-		Xapian::WritableDatabase *writeLock(void);
-
-		/// Unlocks the database.
-		void unlock(void);
-
-		/// Returns a record for the document's properties.
-		static std::string propsToRecord(DocumentInfo *pDoc);
-
-		/// Sets the document's properties acording to the record.
-		static void recordToProps(const std::string &amp;record, DocumentInfo *pDoc);
-
-		/// Returns the URL for the given document in the given index.
-		static std::string buildUrl(const std::string &amp;database, unsigned int docId);
-
-		/// Truncates or partially hashes a term.
-		static std::string limitTermLength(const std::string &amp;term, bool makeUnique = false);
-
-	protected:
-		static const unsigned int m_maxTermLength;
-		std::string m_databaseName;
-		bool m_withSpelling;
-		bool m_readOnly;
-		bool m_overwrite;
-		bool m_obsoleteFormat;
-		pthread_mutex_t m_rwLock;
-#ifdef DEBUG
-		pthread_mutexattr_t m_rwLockAttr;
-#endif
-		Xapian::Database *m_pDatabase;
-		bool m_isOpen;
-		bool m_merge;
-		XapianDatabase *m_pFirst;
-		XapianDatabase *m_pSecond;
-
-		void initializeLock(void);
-
-		void openDatabase(void);
-
-		static bool badRecordField(const std::string &amp;field);
-
-};
-
-#endif // _XAPIAN_DATABASE_H

Deleted: trunk/Index/XapianDatabaseFactory.cpp
===================================================================
--- trunk/Index/XapianDatabaseFactory.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/XapianDatabaseFactory.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,156 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;iostream&gt;
-
-#include &quot;XapianDatabaseFactory.h&quot;
-
-using std::cout;
-using std::endl;
-using std::string;
-using std::map;
-using std::pair;
-
-pthread_mutex_t XapianDatabaseFactory::m_mutex = PTHREAD_MUTEX_INITIALIZER;
-map&lt;string, XapianDatabase *&gt; XapianDatabaseFactory::m_databases;
-
-XapianDatabaseFactory::XapianDatabaseFactory()
-{
-}
-
-XapianDatabaseFactory::~XapianDatabaseFactory()
-{
-}
-
-/// Merges two databases together and add the result to the list.
-bool XapianDatabaseFactory::mergeDatabases(const string &amp;name,
-	XapianDatabase *pFirst, XapianDatabase *pSecond)
-{
-	map&lt;string, XapianDatabase *&gt;::iterator dbIter = m_databases.find(name);
-	if (dbIter != m_databases.end())
-	{
-		return false;
-	}
-
-	// Create the new database
-	XapianDatabase *pDb = new XapianDatabase(name, pFirst, pSecond);
-
-	// Insert it into the map
-	pair&lt;map&lt;string, XapianDatabase *&gt;::iterator, bool&gt; insertPair = m_databases.insert(pair&lt;string, XapianDatabase *&gt;(name, pDb));
-	// Was it inserted ?
-	if (insertPair.second == false)
-	{
-		// No, it wasn't : delete the object
-		delete pDb;
-
-		return false;
-	}
-
-	return true;
-}
-
-/// Returns a XapianDatabase pointer; NULL if unavailable.
-XapianDatabase *XapianDatabaseFactory::getDatabase(const string &amp;location,
-	bool readOnly, bool overwrite)
-{
-	XapianDatabase *pDb = NULL;
-
-	if (location.empty() == true)
-	{
-		return NULL;
-	}
-
-	// Lock the map
-	if (pthread_mutex_lock(&amp;m_mutex) != 0)
-	{
-		return NULL;
-	}
-
-	// Is the database already open ?
-	map&lt;string, XapianDatabase *&gt;::iterator dbIter = m_databases.find(location);
-	if (dbIter != m_databases.end())
-	{
-		pDb = dbIter-&gt;second;
-
-		// Overwrite the database ?
-		if (overwrite == true)
-		{
-			dbIter-&gt;second = NULL;
-#ifdef DEBUG
-			cout &lt;&lt; &quot;XapianDatabaseFactory::getDatabase: closing &quot; &lt;&lt; dbIter-&gt;first &lt;&lt; endl;
-#endif
-			m_databases.erase(dbIter);
-			delete pDb;
-
-			dbIter = m_databases.end();
-		}
-	}
-
-	// Open the database ?
-	if (dbIter == m_databases.end())
-	{
-		// Create a new instance
-		pDb = new XapianDatabase(location, readOnly, overwrite);
-		// Insert it into the map
-		pair&lt;map&lt;string, XapianDatabase *&gt;::iterator, bool&gt; insertPair = m_databases.insert(pair&lt;string, XapianDatabase *&gt;(location, pDb));
-		// Was it inserted ?
-		if (insertPair.second == false)
-		{
-			// No, it wasn't : delete the object
-			delete pDb;
-			pDb = NULL;
-		}
-	}
-
-	// Unlock the map
-	pthread_mutex_unlock(&amp;m_mutex);
-
-	return pDb;
-}
-
-/// Closes all databases.
-void XapianDatabaseFactory::closeAll(void)
-{
-	if (m_databases.empty() == true)
-	{
-		return;
-	}
-
-	// Lock the map
-	if (pthread_mutex_lock(&amp;m_mutex) != 0)
-	{
-		return;
-	}
-
-	std::map&lt;std::string, XapianDatabase *&gt;::iterator dbIter = m_databases.begin();
-	while (dbIter != m_databases.end())
-	{
-		XapianDatabase *pDb = dbIter-&gt;second;
-		dbIter-&gt;second = NULL;
-#ifdef DEBUG
-		cout &lt;&lt; &quot;XapianDatabaseFactory::closeAll: closing &quot; &lt;&lt; dbIter-&gt;first &lt;&lt; endl;
-#endif
-		m_databases.erase(dbIter);
-		delete pDb;
-
-		dbIter = m_databases.begin();
-	}
-
-	// Unlock the map
-	pthread_mutex_unlock(&amp;m_mutex);
-}

Deleted: trunk/Index/XapianDatabaseFactory.h
===================================================================
--- trunk/Index/XapianDatabaseFactory.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/XapianDatabaseFactory.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,57 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _XAPIAN_DATABASE_FACTORY_H
-#define _XAPIAN_DATABASE_FACTORY_H
-
-#include &lt;string&gt;
-#include &lt;map&gt;
-#include &lt;pthread.h&gt;
-
-#include &quot;XapianDatabase.h&quot;
-
-/// Factory for Xapian database objects.
-class XapianDatabaseFactory
-{
-	public:
-		virtual ~XapianDatabaseFactory();
-
-		/// Merges two databases together and add the result to the list.
-		static bool mergeDatabases(const std::string &amp;name,
-			XapianDatabase *pFirst, XapianDatabase *pSecond);
-
-		/// Returns a XapianDatabase pointer; NULL if unavailable.
-		static XapianDatabase *getDatabase(const std::string &amp;location,
-			bool readOnly = true, bool overwrite = false);
-
-		/// Closes all databases.
-		static void closeAll(void);
-
-	protected:
-		static pthread_mutex_t m_mutex;
-		static std::map&lt;std::string, XapianDatabase *&gt; m_databases;
-
-		XapianDatabaseFactory();
-
-	private:
-		XapianDatabaseFactory(const XapianDatabaseFactory &amp;other);
-		XapianDatabaseFactory &amp;operator=(const XapianDatabaseFactory &amp;other);
-
-};
-
-#endif // _XAPIAN_DATABASE_FACTORY_H

Deleted: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/XapianIndex.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,1957 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;fcntl.h&gt;
-#include &lt;ctype.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;stdarg.h&gt;
-#include &lt;strings.h&gt;
-#include &lt;time.h&gt;
-#include &lt;ctype.h&gt;
-#include &lt;iostream&gt;
-#include &lt;fstream&gt;
-#include &lt;algorithm&gt;
-#include &lt;utility&gt;
-#include &lt;xapian.h&gt;
-
-#include &quot;Languages.h&quot;
-#include &quot;StringManip.h&quot;
-#include &quot;TimeConverter.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;LanguageDetector.h&quot;
-#include &quot;XapianDatabaseFactory.h&quot;
-#include &quot;XapianIndex.h&quot;
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::ios;
-using std::ifstream;
-using std::ofstream;
-using std::string;
-using std::vector;
-using std::set;
-using std::map;
-using std::min;
-using std::max;
-
-static bool setVersionFile(const string &amp;databaseName, const string &amp;version)
-{
-	ofstream verFile;
-	string verFileName(databaseName + &quot;/version&quot;);
-	bool setVer = false;
-
-	verFile.open(verFileName.c_str(), ios::trunc);
-	if (verFile.good() == true)
-	{
-		verFile &lt;&lt; version;
-		setVer = true;
-	}
-	verFile.close();
-
-	return setVer;
-}
-
-static string getVersionFromFile(const string &amp;databaseName)
-{
-	ifstream verFile;
-	string verFileName(databaseName + &quot;/version&quot;);
-	string version;
-
-	verFile.open(verFileName.c_str());
-	if (verFile.good() == true)
-	{
-		verFile &gt;&gt; version;
-	}
-	verFile.close();
-
-	return version;
-}
-
-const string XapianIndex::MAGIC_TERM = &quot;X-MetaSE-Doc&quot;;
-
-XapianIndex::XapianIndex(const string &amp;indexName) :
-	IndexInterface(),
-	m_databaseName(indexName),
-	m_goodIndex(false),
-	m_doSpelling(true)
-{
-	// Open in read-only mode
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if ((pDatabase != NULL) &amp;&amp;
-		(pDatabase-&gt;isOpen() == true))
-	{
-		m_goodIndex = true;
-		m_doSpelling = pDatabase-&gt;withSpelling();
-	}
-}
-
-XapianIndex::XapianIndex(const XapianIndex &amp;other) :
-	IndexInterface(other),
-	m_databaseName(other.m_databaseName),
-	m_goodIndex(other .m_goodIndex),
-	m_doSpelling(other.m_doSpelling),
-	m_stemLanguage(other.m_stemLanguage)
-{
-}
-
-XapianIndex::~XapianIndex()
-{
-}
-
-XapianIndex &amp;XapianIndex::operator=(const XapianIndex &amp;other)
-{
-	if (this != &amp;other)
-	{
-		IndexInterface::operator=(other);
-		m_databaseName = other.m_databaseName;
-		m_goodIndex = other .m_goodIndex;
-		m_doSpelling = other.m_doSpelling;
-		m_stemLanguage = other.m_stemLanguage;
-	}
-
-	return *this;
-}
-
-bool XapianIndex::listDocumentsWithTerm(const string &amp;term, set&lt;unsigned int&gt; &amp;docIds,
-	unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	unsigned int docCount = 0;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return 0;
-	}
-
-	docIds.clear();
-	try
-	{
-		Xapian::Database *pIndex = pDatabase-&gt;readLock();
-		if (pIndex != NULL)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;XapianIndex::listDocumentsWithTerm: term &quot; &lt;&lt; term &lt;&lt; endl;
-#endif
-			// Get a list of documents that have the term
-			for (Xapian::PostingIterator postingIter = pIndex-&gt;postlist_begin(term);
-				(postingIter != pIndex-&gt;postlist_end(term)) &amp;&amp;
-					((maxDocsCount == 0) || (docIds.size() &lt; maxDocsCount));
-				++postingIter)
-			{
-				Xapian::docid docId = *postingIter;
-
-				// We cannot use postingIter-&gt;skip_to() because startDoc isn't an ID
-				if (docCount &gt;= startDoc)
-				{
-					docIds.insert(docId);
-				}
-				++docCount;
-			}
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't get document list: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't get document list, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return docIds.size();
-}
-
-void XapianIndex::addPostingsToDocument(const Xapian::Utf8Iterator &amp;itor, Xapian::Document &amp;doc,
-	const Xapian::WritableDatabase &amp;db, const string &amp;prefix, bool noStemming)
-{
-	Xapian::Stem *pStemmer = NULL;
-	Xapian::TermGenerator generator;
-
-	// Do we know what language to use for stemming ?
-	if ((noStemming == false) &amp;&amp;
-		(m_stemLanguage.empty() == false))
-	{
-		try
-		{
-			pStemmer = new Xapian::Stem(StringManip::toLowerCase(m_stemLanguage));
-		}
-		catch (const Xapian::Error &amp;error)
-		{
-			cerr &lt;&lt; &quot;Couldn't create stemmer: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-		}
-
-		if (pStemmer != NULL)
-		{
-			generator.set_stemmer(*pStemmer);
-		}
-	}
-
-	try
-	{
-		// Older Xapian backends don't support spelling correction
-		if (m_doSpelling == true)
-		{
-			// The database is required for the spelling dictionary
-			generator.set_flags(Xapian::TermGenerator::FLAG_SPELLING);
-			generator.set_database(db);
-		}
-		generator.set_document(doc);
-		generator.index_text(itor, 1, prefix);
-	}
-	catch (const Xapian::UnimplementedError &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't index with spelling correction: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-
-		if (m_doSpelling == true)
-		{
-			m_doSpelling = false;
-
-			// Try again without spelling correction
-			// Let the caller catch the exception
-			generator.set_flags(Xapian::TermGenerator::FLAG_SPELLING, Xapian::TermGenerator::FLAG_SPELLING);
-			generator.set_document(doc);
-			generator.index_text(itor, 1, prefix);
-		}
-	}
-
-	if (pStemmer != NULL)
-	{
-		delete pStemmer;
-	}
-}
-
-void XapianIndex::removePostingsFromDocument(const Xapian::Utf8Iterator &amp;itor, Xapian::Document &amp;doc,
-	const string &amp;prefix, const string &amp;language, bool noStemming) const
-{
-	Xapian::Document termsDoc;
-	Xapian::TermGenerator generator;
-	Xapian::Stem *pStemmer = NULL;
-	string stemPrefix(&quot;Z&quot;);
-	string term;
-
-	// Do we know what language to use for stemming ?
-	if ((noStemming == false) &amp;&amp;
-		(language.empty() == false))
-	{
-		try
-		{
-			pStemmer = new Xapian::Stem(StringManip::toLowerCase(m_stemLanguage));
-		}
-		catch (const Xapian::Error &amp;error)
-		{
-			cerr &lt;&lt; &quot;Couldn't create stemmer: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-		}
-
-		if (pStemmer != NULL)
-		{
-			generator.set_stemmer(*pStemmer);
-		}
-	}
-
-	// This temporary document enables to get to the same terms
-	// that were added at indexing time
-	generator.set_document(termsDoc);
-	generator.index_text(itor, 1, prefix);
-
-	// Get the terms and remove the first posting for each
-	for (Xapian::TermIterator termListIter = termsDoc.termlist_begin();
-		termListIter != termsDoc.termlist_end(); ++termListIter)
-	{
-		Xapian::termcount postingsCount = termListIter.positionlist_count();
-		Xapian::termcount postingNum = 0;
-		bool removeTerm = false;
-
-#ifdef DEBUG
-		cout &lt;&lt; &quot;XapianIndex::removePostingsFromDocument: term &quot; &lt;&lt; *termListIter
-			&lt;&lt; &quot; has &quot; &lt;&lt; postingsCount &lt;&lt; &quot; postings&quot; &lt;&lt; endl;
-#endif
-		// If a prefix is defined, or there are no postings, we can afford removing the term
-		if ((prefix.empty() == false) ||
-			(postingsCount == 0))
-		{
-			removeTerm = true;
-		}
-		else
-		{
-			// Check whether this term is in the original document and how many postings it has
-			Xapian::TermIterator termIter = doc.termlist_begin();
-			if (termIter != doc.termlist_end())
-			{
-				termIter.skip_to(*termListIter);
-				if (termIter != doc.termlist_end())
-				{
-					if (*termIter != *termListIter)
-					{
-						// This term doesn't exist in the document !
-#ifdef DEBUG
-						cout &lt;&lt; &quot;XapianIndex::removePostingsFromDocument: no such term&quot; &lt;&lt; endl;
-#endif
-						continue;
-					}
-
-					if (termIter.positionlist_count() &lt;= postingsCount)
-					{
-						// All postings are to be removed, so we can remove the term
-#ifdef DEBUG
-						cout &lt;&lt; &quot;XapianIndex::removePostingsFromDocument: no extra posting&quot; &lt;&lt; endl;
-#endif
-						removeTerm = true;
-					}
-				}
-			}
-		}
-
-		if (removeTerm == true)
-		{
-			try
-			{
-				doc.remove_term(*termListIter);
-			}
-			catch (const Xapian::Error &amp;error)
-			{
-#ifdef DEBUG
-				cout &lt;&lt; &quot;XapianIndex::removePostingsFromDocument: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-#endif
-			}
-			continue;
-		}
-
-		// Otherwise, remove the first N postings
-		// FIXME: if all the postings are in the range associated with the metadata
-		// as opposed to the actual data, the term can be removed altogether
-		for (Xapian::PositionIterator firstPosIter = termListIter.positionlist_begin();
-			firstPosIter != termListIter.positionlist_end(); ++firstPosIter)
-		{
-			if (postingNum &gt;= postingsCount)
-			{
-				break;
-			}
-			++postingNum;
-
-			try
-			{
-				doc.remove_posting(*termListIter, *firstPosIter);
-			}
-			catch (const Xapian::Error &amp;error)
-			{
-				// This posting may have been removed already
-#ifdef DEBUG
-				cout &lt;&lt; &quot;XapianIndex::removePostingsFromDocument: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-#endif
-			}
-		}
-	}
-
-	if (pStemmer != NULL)
-	{
-		delete pStemmer;
-	}
-}
-
-void XapianIndex::addCommonTerms(const DocumentInfo &amp;info, Xapian::Document &amp;doc,
-	const Xapian::WritableDatabase &amp;db)
-{
-	string title(info.getTitle());
-	string location(info.getLocation());
-	Url urlObj(location);
-
-	// Add a magic term :-)
-	doc.add_term(MAGIC_TERM);
-
-	// Index the title with and without prefix S
-	if (title.empty() == false)
-	{
-		addPostingsToDocument(Xapian::Utf8Iterator(title), doc, db, &quot;S&quot;, true);
-		addPostingsToDocument(Xapian::Utf8Iterator(title), doc, db, &quot;&quot;, false);
-	}
-
-	// Index the full URL with prefix U
-	doc.add_term(string(&quot;U&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(location), true));
-	// ...the base file with XFILE:
-	string::size_type qmPos = location.find(&quot;?&quot;);
-	if ((urlObj.isLocal() == true) &amp;&amp;
-		(qmPos != string::npos))
-	{
-		string fileUrl(location.substr(0, qmPos));
-		string protocol(urlObj.getProtocol());
-
-		doc.add_term(string(&quot;XFILE:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(fileUrl), true));
-		if ((urlObj.isLocal() == true) &amp;&amp;
-			(protocol != &quot;file&quot;))
-		{
-			// Add another term with file as protocol
-			fileUrl.replace(0, protocol.length(), &quot;file&quot;);
-			doc.add_term(string(&quot;XFILE:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(fileUrl), true));
-		}
-	}
-	// ...the host name and included domains with prefix H
-	string hostName(StringManip::toLowerCase(urlObj.getHost()));
-	if (hostName.empty() == false)
-	{
-		doc.add_term(string(&quot;H&quot;) + XapianDatabase::limitTermLength(hostName, true));
-		string::size_type dotPos = hostName.find('.');
-		while (dotPos != string::npos)
-		{
-			doc.add_term(string(&quot;H&quot;) + XapianDatabase::limitTermLength(hostName.substr(dotPos + 1), true));
-
-			// Next
-			dotPos = hostName.find('.', dotPos + 1);
-		}
-	}
-	// ...the location (as is) and all directories with prefix XDIR:
-	string tree(urlObj.getLocation());
-	if (tree.empty() == false)
-	{
-		doc.add_term(string(&quot;XDIR:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(tree), true));
-		if (tree[0] == '/')
-		{
-			doc.add_term(&quot;XDIR:/&quot;);
-		}
-		string::size_type slashPos = tree.find('/', 1);
-		while (slashPos != string::npos)
-		{
-			doc.add_term(string(&quot;XDIR:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(tree.substr(0, slashPos)), true));
-
-			// Next
-			slashPos = tree.find('/', slashPos + 1);
-		}
-	}
-	// ...and the file name with prefix P
-	string fileName(urlObj.getFile());
-	if (fileName.empty() == false)
-	{
-		string extension;
-
-		doc.add_term(string(&quot;P&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(fileName), true));
-
-		// Does it have an extension ?
-		string::size_type extPos = fileName.rfind('.');
-		if ((extPos != string::npos) &amp;&amp;
-			(extPos + 1 &lt; fileName.length()))
-		{
-			extension = StringManip::toLowerCase(fileName.substr(extPos + 1));
-		}
-		doc.add_term(string(&quot;XEXT:&quot;) + XapianDatabase::limitTermLength(extension));
-	}
-	// Finally, add the language code with prefix L
-	doc.add_term(string(&quot;L&quot;) + Languages::toCode(m_stemLanguage));
-	// ...and the MIME type with prefix T
-	doc.add_term(string(&quot;T&quot;) + info.getType());
-}
-
-void XapianIndex::removeCommonTerms(Xapian::Document &amp;doc)
-{
-	DocumentInfo docInfo;
-	set&lt;string&gt; commonTerms;
-	string record(doc.get_data());
-
-	// First, remove the magic term
-	commonTerms.insert(MAGIC_TERM);
-
-	if (record.empty() == true)
-        {
-		// Nothing else we can do
-		return;
-	}
-
-	string language(StringManip::extractField(record, &quot;language=&quot;, &quot;\n&quot;));
-
-	docInfo = DocumentInfo(StringManip::extractField(record, &quot;caption=&quot;, &quot;\n&quot;),
-		StringManip::extractField(record, &quot;url=&quot;, &quot;\n&quot;),
-		StringManip::extractField(record, &quot;type=&quot;, &quot;\n&quot;),
-		Languages::toLocale(language));
-	string modTime(StringManip::extractField(record, &quot;modtime=&quot;, &quot;\n&quot;));
-	if (modTime.empty() == false)
-	{
-		time_t timeT = (time_t )atol(modTime.c_str());
-		docInfo.setTimestamp(TimeConverter::toTimestamp(timeT));
-	}
-	string bytesSize(StringManip::extractField(record, &quot;size=&quot;, &quot;&quot;));
-	if (bytesSize.empty() == false)
-	{
-		docInfo.setSize((off_t )atol(bytesSize.c_str()));
-	}
-	Url urlObj(docInfo.getLocation());
-
-	// FIXME: remove terms extracted from the title if they don't have more than one posting
-	string title(docInfo.getTitle());
-	if (title.empty() == false)
-	{
-		removePostingsFromDocument(Xapian::Utf8Iterator(title), doc, &quot;S&quot;, language, true);
-		removePostingsFromDocument(Xapian::Utf8Iterator(title), doc, &quot;&quot;, language, false);
-	}
-
-	// Location 
-	string location(docInfo.getLocation());
-	commonTerms.insert(string(&quot;U&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(location), true));
-	// Base file
-	string::size_type qmPos = location.find(&quot;?&quot;);
-	if ((urlObj.isLocal() == true) &amp;&amp;
-		(qmPos != string::npos))
-	{
-		string fileUrl(location.substr(0, qmPos));
-		string protocol(urlObj.getProtocol());
-
-		commonTerms.insert(string(&quot;XFILE:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(fileUrl), true));
-
-		if ((urlObj.isLocal() == true) &amp;&amp;
-			(protocol != &quot;file&quot;))
-		{
-			// Add another term with file as protocol
-			fileUrl.replace(0, protocol.length(), &quot;file&quot;);
-			doc.add_term(string(&quot;XFILE:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(fileUrl), true));
-		}
-	}
-	// Host name
-	string hostName(StringManip::toLowerCase(urlObj.getHost()));
-	if (hostName.empty() == false)
-	{
-		commonTerms.insert(string(&quot;H&quot;) + XapianDatabase::limitTermLength(hostName, true));
-		string::size_type dotPos = hostName.find('.');
-		while (dotPos != string::npos)
-		{
-			commonTerms.insert(string(&quot;H&quot;) + XapianDatabase::limitTermLength(hostName.substr(dotPos + 1), true));
-
-			// Next
-			dotPos = hostName.find('.', dotPos + 1);
-		}
-	}
-	// ...location
-	string tree(urlObj.getLocation());
-	if (tree.empty() == false)
-	{
-		commonTerms.insert(string(&quot;XDIR:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(tree), true));
-		if (tree[0] == '/')
-		{
-			commonTerms.insert(&quot;XDIR:/&quot;);
-		}
-		string::size_type slashPos = tree.find('/', 1);
-		while (slashPos != string::npos)
-		{
-			commonTerms.insert(string(&quot;XDIR:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(tree.substr(0, slashPos)), true));
-
-			// Next
-			slashPos = tree.find('/', slashPos + 1);
-		}
-	}
-	// ...and file name
-	string fileName(urlObj.getFile());
-	if (fileName.empty() == false)
-	{
-		string extension;
-
-		commonTerms.insert(string(&quot;P&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(fileName), true));
-
-		// Does it have an extension ?
-		string::size_type extPos = fileName.rfind('.');
-		if ((extPos != string::npos) &amp;&amp;
-			(extPos + 1 &lt; fileName.length()))
-		{
-			extension = StringManip::toLowerCase(fileName.substr(extPos + 1));
-		}
-		commonTerms.insert(string(&quot;XEXT:&quot;) + XapianDatabase::limitTermLength(extension));
-	}
-	// Language code
-	commonTerms.insert(string(&quot;L&quot;) + Languages::toCode(language));
-	// MIME type
-	commonTerms.insert(string(&quot;T&quot;) + docInfo.getType());
-
-	for (set&lt;string&gt;::const_iterator termIter = commonTerms.begin(); termIter != commonTerms.end(); ++termIter)
-	{
-		try
-		{
-			doc.remove_term(*termIter);
-		}
-		catch (const Xapian::Error &amp;error)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;XapianIndex::removeCommonTerms: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-#endif
-		}
-	}
-}
-
-string XapianIndex::scanDocument(const char *pData, unsigned int dataLength,
-	DocumentInfo &amp;info)
-{
-	vector&lt;string&gt; candidates;
-	string language;
-
-	// Try to determine the document's language
-	LanguageDetector lang;
-	lang.guessLanguage(pData, max(dataLength, (unsigned int)2048), candidates);
-
-	// See which of these languages is suitable for stemming
-	for (vector&lt;string&gt;::iterator langIter = candidates.begin(); langIter != candidates.end(); ++langIter)
-	{
-		if (*langIter == &quot;unknown&quot;)
-		{
-			continue;
-		}
-
-		try
-		{
-			Xapian::Stem stemmer(*langIter);
-		}
-		catch (const Xapian::Error &amp;error)
-		{
-			cerr &lt;&lt; &quot;Couldn't create stemmer: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-			continue;
-		}
-
-		language = *langIter;
-		break;
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;XapianIndex::scanDocument: language &quot; &lt;&lt; language &lt;&lt; endl;
-#endif
-
-	// Update the document's properties
-	info.setLanguage(language);
-
-	return language;
-}
-
-void XapianIndex::setDocumentData(const DocumentInfo &amp;info, Xapian::Document &amp;doc,
-	const string &amp;language) const
-{
-	time_t timeT = TimeConverter::fromTimestamp(info.getTimestamp());
-	struct tm *tm = localtime(&amp;timeT);
-	string yyyymmdd(TimeConverter::toYYYYMMDDString(tm-&gt;tm_year + 1900, tm-&gt;tm_mon + 1, tm-&gt;tm_mday));
-	string hhmmss(TimeConverter::toHHMMSSString(tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec));
-
-	// Date
-	doc.add_value(0, yyyymmdd);
-	// FIXME: checksum in value 1
-	// Size
-	doc.add_value(2, Xapian::sortable_serialise((double )info.getSize()));
-	// Time
-	doc.add_value(3, hhmmss);
-	// Date and time, for results sorting
-	doc.add_value(4, yyyymmdd + hhmmss);
-
-	DocumentInfo docCopy(info);
-	// XapianDatabase expects the language in English, which is okay here
-	docCopy.setLanguage(language);
-	doc.set_data(XapianDatabase::propsToRecord(&amp;docCopy));
-}
-
-bool XapianIndex::deleteDocuments(const string &amp;term)
-{
-	bool unindexed = false;
-
-	if (term.empty() == true)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
-		if (pIndex != NULL)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;XapianIndex::deleteDocuments: term is &quot; &lt;&lt; term &lt;&lt; endl;
-#endif
-
-			// Delete documents from the index
-			pIndex-&gt;delete_document(term);
-
-			unindexed = true;
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't unindex documents: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't unindex documents, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return unindexed;
-}
-
-//
-// Implementation of IndexInterface
-//
-
-/// Returns false if the index couldn't be opened.
-bool XapianIndex::isGood(void) const
-{
-	return m_goodIndex;
-}
-
-/// Gets the version number.
-string XapianIndex::getVersion(void) const
-{
-	string version(&quot;0.00&quot;);
-
-#if ENABLE_XAPIAN_DB_METADATA&gt;0
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase-&gt;readLock();
-		if (pIndex != NULL)
-		{
-			// If this index type doesn't support metadata, no exception will be thrown
-			// We will just get an empty string
-			version = pIndex-&gt;get_metadata(&quot;version&quot;);
-			if (version.empty() == true)
-			{
-				// Is there a pre-0.80 version file ?
-				version = getVersionFromFile(m_databaseName);
-				if (version.empty() == true)
-				{
-					version = &quot;0.00&quot;;
-				}
-			}
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't get database version: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't get database version, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-#else
-	version = getVersionFromFile(m_databaseName);
-#endif
-
-	return version;
-}
-
-/// Sets the version number.
-bool XapianIndex::setVersion(const string &amp;version) const
-{
-	bool setVer = false;
-
-#if ENABLE_XAPIAN_DB_METADATA&gt;0
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
-		if (pIndex != NULL)
-		{
-			pIndex-&gt;set_metadata(&quot;version&quot;, version);
-			setVer = true;
-		}
-	}
-	catch (const Xapian::UnimplementedError &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't set database version, no support for metadata: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-		// Revert to a version file
-		setVer = setVersionFile(m_databaseName, version);
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't set database version: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't set database version, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-#else
-	setVer = setVersionFile(m_databaseName, version);
-#endif
-
-	// While we are at it, create a CACHEDIR.TAG file
-	// See the spec at <A HREF="http://www.brynosaurus.com/cachedir/">http://www.brynosaurus.com/cachedir/</A>
-	string cacheDirFileName(m_databaseName + &quot;/CACHEDIR.TAG&quot;);
-	ofstream cacheDirFile;
-	cacheDirFile.open(cacheDirFileName.c_str(), ios::trunc);
-	if (cacheDirFile.good() == true)
-	{
-		cacheDirFile &lt;&lt; &quot;Signature: 8a477f597d28d172789f06886806bc55&quot; &lt;&lt; endl;
-		cacheDirFile &lt;&lt; &quot;# This file is a cache directory tag created by Pinot.&quot; &lt;&lt; endl;
-		cacheDirFile &lt;&lt; &quot;# For information about cache directory tags, see:&quot; &lt;&lt; endl;
-		cacheDirFile &lt;&lt; &quot;# <A HREF="http://www.brynosaurus.com/cachedir/">http://www.brynosaurus.com/cachedir/</A>&quot; &lt;&lt; endl;
-	}
-	cacheDirFile.close();
-
-	return setVer;
-}
-
-/// Gets the index location.
-string XapianIndex::getLocation(void) const
-{
-	return m_databaseName;
-}
-
-/// Returns a document's properties.
-bool XapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &amp;docInfo) const
-{
-	bool foundDocument = false;
-
-	if (docId == 0)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase-&gt;readLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc = pIndex-&gt;get_document(docId);
-			string record(doc.get_data());
-
-			// Get the current document data
-			if (record.empty() == false)
-			{
-				XapianDatabase::recordToProps(record, &amp;docInfo);
-				// XapianDatabase stored the language in English
-				docInfo.setLanguage(Languages::toLocale(docInfo.getLanguage()));
-				foundDocument = true;
-			}
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't get document properties: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't get document properties, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return foundDocument;
-}
-
-/// Returns a document's terms count.
-unsigned int XapianIndex::getDocumentTermsCount(unsigned int docId) const
-{
-	unsigned int termsCount = 0;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return 0;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase-&gt;readLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc = pIndex-&gt;get_document(docId);
-
-			termsCount = doc.termlist_count();
-#ifdef DEBUG
-			cout &lt;&lt; &quot;XapianIndex::getDocumentTermsCount: &quot; &lt;&lt; termsCount &lt;&lt; &quot; terms in document &quot; &lt;&lt; docId &lt;&lt; endl;
-#endif
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't get document terms count: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't get document terms count, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return termsCount;
-}
-
-/// Returns a document's terms.
-bool XapianIndex::getDocumentTerms(unsigned int docId, map&lt;unsigned int, string&gt; &amp;wordsBuffer) const
-{
-	vector&lt;string&gt; noPosTerms;
-	bool gotTerms = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase-&gt;readLock();
-		if (pIndex != NULL)
-		{
-			unsigned int lastPos = 0;
-
-			// Go through the position list of each term
-			for (Xapian::TermIterator termIter = pIndex-&gt;termlist_begin(docId);
-				termIter != pIndex-&gt;termlist_end(docId); ++termIter)
-			{
-				string termName(*termIter);
-				char firstChar = termName[0];
-				bool hasPositions = false;
-
-				// Is it prefixed ?
-				if (isupper((int)firstChar) != 0)
-				{
-					// Skip X-prefixed terms
-					if (firstChar == 'X')
-					{
-#ifdef DEBUG
-						cout &lt;&lt; &quot;XapianIndex::getDocumentTerms: skipping &quot; &lt;&lt; termName &lt;&lt; endl;
-#endif
-						continue;
-					}
-
-					// Keep other prefixed terms (S, U, H, P, L, T...)
-					termName.erase(0, 1);
-				}
-
-				for (Xapian::PositionIterator positionIter = pIndex-&gt;positionlist_begin(docId, *termIter);
-					positionIter != pIndex-&gt;positionlist_end(docId, *termIter); ++positionIter)
-				{
-					wordsBuffer[*positionIter] = termName;
-					if (*positionIter &gt; lastPos)
-					{
-						lastPos = *positionIter;
-					}
-					hasPositions = true;
-				}
-
-				if (hasPositions == false)
-				{
-					noPosTerms.push_back(termName);
-				}
-
-				gotTerms = true;
-			}
-
-			// Append terms without positional information as if they were at the end of the document
-			for (vector&lt;string&gt;::const_iterator noPosIter = noPosTerms.begin();
-				noPosIter != noPosTerms.end(); ++noPosIter)
-			{
-				wordsBuffer[lastPos] = *noPosIter;
-				++lastPos;
-			}
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't get document terms: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't get document terms, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return gotTerms;
-}
-
-/// Sets the list of known labels.
-bool XapianIndex::setLabels(const set&lt;string&gt; &amp;labels)
-{
-	bool setLabels = false;
-
-#if ENABLE_XAPIAN_DB_METADATA&gt;0
-	string labelString;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	for (set&lt;string&gt;::const_iterator labelIter = labels.begin();
-		labelIter != labels.end(); ++labelIter)
-	{
-		// Prevent from setting internal labels
-		if (labelIter-&gt;substr(0, 2) == &quot;X-&quot;)
-		{
-			continue;
-		}
-		labelString += &quot;[&quot;;
-		labelString += Url::escapeUrl(*labelIter);
-		labelString += &quot;]&quot;;
-	}
-
-	try
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;XapianIndex::setLabels: &quot; &lt;&lt; labels.size() &lt;&lt; &quot; labels&quot; &lt;&lt; endl;
-#endif
-		Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
-		if (pIndex != NULL)
-		{
-			pIndex-&gt;set_metadata(&quot;labels&quot;, labelString);
-			setLabels = true;
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't set database labels: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't set database labels, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-#endif
-
-	return setLabels;
-}
-
-/// Gets the list of known labels.
-bool XapianIndex::getLabels(set&lt;string&gt; &amp;labels) const
-{
-#if ENABLE_XAPIAN_DB_METADATA&gt;0
-	string labelsString;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase-&gt;readLock();
-		if (pIndex != NULL)
-		{
-			labelsString = pIndex-&gt;get_metadata(&quot;labels&quot;);
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't get database labels: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't get database labels, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	if (labelsString.empty() == false)
-	{
-		string::size_type endPos = 0;
-		string label(StringManip::extractField(labelsString, &quot;[&quot;, &quot;]&quot;, endPos));
-
-		while (label.empty() == false)
-		{
-			labels.insert(Url::unescapeUrl(label));
-
-			if (endPos == string::npos)
-			{
-				break;
-			}
-			label = StringManip::extractField(labelsString, &quot;[&quot;, &quot;]&quot;, endPos);
-		}
-
-		return true;
-	}
-#endif
-
-	return false;
-}
-
-/// Adds a label.
-bool XapianIndex::addLabel(const string &amp;name)
-{
-	// Nothing to do here
-	return false;
-}
-
-/// Renames a label.
-bool XapianIndex::renameLabel(const string &amp;name, const string &amp;newName)
-{
-	bool renamedLabel = false;
-
-	// Prevent from renaming or setting internal labels
-	if ((name.substr(0, 2) == &quot;X-&quot;) ||
-		(newName.substr(0, 2) == &quot;X-&quot;))
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
-		if (pIndex != NULL)
-		{
-			string term(&quot;XLABEL:&quot;);
-
-			// Get documents that have this label
-			term += XapianDatabase::limitTermLength(Url::escapeUrl(name));
-			for (Xapian::PostingIterator postingIter = pIndex-&gt;postlist_begin(term);
-				postingIter != pIndex-&gt;postlist_end(term); ++postingIter)
-			{
-				Xapian::docid docId = *postingIter;
-
-				// Get the document
-				Xapian::Document doc = pIndex-&gt;get_document(docId);
-				// Remove the term
-				doc.remove_term(term);
-				// ...add the new one
-				doc.add_term(string(&quot;XLABEL:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(newName)));
-				// ...and update the document
-				pIndex-&gt;replace_document(docId, doc);
-			}
-
-			renamedLabel = true;
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't delete label: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't delete label, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return renamedLabel;
-}
-
-/// Deletes all references to a label.
-bool XapianIndex::deleteLabel(const string &amp;name)
-{
-	bool deletedLabel = false;
-
-	// Prevent from deleting internal labels
-	if (name.substr(0, 2) == &quot;X-&quot;)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
-		if (pIndex != NULL)
-		{
-			string term(&quot;XLABEL:&quot;);
-
-			// Get documents that have this label
-			term += XapianDatabase::limitTermLength(Url::escapeUrl(name));
-			for (Xapian::PostingIterator postingIter = pIndex-&gt;postlist_begin(term);
-				postingIter != pIndex-&gt;postlist_end(term); ++postingIter)
-			{
-				Xapian::docid docId = *postingIter;
-
-				// Get the document
-				Xapian::Document doc = pIndex-&gt;get_document(docId);
-				// Remove the term
-				doc.remove_term(term);
-				// ...and update the document
-				pIndex-&gt;replace_document(docId, doc);
-			}
-			deletedLabel = true;
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't delete label: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't delete label, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return deletedLabel;
-}
-
-/// Determines whether a document has a label.
-bool XapianIndex::hasLabel(unsigned int docId, const string &amp;name) const
-{
-	bool foundLabel = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase-&gt;readLock();
-		if (pIndex != NULL)
-		{
-			string term(&quot;XLABEL:&quot;);
-
-			// Get documents that have this label
-			// FIXME: would it be faster to get the document's terms ?
-			term += XapianDatabase::limitTermLength(Url::escapeUrl(name));
-			Xapian::PostingIterator postingIter = pIndex-&gt;postlist_begin(term);
-			if (postingIter != pIndex-&gt;postlist_end(term))
-			{
-				// Is this document in the list ?
-				postingIter.skip_to(docId);
-				if ((postingIter != pIndex-&gt;postlist_end(term)) &amp;&amp;
-					(docId == (*postingIter)))
-				{
-					foundLabel = true;
-				}
-			}
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't check document labels: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't check document labels, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return foundLabel;
-}
-
-/// Returns a document's labels.
-bool XapianIndex::getDocumentLabels(unsigned int docId, set&lt;string&gt; &amp;labels) const
-{
-	bool gotLabels = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	labels.clear();
-	try
-	{
-		Xapian::Database *pIndex = pDatabase-&gt;readLock();
-		if (pIndex != NULL)
-		{
-			Xapian::TermIterator termIter = pIndex-&gt;termlist_begin(docId);
-			if (termIter != pIndex-&gt;termlist_end(docId))
-			{
-				for (termIter.skip_to(&quot;XLABEL:&quot;);
-					termIter != pIndex-&gt;termlist_end(docId); ++termIter)
-				{
-					if ((*termIter).length() &lt; 7)
-					{
-						break;
-					}
-
-					// Is this a label ?
-					if (strncasecmp((*termIter).c_str(), &quot;XLABEL:&quot;, min(7, (int)(*termIter).length())) == 0)
-					{
-						labels.insert(Url::unescapeUrl((*termIter).substr(7)));
-					}
-				}
-				gotLabels = true;
-			}
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't get document's labels: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't get document's labels, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return gotLabels;
-}
-
-/// Sets a document's labels.
-bool XapianIndex::setDocumentLabels(unsigned int docId, const set&lt;string&gt; &amp;labels,
-	bool resetLabels)
-{
-	set&lt;unsigned int&gt; docIds;
-
-	docIds.insert(docId);
-	return setDocumentsLabels(docIds, labels, resetLabels);
-}
-
-/// Sets documents' labels.
-bool XapianIndex::setDocumentsLabels(const set&lt;unsigned int&gt; &amp;docIds,
-	const set&lt;string&gt; &amp;labels, bool resetLabels)
-{
-	bool updatedLabels = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	for (set&lt;unsigned int&gt;::const_iterator docIter = docIds.begin();
-		docIter != docIds.end(); ++docIter)
-	{
-		try
-		{
-			Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
-			if (pIndex == NULL)
-			{
-				break;
-			}
-
-			unsigned int docId = (*docIter);
-			Xapian::Document doc = pIndex-&gt;get_document(docId);
-
-			// Reset existing labels ?
-			if (resetLabels == true)
-			{
-				Xapian::TermIterator termIter = pIndex-&gt;termlist_begin(docId);
-				if (termIter != pIndex-&gt;termlist_end(docId))
-				{
-					for (termIter.skip_to(&quot;XLABEL:&quot;);
-						termIter != pIndex-&gt;termlist_end(docId); ++termIter)
-					{
-						string term(*termIter);
-
-						// Is this a non-internal label ?
-						if ((strncasecmp(term.c_str(), &quot;XLABEL:&quot;, min(7, (int)term.length())) == 0) &amp;&amp;
-							(strncasecmp(term.c_str(), &quot;XLABEL:X-&quot;, min(9, (int)term.length())) != 0))
-						{
-							doc.remove_term(term);
-						}
-					}
-				}
-			}
-
-			// Set new labels
-			for (set&lt;string&gt;::const_iterator labelIter = labels.begin(); labelIter != labels.end();
-				++labelIter)
-			{
-				// Prevent from setting internal labels
-				if ((labelIter-&gt;empty() == false) &amp;&amp;
-					(labelIter-&gt;substr(0, 2) != &quot;X-&quot;))
-				{
-					doc.add_term(string(&quot;XLABEL:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(*labelIter)));
-				}
-			}
-
-			pIndex-&gt;replace_document(docId, doc);
-			updatedLabels = true;
-		}
-		catch (const Xapian::Error &amp;error)
-		{
-			cerr &lt;&lt; &quot;Couldn't update document's labels: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-		}
-		catch (...)
-		{
-			cerr &lt;&lt; &quot;Couldn't update document's labels, unknown exception occured&quot; &lt;&lt; endl;
-		}
-
-		pDatabase-&gt;unlock();
-	}
-
-	return updatedLabels;
-}
-
-/// Checks whether the given URL is in the index.
-unsigned int XapianIndex::hasDocument(const string &amp;url) const
-{
-	unsigned int docId = 0;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return 0;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase-&gt;readLock();
-		if (pIndex != NULL)
-		{
-			string term = string(&quot;U&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(Url::canonicalizeUrl(url)), true);
-
-			// Get documents that have this term
-			Xapian::PostingIterator postingIter = pIndex-&gt;postlist_begin(term);
-			if (postingIter != pIndex-&gt;postlist_end(term))
-			{
-				// This URL was indexed
-				docId = *postingIter;
-#ifdef DEBUG
-				cout &lt;&lt; &quot;XapianIndex::hasDocument: &quot; &lt;&lt; term &lt;&lt; &quot; in document &quot;
-					&lt;&lt; docId &lt;&lt; &quot; &quot; &lt;&lt; postingIter.get_wdf() &lt;&lt; &quot; time(s)&quot; &lt;&lt; endl;
-#endif
-			}
-			// FIXME: what if the term exists in more than one document ?
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't look for document: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't look for document, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return docId;
-}
-
-/// Gets terms with the same root.
-unsigned int XapianIndex::getCloseTerms(const string &amp;term, set&lt;string&gt; &amp;suggestions)
-{
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return 0;
-	}
-
-	suggestions.clear();
-	try
-	{
-		Xapian::Database *pIndex = pDatabase-&gt;readLock();
-		if (pIndex != NULL)
-		{
-			Xapian::TermIterator termIter = pIndex-&gt;allterms_begin();
-
-			if (termIter != pIndex-&gt;allterms_end())
-			{
-				string baseTerm(StringManip::toLowerCase(term));
-				unsigned int count = 0;
-
-				// Get the next 10 terms
-				for (termIter.skip_to(baseTerm);
-					(termIter != pIndex-&gt;allterms_end()) &amp;&amp; (count &lt; 10); ++termIter)
-				{
-					string suggestedTerm(*termIter);
-
-					if (suggestedTerm.find(baseTerm) != 0)
-					{
-						// This term doesn't have the same root
-#ifdef DEBUG
-						cout &lt;&lt; &quot;XapianIndex::getCloseTerms: not the same root&quot; &lt;&lt; endl;
-#endif
-						break;
-					}
-
-					suggestions.insert(suggestedTerm);
-					++count;
-				}
-			}
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't get terms: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't get terms, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return suggestions.size();
-}
-
-/// Returns the ID of the last document.
-unsigned int XapianIndex::getLastDocumentID(void) const
-{
-	unsigned int docId = 0;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return 0;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase-&gt;readLock();
-		if (pIndex != NULL)
-		{
-			docId = pIndex-&gt;get_lastdocid();
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't get last document ID: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't get last document ID, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return docId;
-}
-
-/// Returns the number of documents.
-unsigned int XapianIndex::getDocumentsCount(const string &amp;labelName) const
-{
-	unsigned int docCount = 0;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return 0;
-	}
-
-	try
-	{
-		Xapian::Database *pIndex = pDatabase-&gt;readLock();
-		if (pIndex != NULL)
-		{
-			if (labelName.empty() == true)
-			{
-				docCount = pIndex-&gt;get_doccount();
-			}
-			else
-			{
-				string term(&quot;XLABEL:&quot;);
-
-				// Each label appears only one per document so the collection frequency
-				// is the number of documents that have this label
-				term += XapianDatabase::limitTermLength(Url::escapeUrl(labelName));
-				docCount = pIndex-&gt;get_collection_freq(term);
-			}
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't count documents: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't count documents, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return docCount;
-}
-
-/// Lists document IDs.
-unsigned int XapianIndex::listDocuments(set&lt;unsigned int&gt; &amp;docIds,
-	unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	// All documents have the magic term
-	return listDocumentsWithTerm(&quot;&quot;, docIds, maxDocsCount, startDoc);
-}
-
-/// Lists documents.
-bool XapianIndex::listDocuments(const string &amp;name, set&lt;unsigned int&gt; &amp;docIds,
-	NameType type, unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	string term;
-
-	if (type == BY_LABEL)
-	{
-		term = string(&quot;XLABEL:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(name));
-	}
-	else if (type == BY_DIRECTORY)
-	{
-		term = string(&quot;XDIR:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(name), true);
-	}
-	else if (type == BY_FILE)
-	{
-		term = string(&quot;XFILE:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(name), true);
-	}
-
-	return listDocumentsWithTerm(term, docIds, maxDocsCount, startDoc);
-}
-
-/// Indexes the given data.
-bool XapianIndex::indexDocument(const Document &amp;document, const std::set&lt;std::string&gt; &amp;labels,
-	unsigned int &amp;docId)
-{
-	bool indexed = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	// Cache the document's properties
-	DocumentInfo docInfo(document.getTitle(), document.getLocation(),
-		document.getType(), document.getLanguage());
-	docInfo.setTimestamp(document.getTimestamp());
-	docInfo.setSize(document.getSize());
-	docInfo.setLocation(Url::canonicalizeUrl(docInfo.getLocation()));
-
-	unsigned int dataLength = 0;
-	const char *pData = document.getData(dataLength);
-
-	if ((pData != NULL) &amp;&amp;
-		(dataLength &gt; 0))
-	{
-		m_stemLanguage = scanDocument(pData, dataLength, docInfo);
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc;
-
-			// Populate the Xapian document
-			addCommonTerms(docInfo, doc, *pIndex);
-			if ((pData != NULL) &amp;&amp;
-				(dataLength &gt; 0))
-			{
-				Xapian::Utf8Iterator itor(pData, dataLength);
-				addPostingsToDocument(itor, doc, *pIndex, &quot;&quot;, false);
-			}
-
-			// Add labels
-			for (set&lt;string&gt;::const_iterator labelIter = labels.begin(); labelIter != labels.end();
-				++labelIter)
-			{
-				doc.add_term(string(&quot;XLABEL:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(*labelIter)));
-			}
-#ifdef DEBUG
-			cout &lt;&lt; &quot;XapianIndex::indexDocument: &quot; &lt;&lt; labels.size() &lt;&lt; &quot; labels&quot; &lt;&lt; endl;
-#endif
-
-			// Set data
-			setDocumentData(docInfo, doc, m_stemLanguage);
-
-			// Add this document to the Xapian index
-			docId = pIndex-&gt;add_document(doc);
-			indexed = true;
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't index document: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't index document, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return indexed;
-}
-
-/// Updates the given document; true if success.
-bool XapianIndex::updateDocument(unsigned int docId, const Document &amp;document)
-{
-	bool updated = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	// Cache the document's properties
-	DocumentInfo docInfo(document.getTitle(), document.getLocation(),
-		document.getType(), document.getLanguage());
-	docInfo.setTimestamp(document.getTimestamp());
-	docInfo.setSize(document.getSize());
-	docInfo.setLocation(Url::canonicalizeUrl(docInfo.getLocation()));
-
-	unsigned int dataLength = 0;
-	const char *pData = document.getData(dataLength);
-
-	// Don't scan the document if a language is specified
-	m_stemLanguage = Languages::toEnglish(docInfo.getLanguage());
-	if (m_stemLanguage.empty() == true)
-	{
-		if ((pData != NULL) &amp;&amp;
-			(dataLength &gt; 0))
-		{
-			m_stemLanguage = scanDocument(pData, dataLength, docInfo);
-		}
-	}
-
-	Xapian::WritableDatabase *pIndex = NULL;
-
-	try
-	{
-		set&lt;string&gt; labels;
-
-		// Get the document's labels
-		getDocumentLabels(docId, labels);
-
-		pIndex = pDatabase-&gt;writeLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc;
-
-			// Populate the Xapian document
-			addCommonTerms(docInfo, doc, *pIndex);
-			if ((pData != NULL) &amp;&amp;
-				(dataLength &gt; 0))
-			{
-				Xapian::Utf8Iterator itor(pData, dataLength);
-				addPostingsToDocument(itor, doc, *pIndex, &quot;&quot;, false);
-			}
-
-			// Add labels
-			for (set&lt;string&gt;::const_iterator labelIter = labels.begin(); labelIter != labels.end();
-				++labelIter)
-			{
-				doc.add_term(string(&quot;XLABEL:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(*labelIter)));
-			}
-
-			// Set data
-			setDocumentData(docInfo, doc, m_stemLanguage);
-
-			// Update the document in the database
-			pIndex-&gt;replace_document(docId, doc);
-			updated = true;
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't update document: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't update document, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	if (pIndex != NULL)
-	{
-		pDatabase-&gt;unlock();
-	}
-
-	return updated;
-}
-
-/// Updates a document's properties.
-bool XapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &amp;docInfo)
-{
-	bool updated = false;
-
-	if (docId == 0)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc = pIndex-&gt;get_document(docId);
-
-			// Update the document data with the current language
-			m_stemLanguage = Languages::toEnglish(docInfo.getLanguage());
-			removeCommonTerms(doc);
-			addCommonTerms(docInfo, doc, *pIndex);
-			setDocumentData(docInfo, doc, m_stemLanguage);
-
-			pIndex-&gt;replace_document(docId, doc);
-			updated = true;
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't update document properties: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't update document properties, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return updated;
-}
-
-/// Unindexes the given document; true if success.
-bool XapianIndex::unindexDocument(unsigned int docId)
-{
-	bool unindexed = false;
-
-	if (docId == 0)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
-		if (pIndex != NULL)
-		{
-			// Delete the document from the index
-			pIndex-&gt;delete_document(docId);
-			unindexed = true;
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't unindex document: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't unindex document, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return unindexed;
-}
-
-/// Unindexes the given document.
-bool XapianIndex::unindexDocument(const string &amp;location)
-{
-	string term(string(&quot;U&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(Url::canonicalizeUrl(location)), true));
-
-	return deleteDocuments(term);
-}
-
-/// Unindexes documents.
-bool XapianIndex::unindexDocuments(const string &amp;name, NameType type)
-{
-	string term;
-
-	if (type == BY_LABEL)
-	{
-		term = string(&quot;XLABEL:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(name));
-	}
-	else if (type == BY_DIRECTORY)
-	{
-		term = string(&quot;XDIR:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(name), true);
-	}
-	else if (type == BY_FILE)
-	{
-		term = string(&quot;XFILE:&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(name), true);
-	}
-
-	return deleteDocuments(term);
-}
-
-/// Unindexes all documents.
-bool XapianIndex::unindexAllDocuments(void)
-{
-	// All documents have the magic term
-	return deleteDocuments(MAGIC_TERM);
-}
-
-/// Flushes recent changes to the disk.
-bool XapianIndex::flush(void)
-{
-	bool flushed = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
-		if (pIndex != NULL)
-		{
-			pIndex-&gt;flush();
-			flushed = true;
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;Couldn't flush database: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Couldn't flush database, unknown exception occured&quot; &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return flushed;
-}
-
-/// Resets the index.
-bool XapianIndex::reset(void)
-{
-	// Overwrite and reopen
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false, true);
-	if (pDatabase == NULL)
-	{
-		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
-		return false;
-	}
-
-	return true;
-}
-

Deleted: trunk/Index/XapianIndex.h
===================================================================
--- trunk/Index/XapianIndex.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/XapianIndex.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,179 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _XAPIAN_INDEX_H
-#define _XAPIAN_INDEX_H
-
-#include &lt;string&gt;
-#include &lt;set&gt;
-#include &lt;map&gt;
-
-#include &quot;config.h&quot;
-#include &quot;XapianDatabase.h&quot;
-#include &quot;IndexInterface.h&quot;
-
-#if !ENABLE_XAPIAN_DB_METADATA
-// Database metadata is only available in Xapian &gt; 1.0.2
-#if XAPIAN_NUM_VERSION &gt; 1000002
-#define ENABLE_XAPIAN_DB_METADATA 1
-#else
-#define ENABLE_XAPIAN_DB_METADATA 0
-#endif
-#endif
-
-/// A Xapian-based index.
-class XapianIndex : public IndexInterface
-{
-	public:
-		XapianIndex(const std::string &amp;indexName);
-		XapianIndex(const XapianIndex &amp;other);
-		virtual ~XapianIndex();
-
-		XapianIndex &amp;operator=(const XapianIndex &amp;other);
-
-		/// Returns false if the index couldn't be opened.
-		virtual bool isGood(void) const;
-
-		/// Gets the version number.
-		virtual std::string getVersion(void) const;
-
-		/// Sets the version number.
-		virtual bool setVersion(const std::string &amp;version) const;
-
-		/// Gets the index location.
-		virtual std::string getLocation(void) const;
-
-		/// Returns a document's properties.
-		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &amp;docInfo) const;
-
-		/// Returns a document's terms count.
-		virtual unsigned int getDocumentTermsCount(unsigned int docId) const;
-
-		/// Returns a document's terms.
-		virtual bool getDocumentTerms(unsigned int docId,
-			std::map&lt;unsigned int, std::string&gt; &amp;wordsBuffer) const;
-
-		/// Sets the list of known labels.
-		virtual bool setLabels(const std::set&lt;std::string&gt; &amp;labels);
-
-		/// Gets the list of known labels.
-		virtual bool getLabels(std::set&lt;std::string&gt; &amp;labels) const;
-
-		/// Adds a label.
-		virtual bool addLabel(const std::string &amp;name);
-
-		/// Renames a label.
-		virtual bool renameLabel(const std::string &amp;name, const std::string &amp;newName);
-
-		/// Deletes all references to a label.
-		virtual bool deleteLabel(const std::string &amp;name);
-
-		/// Determines whether a document has a label.
-		virtual bool hasLabel(unsigned int docId, const std::string &amp;name) const;
-
-		/// Returns a document's labels.
-		virtual bool getDocumentLabels(unsigned int docId, std::set&lt;std::string&gt; &amp;labels) const;
-
-		/// Sets a document's labels.
-		virtual bool setDocumentLabels(unsigned int docId, const std::set&lt;std::string&gt; &amp;labels,
-			bool resetLabels = true);
-
-		/// Sets documents' labels.
-		virtual bool setDocumentsLabels(const std::set&lt;unsigned int&gt; &amp;docIds,
-			const std::set&lt;std::string&gt; &amp;labels, bool resetLabels = true);
-
-		/// Checks whether the given URL is in the index.
-		virtual unsigned int hasDocument(const std::string &amp;url) const;
-
-		/// Gets terms with the same root.
-		virtual unsigned int getCloseTerms(const std::string &amp;term, std::set&lt;std::string&gt; &amp;suggestions);
-
-		/// Returns the ID of the last document.
-		virtual unsigned int getLastDocumentID(void) const;
-
-		/// Returns the number of documents.
-		virtual unsigned int getDocumentsCount(const std::string &amp;labelName = &quot;&quot;) const;
-
-		/// Lists documents.
-		virtual unsigned int listDocuments(std::set&lt;unsigned int&gt; &amp;docIDList,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		/// Lists documents.
-		virtual bool listDocuments(const std::string &amp;name, std::set&lt;unsigned int&gt; &amp;docIds,
-			NameType type, unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		/// Indexes the given data.
-		virtual bool indexDocument(const Document &amp;doc, const std::set&lt;std::string&gt; &amp;labels,
-			unsigned int &amp;docId);
-
-		/// Updates the given document.
-		virtual bool updateDocument(unsigned int docId, const Document &amp;doc);
-
-		/// Updates a document's properties.
-		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &amp;docInfo);
-
-		/// Unindexes the given document.
-		virtual bool unindexDocument(unsigned int docId);
-
-		/// Unindexes the given document.
-		virtual bool unindexDocument(const std::string &amp;location);
-
-		/// Unindexes documents.
-		virtual bool unindexDocuments(const std::string &amp;name, NameType type);
-
-		/// Unindexes all documents.
-		virtual bool unindexAllDocuments(void);
-
-		/// Flushes recent changes to the disk.
-		virtual bool flush(void);
-
-		/// Resets the index.
-		virtual bool reset(void);
-
-	protected:
-		static const std::string MAGIC_TERM;
-		std::string m_databaseName;
-		bool m_goodIndex;
-		bool m_doSpelling;
-		std::string m_stemLanguage;
-
-		bool listDocumentsWithTerm(const std::string &amp;term, std::set&lt;unsigned int&gt; &amp;docIds,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		void addPostingsToDocument(const Xapian::Utf8Iterator &amp;itor, Xapian::Document &amp;doc,
-			const Xapian::WritableDatabase &amp;db, const std::string &amp;prefix, bool noStemming);
-
-		void removePostingsFromDocument(const Xapian::Utf8Iterator &amp;itor, Xapian::Document &amp;doc,
-			const std::string &amp;prefix, const std::string &amp;language, bool noStemming) const;
-
-		void addCommonTerms(const DocumentInfo &amp;info, Xapian::Document &amp;doc,
-			const Xapian::WritableDatabase &amp;db);
-
-		void removeCommonTerms(Xapian::Document &amp;doc);
-
-		std::string scanDocument(const char *pData, unsigned int dataLength,
-			DocumentInfo &amp;info);
-
-		void setDocumentData(const DocumentInfo &amp;info, Xapian::Document &amp;doc,
-			const std::string &amp;language) const;
-
-		bool deleteDocuments(const std::string &amp;term);
-
-};
-
-#endif // _XAPIAN_INDEX_H

Deleted: trunk/Index/pinot-index.1
===================================================================
--- trunk/Index/pinot-index.1	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/pinot-index.1	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,47 +0,0 @@
-.\&quot; DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-INDEX &quot;1&quot; &quot;November 2007&quot; &quot;pinot-index - pinot 0.81&quot; &quot;User Commands&quot;
-.SH NAME
-pinot-index \- Index documents from the command-line
-.SH SYNOPSIS
-.B pinot-index
-[\fIOPTIONS\fR] \fIURLS\fR
-.SH DESCRIPTION
-pinot\-index \- Index documents from the command\-line
-.SH OPTIONS
-.TP
-\fB\-c\fR, \fB\-\-check\fR
-check whether the given URL is in the index
-.TP
-\fB\-d\fR, \fB\-\-db\fR
-path to index to use (mandatory)
-.TP
-\fB\-h\fR, \fB\-\-help\fR
-display this help and exit
-.TP
-\fB\-i\fR, \fB\-\-index\fR
-index the given URL
-.TP
-\fB\-a\fR, \fB\-\-proxyaddress\fR
-proxy address
-.TP
-\fB\-p\fR, \fB\-\-proxyport\fR
-proxy port
-.TP
-\fB\-t\fR, \fB\-\-proxytype\fR
-proxy type (default HTTP, SOCKS4, SOCKS5)
-.TP
-\fB\-s\fR, \fB\-\-showinfo\fR
-show information about the document
-.TP
-\fB\-v\fR, \fB\-\-version\fR
-output version information and exit
-.SH EXAMPLES
-pinot\-index \fB\-\-check\fR \fB\-\-showinfo\fR \fB\-\-db\fR ~/.pinot/daemon <A HREF="file:///home/fabrice/Documents/Bozo.txt">file:///home/fabrice/Documents/Bozo.txt</A>
-.PP
-pinot\-index \fB\-\-index\fR \fB\-\-db\fR ~/.pinot/index <A HREF="http://pinot.berlios.de/">http://pinot.berlios.de/</A>
-.SH &quot;REPORTING BUGS&quot;
-Report bugs to <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabricecolin at users.berlios.de</A>
-.PP
-This is free software.  You may redistribute copies of it under the terms of
-the GNU General Public License &lt;<A HREF="http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html">http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html</A>&gt;.
-There is NO WARRANTY, to the extent permitted by law.

Deleted: trunk/Index/pinot-index.cpp
===================================================================
--- trunk/Index/pinot-index.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/pinot-index.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,338 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
- 
-#include &lt;getopt.h&gt;
-#include &lt;cstdlib&gt;
-#include &lt;cstdio&gt;
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-#include &lt;fstream&gt;
-
-#include &quot;Languages.h&quot;
-#include &quot;MIMEScanner.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;FilterFactory.h&quot;
-#include &quot;XapianDatabaseFactory.h&quot;
-#include &quot;DownloaderFactory.h&quot;
-#include &quot;FilterWrapper.h&quot;
-#include &quot;IndexFactory.h&quot;
-#include &quot;config.h&quot;
-
-using namespace std;
-
-static struct option g_longOptions[] = {
-	{&quot;check&quot;, 0, 0, 'c'},
-	{&quot;db&quot;, 1, 0, 'd'},
-	{&quot;help&quot;, 0, 0, 'h'},
-	{&quot;index&quot;, 0, 0, 'i'},
-	{&quot;proxyaddress&quot;, 1, 0, 'a'},
-	{&quot;proxyport&quot;, 1, 0, 'p'},
-	{&quot;proxytype&quot;, 1, 0, 't'},
-	{&quot;showinfo&quot;, 0, 0, 's'},
-	{&quot;version&quot;, 0, 0, 'v'},
-	{0, 0, 0, 0}
-};
-
-static void printHelp(void)
-{
-	// Help
-	cout &lt;&lt; &quot;pinot-index - Index documents from the command-line\n\n&quot;
-		&lt;&lt; &quot;Usage: pinot-index [OPTIONS] URLS\n\n&quot;
-		&lt;&lt; &quot;Options:\n&quot;
-		&lt;&lt; &quot;  -c, --check               check whether the given URL is in the index\n&quot;
-		&lt;&lt; &quot;  -d, --db                  path to index to use (mandatory)\n&quot;
-		&lt;&lt; &quot;  -h, --help                display this help and exit\n&quot;
-		&lt;&lt; &quot;  -i, --index               index the given URL\n&quot;
-		&lt;&lt; &quot;  -a, --proxyaddress        proxy address\n&quot;
-		&lt;&lt; &quot;  -p, --proxyport           proxy port\n&quot;
-		&lt;&lt; &quot;  -t, --proxytype           proxy type (default HTTP, SOCKS4, SOCKS5)\n&quot;
-		&lt;&lt; &quot;  -s, --showinfo            show information about the document\n&quot;
-		&lt;&lt; &quot;  -v, --version             output version information and exit\n\n&quot;;
-	// Don't mention type dbus here as it doesn't support indexing and
-	// is identical to xapian when checking for URLs
-	cout &lt;&lt; &quot;Examples:\n&quot;
-		&lt;&lt; &quot;pinot-index --check --showinfo --db ~/.pinot/daemon <A HREF="file:///home/fabrice/Documents/Bozo.txt\n\n">file:///home/fabrice/Documents/Bozo.txt\n\n</A>&quot;
-		&lt;&lt; &quot;pinot-index --index --db ~/.pinot/index <A HREF="http://pinot.berlios.de/\n\n">http://pinot.berlios.de/\n\n</A>&quot;
-		&lt;&lt; &quot;Report bugs to &quot; &lt;&lt; PACKAGE_BUGREPORT &lt;&lt; endl;
-}
-
-int main(int argc, char **argv)
-{
-	string type, option;
-	string databaseName, proxyAddress, proxyPort, proxyType;
-	int longOptionIndex = 0;
-	unsigned int docId = 0;
-	bool checkDocument = false, indexDocument = false, showInfo = false, success = false;
-
-	// Look at the options
-	int optionChar = getopt_long(argc, argv, &quot;cd:hia:p:t:sv&quot;, g_longOptions, &amp;longOptionIndex);
-	while (optionChar != -1)
-	{
-		set&lt;string&gt; engines;
-
-		switch (optionChar)
-		{
-			case 'a':
-				if (optarg != NULL)
-				{
-					proxyAddress = optarg;
-				}
-				break;
-			case 'c':
-				checkDocument = true;
-				break;
-			case 'd':
-				if (optarg != NULL)
-				{
-					databaseName = optarg;
-				}
-				break;
-			case 'h':
-				printHelp();
-				return EXIT_SUCCESS;
-			case 'i':
-				indexDocument = true;
-				break;
-			case 'p':
-				if (optarg != NULL)
-				{
-					proxyPort = optarg;
-				}
-				break;
-			case 's':
-				showInfo = true;
-				break;
-			case 't':
-				if (optarg != NULL)
-				{
-					proxyType = optarg;
-				}
-				break;
-			case 'v':
-				cout &lt;&lt; &quot;pinot-index - &quot; &lt;&lt; PACKAGE_STRING &lt;&lt; &quot;\n\n&quot;
-					&lt;&lt; &quot;This is free software.  You may redistribute copies of it under the terms of\n&quot;
-					&lt;&lt; &quot;the GNU General Public License &lt;<A HREF="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">http://www.gnu.org/licenses/old-licenses/gpl-2.0.html</A>&gt;.\n&quot;
-					&lt;&lt; &quot;There is NO WARRANTY, to the extent permitted by law.&quot; &lt;&lt; endl;
-				return EXIT_SUCCESS;
-			default:
-				return EXIT_FAILURE;
-		}
-
-		// Next option
-		optionChar = getopt_long(argc, argv, &quot;cd:hia:p:t:sv&quot;, g_longOptions, &amp;longOptionIndex);
-	}
-
-	if (argc == 1)
-	{
-		printHelp();
-		return EXIT_SUCCESS;
-	}
-
-	if ((argc &lt; 2) ||
-		(argc - optind == 0))
-	{
-		cerr &lt;&lt; &quot;Not enough parameters&quot; &lt;&lt; endl;
-		return EXIT_FAILURE;
-	}
-
-	if (((indexDocument == false) &amp;&amp;
-		(checkDocument == false)) ||
-		(databaseName.empty() == true))
-	{
-		cerr &lt;&lt; &quot;Incorrect parameters&quot; &lt;&lt; endl;
-		return EXIT_FAILURE;
-	}
-
-	MIMEScanner::initialize(&quot;&quot;, &quot;&quot;);
-	DownloaderInterface::initialize();
-	// Localize language names
-	Languages::setIntlName(0, &quot;Unknown&quot;);
-	Languages::setIntlName(1, &quot;Danish&quot;);
-	Languages::setIntlName(2, &quot;Dutch&quot;);
-	Languages::setIntlName(3, &quot;English&quot;);
-	Languages::setIntlName(4, &quot;Finnish&quot;);
-	Languages::setIntlName(5, &quot;French&quot;);
-	Languages::setIntlName(6, &quot;German&quot;);
-	Languages::setIntlName(7, &quot;Hungarian&quot;);
-	Languages::setIntlName(8, &quot;Italian&quot;);
-	Languages::setIntlName(9, &quot;Norwegian&quot;);
-	Languages::setIntlName(10, &quot;Portuguese&quot;);
-	Languages::setIntlName(11, &quot;Romanian&quot;);
-	Languages::setIntlName(12, &quot;Russian&quot;);
-	Languages::setIntlName(13, &quot;Spanish&quot;);
-	Languages::setIntlName(14, &quot;Swedish&quot;);
-	Languages::setIntlName(15, &quot;Turkish&quot;);
-	Dijon::HtmlFilter::initialize();
-	Dijon::FilterFactory::loadFilters(string(LIBDIR) + string(&quot;/pinot/filters&quot;));
-
-	// Make sure the index is open in the correct mode
-	XapianDatabase *pDb = XapianDatabaseFactory::getDatabase(databaseName, (indexDocument ? false : true));
-	if (pDb == NULL)
-	{
-		cerr &lt;&lt; &quot;Couldn't open index &quot; &lt;&lt; databaseName &lt;&lt; endl;
-
-		Dijon::FilterFactory::unloadFilters();
-		Dijon::HtmlFilter::shutdown();
-		DownloaderInterface::shutdown();
-		MIMEScanner::shutdown();
-
-		return EXIT_FAILURE;
-	}
-
-	// Get a read-write index of the given type
-	IndexInterface *pIndex = IndexFactory::getIndex(&quot;xapian&quot;, databaseName);
-	if (pIndex == NULL)
-	{
-		cerr &lt;&lt; &quot;Couldn't obtain index for &quot; &lt;&lt; databaseName &lt;&lt; endl;
-
-		XapianDatabaseFactory::closeAll();
-		Dijon::FilterFactory::unloadFilters();
-		Dijon::HtmlFilter::shutdown();
-		DownloaderInterface::shutdown();
-		MIMEScanner::shutdown();
-
-		return EXIT_FAILURE;
-	}
-
-	while (optind &lt; argc)
-	{
-		string urlParam(argv[optind]);
-
-		if (checkDocument == true)
-		{
-			if (pIndex-&gt;isGood() == true)
-			{
-				docId = pIndex-&gt;hasDocument(urlParam);
-				if (docId &gt; 0)
-				{
-					cout &lt;&lt; urlParam &lt;&lt; &quot;: document ID &quot; &lt;&lt; docId &lt;&lt; endl;
-					success = true;
-				}
-			}
-		}
-		if (indexDocument == true)
-		{
-			Url thisUrl(urlParam);
-
-			// Which Downloader ?
-			DownloaderInterface *pDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
-			if (pDownloader == NULL)
-			{
-				cerr &lt;&lt; &quot;Couldn't obtain downloader for protocol &quot; &lt;&lt; thisUrl.getProtocol() &lt;&lt; endl;
-
-				success = false;
-				continue;
-			}
-
-			// Set up the proxy
-			if ((proxyAddress.empty() == false) &amp;&amp;
-				(proxyPort.empty() == false))
-			{
-				pDownloader-&gt;setSetting(&quot;proxyaddress&quot;, proxyAddress);
-				pDownloader-&gt;setSetting(&quot;proxyport&quot;, proxyPort);
-				pDownloader-&gt;setSetting(&quot;proxytype&quot;, proxyType);
-			}
-
-			DocumentInfo docInfo(&quot;&quot;, urlParam, MIMEScanner::scanUrl(thisUrl), &quot;&quot;);
-			Document *pDoc = pDownloader-&gt;retrieveUrl(docInfo);
-			if (pDoc == NULL)
-			{
-				cerr &lt;&lt; &quot;Couldn't download &quot; &lt;&lt; urlParam &lt;&lt; endl;
-			}
-			else
-			{
-				FilterWrapper wrapFilter(pIndex);
-				set&lt;string&gt; labels;
-
-				// Update an existing document or add to the index ?
-				docId = pIndex-&gt;hasDocument(urlParam);
-				if (docId &gt; 0)
-				{
-					// Update the document
-					if (wrapFilter.updateDocument(*pDoc, docId) == true)
-					{
-						success = true;
-					}
-				}
-				else
-				{
-					// Index the document
-					success = wrapFilter.indexDocument(*pDoc, labels, docId);
-				}
-
-				if (success == true)
-				{
-					// Flush the index
-					pIndex-&gt;flush();
-				}
-
-				delete pDoc;
-			}
-
-			delete pDownloader;
-		}
-		if ((showInfo == true) &amp;&amp;
-			(docId &gt; 0))
-		{
-			DocumentInfo docInfo;
-			set&lt;string&gt; labels;
-
-			if (pIndex-&gt;getDocumentInfo(docId, docInfo) == true)
-			{
-				cout &lt;&lt; &quot;Location : '&quot; &lt;&lt; docInfo.getLocation() &lt;&lt; &quot;'&quot; &lt;&lt; endl;
-				cout &lt;&lt; &quot;Title    : &quot; &lt;&lt; docInfo.getTitle() &lt;&lt; endl;
-				cout &lt;&lt; &quot;Type     : &quot; &lt;&lt; docInfo.getType() &lt;&lt; endl;
-				cout &lt;&lt; &quot;Language : &quot; &lt;&lt; docInfo.getLanguage() &lt;&lt; endl;
-				cout &lt;&lt; &quot;Date     : &quot; &lt;&lt; docInfo.getTimestamp() &lt;&lt; endl;
-				cout &lt;&lt; &quot;Size     : &quot; &lt;&lt; docInfo.getSize() &lt;&lt; endl;
-			}
-			if (pIndex-&gt;getDocumentLabels(docId, labels) == true)
-			{
-				cout &lt;&lt; &quot;Labels   : &quot;;
-				for (set&lt;string&gt;::const_iterator labelIter = labels.begin();
-					labelIter != labels.end(); ++labelIter)
-				{
-					if (labelIter-&gt;substr(0, 2) == &quot;X-&quot;)
-					{
-						continue;
-					}
-					cout &lt;&lt; &quot;[&quot; &lt;&lt; Url::escapeUrl(*labelIter) &lt;&lt; &quot;]&quot;;
-				}
-				cout &lt;&lt; endl;
-			}
-		}
-
-		// Next
-		++optind;
-	}
-	delete pIndex;
-
-	XapianDatabaseFactory::closeAll();
-	Dijon::FilterFactory::unloadFilters();
-	Dijon::HtmlFilter::shutdown();
-	DownloaderInterface::shutdown();
-	MIMEScanner::shutdown();
-
-	// Did whatever operation we carried out succeed ?
-	if (success == true)
-	{
-		return EXIT_SUCCESS;
-	}
-
-	return EXIT_FAILURE;
-}

Deleted: trunk/Index/pinot-label.1
===================================================================
--- trunk/Index/pinot-label.1	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/pinot-label.1	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,37 +0,0 @@
-.\&quot; DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-LABEL &quot;1&quot; &quot;November 2007&quot; &quot;pinot-label - pinot 0.81&quot; &quot;User Commands&quot;
-.SH NAME
-pinot-label \- Label files from the command-line
-.SH SYNOPSIS
-.B pinot-label
-[\fIOPTIONS\fR] [\fIFILES\fR]
-.SH DESCRIPTION
-pinot\-label \- Label files from the command\-line
-.SH OPTIONS
-.TP
-\fB\-g\fR, \fB\-\-get\fR
-get the labels list for the given file
-.TP
-\fB\-h\fR, \fB\-\-help\fR
-display this help and exit
-.TP
-\fB\-l\fR, \fB\-\-list\fR
-list known labels
-.TP
-\fB\-s\fR, \fB\-\-set\fR
-set labels on the given file
-.TP
-\fB\-v\fR, \fB\-\-version\fR
-output version information and exit
-.SH EXAMPLES
-pinot\-label \fB\-\-get\fR /home/fabrice/Documents/Bozo.txt
-.PP
-pinot\-label \fB\-\-list\fR
-.PP
-pinot\-label \fB\-\-set\fR &quot;[Clowns][Fun][My Hero]&quot; /home/fabrice/Documents/Bozo.txt
-.SH &quot;REPORTING BUGS&quot;
-Report bugs to <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabricecolin at users.berlios.de</A>
-.PP
-This is free software.  You may redistribute copies of it under the terms of
-the GNU General Public License &lt;<A HREF="http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html">http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html</A>&gt;.
-There is NO WARRANTY, to the extent permitted by law.

Deleted: trunk/Index/pinot-label.cpp
===================================================================
--- trunk/Index/pinot-label.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Index/pinot-label.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,278 +0,0 @@
-/*
- *  Copyright 2007 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
- 
-#include &lt;getopt.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;pwd.h&gt;
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-#include &lt;set&gt;
-#include &quot;config.h&quot;
-extern &quot;C&quot;
-{
-#if DBUS_NUM_VERSION &lt; 1000000
-#define DBUS_API_SUBJECT_TO_CHANGE
-#endif
-#include &lt;dbus/dbus.h&gt;
-#include &lt;dbus/dbus-glib.h&gt;
-#include &lt;dbus/dbus-glib-lowlevel.h&gt;
-}
-
-#include &quot;StringManip.h&quot;
-#include &quot;MIMEScanner.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;DBusXapianIndex.h&quot;
-#include &quot;XapianDatabaseFactory.h&quot;
-
-using namespace std;
-
-static struct option g_longOptions[] = {
-	{&quot;get&quot;, 0, 0, 'g'},
-	{&quot;help&quot;, 0, 0, 'h'},
-	{&quot;list&quot;, 0, 0, 'l'},
-	{&quot;set&quot;, 1, 0, 's'},
-	{&quot;version&quot;, 0, 0, 'v'},
-	{0, 0, 0, 0}
-};
-
-
-static void printLabels(const set&lt;string&gt; &amp;labels, const string &amp;fileName)
-{
-	if (fileName.empty() == false)
-	{
-		cout &lt;&lt; fileName &lt;&lt; endl;
-	}
-	cout &lt;&lt; &quot;Labels: &quot;;
-
-	for (set&lt;string&gt;::const_iterator labelIter = labels.begin();
-		labelIter != labels.end(); ++labelIter)
-	{
-		if (labelIter-&gt;substr(0, 2) == &quot;X-&quot;)
-		{
-			continue;
-		}
-		cout &lt;&lt; &quot;[&quot; &lt;&lt; Url::escapeUrl(*labelIter) &lt;&lt; &quot;]&quot;;
-	}
-	cout &lt;&lt; endl;
-}
-
-static string getHomeDirectory(void)
-{
-	struct passwd *pPasswd = getpwuid(geteuid());
-
-	if ((pPasswd != NULL) &amp;&amp;
-		(pPasswd-&gt;pw_dir != NULL))
-	{
-		return pPasswd-&gt;pw_dir;
-	}
-	else
-	{
-		char *homeDir = getenv(&quot;HOME&quot;);
-		if (homeDir != NULL)
-		{
-			return homeDir;
-		}
-	}
-
-	return &quot;~&quot;;
-}
-
-static void printHelp(void)
-{
-	// Help
-	cout &lt;&lt; &quot;pinot-label - Label files from the command-line\n\n&quot;
-		&lt;&lt; &quot;Usage: pinot-label [OPTIONS] [FILES]\n\n&quot;
-		&lt;&lt; &quot;Options:\n&quot;
-		&lt;&lt; &quot;  -g, --get                 get the labels list for the given file\n&quot;
-		&lt;&lt; &quot;  -h, --help                display this help and exit\n&quot;
-		&lt;&lt; &quot;  -l, --list                list known labels\n&quot;
-		&lt;&lt; &quot;  -s, --set                 set labels on the given file\n&quot;
-		&lt;&lt; &quot;  -v, --version             output version information and exit\n\n&quot;;
-	cout &lt;&lt; &quot;Examples:\n&quot;
-		&lt;&lt; &quot;pinot-label --get /home/fabrice/Documents/Bozo.txt\n\n&quot;
-		&lt;&lt; &quot;pinot-label --list\n\n&quot;
-		&lt;&lt; &quot;pinot-label --set \&quot;[Clowns][Fun][My Hero]\&quot; /home/fabrice/Documents/Bozo.txt\n\n&quot;
-		&lt;&lt; &quot;Report bugs to &quot; &lt;&lt; PACKAGE_BUGREPORT &lt;&lt; endl;
-}
-
-int main(int argc, char **argv)
-{
-	set&lt;string&gt; labels;
-	string labelsString;
-	int longOptionIndex = 0;
-	unsigned int docId = 0;
-	int minArgNum = 1;
-	bool getLabels = false, getDocumentLabels = false, setDocumentLabels = false, success = false;
-
-	// Look at the options
-	int optionChar = getopt_long(argc, argv, &quot;ghls:v&quot;, g_longOptions, &amp;longOptionIndex);
-	while (optionChar != -1)
-	{
-		set&lt;string&gt; engines;
-
-		switch (optionChar)
-		{
-			case 'g':
-				getDocumentLabels = true;
-				break;
-			case 'h':
-				printHelp();
-				return EXIT_SUCCESS;
-			case 'l':
-				minArgNum = 0;
-				getLabels = true;
-				break;
-			case 's':
-				setDocumentLabels = true;
-				if (optarg != NULL)
-				{
-					labelsString = optarg;
-				}
-				break;
-			case 'v':
-				cout &lt;&lt; &quot;pinot-label - &quot; &lt;&lt; PACKAGE_STRING &lt;&lt; &quot;\n\n&quot;
-					&lt;&lt; &quot;This is free software.  You may redistribute copies of it under the terms of\n&quot;
-					&lt;&lt; &quot;the GNU General Public License &lt;<A HREF="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">http://www.gnu.org/licenses/old-licenses/gpl-2.0.html</A>&gt;.\n&quot;
-					&lt;&lt; &quot;There is NO WARRANTY, to the extent permitted by law.&quot; &lt;&lt; endl;
-				return EXIT_SUCCESS;
-			default:
-				return EXIT_FAILURE;
-		}
-
-		// Next option
-		optionChar = getopt_long(argc, argv, &quot;ghls:v&quot;, g_longOptions, &amp;longOptionIndex);
-	}
-
-	if (argc == 1)
-	{
-		printHelp();
-		return EXIT_SUCCESS;
-	}
-
-	if ((argc &lt; 2) ||
-		(argc - optind &lt; minArgNum))
-	{
-		cerr &lt;&lt; &quot;Not enough parameters&quot; &lt;&lt; endl;
-		return EXIT_FAILURE;
-	}
-
-	if ((setDocumentLabels == true) &amp;&amp;
-		(labelsString.empty() == true))
-	{
-		cerr &lt;&lt; &quot;Incorrect parameters&quot; &lt;&lt; endl;
-		return EXIT_FAILURE;
-	}
-
-	// Initialize GType
-	g_type_init();
-
-	MIMEScanner::initialize(&quot;&quot;, &quot;&quot;);
-
-	string indexLocation(getHomeDirectory() + &quot;/.pinot/daemon&quot;);
-	DBusXapianIndex index(indexLocation);
-	if (index.isGood() == false)
-	{
-		cerr &lt;&lt; &quot;Couldn't obtain index for &quot; &lt;&lt; indexLocation &lt;&lt; endl;
-
-		XapianDatabaseFactory::closeAll();
-		MIMEScanner::shutdown();
-
-		return EXIT_FAILURE;
-	}
-
-	if (getLabels == true)
-	{
-		if (index.getLabels(labels, true) == true)
-		{
-			printLabels(labels, &quot;&quot;);
-
-			success = true;
-		}
-	}
-
-	while (optind &lt; argc)
-	{
-		string fileParam(argv[optind]);
-
-		if ((getDocumentLabels == true) ||
-			(setDocumentLabels == true))
-		{
-			docId = index.hasDocument(string(&quot;<A HREF="file://">file://</A>&quot;) + fileParam);
-			if (docId == 0)
-			{
-				cerr &lt;&lt; fileParam &lt;&lt; &quot; is not indexed&quot; &lt;&lt; endl;
-				success = false;
-
-				// Next
-				++optind;
-				continue;
-			}
-		}
-
-		if (getDocumentLabels == true)
-		{
-			labels.clear();
-
-			if (index.getDocumentLabels(docId, labels, true) == true)
-			{
-				printLabels(labels, fileParam);
-
-				success = true;
-			}
-		}
-
-		if (setDocumentLabels == true)
-		{
-			string::size_type endPos = 0;
-			string label(StringManip::extractField(labelsString, &quot;[&quot;, &quot;]&quot;, endPos));
-
-			labels.clear();
-
-			// Parse labels
-			while (label.empty() == false)
-			{
-				labels.insert(Url::unescapeUrl(label));
-
-				if (endPos == string::npos)
-				{
-					break;
-				}
-				label = StringManip::extractField(labelsString, &quot;[&quot;, &quot;]&quot;, endPos);
-			}
-
-#ifdef DEBUG
-			printLabels(labels, fileParam);
-#endif
-			success = index.setDocumentLabels(docId, labels);
-		}
-
-		// Next
-		++optind;
-	}
-
-	XapianDatabaseFactory::closeAll();
-	MIMEScanner::shutdown();
-
-	// Did whatever operation we carried out succeed ?
-	if (success == true)
-	{
-		return EXIT_SUCCESS;
-	}
-
-	return EXIT_FAILURE;
-}

Copied: trunk/IndexSearch/DBusXapianIndex.cpp (from rev 1132, trunk/Index/DBusXapianIndex.cpp)

Copied: trunk/IndexSearch/DBusXapianIndex.h (from rev 1132, trunk/Index/DBusXapianIndex.h)

Copied: trunk/IndexSearch/FilterWrapper.cpp (from rev 1132, trunk/Index/FilterWrapper.cpp)

Copied: trunk/IndexSearch/FilterWrapper.h (from rev 1132, trunk/Index/FilterWrapper.h)

Copied: trunk/IndexSearch/Google (from rev 1132, trunk/Search/Google)

Copied: trunk/IndexSearch/IndexFactory.cpp (from rev 1132, trunk/Index/IndexFactory.cpp)

Copied: trunk/IndexSearch/IndexFactory.h (from rev 1132, trunk/Index/IndexFactory.h)

Copied: trunk/IndexSearch/IndexInterface.h (from rev 1132, trunk/Index/IndexInterface.h)

Copied: trunk/IndexSearch/OpenSearchParser.cpp (from rev 1132, trunk/Search/OpenSearchParser.cpp)

Copied: trunk/IndexSearch/OpenSearchParser.h (from rev 1132, trunk/Search/OpenSearchParser.h)

Copied: trunk/IndexSearch/PluginParsers.h (from rev 1132, trunk/Search/PluginParsers.h)

Copied: trunk/IndexSearch/PluginWebEngine.cpp (from rev 1132, trunk/Search/PluginWebEngine.cpp)

Copied: trunk/IndexSearch/PluginWebEngine.h (from rev 1132, trunk/Search/PluginWebEngine.h)

Copied: trunk/IndexSearch/Plugins (from rev 1132, trunk/Search/Plugins)

Copied: trunk/IndexSearch/QueryProperties.cpp (from rev 1132, trunk/Search/QueryProperties.cpp)

Copied: trunk/IndexSearch/QueryProperties.h (from rev 1132, trunk/Search/QueryProperties.h)

Copied: trunk/IndexSearch/ResultsExporter.cpp (from rev 1132, trunk/Search/ResultsExporter.cpp)

Copied: trunk/IndexSearch/ResultsExporter.h (from rev 1132, trunk/Search/ResultsExporter.h)

Copied: trunk/IndexSearch/SOAPEnv.h (from rev 1132, trunk/Search/SOAPEnv.h)

Copied: trunk/IndexSearch/SOAPEnvH.h (from rev 1132, trunk/Search/SOAPEnvH.h)

Copied: trunk/IndexSearch/SOAPEnvNS.cpp (from rev 1132, trunk/Search/SOAPEnvNS.cpp)

Copied: trunk/IndexSearch/SOAPEnvStub.h (from rev 1132, trunk/Search/SOAPEnvStub.h)

Copied: trunk/IndexSearch/SearchEngineFactory.cpp (from rev 1132, trunk/Search/SearchEngineFactory.cpp)

Copied: trunk/IndexSearch/SearchEngineFactory.h (from rev 1132, trunk/Search/SearchEngineFactory.h)

Copied: trunk/IndexSearch/SearchEngineInterface.cpp (from rev 1132, trunk/Search/SearchEngineInterface.cpp)

Copied: trunk/IndexSearch/SearchEngineInterface.h (from rev 1132, trunk/Search/SearchEngineInterface.h)

Copied: trunk/IndexSearch/SearchPluginProperties.cpp (from rev 1132, trunk/Search/SearchPluginProperties.cpp)

Copied: trunk/IndexSearch/SearchPluginProperties.h (from rev 1132, trunk/Search/SearchPluginProperties.h)

Copied: trunk/IndexSearch/SherlockParser.cpp (from rev 1132, trunk/Search/SherlockParser.cpp)

Copied: trunk/IndexSearch/SherlockParser.h (from rev 1132, trunk/Search/SherlockParser.h)

Copied: trunk/IndexSearch/WebEngine.cpp (from rev 1132, trunk/Search/WebEngine.cpp)

Copied: trunk/IndexSearch/WebEngine.h (from rev 1132, trunk/Search/WebEngine.h)

Copied: trunk/IndexSearch/Xapian/AbstractGenerator.cpp (from rev 1132, trunk/Search/AbstractGenerator.cpp)

Copied: trunk/IndexSearch/Xapian/AbstractGenerator.h (from rev 1132, trunk/Search/AbstractGenerator.h)

Copied: trunk/IndexSearch/Xapian/LanguageDetector.cpp (from rev 1132, trunk/Index/LanguageDetector.cpp)

Copied: trunk/IndexSearch/Xapian/LanguageDetector.h (from rev 1132, trunk/Index/LanguageDetector.h)

Copied: trunk/IndexSearch/Xapian/XapianDatabase.cpp (from rev 1132, trunk/Index/XapianDatabase.cpp)

Copied: trunk/IndexSearch/Xapian/XapianDatabase.h (from rev 1132, trunk/Index/XapianDatabase.h)

Copied: trunk/IndexSearch/Xapian/XapianDatabaseFactory.cpp (from rev 1132, trunk/Index/XapianDatabaseFactory.cpp)

Copied: trunk/IndexSearch/Xapian/XapianDatabaseFactory.h (from rev 1132, trunk/Index/XapianDatabaseFactory.h)

Copied: trunk/IndexSearch/Xapian/XapianEngine.cpp (from rev 1132, trunk/Search/XapianEngine.cpp)

Copied: trunk/IndexSearch/Xapian/XapianEngine.h (from rev 1132, trunk/Search/XapianEngine.h)

Copied: trunk/IndexSearch/Xapian/XapianIndex.cpp (from rev 1132, trunk/Index/XapianIndex.cpp)

Copied: trunk/IndexSearch/Xapian/XapianIndex.h (from rev 1132, trunk/Index/XapianIndex.h)

Copied: trunk/IndexSearch/pinot-index.1 (from rev 1132, trunk/Index/pinot-index.1)

Copied: trunk/IndexSearch/pinot-index.cpp (from rev 1132, trunk/Index/pinot-index.cpp)

Copied: trunk/IndexSearch/pinot-label.1 (from rev 1132, trunk/Index/pinot-label.1)

Copied: trunk/IndexSearch/pinot-label.cpp (from rev 1132, trunk/Index/pinot-label.cpp)

Copied: trunk/IndexSearch/pinot-search.1 (from rev 1132, trunk/Search/pinot-search.1)

Copied: trunk/IndexSearch/pinot-search.cpp (from rev 1132, trunk/Search/pinot-search.cpp)

Deleted: trunk/Search/AbstractGenerator.cpp
===================================================================
--- trunk/Search/AbstractGenerator.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/AbstractGenerator.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,256 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;string.h&gt;
-#include &lt;ctype.h&gt;
-#include &lt;sys/time.h&gt;
-#include &lt;glib.h&gt;
-#include &lt;map&gt;
-#include &lt;algorithm&gt;
-#include &lt;iostream&gt;
-#include &lt;utility&gt;
-
-#include &quot;Timer.h&quot;
-#include &quot;AbstractGenerator.h&quot;
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-using std::vector;
-using std::map;
-using std::find;
-
-unsigned int AbstractGenerator::m_maxSeedTerms = 5;
-unsigned int AbstractGenerator::m_minTermPositions = 10;
-
-AbstractGenerator::PositionWindow::PositionWindow() :
-	m_backWeight(0),
-	m_forwardWeight(0)
-{
-}
-
-AbstractGenerator::PositionWindow::~PositionWindow()
-{
-}
-
-AbstractGenerator::AbstractGenerator(const Xapian::Database *pIndex,
-	unsigned int wordsCount) :
-	m_pIndex(pIndex),
-	m_wordsCount(wordsCount)
-{
-}
-
-AbstractGenerator::~AbstractGenerator()
-{
-}
-
-/// Attempts to generate an abstract of wordsCount words.
-string AbstractGenerator::generateAbstract(Xapian::docid docId,
-	const vector&lt;string&gt; &amp;seedTerms)
-{
-	map&lt;Xapian::termpos, PositionWindow&gt; abstractWindows;
-	map&lt;Xapian::termpos, string&gt; wordsBuffer;
-	string summary;
-	Xapian::termpos bestPosition = 0, startPosition = 0;
-	unsigned int seedTermsCount = 0, bestWeight = 0;
-	bool topTerm = true;
-
-	if ((m_pIndex == NULL) ||
-		(seedTerms.empty() == true))
-	{
-		return &quot;&quot;;
-	}
-
-#ifdef DEBUG
-	Timer timer;
-	timer.start();
-#endif
-	for (vector&lt;string&gt;::const_iterator termIter = seedTerms.begin();
-		termIter != seedTerms.end(); ++termIter)
-	{
-		string termName(*termIter);
-
-		if (seedTermsCount &gt;= m_maxSeedTerms)
-		{
-			// Enough terms
-			break;
-		}
-
-#ifdef DEBUG
-		cout &lt;&lt; &quot;AbstractGenerator::generateAbstract: term &quot; &lt;&lt; termName &lt;&lt; endl;
-#endif
-		try
-		{
-			// Go through that term's position list in the document
-			for (Xapian::PositionIterator positionIter = m_pIndex-&gt;positionlist_begin(docId, termName);
-				positionIter != m_pIndex-&gt;positionlist_end(docId, termName); ++positionIter)
-			{
-				Xapian::termpos termPos = *positionIter;
-
-				// Take all the top term's positions into account, and some of 
-				// the other terms' too if the minimum number is not reached
-				if ((m_minTermPositions &gt; abstractWindows.size()) ||
-					(topTerm == true))
-				{
-					abstractWindows[termPos] = PositionWindow();
-				}
-
-				// Look for other terms close to that position
-				for (map&lt;Xapian::termpos, PositionWindow&gt;::iterator winIter = abstractWindows.begin();
-					winIter != abstractWindows.end(); ++winIter)
-				{
-					// Is this within the number of words we are interested in ?
-					if (winIter-&gt;first &gt; termPos)
-					{
-						if (winIter-&gt;first - termPos &lt;= m_wordsCount)
-						{
-							++winIter-&gt;second.m_backWeight;
-						}
-					}
-					else
-					{
-						if (termPos - winIter-&gt;first &lt;= m_wordsCount)
-						{
-							++winIter-&gt;second.m_forwardWeight;
-						}
-					}
-				}
-			}
-
-			topTerm = false;
-			++seedTermsCount;
-		}
-		catch (const Xapian::Error &amp;error)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;AbstractGenerator::generateAbstract: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-#endif
-			continue;
-		}
-
-#ifdef DEBUG
-		cout &lt;&lt; &quot;AbstractGenerator::generateAbstract: &quot; &lt;&lt; abstractWindows.size()
-			&lt;&lt; &quot; positions, &quot; &lt;&lt; seedTermsCount &lt;&lt; &quot; terms&quot; &lt;&lt; endl;
-#endif
-	}
-
-	// Go through positions and find out which one has the largest
-	// number of terms nearby
-	for (map&lt;Xapian::termpos, PositionWindow&gt;::iterator winIter = abstractWindows.begin();
-		winIter != abstractWindows.end(); ++winIter)
-	{
-		if (bestWeight &lt; winIter-&gt;second.m_backWeight)
-		{
-			bestPosition = winIter-&gt;first;
-			startPosition = 0;
-			if (bestPosition &gt; m_wordsCount)
-			{
-				startPosition = bestPosition - m_wordsCount;
-			}
-			bestWeight = winIter-&gt;second.m_backWeight;
-		}
-		if (bestWeight &lt; winIter-&gt;second.m_forwardWeight)
-		{
-			bestPosition = startPosition = winIter-&gt;first;
-			bestWeight = winIter-&gt;second.m_forwardWeight;
-		}
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;AbstractGenerator::generateAbstract: best position is &quot;
-		&lt;&lt; bestPosition &lt;&lt; &quot;:&quot; &lt;&lt; startPosition &lt;&lt; &quot; with weight &quot; &lt;&lt; bestWeight &lt;&lt; endl;
-#endif
-
-	try
-	{
-		// Go through the position list of each term
-		for (Xapian::TermIterator termIter = m_pIndex-&gt;termlist_begin(docId);
-			termIter != m_pIndex-&gt;termlist_end(docId); ++termIter)
-		{
-			string termName(*termIter);
-
-			// Skip prefixed terms
-			if (isupper((int)termName[0]) != 0)
-			{
-				continue;
-			}
-
-			for (Xapian::PositionIterator positionIter = m_pIndex-&gt;positionlist_begin(docId, termName);
-				positionIter != m_pIndex-&gt;positionlist_end(docId, termName); ++positionIter)
-			{
-				Xapian::termpos termPos = *positionIter;
-
-				// ...and get those that fall in the abstract window
-				if ((startPosition &lt;= termPos + 1) &amp;&amp;
-					(termPos &lt; startPosition + m_wordsCount))
-				{
-					wordsBuffer[termPos] = termName;
-				}
-			}
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;AbstractGenerator::generateAbstract: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-#endif
-		return &quot;&quot;;
-	}
-
-	// Generate the abstract
-	for (map&lt;Xapian::termpos, string&gt;::iterator wordIter = wordsBuffer.begin();
-		wordIter != wordsBuffer.end(); ++wordIter)
-	{
-		gchar *pEscToken = NULL;
-		gchar *pUTF8Token = NULL;
-		gsize bytesWritten = 0;
-
-		pUTF8Token = g_locale_to_utf8(wordIter-&gt;second.c_str(), wordIter-&gt;second.length(),
-			NULL, &amp;bytesWritten, NULL);
-		if (pUTF8Token != NULL)
-		{
-			pEscToken = g_markup_escape_text(pUTF8Token, -1);
-			g_free(pUTF8Token);
-		}
-		if (pEscToken == NULL)
-		{
-			continue;
-		}
-
-		// Is this a seed term ?
-		if (find(seedTerms.begin(), seedTerms.end(), wordIter-&gt;second) != seedTerms.end())
-		{
-			summary += &quot;&lt;b&gt;&quot;;
-			summary += pEscToken;
-			summary += &quot;&lt;/b&gt;&quot;;
-		}
-		else
-		{
-			summary += pEscToken;
-		}
-		summary += &quot; &quot;;
-
-		g_free(pEscToken);
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;AbstractGenerator::generateAbstract: summarized document &quot;
-		&lt;&lt; docId &lt;&lt; &quot; in &quot; &lt;&lt; timer.stop() &lt;&lt; &quot; ms&quot; &lt;&lt; endl;
-#endif
-
-	return summary;
-}

Deleted: trunk/Search/AbstractGenerator.h
===================================================================
--- trunk/Search/AbstractGenerator.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/AbstractGenerator.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,61 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _ABSTRACT_GENERATOR_H
-#define _ABSTRACT_GENERATOR_H
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include &lt;xapian.h&gt;
-
-/// Generates abstracts for indexed documents.
-class AbstractGenerator
-{
-	public:
-		AbstractGenerator(const Xapian::Database *pIndex, unsigned int wordsCount);
-		virtual ~AbstractGenerator();
-
-		/// Attempts to generate an abstract of wordsCount words.
-		std::string generateAbstract(Xapian::docid docId,
-			const std::vector&lt;std::string&gt; &amp;seedTerms);
-
-	protected:
-		static unsigned int m_maxSeedTerms;
-		static unsigned int m_minTermPositions;
-		const Xapian::Database *m_pIndex;
-		unsigned int m_wordsCount;
-
-		class PositionWindow
-		{
-			public:
-				PositionWindow();
-				~PositionWindow();
-
-				unsigned int m_backWeight;
-				unsigned int m_forwardWeight;
-
-		};
-
-	private:
-		AbstractGenerator(const AbstractGenerator &amp;other);
-		AbstractGenerator &amp;operator=(const AbstractGenerator &amp;other);
-
-};
-
-#endif // _ABSTRACT_GENERATOR_H

Deleted: trunk/Search/OpenSearchParser.cpp
===================================================================
--- trunk/Search/OpenSearchParser.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/OpenSearchParser.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,564 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;iostream&gt;
-#include &lt;glibmm/thread.h&gt;
-#include &lt;glibmm/convert.h&gt;
-#include &lt;libxml/parserInternals.h&gt;
-#include &lt;libxml++/parsers/domparser.h&gt;
-#include &lt;libxml++/nodes/node.h&gt;
-#include &lt;libxml++/nodes/textnode.h&gt;
-#include &lt;libxml++/nodes/cdatanode.h&gt;
-
-#include &quot;StringManip.h&quot;
-#include &quot;OpenSearchParser.h&quot;
-
-using namespace std;
-using namespace Glib;
-using namespace xmlpp;
-
-static ustring getNodeContent(const Node *pNode)
-{
-	if (pNode == NULL)
-	{
-		return &quot;&quot;;
-	}
-
-	// Is it an element ?
-	const Element *pElem = dynamic_cast&lt;const Element*&gt;(pNode);
-	if (pElem != NULL)
-	{
-#ifdef HAS_LIBXMLPP026
-		const TextNode *pText = pElem-&gt;get_child_content();
-#else
-		const TextNode *pText = pElem-&gt;get_child_text();
-#endif
-		if (pText == NULL)
-		{
-			// Maybe the text is given as CDATA
-			const Node::NodeList childNodes = pNode-&gt;get_children();
-			if (childNodes.size() == 1)
-			{
-				// Is it CDATA ?
-				const CdataNode *pContent = dynamic_cast&lt;const CdataNode*&gt;(*childNodes.begin());
-				if (pContent != NULL)
-				{
-					return pContent-&gt;get_content();
-				}
-			}
-
-			return &quot;&quot;;
-		}
-
-		return pText-&gt;get_content();
-	}
-
-	return &quot;&quot;;
-}
-
-OpenSearchResponseParser::OpenSearchResponseParser(bool rssResponse) :
-	ResponseParserInterface(),
-	m_rssResponse(rssResponse)
-{
-}
-
-OpenSearchResponseParser::~OpenSearchResponseParser()
-{
-}
-
-bool OpenSearchResponseParser::parse(const ::Document *pResponseDoc, vector&lt;DocumentInfo&gt; &amp;resultsList,
-	unsigned int &amp;totalResults, unsigned int &amp;firstResultIndex) const
-{
-	float pseudoScore = 100;
-	unsigned int contentLen = 0;
-	bool foundResult = false;
-
-	if ((pResponseDoc == NULL) ||
-		(pResponseDoc-&gt;getData(contentLen) == NULL) ||
-		(contentLen == 0))
-	{
-		return false;
-	}
-
-	// Make sure the response MIME type is sensible
-	string mimeType = pResponseDoc-&gt;getType();
-	if ((mimeType.empty() == false) &amp;&amp;
-		(mimeType.find(&quot;xml&quot;) == string::npos))
-	{
-		cerr &lt;&lt; &quot;OpenSearchResponseParser::parse: response is not XML&quot; &lt;&lt; endl;
-		return false;
-	}
-
-	const char *pContent = pResponseDoc-&gt;getData(contentLen);
-	try
-	{
-		bool loadFeed = false;
-
-		// Parse the configuration file
-		DomParser parser;
-		parser.set_substitute_entities(true);
-		parser.parse_memory_raw((const unsigned char *)pContent, (Parser::size_type)contentLen);
-		xmlpp::Document *pDocument = parser.get_document();
-		if (pDocument == NULL)
-		{
-			return false;
-		}
-
-		Node *pNode = pDocument-&gt;get_root_node();
-		Element *pRootElem = dynamic_cast&lt;Element *&gt;(pNode);
-		if (pRootElem == NULL)
-		{
-			return false;
-		}
-		// Check the top-level element is what we expect
-		ustring rootNodeName = pRootElem-&gt;get_name();
-		if (m_rssResponse == true)
-		{
-			if (rootNodeName == &quot;rss&quot;)
-			{
-				const Node::NodeList rssChildNodes = pRootElem-&gt;get_children();
-				for (Node::NodeList::const_iterator rssIter = rssChildNodes.begin();
-					rssIter != rssChildNodes.end(); ++rssIter)
-				{
-					Node *pRssNode = (*rssIter);
-					Element *pRssElem = dynamic_cast&lt;Element*&gt;(pRssNode);
-					if (pRssElem != NULL)
-					{
-						if (pRssElem-&gt;get_name() == &quot;channel&quot;)
-						{
-							pRootElem = pRssElem;
-							loadFeed = true;
-							break;
-						}
-					}
-				}
-			}
-		}
-		else
-		{
-			if (rootNodeName != &quot;feed&quot;)
-			{
-				return false;
-			}
-			loadFeed = true;
-		}
-
-		if (loadFeed == false)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;OpenSearchResponseParser::parse: error on root node &quot;
-				&lt;&lt; rootNodeName &lt;&lt; endl;
-#endif
-			return false;
-		}
-
-		// RSS
-		ustring itemNode(&quot;item&quot;);
-		ustring descriptionNode(&quot;description&quot;);
-		if (m_rssResponse == false)
-		{
-			// Atom
-			itemNode = &quot;entry&quot;;
-			descriptionNode = &quot;content&quot;;
-		}
-
-		// Go through the subnodes
-		const Node::NodeList childNodes = pRootElem-&gt;get_children();
-		for (Node::NodeList::const_iterator iter = childNodes.begin();
-			iter != childNodes.end(); ++iter)
-		{
-			Node *pChildNode = (*iter);
-			ustring nodeName(pChildNode-&gt;get_name());
-			ustring nodeContent(getNodeContent(pChildNode));
-
-			// Is this an OpenSearch extension ?
-			// FIXME: make sure namespace is opensearch
-			if (nodeName == &quot;totalResults&quot;)
-			{
-				if (nodeContent.empty() == false)
-				{
-					totalResults = min((unsigned int)atoi(nodeContent.c_str()), totalResults);
-#ifdef DEBUG
-					cout &lt;&lt; &quot;OpenSearchResponseParser::parse: total results &quot;
-						&lt;&lt; totalResults &lt;&lt; endl;
-#endif
-				}
-			}
-			else if (nodeName == &quot;startIndex&quot;)
-			{
-				if (nodeContent.empty() == false)
-				{
-					firstResultIndex = (unsigned int)atoi(nodeContent.c_str());
-#ifdef DEBUG
-					cout &lt;&lt; &quot;OpenSearchResponseParser::parse: first result index &quot;
-						&lt;&lt; firstResultIndex &lt;&lt; endl;
-#endif
-				}
-			}
-
-			if (nodeName != itemNode)
-			{
-				continue;
-			}
-
-			// Go through the item's subnodes
-			ustring title, url, extract;
-			const Node::NodeList itemChildNodes = pChildNode-&gt;get_children();
-			for (Node::NodeList::const_iterator itemIter = itemChildNodes.begin();
-				itemIter != itemChildNodes.end(); ++itemIter)
-			{
-				Node *pItemNode = (*itemIter);
-				Element *pItemElem = dynamic_cast&lt;Element*&gt;(pItemNode);
-				if (pItemElem == NULL)
-				{
-					continue;
-				}
-
-				ustring itemNodeName = pItemNode-&gt;get_name();
-				if (itemNodeName == &quot;title&quot;)
-				{
-					title = getNodeContent(pItemNode);
-				}
-				else if (itemNodeName == &quot;link&quot;)
-				{
-					if (m_rssResponse == true)
-					{
-						url = getNodeContent(pItemNode);
-					}
-					else
-					{
-						Attribute *pAttr = pItemElem-&gt;get_attribute(&quot;href&quot;);
-						if (pAttr != NULL)
-						{
-							url = pAttr-&gt;get_value();
-						}
-					}
-				}
-				else if (itemNodeName == descriptionNode)
-				{
-					extract = getNodeContent(pItemNode);
-				}
-			}
-
-			DocumentInfo result(title, url, &quot;&quot;, &quot;&quot;);
-			result.setExtract(extract);
-			result.setScore(pseudoScore);
-
-			resultsList.push_back(result);
-			--pseudoScore;
-			foundResult = true;
-			if (resultsList.size() &gt;= totalResults)
-			{
-				// Enough results
-				break;
-			}
-		}
-	}
-	catch (const std::exception&amp; ex)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;OpenSearchResponseParser::parse: caught exception: &quot; &lt;&lt; ex.what() &lt;&lt; endl;
-#endif
-		foundResult = false;
-	}
-
-	return foundResult;
-}
-
-OpenSearchParser::OpenSearchParser(const string &amp;fileName) :
-	PluginParserInterface(fileName)
-{
-}
-
-OpenSearchParser::~OpenSearchParser()
-{
-}
-
-ResponseParserInterface *OpenSearchParser::parse(SearchPluginProperties &amp;properties,
-	bool extractSearchParams)
-{
-	struct stat fileStat;
-	bool rssResponse = true, success = true;
-
-	if ((m_fileName.empty() == true) ||
-		(stat(m_fileName.c_str(), &amp;fileStat) != 0) ||
-		(!S_ISREG(fileStat.st_mode)))
-	{
-		return NULL;
-	}
-
-	try
-	{
-		// Parse the configuration file
-		DomParser parser;
-		parser.set_substitute_entities(true);
-		parser.parse_file(m_fileName);
-		xmlpp::Document *pDocument = parser.get_document();
-		if (pDocument == NULL)
-		{
-			return NULL;
-		}
-
-		Node *pNode = pDocument-&gt;get_root_node();
-		Element *pRootElem = dynamic_cast&lt;Element *&gt;(pNode);
-		if (pRootElem == NULL)
-		{
-			return NULL;
-		}
-		// Check the top-level element is what we expect
-		// MozSearch is very much like OpenSearch Description
-		ustring rootNodeName = pRootElem-&gt;get_name();
-		if ((rootNodeName != &quot;OpenSearchDescription&quot;) &amp;&amp;
-			(rootNodeName != &quot;SearchPlugin&quot;))
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;OpenSearchParser::parse: wrong root node &quot; &lt;&lt; rootNodeName &lt;&lt; endl;
-#endif
-			return NULL;
-		}
-
-		// Go through the subnodes
-		const Node::NodeList childNodes = pRootElem-&gt;get_children();
-		if (childNodes.empty() == false)
-		{
-			for (Node::NodeList::const_iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-			{
-				Node *pChildNode = (*iter);
-				Element *pElem = dynamic_cast&lt;Element*&gt;(pChildNode);
-				if (pElem == NULL)
-				{
-					continue;
-				}
-
-				ustring nodeName(pChildNode-&gt;get_name());
-				ustring nodeContent(getNodeContent(pChildNode));
-
-				if (nodeName == &quot;ShortName&quot;)
-				{
-					properties.m_name = nodeContent;
-				}
-				else if (nodeName == &quot;Description&quot;)
-				{
-					properties.m_description = nodeContent;
-				}
-				else if (nodeName == &quot;Url&quot;)
-				{
-					ustring url, type;
-					SearchPluginProperties::Response response = SearchPluginProperties::RSS_RESPONSE;
-					bool getMethod = true;
-
-					// Parse Query Syntax
-					Element::AttributeList attributes = pElem-&gt;get_attributes();
-					for (Element::AttributeList::const_iterator iter = attributes.begin();
-						iter != attributes.end(); ++iter)
-					{
-						Attribute *pAttr = (*iter);
-
-						if (pAttr != NULL)
-						{
-							ustring attrName = pAttr-&gt;get_name();
-							ustring attrContent = pAttr-&gt;get_value();
-
-							if (attrName == &quot;template&quot;)
-							{
-								url = attrContent;
-							}
-							else if (attrName == &quot;type&quot;)
-							{
-								type = attrContent;
-							}
-							else if (attrName == &quot;method&quot;)
-							{
-								// GET is the default method
-								if (StringManip::toLowerCase(attrContent) != &quot;get&quot;)
-								{
-									getMethod = false;
-								}
-							}
-						}
-					}
-
-					// Did we get the URL ?
-					if (url.empty() == true)
-					{
-						// It's probably provided as content, v1.0 style
-						url = nodeContent;
-					}
-
-					if (getMethod == true)
-					{
-						string::size_type startPos = 0, pos = url.find(&quot;?&quot;);
-
-						// Do we support that type ?
-						if (type == &quot;application/atom+xml&quot;)
-						{
-							response = SearchPluginProperties::ATOM_RESPONSE;
-							rssResponse = false;
-						}
-						else if ((type.empty() == false) &amp;&amp;
-							(type != &quot;application/rss+xml&quot;))
-						{
-							response = SearchPluginProperties::UNKNOWN_RESPONSE;
-#ifdef DEBUG
-							cout &lt;&lt; &quot;OpenSearchParser::parse: unsupported response type &quot;
-								&lt;&lt; type &lt;&lt; endl;
-#endif
-							continue;
-						}
-	
-						// Break the URL down into base and parameters
-						if (pos != string::npos)
-						{
-							string params(url.substr(pos + 1));
-
-							// URL
-							properties.m_baseUrl = url.substr(0, pos);
-#ifdef DEBUG
-							cout &lt;&lt; &quot;OpenSearchParser::parse: URL is &quot; &lt;&lt; url &lt;&lt; endl;
-#endif
-
-							// Split this into the actual parameters
-							params += &quot;&amp;&quot;;
-							pos = params.find(&quot;&amp;&quot;);
-							while (pos != string::npos)
-							{
-								string parameter(params.substr(startPos, pos - startPos));
-
-								string::size_type equalPos = parameter.find(&quot;=&quot;);
-								if (equalPos != string::npos)
-								{
-									string paramName(parameter.substr(0, equalPos));
-									string paramValue(parameter.substr(equalPos + 1));
-									SearchPluginProperties::Parameter param = SearchPluginProperties::UNKNOWN_PARAM;
-
-									if (paramValue == &quot;{searchTerms}&quot;)
-									{
-										param = SearchPluginProperties::SEARCH_TERMS_PARAM;
-									}
-									else if (paramValue == &quot;{count}&quot;)
-									{
-										param = SearchPluginProperties::COUNT_PARAM;
-									}
-									else if (paramValue == &quot;{startIndex}&quot;)
-									{
-										param = SearchPluginProperties::START_INDEX_PARAM;
-									}
-									else if (paramValue == &quot;{startPage}&quot;)
-									{
-										param = SearchPluginProperties::START_PAGE_PARAM;
-									}
-									else if (paramValue == &quot;{language}&quot;)
-									{
-										param = SearchPluginProperties::LANGUAGE_PARAM;
-									}
-									else if (paramValue == &quot;{outputEncoding}&quot;)
-									{
-										param = SearchPluginProperties::OUTPUT_ENCODING_PARAM;
-									}
-									else if (paramValue == &quot;{inputEncoding}&quot;)
-									{
-										param = SearchPluginProperties::INPUT_ENCODING_PARAM;
-									}
-
-									if (param != SearchPluginProperties::UNKNOWN_PARAM)
-									{
-										properties.m_parameters[param] = paramName;
-									}
-									else
-									{
-										// Append to the remainder
-										if (properties.m_parametersRemainder.empty() == false)
-										{
-											properties.m_parametersRemainder += &quot;&amp;&quot;;
-										}
-										properties.m_parametersRemainder += paramName;
-										properties.m_parametersRemainder += &quot;=&quot;;
-										properties.m_parametersRemainder += paramValue;
-									}
-								}
-
-								// Next
-								startPos = pos + 1;
-								pos = params.find_first_of(&quot;&amp;&quot;, startPos);
-							}
-						}
-
-						// Method
-						properties.m_method = SearchPluginProperties::GET_METHOD;
-						// Output type
-						properties.m_outputType = type;
-						// Response
-						properties.m_response = response;
-					}
-
-					// We ignore Param as we only support GET
-				}
-				else if (nodeName == &quot;Tags&quot;)
-				{
-					// This is supposed to be a space-delimited list, but use the whole thing as channel
-					properties.m_channel = nodeContent;
-				}
-				else if (nodeName == &quot;LongName&quot;)
-				{
-					properties.m_longName = nodeContent;
-				}
-				else if (nodeName == &quot;Language&quot;)
-				{
-					properties.m_languages.insert(nodeContent);
-				}
-				else if (nodeName == &quot;OutputEncoding&quot;)
-				{
-					properties.m_outputEncodings.insert(nodeContent);
-				}
-				else if (nodeName == &quot;InputEncoding&quot;)
-				{
-					properties.m_inputEncodings.insert(nodeContent);
-				}
-			}
-		}
-	}
-	catch (const std::exception&amp; ex)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;OpenSearchParser::parse: caught exception: &quot; &lt;&lt; ex.what() &lt;&lt; endl;
-#endif
-		success = false;
-	}
-
-	if (success == false)
-	{
-		return NULL;
-	}
-
-	// Scrolling
-	properties.m_nextIncrement = 1;
-	properties.m_nextBase = 1;
-	if (properties.m_parameters.find(SearchPluginProperties::START_PAGE_PARAM) != properties.m_parameters.end())
-	{
-		properties.m_scrolling = SearchPluginProperties::PER_PAGE;
-	}
-	else
-	{
-		properties.m_scrolling = SearchPluginProperties::PER_INDEX;
-	}
-
-	return new OpenSearchResponseParser(rssResponse);
-}

Deleted: trunk/Search/OpenSearchParser.h
===================================================================
--- trunk/Search/OpenSearchParser.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/OpenSearchParser.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,69 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _OPENSEARCH_PARSER_H
-#define _OPENSEARCH_PARSER_H
-
-#include &lt;string&gt;
-
-#include &quot;Document.h&quot;
-#include &quot;PluginParsers.h&quot;
-
-/// Parses OpenSearch Response.
-class OpenSearchResponseParser : public ResponseParserInterface
-{
-	public:
-		OpenSearchResponseParser(bool rssResponse);
-		virtual ~OpenSearchResponseParser();
-
-		/// Parses the response; false if not all could be parsed.
-		virtual bool parse(const Document *pResponseDoc, std::vector&lt;DocumentInfo&gt; &amp;resultsList,
-			unsigned int &amp;totalResults, unsigned int &amp;firstResultIndex) const;
-
-	protected:
-		bool m_rssResponse;
-
-	private:
-		OpenSearchResponseParser(const OpenSearchResponseParser &amp;other);
-		OpenSearchResponseParser&amp; operator=(const OpenSearchResponseParser&amp; other);
-
-};
-
-/** A parser for OpenSearch Description and Query Syntax, version 1.1.
-  * See <A HREF="http://opensearch.a9.com/spec/1.1/description/">http://opensearch.a9.com/spec/1.1/description/</A>
-  * and <A HREF="http://opensearch.a9.com/spec/1.1/querysyntax/">http://opensearch.a9.com/spec/1.1/querysyntax/</A>
-  * It can also parse MozSearch plugins.
-  * See <A HREF="http://developer.mozilla.org/en/docs/Creating_MozSearch_plugins">http://developer.mozilla.org/en/docs/Creating_MozSearch_plugins</A>
-  */
-class OpenSearchParser : public PluginParserInterface
-{
-	public:
-		OpenSearchParser(const std::string &amp;fileName);
-		virtual ~OpenSearchParser();
-
-		/// Parses the plugin and returns a response parser.
-		virtual ResponseParserInterface *parse(SearchPluginProperties &amp;properties,
-			bool extractSearchParams = false);
-
-	private:
-		OpenSearchParser(const OpenSearchParser &amp;other);
-		OpenSearchParser&amp; operator=(const OpenSearchParser&amp; other);
-
-};
-
-#endif // _OPENSEARCH_PARSER_H

Deleted: trunk/Search/PluginParsers.h
===================================================================
--- trunk/Search/PluginParsers.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/PluginParsers.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,69 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _PLUGIN_PARSERS_H
-#define _PLUGIN_PARSERS_H
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include &quot;Document.h&quot;
-#include &quot;SearchPluginProperties.h&quot;
-
-/// Interface implemented by response parsers.
-class ResponseParserInterface
-{
-	public:
-		virtual ~ResponseParserInterface()
-		{
-		}
-
-		/// Parses the response; false if not all could be parsed.
-		virtual bool parse(const Document *pResponseDoc, std::vector&lt;DocumentInfo&gt; &amp;resultsList,
-			unsigned int &amp;totalResults, unsigned int &amp;firstResultIndex) const = 0;
-
-	protected:
-		ResponseParserInterface()
-		{
-		}
-		
-};
-	
-/// Interface implemented by plugin parsers.
-class PluginParserInterface
-{
-	public:
-		virtual ~PluginParserInterface()
-		{
-		}
-
-		/// Parses the plugin and returns a response parser.
-		virtual ResponseParserInterface *parse(SearchPluginProperties &amp;properties,
-			bool extractSearchParams = false) = 0;
-
-	protected:
-		std::string m_fileName;
-
-		PluginParserInterface(const std::string &amp;fileName) :
-			m_fileName(fileName)
-		{
-		}
-
-};
-
-#endif // _PLUGIN_PARSERS_H

Deleted: trunk/Search/PluginWebEngine.cpp
===================================================================
--- trunk/Search/PluginWebEngine.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/PluginWebEngine.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,340 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;algorithm&gt;
-#include &lt;fstream&gt;
-#include &lt;iostream&gt;
-
-#include &quot;config.h&quot;
-#include &quot;Document.h&quot;
-#include &quot;StringManip.h&quot;
-#include &quot;OpenSearchParser.h&quot;
-#ifdef HAVE_BOOST_SPIRIT
-#include &quot;SherlockParser.h&quot;
-#endif
-#include &quot;PluginWebEngine.h&quot;
-
-using std::cout;
-using std::cerr;
-using std::endl;
-
-PluginWebEngine::PluginWebEngine(const string &amp;fileName) :
-	WebEngine(),
-	m_pResponseParser(NULL)
-{
-	load(fileName);
-}
-
-PluginWebEngine::~PluginWebEngine()
-{
-	if (m_pResponseParser != NULL)
-	{
-		delete m_pResponseParser;
-	}
-}
-
-void PluginWebEngine::load(const string &amp;fileName)
-{
-	if (fileName.empty() == true)
-	{
-		return;
-	}
-
-	PluginParserInterface *pParser = getPluginParser(fileName);
-	if (pParser == NULL)
-	{
-		return;
-	}
-
-	m_pResponseParser = pParser-&gt;parse(m_properties);
-	delete pParser;
-}
-
-bool PluginWebEngine::getPage(const string &amp;formattedQuery, unsigned int maxResultsCount)
-{
-	if ((m_pResponseParser == NULL) ||
-		(formattedQuery.empty() == true))
-	{
-		return false;
-	}
-
-	DocumentInfo docInfo(&quot;Results Page&quot;, formattedQuery,
-		&quot;text/html&quot;, &quot;&quot;);
-	Document *pResponseDoc = downloadPage(docInfo);
-	if (pResponseDoc == NULL)
-	{
-		cerr &lt;&lt; &quot;PluginWebEngine::getPage: couldn't download &quot;
-			&lt;&lt; formattedQuery &lt;&lt; endl;
-		return false;
-	}
-
-	unsigned int contentLen;
-	const char *pContent = pResponseDoc-&gt;getData(contentLen);
-	if ((pContent == NULL) ||
-		(contentLen == 0))
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;PluginWebEngine::getPage: downloaded empty page&quot; &lt;&lt; endl;
-#endif
-		delete pResponseDoc;
-		return false;
-	}
-#ifdef DEBUG
-	ofstream pageBackup(&quot;PluginWebEngine.html&quot;);
-	pageBackup.write(pContent, contentLen);
-	pageBackup.close();
-#endif
-
-	bool success = m_pResponseParser-&gt;parse(pResponseDoc, m_resultsList,
-		maxResultsCount, m_properties.m_nextBase);
-	vector&lt;DocumentInfo&gt;::iterator resultIter = m_resultsList.begin();
-	while (resultIter != m_resultsList.end())
-	{
-		if (processResult(formattedQuery, *resultIter) == false)
-		{
-			// Remove this result
-			if (resultIter == m_resultsList.begin())
-			{
-				m_resultsList.erase(resultIter);
-				resultIter = m_resultsList.begin();
-			}
-			else
-			{
-				vector&lt;DocumentInfo&gt;::iterator badResultIter = resultIter;
-				--resultIter;
-				m_resultsList.erase(badResultIter);
-			}
-		}
-		else
-		{
-			// Next
-			++resultIter;
-		}
-	}
-
-	delete pResponseDoc;
-
-	return success;
-}
-
-PluginParserInterface *PluginWebEngine::getPluginParser(const string &amp;fileName)
-{
-	if (fileName.empty() == true)
-	{
-		return NULL;
-	}
-
-	// What type of plugin is it ?
-	// Look at the file extension
-	string::size_type pos = fileName.find_last_of(&quot;.&quot;);
-	if (pos == string::npos)
-	{
-		// No way to tell
-		return NULL;
-	}
-
-	string extension(fileName.substr(pos + 1));
-#ifdef HAVE_BOOST_SPIRIT_CORE_HPP
-	if (strncasecmp(extension.c_str(), &quot;src&quot;, 3) == 0)
-	{
-		return new SherlockParser(fileName);
-	}
-	else
-#endif
-	if (strncasecmp(extension.c_str(), &quot;xml&quot;, 3) == 0)
-	{
-		return new OpenSearchParser(fileName);
-	}
-
-	return NULL;
-}
-
-bool PluginWebEngine::getDetails(const string &amp;fileName, string &amp;name, string &amp;channel)
-{
-	if (fileName.empty() == true)
-	{
-		return false;
-	}
-
-	PluginParserInterface *pParser = getPluginParser(fileName);
-	if (pParser == NULL)
-	{
-		return false;
-	}
-
-	SearchPluginProperties properties;
-	ResponseParserInterface *pResponseParser = pParser-&gt;parse(properties, true);
-	if (pResponseParser == NULL)
-	{
-		cerr &lt;&lt; &quot;PluginWebEngine::getDetails: couldn't parse &quot;
-			&lt;&lt; fileName &lt;&lt; endl;
-		delete pParser;
-
-		return false;
-	}
-	delete pResponseParser;
-	delete pParser;
-
-	if (properties.m_response == SearchPluginProperties::UNKNOWN_RESPONSE)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;PluginWebEngine::getDetails: bad response type for &quot;
-			&lt;&lt; fileName &lt;&lt; endl;
-#endif
-		return false;
-	}
-
-	name = properties.m_name;
-	channel = properties.m_channel;
-
-	return true;
-}
-
-//
-// Implementation of SearchEngineInterface
-//
-
-/// Runs a query; true if success.
-bool PluginWebEngine::runQuery(QueryProperties&amp; queryProps,
-	unsigned int startDoc)
-{
-	string queryString(queryProps.getFreeQuery(true));
-	char countStr[64];
-	unsigned int maxResultsCount(queryProps.getMaximumResultsCount());
-	unsigned int currentIncrement = 0, count = 0;
-
-	m_resultsList.clear();
-	m_resultsCountEstimate = 0;
-
-	if (queryProps.getType() != QueryProperties::XAPIAN_QP)
-	{
-		cerr &lt;&lt; &quot;PluginWebEngine::runQuery: query type not supported&quot; &lt;&lt; endl;
-		return false;
-	}
-
-	if (queryString.empty() == true)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;PluginWebEngine::runQuery: query is empty&quot; &lt;&lt; endl;
-#endif
-		return false;
-	}
-
-	map&lt;SearchPluginProperties::Parameter, string&gt;::iterator paramIter = m_properties.m_parameters.find(SearchPluginProperties::SEARCH_TERMS_PARAM);
-	if (paramIter == m_properties.m_parameters.end())
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;PluginWebEngine::runQuery: no user input tag&quot; &lt;&lt; endl;
-#endif
-		return false;
-	}
-
-	string userInputTag(paramIter-&gt;second);
-	string formattedQuery = m_properties.m_baseUrl;
-	formattedQuery += &quot;?&quot;;
-	formattedQuery += userInputTag;
-	formattedQuery += &quot;=&quot;;
-	formattedQuery += queryString;
-	if (m_properties.m_parametersRemainder.empty() == false)
-	{
-		formattedQuery += &quot;&amp;&quot;;
-		formattedQuery += m_properties.m_parametersRemainder;
-	}
-
-	setQuery(queryProps);
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;PluginWebEngine::runQuery: querying &quot;
-		&lt;&lt; m_properties.m_name &lt;&lt; endl;
-#endif
-	while (count &lt; maxResultsCount)
-	{
-		string pageQuery(formattedQuery);
-
-		// How do we scroll ?
-		if (m_properties.m_scrolling == SearchPluginProperties::PER_INDEX)
-		{
-			paramIter = m_properties.m_parameters.find(SearchPluginProperties::COUNT_PARAM);
-			if (paramIter != m_properties.m_parameters.end())
-			{
-				// Number of results requested
-				pageQuery += &quot;&amp;&quot;;
-				pageQuery += paramIter-&gt;second;
-				pageQuery += &quot;=&quot;;
-				snprintf(countStr, 64, &quot;%u&quot;, maxResultsCount);
-				pageQuery += countStr;
-			}
-
-			paramIter = m_properties.m_parameters.find(SearchPluginProperties::START_INDEX_PARAM);
-			if (paramIter != m_properties.m_parameters.end())
-			{
-				// The offset of the first result (typically 1 or 0)
-				pageQuery += &quot;&amp;&quot;;
-				pageQuery += paramIter-&gt;second;
-				pageQuery += &quot;=&quot;;
-				snprintf(countStr, 64, &quot;%u&quot;, count + m_properties.m_nextBase);
-				pageQuery += countStr;
-			}
-		}
-		else
-		{
-			paramIter = m_properties.m_parameters.find(SearchPluginProperties::START_PAGE_PARAM);
-			if (paramIter != m_properties.m_parameters.end())
-			{
-				// The offset of the page
-				pageQuery += &quot;&amp;&quot;;
-				pageQuery += paramIter-&gt;second;
-				pageQuery += &quot;=&quot;;
-				snprintf(countStr, 64, &quot;%u&quot;, currentIncrement + m_properties.m_nextBase);
-				pageQuery += countStr;
-			}
-		}
-
-		if (getPage(pageQuery, queryProps.getMaximumResultsCount()) == false)
-		{
-			break;
-		}
-
-		if (m_properties.m_nextIncrement == 0)
-		{
-			// That one page should have all the results...
-#ifdef DEBUG
-			cout &lt;&lt; &quot;PluginWebEngine::runQuery: performed one off call&quot; &lt;&lt; endl;
-#endif
-			break;
-		}
-		else
-		{
-			if (m_resultsList.size() &lt; count + m_properties.m_nextIncrement)
-			{
-				// We got less than the maximum number of results per page
-				// so there's no point in requesting the next page
-#ifdef DEBUG
-				cout &lt;&lt; &quot;PluginWebEngine::runQuery: last page wasn't full&quot; &lt;&lt; endl;
-#endif
-				break;
-			}
-
-			// Increase factor
-			currentIncrement += m_properties.m_nextIncrement;
-		}
-		count = m_resultsList.size();
-	}
-
-	return true;
-}

Deleted: trunk/Search/PluginWebEngine.h
===================================================================
--- trunk/Search/PluginWebEngine.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/PluginWebEngine.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,58 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _XML_WEB_ENGINE_H
-#define _XML_WEB_ENGINE_H
-
-#include &lt;string&gt;
-
-#include &quot;PluginParsers.h&quot;
-#include &quot;SearchPluginProperties.h&quot;
-#include &quot;WebEngine.h&quot;
-
-/// A plugin-based search engine.
-class PluginWebEngine : public WebEngine
-{
-	public:
-		PluginWebEngine(const std::string &amp;fileName);
-		virtual ~PluginWebEngine();
-
-		/// Utility method that returns a search plugin's name and channel.
-		static bool getDetails(const std::string &amp;fileName, std::string &amp;name, std::string &amp;channel);
-
-		/// Runs a query; true if success.
-		virtual bool runQuery(QueryProperties&amp; queryProps,
-			unsigned int startDoc = 0);
-
-	protected:
-		SearchPluginProperties m_properties;
-		ResponseParserInterface *m_pResponseParser;
-
-		void load(const std::string &amp;fileName);
-
-		bool getPage(const std::string &amp;formattedQuery, unsigned int maxResultsCount);
-
-		static PluginParserInterface *getPluginParser(const std::string &amp;fileName);
-
-	private:
-		PluginWebEngine(const PluginWebEngine &amp;other);
-		PluginWebEngine &amp;operator=(const PluginWebEngine &amp;other);
-
-};
-
-#endif // _XML_WEB_ENGINE_H

Deleted: trunk/Search/QueryProperties.cpp
===================================================================
--- trunk/Search/QueryProperties.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/QueryProperties.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,292 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;ctype.h&gt;
-#include &lt;set&gt;
-#include &lt;iostream&gt;
-#include &lt;algorithm&gt;
-#include &lt;utility&gt;
-
-#include &quot;Tokenizer.h&quot;
-#include &quot;QueryProperties.h&quot;
-
-QueryProperties::QueryProperties() :
-	m_type(XAPIAN_QP),
-	m_order(RELEVANCE),
-	m_resultsCount(10),
-	m_indexResults(false)
-{
-}
-
-QueryProperties::QueryProperties(const string &amp;name, const string &amp;freeQuery,
-	QueryType type) :
-	m_name(name),
-	m_type(type),
-	m_order(RELEVANCE),
-	m_freeQuery(freeQuery),
-	m_resultsCount(10),
-	m_indexResults(false)
-{
-	removeFilters();
-}
-
-QueryProperties::QueryProperties(const QueryProperties &amp;other) :
-	m_name(other.m_name),
-	m_type(other.m_type),
-	m_order(other.m_order),
-	m_freeQuery(other.m_freeQuery),
-	m_freeQueryWithoutFilters(other.m_freeQueryWithoutFilters),
-	m_resultsCount(other.m_resultsCount),
-	m_indexResults(other.m_indexResults),
-	m_labelName(other.m_labelName)
-{
-}
-
-QueryProperties::~QueryProperties()
-{
-}
-
-QueryProperties &amp;QueryProperties::operator=(const QueryProperties &amp;other)
-{
-	if (this != &amp;other)
-	{
-		m_name = other.m_name;
-		m_type = other.m_type;
-		m_order = other.m_order;
-		m_freeQuery = other.m_freeQuery;
-		m_freeQueryWithoutFilters = other.m_freeQueryWithoutFilters;
-		m_resultsCount = other.m_resultsCount;
-		m_indexResults = other.m_indexResults;
-		m_labelName = other.m_labelName;
-	}
-
-	return *this;
-}
-
-bool QueryProperties::operator==(const QueryProperties &amp;other) const
-{
-	if (m_name == other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-bool QueryProperties::operator&lt;(const QueryProperties &amp;other) const
-{
-	if (m_name &lt; other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-void QueryProperties::removeFilters(void)
-{
-	m_freeQueryWithoutFilters.clear();
-
-	if (m_freeQuery.empty() == true)
-	{
-		return;
-	}
-
-	if (m_type != XAPIAN_QP)
-	{
-		m_freeQueryWithoutFilters = m_freeQuery.substr(0, min(20, (int)m_freeQuery.length()));
-		return;
-	}
-
-	Document doc;
-
-	doc.setData(m_freeQuery.c_str(), m_freeQuery.length());
-	Tokenizer tokens(&amp;doc);
-
-	string token;
-	while (tokens.nextToken(token) == true)
-	{
-		if ((token.find(':') != string::npos) ||
-			(token.find(&quot;..&quot;) != string::npos))
-		{
-			// It's a filter or a range
-			continue;
-		}
-
-		if (m_freeQueryWithoutFilters.empty() == false)
-		{
-			m_freeQueryWithoutFilters += &quot; &quot;;
-		}
-		m_freeQueryWithoutFilters += token;
-	}
-}
-
-/// Sets the name.
-void QueryProperties::setName(const string &amp;name)
-{
-	m_name = name;
-}
-
-/// Gets the name.
-string QueryProperties::getName(void) const
-{
-	return m_name;
-}
-
-/// Sets the type.
-void QueryProperties::setType(QueryType type)
-{
-	m_type = type;
-}
-
-/// Gets the type.
-QueryProperties::QueryType QueryProperties::getType(void) const
-{
-	return m_type;
-}
-
-/// Sets the sort order.
-void QueryProperties::setSortOrder(SortOrder order)
-{
-	m_order = order;
-}
-
-/// Gets the sort order.
-QueryProperties::SortOrder QueryProperties::getSortOrder(void) const
-{
-	return m_order;
-}
-
-/// Sets the query string.
-void QueryProperties::setFreeQuery(const string &amp;freeQuery)
-{
-	m_freeQuery = freeQuery;
-	removeFilters();
-}
-
-/// Gets the query string.
-string QueryProperties::getFreeQuery(bool withoutFilters) const
-{
-	if (withoutFilters == false)
-	{
-		return m_freeQuery;
-	}
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;QueryProperties::getFreeQuery: &quot; &lt;&lt; m_freeQueryWithoutFilters &lt;&lt; endl;
-#endif
-	return m_freeQueryWithoutFilters;
-}
-
-/// Gets the value of a specific filter.
-string QueryProperties::getFilter(const string &amp;filterStr)
-{
-	if ((m_freeQuery.empty() == true) ||
-		(filterStr.empty() == true))
-	{
-		return &quot;&quot;;
-	}
-
-	Document doc;
-
-	doc.setData(m_freeQuery.c_str(), m_freeQuery.length());
-	Tokenizer tokens(&amp;doc, true);
-
-	string token;
-	while (tokens.nextToken(token) == true)
-	{
-		string::size_type langPos = token.find(filterStr + &quot;:&quot;);
-
-		// Is it the language filter ?
-		if (langPos != string::npos)
-		{
-			string filterValue(token.substr(langPos + filterStr.length() + 1));
-
-#ifdef DEBUG
-			cout &lt;&lt; &quot;QueryProperties::getFilter: &quot; &lt;&lt; filterStr &lt;&lt; &quot;=&quot; &lt;&lt; filterValue &lt;&lt; endl;
-#endif
-			return filterValue;
-		}
-	}
-
-	return &quot;&quot;;
-}
-
-/// Sets the maximum number of results.
-void QueryProperties::setMaximumResultsCount(unsigned int count)
-{
-	m_resultsCount = count;
-}
-
-/// Gets the maximum number of results.
-unsigned int QueryProperties::getMaximumResultsCount(void) const
-{
-	return m_resultsCount;
-}
-
-/// Sets whether results should be indexed.
-void QueryProperties::setIndexResults(bool index)
-{
-	m_indexResults = index;
-}
-
-/// Gets whether results should be indexed
-bool QueryProperties::getIndexResults(void) const
-{
-	return m_indexResults;
-}
-
-/// Sets the name of the label to use for indexed documents.
-void QueryProperties::setLabelName(const string &amp;labelName)
-{
-	m_labelName = labelName;
-}
-
-/// Gets the name of the label to use for indexed documents.
-string QueryProperties::getLabelName(void) const
-{
-	return m_labelName;
-}
-
-/// Returns the query's terms.
-void QueryProperties::getTerms(set&lt;string&gt; &amp;terms) const
-{
-	Document doc;
-
-	doc.setData(m_freeQueryWithoutFilters.c_str(), m_freeQueryWithoutFilters.length());
-	Tokenizer tokens(&amp;doc);
-
-	terms.clear();
-
-	string token;
-	while (tokens.nextToken(token) == true)
-	{
-		terms.insert(token);
-	}
-}
-
-/// Returns whether the query is empty.
-bool QueryProperties::isEmpty() const
-{
-	if (m_freeQuery.empty() == true)
-	{
-		return true;
-	}
-
-	return false;
-}

Deleted: trunk/Search/QueryProperties.h
===================================================================
--- trunk/Search/QueryProperties.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/QueryProperties.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,102 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _QUERY_PROPERTIES_H
-#define _QUERY_PROPERTIES_H
-
-#include &lt;string&gt;
-#include &lt;set&gt;
-
-using namespace std;
-
-/// This represents a query.
-class QueryProperties
-{
-	public:
-		typedef enum { XAPIAN_QP = 0, XESAM_QL, XESAM_UL } QueryType;
-		typedef enum { RELEVANCE = 0, DATE } SortOrder;
-
-		QueryProperties();
-		QueryProperties(const string &amp;name, const string &amp;freeQuery,
-			QueryType type = XAPIAN_QP);
-		QueryProperties(const QueryProperties &amp;other);
-		~QueryProperties();
-
-		QueryProperties &amp;operator=(const QueryProperties &amp;other);
-		bool operator==(const QueryProperties &amp;other) const;
-		bool operator&lt;(const QueryProperties &amp;other) const;
-
-		/// Sets the name.
-		void setName(const string &amp;name);
-		/// Gets the name.
-		string getName(void) const;
-
-		/// Sets the type.
-		void setType(QueryType type);
-		/// Gets the type.
-		QueryType getType(void) const;
-
-		/// Sets the sort order.
-		void setSortOrder(SortOrder order);
-		/// Gets the sort order.
-		SortOrder getSortOrder(void) const;
-
-		/// Sets the query string.
-		void setFreeQuery(const string &amp;freeQuery);
-		/// Gets the query string.
-		string getFreeQuery(bool withoutFilters = false) const;
-
-		/// Gets the value of a specific filter.
-		string getFilter(const string &amp;filterStr);
-
-		/// Sets the maximum number of results.
-		void setMaximumResultsCount(unsigned int count);
-		/// Gets the maximum number of results.
-		unsigned int getMaximumResultsCount(void) const;
-
-		/// Sets whether results should be indexed.
-		void setIndexResults(bool index);
-		/// Gets whether results should be indexed
-		bool getIndexResults(void) const;
-
-		/// Sets the name of the label to use for indexed documents.
-		void setLabelName(const string &amp;labelName);
-		/// Gets the name of the label to use for indexed documents.
-		string getLabelName(void) const;
-
-		/// Returns the query's terms.
-		void getTerms(set&lt;string&gt; &amp;terms) const;
-
-		/// Returns whether the query is empty.
-		bool isEmpty() const;
-
-	protected:
-		string m_name;
-		QueryType m_type;
-		SortOrder m_order;
-		string m_freeQuery;
-		string m_freeQueryWithoutFilters;
-		unsigned int m_resultsCount;
-		bool m_indexResults;
-		string m_labelName;
-
-		void removeFilters(void);
-
-};
-
-#endif // _QUERY_PROPERTIES_H

Deleted: trunk/Search/ResultsExporter.cpp
===================================================================
--- trunk/Search/ResultsExporter.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/ResultsExporter.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,275 +0,0 @@
-/*
- *  Copyright 2007 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;iostream&gt;
-#include &lt;fstream&gt;
-#include &lt;libxml++/parsers/domparser.h&gt;
-#include &lt;libxml++/nodes/node.h&gt;
-#include &lt;libxml++/nodes/textnode.h&gt;
-
-#include &quot;StringManip.h&quot;
-#include &quot;FilterUtils.h&quot;
-#include &quot;ResultsExporter.h&quot;
-
-using std::string;
-using std::vector;
-using std::ofstream;
-using std::endl;
-using xmlpp::Element;
-
-static Element *addChildElement(Element *pElem, const string &amp;nodeName, const string &amp;nodeContent)
-{
-	if (pElem == NULL)
-	{
-		return NULL;
-	}
-
-	Element *pSubElem = pElem-&gt;add_child(nodeName);
-	if (pSubElem != NULL)
-	{
-#ifdef HAS_LIBXMLPP026
-		pSubElem-&gt;set_child_content(nodeContent);
-#else
-		pSubElem-&gt;set_child_text(nodeContent);
-#endif
-	}
-
-	return pSubElem;
-}
-
-ResultsExporter::ResultsExporter(const string &amp;fileName,
-	const QueryProperties &amp;queryProps) :
-	m_fileName(fileName),
-	m_queryName(queryProps.getName()),
-	m_queryDetails(queryProps.getFreeQuery())
-{
-}
-
-ResultsExporter::~ResultsExporter()
-{
-}
-
-CSVExporter::CSVExporter(const string &amp;fileName,
-	const QueryProperties &amp;queryProps) :
-	ResultsExporter(fileName, queryProps)
-{
-}
-
-CSVExporter::~CSVExporter()
-{
-}
-
-bool CSVExporter::exportResults(const string &amp;engineName, unsigned int maxResultsCount,
-	const vector&lt;DocumentInfo&gt; &amp;resultsList)
-{
-	if ((resultsList.empty() == true) ||
-		(exportStart(engineName, maxResultsCount) == false))
-	{
-		return false;
-	}
-
-	for (vector&lt;DocumentInfo&gt;::const_iterator iter = resultsList.begin();
-		iter != resultsList.end(); ++iter)
-	{
-		exportResult(engineName, *iter);
-	}
-	exportEnd();
-
-	return true;
-}
-
-bool CSVExporter::exportStart(const string &amp;engineName, unsigned int maxResultsCount)
-{
-	if (m_fileName.empty() == true)
-	{
-		return false;
-	}
-
-	m_outputFile.open(m_fileName.c_str());
-	if (m_outputFile.good() == false)
-	{
-		m_outputFile.close();
-
-		return false;
-	}
-
-	m_outputFile &lt;&lt; &quot;\&quot;query\&quot;;\&quot;engine\&quot;;\&quot;caption\&quot;;\&quot;url\&quot;;\&quot;type\&quot;;\&quot;language\&quot;;\&quot;modtime\&quot;;\&quot;size\&quot;;\&quot;abstract\&quot;&quot; &lt;&lt; endl;
-
-	return true;
-}
-
-bool CSVExporter::exportResult(const string &amp;engineName, const DocumentInfo &amp;docInfo)
-{
-	string title(FilterUtils::stripMarkup(docInfo.getTitle()));
-	string extract(FilterUtils::stripMarkup(docInfo.getExtract()));
-
-	if (m_outputFile.good() == false)
-	{
-		return false;
-	}
-
-	// Double double-quotes
-	m_outputFile &lt;&lt; &quot;\&quot;&quot; &lt;&lt; StringManip::replaceSubString(m_queryName, &quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;)
-		&lt;&lt; &quot;\&quot;;\&quot;&quot; &lt;&lt; StringManip::replaceSubString(engineName, &quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;)
-		&lt;&lt; &quot;\&quot;;\&quot;&quot; &lt;&lt; StringManip::replaceSubString(title, &quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;)
-		&lt;&lt; &quot;\&quot;;\&quot;&quot; &lt;&lt; StringManip::replaceSubString(docInfo.getLocation(), &quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;)
-		&lt;&lt; &quot;\&quot;;\&quot;&quot; &lt;&lt; StringManip::replaceSubString(docInfo.getType(), &quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;)
-		&lt;&lt; &quot;\&quot;;\&quot;&quot; &lt;&lt; StringManip::replaceSubString(docInfo.getLanguage(), &quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;)
-		&lt;&lt; &quot;\&quot;;\&quot;&quot; &lt;&lt; StringManip::replaceSubString(docInfo.getTimestamp(), &quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;)
-		&lt;&lt; &quot;\&quot;;\&quot;&quot; &lt;&lt; docInfo.getSize()
-		&lt;&lt; &quot;\&quot;;\&quot;&quot; &lt;&lt; StringManip::replaceSubString(extract, &quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;)
-		&lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
-
-	return true;
-}
-
-void CSVExporter::exportEnd(void)
-{
-	m_outputFile.close();
-}
-
-OpenSearchExporter::OpenSearchExporter(const string &amp;fileName,
-	const QueryProperties &amp;queryProps) :
-	ResultsExporter(fileName, queryProps),
-	m_pDoc(NULL),
-	m_pChannelElem(NULL)
-{
-}
-
-OpenSearchExporter::~OpenSearchExporter()
-{
-}
-
-bool OpenSearchExporter::exportResults(const string &amp;engineName, unsigned int maxResultsCount,
-	const vector&lt;DocumentInfo&gt; &amp;resultsList)
-{
-	if ((resultsList.empty() == true) ||
-		(exportStart(engineName, maxResultsCount) == false))
-	{
-		return false;
-	}
-
-	for (vector&lt;DocumentInfo&gt;::const_iterator iter = resultsList.begin();
-		iter != resultsList.end(); ++iter)
-	{
-		exportResult(engineName, *iter);
-	}
-	exportEnd();
-
-	return true;
-}
-
-bool OpenSearchExporter::exportStart(const string &amp;engineName, unsigned int maxResultsCount)
-{
-	if (m_fileName.empty() == true)
-	{
-		return false;
-	}
-
-	if (m_pDoc != NULL)
-	{
-		delete m_pDoc;
-		m_pDoc = NULL;
-		m_pChannelElem = NULL;
-	}
-
-	Element *pRootElem = NULL;
-	string description(&quot;Search&quot;);
-	char numStr[64];
-
-	m_pDoc = new xmlpp::Document(&quot;1.0&quot;);
-
-	// Create a new node
-	pRootElem = m_pDoc-&gt;create_root_node(&quot;rss&quot;);
-	if (pRootElem == NULL)
-	{
-		return false;
-	}
-	pRootElem-&gt;set_attribute(&quot;version&quot;, &quot;2.0&quot;);
-	pRootElem-&gt;set_attribute(&quot;xmlns:opensearch&quot;, &quot;<A HREF="http://a9.com/-/spec/opensearch/1.1/">http://a9.com/-/spec/opensearch/1.1/</A>&quot;);
-	pRootElem-&gt;set_attribute(&quot;xmlns:atom&quot;, &quot;<A HREF="http://www.w3.org/2005/Atom">http://www.w3.org/2005/Atom</A>&quot;);
-
-	// User interface position and size
-	m_pChannelElem = pRootElem-&gt;add_child(&quot;channel&quot;);
-	if (m_pChannelElem == NULL)
-	{
-		return false;
-	}
-	if (m_queryName.empty() == false)
-	{
-		addChildElement(m_pChannelElem, &quot;title&quot;, m_queryName);
-	}
-	if (m_queryName.empty() == false)
-	{
-		description += &quot; for \&quot;&quot;;
-		description += m_queryName;
-		description += &quot;\&quot;&quot;;
-	}
-	if (engineName.empty() == false)
-	{
-		description += &quot; on &quot;;
-		description += engineName;
-	}
-	addChildElement(m_pChannelElem, &quot;description&quot;, description);
-	sprintf(numStr, &quot;%d&quot;, maxResultsCount);
-	addChildElement(m_pChannelElem, &quot;opensearch:totalResults&quot;, numStr);
-	addChildElement(m_pChannelElem, &quot;opensearch:itemsPerPage&quot;, numStr);
-	if (m_queryDetails.empty() == false)
-	{
-		Element *pQueryElem = addChildElement(m_pChannelElem, &quot;opensearch:Query&quot;, &quot;&quot;);
-		if (pQueryElem != NULL)
-		{
-			pQueryElem-&gt;set_attribute(&quot;role&quot;, &quot;request&quot;);
-			pQueryElem-&gt;set_attribute(&quot;searchTerms&quot;, m_queryDetails);
-			pQueryElem-&gt;set_attribute(&quot;startPage&quot;, &quot;1&quot;);
-		}
-	}
-
-	return true;
-}
-
-bool OpenSearchExporter::exportResult(const string &amp;engineName, const DocumentInfo &amp;docInfo)
-{
-	if (m_pChannelElem == NULL)
-	{
-		return false;
-	}
-
-	Element *pElem = m_pChannelElem-&gt;add_child(&quot;item&quot;);
-	addChildElement(pElem, &quot;title&quot;, docInfo.getTitle());
-	addChildElement(pElem, &quot;link&quot;, docInfo.getLocation());
-	addChildElement(pElem, &quot;description&quot;, FilterUtils::stripMarkup(docInfo.getExtract()));
-
-	return true;
-}
-
-void OpenSearchExporter::exportEnd(void)
-{
-	if (m_pDoc == NULL)
-	{
-		return;
-	}
-
-	// Save to file
-	m_pDoc-&gt;write_to_file_formatted(m_fileName);
-
-	m_pChannelElem = NULL;
-	delete m_pDoc;
-	m_pDoc = NULL;
-}
-

Deleted: trunk/Search/ResultsExporter.h
===================================================================
--- trunk/Search/ResultsExporter.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/ResultsExporter.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,133 +0,0 @@
-/*
- *  Copyright 2007 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _RESULTS_EXPORTER_H
-#define _RESULTS_EXPORTER_H
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;fstream&gt;
-#include &lt;libxml++/document.h&gt;
-#include &lt;libxml++/nodes/element.h&gt;
-
-#include &quot;DocumentInfo.h&quot;
-#include &quot;QueryProperties.h&quot;
-
-/// Exports results to a given format.
-class ResultsExporter
-{
-	public:
-		ResultsExporter(const std::string &amp;fileName,
-			const QueryProperties &amp;queryProps);
-		virtual ~ResultsExporter();
-
-		/// Exports a list of results.
-		virtual bool exportResults(const std::string &amp;engineName,
-			unsigned int maxResultsCount,
-			const std::vector&lt;DocumentInfo&gt; &amp;resultsList) = 0;
-
-		/// Starts export.
-		virtual bool exportStart(const std::string &amp;engineName,
-			unsigned int maxResultsCount) = 0;
-
-		/// Exports the given result.
-		virtual bool exportResult(const std::string &amp;engineName,
-			const DocumentInfo &amp;docInfo) = 0;
-
-		/// Ends export.
-		virtual void exportEnd(void) = 0;
-
-	protected:
-		std::string m_fileName;
-		std::string m_queryName;
-		std::string m_queryDetails;
-
-	private:
-		ResultsExporter(const ResultsExporter &amp;other);
-		ResultsExporter&amp; operator=(const ResultsExporter&amp; other);
-
-};
-
-/// Exports results to CSV.
-class CSVExporter : public ResultsExporter
-{
-	public:
-		CSVExporter(const std::string &amp;fileName,
-			const QueryProperties &amp;queryProps);
-		virtual ~CSVExporter();
-
-		/// Exports the results; false if an error occured.
-		virtual bool exportResults(const std::string &amp;engineName,
-			unsigned int maxResultsCount,
-			const std::vector&lt;DocumentInfo&gt; &amp;resultsList);
-
-		/// Starts export.
-		virtual bool exportStart(const std::string &amp;engineName,
-			unsigned int maxResultsCount);
-
-		/// Exports the given result.
-		virtual bool exportResult(const std::string &amp;engineName,
-			const DocumentInfo &amp;docInfo);
-
-		/// Ends export.
-		virtual void exportEnd(void);
-
-	protected:
-		std::ofstream m_outputFile;
-
-	private:
-		CSVExporter(const CSVExporter &amp;other);
-		CSVExporter&amp; operator=(const CSVExporter&amp; other);
-
-};
-
-/// Exports results to OpenSearch response. 
-class OpenSearchExporter : public ResultsExporter
-{
-	public:
-		OpenSearchExporter(const std::string &amp;fileName,
-			const QueryProperties &amp;queryProps);
-		virtual ~OpenSearchExporter();
-
-		/// Exports the results; false if an error occured.
-		virtual bool exportResults(const std::string &amp;engineName,
-			unsigned int maxResultsCount,
-			const std::vector&lt;DocumentInfo&gt; &amp;resultsList);
-
-		/// Starts export.
-		virtual bool exportStart(const std::string &amp;engineName,
-			unsigned int maxResultsCount);
-
-		/// Exports the given result.
-		virtual bool exportResult(const std::string &amp;engineName,
-			const DocumentInfo &amp;docInfo);
-
-		/// Ends export.
-		virtual void exportEnd(void);
-
-	protected:
-		xmlpp::Document *m_pDoc;
-		xmlpp::Element *m_pChannelElem;
-
-	private:
-		OpenSearchExporter(const OpenSearchExporter &amp;other);
-		OpenSearchExporter&amp; operator=(const OpenSearchExporter&amp; other);
-
-};
-
-#endif // _RESULTS_EXPORTER_H

Deleted: trunk/Search/SOAPEnv.h
===================================================================

Deleted: trunk/Search/SOAPEnvH.h
===================================================================
--- trunk/Search/SOAPEnvH.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SOAPEnvH.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,201 +0,0 @@
-/* SOAPEnvH.h
-   Generated by gSOAP 2.7.9e from SOAPEnv.h
-   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
-   This part of the software is released under one of the following licenses:
-   GPL, the gSOAP public license, or Genivia's license for commercial use.
-*/
-
-#ifndef SOAPEnvH_H
-#define SOAPEnvH_H
-#include &quot;SOAPEnvStub.h&quot;
-#ifndef WITH_NOIDREF
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap*, const void*, int);
-SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap*, const void*, const char*, int, int);
-SOAP_FMAC3 void *SOAP_FMAC4 soap_getelement(struct soap*, int*);
-
-#ifdef __cplusplus
-}
-#endif
-SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap*);
-#endif
-SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap*);
-
-SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap*, int, const char*, const char*, size_t*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist*);
-SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap*, const char*, void*, int, size_t, const char*, const char*);
-
-#ifndef SOAP_TYPE_byte
-#define SOAP_TYPE_byte (2)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap*, char *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap*, const char *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap*, const char*, int, const char *, const char*);
-SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap*, char *, const char*, const char*);
-SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap*, const char*, char *, const char*);
-
-#ifndef SOAP_TYPE_int
-#define SOAP_TYPE_int (1)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap*, int *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap*, const int *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap*, const char*, int, const int *, const char*);
-SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap*, int *, const char*, const char*);
-SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap*, const char*, int *, const char*);
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_SOAP_ENV__Fault
-#define SOAP_TYPE_SOAP_ENV__Fault (13)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap*, const char*, int, const struct SOAP_ENV__Fault *, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap*, const char*, struct SOAP_ENV__Fault *, const char*);
-SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap*, int);
-SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault*);
-SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
-SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap*, int, int, void*, size_t, const void*, size_t);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_SOAP_ENV__Reason
-#define SOAP_TYPE_SOAP_ENV__Reason (12)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap*, const char*, int, const struct SOAP_ENV__Reason *, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason *, const char*);
-SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap*, int);
-SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason*);
-SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
-SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap*, int, int, void*, size_t, const void*, size_t);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_SOAP_ENV__Detail
-#define SOAP_TYPE_SOAP_ENV__Detail (11)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap*, const char*, int, const struct SOAP_ENV__Detail *, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail *, const char*);
-SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap*, int);
-SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail*);
-SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
-SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap*, int, int, void*, size_t, const void*, size_t);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_SOAP_ENV__Code
-#define SOAP_TYPE_SOAP_ENV__Code (9)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap*, const char*, int, const struct SOAP_ENV__Code *, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code *, const char*);
-SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap*, int);
-SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code*);
-SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
-SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap*, int, int, void*, size_t, const void*, size_t);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_SOAP_ENV__Header
-#define SOAP_TYPE_SOAP_ENV__Header (8)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap*, const char*, int, const struct SOAP_ENV__Header *, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap*, const char*, struct SOAP_ENV__Header *, const char*);
-SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap*, int);
-SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header*);
-SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
-SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap*, int, int, void*, size_t, const void*, size_t);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
-#define SOAP_TYPE_PointerToSOAP_ENV__Reason (15)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap*, const char *, int, struct SOAP_ENV__Reason *const*, const char *);
-SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason **, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason **, const char*);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
-#define SOAP_TYPE_PointerToSOAP_ENV__Detail (14)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap*, const char *, int, struct SOAP_ENV__Detail *const*, const char *);
-SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail **, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail **, const char*);
-
-#endif
-
-#ifndef WITH_NOGLOBAL
-
-#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
-#define SOAP_TYPE_PointerToSOAP_ENV__Code (10)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap*, const char *, int, struct SOAP_ENV__Code *const*, const char *);
-SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code **, const char*, const char*);
-SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code **, const char*);
-
-#endif
-
-#ifndef SOAP_TYPE__QName
-#define SOAP_TYPE__QName (5)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap*, char **);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap*, char *const*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap*, char *const*, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap*, const char*, int, char*const*, const char*);
-SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap*, char **, const char*, const char*);
-SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap*, const char*, char **, const char*);
-
-#ifndef SOAP_TYPE_string
-#define SOAP_TYPE_string (3)
-#endif
-SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap*, char **);
-SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap*, char *const*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap*, char *const*, const char*, const char*);
-SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap*, const char*, int, char*const*, const char*);
-SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap*, char **, const char*, const char*);
-SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap*, const char*, char **, const char*);
-
-#endif
-
-/* End of SOAPEnvH.h */

Deleted: trunk/Search/SOAPEnvNS.cpp
===================================================================
--- trunk/Search/SOAPEnvNS.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SOAPEnvNS.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1 +0,0 @@
-struct Namespace *namespaces;

Deleted: trunk/Search/SOAPEnvStub.h
===================================================================
--- trunk/Search/SOAPEnvStub.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SOAPEnvStub.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,151 +0,0 @@
-/* SOAPEnvStub.h
-   Generated by gSOAP 2.7.9e from SOAPEnv.h
-   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
-   This part of the software is released under one of the following licenses:
-   GPL, the gSOAP public license, or Genivia's license for commercial use.
-*/
-
-#ifndef SOAPEnvStub_H
-#define SOAPEnvStub_H
-#include &quot;stdsoap2.h&quot;
-
-/******************************************************************************\
- *                                                                            *
- * Enumerations                                                               *
- *                                                                            *
-\******************************************************************************/
-
-
-/******************************************************************************\
- *                                                                            *
- * Classes and Structs                                                        *
- *                                                                            *
-\******************************************************************************/
-
-
-#ifndef SOAP_TYPE_SOAP_ENV__Header
-#define SOAP_TYPE_SOAP_ENV__Header (8)
-/* SOAP Header: */
-struct SOAP_ENV__Header
-{
-public:
-	void *dummy;	/* transient */
-};
-#endif
-
-#ifndef SOAP_TYPE_SOAP_ENV__Code
-#define SOAP_TYPE_SOAP_ENV__Code (9)
-/* SOAP Fault Code: */
-struct SOAP_ENV__Code
-{
-public:
-	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
-	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
-};
-#endif
-
-#ifndef SOAP_TYPE_SOAP_ENV__Detail
-#define SOAP_TYPE_SOAP_ENV__Detail (11)
-/* SOAP-ENV:Detail */
-struct SOAP_ENV__Detail
-{
-public:
-	int __type;	/* any type of element &lt;fault&gt; (defined below) */
-	void *fault;	/* transient */
-	char *__any;
-};
-#endif
-
-#ifndef SOAP_TYPE_SOAP_ENV__Reason
-#define SOAP_TYPE_SOAP_ENV__Reason (12)
-/* SOAP-ENV:Reason */
-struct SOAP_ENV__Reason
-{
-public:
-	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
-};
-#endif
-
-#ifndef SOAP_TYPE_SOAP_ENV__Fault
-#define SOAP_TYPE_SOAP_ENV__Fault (13)
-/* SOAP Fault: */
-struct SOAP_ENV__Fault
-{
-public:
-	char *faultcode;	/* optional element of type xsd:QName */
-	char *faultstring;	/* optional element of type xsd:string */
-	char *faultactor;	/* optional element of type xsd:string */
-	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
-	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
-	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
-	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
-	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
-	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
-};
-#endif
-
-/******************************************************************************\
- *                                                                            *
- * Types with Custom Serializers                                              *
- *                                                                            *
-\******************************************************************************/
-
-
-/******************************************************************************\
- *                                                                            *
- * Typedefs                                                                   *
- *                                                                            *
-\******************************************************************************/
-
-#ifndef SOAP_TYPE__XML
-#define SOAP_TYPE__XML (4)
-typedef char *_XML;
-#endif
-
-#ifndef SOAP_TYPE__QName
-#define SOAP_TYPE__QName (5)
-typedef char *_QName;
-#endif
-
-
-/******************************************************************************\
- *                                                                            *
- * Typedef Synonyms                                                           *
- *                                                                            *
-\******************************************************************************/
-
-
-/******************************************************************************\
- *                                                                            *
- * Externals                                                                  *
- *                                                                            *
-\******************************************************************************/
-
-
-/******************************************************************************\
- *                                                                            *
- * Service Operations                                                         *
- *                                                                            *
-\******************************************************************************/
-
-
-/******************************************************************************\
- *                                                                            *
- * Stubs                                                                      *
- *                                                                            *
-\******************************************************************************/
-
-
-/******************************************************************************\
- *                                                                            *
- * Skeletons                                                                  *
- *                                                                            *
-\******************************************************************************/
-
-SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);
-
-SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);
-
-#endif
-
-/* End of SOAPEnvStub.h */

Deleted: trunk/Search/SearchEngineFactory.cpp
===================================================================
--- trunk/Search/SearchEngineFactory.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SearchEngineFactory.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,106 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifdef HAVE_GOOGLEAPI
-#include &quot;GoogleAPIEngine.h&quot;
-#endif
-#include &quot;PluginWebEngine.h&quot;
-#include &quot;XapianEngine.h&quot;
-#include &quot;SearchEngineFactory.h&quot;
-
-SearchEngineFactory::SearchEngineFactory()
-{
-}
-
-SearchEngineFactory::~SearchEngineFactory()
-{
-}
-
-SearchEngineInterface *SearchEngineFactory::getSearchEngine(const string &amp;type, const string &amp;option)
-{
-	SearchEngineInterface *myEngine = NULL;
-
-	// Choice by type
-	if ((type == &quot;sherlock&quot;) ||
-		(type == &quot;opensearch&quot;))
-	{
-		myEngine = new PluginWebEngine(option);
-	}
-	else if (type == &quot;xapian&quot;)
-	{
-		myEngine = new XapianEngine(option);
-	}
-#ifdef HAVE_GOOGLEAPI
-	else if (type == &quot;googleapi&quot;)
-	{
-		myEngine = new GoogleAPIEngine(option);
-	}
-#endif
-
-	return myEngine;
-}
-
-string SearchEngineFactory::getSearchEngineName(const string &amp;type, const string &amp;option)
-{
-	if ((type == &quot;sherlock&quot;) ||
-		(type == &quot;opensearch&quot;))
-	{
-		string name, channel;
-
-		if (PluginWebEngine::getDetails(option, name, channel) == true)
-		{
-			return name;
-		}
-
-		return &quot;&quot;;
-	}
-	else if (type == &quot;xapian&quot;)
-	{
-		return option;
-	}
-
-	return type;
-}
-
-void SearchEngineFactory::getSupportedEngines(set&lt;string&gt; &amp;engines)
-{
-	engines.clear();
-
-	// List supported engines
-	engines.insert(&quot;sherlock&quot;);
-	engines.insert(&quot;opensearch&quot;);
-	engines.insert(&quot;xapian&quot;);
-#ifdef HAVE_GOOGLEAPI
-	engines.insert(&quot;googleapi&quot;);
-#endif
-}
-
-bool SearchEngineFactory::isSupported(const string &amp;type)
-{
-	if (
-#ifdef HAVE_GOOGLEAPI
-		(type == &quot;googleapi&quot;) ||
-#endif
-		(type == &quot;sherlock&quot;) ||
-		(type == &quot;xapian&quot;))
-	{
-		return true;
-	}
-
-	return false;	
-}

Deleted: trunk/Search/SearchEngineFactory.h
===================================================================
--- trunk/Search/SearchEngineFactory.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SearchEngineFactory.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,59 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _SEARCHENGINE_FACTORY_H
-#define _SEARCHENGINE_FACTORY_H
-
-#include &lt;string&gt;
-#include &lt;map&gt;
-#include &lt;set&gt;
-
-#include &quot;SearchEngineInterface.h&quot;
-
-using std::string;
-using std::map;
-using std::set;
-
-/// Factory for search engines.
-class SearchEngineFactory
-{
-	public:
-		virtual ~SearchEngineFactory();
-
-		/// Returns a SearchEngine of the specified type; NULL if unavailable.
-		static SearchEngineInterface *getSearchEngine(const string &amp;type, const string &amp;option);
-
-		/// Returns the name of the given engine.
-		static string getSearchEngineName(const string &amp;type, const string &amp;option);
-
-		/// Returns all supported engines.
-		static void getSupportedEngines(set&lt;string&gt; &amp;engines);
-
-		/// Indicates whether a search engine is supported or not.
-		static bool isSupported(const string &amp;type);
-
-	protected:
-		SearchEngineFactory();
-
-	private:
-		SearchEngineFactory(const SearchEngineFactory &amp;other);
-		SearchEngineFactory &amp;operator=(const SearchEngineFactory &amp;other);
-
-};
-
-#endif // _SEARCHENGINE_FACTORY_H

Deleted: trunk/Search/SearchEngineInterface.cpp
===================================================================
--- trunk/Search/SearchEngineInterface.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SearchEngineInterface.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,93 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;iostream&gt;
-
-#include &quot;Document.h&quot;
-#include &quot;StringManip.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;SearchEngineInterface.h&quot;
-
-using std::cout;
-using std::endl;
-
-SearchEngineInterface::SearchEngineInterface() :
-	m_defaultOperator(DEFAULT_OP_AND),
-	m_resultsCountEstimate(0)
-{
-}
-
-SearchEngineInterface::~SearchEngineInterface()
-{
-}
-
-/// Sets whether AND is the default operator.
-void SearchEngineInterface::setDefaultOperator(DefaultOperator op)
-{
-	m_defaultOperator = op;
-}
-
-/// Sets the set of documents to limit to.
-bool SearchEngineInterface::setLimitSet(const set&lt;string&gt; &amp;docsSet)
-{
-	// Not all engines support this
-	return false;
-}
-
-/// Sets the set of documents to expand from.
-bool SearchEngineInterface::setExpandSet(const set&lt;string&gt; &amp;docsSet)
-{
-	// Not all engines support this
-	return false;
-}
-
-/// Returns the downloader used if any.
-DownloaderInterface *SearchEngineInterface::getDownloader(void)
-{
-	return NULL;
-}
-
-/// Returns the results for the previous query.
-const vector&lt;DocumentInfo&gt; &amp;SearchEngineInterface::getResults(void) const
-{
-	return m_resultsList;
-}
-
-/// Returns an estimate of the total number of results for the previous query.
-unsigned int SearchEngineInterface::getResultsCountEstimate(void) const
-{
-	return m_resultsCountEstimate;
-}
-
-/// Returns the charset for the previous query's results.
-string SearchEngineInterface::getResultsCharset(void) const
-{
-	return m_charset;
-}
-
-/// Suggests a spelling correction.
-string SearchEngineInterface::getSpellingCorrection(void) const
-{
-	return m_correctedFreeQuery;
-}
-
-/// Returns expand terms from the previous query.
-const set&lt;string&gt; &amp;SearchEngineInterface::getExpandTerms(void) const
-{
-	return m_expandTerms;
-}

Deleted: trunk/Search/SearchEngineInterface.h
===================================================================
--- trunk/Search/SearchEngineInterface.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SearchEngineInterface.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,88 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _SEARCH_ENGINE_INTERFACE_H
-#define _SEARCH_ENGINE_INTERFACE_H
-
-#include &lt;time.h&gt;
-#include &lt;string&gt;
-#include &lt;set&gt;
-#include &lt;vector&gt;
-
-#include &quot;DownloaderInterface.h&quot;
-#include &quot;QueryProperties.h&quot;
-#include &quot;DocumentInfo.h&quot;
-
-using namespace std;
-
-/// Interface implemented by search engines.
-class SearchEngineInterface
-{
-	public:
-		typedef enum { DEFAULT_OP_AND = 0, DEFAULT_OP_OR } DefaultOperator;
-
-		virtual ~SearchEngineInterface();
-
-		/// Sets whether AND is the default operator.
-		virtual void setDefaultOperator(DefaultOperator op);
-
-		/// Sets the set of documents to limit to.
-		virtual bool setLimitSet(const set&lt;string&gt; &amp;docsSet);
-
-		/// Sets the set of documents to expand from.
-		virtual bool setExpandSet(const set&lt;string&gt; &amp;docsSet);
-
-		/// Returns the downloader used if any.
-		virtual DownloaderInterface *getDownloader(void);
-
-		/// Runs a query; true if success.
-		virtual bool runQuery(QueryProperties&amp; queryProps,
-			unsigned int startDoc = 0) = 0;
-
-		/// Returns the results for the previous query.
-		virtual const vector&lt;DocumentInfo&gt; &amp;getResults(void) const;
-
-		/// Returns an estimate of the total number of results for the previous query.
-		virtual unsigned int getResultsCountEstimate(void) const;
-
-		/// Returns the charset for the previous query's results.
-		virtual string getResultsCharset(void) const;
-
-		/// Suggests a spelling correction.
-		virtual string getSpellingCorrection(void) const;
-
-		/// Returns expand terms from the previous query.
-		virtual const set&lt;string&gt; &amp;getExpandTerms(void) const;
-
-	protected:
-		DefaultOperator m_defaultOperator;
-		vector&lt;DocumentInfo&gt; m_resultsList;
-		unsigned int m_resultsCountEstimate;
-		string m_charset;
-		string m_correctedFreeQuery;
-		set&lt;string&gt; m_expandTerms;
-
-		SearchEngineInterface();
-
-	private:
-		SearchEngineInterface(const SearchEngineInterface &amp;other);
-		SearchEngineInterface &amp;operator=(const SearchEngineInterface &amp;other);
-
-};
-
-#endif // _SEARCH_ENGINE_INTERFACE_H

Deleted: trunk/Search/SearchPluginProperties.cpp
===================================================================
--- trunk/Search/SearchPluginProperties.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SearchPluginProperties.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,114 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &quot;SearchPluginProperties.h&quot;
-
-using std::string;
-using std::map;
-using std::set;
-
-SearchPluginProperties::SearchPluginProperties() :
-	m_method(GET_METHOD),
-	m_scrolling(PER_PAGE),
-	m_nextIncrement(0),
-	m_nextBase(0),
-	m_response(UNKNOWN_RESPONSE)
-{
-}
-
-SearchPluginProperties::SearchPluginProperties(const SearchPluginProperties &amp;other) :
-	m_name(other.m_name),
-	m_longName(other.m_longName),
-	m_description(other.m_description),
-	m_channel(other.m_channel),
-	m_baseUrl(other.m_baseUrl),
-	m_method(other.m_method),
-	m_parametersRemainder(other.m_parametersRemainder),
-	m_outputType(other.m_outputType),
-	m_scrolling(other.m_scrolling),
-	m_nextIncrement(other.m_nextIncrement),
-	m_nextBase(other.m_nextBase),
-	m_response(other.m_response)
-{
-	copy(other.m_languages.begin(), other.m_languages.end(),
-		inserter(m_languages, m_languages.begin()));
-	copy(other.m_outputEncodings.begin(), other.m_outputEncodings.end(),
-		inserter(m_outputEncodings, m_outputEncodings.begin()));
-	copy(other.m_inputEncodings.begin(), other.m_inputEncodings.end(),
-		inserter(m_inputEncodings, m_inputEncodings.begin()));
-	copy(other.m_parameters.begin(), other.m_parameters.end(),
-		inserter(m_parameters, m_parameters.begin()));
-}
-
-SearchPluginProperties::~SearchPluginProperties()
-{
-}
-
-SearchPluginProperties&amp; SearchPluginProperties::operator=(const SearchPluginProperties&amp; other)
-{
-	if (this != &amp;other)
-	{
-		m_name = other.m_name;
-		m_longName = other.m_longName;
-		m_description = other.m_description;
-		m_channel = other.m_channel;
-		m_baseUrl = other.m_baseUrl;
-		m_method = other.m_method;
-		m_parametersRemainder = other.m_parametersRemainder;
-		m_outputType = other.m_outputType;
-		m_scrolling = other.m_scrolling;
-		m_nextIncrement = other.m_nextIncrement;
-		m_nextBase = other.m_nextBase;
-		m_response = other.m_response;
-
-		m_languages.clear();
-		copy(other.m_languages.begin(), other.m_languages.end(),
-			inserter(m_languages, m_languages.begin()));
-		m_outputEncodings.clear();
-		copy(other.m_outputEncodings.begin(), other.m_outputEncodings.end(),
-			inserter(m_outputEncodings, m_outputEncodings.begin()));
-		m_inputEncodings.clear();
-		copy(other.m_inputEncodings.begin(), other.m_inputEncodings.end(),
-			inserter(m_inputEncodings, m_inputEncodings.begin()));
-		m_parameters.clear();
-		copy(other.m_parameters.begin(), other.m_parameters.end(),
-			inserter(m_parameters, m_parameters.begin()));
-	}
-
-	return *this;
-}
-
-bool SearchPluginProperties::operator==(const SearchPluginProperties &amp;other) const
-{
-	if (m_name == other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-bool SearchPluginProperties::operator&lt;(const SearchPluginProperties &amp;other) const
-{
-	if (m_name &lt; other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}

Deleted: trunk/Search/SearchPluginProperties.h
===================================================================
--- trunk/Search/SearchPluginProperties.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SearchPluginProperties.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,72 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _SEARCH_PLUGIN_PROPERTIES_H
-#define _SEARCH_PLUGIN_PROPERTIES_H
-
-#include &lt;string&gt;
-#include &lt;map&gt;
-#include &lt;set&gt;
-
-/// Properties of a search plugin.
-class SearchPluginProperties
-{
-	public:
-		SearchPluginProperties();
-		SearchPluginProperties(const SearchPluginProperties &amp;other);
-		virtual ~SearchPluginProperties();
-
-		SearchPluginProperties&amp; operator=(const SearchPluginProperties&amp; other);
-		bool operator==(const SearchPluginProperties &amp;other) const;
-		bool operator&lt;(const SearchPluginProperties &amp;other) const;
-
-		typedef enum { GET_METHOD = 0, POST_METHOD } Method;
-
-		typedef enum { UNKNOWN_PARAM = 0, SEARCH_TERMS_PARAM,
-			 COUNT_PARAM,START_INDEX_PARAM, START_PAGE_PARAM, LANGUAGE_PARAM,
-			OUTPUT_ENCODING_PARAM, INPUT_ENCODING_PARAM } Parameter;
-
-		typedef enum { PER_PAGE = 0, PER_INDEX } Scrolling;
-
-		typedef enum { UNKNOWN_RESPONSE = 0, HTML_RESPONSE,
-			RSS_RESPONSE, ATOM_RESPONSE } Response;
-
-		// Description
-		std::string m_name;
-		std::string m_longName;
-		std::string m_description;
-		std::string m_channel;
-		std::set&lt;std::string&gt; m_languages;
-		std::set&lt;std::string&gt; m_outputEncodings;
-		std::set&lt;std::string&gt; m_inputEncodings;
-		// Query
-		std::string m_baseUrl;
-		Method m_method;
-		std::map&lt;Parameter, std::string&gt; m_parameters;
-		std::string m_parametersRemainder;
-		std::string m_outputType;
-		// Scrolling
-		Scrolling m_scrolling;
-		unsigned int m_nextIncrement;
-		unsigned int m_nextBase;
-		// Response
-		Response m_response;
-
-};
-
-#endif // _SEARCH_PLUGIN_PROPERTIES_H

Deleted: trunk/Search/SherlockParser.cpp
===================================================================
--- trunk/Search/SherlockParser.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SherlockParser.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,744 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;stdlib.h&gt;
-#include &lt;map&gt;
-#include &lt;set&gt;
-#include &lt;iostream&gt;
-#include &lt;boost/spirit/core.hpp&gt;
-#include &lt;boost/spirit/actor/push_back_actor.hpp&gt;
-#include &lt;boost/spirit/actor/insert_at_actor.hpp&gt;
-#include &lt;boost/spirit/utility/confix.hpp&gt;
-
-#include &quot;StringManip.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;HtmlFilter.h&quot;
-#include &quot;FilterFactory.h&quot;
-#include &quot;FileCollector.h&quot;
-#include &quot;FilterUtils.h&quot;
-#include &quot;SherlockParser.h&quot;
-
-using std::cout;
-using std::endl;
-using std::string;
-using std::vector;
-using std::map;
-using std::set;
-using std::exception;
-
-using namespace boost::spirit;
-
-// A function object to lower case map keys with for_each()
-struct LowerAndCopy
-{
-	public:
-		LowerAndCopy(map&lt;string, string&gt; &amp;other) :
-			m_other(other)
-		{
-		}
-
-		void operator()(map&lt;string, string&gt;::value_type &amp;p)
-		{
-			m_other[StringManip::toLowerCase(p.first)] = p.second;
-		}
-
-		map&lt;string, string&gt; &amp;m_other;
-
-};
-
-struct plugin_skip_grammar : public grammar&lt;plugin_skip_grammar&gt;
-{
-	template &lt;typename ScannerT&gt;
-	struct definition
-	{
-		definition(plugin_skip_grammar const &amp;self)
-		{
-			// Skip all spaces and comments, starting with a #
-			// FIXME: make sure comments start at the beginning of the line !
-			skip = space_p | (ch_p('#') &gt;&gt; *(anychar_p - ch_p('\n')) &gt;&gt; ch_p('\n'));
-		}
-	
-		rule&lt;ScannerT&gt; skip;
-	
-		rule&lt;ScannerT&gt; const&amp; start() const
-		{
-			return skip;
-		}
-	};
-};
-
-/**
-  * A minimal grammar for Sherlock plugins.
-  * This only checks for the existence of the SEARCH tag.
-  * It is used to quickly extract SEARCH attributes.
-  */
-struct plugin_min_grammar : public grammar&lt;plugin_min_grammar&gt;
-{
-	 plugin_min_grammar(map&lt;string, string&gt; &amp;searchParams) :
-		m_searchParams(searchParams)
-	{
-	}
-
-	template &lt;typename ScannerT&gt;
-	struct definition
-	{
-		definition(plugin_min_grammar const &amp;self)
-		{
-			// Start
-			search_plugin = search_header &gt;&gt; rest;
-
-			// All items have a name and an optionally-quoted value, separated by =
-			end_of_name = ch_p('=');
-			any_name = *(~ch_p('&gt;') - end_of_name);
-			any_value_without_quotes = lexeme_d[*(~ch_p('&gt;') - ch_p('\n'))];
-			any_value = ch_p('\'') &gt;&gt; (*(~ch_p('\'')))[assign_a(unquotedValue)] &gt;&gt; ch_p('\'') |
-				ch_p('&quot;') &gt;&gt; (*(~ch_p('&quot;')))[assign_a(unquotedValue)] &gt;&gt; ch_p('&quot;') |
-				any_value_without_quotes[assign_a(unquotedValue)];
-
-			// SEARCH attributes are items
-			// There should be only one SEARCH tag
-			search_item = (any_name[assign_a(itemName)]
-				&gt;&gt; ch_p('=') &gt;&gt; any_value[assign_a(itemValue, unquotedValue)])
-				[insert_at_a(self.m_searchParams, itemName, itemValue)];
-
-			// SEARCH may have any number of attributes
-			search_header = ch_p('&lt;') &gt;&gt; as_lower_d[str_p(&quot;search&quot;)] &gt;&gt; *search_item &gt;&gt; ch_p('&gt;');
-
-			// Rest
-			rest = *anychar_p;
-		}
-
-		string unquotedValue, itemName, itemValue;		
-		rule&lt;ScannerT&gt; search_plugin, search_header, rest;
-		rule&lt;ScannerT&gt; end_of_name, any_name, any_value_without_quotes, any_value, search_item;
-
-		rule&lt;ScannerT&gt; const&amp; start() const
-		{
-			return search_plugin;
-		}
-	};
-
-	map&lt;string, string&gt; &amp;m_searchParams;
-
-};
-
-/**
-  * A complete but lax grammar for Sherlock plugins.
-  * For instance, it doesn't mind if INPUT has a NAME but no VALUE.
-  * More importantly, it doesn't enforce types, eg FACTOR should be an integer.
-  */
-struct plugin_grammar : public grammar&lt;plugin_grammar&gt;
-{
-	plugin_grammar(map&lt;string, string&gt; &amp;searchParams,
-		map&lt;string, string&gt; &amp;interpretParams,
-		map&lt;string, string&gt; &amp;inputItems,
-		string &amp;userInput, string &amp;nextInput,
-		string &amp;nextFactor,
-		string &amp;nextValue) :
-		m_searchParams(searchParams),
-		m_interpretParams(interpretParams),
-		m_inputItems(inputItems),
-		m_userInput(userInput),
-		m_nextInput(nextInput),
-		m_nextFactor(nextFactor),
-		m_nextValue(nextValue)
-	{
-	}
-
-	template &lt;typename ScannerT&gt;
-	struct definition
-	{
-		definition(plugin_grammar const &amp;self)
-		{
-			// Start
-			search_plugin = search_header &gt;&gt; input_elements &gt;&gt; search_footer &gt;&gt; rest;
-
-			// All items have a name and an optionally-quoted value, separated by =
-			end_of_name = ch_p('=');
-			any_name = *(~ch_p('&gt;') - end_of_name);
-			any_value_without_quotes = lexeme_d[*(~ch_p('&gt;') - ch_p('\n'))];
-			any_value = ch_p('\'') &gt;&gt; (*(~ch_p('\'')))[assign_a(unquotedValue)] &gt;&gt; ch_p('\'') |
-				ch_p('&quot;') &gt;&gt; (*(~ch_p('&quot;')))[assign_a(unquotedValue)] &gt;&gt; ch_p('&quot;') |
-				any_value_without_quotes[assign_a(unquotedValue)];
-
-			// SEARCH attributes are items
-			// There should be only one SEARCH tag
-			search_item = (any_name[assign_a(itemName)]
-				&gt;&gt; ch_p('=') &gt;&gt; any_value[assign_a(itemValue, unquotedValue)])
-				[insert_at_a(self.m_searchParams, itemName, itemValue)];
-
-			// SEARCH may have any number of attributes
-			search_header = ch_p('&lt;') &gt;&gt; as_lower_d[str_p(&quot;search&quot;)] &gt;&gt; *search_item &gt;&gt; ch_p('&gt;');
-
-			// INPUT
-			input_item_name = as_lower_d[str_p(&quot;name&quot;)] &gt;&gt; ch_p('=')
-				&gt;&gt; any_value[assign_a(itemName, unquotedValue)];
-			input_item_value = as_lower_d[str_p(&quot;value&quot;)] &gt;&gt; ch_p('=')
-				&gt;&gt; any_value[assign_a(itemValue, unquotedValue)];
-			input_item_user = as_lower_d[str_p(&quot;user&quot;)];
-			input_item_factor = as_lower_d[str_p(&quot;factor&quot;)]
-				&gt;&gt; ch_p('=') &gt;&gt; any_value[assign_a(itemValue, unquotedValue)];
-
-			// INPUT tags have name and value items; one is marked with USER
-			input_item = input_item_name |
-				input_item_value |
-				input_item_user[assign_a(self.m_userInput, itemName)];
-
-			input_element = (ch_p('&lt;') &gt;&gt; as_lower_d[str_p(&quot;input&quot;)] &gt;&gt; *input_item &gt;&gt; ch_p('&gt;'))
-				[insert_at_a(self.m_inputItems, itemName, itemValue)];
-
-			// INPUTPREV tags have name and either factor or value items
-			// There should be only one INPUTPREV tag
-			// FIXME: save those
-			inputprev_item = input_item_name |
-				input_item_factor |
-				input_item_value;
-
-			inputprev_element = ch_p('&lt;') &gt;&gt; as_lower_d[str_p(&quot;inputprev&quot;)] &gt;&gt; *inputprev_item &gt;&gt; ch_p('&gt;');
-
-			// INPUTNEXT tags have name and either factor or value items
-			// There should be only one INPUTNEXT tag
-			inputnext_item = input_item_name[assign_a(self.m_nextInput, itemName)] |
-				input_item_factor[assign_a(self.m_nextFactor, itemValue)] |
-				input_item_value[assign_a(self.m_nextValue, itemValue)];
-
-			inputnext_element = ch_p('&lt;') &gt;&gt; as_lower_d[str_p(&quot;inputnext&quot;)] &gt;&gt; *inputnext_item &gt;&gt; ch_p('&gt;');
-
-			// INTERPRET tags have varied types of items
-			// There should be only one INTERPRET tag
-			interpret_item = (any_name[assign_a(itemName)]
-				&gt;&gt; ch_p('=') &gt;&gt; any_value[assign_a(itemValue, unquotedValue)])
-				[insert_at_a(self.m_interpretParams, itemName, itemValue)];
-
-			interpret_element = ch_p('&lt;') &gt;&gt; as_lower_d[str_p(&quot;interpret&quot;)] &gt;&gt; *interpret_item &gt;&gt; ch_p('&gt;');
-
-			// INPUT, INPUTNEXT and INTERPRET may appear in any order
-			input_elements = *(input_element |
-				inputprev_element |
-				inputnext_element |
-				interpret_element);
-
-			// SEARCH has a closing tag
-			search_footer =  ch_p('&lt;') &gt;&gt; ch_p('/') &gt;&gt; as_lower_d[str_p(&quot;search&quot;)] &gt;&gt; ch_p('&gt;');
-
-			// Rest
-			rest = *anychar_p;
-		}
-
-		string unquotedValue, itemName, itemValue;		
-		rule&lt;ScannerT&gt; search_plugin, search_header, search_footer, rest;
-		rule&lt;ScannerT&gt; end_of_name, any_name, any_value_without_quotes, any_value, search_item;
-		rule&lt;ScannerT&gt; input_elements, input_element, inputprev_element, inputnext_element, interpret_element;
-		rule&lt;ScannerT&gt; input_item_name, input_item_value, input_item_user, input_item_factor;
-		rule&lt;ScannerT&gt; input_item, inputprev_item, inputnext_item, interpret_item;
-
-		rule&lt;ScannerT&gt; const&amp; start() const
-		{
-			return search_plugin;
-		}
-	};
-
-	map&lt;string, string&gt; &amp;m_searchParams;
-	map&lt;string, string&gt; &amp;m_interpretParams;
-	map&lt;string, string&gt; &amp;m_inputItems;
-	string &amp;m_userInput;
-	string &amp;m_nextInput;
-	string &amp;m_nextFactor;
-	string &amp;m_nextValue;
-
-};
-
-SherlockResponseParser::SherlockResponseParser() :
-	ResponseParserInterface(),
-	m_skipLocal(true)
-{
-}
-
-SherlockResponseParser::~SherlockResponseParser()
-{
-}
-
-bool SherlockResponseParser::parse(const Document *pResponseDoc, vector&lt;DocumentInfo&gt; &amp;resultsList,
-	unsigned int &amp;totalResults, unsigned int &amp;firstResultIndex) const
-{
-	float pseudoScore = 100;
-	unsigned int contentLen = 0;
-	bool foundResult = false;
-
-	if ((pResponseDoc == NULL) ||
-		(pResponseDoc-&gt;getData(contentLen) == NULL) ||
-		(contentLen == 0))
-	{
-		return false;
-	}
-
-	// These two are the minimum we need
-	if ((m_resultItemStart.empty() == true) ||
-		(m_resultItemEnd.empty() == true))
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;SherlockResponseParser::parse: incomplete properties&quot; &lt;&lt; endl;
-#endif
-		return false;
-	}
-
-	// Extract the results list
-#ifdef DEBUG
-	cout &lt;&lt; &quot;SherlockResponseParser::parse: getting results list (&quot;
-		&lt;&lt; m_resultListStart &lt;&lt; &quot;, &quot; &lt;&lt; m_resultListEnd &lt;&lt; &quot;)&quot; &lt;&lt; endl;
-#endif
-	const char *pContent = pResponseDoc-&gt;getData(contentLen);
-	string resultList = StringManip::extractField(pContent, m_resultListStart, m_resultListEnd);
-	if (resultList.empty() == true)
-	{
-		resultList = string(pContent, contentLen);
-	}
-
-	// Extract results
-	string::size_type endPos = 0;
-#ifdef DEBUG
-	cout &lt;&lt; &quot;SherlockResponseParser::parse: getting first result (&quot;
-		&lt;&lt; m_resultItemStart &lt;&lt; &quot;, &quot; &lt;&lt; m_resultItemEnd &lt;&lt; &quot;)&quot; &lt;&lt; endl;
-#endif
-	string resultItem = StringManip::extractField(resultList,
-		m_resultItemStart, m_resultItemEnd, endPos);
-	while (resultItem.empty() == false)
-	{
-		string contentType, url, name, extract;
-
-#ifdef DEBUG
-		cout &lt;&lt; &quot;SherlockResponseParser::parse: candidate chunk \&quot;&quot;
-			&lt;&lt; resultItem &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
-#endif
-		contentType = pResponseDoc-&gt;getType();
-		if (strncasecmp(contentType.c_str(), &quot;text/html&quot;, 9) == 0)
-		{
-			Document chunkDoc(&quot;&quot;, &quot;&quot;, contentType, &quot;&quot;);
-			string htmlChunk(resultItem);
-
-			// The chunk may contain truncated tags, get rid of them !
-			string::size_type firstOpen = htmlChunk.find('&lt;');
-			string::size_type firstClose = htmlChunk.find('&gt;');
-			if (firstClose != string::npos)
-			{
-				if ((firstOpen == string::npos) ||
-					(firstClose &lt; firstOpen))
-				{
-					htmlChunk.erase(0, firstClose + 1);
-				}
-			}
-			string::size_type lastClose = htmlChunk.find_last_of(&quot;&gt;&quot;);
-			string::size_type lastOpen = htmlChunk.find_last_of(&quot;&lt;&quot;);
-			if (lastOpen != string::npos)
-			{
-				if ((lastClose == string::npos) ||
-					(lastOpen &gt; lastClose))
-				{
-					htmlChunk.erase(lastOpen);
-				}
-			}
-
-			// Wrap input
-			string dummyHtml(&quot;&lt;html&gt;&lt;head&gt;&lt;meta HTTP-EQUIV=\&quot;content-type\&quot; CONTENT=\&quot;&quot;);
-			dummyHtml += pResponseDoc-&gt;getType();
-			dummyHtml += &quot;\&quot;&gt;&lt;/head&gt;&lt;body&gt;&quot;;
-			dummyHtml += htmlChunk;
-			dummyHtml += &quot;&lt;/body&gt;&lt;/html&gt;&quot;;
-#ifdef DEBUG
-			cout &lt;&lt; &quot;SherlockResponseParser::parse: wrapped chunk \&quot;&quot;
-				&lt;&lt; dummyHtml &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
-#endif
-			chunkDoc.setData(dummyHtml.c_str(), dummyHtml.length());
-
-			// Feed this chunk to the filter
-			Dijon::HtmlFilter chunkFilter(&quot;text/html&quot;);
-			set&lt;Dijon::Link&gt; chunkLinks;
-			if ((FilterUtils::feedFilter(chunkDoc, &amp;chunkFilter) == true) &amp;&amp;
-				(chunkFilter.get_links(chunkLinks) == true) &amp;&amp;
-				(chunkFilter.next_document() == true))
-			{
-				unsigned int endOfFirstLink = 0, startOfSecondLink = 0, endOfSecondLink = 0, startOfThirdLink = 0;
-
-				// The result's URL and title should be given by the first link
-				for (set&lt;Dijon::Link&gt;::iterator linkIter = chunkLinks.begin(); linkIter != chunkLinks.end(); ++linkIter)
-				{
-					if (linkIter-&gt;m_index == 0)
-					{
-						url = linkIter-&gt;m_url;
-						name = linkIter-&gt;m_name;
-#ifdef DEBUG
-						cout &lt;&lt; &quot;SherlockResponseParser::parse: first link in chunk is &quot;
-							&lt;&lt; url &lt;&lt; endl;
-#endif
-						endOfFirstLink = linkIter-&gt;m_endPos;
-					}
-					else if (linkIter-&gt;m_index == 1)
-					{
-						startOfSecondLink = linkIter-&gt;m_startPos;
-						endOfSecondLink = linkIter-&gt;m_endPos;
-					}
-					else if (linkIter-&gt;m_index == 2)
-					{
-						startOfThirdLink = linkIter-&gt;m_startPos;
-					}
-				}
-
-				// Any extract ?
-				const map&lt;string, string&gt; &amp;metaData = chunkFilter.get_meta_data();
-				map&lt;string, string&gt;::const_iterator abstractIter = metaData.find(&quot;abstract&quot;);
-				if (abstractIter == metaData.end())
-				{
-					extract = FilterUtils::stripMarkup(resultItem);
-					StringManip::trimSpaces(extract);
-				}
-				else
-				{
-					extract = abstractIter-&gt;second;
-				}
-			}
-		}
-		else
-		{
-			// This is not HTML
-			// Use extended attributes
-			if ((m_resultTitleStart.empty() == false) &amp;&amp;
-				(m_resultTitleEnd.empty() == false))
-			{
-				name = StringManip::extractField(resultItem,
-					m_resultTitleStart, m_resultTitleEnd);
-			}
-
-			if ((m_resultLinkStart.empty() == false) &amp;&amp;
-				(m_resultLinkEnd.empty() == false))
-			{
-				url = StringManip::extractField(resultItem,
-					m_resultLinkStart, m_resultLinkEnd);
-			}
-
-			if ((m_resultExtractStart.empty() == false) &amp;&amp;
-				(m_resultExtractEnd.empty() == false))
-			{
-				extract = StringManip::extractField(resultItem,
-					m_resultExtractStart, m_resultExtractEnd);
-			}
-		}
-
-		if (url.empty() == false)
-		{
-			Url urlObj(url);
-
-			// Is this URL relative to the search engine's domain ?
-			// FIXME: look for a interpret/baseurl tag, see <A HREF="https://bugzilla.mozilla.org/show_bug.cgi?id=65453">https://bugzilla.mozilla.org/show_bug.cgi?id=65453</A>
-			// FIXME: obey m_skipLocal
-			if (urlObj.getHost().empty() == true)
-			{
-				Url baseUrlObj(pResponseDoc-&gt;getLocation());
-
-				string tmpUrl = baseUrlObj.getProtocol();
-				tmpUrl += &quot;://&quot;;
-				tmpUrl += baseUrlObj.getHost();
-				if (url[0] != '/')
-				{
-					tmpUrl += &quot;/&quot;;
-				}
-				tmpUrl += url;
-				url = tmpUrl;
-			}
-
-			DocumentInfo result(name, url, &quot;&quot;, &quot;&quot;);
-			result.setExtract(extract);
-			result.setScore(pseudoScore);
-
-			resultsList.push_back(result);
-			--pseudoScore;
-			foundResult = true;
-			if (resultsList.size() == totalResults)
-			{
-				// Enough results
-				break;
-			}
-		}
-
-		// Next
-		endPos += m_resultItemEnd.length();
-		resultItem = StringManip::extractField(resultList,
-			m_resultItemStart, m_resultItemEnd, endPos);
-	}
-
-	return foundResult;
-}
-
-pthread_mutex_t SherlockParser::m_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-SherlockParser::SherlockParser(const string &amp;fileName) :
-	PluginParserInterface(fileName)
-{
-}
-
-SherlockParser::~SherlockParser()
-{
-}
-
-ResponseParserInterface *SherlockParser::parse(SearchPluginProperties &amp;properties,
-	bool extractSearchParams)
-{
-	FileCollector fileCollect;
-	DocumentInfo docInfo(&quot;Sherlock Source&quot;, string(&quot;<A HREF="file://">file://</A>&quot;) + m_fileName,
-		&quot;text/plain&quot;, &quot;&quot;);
-
-	// Get the definition file
-	Document *pPluginDoc = fileCollect.retrieveUrl(docInfo);
-	if (pPluginDoc == NULL)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;SherlockParser::parse: couldn't load &quot; &lt;&lt; m_fileName &lt;&lt; endl;
-#endif
-		return NULL;
-	}
-
-	unsigned int dataLength;
-	const char *pData = pPluginDoc-&gt;getData(dataLength);
-	if ((pData == NULL) ||
-		(dataLength == 0))
-	{
-		delete pPluginDoc;
-		return NULL;
-	}
-
-	map&lt;string, string&gt; searchParams, interpretParams, inputItems;
-	string userInput, nextInput, nextFactor, nextValue;
-	bool parsedPlugin = false;
-
-	if (pthread_mutex_lock(&amp;m_mutex) == 0)
-	{
-		try
-		{
-			if (extractSearchParams == false)
-			{
-				plugin_skip_grammar skip;
-				plugin_grammar plugin(searchParams, interpretParams, inputItems,
-					userInput, nextInput, nextFactor, nextValue);
-
-				parse_info&lt;&gt; parseInfo = boost::spirit::parse(pData, plugin, skip);
-				parsedPlugin = parseInfo.hit;
-			}
-			else
-			{
-				plugin_skip_grammar skip;
-				plugin_min_grammar plugin(searchParams);
-
-				parse_info&lt;&gt; parseInfo = boost::spirit::parse(pData, plugin, skip);
-				parsedPlugin = parseInfo.hit;
-			}
-		}
-		catch (const exception &amp;e)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;SherlockParser::parse: caught exception ! &quot; &lt;&lt; e.what() &lt;&lt; endl;
-#endif
-			parsedPlugin = false;
-		}
-		catch (...)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;SherlockParser::parse: caught unknown exception !&quot; &lt;&lt; endl;
-#endif
-			parsedPlugin = false;
-		}
-
-		pthread_mutex_unlock(&amp;m_mutex);
-	}
-
-	// We are done with the document
-	delete pPluginDoc;
-
-	SherlockResponseParser *pResponseParser = NULL;
-
-	if (parsedPlugin == true)
-	{
-		map&lt;string, string&gt; lowSearchParams, lowInterpretParams, lowInputItems;
-
-		pResponseParser = new SherlockResponseParser();
-
-		LowerAndCopy lowCopy1(lowSearchParams);
-		for_each(searchParams.begin(), searchParams.end(), lowCopy1);
-		LowerAndCopy lowCopy2(lowInterpretParams);
-		for_each(interpretParams.begin(), interpretParams.end(), lowCopy2);
-		LowerAndCopy lowCopy3(lowInputItems);
-		for_each(inputItems.begin(), inputItems.end(), lowCopy3);
-
-		// Response
-		properties.m_response = SearchPluginProperties::HTML_RESPONSE;
-		// Method
-		properties.m_method = SearchPluginProperties::GET_METHOD;
-
-		// Name
-		map&lt;string, string&gt;::iterator mapIter = lowSearchParams.find(&quot;name&quot;);
-		if (mapIter != lowSearchParams.end())
-		{
-			properties.m_name = mapIter-&gt;second;
-		}
-
-		// Description
-		mapIter = lowSearchParams.find(&quot;description&quot;);
-		if (mapIter != lowSearchParams.end())
-		{
-			properties.m_description = mapIter-&gt;second;
-		}
-
-		// Channel
-		mapIter = lowSearchParams.find(&quot;routetype&quot;);
-		if (mapIter != lowSearchParams.end())
-		{
-			properties.m_channel = mapIter-&gt;second;
-		}
-
-		if (extractSearchParams == false)
-		{
-			if (userInput.empty() == false)
-			{
-				// Remove the user input tag from the input tags map
-				mapIter = lowInputItems.find(userInput);
-				if (mapIter != lowInputItems.end())
-				{
-					lowInputItems.erase(mapIter);
-				}
-
-				properties.m_parameters[SearchPluginProperties::SEARCH_TERMS_PARAM] = userInput;
-			}
-			for (map&lt;string, string&gt;::iterator iter = lowInputItems.begin();
-				iter != lowInputItems.end(); ++iter)
-			{
-				// Append to the remainder
-				if (properties.m_parametersRemainder.empty() == false)
-				{
-					properties.m_parametersRemainder += &quot;&amp;&quot;;
-				}
-				properties.m_parametersRemainder += iter-&gt;first;
-				properties.m_parametersRemainder += &quot;=&quot;;
-				properties.m_parametersRemainder += iter-&gt;second;
-			}
-
-			// URL
-			mapIter = lowSearchParams.find(&quot;action&quot;);
-			if (mapIter != lowSearchParams.end())
-			{
-				properties.m_baseUrl = mapIter-&gt;second;
-			}
-
-			// Response
-			mapIter = lowInterpretParams.find(&quot;resultliststart&quot;);
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser-&gt;m_resultListStart = StringManip::replaceSubString(mapIter-&gt;second, &quot;\\n&quot;, &quot;\n&quot;);
-			}
-
-			mapIter = lowInterpretParams.find(&quot;resultlistend&quot;);
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser-&gt;m_resultListEnd = StringManip::replaceSubString(mapIter-&gt;second, &quot;\\n&quot;, &quot;\n&quot;);
-			}
-
-			mapIter = lowInterpretParams.find(&quot;resultitemstart&quot;);
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser-&gt;m_resultItemStart = StringManip::replaceSubString(mapIter-&gt;second, &quot;\\n&quot;, &quot;\n&quot;);
-			}
-
-			mapIter = lowInterpretParams.find(&quot;resultitemend&quot;);
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser-&gt;m_resultItemEnd = StringManip::replaceSubString(mapIter-&gt;second, &quot;\\n&quot;, &quot;\n&quot;);
-			}
-
-			mapIter = lowInterpretParams.find(&quot;resulttitlestart&quot;);
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser-&gt;m_resultTitleStart = mapIter-&gt;second;
-			}
-
-			mapIter = lowInterpretParams.find(&quot;resulttitleend&quot;);
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser-&gt;m_resultTitleEnd = mapIter-&gt;second;
-			}
-
-			mapIter = lowInterpretParams.find(&quot;resultlinkstart&quot;);
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser-&gt;m_resultLinkStart = mapIter-&gt;second;
-			}
-
-			mapIter = lowInterpretParams.find(&quot;resultlinkend&quot;);
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser-&gt;m_resultLinkEnd = mapIter-&gt;second;
-			}
-
-			mapIter = lowInterpretParams.find(&quot;resultextractstart&quot;);
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser-&gt;m_resultExtractStart = mapIter-&gt;second;
-			}
-
-			mapIter = lowInterpretParams.find(&quot;resultextractend&quot;);
-			if (mapIter != lowInterpretParams.end())
-			{
-				pResponseParser-&gt;m_resultExtractEnd = mapIter-&gt;second;
-			}
-
-			mapIter = lowInterpretParams.find(&quot;skiplocal&quot;);
-			if (mapIter != lowInterpretParams.end())
-			{
-				if (mapIter-&gt;second == &quot;false&quot;)
-				{
-					pResponseParser-&gt;m_skipLocal = false;
-				}
-			}
-
-			// Here we differ from how Mozilla uses these parameters
-			// Normally, either factor or value is used, but we use value
-			// as the parameter's initial value
-			if (nextFactor.empty() == false)
-			{
-				properties.m_parameters[SearchPluginProperties::START_PAGE_PARAM] = nextInput;
-				properties.m_scrolling = SearchPluginProperties::PER_PAGE;
-				// What Sherlock calls a factor is actually an increment
-				properties.m_nextIncrement = (unsigned int)atoi(nextFactor.c_str());
-			}
-			else
-			{
-				// Assume INPUTNEXT allows to specify a number of results
-				// Not sure if this is how Sherlock/Mozilla interpret this
-				properties.m_parameters[SearchPluginProperties::COUNT_PARAM] = nextInput;
-				properties.m_scrolling = SearchPluginProperties::PER_INDEX;
-				properties.m_nextIncrement = 0;
-			}
-			if (nextValue.empty() == false)
-			{
-				properties.m_nextBase = (unsigned int)atoi(nextValue.c_str());
-			}
-			else
-			{
-				properties.m_nextBase = 0;
-			}
-		}
-	}
-
-	return pResponseParser;
-}

Deleted: trunk/Search/SherlockParser.h
===================================================================
--- trunk/Search/SherlockParser.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/SherlockParser.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,81 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _SHERLOCK_PARSER_H
-#define _SHERLOCK_PARSER_H
-
-#include &lt;pthread.h&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include &quot;Document.h&quot;
-#include &quot;PluginParsers.h&quot;
-
-/// Parses output of Sherlock-based search engines.
-class SherlockResponseParser : public ResponseParserInterface
-{
-	public:
-		SherlockResponseParser();
-		virtual ~SherlockResponseParser();
-
-		/// Parses the response; false if not all could be parsed.
-		virtual bool parse(const Document *pResponseDoc, std::vector&lt;DocumentInfo&gt; &amp;resultsList,
-			unsigned int &amp;totalResults, unsigned int &amp;firstResultIndex) const;
-
-		std::string m_resultListStart;
-		std::string m_resultListEnd;
-		std::string m_resultItemStart;
-		std::string m_resultItemEnd;
-		std::string m_resultTitleStart;
-		std::string m_resultTitleEnd;
-		std::string m_resultLinkStart;
-		std::string m_resultLinkEnd;
-		std::string m_resultExtractStart;
-		std::string m_resultExtractEnd;
-		bool m_skipLocal;
-
-	private:
-		SherlockResponseParser(const SherlockResponseParser &amp;other);
-		SherlockResponseParser&amp; operator=(const SherlockResponseParser&amp; other);
-
-};
-
-/** A parser for Sherlock plugin files.
-  * See <A HREF="http://developer.apple.com/technotes/tn/tn1141.html">http://developer.apple.com/technotes/tn/tn1141.html</A>
-  * and <A HREF="http://mycroft.mozdev.org/deepdocs/deepdocs.html">http://mycroft.mozdev.org/deepdocs/deepdocs.html</A>
-  */
-class SherlockParser : public PluginParserInterface
-{
-	public:
-		SherlockParser(const std::string &amp;fileName);
-		virtual ~SherlockParser();
-
-		/// Parses the plugin and returns a response parser.
-		virtual ResponseParserInterface *parse(SearchPluginProperties &amp;properties,
-			bool extractSearchParams = false);
-
-	protected:
-		static pthread_mutex_t m_mutex;
-
-	private:
-		SherlockParser(const SherlockParser &amp;other);
-		SherlockParser&amp; operator=(const SherlockParser&amp; other);
-
-};
-
-#endif // _SHERLOCK_PARSER_H

Deleted: trunk/Search/WebEngine.cpp
===================================================================
--- trunk/Search/WebEngine.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/WebEngine.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,235 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;string.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;glib.h&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;iostream&gt;
-
-#include &quot;StringManip.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;HtmlFilter.h&quot;
-#include &quot;DownloaderFactory.h&quot;
-#include &quot;FilterUtils.h&quot;
-#include &quot;Tokenizer.h&quot;
-#include &quot;WebEngine.h&quot;
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-using std::set;
-using std::vector;
-
-WebEngine::WebEngine() :
-	SearchEngineInterface(),
-	m_pDownloader(DownloaderFactory::getDownloader(&quot;http&quot;))
-{
-}
-
-WebEngine::~WebEngine()
-{
-	if (m_pDownloader != NULL)
-	{
-		delete m_pDownloader;
-	}
-}
-
-Document *WebEngine::downloadPage(const DocumentInfo &amp;docInfo)
-{
-	m_charset.clear();
-
-	if (m_pDownloader == NULL)
-	{
-		return NULL;
-	}
-
-	Document *pDoc = m_pDownloader-&gt;retrieveUrl(docInfo);
-	if (pDoc != NULL)
-	{
-		string contentType(pDoc-&gt;getType());
-
-		// Is a charset specified ?
-		string::size_type pos = contentType.find(&quot;charset=&quot;);
-		if (pos != string::npos)
-		{
-			m_charset = StringManip::removeQuotes(contentType.substr(pos + 8));
-		}
-		if (m_charset.empty() == true)
-		{
-			Dijon::HtmlFilter htmlFilter(&quot;text/html&quot;);
-
-			if (FilterUtils::feedFilter(*pDoc, &amp;htmlFilter) == true)
-			{
-				const map&lt;string, string&gt; &amp;metaData = htmlFilter.get_meta_data();
-				map&lt;string, string&gt;::const_iterator charsetIter = metaData.find(&quot;charset&quot;);
-
-				if (charsetIter != metaData.end())
-				{
-					m_charset = charsetIter-&gt;second;
-				}
-			}
-		}
-#ifdef DEBUG
-		cout &lt;&lt; &quot;WebEngine::downloadPage: charset is &quot; &lt;&lt; m_charset &lt;&lt; endl;
-#endif
-	}
-
-	return pDoc;
-}
-
-void WebEngine::setQuery(const QueryProperties &amp;queryProps)
-{
-	queryProps.getTerms(m_queryTerms);
-}
-
-bool WebEngine::processResult(const string &amp;queryUrl, DocumentInfo &amp;result)
-{
-	Url queryUrlObj(queryUrl);
-	string resultUrl(result.getLocation());
-	string queryHost(Url::reduceHost(queryUrlObj.getHost(), 2));
-
-	if (resultUrl.empty() == true)
-	{
-		return false;
-	}
-
-	if ((resultUrl[0] == '/') ||
-		((resultUrl.length() &gt; 1) &amp;&amp;
-		(resultUrl[0] == '.') &amp;&amp;
-		(resultUrl[1] == '/')))
-	{
-		string fullResultUrl(queryUrlObj.getProtocol());
-
-		fullResultUrl += &quot;://&quot;;
-		fullResultUrl += queryUrlObj.getHost();
-		if (resultUrl[0] == '.')
-		{
-			fullResultUrl += resultUrl.substr(1);
-		}
-		else
-		{
-			fullResultUrl += resultUrl;
-		}
-
-		resultUrl = fullResultUrl;
-	}
-
-	Url resultUrlObj(resultUrl);
-
-	// Is the result's host name the same as the search engine's ?
-	// FIXME: not all TLDs have leafs at level 2
-	if (queryHost == Url::reduceHost(resultUrlObj.getHost(), 2))
-	{
-		string protocol(resultUrlObj.getProtocol());
-
-		if (protocol.empty() == false)
-		{
-			string embeddedUrl;
-
-			string::size_type startPos = resultUrl.find(protocol, protocol.length());
-			if (startPos != string::npos)
-			{
-				string::size_type endPos = resultUrl.find(&quot;&amp;&quot;, startPos);
-				if (endPos != string::npos)
-				{
-					embeddedUrl = resultUrl.substr(startPos, endPos - startPos);
-				}
-				else
-				{
-					embeddedUrl = resultUrl.substr(startPos);
-				}
-
-				resultUrl = Url::unescapeUrl(embeddedUrl);
-			}
-#ifdef DEBUG
-			else cout &lt;&lt; &quot;WebEngine::processResult: no embedded URL&quot; &lt;&lt; endl;
-#endif
-		}
-#ifdef DEBUG
-		else cout &lt;&lt; &quot;WebEngine::processResult: no protocol&quot; &lt;&lt; endl;
-#endif
-	}
-
-	// Trim spaces
-	string trimmedUrl(resultUrl);
-	StringManip::trimSpaces(trimmedUrl);
-
-	// Make the URL canonical
-	result.setLocation(Url::canonicalizeUrl(trimmedUrl));
-
-	// Scan the extract for query terms
-	string extract(result.getExtract());
-	if (extract.empty() == true)
-	{
-		return true;
-	}
-
-	Document doc;
-	doc.setData(extract.c_str(), extract.length());
-	Tokenizer tokens(&amp;doc);
-
-	extract.clear();
-
-	string token;
-	while (tokens.nextToken(token) == true)
-	{
-		gchar *pEscToken = NULL;
-		gchar *pUTF8Token = NULL;
-		gsize bytesWritten = 0;
-
-		pUTF8Token = g_locale_to_utf8(token.c_str(), token.length(),
-			NULL, &amp;bytesWritten, NULL);
-		if (pUTF8Token != NULL)
-		{
-			pEscToken = g_markup_escape_text(pUTF8Token, -1);
-			g_free(pUTF8Token);
-		}
-		if (pEscToken == NULL)
-		{
-			continue;
-		}
-
-		// Is this a query term ?
-		if (m_queryTerms.find(StringManip::toLowerCase(token)) == m_queryTerms.end())
-		{
-			extract += pEscToken;
-		}
-		else
-		{
-			extract += &quot;&lt;b&gt;&quot;;
-			extract += pEscToken;
-			extract += &quot;&lt;/b&gt;&quot;;
-		}
-		extract += &quot; &quot;;
-
-		g_free(pEscToken);
-
-		result.setExtract(extract);
-	}
-
-	return true;
-}
-
-/// Returns the downloader used if any.
-DownloaderInterface *WebEngine::getDownloader(void)
-{
-	return m_pDownloader;
-}

Deleted: trunk/Search/WebEngine.h
===================================================================
--- trunk/Search/WebEngine.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/WebEngine.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,59 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _WEB_ENGINE_H
-#define _WEB_ENGINE_H
-
-#include &lt;string&gt;
-#include &lt;set&gt;
-
-#include &quot;Document.h&quot;
-#include &quot;QueryProperties.h&quot;
-#include &quot;SearchEngineInterface.h&quot;
-
-/// Base class for all Web search engines.
-class WebEngine : public SearchEngineInterface
-{
-	public:
-		WebEngine();
-		virtual ~WebEngine();
-
-		/// Returns the downloader used if any.
-		virtual DownloaderInterface *getDownloader(void);
-
-	protected:
-		DownloaderInterface *m_pDownloader;
-		std::set&lt;std::string&gt; m_queryTerms;
-
-		Document *downloadPage(const DocumentInfo &amp;docInfo);
-
-		void setHostNameFilter(const string &amp;filter);
-
-		void setFileNameFilter(const string &amp;filter);
-
-		void setQuery(const QueryProperties &amp;queryProps);
-
-		virtual bool processResult(const string &amp;queryUrl, DocumentInfo &amp;result);
-
-	private:
-		WebEngine(const WebEngine &amp;other);
-		WebEngine &amp;operator=(const WebEngine &amp;other);
-
-};
-
-#endif // _WEB_ENGINE_H

Deleted: trunk/Search/XapianEngine.cpp
===================================================================
--- trunk/Search/XapianEngine.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/XapianEngine.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,677 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;time.h&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;iostream&gt;
-#include &lt;algorithm&gt;
-
-#include &quot;Languages.h&quot;
-#include &quot;StringManip.h&quot;
-#include &quot;TimeConverter.h&quot;
-#include &quot;Timer.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;XapianDatabaseFactory.h&quot;
-#include &quot;AbstractGenerator.h&quot;
-#include &quot;XapianEngine.h&quot;
-#include &quot;xesam/XapianQueryBuilder.h&quot;
-#include &quot;xesam/XesamQLParser.h&quot;
-#ifdef HAVE_BOOST_SPIRIT
-#include &quot;xesam/XesamULParser.h&quot;
-#endif
-
-using std::string;
-using std::multimap;
-using std::vector;
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::inserter;
-using namespace Dijon;
-
-static void checkFilter(const string &amp;freeQuery, string::size_type filterValueStart,
-	bool &amp;escapeValue, bool &amp;hashValue)
-{
-	string filterName;
-	string::size_type filterNameStart = freeQuery.rfind(' ', filterValueStart);
-
-	escapeValue = hashValue = false;
-
-	if (filterNameStart == string::npos)
-	{
-		filterName = freeQuery.substr(0, filterValueStart);
-	}
-	else
-	{
-		filterName = freeQuery.substr(filterNameStart + 1, filterValueStart - filterNameStart - 1);
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;checkFilter: filter &quot; &lt;&lt; filterName &lt;&lt; endl;
-#endif
-
-	// In XapianIndex, these are escaped and hashed
-	if ((filterName == &quot;file&quot;) ||
-		(filterName ==&quot;dir&quot;) ||
-		(filterName == &quot;url&quot;))
-	{
-		escapeValue = hashValue = true;
-	}
-	// except label which is only escaped
-	else if (filterName == &quot;label&quot;)
-	{
-		escapeValue = true;
-	}
-}
-
-class TimeValueRangeProcessor : public Xapian::ValueRangeProcessor
-{
-	public:
-		TimeValueRangeProcessor(Xapian::valueno valueNumber) : Xapian::ValueRangeProcessor(), m_valueNumber(valueNumber) { }
-		~TimeValueRangeProcessor() { }
-
-		virtual Xapian::valueno operator()(string &amp;begin, string &amp;end)
-		{
-			if ((begin.size() == 6) &amp;&amp;
-					(end.size() == 6))
-			{
-				// HHMMSS
-#ifdef DEBUG
-				cout &lt;&lt; &quot;TimeValueRangeProcessor::operator: accepting &quot; &lt;&lt; begin &lt;&lt; &quot;..&quot; &lt;&lt; end &lt;&lt; endl;
-#endif
-				return m_valueNumber;
-			}
-			if ((begin.size() == 8) &amp;&amp; (end.size() == 8) &amp;&amp;
-					(begin[2] == begin[5]) &amp;&amp; (end[2] == end[5]) &amp;&amp; (begin[2] == end[2]) &amp;&amp;
-					(end[4] == ':'))
-			{
-				// HH:MM:SS
-				begin.erase(2, 1);
-				begin.erase(5, 1);
-				end.erase(2, 1);
-				end.erase(5, 1);
-#ifdef DEBUG
-				cout &lt;&lt; &quot;TimeValueRangeProcessor::operator: accepting &quot; &lt;&lt; begin &lt;&lt; &quot;..&quot; &lt;&lt; end &lt;&lt; endl;
-#endif
-				return m_valueNumber;
-			}
-#ifdef DEBUG
-			cout &lt;&lt; &quot;TimeValueRangeProcessor::operator: rejecting &quot; &lt;&lt; begin &lt;&lt; &quot;..&quot; &lt;&lt; end &lt;&lt; endl;
-#endif
-
-			return Xapian::BAD_VALUENO;
-		}
-
-	protected:
-		Xapian::valueno m_valueNumber;
-
-};
-
-class PrefixDecider : public Xapian::ExpandDecider
-{
-	public:
-		PrefixDecider(const string &amp;allowedPrefixes) : Xapian::ExpandDecider(), m_allowedPrefixes(allowedPrefixes) { }
-		~PrefixDecider() { }
-
-		virtual bool operator()(const std::string &amp;term) const
-		{
-			if ((isupper((int)(term[0])) == 0) ||
-				(m_allowedPrefixes.find(term[0]) != string::npos))
-			{
-				return true;
-			}
-#ifdef DEBUG
-			cout &lt;&lt; &quot;PrefixDecider::operator: rejecting &quot; &lt;&lt; term &lt;&lt; endl;
-#endif
-
-			return false;
-		}
-
-	protected:
-		string m_allowedPrefixes;
-
-};
-
-XapianEngine::XapianEngine(const string &amp;database) :
-	SearchEngineInterface()
-{
-	// If the database name ends with a slash, remove it
-	if (database[database.length() - 1] == '/')
-	{
-		m_databaseName = database.substr(0, database.length() - 1);
-	}
-	else
-	{
-		m_databaseName = database;
-	}
-}
-
-XapianEngine::~XapianEngine()
-{
-}
-
-Xapian::Query XapianEngine::parseQuery(Xapian::Database *pIndex, const QueryProperties &amp;queryProps,
-	const string &amp;stemLanguage, DefaultOperator defaultOperator,
-	const string &amp;limitQuery, string &amp;correctedFreeQuery, bool minimal)
-{
-	Xapian::QueryParser parser;
-	Xapian::Stem stemmer;
-	string freeQuery(StringManip::replaceSubString(queryProps.getFreeQuery(), &quot;\n&quot;, &quot; &quot;));
-	unsigned int minDay, minMonth, minYear = 0;
-	unsigned int maxDay, maxMonth, maxYear = 0;
-
-	// Set things up
-	if ((minimal == false) &amp;&amp;
-		(stemLanguage.empty() == false))
-	{
-		try
-		{
-			stemmer = Xapian::Stem(StringManip::toLowerCase(stemLanguage));
-		}
-		catch (const Xapian::Error &amp;error)
-		{
-			cerr &lt;&lt; &quot;Couldn't create stemmer: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-		}
-		parser.set_stemming_strategy(Xapian::QueryParser::STEM_ALL);
-		parser.set_stemmer(stemmer);
-	}
-	else
-	{
-		parser.set_stemming_strategy(Xapian::QueryParser::STEM_NONE);
-	}
-	// What's the default operator ?
-	if (defaultOperator == DEFAULT_OP_AND)
-	{
-		parser.set_default_op(Xapian::Query::OP_AND);
-	}
-	else
-	{
-		parser.set_default_op(Xapian::Query::OP_OR);
-	}
-	if (pIndex != NULL)
-	{
-		// The database is required for wildcards and spelling
-		parser.set_database(*pIndex);
-	}
-	// X prefixes should always include a colon
-	parser.add_boolean_prefix(&quot;site&quot;, &quot;H&quot;);
-	parser.add_boolean_prefix(&quot;file&quot;, &quot;P&quot;);
-	parser.add_boolean_prefix(&quot;ext&quot;, &quot;XEXT:&quot;);
-	parser.add_prefix(&quot;title&quot;, &quot;S&quot;);
-	parser.add_boolean_prefix(&quot;url&quot;, &quot;U&quot;);
-	parser.add_boolean_prefix(&quot;dir&quot;, &quot;XDIR:&quot;);
-	parser.add_boolean_prefix(&quot;lang&quot;, &quot;L&quot;);
-	parser.add_boolean_prefix(&quot;type&quot;, &quot;T&quot;);
-	parser.add_boolean_prefix(&quot;label&quot;, &quot;XLABEL:&quot;);
-
-	// Any limit on what documents should be searched ?
-	if (limitQuery.empty() == false)
-	{
-		string limitedQuery(limitQuery);
-
-		limitedQuery += &quot; AND ( &quot;;
-		limitedQuery += freeQuery;
-		limitedQuery += &quot; )&quot;;
-		freeQuery = limitedQuery;
-#ifdef DEBUG
-		cout &lt;&lt; &quot;XapianEngine::parseQuery: &quot; &lt;&lt; freeQuery &lt;&lt; endl;
-#endif
-	}
-
-	// Date range
-	Xapian::DateValueRangeProcessor dateProcessor(0);
-	parser.add_valuerangeprocessor(&amp;dateProcessor);
-
-	// Size with a &quot;b&quot; suffix, ie 1024..10240b
-#if XAPIAN_NUM_VERSION &gt;= 1001000
-	Xapian::NumberValueRangeProcessor sizeProcessor(2, &quot;b&quot;, false);
-	parser.add_valuerangeprocessor(&amp;sizeProcessor);
-#elif XAPIAN_NUM_VERSION &gt;= 1000002
-	// Xapian 1.02 is the bare minimum
-	Xapian::v102::NumberValueRangeProcessor sizeProcessor(2, &quot;b&quot;, false);
-	parser.add_valuerangeprocessor(&amp;sizeProcessor);
-#endif
-
-	// Time range
-	TimeValueRangeProcessor timeProcessor(3);
-	parser.add_valuerangeprocessor(&amp;timeProcessor);
-
-	// What type of query is this ?
-	QueryProperties::QueryType type = queryProps.getType();
-	if (type != QueryProperties::XAPIAN_QP)
-	{
-		map&lt;string, string&gt; fieldMapping;
-
-		// Bare minimum mapping between Xesam fields and our prefixes 
-		fieldMapping[&quot;dc:title&quot;] = &quot;S&quot;;
-
-		XapianQueryBuilder builder(parser, fieldMapping);
-		XesamParser *pParser = NULL;
-
-		// Get a Xesam parser
-		if (type == QueryProperties::XESAM_QL)
-		{
-			pParser = new XesamQLParser();
-		}
-#ifdef HAVE_BOOST_SPIRIT_CORE_HPP
-		else if (type == QueryProperties::XESAM_UL)
-		{
-			pParser = new XesamULParser();
-		}
-#endif
-
-		if (pParser != NULL)
-		{
-			bool parsedQuery = pParser-&gt;parse(freeQuery, builder);
-
-			delete pParser;
-
-			if (parsedQuery == true)
-			{
-				return builder.get_query();
-			}
-		}
-
-		return Xapian::Query();
-	}
-
-	// Do some pre-processing : look for filters with quoted values
-	string::size_type escapedFilterEnd = 0;
-	string::size_type escapedFilterStart = freeQuery.find(&quot;:\&quot;&quot;);
-	while ((escapedFilterStart != string::npos) &amp;&amp;
-		(escapedFilterStart &lt; freeQuery.length() - 2))
-	{
-		escapedFilterEnd = freeQuery.find(&quot;\&quot;&quot;, escapedFilterStart + 2);
-		if (escapedFilterEnd == string::npos)
-		{
-			break;
-		}
-
-		string filterValue = freeQuery.substr(escapedFilterStart + 2, escapedFilterEnd - escapedFilterStart - 2);
-		if (filterValue.empty() == false)
-		{
-			string escapedValue(Url::escapeUrl(filterValue));
-			bool escapeValue = false, hashValue = false;
-
-			// The value should be escaped and length-limited as done at indexing time
-			checkFilter(freeQuery, escapedFilterStart, escapeValue, hashValue);
-
-			if (escapeValue == false)
-			{
-				// No escaping
-				escapedValue = filterValue;
-			}
-			if (hashValue == true)
-			{
-				// Partially hash if necessary
-				escapedValue = XapianDatabase::limitTermLength(escapedValue, true);
-			}
-			else
-			{
-				escapedValue = XapianDatabase::limitTermLength(escapedValue);
-			}
-
-			freeQuery.replace(escapedFilterStart + 1, escapedFilterEnd - escapedFilterStart,
-				escapedValue);
-			escapedFilterEnd = escapedFilterEnd + escapedValue.length() - filterValue.length();
-		}
-		else
-		{
-			// No value !
-			freeQuery.replace(escapedFilterStart, escapedFilterEnd - escapedFilterStart + 1, &quot;:&quot;);
-			escapedFilterEnd -= 2;
-		}
-#ifdef DEBUG
-		cout &lt;&lt; &quot;XapianEngine::parseQuery: replaced filter: &quot; &lt;&lt; freeQuery &lt;&lt; endl;
-#endif
-
-		// Next
-		escapedFilterStart = freeQuery.find(&quot;:\&quot;&quot;, escapedFilterEnd);
-	}
-
-	// Parse the query string with all necessary options
-	unsigned int flags = Xapian::QueryParser::FLAG_BOOLEAN|Xapian::QueryParser::FLAG_PHRASE|
-		Xapian::QueryParser::FLAG_LOVEHATE|Xapian::QueryParser::FLAG_BOOLEAN_ANY_CASE|
-		Xapian::QueryParser::FLAG_PURE_NOT;
-	if (minimal == false)
-	{
-		flags |= Xapian::QueryParser::FLAG_WILDCARD;
-#if ENABLE_XAPIAN_SPELLING_CORRECTION&gt;0
-		flags |= Xapian::QueryParser::FLAG_SPELLING_CORRECTION;
-#endif
-	}
-	Xapian::Query parsedQuery = parser.parse_query(freeQuery, flags);
-	if (minimal == true)
-	{
-		return parsedQuery;
-	}
-
-#if ENABLE_XAPIAN_SPELLING_CORRECTION&gt;0
-	// Any correction ?
-	correctedFreeQuery = parser.get_corrected_query_string();
-#ifdef DEBUG
-	if (correctedFreeQuery.empty() == false)
-	{
-		cout &lt;&lt; &quot;XapianEngine::parseQuery: corrected spelling to: &quot; &lt;&lt; correctedFreeQuery &lt;&lt; endl;
-	}
-#endif
-#endif
-
-	return parsedQuery;
-}
-
-bool XapianEngine::queryDatabase(Xapian::Database *pIndex, Xapian::Query &amp;query,
-	unsigned int startDoc, const QueryProperties &amp;queryProps)
-{
-	Timer timer;
-	unsigned int maxResultsCount = queryProps.getMaximumResultsCount();
-	bool completedQuery = false;
-
-	if (pIndex == NULL)
-	{
-		return false;
-	}
-
-	// Start an enquire session on the database
-	Xapian::Enquire enquire(*pIndex);
-
-	timer.start();
-	try
-	{
-		AbstractGenerator abstractGen(pIndex, 50);
-		vector&lt;string&gt; seedTerms;
-
-		// Give the query object to the enquire session
-#ifdef DEBUG
-		cout &lt;&lt; &quot;XapianEngine::queryDatabase: enquiring about &quot; &lt;&lt; query.get_description() &lt;&lt; endl;
-#endif
-		enquire.set_query(query);
-		// How should results be sorted ?
-		if (queryProps.getSortOrder() == QueryProperties::RELEVANCE)
-		{
-			// By relevance, only
-			enquire.set_sort_by_relevance_then_value(4);
-#ifdef DEBUG
-			cout &lt;&lt; &quot;XapianEngine::queryDatabase: sorting by relevance first&quot; &lt;&lt; endl;
-#endif
-		}
-		else if (queryProps.getSortOrder() == QueryProperties::DATE)
-		{
-			// By date, and then by relevance
-			enquire.set_sort_by_value_then_relevance(4);
-#ifdef DEBUG
-			cout &lt;&lt; &quot;XapianEngine::queryDatabase: sorting by date and time first&quot; &lt;&lt; endl;
-#endif
-		}
-
-		// Get the top results of the query
-		Xapian::MSet matches = enquire.get_mset(startDoc, maxResultsCount, (2 * maxResultsCount) + 1);
-		if (matches.empty() == false)
-		{
-			m_resultsCountEstimate = matches.get_matches_estimated();
-#ifdef DEBUG
-			cout &lt;&lt; &quot;XapianEngine::queryDatabase: found &quot; &lt;&lt; matches.size() &lt;&lt; &quot;/&quot; &lt;&lt; maxResultsCount
-				&lt;&lt; &quot; results found from position &quot; &lt;&lt; startDoc &lt;&lt; endl;
-			cout &lt;&lt; &quot;XapianEngine::queryDatabase: estimated &quot; &lt;&lt; matches.get_matches_lower_bound()
-				&lt;&lt; &quot;/&quot; &lt;&lt; m_resultsCountEstimate &lt;&lt; &quot;/&quot; &lt;&lt; matches.get_matches_upper_bound() &lt;&lt; endl;
-#endif
-
-			// Get the results
-			for (Xapian::MSetIterator mIter = matches.begin(); mIter != matches.end(); ++mIter)
-			{
-				Xapian::docid docId = *mIter;
-				Xapian::Document doc(mIter.get_document());
-
-				// What terms did this document match ?
-				seedTerms.clear();
-				for (Xapian::TermIterator termIter = enquire.get_matching_terms_begin(docId);
-					termIter != enquire.get_matching_terms_end(docId); ++termIter)
-				{
-					seedTerms.push_back(*termIter);
-				}
-
-				DocumentInfo thisResult;
-				thisResult.setExtract(abstractGen.generateAbstract(docId, seedTerms));
-				thisResult.setScore((float)mIter.get_percent());
-
-#ifdef DEBUG
-				cout &lt;&lt; &quot;XapianEngine::queryDatabase: found document ID &quot; &lt;&lt; docId &lt;&lt; endl;
-#endif
-				XapianDatabase::recordToProps(doc.get_data(), &amp;thisResult);
-				// XapianDatabase stored the language in English
-				thisResult.setLanguage(Languages::toLocale(thisResult.getLanguage()));
-
-				string url(thisResult.getLocation());
-				if (url.empty() == true)
-				{
-					// Hmmm this shouldn't be empty...
-					// Use this instead, even though the document isn't cached in the index
-					thisResult.setLocation(XapianDatabase::buildUrl(m_databaseName, docId));
-				}
-
-				// We don't know the index ID, just the document ID
-				thisResult.setIsIndexed(0, docId);
-
-				// Add this result
-				m_resultsList.push_back(thisResult);
-			}
-		}
-
-		completedQuery = true;
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;XapianEngine::queryDatabase: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	cout &lt;&lt; &quot;Ran query \&quot;&quot; &lt;&lt; queryProps.getFreeQuery() &lt;&lt; &quot;\&quot; in &quot; &lt;&lt; timer.stop() &lt;&lt; &quot; ms&quot; &lt;&lt; endl;
-
-	try
-	{
-		m_expandTerms.clear();
-
-		// Expand the query ?
-		if (m_expandDocuments.empty() == false)
-		{
-			Xapian::RSet expandDocs;
-			unsigned int count = 0;
-
-			for (set&lt;string&gt;::const_iterator docIter = m_expandDocuments.begin();
-				docIter != m_expandDocuments.end(); ++docIter)
-			{
-				string uniqueTerm(string(&quot;U&quot;) + XapianDatabase::limitTermLength(Url::escapeUrl(Url::canonicalizeUrl(*docIter)), true));
-
-				// Only one document may have this term
-				Xapian::PostingIterator postingIter = pIndex-&gt;postlist_begin(uniqueTerm);
-				if (postingIter != pIndex-&gt;postlist_end(uniqueTerm))
-				{
-					expandDocs.add_document(*postingIter);
-				}
-			}
-#ifdef DEBUG
-			cout &lt;&lt; &quot;XapianEngine::queryDatabase: expand from &quot; &lt;&lt; expandDocs.size() &lt;&lt; &quot; documents&quot; &lt;&lt; endl;
-#endif
-
-			// Get 10 non-prefixed terms
-			string allowedPrefixes(&quot;RSZ&quot;);
-			PrefixDecider expandDecider(allowedPrefixes);
-			Xapian::ESet expandTerms = enquire.get_eset(20, expandDocs, &amp;expandDecider);
-#ifdef DEBUG
-			cout &lt;&lt; &quot;XapianEngine::queryDatabase: &quot; &lt;&lt; expandTerms.size() &lt;&lt; &quot; expand terms&quot; &lt;&lt; endl;
-#endif
-			for (Xapian::ESetIterator termIter = expandTerms.begin();
-				(termIter != expandTerms.end()) &amp;&amp; (count &lt; 10); ++termIter)
-			{
-				char firstChar = (*termIter)[0];
-
-				if (allowedPrefixes.find(firstChar) != string::npos)
-				{
-					m_expandTerms.insert((*termIter).substr(1));
-				}
-				else
-				{
-					m_expandTerms.insert(*termIter);
-				}
-				++count;
-			}
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;XapianEngine::queryDatabase: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-
-	// Be tolerant of errors as long as we got some results
-	if ((completedQuery == true) ||
-		(m_resultsList.empty() == false))
-	{
-		return true;
-	}
-
-	return false;
-}
-
-//
-// Implementation of SearchEngineInterface
-//
-
-/// Sets the set of documents to limit to.
-bool XapianEngine::setLimitSet(const set&lt;string&gt; &amp;docsSet)
-{
-	unsigned int bracketsLevel = 1;
-	bool firstLocation = true;
-
-	m_limitQuery.clear();
-
-	if (docsSet.empty() == true)
-	{
-		return true;
-	}
-
-	// FIXME: there must be a better way !
-	m_limitQuery = &quot;( &quot;;
-	for (set&lt;string&gt;::const_iterator docIter = docsSet.begin();
-		docIter != docsSet.end(); ++docIter)
-	{
-		if (firstLocation == false)
-		{
-			m_limitQuery += &quot; OR ( &quot;;
-			++bracketsLevel;
-		}
-
-		m_limitQuery += &quot;url:\&quot;&quot;;
-		m_limitQuery += *docIter;
-		m_limitQuery += &quot;\&quot;&quot;;
-
-		firstLocation = false;
-	}
-	for (unsigned int count = 0; count &lt; bracketsLevel; ++count)
-	{
-		m_limitQuery += &quot; )&quot;;
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;XapianEngine::setLimitSet: &quot; &lt;&lt; m_limitQuery &lt;&lt; endl;
-#endif
-
-	return true;
-}
-
-/// Sets the set of documents to expand from.
-bool XapianEngine::setExpandSet(const set&lt;string&gt; &amp;docsSet)
-{
-	copy(docsSet.begin(), docsSet.end(),
-		inserter(m_expandDocuments, m_expandDocuments.begin()));
-#ifdef DEBUG
-	cout &lt;&lt; &quot;XapianEngine::setExpandSet: &quot; &lt;&lt; m_expandDocuments.size() &lt;&lt; &quot; documents&quot; &lt;&lt; endl;
-#endif
-
-	return true;
-}
-
-/// Runs a query; true if success.
-bool XapianEngine::runQuery(QueryProperties&amp; queryProps,
-	unsigned int startDoc)
-{
-	// Clear the results list
-	m_resultsList.clear();
-	m_resultsCountEstimate = 0;
-	m_correctedFreeQuery.clear();
-
-	if (queryProps.isEmpty() == true)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;XapianEngine::runQuery: query is empty&quot; &lt;&lt; endl;
-#endif
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, true);
-	if (pDatabase == NULL)
-	{
-		return false;
-	}
-
-	// Get the latest revision...
-	pDatabase-&gt;reopen();
-	Xapian::Database *pIndex = pDatabase-&gt;readLock();
-	try
-	{
-		string stemLanguage(queryProps.getFilter(&quot;lang&quot;));
-		unsigned int searchStep = 1;
-
-		// Searches are run in this order :
-		// 1. don't stem terms
-		// 2. if no results, stem terms if a language is defined for the query
-		Xapian::Query fullQuery = parseQuery(pIndex, queryProps, &quot;&quot;,
-			m_defaultOperator, m_limitQuery, m_correctedFreeQuery);
-		while (fullQuery.empty() == false)
-		{
-			// Query the database
-			if (queryDatabase(pIndex, fullQuery, startDoc, queryProps) == false)
-			{
-				break;
-			}
-
-			// The search did succeed but didn't return anything
-			if ((m_resultsList.empty() == true) &amp;&amp;
-				(searchStep == 1) &amp;&amp;
-				(stemLanguage.empty() == false))
-			{
-#ifdef DEBUG
-				cout &lt;&lt; &quot;XapianEngine::runQuery: trying again with stemming&quot; &lt;&lt; endl;
-#endif
-				fullQuery = parseQuery(pIndex, queryProps, Languages::toEnglish(stemLanguage),
-					m_defaultOperator, m_limitQuery, m_correctedFreeQuery);
-				++searchStep;
-				continue;
-			}
-
-			pDatabase-&gt;unlock();
-			return true;
-		}
-	}
-	catch (const Xapian::Error &amp;error)
-	{
-		cerr &lt;&lt; &quot;XapianEngine::runQuery: &quot; &lt;&lt; error.get_type() &lt;&lt; &quot;: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
-	}
-	pDatabase-&gt;unlock();
-
-	return false;
-}

Deleted: trunk/Search/XapianEngine.h
===================================================================
--- trunk/Search/XapianEngine.h	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/XapianEngine.h	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,77 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _XAPIAN_ENGINE_H
-#define _XAPIAN_ENGINE_H
-
-#include &lt;string&gt;
-#include &lt;set&gt;
-#include &lt;vector&gt;
-
-#include &lt;xapian.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;SearchEngineInterface.h&quot;
-#include &quot;DownloaderFactory.h&quot;
-
-#if !ENABLE_XAPIAN_SPELLING_CORRECTION
-// Spelling correction in Xapian 1.0.2 may cause a crash
-// See <A HREF="http://www.xapian.org/cgi-bin/bugzilla/show_bug.cgi?id=194">http://www.xapian.org/cgi-bin/bugzilla/show_bug.cgi?id=194</A>
-#if XAPIAN_NUM_VERSION &gt; 1000002
-#define ENABLE_XAPIAN_SPELLING_CORRECTION 1
-#else
-#define ENABLE_XAPIAN_SPELLING_CORRECTION 0
-#endif
-#endif
-
-/// Wraps Xapian's search funtionality.
-class XapianEngine : public SearchEngineInterface
-{
-	public:
-		XapianEngine(const std::string &amp;database);
-		virtual ~XapianEngine();
-
-		/// Sets the set of documents to limit to.
-		virtual bool setLimitSet(const std::set&lt;std::string&gt; &amp;docsSet);
-
-		/// Sets the set of documents to expand from.
-		virtual bool setExpandSet(const std::set&lt;std::string&gt; &amp;docsSet);
-
-		/// Runs a query; true if success.
-		virtual bool runQuery(QueryProperties&amp; queryProps,
-			unsigned int startDoc = 0);
-
-	protected:
-		std::string m_databaseName;
-		std::string m_limitQuery;
-		std::set&lt;std::string&gt; m_expandDocuments;
-
-		bool queryDatabase(Xapian::Database *pIndex, Xapian::Query &amp;query,
-			unsigned int startDoc, const QueryProperties &amp;queryProps);
-
-		static Xapian::Query parseQuery(Xapian::Database *pIndex, const QueryProperties &amp;queryProps,
-			const string &amp;stemLanguage, DefaultOperator defaultOperator,
-			const string &amp;limitQuery, string &amp;correctedFreeQuery, bool minimal = false);
-
-	private:
-		XapianEngine(const XapianEngine &amp;other);
-		XapianEngine &amp;operator=(const XapianEngine &amp;other);
-
-};
-
-#endif // _XAPIAN_ENGINE_H

Deleted: trunk/Search/pinot-search.1
===================================================================
--- trunk/Search/pinot-search.1	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/pinot-search.1	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,58 +0,0 @@
-.\&quot; DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-SEARCH &quot;1&quot; &quot;November 2007&quot; &quot;pinot-search - pinot 0.81&quot; &quot;User Commands&quot;
-.SH NAME
-pinot-search \- Query search engines from the command-line
-.SH SYNOPSIS
-.B pinot-search
-[\fIOPTIONS\fR] \fISEARCHENGINETYPE SEARCHENGINENAME|SEARCHENGINEOPTION QUERYINPUT\fR
-.SH DESCRIPTION
-pinot\-search \- Query search engines from the command\-line
-.SH OPTIONS
-.TP
-\fB\-h\fR, \fB\-\-help\fR
-display this help and exit
-.TP
-\fB\-m\fR, \fB\-\-max\fR
-maximum number of results (default 10)
-.TP
-\fB\-a\fR, \fB\-\-proxyaddress\fR
-proxy address
-.TP
-\fB\-p\fR, \fB\-\-proxyport\fR
-proxy port
-.TP
-\fB\-t\fR, \fB\-\-proxytype\fR
-proxy type (default HTTP, SOCKS4, SOCKS5)
-.TP
-\fB\-c\fR, \fB\-\-tocsv\fR
-file to export results in CSV format to
-.TP
-\fB\-x\fR, \fB\-\-toxml\fR
-file to export results in XML format to
-.TP
-\fB\-v\fR, \fB\-\-version\fR
-output version information and exit
-.TP
-\fB\-q\fR, \fB\-\-xesamql\fR
-query input is a file containing Xesam QL
-.TP
-\fB\-u\fR, \fB\-\-xesamul\fR
-query input is a file containing Xesam UL
-.PP
-Supported search engine types are googleapi opensearch sherlock xapian
-.SH EXAMPLES
-pinot\-search googleapi mygoogleapikey &quot;clowns&quot;
-.PP
-pinot\-search opensearch /usr/share/pinot/engines/KrustyDescription.xml &quot;clowns&quot;
-.PP
-pinot\-search \fB\-\-max\fR 20 sherlock /usr/share/pinot/engines/Bozo.src &quot;clowns&quot;
-.PP
-pinot\-search \fB\-\-max\fR 10 xapian ~/.pinot/index &quot;clowns&quot;
-.PP
-pinot\-search xapian somehostname:12345 &quot;clowns&quot;
-.SH &quot;REPORTING BUGS&quot;
-Report bugs to <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabricecolin at users.berlios.de</A>
-.PP
-This is free software.  You may redistribute copies of it under the terms of
-the GNU General Public License &lt;<A HREF="http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html">http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html</A>&gt;.
-There is NO WARRANTY, to the extent permitted by law.

Deleted: trunk/Search/pinot-search.cpp
===================================================================
--- trunk/Search/pinot-search.cpp	2007-11-30 15:20:18 UTC (rev 1132)
+++ trunk/Search/pinot-search.cpp	2007-12-01 09:25:54 UTC (rev 1133)
@@ -1,344 +0,0 @@
-/*
- *  Copyright 2005,2006,2007 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;stdlib.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;getopt.h&gt;
-#include &lt;iostream&gt;
-#include &lt;fstream&gt;
-#include &lt;string&gt;
-
-#include &quot;Languages.h&quot;
-#include &quot;MIMEScanner.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;XapianDatabaseFactory.h&quot;
-#include &quot;SearchEngineFactory.h&quot;
-#include &quot;ResultsExporter.h&quot;
-#include &quot;DownloaderFactory.h&quot;
-#include &quot;config.h&quot;
-
-using namespace std;
-
-static struct option g_longOptions[] = {
-	{&quot;help&quot;, 0, 0, 'h'},
-	{&quot;max&quot;, 1, 0, 'm'},
-	{&quot;proxyaddress&quot;, 1, 0, 'a'},
-	{&quot;proxyport&quot;, 1, 0, 'p'},
-	{&quot;proxytype&quot;, 1, 0, 't'},
-	{&quot;tocsv&quot;, 1, 0, 'c'},
-	{&quot;toxml&quot;, 1, 0, 'x'},
-	{&quot;version&quot;, 0, 0, 'v'},
-	{&quot;xesamql&quot;, 0, 0, 'q'},
-	{&quot;xesamul&quot;, 0, 0, 'u'},
-	{0, 0, 0, 0}
-};
-
-static bool loadFile(const string &amp;xesamFile, string &amp;fileContents)
-{
-	ifstream inputFile;
-	bool readFile = false;
-
-	inputFile.open(xesamFile.c_str());
-	if (inputFile.good() == true)
-	{
-		inputFile.seekg(0, ios::end);
-		int length = inputFile.tellg();
-		inputFile.seekg(0, ios::beg);
-
-		char *pFileBuffer = new char[length + 1];
-		inputFile.read(pFileBuffer, length);
-		if (inputFile.fail() == false)
-		{
-			pFileBuffer[length] = '\0';
-
-			fileContents = string(pFileBuffer, length);
-			readFile = true;
-		}
-		delete[] pFileBuffer;
-	}
-	inputFile.close();
-
-	return readFile;
-}
-
-static void printHelp(void)
-{
-	set&lt;string&gt; engines;
-
-	// Help
-	SearchEngineFactory::getSupportedEngines(engines);
-	cout &lt;&lt; &quot;pinot-search - Query search engines from the command-line\n\n&quot;
-		&lt;&lt; &quot;Usage: pinot-search [OPTIONS] SEARCHENGINETYPE SEARCHENGINENAME|SEARCHENGINEOPTION QUERYINPUT\n\n&quot;
-		&lt;&lt; &quot;Options:\n&quot;
-		&lt;&lt; &quot;  -h, --help                display this help and exit\n&quot;
-		&lt;&lt; &quot;  -m, --max                 maximum number of results (default 10)\n&quot;
-		&lt;&lt; &quot;  -a, --proxyaddress        proxy address\n&quot;
-		&lt;&lt; &quot;  -p, --proxyport           proxy port\n&quot;
-		&lt;&lt; &quot;  -t, --proxytype           proxy type (default HTTP, SOCKS4, SOCKS5)\n&quot;
-		&lt;&lt; &quot;  -c, --tocsv               file to export results in CSV format to\n&quot;
-		&lt;&lt; &quot;  -x, --toxml               file to export results in XML format to\n&quot;
-		&lt;&lt; &quot;  -v, --version             output version information and exit\n&quot;
-		&lt;&lt; &quot;  -q, --xesamql             query input is a file containing Xesam QL\n&quot;
-		&lt;&lt; &quot;  -u, --xesamul             query input is a file containing Xesam UL\n\n&quot;
-		&lt;&lt; &quot;Supported search engine types are&quot;;
-	for (set&lt;string&gt;::iterator engineIter = engines.begin(); engineIter != engines.end(); ++engineIter)
-	{
-		cout &lt;&lt; &quot; &quot; &lt;&lt; *engineIter;
-	}
-	cout &lt;&lt; &quot;\n\nExamples:\n&quot;
-#ifdef HAVE_GOOGLEAPI
-		&lt;&lt; &quot;pinot-search googleapi mygoogleapikey \&quot;clowns\&quot;\n\n&quot;
-#endif
-		&lt;&lt; &quot;pinot-search opensearch &quot; &lt;&lt; PREFIX &lt;&lt; &quot;/share/pinot/engines/KrustyDescription.xml \&quot;clowns\&quot;\n\n&quot;
-		&lt;&lt; &quot;pinot-search --max 20 sherlock &quot; &lt;&lt; PREFIX &lt;&lt; &quot;/share/pinot/engines/Bozo.src \&quot;clowns\&quot;\n\n&quot;
-		&lt;&lt; &quot;pinot-search --max 10 xapian ~/.pinot/index \&quot;clowns\&quot;\n\n&quot;
-		&lt;&lt; &quot;pinot-search xapian somehostname:12345 \&quot;clowns\&quot;\n\n&quot;
-		&lt;&lt; &quot;Report bugs to &quot; &lt;&lt; PACKAGE_BUGREPORT &lt;&lt; endl;
-}
-
-int main(int argc, char **argv)
-{
-	QueryProperties::QueryType queryType = QueryProperties::XAPIAN_QP;
-	string engineType, option, csvExport, xmlExport, proxyAddress, proxyPort, proxyType;
-	unsigned int maxResultsCount = 10; 
-	int longOptionIndex = 0;
-	bool printResults = true;
-
-	// Look at the options
-	int optionChar = getopt_long(argc, argv, &quot;c:hm:a:p:qt:uvx:&quot;, g_longOptions, &amp;longOptionIndex);
-	while (optionChar != -1)
-	{
-		switch (optionChar)
-		{
-			case 'a':
-				if (optarg != NULL)
-				{
-					proxyAddress = optarg;
-				}
-				break;
-			case 'c':
-				if (optarg != NULL)
-				{
-					csvExport = optarg;
-					printResults = false;
-				}
-				break;
-			case 'h':
-				printHelp();
-				return EXIT_SUCCESS;
-			case 'm':
-				if (optarg != NULL)
-				{
-					maxResultsCount = (unsigned int )atoi(optarg);
-				}
-				break;
-			case 'p':
-				if (optarg != NULL)
-				{
-					proxyPort = optarg;
-				}
-				break;
-			case 'q':
-				queryType = QueryProperties::XESAM_QL;
-				break;
-			case 't':
-				if (optarg != NULL)
-				{
-					proxyType = optarg;
-				}
-				break;
-			case 'u':
-				queryType = QueryProperties::XESAM_UL;
-				break;
-			case 'v':
-				cout &lt;&lt; &quot;pinot-search - &quot; &lt;&lt; PACKAGE_STRING &lt;&lt; &quot;\n\n&quot;
-					&lt;&lt; &quot;This is free software.  You may redistribute copies of it under the terms of\n&quot;
-					&lt;&lt; &quot;the GNU General Public License &lt;<A HREF="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">http://www.gnu.org/licenses/old-licenses/gpl-2.0.html</A>&gt;.\n&quot;
-					&lt;&lt; &quot;There is NO WARRANTY, to the extent permitted by law.&quot; &lt;&lt; endl;
-				return EXIT_SUCCESS;
-			case 'x':
-				if (optarg != NULL)
-				{
-					xmlExport = optarg;
-					printResults = false;
-				}
-				break;
-			default:
-				return EXIT_FAILURE;
-		}
-
-		// Next option
-		optionChar = getopt_long(argc, argv, &quot;c:hm:a:p:qt:uvx:&quot;, g_longOptions, &amp;longOptionIndex);
-	}
-
-	if (argc == 1)
-	{
-		printHelp();
-		return EXIT_SUCCESS;
-	}
-
-	if ((argc &lt; 4) ||
-		(argc - optind != 3))
-	{
-		cerr &lt;&lt; &quot;Wrong number of parameters&quot; &lt;&lt; endl;
-		return EXIT_FAILURE;
-	}
-
-	MIMEScanner::initialize(&quot;&quot;, &quot;&quot;);
-	DownloaderInterface::initialize();
-	// Localize language names
-	Languages::setIntlName(0, &quot;Unknown&quot;);
-	Languages::setIntlName(1, &quot;Danish&quot;);
-	Languages::setIntlName(2, &quot;Dutch&quot;);
-	Languages::setIntlName(3, &quot;English&quot;);
-	Languages::setIntlName(4, &quot;Finnish&quot;);
-	Languages::setIntlName(5, &quot;French&quot;);
-	Languages::setIntlName(6, &quot;German&quot;);
-	Languages::setIntlName(7, &quot;Hungarian&quot;);
-	Languages::setIntlName(8, &quot;Italian&quot;);
-	Languages::setIntlName(9, &quot;Norwegian&quot;);
-	Languages::setIntlName(10, &quot;Portuguese&quot;);
-	Languages::setIntlName(11, &quot;Romanian&quot;);
-	Languages::setIntlName(12, &quot;Russian&quot;);
-	Languages::setIntlName(13, &quot;Spanish&quot;);
-	Languages::setIntlName(14, &quot;Swedish&quot;);
-	Languages::setIntlName(15, &quot;Turkish&quot;);
-
-	engineType = argv[optind];
-	option = argv[optind + 1];
-	char *pQueryInput = argv[optind + 2];
-
-	// Which SearchEngine ?
-	SearchEngineInterface *pEngine = SearchEngineFactory::getSearchEngine(engineType, option);
-	if (pEngine == NULL)
-	{
-		cerr &lt;&lt; &quot;Couldn't obtain search engine instance&quot; &lt;&lt; endl;
-
-		DownloaderInterface::shutdown();
-		MIMEScanner::shutdown();
-
-		return EXIT_FAILURE;
-	}
-
-	// Set up the proxy
-	DownloaderInterface *pDownloader = pEngine-&gt;getDownloader();
-	if ((pDownloader != NULL) &amp;&amp;
-		(proxyAddress.empty() == false) &amp;&amp;
-		(proxyPort.empty() == false))
-	{
-		pDownloader-&gt;setSetting(&quot;proxyaddress&quot;, proxyAddress);
-		pDownloader-&gt;setSetting(&quot;proxyport&quot;, proxyPort);
-		pDownloader-&gt;setSetting(&quot;proxytype&quot;, proxyType);
-	}
-
-	// Set the query
-	QueryProperties queryProps(&quot;pinot-search&quot;, &quot;&quot;, queryType);
-	if (queryType == QueryProperties::XAPIAN_QP)
-	{
-		queryProps.setFreeQuery(pQueryInput);
-	}
-	else
-	{
-		string fileContents;
-
-		// Load the query from file
-		if (loadFile(pQueryInput, fileContents) == false)
-		{
-			cerr &lt;&lt; &quot;Couldn't load query from file &quot; &lt;&lt; pQueryInput &lt;&lt; endl;
-
-			DownloaderInterface::shutdown();
-			MIMEScanner::shutdown();
-
-			return EXIT_FAILURE;
-		}
-
-		queryProps.setFreeQuery(fileContents);
-	}
-
-	queryProps.setMaximumResultsCount(maxResultsCount);
-	pEngine-&gt;setDefaultOperator(SearchEngineInterface::DEFAULT_OP_AND);
-	if (pEngine-&gt;runQuery(queryProps) == true)
-	{
-		string resultsPage;
-
-		// Try getting a list of links
-		const vector&lt;DocumentInfo&gt; resultsList = pEngine-&gt;getResults();
-		if (resultsList.empty() == false)
-		{
-			if (printResults == true)
-			{
-				unsigned int count = 0;
-
-				cout &lt;&lt; &quot;Matching documents are :&quot; &lt;&lt; endl;
-
-				vector&lt;DocumentInfo&gt;::const_iterator resultIter = resultsList.begin();
-				while (resultIter != resultsList.end())
-				{
-					string rawUrl(resultIter-&gt;getLocation());
-
-					cout &lt;&lt; count &lt;&lt; &quot; Location : '&quot; &lt;&lt; rawUrl &lt;&lt; &quot;'&quot;&lt;&lt; endl;
-					cout &lt;&lt; count &lt;&lt; &quot; Title    : &quot; &lt;&lt; resultIter-&gt;getTitle() &lt;&lt; endl;
-					cout &lt;&lt; count &lt;&lt; &quot; Type     : &quot; &lt;&lt; resultIter-&gt;getType() &lt;&lt; endl;
-					cout &lt;&lt; count &lt;&lt; &quot; Language : &quot; &lt;&lt; resultIter-&gt;getLanguage() &lt;&lt; endl;
-					cout &lt;&lt; count &lt;&lt; &quot; Date     : &quot; &lt;&lt; resultIter-&gt;getTimestamp() &lt;&lt; endl;
-					cout &lt;&lt; count &lt;&lt; &quot; Size     : &quot; &lt;&lt; resultIter-&gt;getSize() &lt;&lt; endl;
-					cout &lt;&lt; count &lt;&lt; &quot; Extract  : &quot; &lt;&lt; resultIter-&gt;getExtract() &lt;&lt; endl;
-					cout &lt;&lt; count &lt;&lt; &quot; Score    : &quot; &lt;&lt; resultIter-&gt;getScore() &lt;&lt; endl;
-					count++;
-
-					// Next
-					resultIter++;
-				}
-			}
-			else
-			{
-				string engineName(SearchEngineFactory::getSearchEngineName(engineType, option));
-
-				if (csvExport.empty() == false)
-				{
-					CSVExporter exporter(csvExport, queryProps);
-
-					exporter.exportResults(engineName, maxResultsCount, resultsList);
-				}
-
-				if (xmlExport.empty() == false)
-				{
-					OpenSearchExporter exporter(xmlExport, queryProps);
-
-					exporter.exportResults(engineName, maxResultsCount, resultsList);
-				}
-			}
-		}
-		else
-		{
-			cerr &lt;&lt; &quot;Couldn't get a results list !&quot; &lt;&lt; endl;
-		}
-	}
-	else
-	{
-		cerr &lt;&lt; &quot;Couldn't run query on search engine &quot; &lt;&lt; engineType &lt;&lt; endl;
-	}
-
-	delete pEngine;
-
-	XapianDatabaseFactory::closeAll();
-	DownloaderInterface::shutdown();
-	MIMEScanner::shutdown();
-
-	return EXIT_SUCCESS;
-}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="001130.html">[Pinot-svn] r1134 - in trunk/IndexSearch: . Xapian
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1129">[ date ]</a>
              <a href="thread.html#1129">[ thread ]</a>
              <a href="subject.html#1129">[ subject ]</a>
              <a href="author.html#1129">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/pinot-svn">More information about the Pinot-svn
mailing list</a><br>
</body></html>
