From fabricecolin at mail.berlios.de  Sun Feb  1 10:51:43 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 1 Feb 2009 10:51:43 +0100
Subject: [Pinot-svn] r1528 - trunk/IndexSearch
Message-ID: <200902010951.n119phnR020102@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-01 10:51:33 +0100 (Sun, 01 Feb 2009)
New Revision: 1528

Modified:
   trunk/IndexSearch/pinot-search.cpp
Log:
Use getResults()'s return by reference as it should be.


Modified: trunk/IndexSearch/pinot-search.cpp
===================================================================
--- trunk/IndexSearch/pinot-search.cpp	2009-01-30 14:53:45 UTC (rev 1527)
+++ trunk/IndexSearch/pinot-search.cpp	2009-02-01 09:51:33 UTC (rev 1528)
@@ -326,8 +326,7 @@
 	{
 		string resultsPage;
 
-		// Try getting a list of links
-		const vector<DocumentInfo> resultsList = pEngine->getResults();
+		const vector<DocumentInfo> &resultsList = pEngine->getResults();
 		if (resultsList.empty() == false)
 		{
 			if (printResults == true)



From fabricecolin at mail.berlios.de  Sun Feb  1 10:53:49 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 1 Feb 2009 10:53:49 +0100
Subject: [Pinot-svn] r1529 - trunk/UI/GTK2/src
Message-ID: <200902010953.n119rnlD020174@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-01 10:53:30 +0100 (Sun, 01 Feb 2009)
New Revision: 1529

Modified:
   trunk/UI/GTK2/src/DaemonState.cpp
Log:
Don't pop actions out of the queue when threads are being stopped.


Modified: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2009-02-01 09:51:33 UTC (rev 1528)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2009-02-01 09:53:30 UTC (rev 1529)
@@ -599,11 +599,13 @@
 		return;
 	}
 
-	// What type of thread was it ?
 	string type(pThread->getType());
+	bool isStopped = pThread->isStopped();
 #ifdef DEBUG
 	cout << "DaemonState::on_thread_end: end of thread " << type << " " << pThread->getId() << endl;
 #endif
+
+	// What type of thread was it ?
 	if (type == "DirectoryScannerThread")
 	{
 		DirectoryScannerThread *pScannerThread = dynamic_cast<DirectoryScannerThread *>(pThread);
@@ -626,7 +628,7 @@
 			delete pIndex;
 		}
 
-		if (pScannerThread->isStopped() == false)
+		if (isStopped == false)
 		{
 			// Pop the queue
 			m_crawlQueue.pop();
@@ -777,8 +779,11 @@
 	cout << "DaemonState::on_thread_end: reload status " << m_reload << endl;
 #endif
 
-	// We might be able to run a queued action
-	pop_queue(indexedUrl);
+	// Try to run a queued action unless threads were stopped
+	if (isStopped == false)
+	{
+		pop_queue(indexedUrl);
+	}
 }
 
 void DaemonState::on_message_filefound(DocumentInfo docInfo, bool isDirectory)



From fabricecolin at mail.berlios.de  Sun Feb  1 12:05:38 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 1 Feb 2009 12:05:38 +0100
Subject: [Pinot-svn] r1530 - in trunk: . Core UI/GTK2/src po
Message-ID: <200902011105.n11B5cOR025670@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-01 12:04:31 +0100 (Sun, 01 Feb 2009)
New Revision: 1530

Added:
   trunk/Core/
   trunk/Core/DaemonState.cpp
   trunk/Core/DaemonState.h
   trunk/Core/Makefile.am
   trunk/Core/OnDiskHandler.cpp
   trunk/Core/OnDiskHandler.h
   trunk/Core/PinotSettings.cpp
   trunk/Core/PinotSettings.h
   trunk/Core/PinotUtils.cpp
   trunk/Core/PinotUtils.h
   trunk/Core/ServerThreads.cpp
   trunk/Core/ServerThreads.h
   trunk/Core/UniqueApplication.cpp
   trunk/Core/UniqueApplication.h
   trunk/Core/WorkerThreads.cpp
   trunk/Core/WorkerThreads.h
   trunk/Core/de.berlios.Pinot.service.in
   trunk/Core/pinot-dbus-daemon.1
   trunk/Core/pinot-dbus-daemon.cc
   trunk/Core/pinot-dbus-daemon.xml
Removed:
   trunk/UI/GTK2/src/DaemonState.cpp
   trunk/UI/GTK2/src/DaemonState.h
   trunk/UI/GTK2/src/OnDiskHandler.cpp
   trunk/UI/GTK2/src/OnDiskHandler.h
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/PinotSettings.h
   trunk/UI/GTK2/src/PinotUtils.cpp
   trunk/UI/GTK2/src/PinotUtils.h
   trunk/UI/GTK2/src/ServerThreads.cpp
   trunk/UI/GTK2/src/ServerThreads.h
   trunk/UI/GTK2/src/UniqueApplication.cpp
   trunk/UI/GTK2/src/UniqueApplication.h
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
   trunk/UI/GTK2/src/de.berlios.Pinot.service.in
   trunk/UI/GTK2/src/pinot-dbus-daemon.1
   trunk/UI/GTK2/src/pinot-dbus-daemon.cc
   trunk/UI/GTK2/src/pinot-dbus-daemon.xml
Modified:
   trunk/Makefile.am
   trunk/UI/GTK2/src/Makefile.am
   trunk/configure.in
   trunk/po/POTFILES.in
Log:
Moved daemon and non-UI specific code out of UI/GTK2/src to Core.


Copied: trunk/Core/DaemonState.cpp (from rev 1529, trunk/UI/GTK2/src/DaemonState.cpp)


Property changes on: trunk/Core/DaemonState.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/DaemonState.h (from rev 1529, trunk/UI/GTK2/src/DaemonState.h)


Property changes on: trunk/Core/DaemonState.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Added: trunk/Core/Makefile.am
===================================================================
--- trunk/Core/Makefile.am	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/Core/Makefile.am	2009-02-01 11:04:31 UTC (rev 1530)
@@ -0,0 +1,60 @@
+# Process this file with automake to produce Makefile.in
+
+noinst_HEADERS = \
+	DaemonState.h \
+	OnDiskHandler.h \
+	PinotSettings.h \
+	PinotUtils.h \
+	ServerThreads.h \
+	UniqueApplication.h \
+	WorkerThreads.h
+
+noinst_LTLIBRARIES = libCore.la
+
+libCore_la_SOURCES = \
+	DaemonState.cpp \
+	OnDiskHandler.cpp \
+	PinotSettings.cpp \
+	PinotUtils.cpp \
+	ServerThreads.cpp \
+	UniqueApplication.cpp \
+	WorkerThreads.cpp
+
+pinot_dbus_daemon_SOURCES = \
+	pinot-dbus-daemon.cc
+
+if HAVE_DBUS
+bin_PROGRAMS = pinot-dbus-daemon
+endif
+
+AM_CXXFLAGS = \
+	@MISC_CFLAGS@ \
+	-I$(top_srcdir)/Utils \
+	-I$(top_srcdir)/Tokenize \
+	-I$(top_srcdir)/Tokenize/filters \
+	-I$(top_srcdir)/SQL \
+	-I$(top_srcdir)/Monitor \
+	-I$(top_srcdir)/Collect \
+	-I$(top_srcdir)/IndexSearch \
+	@SQL_CFLAGS@ @HTTP_CFLAGS@ @XML_CFLAGS@ @DBUS_CFLAGS@ \
+	@INDEX_CFLAGS@ @GTHREAD_CFLAGS@ @GTKMM_CFLAGS@
+
+if HAVE_DBUS
+AM_CXXFLAGS += -DHAVE_DBUS
+endif
+
+pinot_dbus_daemon_LDFLAGS = \
+	-rdynamic
+
+pinot_dbus_daemon_LDADD = \
+	-L$(top_builddir)/Utils \
+	-L$(top_builddir)/Tokenize \
+	-L$(top_builddir)/SQL \
+	-L$(top_builddir)/Monitor \
+	-L$(top_builddir)/Collect \
+	-L$(top_builddir)/IndexSearch \
+	-lCore -lIndexSearch -lMonitor -lCollect -lSQL \
+	-lTokenize -lUtils -lBasicUtils @LIBS@ \
+	@GLIBMM_LIBS@ @DBUS_LIBS@ @GTHREAD_LIBS@ @XML_LIBS@ \
+	@HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
+

Copied: trunk/Core/OnDiskHandler.cpp (from rev 1529, trunk/UI/GTK2/src/OnDiskHandler.cpp)


Property changes on: trunk/Core/OnDiskHandler.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/OnDiskHandler.h (from rev 1529, trunk/UI/GTK2/src/OnDiskHandler.h)


Property changes on: trunk/Core/OnDiskHandler.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/PinotSettings.cpp (from rev 1529, trunk/UI/GTK2/src/PinotSettings.cpp)


Property changes on: trunk/Core/PinotSettings.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/PinotSettings.h (from rev 1529, trunk/UI/GTK2/src/PinotSettings.h)


Property changes on: trunk/Core/PinotSettings.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/PinotUtils.cpp (from rev 1529, trunk/UI/GTK2/src/PinotUtils.cpp)


Property changes on: trunk/Core/PinotUtils.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/PinotUtils.h (from rev 1529, trunk/UI/GTK2/src/PinotUtils.h)


Property changes on: trunk/Core/PinotUtils.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/ServerThreads.cpp (from rev 1529, trunk/UI/GTK2/src/ServerThreads.cpp)


Property changes on: trunk/Core/ServerThreads.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/ServerThreads.h (from rev 1529, trunk/UI/GTK2/src/ServerThreads.h)


Property changes on: trunk/Core/ServerThreads.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/UniqueApplication.cpp (from rev 1529, trunk/UI/GTK2/src/UniqueApplication.cpp)


Property changes on: trunk/Core/UniqueApplication.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/UniqueApplication.h (from rev 1529, trunk/UI/GTK2/src/UniqueApplication.h)


Property changes on: trunk/Core/UniqueApplication.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/WorkerThreads.cpp (from rev 1529, trunk/UI/GTK2/src/WorkerThreads.cpp)


Property changes on: trunk/Core/WorkerThreads.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/WorkerThreads.h (from rev 1529, trunk/UI/GTK2/src/WorkerThreads.h)


Property changes on: trunk/Core/WorkerThreads.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/de.berlios.Pinot.service.in (from rev 1529, trunk/UI/GTK2/src/de.berlios.Pinot.service.in)


Property changes on: trunk/Core/de.berlios.Pinot.service.in
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/pinot-dbus-daemon.1 (from rev 1529, trunk/UI/GTK2/src/pinot-dbus-daemon.1)


Property changes on: trunk/Core/pinot-dbus-daemon.1
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/pinot-dbus-daemon.cc (from rev 1529, trunk/UI/GTK2/src/pinot-dbus-daemon.cc)


Property changes on: trunk/Core/pinot-dbus-daemon.cc
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/pinot-dbus-daemon.xml (from rev 1529, trunk/UI/GTK2/src/pinot-dbus-daemon.xml)


Property changes on: trunk/Core/pinot-dbus-daemon.xml
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/Makefile.am	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,5 +1,5 @@
 
-SUBDIRS = po Utils Tokenize SQL Collect IndexSearch/Google IndexSearch IndexSearch/Xapian IndexSearch/XesamGLib Monitor UI/GTK2/src
+SUBDIRS = po Utils Tokenize SQL Collect IndexSearch/Google IndexSearch IndexSearch/Xapian IndexSearch/XesamGLib Monitor Core UI/GTK2/src
 
 # TODO: Fix that when cleaning up for distcheck! - crazy -
 EXTRA_DIST = AUTHORS ChangeLog ChangeLog-dijon FAQ NEWS README TODO \
@@ -9,8 +9,8 @@
 	IndexSearch/Plugins/*src IndexSearch/Plugins/*.xml \
 	IndexSearch/pinot-index.1 IndexSearch/pinot-label.1 \
 	IndexSearch/pinot-search.1 UI/GTK2/src/pinot.1 \
-	UI/GTK2/src/pinot-dbus-daemon.1 UI/GTK2/src/pinot-dbus-daemon.xml \
-	UI/GTK2/src/de.berlios.Pinot.service \
+	Core/pinot-dbus-daemon.1 Core/pinot-dbus-daemon.xml \
+	Core/de.berlios.Pinot.service \
 	UI/GTK2/xapian-powered.png UI/icons/48x48/pinot.png \
 	UI/icons/32x32/pinot.png UI/icons/24x24/pinot.png \
 	UI/icons/22x22/pinot.png UI/icons/16x16/pinot.png \
@@ -18,14 +18,14 @@
 	scripts/bash/*.sh scripts/python/*.py
 
 man_MANS = IndexSearch/pinot-index.1 IndexSearch/pinot-label.1 \
-	IndexSearch/pinot-search.1 UI/GTK2/src/pinot.1 UI/GTK2/src/pinot-dbus-daemon.1
+	IndexSearch/pinot-search.1 Core/pinot-dbus-daemon.1 UI/GTK2/src/pinot.1
 
 manuals:
 	@help2man --no-info --name "Index documents from the command-line" IndexSearch/pinot-index       >IndexSearch/pinot-index.1
 	@help2man --no-info --name "Label files from the command-line" IndexSearch/pinot-label           >IndexSearch/pinot-label.1
 	@help2man --no-info --name "Query search engines from the command-line" IndexSearch/pinot-search >IndexSearch/pinot-search.1
+	@help2man --no-info --name "D-Bus search and index daemon" Core/pinot-dbus-daemon                >Core/pinot-dbus-daemon.1
 	@help2man --no-info --name "A metasearch tool for the Free Desktop" UI/GTK2/src/pinot            >UI/GTK2/src/pinot.1
-	@help2man --no-info --name "D-Bus search and index daemon" UI/GTK2/src/pinot-dbus-daemon         >UI/GTK2/src/pinot-dbus-daemon.1
 
 install-data-local:
 	@ln -fs $(bindir)/pinot $(DESTDIR)$(bindir)/pinot-prefs
@@ -35,11 +35,11 @@
 	$(INSTALL_DATA) $(srcdir)/textcat_conf.txt $(DESTDIR)$(sysconfdir)/pinot/textcat_conf.txt
 	$(INSTALL_DATA) $(srcdir)/textcat3_conf.txt $(DESTDIR)$(sysconfdir)/pinot/textcat3_conf.txt
 	@mkdir -p $(DESTDIR)$(datadir)/pinot $(DESTDIR)$(datadir)/dbus-1/services
+	$(INSTALL_DATA) $(builddir)/Core/de.berlios.Pinot.service $(DESTDIR)$(datadir)/dbus-1/services/de.berlios.Pinot.service
+	$(INSTALL_DATA) $(srcdir)/Core/pinot-dbus-daemon.xml $(DESTDIR)$(datadir)/pinot/pinot-dbus-daemon.xml
 	$(INSTALL_DATA) $(srcdir)/UI/GTK2/xapian-powered.png $(DESTDIR)$(datadir)/pinot/xapian-powered.png
 	$(INSTALL_DATA) $(srcdir)/UI/GTK2/metase-gtk2.glade $(DESTDIR)$(datadir)/pinot/metase-gtk2.glade
 	$(INSTALL_DATA) $(srcdir)/UI/GTK2/metase-gtk2.gladep $(DESTDIR)$(datadir)/pinot/metase-gtk2.gladep
-	$(INSTALL_DATA) $(srcdir)/UI/GTK2/src/pinot-dbus-daemon.xml $(DESTDIR)$(datadir)/pinot/pinot-dbus-daemon.xml
-	$(INSTALL_DATA) $(builddir)/UI/GTK2/src/de.berlios.Pinot.service $(DESTDIR)$(datadir)/dbus-1/services/de.berlios.Pinot.service
 	@mkdir -p $(DESTDIR)$(datadir)/pinot/engines
 	$(INSTALL_DATA) $(srcdir)/IndexSearch/Plugins/*.src $(DESTDIR)$(datadir)/pinot/engines/
 	$(INSTALL_DATA) $(srcdir)/IndexSearch/Plugins/*.xml $(DESTDIR)$(datadir)/pinot/engines/

Deleted: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,836 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include <strings.h>
-#include <sys/types.h>
-#include <dirent.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <stdint.h>
-#include <stdlib.h>
-#ifdef HAVE_STATFS
-  #ifdef HAVE_SYS_VFS_H
-  #include <sys/vfs.h>
-  #define CHECK_DISK_SPACE 1
-  #else
-    #ifdef HAVE_SYS_STATFS_H
-      #include <sys/statfs.h>
-      #define CHECK_DISK_SPACE 1
-    #else
-      #ifdef HAVE_SYS_MOUNT_H
-        #include <sys/mount.h>
-        #define CHECK_DISK_SPACE 1
-      #endif
-    #endif
-  #endif
-#else
-  #ifdef HAVE_STATVFS
-  #include <sys/statvfs.h>
-  #define CHECK_DISK_SPACE 1
-  #endif
-#endif
-#ifdef __FreeBSD__
-#ifdef HAVE_SYSCTLBYNAME
-#include <sys/sysctl.h>
-#define CHECK_BATTERY_SYSCTL 1
-#endif
-#endif
-#include <iostream>
-#include <glibmm/ustring.h>
-#include <glibmm/stringutils.h>
-#include <glibmm/convert.h>
-#include <glibmm/thread.h>
-#include <glibmm/random.h>
-
-#include "Url.h"
-#include "MonitorFactory.h"
-#include "CrawlHistory.h"
-#ifdef HAVE_DBUS
-#include "DBusIndex.h"
-#endif
-#include "DaemonState.h"
-#include "OnDiskHandler.h"
-#include "PinotSettings.h"
-#include "PinotUtils.h"
-#include "ServerThreads.h"
-
-using namespace std;
-using namespace Glib;
-
-static double getFSFreeSpace(const string &path)
-{
-	double availableBlocks = 0.0;
-	double blockSize = 0.0;
-	int statSuccess = -1;
-#ifdef HAVE_STATFS
-	struct statfs fsStats;
-
-	statSuccess = statfs(PinotSettings::getInstance().m_daemonIndexLocation.c_str(), &fsStats);
-	availableBlocks = (uintmax_t)fsStats.f_bavail;
-	blockSize = fsStats.f_bsize;
-#else
-#ifdef HAVE_STATVFS
-	struct statvfs vfsStats;
-
-	statSuccess = statvfs(path.c_str(), &vfsStats);
-	availableBlocks = (uintmax_t)vfsStats.f_bavail;
-	// f_frsize isn't supported by all implementations
-	blockSize = (vfsStats.f_frsize ? vfsStats.f_frsize : vfsStats.f_bsize);
-#endif
-#endif
-	// Did it fail ?
-	if ((statSuccess == -1) ||
-		(blockSize == 0.0))
-	{
-		return -1.0;
-	}
-
-	double mbRatio = blockSize / (1024 * 1024);
-	double availableMbSize = availableBlocks * mbRatio;
-#ifdef DEBUG
-	cout << "DaemonState::getFSFreeSpace: " << availableBlocks << " blocks of " << blockSize
-		<< " bytes (" << mbRatio << ")" << endl;
-#endif
-
-	return availableMbSize;
-}
-
-// A function object to stop DirectoryScanner threads with for_each()
-struct StopScannerThreadFunc
-{
-public:
-	void operator()(map<unsigned int, WorkerThread *>::value_type &p)
-	{
-		string type(p.second->getType());
-
-		if (type == "DirectoryScannerThread")
-		{
-			p.second->stop();
-#ifdef DEBUG
-			cout << "StopScannerThreadFunc: stopped thread " << p.second->getId() << endl;
-#endif
-		}
-	}
-};
-
-#ifdef HAVE_DBUS
-DBusServletInfo::DBusServletInfo(DBusConnection *pConnection, DBusMessage *pRequest) :
-	m_pConnection(pConnection),
-	m_pRequest(pRequest),
-	m_pReply(NULL),
-	m_pArray(NULL),
-	m_simpleQuery(true),
-	m_pThread(NULL),
-	m_replied(false)
-{
-}
-
-DBusServletInfo::~DBusServletInfo()
-{
-	if (m_pReply != NULL)
-	{
-		dbus_message_unref(m_pReply);
-	}
-	if (m_pRequest != NULL)
-	{
-		dbus_message_unref(m_pRequest);
-	}
-	if (m_pConnection != NULL)
-	{
-		dbus_connection_unref(m_pConnection);
-	}
-	if (m_pArray != NULL)
-	{
-		// Free the array
-		g_ptr_array_free(m_pArray, TRUE);
-	}
-}
-
-bool DBusServletInfo::newReply(void)
-{
-        if (m_pRequest == NULL) 
-        {
-                return false;
-        }
-
-        m_pReply = dbus_message_new_method_return(m_pRequest);
-        if (m_pReply != NULL)
-        {
-                return true;
-        }
-
-        return false;
-}
-
-bool DBusServletInfo::newErrorReply(const string &name, const string &message)
-{
-        if (m_pRequest == NULL) 
-        {
-                return false;
-        }
-
-	if (m_pReply != NULL)
-	{
-		dbus_message_unref(m_pReply);
-		m_pReply = NULL;
-	}
-
-	m_pReply = dbus_message_new_error(m_pRequest,
-		name.c_str(), message.c_str());
-        if (m_pReply != NULL)
-        {
-                return true;
-        }
-
-        return false;
-}
-
-bool DBusServletInfo::newReplyWithArray(void)
-{
-	if (newReply() == true)
-	{
-		dbus_message_append_args(m_pReply,
-			DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &m_pArray->pdata, m_pArray->len,
-			DBUS_TYPE_INVALID);
-
-		return true;
-	}
-
-	return false;
-}
-
-bool DBusServletInfo::newQueryReply(const vector<DocumentInfo> &resultsList,
-	unsigned int resultsEstimate)
-{
-	DBusMessageIter iter, subIter;
-
-	if (m_simpleQuery == false)
-	{
-		// Create the reply
-		if (newReply() == false)
-		{
-			return false;
-		}
-
-		// ...and attach a container
-		dbus_message_iter_init_append(m_pReply, &iter);
-		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32,
-			&resultsEstimate);
-		dbus_message_iter_open_container(&iter, DBUS_TYPE_ARRAY,
-			 DBUS_TYPE_ARRAY_AS_STRING \
-			 DBUS_STRUCT_BEGIN_CHAR_AS_STRING \
-			 DBUS_TYPE_STRING_AS_STRING \
-			 DBUS_TYPE_STRING_AS_STRING \
-			 DBUS_STRUCT_END_CHAR_AS_STRING, &subIter);
-	}
-	else
-	{
-		// Create an array
-		// FIXME: use a container for this too
-		m_pArray = g_ptr_array_new();
-	}
-
-	for (vector<DocumentInfo>::const_iterator resultIter = resultsList.begin();
-		resultIter != resultsList.end(); ++resultIter)
-	{
-		unsigned int indexId = 0;
-		unsigned int docId = resultIter->getIsIndexed(indexId);
-
-#ifdef DEBUG
-		cout << "DBusServletInfo::newQueryReply: adding result " << docId << endl;
-#endif
-		if (m_simpleQuery == false)
-		{
-			// The document ID isn't needed here
-			if (DBusIndex::documentInfoToDBus(&subIter, 0, *resultIter) == false)
-			{
-				newErrorReply("de.berlios.Pinot.Query", "Unknown error");
-				return false;
-			}
-		}
-		else if (docId > 0)
-		{
-			char docIdStr[64];
-
-			// We only need the document ID
-			snprintf(docIdStr, 64, "%u", docId);
-			g_ptr_array_add(m_pArray, const_cast<char*>(docIdStr));
-		}
-	}
-
-	if (m_simpleQuery == false)
-	{
-		// Close the container
-		dbus_message_iter_close_container(&iter, &subIter);
-		return true;
-	}
-
-	// Attach the array to the reply
-	return newReplyWithArray();
-}
-
-bool DBusServletInfo::reply(void)
-{
-	// Send a reply ?
-	if ((m_pConnection != NULL) &&
-		(m_pReply != NULL) &&
-		(m_replied == false))
-	{
-		m_replied = true;
-
-		dbus_connection_send(m_pConnection, m_pReply, NULL);
-		dbus_connection_flush(m_pConnection);
-#ifdef DEBUG
-		cout << "DBusServletInfo::reply: sent reply" << endl;
-#endif
-
-		return true;
-	}
-
-	return false;
-}
-#endif
-
-DaemonState::DaemonState() :
-	ThreadsManager(PinotSettings::getInstance().m_daemonIndexLocation, 10),
-	m_fullScan(false),
-	m_isReindex(false),
-	m_reload(false),
-	m_pDiskMonitor(MonitorFactory::getMonitor()),
-	m_pDiskHandler(NULL),
-	m_crawlers(0)
-{
-	FD_ZERO(&m_flagsSet);
-
-	// Check disk usage every minute
-	m_timeoutConnection = Glib::signal_timeout().connect(sigc::mem_fun(*this,
-		&DaemonState::on_activity_timeout), 60000);
-	// Check right now before doing anything else
-	DaemonState::on_activity_timeout();
-
-	m_onThreadEndSignal.connect(sigc::mem_fun(*this, &DaemonState::on_thread_end));
-}
-
-DaemonState::~DaemonState()
-{
-	// Don't delete m_pDiskMonitor and m_pDiskHandler, threads may need them
-	// Since DaemonState is destroyed when the program exits, it's a leak we can live with
-}
-
-bool DaemonState::on_activity_timeout(void)
-{
-	if (m_timeoutConnection.blocked() == false)
-	{
-#ifdef CHECK_DISK_SPACE
-		double availableMbSize = getFSFreeSpace(PinotSettings::getInstance().m_daemonIndexLocation);
-		if (availableMbSize >= 0)
-		{
-#ifdef DEBUG
-			cout << "DaemonState::on_activity_timeout: " << availableMbSize << " Mb free for "
-				<< PinotSettings::getInstance().m_daemonIndexLocation << endl;
-#endif
-			if (availableMbSize < PinotSettings::getInstance().m_minimumDiskSpace)
-			{
-				// Stop indexing
-				m_stopIndexing = true;
-				// Stop crawling
-				set_flag(LOW_DISK_SPACE);
-				stop_crawling();
-
-				cerr << "Stopped indexing because of low disk space" << endl;
-			}
-			else if (m_stopIndexing == true)
-			{
-				// Go ahead
-				m_stopIndexing = false;
-				reset_flag(LOW_DISK_SPACE);
-
-				cerr << "Resumed indexing following low disk space condition" << endl;
-			}
-		}
-#endif
-#ifdef CHECK_BATTERY_SYSCTL
-		// Check the battery state too
-		check_battery_state();
-#endif
-	}
-
-	return true;
-}
-
-void DaemonState::check_battery_state(void)
-{
-#ifdef CHECK_BATTERY_SYSCTL
-	int acline = 1;
-	size_t len = sizeof(acline);
-	bool onBattery = false;
-
-	// Are we on battery power ?
-	if (sysctlbyname("hw.acpi.acline", &acline, &len, NULL, 0) == 0)
-	{
-#ifdef DEBUG
-		cout << "DaemonState::check_battery_state: acline " << acline << endl;
-#endif
-		if (acline == 0)
-		{
-			onBattery = true;
-		}
-
-		bool wasOnBattery = is_flag_set(ON_BATTERY);
-		if (onBattery != wasOnBattery)
-		{
-			if (onBattery == true)
-			{
-				// We are now on battery
-				set_flag(ON_BATTERY);
-				stop_crawling();
-
-				cout << "System is now on battery" << endl;
-			}
-			else
-			{
-				// Back on-line
-				reset_flag(ON_BATTERY);
-				start_crawling();
-
-				cout << "System is now on AC" << endl;
-			}
-		}
-	}
-#endif
-}
-
-bool DaemonState::crawl_location(const PinotSettings::IndexableLocation &location)
-{
-	string locationToCrawl(location.m_name);
-	bool doMonitoring = location.m_monitor;
-	bool isSource = location.m_isSource;
-	DirectoryScannerThread *pScannerThread = NULL;
-
-	// Can we go ahead and crawl ?
-	if ((is_flag_set(LOW_DISK_SPACE) == true) ||
-		(is_flag_set(ON_BATTERY) == true))
-	{
-#ifdef DEBUG
-		cout << "DaemonState::crawl_location: crawling was stopped" << endl;
-#endif
-		return true;
-	}
-
-	if (locationToCrawl.empty() == true)
-	{
-		return false;
-	}
-
-	if (doMonitoring == false)
-	{
-		// Monitoring is not necessary, but we still have to pass the handler
-		// so that we can act on documents that have been deleted
-		pScannerThread = new DirectoryScannerThread(locationToCrawl, isSource,
-			m_fullScan, m_isReindex, NULL, m_pDiskHandler);
-	}
-	else
-	{
-		pScannerThread = new DirectoryScannerThread(locationToCrawl, isSource,
-			m_fullScan, m_isReindex, m_pDiskMonitor, m_pDiskHandler);
-	}
-	pScannerThread->getFileFoundSignal().connect(sigc::mem_fun(*this, &DaemonState::on_message_filefound));
-
-	if (start_thread(pScannerThread, true) == true)
-	{
-		++m_crawlers;
-		set_flag(CRAWLING);
-
-		return true;
-	}
-
-	return false;
-}
-
-void DaemonState::start(bool forceFullScan, bool isReindex)
-{
-	// Disable implicit flushing after a change
-	WorkerThread::immediateFlush(false);
-
-	// Do full scans ?
-	if (forceFullScan == true)
-	{
-		m_fullScan = true;
-	}
-	else
-	{
-		Rand randomStuff;
-		guint32 randomArray[5];
-
-		randomStuff.set_seed(randomArray[2]);
-		gint32 randomNum = randomStuff.get_int_range(0, 10);
-		if (randomNum >= 7)
-		{
-			m_fullScan = true;
-		}
-#ifdef DEBUG
-		cout << "DaemonState::start: picked " << randomNum << endl;
-#endif
-	}
-	m_isReindex = isReindex;
-
-	// Fire up the disk monitor thread
-	if (m_pDiskHandler == NULL)
-	{
-		OnDiskHandler *pDiskHandler = new OnDiskHandler();
-		pDiskHandler->getFileFoundSignal().connect(sigc::mem_fun(*this, &DaemonState::on_message_filefound));
-		m_pDiskHandler = pDiskHandler;
-	}
-	MonitorThread *pDiskMonitorThread = new MonitorThread(m_pDiskMonitor, m_pDiskHandler);
-	start_thread(pDiskMonitorThread, true);
-
-	for (set<PinotSettings::IndexableLocation>::const_iterator locationIter = PinotSettings::getInstance().m_indexableLocations.begin();
-		locationIter != PinotSettings::getInstance().m_indexableLocations.end(); ++locationIter)
-	{
-		m_crawlQueue.push(*locationIter);
-	}
-#ifdef DEBUG
-	cout << "DaemonState::start: " << m_crawlQueue.size() << " locations to crawl" << endl;
-#endif
-
-	if (m_fullScan == true)
-	{
-		CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-
-		// Update all items status so that we can get rid of files from deleted sources
-		crawlHistory.updateItemsStatus(CrawlHistory::TO_CRAWL, 0, true);
-	}
-
-	// Initiate crawling
-	start_crawling();
-}
-
-void DaemonState::reload(void)
-{
-	// Reload whenever possible
-	m_reload = true;
-}
-
-void DaemonState::start_crawling(void)
-{
-	if (write_lock_lists() == true)
-	{
-#ifdef DEBUG
-		cout << "DaemonState::start_crawling: " << m_crawlQueue.size() << " locations to crawl, "
-			<< m_crawlers << " crawlers" << endl;
-#endif
-		// Get the next location, unless something is still being crawled
-		if (m_crawlers == 0)
-		{
-			reset_flag(CRAWLING);
-
-			if (m_crawlQueue.empty() == false)
-			{
-				PinotSettings::IndexableLocation nextLocation(m_crawlQueue.front());
-
-				crawl_location(nextLocation);
-			}
-			else if (m_fullScan == true)
-			{
-				CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-				set<string> deletedFiles;
-
-				// All files left with status TO_CRAWL belong to deleted sources
-				if ((m_pDiskHandler != NULL) &&
-					(crawlHistory.getItems(CrawlHistory::TO_CRAWL, deletedFiles) > 0))
-				{
-#ifdef DEBUG
-					cout << "DaemonState::start_crawling: " << deletedFiles.size() << " orphaned files" << endl;
-#endif
-					for(set<string>::const_iterator fileIter = deletedFiles.begin();
-						fileIter != deletedFiles.end(); ++fileIter)
-					{
-						// Inform the MonitorHandler
-						m_pDiskHandler->fileDeleted(fileIter->substr(7));
-
-						// Delete this item
-						crawlHistory.deleteItem(*fileIter);
-					}
-				}
-			}
-		}
-
-		unlock_lists();
-	}
-
-}
-
-void DaemonState::stop_crawling(void)
-{
-	if (write_lock_threads() == true)
-	{
-		if (m_threads.empty() == false)
-		{
-			// Stop all DirectoryScanner threads
-			for_each(m_threads.begin(), m_threads.end(), StopScannerThreadFunc());
-		}
-
-		unlock_threads();
-	}
-}
-
-void DaemonState::on_thread_end(WorkerThread *pThread)
-{
-	string indexedUrl;
-
-	if (pThread == NULL)
-	{
-		return;
-	}
-
-	string type(pThread->getType());
-	bool isStopped = pThread->isStopped();
-#ifdef DEBUG
-	cout << "DaemonState::on_thread_end: end of thread " << type << " " << pThread->getId() << endl;
-#endif
-
-	// What type of thread was it ?
-	if (type == "DirectoryScannerThread")
-	{
-		DirectoryScannerThread *pScannerThread = dynamic_cast<DirectoryScannerThread *>(pThread);
-		if (pScannerThread == NULL)
-		{
-			delete pThread;
-			return;
-		}
-		--m_crawlers;
-#ifdef DEBUG
-		cout << "DaemonState::on_thread_end: done crawling " << pScannerThread->getDirectory() << endl;
-#endif
-
-		// Explicitely flush the index once a directory has been crawled
-		IndexInterface *pIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
-		if (pIndex != NULL)
-		{
-			pIndex->flush();
-
-			delete pIndex;
-		}
-
-		if (isStopped == false)
-		{
-			// Pop the queue
-			m_crawlQueue.pop();
-		}
-		// Else, the directory wasn't fully crawled so better leave it in the queue
-
-		start_crawling();
-	}
-	else if (type == "IndexingThread")
-	{
-		IndexingThread *pIndexThread = dynamic_cast<IndexingThread *>(pThread);
-		if (pIndexThread == NULL)
-		{
-			delete pThread;
-			return;
-		}
-
-		// Get the URL we have just indexed
-		indexedUrl = pIndexThread->getURL();
-
-		// Did it fail ?
-		int errorNum = pThread->getErrorNum();
-		if ((errorNum > 0) &&
-			(indexedUrl.empty() == false))
-		{
-			CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-
-			// An entry should already exist for this
-			crawlHistory.updateItem(indexedUrl, CrawlHistory::CRAWL_ERROR, time(NULL), errorNum);
-		}
-	}
-	else if (type == "UnindexingThread")
-	{
-		// FIXME: anything to do ?
-	}
-	else if (type == "MonitorThread")
-	{
-		// FIXME: do something about this
-	}
-#ifdef HAVE_DBUS
-	else if (type == "DBusServletThread")
-	{
-		DBusServletThread *pDBusThread = dynamic_cast<DBusServletThread *>(pThread);
-		if (pDBusThread == NULL)
-		{
-			delete pThread;
-			return;
-		}
-
-		// Send the reply ?
-		DBusServletInfo *pInfo = pDBusThread->getServletInfo();
-		if (pInfo != NULL)
-		{
-			if (pInfo->m_pThread != NULL)
-			{
-				m_servletsInfo.insert(pInfo);
-
-				start_thread(pInfo->m_pThread);
-			}
-			else
-			{
-				pInfo->reply();
-
-				delete pInfo;
-			}
-		}
-
-		if (pDBusThread->mustQuit() == true)
-		{
-			// Disconnect the timeout signal
-			if (m_timeoutConnection.connected() == true)
-			{
-				m_timeoutConnection.block();
-				m_timeoutConnection.disconnect();
-			}
-			m_signalQuit(0);
-		}
-	}
-#endif
-	else if (type == "QueryingThread")
-	{
-		QueryingThread *pQueryThread = dynamic_cast<QueryingThread *>(pThread);
-		if (pQueryThread == NULL)
-		{
-			delete pThread;
-			return;
-		}
-
-		bool wasCorrected = false;
-		QueryProperties queryProps(pQueryThread->getQuery(wasCorrected));
-		const vector<DocumentInfo> &resultsList = pQueryThread->getDocuments();
-
-#ifdef HAVE_DBUS
-		// Find the servlet info
-		for (set<DBusServletInfo *>::const_iterator servIter = m_servletsInfo.begin();
-			servIter != m_servletsInfo.end(); ++servIter)
-		{
-			DBusServletInfo *pInfo = const_cast<DBusServletInfo *>(*servIter);
-
-			if ((pInfo != NULL) &&
-				(pInfo->m_pThread->getId() == pThread->getId()))
-			{
-#ifdef DEBUG
-				cout << "DaemonState::on_thread_end: ran query " << queryProps.getName() << endl;
-#endif
-				// Prepare and send the reply
-				pInfo->newQueryReply(resultsList, pQueryThread->getDocumentsCount());
-				pInfo->reply();
-
-				m_servletsInfo.erase(servIter);
-				delete pInfo;
-
-				break;
-			}
-		}
-#endif
-	}
-
-	// Delete the thread
-	delete pThread;
-
-	// Are we supposed to reload the configuration ?
-	// Wait until there are no threads running (except background ones)
-	if ((m_reload == true) &&
-		(get_threads_count() == 0))
-	{
-#ifdef DEBUG
-		cout << "DaemonState::on_thread_end: stopping all threads" << endl;
-#endif
-		// Stop background threads
-		stop_threads();
-		// ...clear the queues
-		clear_queues();
-
-		// Reload
-		PinotSettings &settings = PinotSettings::getInstance();
-		settings.clear();
-		settings.load(PinotSettings::LOAD_ALL);
-		m_reload = false;
-#ifdef DEBUG
-		cout << "DaemonState::on_thread_end: reloading" << endl;
-#endif
-
-		// ...and restart everything 
-		start(true, false);
-	}
-#ifdef DEBUG
-	cout << "DaemonState::on_thread_end: reload status " << m_reload << endl;
-#endif
-
-	// Try to run a queued action unless threads were stopped
-	if (isStopped == false)
-	{
-		pop_queue(indexedUrl);
-	}
-}
-
-void DaemonState::on_message_filefound(DocumentInfo docInfo, bool isDirectory)
-{
-	if (isDirectory == false)
-	{
-		queue_index(docInfo);
-	}
-	else
-	{
-		PinotSettings::IndexableLocation newLocation;
-
-		newLocation.m_monitor = true;
-		newLocation.m_name = docInfo.getLocation().substr(7);
-		newLocation.m_isSource = false;
-#ifdef DEBUG
-		cout << "DaemonState::on_message_filefound: new directory " << newLocation.m_name << endl;
-#endif
-
-		// Queue this directory for crawling
-		m_crawlQueue.push(newLocation);
-		start_crawling();
-	}
-}
-
-sigc::signal1<void, int>& DaemonState::getQuitSignal(void)
-{
-	return m_signalQuit;
-}
-
-void DaemonState::set_flag(StatusFlag flag)
-{
-	FD_SET((int)flag, &m_flagsSet);
-}
-
-bool DaemonState::is_flag_set(StatusFlag flag)
-{
-	if (FD_ISSET((int)flag, &m_flagsSet))
-	{
-		return true;
-	}
-
-	return false;
-}
-
-void DaemonState::reset_flag(StatusFlag flag)
-{
-	FD_CLR((int)flag, &m_flagsSet);
-}
-

Deleted: trunk/UI/GTK2/src/DaemonState.h
===================================================================
--- trunk/UI/GTK2/src/DaemonState.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/DaemonState.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,126 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _DAEMONSTATE_HH
-#define _DAEMONSTATE_HH
-
-#include <sys/select.h>
-#include <string>
-#include <queue>
-#include <set>
-#ifdef HAVE_DBUS
-extern "C"
-{
-#if DBUS_VERSION < 1000000
-#define DBUS_API_SUBJECT_TO_CHANGE
-#endif
-#include <dbus/dbus.h>
-#include <dbus/dbus-glib.h>
-#include <dbus/dbus-glib-lowlevel.h>
-}
-#endif
-#include <sigc++/sigc++.h>
-
-#include "MonitorInterface.h"
-#include "MonitorHandler.h"
-#include "PinotSettings.h"
-#include "WorkerThreads.h"
-
-#ifdef HAVE_DBUS
-class DBusServletInfo
-{
-	public:
-		DBusServletInfo(DBusConnection *pConnection, DBusMessage *pRequest);
-		~DBusServletInfo();
-
-		bool newReply(void);
-
-		bool newErrorReply(const std::string &name, const std::string &message);
-
-		bool newReplyWithArray(void);
-
-		bool newQueryReply(const vector<DocumentInfo> &resultsList,
-			unsigned int resultsEstimate);
-
-		bool reply(void);
-
-		DBusConnection *m_pConnection;
-		DBusMessage *m_pRequest;
-		DBusMessage *m_pReply;
-		GPtrArray *m_pArray;
-		bool m_simpleQuery;
-		WorkerThread *m_pThread;
-
-	protected:
-		bool m_replied;
-
-};
-#endif
-
-class DaemonState : public ThreadsManager
-{
-	public:
-		DaemonState();
-		virtual ~DaemonState();
-
-		typedef enum { LOW_DISK_SPACE = 0, ON_BATTERY, CRAWLING, STOPPED, DISCONNECTED } StatusFlag;
-
-		void start(bool forceFullScan, bool isReindex);
-
-		void reload(void);
-
-		void start_crawling(void);
-
-		void stop_crawling(void);
-
-		void on_thread_end(WorkerThread *pThread);
-
-		void on_message_filefound(DocumentInfo docInfo, bool isDirectory);
-
-		sigc::signal1<void, int>& getQuitSignal(void);
-
-		void set_flag(StatusFlag flag);
-
-		bool is_flag_set(StatusFlag flag);
-
-		void reset_flag(StatusFlag flag);
-
-	protected:
-		bool m_fullScan;
-		bool m_isReindex;
-		bool m_reload;
-		fd_set m_flagsSet;
-		MonitorInterface *m_pDiskMonitor;
-		MonitorHandler *m_pDiskHandler;
-		sigc::connection m_timeoutConnection;
-		sigc::signal1<void, int> m_signalQuit;
-		unsigned int m_crawlers;
-		std::queue<PinotSettings::IndexableLocation> m_crawlQueue;
-#ifdef HAVE_DBUS
-		std::set<DBusServletInfo *> m_servletsInfo;
-#endif
-
-		bool on_activity_timeout(void);
-
-		void check_battery_state(void);
-
-		bool crawl_location(const PinotSettings::IndexableLocation &location);
-
-};
-
-#endif // _DAEMONSTATE_HH

Modified: trunk/UI/GTK2/src/Makefile.am
===================================================================
--- trunk/UI/GTK2/src/Makefile.am	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/Makefile.am	2009-02-01 11:04:31 UTC (rev 1530)
@@ -17,18 +17,11 @@
 	queryDialog.hh \
 	statisticsDialog_glade.hh \
 	statisticsDialog.hh \
-	DaemonState.h \
 	EnginesTree.h \
 	IndexPage.h \
 	ModelColumns.h \
 	Notebook.h \
-	OnDiskHandler.h \
-	PinotSettings.h \
-	PinotUtils.h \
-	ResultsTree.h \
-	ServerThreads.h \
-	UniqueApplication.h \
-	WorkerThreads.h
+	ResultsTree.h
 
 pinot_SOURCES = \
 	pinot.cc \
@@ -52,25 +45,9 @@
 	IndexPage.cpp \
 	ModelColumns.cpp \
 	Notebook.cpp \
-	PinotSettings.cpp \
-	PinotUtils.cpp \
-	ResultsTree.cpp \
-	WorkerThreads.cpp
+	ResultsTree.cpp
 
-pinot_dbus_daemon_SOURCES = \
-	pinot-dbus-daemon.cc \
-	DaemonState.cpp \
-	OnDiskHandler.cpp \
-	PinotSettings.cpp \
-	ServerThreads.cpp \
-	UniqueApplication.cpp \
-	WorkerThreads.cpp
-
-if HAVE_DBUS
-bin_PROGRAMS = pinot pinot-dbus-daemon
-else
 bin_PROGRAMS = pinot
-endif
 
 AM_CXXFLAGS = \
 	@MISC_CFLAGS@ \
@@ -81,6 +58,7 @@
 	-I$(top_srcdir)/Monitor \
 	-I$(top_srcdir)/Collect \
 	-I$(top_srcdir)/IndexSearch \
+	-I$(top_srcdir)/Core \
 	@SQL_CFLAGS@ @HTTP_CFLAGS@ @XML_CFLAGS@ @DBUS_CFLAGS@ \
 	@INDEX_CFLAGS@ @GTHREAD_CFLAGS@ @GTKMM_CFLAGS@
 
@@ -98,23 +76,9 @@
 	-L$(top_builddir)/Monitor \
 	-L$(top_builddir)/Collect \
 	-L$(top_builddir)/IndexSearch \
-	-lIndexSearch -lMonitor -lCollect -lSQL \
+	-L$(top_srcdir)/Core \
+	-lCore -lIndexSearch -lMonitor -lCollect -lSQL \
 	-lTokenize -lUtils -lBasicUtils @LIBS@ \
 	@GTKMM_LIBS@ @DBUS_LIBS@ @GTHREAD_LIBS@ @XML_LIBS@ \
 	@HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
 
-pinot_dbus_daemon_LDFLAGS = \
-	-rdynamic
-
-pinot_dbus_daemon_LDADD = \
-	-L$(top_builddir)/Utils \
-	-L$(top_builddir)/Tokenize \
-	-L$(top_builddir)/SQL \
-	-L$(top_builddir)/Monitor \
-	-L$(top_builddir)/Collect \
-	-L$(top_builddir)/IndexSearch \
-	-lIndexSearch -lMonitor -lCollect -lSQL \
-	-lTokenize -lUtils -lBasicUtils @LIBS@ \
-	@GLIBMM_LIBS@ @DBUS_LIBS@ @GTHREAD_LIBS@ @XML_LIBS@ \
-	@HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
-

Deleted: trunk/UI/GTK2/src/OnDiskHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/OnDiskHandler.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,422 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <fcntl.h>
-#include <unistd.h>
-#include <time.h>
-#include <set>
-#include <iostream>
-#include <fstream>
-#include <sstream>
-
-#include "config.h"
-#include "NLS.h"
-#include "MIMEScanner.h"
-#include "StringManip.h"
-#include "Url.h"
-#include "FilterWrapper.h"
-#include "PinotSettings.h"
-#include "OnDiskHandler.h"
-
-using namespace std;
-
-OnDiskHandler::OnDiskHandler() :
-	MonitorHandler(),
-	m_history(PinotSettings::getInstance().getHistoryDatabaseName()),
-	m_metaData(PinotSettings::getInstance().getHistoryDatabaseName()),
-	m_pIndex(PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation))
-{
-	pthread_mutex_init(&m_mutex, NULL);
-}
-
-OnDiskHandler::~OnDiskHandler()
-{
-	pthread_mutex_destroy(&m_mutex);
-
-	// Disconnect the signal
-	sigc::signal2<void, DocumentInfo, bool>::slot_list_type slotsList = m_signalFileFound.slots();
-	sigc::signal2<void, DocumentInfo, bool>::slot_list_type::iterator slotIter = slotsList.begin();
-	if (slotIter != slotsList.end())
-	{
-		if (slotIter->empty() == false)
-		{
-			slotIter->block();
-			slotIter->disconnect();
-		}
-	}
-
-	if (m_pIndex != NULL)
-	{
-		delete m_pIndex;
-	}
-}
-
-bool OnDiskHandler::fileMoved(const string &fileName, const string &previousFileName,
-	IndexInterface::NameType type)
-{
-	set<unsigned int> docIdList;
-	bool handledEvent = false;
-
-#ifdef DEBUG
-	cout << "OnDiskHandler::fileMoved: " << fileName << endl;
-#endif
-	if (m_pIndex == NULL)
-	{
-		return false;
-	}
-
-	pthread_mutex_lock(&m_mutex);
-	// Get a list of documents in that directory/file
-	if (type == IndexInterface::BY_FILE)
-	{
-		m_pIndex->listDocuments(string("file://") + previousFileName, docIdList, type);
-	}
-	else
-	{
-		m_pIndex->listDocuments(previousFileName, docIdList, type);
-	}
-	// ...and the directory/file itself
-	unsigned int baseDocId = m_pIndex->hasDocument(string("file://") + previousFileName);
-	if (baseDocId > 0)
-	{
-		docIdList.insert(baseDocId);
-	}
-	if (docIdList.empty() == false)
-	{
-		for (set<unsigned int>::const_iterator iter = docIdList.begin();
-			iter != docIdList.end(); ++iter)
-		{
-			DocumentInfo docInfo;
-
-#ifdef DEBUG
-			cout << "OnDiskHandler::fileMoved: moving " << *iter << endl;
-#endif
-			if (m_pIndex->getDocumentInfo(*iter, docInfo) == true)
-			{
-				string newLocation(docInfo.getLocation());
-
-				if (baseDocId == *iter)
-				{
-					Url previousUrlObj(previousFileName), urlObj(fileName);
-
-					// Update the title if it was the directory/file name
-					if (docInfo.getTitle() == previousUrlObj.getFile())
-					{
-						docInfo.setTitle(urlObj.getFile());
-					}
-				}
-
-				string::size_type pos = newLocation.find(previousFileName);
-				if (pos != string::npos)
-				{
-					newLocation.replace(pos, previousFileName.length(), fileName);
-
-					// Change the location
-					docInfo.setLocation(newLocation);
-
-					handledEvent = replaceFile(*iter, docInfo);
-#ifdef DEBUG
-					cout << "OnDiskHandler::fileMoved: moved " << *iter << ", " << docInfo.getLocation() << endl;
-#endif
-				}
-#ifdef DEBUG
-				else cout << "OnDiskHandler::fileMoved: skipping " << newLocation << endl;
-#endif
-			}
-		}
-	}
-#ifdef DEBUG
-	else cout << "OnDiskHandler::fileMoved: no documents in " << previousFileName << endl;
-#endif
-	pthread_mutex_unlock(&m_mutex);
-
-	return handledEvent;
-}
-
-bool OnDiskHandler::fileDeleted(const string &fileName, IndexInterface::NameType type)
-{
-	set<unsigned int> docIdList;
-	string location(string("file://") + fileName);
-	bool unindexedDocs = false, handledEvent = false;
-
-#ifdef DEBUG
-	cout << "OnDiskHandler::fileDeleted: " << fileName << endl;
-#endif
-	if (m_pIndex == NULL)
-	{
-		return false;
-	}
-
-	pthread_mutex_lock(&m_mutex);
-	// Unindex all of the directory/file's documents
-	if (type == IndexInterface::BY_FILE)
-	{
-		unindexedDocs = m_pIndex->unindexDocuments(location, type);
-	}
-	else
-	{
-		unindexedDocs = m_pIndex->unindexDocuments(fileName, type);
-	}
-	if (unindexedDocs == true)
-	{
-		// ...as well as the actual directory/file
-		m_pIndex->unindexDocument(location);
-
-		m_history.deleteItems(location);
-		handledEvent = true;
-	}
-	pthread_mutex_unlock(&m_mutex);
-
-	return handledEvent;
-}
-
-bool OnDiskHandler::indexFile(const string &fileName, bool isDirectory, unsigned int &sourceId)
-{
-	string location(string("file://") + fileName);
-	Url urlObj(location);
-
-	if (fileName.empty() == true)
-	{
-		return false;
-	}
-
-	// Is it black-listed ?
-	if (PinotSettings::getInstance().isBlackListed(fileName) == true)
-	{
-		return false;
-	}
-
-	DocumentInfo docInfo("", location, MIMEScanner::scanUrl(urlObj), "");
-
-	// What source does it belong to ?
-	for (map<unsigned int, string>::const_iterator sourceIter = m_fileSources.begin();
-		sourceIter != m_fileSources.end(); ++sourceIter)
-	{
-		sourceId = sourceIter->first;
-
-		if (sourceIter->second.length() > location.length())
-		{
-			// Skip
-			continue;
-		}
-
-		if (location.substr(0, sourceIter->second.length()) == sourceIter->second)
-		{
-			set<string> labels;
-			stringstream labelStream;
-
-			// That's the one
-			labelStream << "X-SOURCE" << sourceIter->first;
-#ifdef DEBUG
-			cout << "OnDiskHandler::indexFile: source label for " << location << " is " << labelStream.str() << endl;
-#endif
-			labels.insert(labelStream.str());
-			docInfo.setLabels(labels);
-			break;
-		}
-#ifdef DEBUG
-		else cout << "OnDiskHandler::indexFile: not " << sourceIter->second << endl;
-#endif
-	}
-
-	m_metaData.getItem(docInfo, DocumentInfo::SERIAL_ALL);
-
-	m_signalFileFound(docInfo, isDirectory);
-
-	return true;
-}
-
-bool OnDiskHandler::replaceFile(unsigned int docId, DocumentInfo &docInfo)
-{
-	if (m_pIndex == NULL)
-	{
-		return false;
-	}
-
-	// Unindex the destination file
-	FilterWrapper wrapFilter(m_pIndex);
-	wrapFilter.unindexDocument(docInfo.getLocation());
-
-	// Update the document info
-	return m_pIndex->updateDocumentInfo(docId, docInfo);
-}
-
-void OnDiskHandler::initialize(void)
-{
-	set<string> directories;
-
-	// Get the map of indexable locations
-	set<PinotSettings::IndexableLocation> &indexableLocations = PinotSettings::getInstance().m_indexableLocations;
-	for (set<PinotSettings::IndexableLocation>::iterator dirIter = indexableLocations.begin();
-		dirIter != indexableLocations.end(); ++dirIter)
-	{
-		directories.insert(dirIter->m_name);
-	}
-
-	// Unindex documents that belong to sources that no longer exist
-	if (m_history.getSources(m_fileSources) > 0)
-	{
-		for(map<unsigned int, string>::const_iterator sourceIter = m_fileSources.begin();
-			sourceIter != m_fileSources.end(); ++sourceIter)
-		{
-			unsigned int sourceId = sourceIter->first;
-
-			if (sourceIter->second.substr(0, 7) != "file://")
-			{
-				// Skip
-				continue;
-			}
-
-			// Is this an indexable location ?
-			if (directories.find(sourceIter->second.substr(7)) == directories.end())
-			{
-				stringstream labelStream;
-
-				labelStream << "X-SOURCE" << sourceId;
-
-#ifdef DEBUG
-				cout << "OnDiskHandler::initialize: " << sourceIter->second
-					<< ", source " << sourceId << " was removed" << endl;
-#endif
-				// All documents with this label will be unindexed
-				if ((m_pIndex != NULL) &&
-					(m_pIndex->unindexDocuments(labelStream.str(), IndexInterface::BY_LABEL) == true))
-				{
-					// Delete the source itself and all its items
-					m_history.deleteSource(sourceId);
-					m_history.deleteItems(sourceId);
-				}
-			}
-#ifdef DEBUG
-			else cout << "OnDiskHandler::initialize: " << sourceIter->second
-				<< " is still configured" << endl;
-#endif
-		}
-	}
-}
-
-void OnDiskHandler::flushIndex(void)
-{
-	pthread_mutex_lock(&m_mutex);
-	if (m_pIndex != NULL)
-	{
-		m_pIndex->flush();
-	}
-	pthread_mutex_unlock(&m_mutex);
-}
-
-bool OnDiskHandler::fileExists(const string &fileName)
-{
-	// Nothing to do here
-	return true;
-}
-
-bool OnDiskHandler::fileCreated(const string &fileName)
-{
-	unsigned int sourceId;
-	bool handledEvent = false;
-
-#ifdef DEBUG
-	cout << "OnDiskHandler::fileCreated: " << fileName << endl;
-#endif
-	pthread_mutex_lock(&m_mutex);
-	// The file may exist in the index
-	handledEvent = indexFile(fileName, false, sourceId);
-	if (handledEvent == true)
-	{
-	        string location("file://" + fileName);
-		CrawlHistory::CrawlStatus status = CrawlHistory::UNKNOWN;
-	        time_t itemDate;
-
-		// ...and therefore may exist in the history database
-		if (m_history.hasItem(location, status, itemDate) == true)
-		{
-			m_history.updateItem(location, CrawlHistory::CRAWLED, time(NULL));
-		}
-		else
-		{
-			m_history.insertItem(location, CrawlHistory::CRAWLED, sourceId, time(NULL));
-		}
-	}
-	pthread_mutex_unlock(&m_mutex);
-
-	return handledEvent;
-}
-
-bool OnDiskHandler::directoryCreated(const string &dirName)
-{
-	unsigned int sourceId;
-	bool handledEvent = false;
-
-#ifdef DEBUG
-	cout << "OnDiskHandler::directoryCreated: " << dirName << endl;
-#endif
-	pthread_mutex_lock(&m_mutex);
-	handledEvent = indexFile(dirName, true, sourceId);
-	// History will be set by crawling
-	pthread_mutex_unlock(&m_mutex);
-
-	return handledEvent;
-}
-
-bool OnDiskHandler::fileModified(const string &fileName)
-{
-	unsigned int sourceId;
-	bool handledEvent = false;
-
-#ifdef DEBUG
-	cout << "OnDiskHandler::fileModified: " << fileName << endl;
-#endif
-	pthread_mutex_lock(&m_mutex);
-	// Update the file, or index if necessary
-	handledEvent = indexFile(fileName, false, sourceId);
-	if (handledEvent == true)
-	{
-		m_history.updateItem("file://" + fileName, CrawlHistory::CRAWLED, time(NULL));
-	}
-	pthread_mutex_unlock(&m_mutex);
-
-	return handledEvent;
-}
-
-bool OnDiskHandler::fileMoved(const string &fileName, const string &previousFileName)
-{
-	return fileMoved(fileName, previousFileName, IndexInterface::BY_FILE);
-}
-
-bool OnDiskHandler::directoryMoved(const string &dirName,
-	const string &previousDirName)
-{
-	return fileMoved(dirName, previousDirName, IndexInterface::BY_DIRECTORY);
-}
-
-bool OnDiskHandler::fileDeleted(const string &fileName)
-{
-	return fileDeleted(fileName, IndexInterface::BY_FILE);
-}
-
-bool OnDiskHandler::directoryDeleted(const string &dirName)
-{
-	return fileDeleted(dirName, IndexInterface::BY_DIRECTORY);
-}
-
-sigc::signal2<void, DocumentInfo, bool>& OnDiskHandler::getFileFoundSignal(void)
-{
-	return m_signalFileFound;
-}
-

Deleted: trunk/UI/GTK2/src/OnDiskHandler.h
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/OnDiskHandler.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,98 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
- 
-#ifndef _ONDISKHANDLER_HH
-#define _ONDISKHANDLER_HH
-
-#include <time.h>
-#include <pthread.h>
-#include <string>
-#include <map>
-#include <sigc++/sigc++.h>
-
-#include "CrawlHistory.h"
-#include "MetaDataBackup.h"
-#include "IndexInterface.h"
-#include "MonitorHandler.h"
-#include "PinotSettings.h"
-
-class OnDiskHandler : public MonitorHandler
-{
-	public:
-		OnDiskHandler();
-		virtual ~OnDiskHandler();
-
-		/// Initializes things before starting monitoring.
-		virtual void initialize(void);
-
-		/// Handles flushing the index.
-		virtual void flushIndex(void);
-
-		/// Handles file existence events.
-		virtual bool fileExists(const std::string &fileName);
-
-		/// Handles file creation events.
-		virtual bool fileCreated(const std::string &fileName);
-
-		/// Handles directory creation events.
-		virtual bool directoryCreated(const std::string &dirName);
-
-		/// Handles file modified events.
-		virtual bool fileModified(const std::string &fileName);
-
-		/// Handles file moved events.
-		virtual bool fileMoved(const std::string &fileName,
-			const std::string &previousFileName);
-
-		/// Handles directory moved events.
-		virtual bool directoryMoved(const std::string &dirName,
-			const std::string &previousDirName);
-
-		/// Handles file deleted events.
-		virtual bool fileDeleted(const std::string &fileName);
-
-		/// Handles directory deleted events.
-		virtual bool directoryDeleted(const std::string &dirName);
-
-		sigc::signal2<void, DocumentInfo, bool>& getFileFoundSignal(void);
-
-	protected:
-		pthread_mutex_t m_mutex;
-		sigc::signal2<void, DocumentInfo, bool> m_signalFileFound;
-		std::map<unsigned int, std::string> m_fileSources;
-		CrawlHistory m_history;
-		MetaDataBackup m_metaData;
-		IndexInterface *m_pIndex;
-
-		bool fileMoved(const std::string &fileName,
-			const std::string &previousFileName,
-			IndexInterface::NameType type);
-
-		bool fileDeleted(const std::string &fileName, IndexInterface::NameType type);
-
-		bool indexFile(const std::string &fileName, bool isDirectory, unsigned int &sourceId);
-
-		bool replaceFile(unsigned int docId, DocumentInfo &docInfo);
-
-	private:
-		OnDiskHandler(const OnDiskHandler &other);
-		OnDiskHandler &operator=(const OnDiskHandler &other);
-
-};
-
-#endif // _ONDISKHANDLER_HH

Deleted: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,2170 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <ctype.h>
-#include <unistd.h>
-#include <string.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <dirent.h>
-#ifdef HAVE_PWD_H
-#include <pwd.h>
-#endif
-#ifdef HAVE_FNMATCH_H
-#include <fnmatch.h>
-#endif
-#include <algorithm>
-#include <iostream>
-
-#include <glibmm/convert.h>
-#include <glibmm/date.h>
-#include <libxml++/parsers/domparser.h>
-#include <libxml++/nodes/node.h>
-#include <libxml++/nodes/textnode.h>
-
-#include "NLS.h"
-#include "CommandLine.h"
-#include "Languages.h"
-#include "StringManip.h"
-#include "ModuleFactory.h"
-#include "PluginWebEngine.h"
-#include "PinotSettings.h"
-
-using namespace std;
-using namespace Glib;
-using namespace xmlpp;
-
-static string getElementContent(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return "";
-	}
-
-#ifdef HAS_LIBXMLPP026
-	const TextNode *pText = pElem->get_child_content();
-#else
-	const TextNode *pText = pElem->get_child_text();
-#endif
-	if (pText == NULL)
-	{
-		return "";
-	}
-
-	return pText->get_content();
-}
-
-static Element *addChildElement(Element *pElem, const string &nodeName, const string &nodeContent)
-{
-	if (pElem == NULL)
-	{
-		return NULL;
-	}
-
-	Element *pSubElem = pElem->add_child(nodeName);
-	if (pSubElem != NULL)
-	{
-#ifdef HAS_LIBXMLPP026
-		pSubElem->set_child_content(nodeContent);
-#else
-		pSubElem->set_child_text(nodeContent);
-#endif
-	}
-
-	return pSubElem;
-}
-
-PinotSettings PinotSettings::m_instance;
-bool PinotSettings::m_clientMode = false;
-
-PinotSettings::PinotSettings() :
-	m_warnAboutVersion(false),
-	m_defaultBackend("xapian"),
-	m_minimumDiskSpace(50),
-	m_xPos(0),
-	m_yPos(0),
-	m_width(0),
-	m_height(0),
-	m_panePos(-1),
-	m_showEngines(false),
-	m_expandQueries(false),
-	m_ignoreRobotsDirectives(false),
-	m_suggestQueryTerms(true),
-	m_newResultsColourRed(65535),
-	m_newResultsColourGreen(0),
-	m_newResultsColourBlue(0),
-	m_proxyPort(8080),
-	m_proxyEnabled(false),
-	m_isBlackList(true),
-	m_firstRun(false),
-	m_indexCount(0)
-{
-	string directoryName(getConfigurationDirectory());
-	struct stat fileStat;
-
-	// Find out if there is a .pinot directory
-	if (stat(directoryName.c_str(), &fileStat) != 0)
-	{
-		// No, create it then
-#ifdef WIN32
-		if (mkdir(directoryName.c_str()) == 0)
-#else
-		if (mkdir(directoryName.c_str(), (mode_t)S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IWGRP|S_IXGRP|S_IROTH|S_IXOTH) == 0)
-#endif
-		{
-			cerr << "Created directory " << directoryName << endl;
-			m_firstRun = true;
-		}
-		else
-		{
-			cerr << "Couldn't create pinot directory at "
-				<< directoryName << endl;
-		}
-	}
-
-	// This is where the internal indices live
-	m_docsIndexLocation = directoryName;
-	m_docsIndexLocation += "/index";
-	m_daemonIndexLocation = directoryName;
-	m_daemonIndexLocation += "/daemon";
-
-	// This is not set in the settings files
-	char *pEnvVar = getenv("PINOT_MINIMUM_DISK_SPACE");
-	if ((pEnvVar != NULL) &&
-		(strlen(pEnvVar) > 0))
-	{
-		m_minimumDiskSpace = atof(pEnvVar);
-	}
-}
-
-PinotSettings::~PinotSettings()
-{
-}
-
-PinotSettings &PinotSettings::getInstance(void)
-{
-	return m_instance;
-}
-
-bool PinotSettings::enableClientMode(bool enable)
-{
-	bool isEnabled = m_clientMode;
-
-	m_clientMode = enable;
-
-	return isEnabled;
-}
-
-string PinotSettings::getHomeDirectory(void)
-{
-#ifdef HAVE_PWD_H
-	struct passwd *pPasswd = getpwuid(geteuid());
-
-	if ((pPasswd != NULL) &&
-		(pPasswd->pw_dir != NULL))
-	{
-		return pPasswd->pw_dir;
-	}
-	else
-	{
-#endif
-		char *homeDir = getenv("HOME");
-		if (homeDir != NULL)
-		{
-			return homeDir;
-		}
-#ifdef HAVE_PWD_H
-	}
-
-	return "~";
-#else
-
-	return ".";
-#endif
-}
-
-string PinotSettings::getConfigurationDirectory(void)
-{
-	string directoryName(getHomeDirectory());
-
-	if (directoryName.empty() == true)
-	{
-		return "~/.pinot";
-	}
-	directoryName += "/.pinot";
-
-	return directoryName;
-}
-
-string PinotSettings::getFileName(bool prefsOrUI)
-{
-	string configFileName(getConfigurationDirectory());
-
-	if (prefsOrUI == true)
-	{
-		configFileName += "/prefs.xml";
-	}
-	else
-	{
-		configFileName += "/ui.xml";
-	}
-
-	return configFileName;
-}
-
-string PinotSettings::getCurrentUserName(void)
-{
-#ifdef HAVE_PWD_H
-	struct passwd *pPasswd = getpwuid(geteuid());
-
-	if ((pPasswd != NULL) &&
-		(pPasswd->pw_name != NULL))
-	{
-		return pPasswd->pw_name;
-	}
-#endif
-
-	return "";
-}
-
-void PinotSettings::checkHistoryDatabase(void)
-{
-	string uiHistoryDatabase(getConfigurationDirectory());
-	string daemonHistoryDatabase(getConfigurationDirectory());
-	struct stat fileStat;
-
-	uiHistoryDatabase += "/history";
-	daemonHistoryDatabase += "/history-daemon";
-
-	// Copy the UI's over to the daemon's history if it doesn't exist
-	if ((stat(uiHistoryDatabase.c_str(), &fileStat) == 0) &&
-		((stat(daemonHistoryDatabase.c_str(), &fileStat) != 0) ||
-		(!S_ISREG(fileStat.st_mode))))
-	{
-		string output;
-
-		CommandLine::runSync(string("\\cp -f ") + uiHistoryDatabase + " " + daemonHistoryDatabase, output);
-#ifdef DEBUG
-		cout << "PinotSettings::checkHistoryDatabase: " << output << endl;
-#endif
-	}
-}
-
-string PinotSettings::getHistoryDatabaseName(bool needToQueryDaemonHistory)
-{
-	string historyDatabase(getConfigurationDirectory());
-
-	if ((m_clientMode == false) ||
-		(needToQueryDaemonHistory == true))
-	{
-		historyDatabase += "/history-daemon";
-	}
-	else
-	{
-		historyDatabase += "/history";
-	}
-
-	return historyDatabase;
-}
-
-bool PinotSettings::isFirstRun(void) const
-{
-	return m_firstRun;
-}
-
-void PinotSettings::clear(void)
-{
-	m_version.clear();
-	m_warnAboutVersion = false;
-	m_defaultBackend = "xapian";
-	m_googleAPIKey.clear();
-	m_xPos = 0;
-	m_yPos = 0;
-	m_width = 0;
-	m_height = 0;
-	m_panePos = -1;
-	m_showEngines = false;
-	m_expandQueries = false;
-	m_ignoreRobotsDirectives = false;
-	m_suggestQueryTerms = true;
-	m_newResultsColourRed = 65535;
-	m_newResultsColourGreen = 0;
-	m_newResultsColourBlue = 0;
-	m_proxyAddress.clear();
-	m_proxyPort = 8080;
-	m_proxyType.clear();
-	m_proxyEnabled = false;
-	m_indexableLocations.clear();
-	m_filePatternsList.clear();
-	m_isBlackList = true;
-	m_editablePluginValues.clear();
-	m_cacheProviders.clear();
-	m_cacheProtocols.clear();
-
-	m_firstRun = false;
-	m_indexes.clear();
-	m_indexCount = 0;
-	m_engines.clear();
-	m_engineIds.clear();
-	m_engineChannels.clear();
-	m_queries.clear();
-	m_labels.clear();
-}
-
-bool PinotSettings::load(LoadWhat what)
-{
-	string fileName;
-	bool loadedUIConfiguration = false;
-
-	if ((what == LOAD_ALL) ||
-		(what == LOAD_GLOBAL))
-	{
-		fileName = string(SYSCONFDIR) + "/pinot/globalconfig.xml";
-
-		if (loadConfiguration(fileName, true) == false)
-		{
-			return false;
-		}
-
-		if (what == LOAD_GLOBAL)
-		{
-			// Stop here
-			return true;
-		}
-	}
-
-	// Load settings ?
-	if (m_firstRun == false)
-	{
-		// Load 0.90 preferences first
-		if (loadConfiguration(getFileName(true), false) == false)
-		{
-			fileName = getConfigurationDirectory() + "/config.xml";
-
-			// We may have to migrate away from a pre-0.90 configuration
-			clear();
-			if (loadConfiguration(fileName, false) == true)
-			{
-				// Save settings now to the new format
-				save(SAVE_PREFS);
-				save(SAVE_CONFIG);
-
-				cout << "Migrated settings to 0.90 format" << endl;
-			}
-			else
-			{
-				m_firstRun = true;
-			}
-		}
-		else
-		{
-			loadedUIConfiguration = loadConfiguration(getFileName(false), false);
-		}
-	}
-
-	if (what == LOAD_ALL)
-	{
-		// Load search engines
-		loadSearchEngines(string(PREFIX) + "/share/pinot/engines");
-		loadSearchEngines(getConfigurationDirectory() + "/engines");
-	}
-
-	map<ModuleProperties, bool> engines;
-	string currentUserChannel("X-Current-User-Channel");
-
-	// Some engines are available as back-ends
-	ModuleFactory::getSupportedEngines(engines);
-	for (map<ModuleProperties, bool>::const_iterator engineIter = engines.begin();
-		engineIter != engines.end(); ++engineIter)
-	{
-		if (engineIter->second == true)
-		{
-			string channelName(engineIter->first.m_channel);
-
-			m_engineIds[1 << m_engines.size()] = engineIter->first.m_name;
-
-			// Is a channel specified ?
-			if (engineIter->first.m_channel.empty() == true)
-			{
-				ModuleProperties modProps(engineIter->first);
-
-				channelName = modProps.m_channel = currentUserChannel;
-
-#ifdef DEBUG
-				cout << "PinotSettings::load: no channel for back-end " << engineIter->first.m_name << endl;
-#endif
-				m_engines.insert(modProps);
-			}
-			else
-			{
-				m_engines.insert(engineIter->first);
-			}
-
-			if (m_engineChannels.find(channelName) == m_engineChannels.end())
-			{
-				m_engineChannels.insert(pair<string, bool>(channelName, true));
-			}
-		}
-	}
-
-	// Internal indices
-	addIndex(_("My Web Pages"), m_docsIndexLocation, true);
-	addIndex(_("My Documents"), m_daemonIndexLocation, true);
-
-	if (loadedUIConfiguration == false)
-	{
-		// Add default labels
-		m_labels.insert(_("Important"));
-		m_labels.insert(_("New"));
-		m_labels.insert(_("Personal"));
-		m_isBlackList = getDefaultPatterns(m_filePatternsList);
-
-		// Create default queries
-#ifdef HAVE_PWD_H
-		struct passwd *pPasswd = getpwuid(geteuid());
-		if (pPasswd != NULL)
-		{
-			string userName;
-
-			if ((pPasswd->pw_gecos != NULL) &&
-				(strlen(pPasswd->pw_gecos) > 0))
-			{
-				userName = pPasswd->pw_gecos;
-			}
-			else if (pPasswd->pw_name != NULL)
-			{
-				userName = pPasswd->pw_name;
-			}
-
-			if (userName.empty() == false)
-			{
-				QueryProperties queryProps(_("Me"), userName);
-
-				queryProps.setSortOrder(QueryProperties::DATE);
-				addQuery(queryProps);
-			}
-		}
-#endif
-
-		QueryProperties queryProps(_("Latest First"), "dir:/");
-		queryProps.setSortOrder(QueryProperties::DATE);
-		addQuery(queryProps);
-		addQuery(QueryProperties(_("Home Stuff"), string("dir:") + getHomeDirectory()));
-		addQuery(QueryProperties(_("With Label New"), "label:New"));
-		addQuery(QueryProperties(_("Have CJKV"), "tokens:CJKV"));
-		addQuery(QueryProperties(_("In English"), "lang:en"));
-		addQuery(QueryProperties(_("10kb And Smaller"), "0..10240b"));
-		addQuery(QueryProperties("Pinot search", "pinot search"));
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadSearchEngines(const string &directoryName)
-{
-	if (directoryName.empty() == true)
-	{
-		return true;
-	}
-
-	DIR *pDir = opendir(directoryName.c_str());
-	if (pDir == NULL)
-	{
-		return false;
-	}
-
-	// Iterate through this directory's entries
-	struct dirent *pDirEntry = readdir(pDir);
-	while (pDirEntry != NULL)
-	{
-		char *pEntryName = pDirEntry->d_name;
-		if (pEntryName != NULL)
-		{
-			struct stat fileStat;
-			string location = directoryName;
-			location += "/";
-			location += pEntryName;
-
-			// Is that a file ?
-			if ((stat(location.c_str(), &fileStat) == 0) &&
-				(S_ISREG(fileStat.st_mode)))
-			{
-				SearchPluginProperties properties;
-
-				if ((PluginWebEngine::getDetails(location, properties) == true) &&
-					(properties.m_name.empty() == false) &&
-					(properties.m_longName.empty() == false))
-				{
-					m_engineIds[1 << m_engines.size()] = properties.m_longName;
-					if (properties.m_channel.empty() == true)
-					{
-						properties.m_channel = _("Unclassified");
-					}
-					// SearchPluginProperties derives ModuleProperties
-					m_engines.insert(properties);
-					if (m_engineChannels.find(properties.m_channel) == m_engineChannels.end())
-					{
-						m_engineChannels.insert(pair<string, bool>(properties.m_channel, true));
-					}
-
-					// Any editable parameters in this plugin ?
-					for (map<string, string>::const_iterator editableIter = properties.m_editableParameters.begin();
-						editableIter != properties.m_editableParameters.end(); ++editableIter)
-					{
-						// This may have been created when loading settings
-						if (m_editablePluginValues.find(editableIter->second) == m_editablePluginValues.end())
-						{
-							m_editablePluginValues[editableIter->second] = "";
-						}
-					}
-#ifdef DEBUG
-					cout << "PinotSettings::loadSearchEngines: " << properties.m_name
-						<< ", " << properties.m_longName << ", " << properties.m_option
-						<< " has " << properties.m_editableParameters.size() << " editable values" << endl;
-#endif
-				}
-			}
-		}
-
-		// Next entry
-		pDirEntry = readdir(pDir);
-	}
-	closedir(pDir);
-
-	return true;
-}
-
-bool PinotSettings::loadConfiguration(const string &fileName, bool isGlobal)
-{
-	struct stat fileStat;
-	bool success = true;
-
-	if ((stat(fileName.c_str(), &fileStat) != 0) ||
-		(!S_ISREG(fileStat.st_mode)))
-	{
-		cerr << "Couldn't open settings file " << fileName << endl;
-		return false;
-	}
-
-	try
-	{
-		// Parse the settings file
-		DomParser parser;
-		parser.set_substitute_entities(true);
-		parser.parse_file(fileName);
-		xmlpp::Document *pDocument = parser.get_document();
-		if (pDocument == NULL)
-		{
-			return false;
-		}
-
-		Element *pRootElem = pDocument->get_root_node();
-		if (pRootElem == NULL)
-		{
-			return false;
-		}
-
-		// Check the top-level element is what we expect
-		ustring rootNodeName = pRootElem->get_name();
-		if (rootNodeName != "pinot")
-		{
-			return false;
-		}
-
-		// Go through the subnodes
-		const Node::NodeList childNodes = pRootElem->get_children();
-		if (childNodes.empty() == false)
-		{
-			for (Node::NodeList::const_iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-			{
-				Node *pNode = (*iter);
-				// All nodes should be elements
-				Element *pElem = dynamic_cast<Element*>(pNode);
-				if (pElem == NULL)
-				{
-					continue;
-				}
-
-				string nodeName(pElem->get_name());
-				string nodeContent(getElementContent(pElem));
-				if (isGlobal == true)
-				{
-					if (nodeName == "cache")
-					{
-						loadCacheProviders(pElem);
-					}
-					else
-					{
-						// Unsupported element
-						continue;
-					}
-				}
-				else if (nodeName == "version")
-				{
-					m_version = nodeContent;
-				}
-				else if (nodeName == "warnaboutversion")
-				{
-					if (nodeContent == "YES")
-					{
-						m_warnAboutVersion = true;
-					}
-					else
-					{
-						m_warnAboutVersion = false;
-					}
-				}
-				else if (nodeName == "backend")
-				{
-					m_defaultBackend = nodeContent;
-				}
-				else if (nodeName == "googleapikey")
-				{
-					m_googleAPIKey = nodeContent;
-				}
-				else if (nodeName == "ui")
-				{
-					loadUi(pElem);
-				}
-				else if (nodeName == "extraindex")
-				{
-					loadIndexes(pElem);
-				}
-				else if (nodeName == "channel")
-				{
-					loadEngineChannels(pElem);
-				}
-				else if (nodeName == "storedquery")
-				{
-					loadQueries(pElem);
-				}
-				else if (nodeName == "label")
-				{
-					loadLabels(pElem);
-				}
-				else if (nodeName == "robots")
-				{
-					if (nodeContent == "IGNORE")
-					{
-						m_ignoreRobotsDirectives = true;
-					}
-					else
-					{
-						m_ignoreRobotsDirectives = false;
-					}
-				}
-				else if (nodeName == "suggestterms")
-				{
-					if (nodeContent == "YES")
-					{
-						m_suggestQueryTerms = true;
-					}
-					else
-					{
-						m_suggestQueryTerms = false;
-					}
-				}
-				else if (nodeName == "newresults")
-				{
-					loadColour(pElem);
-				}
-				else if (nodeName == "proxy")
-				{
-					loadProxy(pElem);
-				}
-				else if (nodeName == "indexable")
-				{
-					loadIndexableLocations(pElem);
-				}
-				else if ((nodeName == "blacklist") ||
-					(nodeName == "patterns"))
-				{
-					loadFilePatterns(pElem);
-				}
-				else if (nodeName == "pluginparameters")
-				{
-					loadPluginParameters(pElem);
-				}
-			}
-		}
-	}
-	catch (const std::exception& ex)
-	{
-		cerr << "Couldn't parse settings file: "
-			<< ex.what() << endl;
-		success = false;
-	}
-
-	return success;
-}
-
-bool PinotSettings::loadUi(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem->get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast<Element*>(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem->get_name());
-		string nodeContent(getElementContent(pChildElem));
-		if (nodeName == "xpos")
-		{
-			m_xPos = atoi(nodeContent.c_str());
-		}
-		else if (nodeName == "ypos")
-		{
-			m_yPos = atoi(nodeContent.c_str());
-		}
-		else if (nodeName == "width")
-		{
-			m_width = atoi(nodeContent.c_str());
-		}
-		else if (nodeName == "height")
-		{
-			m_height = atoi(nodeContent.c_str());
-		}
-		else if (nodeName == "panepos")
-		{
-			m_panePos = atoi(nodeContent.c_str());
-		}
-		else if (nodeName == "expandqueries")
-		{
-			if (nodeContent == "YES")
-			{
-				m_expandQueries = true;
-			}
-			else
-			{
-				m_expandQueries = false;
-			}
-		}
-		else if (nodeName == "showengines")
-		{
-			if (nodeContent == "YES")
-			{
-				m_showEngines = true;
-			}
-			else
-			{
-				m_showEngines = false;
-			}
-		}
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadIndexes(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem->get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	string indexName, indexLocation;
-
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast<Element*>(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem->get_name());
-		string nodeContent(getElementContent(pChildElem));
-		if (nodeName == "name")
-		{
-			indexName = nodeContent;
-		}
-		else if (nodeName == "location")
-		{
-			indexLocation = nodeContent;
-		}
-	}
-
-	if ((indexName.empty() == false) &&
-		(indexLocation.empty() == false))
-	{
-		addIndex(indexName, indexLocation, false);
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadEngineChannels(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem->get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast<Element*>(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem->get_name());
-		string nodeContent(getElementContent(pChildElem));
-		if (nodeName == "name")
-		{
-			std::map<string, bool>::iterator channelIter = m_engineChannels.find(nodeContent);
-
-			if (channelIter != m_engineChannels.end())
-			{
-				channelIter->second = false;
-			}
-			else
-			{
-				m_engineChannels.insert(pair<string, bool>(nodeContent, false));
-			}
-		}
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadQueries(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem->get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	QueryProperties queryProps;
-	Date minDate, maxDate;
-	string freeQuery;
-	bool enableMinDate = false, enableMaxDate = false;
-
-	// Load the query's properties
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast<Element*>(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem->get_name());
-		string nodeContent(getElementContent(pChildElem));
-		if (nodeName == "name")
-		{
-			queryProps.setName(nodeContent);
-		}
-		else if (nodeName == "sortorder")
-		{
-			if (nodeContent == "DATE")
-			{
-				queryProps.setSortOrder(QueryProperties::DATE);
-			}
-			else
-			{
-				queryProps.setSortOrder(QueryProperties::RELEVANCE);
-			}
-		}
-		else if (nodeName == "text")
-		{
-			freeQuery = nodeContent;
-		}
-		else if ((nodeName == "and") &&
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += " ";
-			}
-			freeQuery += nodeContent;
-		}
-		else if ((nodeName == "phrase") &&
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += " ";
-			}
-			freeQuery += "\"";
-			freeQuery += nodeContent;
-			freeQuery += "\"";
-		}
-		else if ((nodeName == "any") &&
-			(nodeContent.empty() == false))
-		{
-			// FIXME: don't be lazy and add those correctly
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += " ";
-			}
-			freeQuery += nodeContent;
-		}
-		else if ((nodeName == "not") &&
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += " ";
-			}
-			freeQuery += "-(";
-			freeQuery += nodeContent;
-			freeQuery += ")";
-		}
-		else if ((nodeName == "language") &&
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += " ";
-			}
-			freeQuery += "lang:";
-			freeQuery += nodeContent;
-		}
-		else if ((nodeName == "stemlanguage") &&
-			(nodeContent.empty() == false))
-		{
-			queryProps.setStemmingLanguage(Languages::toLocale(nodeContent));
-		}
-		else if ((nodeName == "hostfilter") &&
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += " ";
-			}
-			freeQuery += "site:";
-			freeQuery += nodeContent;
-		}
-		else if ((nodeName == "filefilter") &&
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += " ";
-			}
-			freeQuery += "file:";
-			freeQuery += nodeContent;
-		}
-		else if ((nodeName == "labelfilter") &&
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += " ";
-			}
-			freeQuery += "label:";
-			freeQuery += nodeContent;
-		}
-		else if (nodeName == "maxresults")
-		{
-			int count = atoi(nodeContent.c_str());
-			queryProps.setMaximumResultsCount((unsigned int)max(count, 10));
-		}
-		else if (nodeName == "enablemindate")
-		{
-			if (nodeContent == "YES")
-			{
-				enableMinDate = true;
-			}
-		}
-		else if (nodeName == "mindate")
-		{
-			minDate.set_parse(nodeContent);
-		}
-		else if (nodeName == "enablemaxdate")
-		{
-			if (nodeContent == "YES")
-			{
-				enableMaxDate = true;
-			}
-		}
-		else if (nodeName == "maxdate")
-		{
-			maxDate.set_parse(nodeContent);
-		}
-		else if (nodeName == "index")
-		{
-			if (nodeContent == "NEW")
-			{
-				queryProps.setIndexResults(QueryProperties::NEW_RESULTS);
-			}
-			else if (nodeContent == "ALL")
-			{
-				queryProps.setIndexResults(QueryProperties::ALL_RESULTS);
-			}
-			else
-			{
-				queryProps.setIndexResults(QueryProperties::NOTHING);
-			}
-		}
-		else if (nodeName == "label")
-		{
-			queryProps.setLabelName(nodeContent);
-		}
-		else if (nodeName == "modified")
-		{
-			if (nodeContent == "YES")
-			{
-				queryProps.setModified(true);
-			}
-		}
-	}
-
-	// Are pre-0.80 dates specified ?
-	if ((enableMinDate == true) ||
-		(enableMaxDate == true))
-	{
-		// Provide reasonable defaults
-		if (enableMinDate == false)
-		{
-			minDate.set_day(1);
-			minDate.set_month(Date::JANUARY);
-			minDate.set_year(1970);
-		}
-		if (enableMaxDate == false)
-		{
-			maxDate.set_day(31);
-			maxDate.set_month(Date::DECEMBER);
-			maxDate.set_year(2099);
-		}
-
-		ustring minDateStr(minDate.format_string("%Y%m%d"));
-		ustring maxDateStr(maxDate.format_string("%Y%m%d"));
-
-#ifdef DEBUG
-		cout << "PinotSettings::loadQueries: date range " << minDateStr << " to " << maxDateStr << endl;
-#endif
-		freeQuery += " ";
-		freeQuery += minDateStr;
-		freeQuery += "..";
-		freeQuery += maxDateStr;
-	}
-
-	// We need at least a name
-	if (queryProps.getName().empty() == false)
-	{
-		if (freeQuery.empty() == false)
-		{
-			queryProps.setFreeQuery(freeQuery);
-		}
-		m_queries[queryProps.getName()] = queryProps;
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadLabels(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem->get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	// Load the label's properties
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast<Element*>(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem->get_name());
-		string nodeContent(getElementContent(pChildElem));
-
-		if (nodeName == "name")
-		{
-			m_labels.insert(nodeContent);
-		}
-		// Labels used to have colours...
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadColour(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem->get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	// Load the colour RGB components
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast<Element*>(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem->get_name());
-		string nodeContent(getElementContent(pChildElem));
-		gushort value = (gushort)atoi(nodeContent.c_str());
-
-		if (nodeName == "red")
-		{
-			m_newResultsColourRed = value;
-		}
-		else if (nodeName == "green")
-		{
-			m_newResultsColourGreen = value;
-		}
-		else if (nodeName == "blue")
-		{
-			m_newResultsColourBlue = value;
-		}
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadProxy(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem->get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast<Element*>(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem->get_name());
-		string nodeContent(getElementContent(pChildElem));
-
-		if (nodeName == "address")
-		{
-			m_proxyAddress = nodeContent;
-		}
-		else if (nodeName == "port")
-		{
-			m_proxyPort = (unsigned int)atoi(nodeContent.c_str());
-		}
-		else if (nodeName == "type")
-		{
-			m_proxyType = nodeContent;
-		}
-		else if (nodeName == "enable")
-		{
-			if (nodeContent == "YES")
-			{
-				m_proxyEnabled = true;
-			}
-			else
-			{
-				m_proxyEnabled = false;
-			}
-		}	
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadIndexableLocations(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem->get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	IndexableLocation location;
-
-	// Load the indexable location's properties
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast<Element*>(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem->get_name());
-		string nodeContent(getElementContent(pChildElem));
-
-		if (nodeName == "name")
-		{
-			location.m_name = nodeContent;
-		}
-		else if (nodeName == "monitor")
-		{
-			if (nodeContent == "YES")
-			{
-				location.m_monitor = true;
-			}
-			else
-			{
-				location.m_monitor = false;
-			}
-		}
-	}
-
-	if (location.m_name.empty() == false)
-	{
-		location.m_isSource = true;
-
-		m_indexableLocations.insert(location);
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadFilePatterns(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem->get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	// Load the file patterns list
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast<Element*>(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem->get_name());
-		string nodeContent(getElementContent(pChildElem));
-
-		if (nodeName == "pattern")
-		{
-			m_filePatternsList.insert(nodeContent);
-		}
-		else if (nodeName == "forbid")
-		{
-			if (nodeContent == "YES")
-			{
-				m_isBlackList = true;
-			}
-			else
-			{
-				m_isBlackList = false;
-			}
-		}
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadPluginParameters(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem->get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	string name, value;
-
-	// Load the plugin parameters' values 
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast<Element*>(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem->get_name());
-		string nodeContent(getElementContent(pChildElem));
-
-		if (nodeName == "name")
-		{
-			name = nodeContent;
-		}
-		else if (nodeName == "value")
-		{
-			value = nodeContent;
-		}
-	}
-
-	m_editablePluginValues[name] = value;
-
-	return true;
-}
-
-bool PinotSettings::loadCacheProviders(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem->get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	CacheProvider cacheProvider;
-
-	// Load the cache provider's properties
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast<Element*>(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem->get_name());
-		string nodeContent(getElementContent(pChildElem));
-
-		if (nodeName == "name")
-		{
-			cacheProvider.m_name = nodeContent;
-		}
-		else if (nodeName == "location")
-		{
-			cacheProvider.m_location = nodeContent;
-		}
-		else if (nodeName == "protocols")
-		{
-			nodeContent += ",";
-
-			ustring::size_type previousPos = 0, commaPos = nodeContent.find(",");
-			while (commaPos != ustring::npos)
-			{
-				string protocol(nodeContent.substr(previousPos,
-                                        commaPos - previousPos));
-
-				StringManip::trimSpaces(protocol);
-				cacheProvider.m_protocols.insert(protocol);
-
-				// Next
-				previousPos = commaPos + 1;
-				commaPos = nodeContent.find(",", previousPos);
-			}
-		}
-	}
-
-	if ((cacheProvider.m_name.empty() == false) &&
-		(cacheProvider.m_location.empty() == false))
-	{
-		m_cacheProviders.push_back(cacheProvider);
-
-		// Copy the list of protocols supported by this cache provider
-		copy(cacheProvider.m_protocols.begin(), cacheProvider.m_protocols.end(),
-			inserter(m_cacheProtocols, m_cacheProtocols.begin()));
-	}
-
-	return true;
-}
-
-bool PinotSettings::save(SaveWhat what)
-{
-	Element *pRootElem = NULL;
-	Element *pElem = NULL;
-	char numStr[64];
-	bool prefsOrUI = true;
-
-	if (what == SAVE_CONFIG)
-	{
-		prefsOrUI = false;
-	}
-
-	try
-	{
-		xmlpp::Document doc("1.0");
-
-		// Create a new node
-		pRootElem = doc.create_root_node("pinot");
-		if (pRootElem == NULL)
-		{
-			return false;
-		}
-		// ...with text children nodes
-		addChildElement(pRootElem, "version", VERSION);
-		if (what == SAVE_CONFIG)
-		{
-			addChildElement(pRootElem, "warnaboutversion", (m_warnAboutVersion ? "YES" : "NO"));
-			// User interface position and size
-			pElem = pRootElem->add_child("ui");
-			if (pElem == NULL)
-			{
-				return false;
-			}
-			snprintf(numStr, 64, "%d", m_xPos);
-			addChildElement(pElem, "xpos", numStr);
-			snprintf(numStr, 64, "%d", m_yPos);
-			addChildElement(pElem, "ypos", numStr);
-			snprintf(numStr, 64, "%d", m_width);
-			addChildElement(pElem, "width", numStr);
-			snprintf(numStr, 64, "%d", m_height);
-			addChildElement(pElem, "height", numStr);
-			snprintf(numStr, 64, "%d", m_panePos);
-			addChildElement(pElem, "panepos", numStr);
-			addChildElement(pElem, "expandqueries", (m_expandQueries ? "YES" : "NO"));
-			addChildElement(pElem, "showengines", (m_showEngines ? "YES" : "NO"));
-			// User-defined indexes
-			for (set<IndexProperties>::iterator indexIter = m_indexes.begin(); indexIter != m_indexes.end(); ++indexIter)
-			{
-				if (indexIter->m_internal == true)
-				{
-					continue;
-				}
-
-				pElem = pRootElem->add_child("extraindex");
-				if (pElem == NULL)
-				{
-					return false;
-				}
-				addChildElement(pElem, "name", indexIter->m_name);
-				addChildElement(pElem, "location", indexIter->m_location);
-			}
-			// Engine channels
-			for (map<string, bool>::iterator channelIter = m_engineChannels.begin();
-				channelIter != m_engineChannels.end(); ++channelIter)
-			{
-				// Only save those whose group was collapsed
-				if (channelIter->second == false)
-				{
-					pElem = pRootElem->add_child("channel");
-					if (pElem == NULL)
-					{
-						return false;
-					}
-					addChildElement(pElem, "name", channelIter->first);
-				}
-			}
-			// User-defined queries
-			for (map<string, QueryProperties>::iterator queryIter = m_queries.begin();
-				queryIter != m_queries.end(); ++queryIter)
-			{
-				pElem = pRootElem->add_child("storedquery");
-				if (pElem == NULL)
-				{
-					return false;
-				}
-
-				addChildElement(pElem, "name", queryIter->first);
-				addChildElement(pElem, "sortorder", (queryIter->second.getSortOrder() == QueryProperties::DATE ? "DATE" : "RELEVANCE"));
-				addChildElement(pElem, "text", queryIter->second.getFreeQuery());
-				addChildElement(pElem, "stemlanguage", Languages::toEnglish(queryIter->second.getStemmingLanguage()));
-				snprintf(numStr, 64, "%u", queryIter->second.getMaximumResultsCount());
-				addChildElement(pElem, "maxresults", numStr);
-				QueryProperties::IndexWhat indexResults = queryIter->second.getIndexResults();
-				if (indexResults == QueryProperties::NEW_RESULTS)
-				{
-					addChildElement(pElem, "index", "NEW");
-				}
-				else if (indexResults == QueryProperties::ALL_RESULTS)
-				{
-					addChildElement(pElem, "index", "ALL");
-				}
-				else
-				{
-					addChildElement(pElem, "index", "NONE");
-				}
-				addChildElement(pElem, "label", queryIter->second.getLabelName());
-				addChildElement(pElem, "modified", (queryIter->second.getModified() ? "YES" : "NO"));
-			}
-		}
-		if (what == SAVE_PREFS)
-		{
-			addChildElement(pRootElem, "backend", m_defaultBackend);
-			addChildElement(pRootElem, "googleapikey", m_googleAPIKey);
-			// Labels
-			for (set<string>::iterator labelIter = m_labels.begin(); labelIter != m_labels.end(); ++labelIter)
-			{
-				pElem = pRootElem->add_child("label");
-				if (pElem == NULL)
-				{
-					return false;
-				}
-				addChildElement(pElem, "name", *labelIter);
-			}
-			// Ignore robots directives
-			addChildElement(pRootElem, "robots", (m_ignoreRobotsDirectives ? "IGNORE" : "OBEY"));
-			// Enable terms suggestion
-			addChildElement(pRootElem, "suggestterms", (m_suggestQueryTerms ? "YES" : "NO"));
-			// New results colour
-			pElem = pRootElem->add_child("newresults");
-			if (pElem == NULL)
-			{
-				return false;
-			}
-			snprintf(numStr, 64, "%u", m_newResultsColourRed);
-			addChildElement(pElem, "red", numStr);
-			snprintf(numStr, 64, "%u", m_newResultsColourGreen);
-			addChildElement(pElem, "green", numStr);
-			snprintf(numStr, 64, "%u", m_newResultsColourBlue);
-			addChildElement(pElem, "blue", numStr);
-			// Proxy
-			pElem = pRootElem->add_child("proxy");
-			if (pElem == NULL)
-			{
-				return false;
-			}
-			addChildElement(pElem, "address", m_proxyAddress);
-			snprintf(numStr, 64, "%u", m_proxyPort);
-			addChildElement(pElem, "port", numStr);
-			addChildElement(pElem, "type", m_proxyType);
-			addChildElement(pElem, "enable", (m_proxyEnabled ? "YES" : "NO"));
-			// Locations to index 
-			for (set<IndexableLocation>::iterator locationIter = m_indexableLocations.begin();
-				locationIter != m_indexableLocations.end(); ++locationIter)
-			{
-				pElem = pRootElem->add_child("indexable");
-				if (pElem == NULL)
-				{
-					return false;
-				}
-				addChildElement(pElem, "name", locationIter->m_name);
-				addChildElement(pElem, "monitor", (locationIter->m_monitor ? "YES" : "NO"));
-			}
-			// File patterns
-			pElem = pRootElem->add_child("patterns");
-			if (pElem == NULL)
-			{
-				return false;
-			}
-			for (set<ustring>::iterator patternIter = m_filePatternsList.begin();
-				patternIter != m_filePatternsList.end() ; ++patternIter)
-			{
-				addChildElement(pElem, "pattern", *patternIter);
-			}
-			addChildElement(pElem, "forbid", (m_isBlackList ? "YES" : "NO"));
-			// Values of editable plugin parameters
-			for (map<string, string>::iterator editableIter = m_editablePluginValues.begin();
-				editableIter != m_editablePluginValues.end() ; ++editableIter)
-			{
-				if (editableIter->second.empty() == true)
-				{
-					continue;
-				}
-
-				pElem = pRootElem->add_child("pluginparameters");
-				if (pElem == NULL)
-				{
-					return false;
-				}
-				addChildElement(pElem, "name", editableIter->first);
-				addChildElement(pElem, "value", editableIter->second);
-			}
-		}
-#ifdef DEBUG
-		cout << "PinotSettings::save: saving to " << getFileName(prefsOrUI) << endl;
-#endif
-
-		// Save to file
-		doc.write_to_file_formatted(getFileName(prefsOrUI));
-	}
-	catch (const std::exception& ex)
-	{
-		cerr << "Couldn't save settings file: "
-			<< ex.what() << endl;
-		return false;
-	}
-
-	return true;
-}
-
-/// Returns the indexes set.
-const set<PinotSettings::IndexProperties> &PinotSettings::getIndexes(void) const
-{
-	return m_indexes;
-}
-
-/// Adds a new index.
-bool PinotSettings::addIndex(const ustring &name, const string &location, bool isInternal)
-{
-	unsigned int indexId(1 << m_indexCount);
-	m_indexes.insert(IndexProperties(name, location, indexId, isInternal));
-#ifdef DEBUG
-	cout << "PinotSettings::addIndex: index " << m_indexCount << " is " << name << " with ID " << indexId << endl;
-#endif
-	++m_indexCount;
-
-	return true;
-}
-
-/// Removes an index.
-bool PinotSettings::removeIndex(const IndexProperties &indexProps)
-{
-	// Remove from the names map
-	set<IndexProperties>::iterator namesMapIter = m_indexes.find(indexProps);
-	if (namesMapIter != m_indexes.end())
-	{
-		m_indexes.erase(namesMapIter);
-
-		return true;
-	}
-
-	return false;
-}
-
-/// Clears the indexes map.
-void PinotSettings::clearIndexes(void)
-{
-	// Clear and reinsert the internal indexes
-	m_indexes.clear();
-	m_indexCount = 0;
-	addIndex(_("My Web Pages"), m_docsIndexLocation, true);
-	addIndex(_("My Documents"), m_daemonIndexLocation, true);
-}
-
-/// Returns properties of the given index.
-PinotSettings::IndexProperties PinotSettings::getIndexPropertiesByName(const string &name) const
-{
-	unsigned int indexId = 0;
-
-	for (set<IndexProperties>::const_iterator propsIter = m_indexes.begin();
-		propsIter != m_indexes.end(); ++propsIter)
-	{
-		if (propsIter->m_name == name)
-		{
-			return *propsIter;
-		}
-	}
-
-	return IndexProperties();
-}
-
-/// Returns properties of the given index.
-PinotSettings::IndexProperties PinotSettings::getIndexPropertiesByLocation(const string &location) const
-{
-	for (set<IndexProperties>::const_iterator propsIter = m_indexes.begin();
-		propsIter != m_indexes.end(); ++propsIter)
-	{
-		if (propsIter->m_location == location)
-		{
-			return *propsIter;
-		}
-	}
-
-	return IndexProperties();
-}
-
-/// Returns the name(s) for the given ID.
-void PinotSettings::getIndexNames(unsigned int id, set<string> &names)
-{
-	names.clear();
-
-	// Make sure indexes are or were defined
-	if (m_indexCount == 0)
-	{
-		return;
-	}
-
-	unsigned indexId = 1 << (m_indexCount - 1);
-	do
-	{
-		if (id & indexId)
-		{
-			for (set<IndexProperties>::const_iterator propsIter = m_indexes.begin();
-				propsIter != m_indexes.end(); ++propsIter)
-			{
-				if (propsIter->m_id == indexId)
-				{
-#ifdef DEBUG
-					cout << "PinotSettings::getIndexNames: index " << indexId << " is " << propsIter->m_name << endl;
-#endif
-					// Get the associated name
-					names.insert(propsIter->m_name);
-				}
-			}
-		}
-		// Shift to the right
-		indexId = indexId >> 1;
-	} while (indexId > 0);
-}
-
-/// Returns an IndexInterface for the given index location.
-IndexInterface *PinotSettings::getIndex(const string &location)
-{
-	if (location == m_docsIndexLocation)
-	{
-		return ModuleFactory::getIndex(m_defaultBackend, m_docsIndexLocation);
-	}
-	else if ((m_clientMode == true) &&
-		(location == m_daemonIndexLocation))
-	{
-		return ModuleFactory::getIndex("dbus-" + m_defaultBackend, m_daemonIndexLocation);
-	}
-
-	return ModuleFactory::getIndex(m_defaultBackend, location);
-}
-
-/// Returns the search engines set.
-bool PinotSettings::getSearchEngines(set<ModuleProperties> &engines, const string &channelName) const
-{
-	if (channelName.empty() == true)
-	{
-		// Copy the whole list of search engines
-		copy(m_engines.begin(), m_engines.end(), inserter(engines, engines.begin()));
-	}
-	else
-	{
-		if (m_engineChannels.find(channelName) == m_engineChannels.end())
-		{
-			// Unknown channel name
-			return false;
-		}
-
-		// Copy engines that belong to the given channel
-		for (set<ModuleProperties>::iterator engineIter = m_engines.begin(); engineIter != m_engines.end(); ++engineIter)
-		{
-			if (engineIter->m_channel == channelName)
-			{
-#ifdef DEBUG
-				cout << "PinotSettings::getSearchEngines: engine " << engineIter->m_longName << " in channel " << channelName << endl;
-#endif
-				engines.insert(*engineIter);
-			}
-		}
-	}
-
-	return true;
-}
-
-/// Returns an ID that identifies the given engine name.
-unsigned int PinotSettings::getEngineId(const string &name)
-{
-	unsigned int engineId = 0;
-
-	for (map<unsigned int, string>::iterator mapIter = m_engineIds.begin();
-		mapIter != m_engineIds.end(); ++mapIter)
-	{
-		if (mapIter->second == name)
-		{
-			engineId = mapIter->first;
-			break;
-		}
-	}
-#ifdef DEBUG
-	cout << "PinotSettings::getEngineId: " << name << ", ID " << engineId << endl;
-#endif
-
-	return engineId;
-}
-
-/// Returns the name for the given ID.
-void PinotSettings::getEngineNames(unsigned int id, set<string> &names)
-{
-	names.clear();
-
-	// Make sure there are search engines defined
-	if (m_engines.empty() == true)
-	{
-		return;
-	}
-
-	unsigned engineId = 1 << (m_engines.size() - 1);
-	do
-	{
-		if (id & engineId)
-		{
-			map<unsigned int, string>::iterator mapIter = m_engineIds.find(engineId);
-			if (mapIter != m_engineIds.end())
-			{
-				// Get the associated name
-				names.insert(mapIter->second);
-			}
-		}
-		// Shift to the right
-		engineId = engineId >> 1;
-	} while (engineId > 0);
-}
-
-/// Returns the search engines channels.
-map<string, bool> &PinotSettings::getSearchEnginesChannels(void)
-{
-	return m_engineChannels;
-}
-
-/// Returns the queries map, keyed by name.
-const map<string, QueryProperties> &PinotSettings::getQueries(void) const
-{
-	return m_queries;
-}
-
-/// Adds a new query.
-bool PinotSettings::addQuery(const QueryProperties &properties)
-{
-	string name(properties.getName());
-
-	map<string, QueryProperties>::iterator queryIter = m_queries.find(name);
-	if (queryIter == m_queries.end())
-	{
-		// Okay, no such query exists
-		m_queries[name] = properties;
-
-		return true;
-	}
-
-	return false;
-}
-
-/// Removes a query.
-bool PinotSettings::removeQuery(const string &name)
-{
-	// Remove from the map
-	map<string, QueryProperties>::iterator queryIter = m_queries.find(name);
-	if (queryIter != m_queries.end())
-	{
-		m_queries.erase(queryIter);
-
-		return true;
-	}
-
-	return false;
-}
-
-/// Clears the queries map.
-void PinotSettings::clearQueries(void)
-{
-	m_queries.clear();
-}
-
-/// Gets default patterns.
-bool PinotSettings::getDefaultPatterns(set<ustring> &defaultPatterns)
-{
-	defaultPatterns.clear();
-
-	// Skip common image, video and archive types
-	defaultPatterns.insert("*~");
-	defaultPatterns.insert("*.Z");
-	defaultPatterns.insert("*.a");
-	defaultPatterns.insert("*.asf");
-	defaultPatterns.insert("*.avi");
-	defaultPatterns.insert("*.aux");
-	defaultPatterns.insert("*CVS");
-	defaultPatterns.insert("*.cap");
-	defaultPatterns.insert("*.divx");
-	defaultPatterns.insert("*.flv");
-	defaultPatterns.insert("*.gif");
-	defaultPatterns.insert("*.git");
-	defaultPatterns.insert("*.gmo");
-	defaultPatterns.insert("*.iso");
-	defaultPatterns.insert("*.la");
-	defaultPatterns.insert("*.lha");
-	defaultPatterns.insert("*.lo");
-	defaultPatterns.insert("*.loT");
-	defaultPatterns.insert("*.m4");
-	defaultPatterns.insert("*.mov");
-	defaultPatterns.insert("*.msf");
-	defaultPatterns.insert("*.mpeg");
-	defaultPatterns.insert("*.mpg");
-	defaultPatterns.insert("*.mo");
-	defaultPatterns.insert("*.o");
-	defaultPatterns.insert("*.omf");
-	defaultPatterns.insert("*.orig");
-	defaultPatterns.insert("*.part");
-	defaultPatterns.insert("*.pc");
-	defaultPatterns.insert("*.png");
-	defaultPatterns.insert("*.po");
-	defaultPatterns.insert("*.rar");
-	defaultPatterns.insert("*.rej");
-	defaultPatterns.insert("*.sh");
-	defaultPatterns.insert("*.so");
-	defaultPatterns.insert("*.svn");
-	defaultPatterns.insert("*.tiff");
-	defaultPatterns.insert("*.tmp");
-	defaultPatterns.insert("*.torrent");
-	defaultPatterns.insert("*.vm*");
-	defaultPatterns.insert("*.wmv");
-	defaultPatterns.insert("*.xbm");
-	defaultPatterns.insert("*.xpm");
-
-	return true;
-}
-
-/// Determines if a file matches the blacklist.
-bool PinotSettings::isBlackListed(const string &fileName)
-{
-	if (m_filePatternsList.empty() == true)
-	{
-		if (m_isBlackList == true)
-		{
-			// There is no black-list
-			return false;
-		}
-
-		// The file is not in the (empty) whitelist
-		return true;
-	}
-
-#ifdef HAVE_FNMATCH_H
-	// Any pattern matches this file name ?
-	for (set<ustring>::iterator patternIter = m_filePatternsList.begin(); patternIter != m_filePatternsList.end() ; ++patternIter)
-	{
-		if (fnmatch(patternIter->c_str(), fileName.c_str(), FNM_NOESCAPE) == 0)
-		{
-			// Fail if it's in the blacklist, let the file through otherwise
-			return m_isBlackList;
-		}
-	}
-#endif
-
-	return !m_isBlackList;
-}
-
-PinotSettings::IndexableLocation::IndexableLocation() :
-	m_monitor(false),
-	m_isSource(true)
-{
-}
-
-PinotSettings::IndexableLocation::IndexableLocation(const IndexableLocation &other) :
-	m_monitor(other.m_monitor),
-	m_name(other.m_name),
-	m_isSource(other.m_isSource)
-{
-}
-
-PinotSettings::IndexableLocation::~IndexableLocation()
-{
-}
-
-PinotSettings::IndexableLocation &PinotSettings::IndexableLocation::operator=(const IndexableLocation &other)
-{
-	if (this != &other)
-	{
-		m_monitor = other.m_monitor;
-		m_name = other.m_name;
-		m_isSource = other.m_isSource;
-	}
-
-	return *this;
-}
-
-bool PinotSettings::IndexableLocation::operator<(const IndexableLocation &other) const
-{
-	if (m_name < other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-bool PinotSettings::IndexableLocation::operator==(const IndexableLocation &other) const
-{
-	if (m_name == other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-PinotSettings::CacheProvider::CacheProvider()
-{
-}
-
-PinotSettings::CacheProvider::CacheProvider(const CacheProvider &other) :
-	m_name(other.m_name),
-	m_location(other.m_location)
-{
-	m_protocols.clear();
-	copy(other.m_protocols.begin(), other.m_protocols.end(),
-		inserter(m_protocols, m_protocols.begin()));
-}
-
-PinotSettings::CacheProvider::~CacheProvider()
-{
-}
-
-PinotSettings::CacheProvider &PinotSettings::CacheProvider::operator=(const CacheProvider &other)
-{
-	if (this != &other)
-	{
-		m_name = other.m_name;
-		m_location = other.m_location;
-		m_protocols.clear();
-		copy(other.m_protocols.begin(), other.m_protocols.end(),
-			inserter(m_protocols, m_protocols.begin()));
-	}
-
-	return *this;
-}
-
-bool PinotSettings::CacheProvider::operator<(const CacheProvider &other) const
-{
-	if (m_name < other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-bool PinotSettings::CacheProvider::operator==(const CacheProvider &other) const
-{
-	if (m_name == other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-PinotSettings::IndexProperties::IndexProperties() :
-	m_id(0),
-	m_internal(false)
-{
-}
-
-PinotSettings::IndexProperties::IndexProperties(const ustring &name,
-	const string &location, unsigned int id, bool isInternal) :
-	m_name(name),
-	m_location(location),
-	m_id(id),
-	m_internal(isInternal)
-{
-}
-
-PinotSettings::IndexProperties::IndexProperties(const IndexProperties &other) :
-	m_name(other.m_name),
-	m_location(other.m_location),
-	m_id(other.m_id),
-	m_internal(other.m_internal)
-{
-}
-
-PinotSettings::IndexProperties::~IndexProperties()
-{
-}
-
-PinotSettings::IndexProperties& PinotSettings::IndexProperties::operator=(const IndexProperties &other)
-{
-	if (this != &other)
-	{
-		m_name = other.m_name;
-		m_location = other.m_location;
-		m_id = other.m_id;
-		m_internal = other.m_internal;
-	}
-
-	return *this;
-}
-
-bool PinotSettings::IndexProperties::operator<(const IndexProperties &other) const
-{
-	if (m_id < other.m_id)
-	{
-		return true;
-	}
-	else if (m_id == other.m_id)
-	{
-		if (m_name < other.m_name)
-		{
-			return true;
-		}
-	}
-
-	return false;
-}
-
-bool PinotSettings::IndexProperties::operator==(const IndexProperties &other) const
-{
-	if (m_id == other.m_id)
-	{
-		return true;
-	}
-
-	return false;
-}

Deleted: trunk/UI/GTK2/src/PinotSettings.h
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/PinotSettings.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,240 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _PINOTSETTINGS_HH
-#define _PINOTSETTINGS_HH
-
-#include <sys/types.h>
-#include <string>
-#include <vector>
-#include <map>
-#include <set>
-#include <vector>
-#include <glibmm/ustring.h>
-#include <libxml++/nodes/element.h>
-
-#include "IndexInterface.h"
-#include "ModuleProperties.h"
-#include "QueryProperties.h"
-
-class PinotSettings
-{
-	public:
-		~PinotSettings();
-
-		typedef enum { LOAD_ALL = 0, LOAD_GLOBAL, LOAD_LOCAL } LoadWhat;
-
-		typedef enum { SAVE_PREFS = 0, SAVE_CONFIG } SaveWhat;
-
-		class IndexProperties
-		{
-			public:
-				IndexProperties();
-				IndexProperties(const Glib::ustring &name,
-		                        const std::string &location,
-					unsigned int id, bool isInternal);
-				IndexProperties(const IndexProperties &other);
-				virtual ~IndexProperties();
-
-				IndexProperties& operator=(const IndexProperties &other);
-				bool operator<(const IndexProperties &other) const;
-				bool operator==(const IndexProperties &other) const;
-
-				Glib::ustring m_name;
-				std::string m_location;
-				unsigned int m_id;
-				bool m_internal;
-
-		};
-
-		static PinotSettings &getInstance(void);
-
-		static bool enableClientMode(bool enable);
-
-		static std::string getHomeDirectory(void);
-
-		static std::string getConfigurationDirectory(void);
-
-		static std::string getFileName(bool prefsOrUI);
-
-		static std::string getCurrentUserName(void);
-
-		static void checkHistoryDatabase(void);
-
-		static std::string getHistoryDatabaseName(bool needToQueryDaemonHistory = false);
-
-		bool isFirstRun(void) const;
-
-		void clear(void);
-
-		bool load(LoadWhat what);
-
-		bool save(SaveWhat what);
-
-		/// Returns the indexes set.
-		const std::set<IndexProperties> &getIndexes(void) const;
-
-		/// Adds a new index.
-		bool addIndex(const Glib::ustring &name, const std::string &location,
-			bool isInternal = false);
-
-		/// Removes an index.
-		bool removeIndex(const IndexProperties &indexProps);
-
-		/// Clears the indexes map.
-		void clearIndexes(void);
-
-		/// Returns properties of the given index.
-		IndexProperties getIndexPropertiesByName(const std::string &name) const;
-
-		/// Returns properties of the given index.
-		IndexProperties getIndexPropertiesByLocation(const std::string &location) const;
-
-		/// Returns the name(s) for the given ID.
-		void getIndexNames(unsigned int id, std::set<std::string> &names);
-
-		/// Returns an IndexInterface for the given index location.
-		IndexInterface *getIndex(const std::string &location);
-
-		/// Returns the search engines set.
-		bool getSearchEngines(std::set<ModuleProperties> &engines, const std::string &channelName = "") const;
-
-		/// Returns an ID that identifies the given engine name.
-		unsigned int getEngineId(const std::string &name);
-
-		/// Returns the name(s) for the given ID.
-		void getEngineNames(unsigned int id, std::set<std::string> &names);
-
-		/// Returns the search engines channels.
-		std::map<std::string, bool> &getSearchEnginesChannels(void);
-
-		/// Returns the queries map, keyed by name.
-		const std::map<std::string, QueryProperties> &getQueries(void) const;
-
-		/// Adds a new query.
-		bool addQuery(const QueryProperties &properties);
-
-		/// Removes a query.
-		bool removeQuery(const std::string &name);
-
-		/// Clears the queries map.
-		void clearQueries(void);
-
-		/// Gets default patterns.
-		bool getDefaultPatterns(std::set<Glib::ustring> &defaultPatterns);
-
-		/// Determines if a file matches the blacklist.
-		bool isBlackListed(const std::string &fileName);
-
-		class IndexableLocation 
-		{
-			public:
-				IndexableLocation();
-				IndexableLocation(const IndexableLocation &other);
-				~IndexableLocation();
-
-				IndexableLocation &operator=(const IndexableLocation &other);
-				bool operator<(const IndexableLocation &other) const;
-				bool operator==(const IndexableLocation &other) const;
-
-				bool m_monitor;
-				Glib::ustring m_name;
-				bool m_isSource;
-
-		};
-
-		class CacheProvider
-		{
-			public:
-				CacheProvider();
-				CacheProvider(const CacheProvider &other);
-				~CacheProvider();
-
-				CacheProvider &operator=(const CacheProvider &other);
-				bool operator<(const CacheProvider &other) const;
-				bool operator==(const CacheProvider &other) const;
-
-				Glib::ustring m_name;
-				Glib::ustring m_location;
-				std::set<Glib::ustring> m_protocols;
-		};
-
-		Glib::ustring m_version;
-		bool m_warnAboutVersion;
-		Glib::ustring m_defaultBackend;
-		Glib::ustring m_googleAPIKey;
-		Glib::ustring m_docsIndexLocation;
-		Glib::ustring m_daemonIndexLocation;
-		double m_minimumDiskSpace;
-		int m_xPos;
-		int m_yPos;
-		int m_width;
-		int m_height;
-		int m_panePos;
-		bool m_showEngines;
-		bool m_expandQueries;
-		bool m_ignoreRobotsDirectives;
-		bool m_suggestQueryTerms;
-		unsigned short m_newResultsColourRed;
-		unsigned short m_newResultsColourGreen;
-		unsigned short m_newResultsColourBlue;
-		Glib::ustring m_proxyAddress;
-		unsigned int m_proxyPort;
-		Glib::ustring  m_proxyType;
-		bool m_proxyEnabled;
-		std::set<std::string> m_labels;
-		std::set<IndexableLocation> m_indexableLocations;
-		std::set<Glib::ustring> m_filePatternsList;
-		bool m_isBlackList;
-		std::map<std::string, std::string> m_editablePluginValues;
-		std::vector<CacheProvider> m_cacheProviders;
-		std::set<Glib::ustring> m_cacheProtocols;
-
-	protected:
-		static PinotSettings m_instance;
-		static bool m_clientMode;
-		bool m_firstRun;
-		std::set<IndexProperties> m_indexes;
-		unsigned int m_indexCount;
-		std::set<ModuleProperties> m_engines;
-		std::map<unsigned int, std::string> m_engineIds;
-		std::map<std::string, bool> m_engineChannels;
-		std::map<std::string, QueryProperties> m_queries;
-
-		PinotSettings();
-		bool loadSearchEngines(const std::string &directoryName);
-		bool loadConfiguration(const std::string &fileName, bool isGlobal);
-		bool loadUi(const xmlpp::Element *pElem);
-		bool loadIndexes(const xmlpp::Element *pElem);
-		bool loadEngineChannels(const xmlpp::Element *pElem);
-		bool loadQueries(const xmlpp::Element *pElem);
-		bool loadLabels(const xmlpp::Element *pElem);
-		bool loadColour(const xmlpp::Element *pElem);
-		bool loadProxy(const xmlpp::Element *pElem);
-		bool loadIndexableLocations(const xmlpp::Element *pElem);
-		bool loadFilePatterns(const xmlpp::Element *pElem);
-		bool loadPluginParameters(const xmlpp::Element *pElem);
-		bool loadCacheProviders(const xmlpp::Element *pElem);
-
-	private:
-		PinotSettings(const PinotSettings &other);
-		PinotSettings &operator=(const PinotSettings &other);
-
-};
-
-#endif // _PINOTSETTINGS_HH

Deleted: trunk/UI/GTK2/src/PinotUtils.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/PinotUtils.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,272 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <iostream>
-#include <gtkmm/stock.h>
-
-#include "config.h"
-#include "NLS.h"
-#include "Url.h"
-#include "PinotSettings.h"
-#include "PinotUtils.h"
-
-using namespace std;
-using namespace Glib;
-using namespace Gtk;
-
-/// Open a FileChooserDialog.
-bool select_file_name(const ustring &title, ustring &location,
-	bool openOrCreate, bool directoriesOnly)
-{
-	FileChooserDialog fileChooser(title);
-
-	if (title.empty() == true)
-	{
-		return false;
-	}
-
-	prepare_file_chooser(fileChooser, location, openOrCreate, directoriesOnly);
-	fileChooser.show();
-
-	int result = fileChooser.run();
-	if (result == RESPONSE_OK)
-	{
-		// Retrieve the chosen location
-		if (directoriesOnly == false)
-		{
-			location = filename_to_utf8(fileChooser.get_filename());
-		}
-		else
-		{
-			location = filename_to_utf8(fileChooser.get_current_folder());
-		}
-
-		return true;
-	}
-
-	return false;
-}
-
-bool prepare_file_chooser(FileChooserDialog &fileChooser, ustring &location,
-	bool openOrCreate, bool directoriesOnly)
-{
-	FileChooserAction chooserAction = FILE_CHOOSER_ACTION_OPEN;
-	StockID okButtonStockId = Stock::OPEN;
-	bool isDirectory = false;
-
-	if (openOrCreate == false)
-	{
-		okButtonStockId = Stock::SAVE;
-		fileChooser.set_do_overwrite_confirmation(true);
-	}
-
-	// Have we been provided with an initial location ?
-	if (location.empty() == true)
-	{
-		// No, get the location of the home directory then
-		location = PinotSettings::getInstance().getHomeDirectory();
-		isDirectory = true;
-	}
-
-	if (directoriesOnly == false)
-	{
-		if (openOrCreate == true)
-		{
-			chooserAction = FILE_CHOOSER_ACTION_OPEN;
-		}
-		else
-		{
-			chooserAction = FILE_CHOOSER_ACTION_SAVE;
-		}
-	}
-	else
-	{
-		if (openOrCreate == true)
-		{
-			chooserAction = FILE_CHOOSER_ACTION_SELECT_FOLDER;
-		}
-		else
-		{
-			chooserAction = FILE_CHOOSER_ACTION_CREATE_FOLDER;
-		}
-		isDirectory = true;
-	}
-
-	fileChooser.set_action(chooserAction);
-	Url urlObj(location);
-	fileChooser.set_current_folder(filename_from_utf8(urlObj.getLocation()));
-	if (isDirectory == false)
-	{
-		fileChooser.set_current_name(filename_from_utf8(urlObj.getFile()));
-	}
-	fileChooser.set_local_only();
-	fileChooser.set_select_multiple(false);
-	fileChooser.add_button(Stock::CANCEL, RESPONSE_CANCEL);
-	fileChooser.add_button(okButtonStockId, RESPONSE_OK);
-	fileChooser.set_show_hidden(true);
-
-	return true;
-}
-
-/// Get a column height.
-int get_column_height(TreeView *pTree)
-{
-	int height = 0;
-
-	if (pTree == NULL)
-	{
-		return 0;
-	}
-
-	TreeViewColumn *pColumn = pTree->get_column(1);
-	if (pColumn != NULL)
-	{
-		Gdk::Rectangle cellArea;
-		int xOffset, yOffset, cellWidth, cellHeight;
-
-		pColumn->cell_get_size(cellArea, xOffset, yOffset, cellWidth, cellHeight);
-		height += cellHeight;
-#ifdef DEBUG
-		cout << "get_column_height: cell " << cellHeight << " " << yOffset << endl;
-#endif
-	}
-#ifdef DEBUG
-	cout << "get_column_height: " << height << endl;
-#endif
-
-	return height;
-}
-
-/// Create a text column.
-TreeViewColumn *create_column(const ustring &title, const TreeModelColumnBase& modelColumn,
-	bool isResizable, bool isSortable, const TreeModelColumnBase &sortColumn)
-{
-	TreeViewColumn *pColumn = new TreeViewColumn(title);
-
-	CellRendererText *pTextRenderer = new CellRendererText();
-	pColumn->pack_start(*manage(pTextRenderer));
-	pColumn->add_attribute(pTextRenderer->property_text(), modelColumn);
-	pColumn->set_resizable(isResizable);
-	if (isSortable == true)
-	{
-		pColumn->set_sort_column(sortColumn);
-	}
-
-	return pColumn;
-}
-
-/// Create an icon and text column, rendered by renderTextAndIconCell.
-TreeViewColumn *create_column_with_icon(const ustring &title, const TreeModelColumnBase& modelColumn,
-	const TreeViewColumn::SlotCellData &renderTextAndIconCell,
-	bool isResizable, bool isSortable, const TreeModelColumnBase &sortColumn)
-{
-	TreeViewColumn *pColumn = new TreeViewColumn(title);
-
-	// Pack an icon renderer in the column
-	CellRendererPixbuf *pIconRenderer = new CellRendererPixbuf();
-	pColumn->pack_start(*manage(pIconRenderer), false);
-	pColumn->set_cell_data_func(*pIconRenderer, renderTextAndIconCell);
-	// ...followed by a text renderer
-	CellRendererText *pTextRenderer = new CellRendererText();
-	pColumn->pack_start(*manage(pTextRenderer));
-	pColumn->set_cell_data_func(*pTextRenderer, renderTextAndIconCell);
-
-	pColumn->add_attribute(pTextRenderer->property_text(), modelColumn);
-	pColumn->set_resizable(isResizable);
-	if (isSortable == true)
-	{
-		pColumn->set_sort_column(sortColumn);
-	}
-
-	return pColumn;
-}
-
-/// Converts to UTF-8.
-ustring to_utf8(const string &text)
-{
-	std::string charset;
-
-	// Get the locale charset
-	get_charset(charset);
-	// Call overload
-	return to_utf8(text, charset);
-}
-
-/// Converts from the given charset to UTF-8.
-ustring to_utf8(const string &text, const string &charset)
-{
-	if ((charset == "UTF-8") ||
-		(charset == "utf-8"))
-	{
-		// No conversion necessary
-		return text;
-	}
-
-	try
-	{
-		if (charset.empty() == false)
-		{
-			return convert_with_fallback(text, "UTF-8", charset, " ");
-		}
-		else
-		{
-			return locale_to_utf8(text);
-		}
-	}
-	catch (Error &ce)
-	{
-#ifdef DEBUG
-		cout << "to_utf8: cannot convert from " << charset << ": " << ce.what() << endl;
-#endif
-		if (charset.empty() == false)
-		{
-			return to_utf8(text);
-		}
-	}
-	catch (...)
-	{
-#ifdef DEBUG
-		cout << "to_utf8: unknown exception" << endl;
-#endif
-	}
-
-	return "";
-}
-
-/// Converts from UTF-8.
-string from_utf8(const ustring &text)
-{
-	try
-	{
-		return locale_from_utf8(text);
-	}
-	catch (Error &ce)
-	{
-#ifdef DEBUG
-		cout << "from_utf8: " << ce.what() << endl;
-#endif
-	}
-	catch (...)
-	{
-#ifdef DEBUG
-		cout << "from_utf8: unknown exception" << endl;
-#endif
-	}
-
-	return "";
-}

Deleted: trunk/UI/GTK2/src/PinotUtils.h
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/PinotUtils.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,62 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
- 
-#ifndef _PINOTUTILS_HH
-#define _PINOTUTILS_HH
-
-#include <string>
-#include <gtkmmconfig.h>
-#include <glibmm/ustring.h>
-#include <gtkmm/window.h>
-#include <gtkmm/filechooserdialog.h>
-#include <gtkmm/treeview.h>
-#include <gtkmm/treemodel.h>
-#include <gtkmm/filechooserdialog.h>
-
-/// Open a FileChooserDialog.
-bool select_file_name(const Glib::ustring &title, Glib::ustring &location,
-	bool openOrCreate, bool directoriesOnly = false);
-
-/// Prepare a FileChooserDialog.
-bool prepare_file_chooser(Gtk::FileChooserDialog &fileChooser, Glib::ustring &location,
-	bool openOrCreate, bool directoriesOnly = false);
-
-/// Get a column height.
-int get_column_height(Gtk::TreeView *pTree);
-
-/// Create a text column.
-Gtk::TreeViewColumn *create_column(const Glib::ustring &title,
-	const Gtk::TreeModelColumnBase& modelColumn,
-	bool isResizable, bool isSortable, const Gtk::TreeModelColumnBase &sortColumn);
-
-/// Create an icon and text column, rendered by renderTextAndIconCell.
-Gtk::TreeViewColumn *create_column_with_icon(const Glib::ustring &title,
-	const Gtk::TreeModelColumnBase& modelColumn,
-	const Gtk::TreeViewColumn::SlotCellData &renderTextAndIconCell,
-	bool isResizable, bool isSortable, const Gtk::TreeModelColumnBase &sortColumn);
-
-/// Converts to UTF-8.
-Glib::ustring to_utf8(const std::string &text);
-
-/// Converts from the given charset to UTF-8.
-Glib::ustring to_utf8(const std::string &text, const std::string &charset);
-
-/// Converts from UTF-8.
-std::string from_utf8(const Glib::ustring &text);
-
-#endif // _PINOTUTILS_HH

Deleted: trunk/UI/GTK2/src/ServerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/ServerThreads.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/ServerThreads.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,1489 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <sys/types.h>
-#include <dirent.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <fcntl.h>
-#include <string.h>
-#include <strings.h>
-#include <signal.h>
-#include <errno.h>
-#include <exception>
-#include <iostream>
-#include <fstream>
-#include <sstream>
-#include <glibmm/miscutils.h>
-#include <glibmm/convert.h>
-
-#include "config.h"
-#include "NLS.h"
-#include "MIMEScanner.h"
-#include "TimeConverter.h"
-#include "Timer.h"
-#include "Url.h"
-#include "CrawlHistory.h"
-#include "MetaDataBackup.h"
-#ifdef HAVE_DBUS
-#include "DBusIndex.h"
-#endif
-#include "ModuleFactory.h"
-#include "DaemonState.h"
-#include "PinotSettings.h"
-#include "ServerThreads.h"
-
-using namespace Glib;
-using namespace std;
-
-static void updateLabels(unsigned int docId, MetaDataBackup &metaData,
-	IndexInterface *pIndex, set<string> &labels, gboolean resetLabels)
-{
-	DocumentInfo docInfo;
-
-	if (pIndex == NULL)
-	{
-		return;
-	}
-
-	// If it's a reset, remove labels from the metadata backup
-	if ((resetLabels == TRUE) &&
-		(pIndex->getDocumentInfo(docId, docInfo) == true))
-	{
-		metaData.deleteItem(docInfo, DocumentInfo::SERIAL_LABELS);
-	}
-
-	// Get the current labels 
-	if (resetLabels == TRUE)
-	{
-		labels.clear();
-		pIndex->getDocumentLabels(docId, labels);
-	}
-	docInfo.setLabels(labels);
-	metaData.addItem(docInfo, DocumentInfo::SERIAL_LABELS);
-}
-
-static ustring g_xmlDescription;
-
-static bool loadXMLDescription(void)
-{
-	bool readFile = false;
-
-	if (g_xmlDescription.empty() == false)
-	{
-		return true;
-	}
-
-	ifstream xmlFile;
-	string xmlFileName(PREFIX);
-
-	xmlFileName += "/share/pinot/pinot-dbus-daemon.xml";
-	xmlFile.open(xmlFileName.c_str());
-	if (xmlFile.good() == true)
-	{
-		xmlFile.seekg(0, ios::end);
-		int length = xmlFile.tellg();
-		xmlFile.seekg(0, ios::beg);
-
-		char *pXmlBuffer = new char[length + 1];
-		xmlFile.read(pXmlBuffer, length);
-		if (xmlFile.fail() == false)
-		{
-			pXmlBuffer[length] = '\0';
-			g_xmlDescription = pXmlBuffer;
-			readFile = true;
-		}
-		delete[] pXmlBuffer;
-	}
-	xmlFile.close();
-
-	if (readFile == false)
-	{
-		cerr << "File " << xmlFileName << " couldn't be read" << endl;
-	}
-	return readFile;
-}
-
-DirectoryScannerThread::DirectoryScannerThread(const string &dirName, bool isSource,
-	bool fullScan, bool isReindex,
-	MonitorInterface *pMonitor, MonitorHandler *pHandler,
-	unsigned int maxLevel, bool inlineIndexing, bool followSymLinks) :
-	IndexingThread(),
-	m_dirName(dirName),
-	m_fullScan(fullScan),
-	m_isReindex(isReindex),
-	m_pMonitor(pMonitor),
-	m_pHandler(pHandler),
-	m_sourceId(0),
-	m_currentLevel(0),
-	m_maxLevel(maxLevel),
-	m_inlineIndexing(inlineIndexing),
-	m_followSymLinks(followSymLinks)
-{
-	if (m_dirName.empty() == false)
-	{
-		CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-
-		if (isSource == true)
-		{
-			// Does this source exist ?
-			if (crawlHistory.hasSource("file://" + m_dirName, m_sourceId) == false)
-			{
-				// Create it
-				m_sourceId = crawlHistory.insertSource("file://" + m_dirName);
-			}
-		}
-		else
-		{
-			map<unsigned int, string> fileSources;
-
-			// What source does this belong to ?
-			for(map<unsigned int, string>::const_iterator sourceIter = fileSources.begin();
-				sourceIter != fileSources.end(); ++sourceIter)
-			{
-				if (sourceIter->second.length() < m_dirName.length())
-				{
-					// Skip
-					continue;
-				}
-
-				if (sourceIter->second.substr(0, m_dirName.length()) == m_dirName)
-				{
-					// That's the one
-					m_sourceId = sourceIter->first;
-					break;
-				}
-			}
-		}
-	}
-}
-
-DirectoryScannerThread::~DirectoryScannerThread()
-{
-}
-
-string DirectoryScannerThread::getType(void) const
-{
-	return "DirectoryScannerThread";
-}
-
-string DirectoryScannerThread::getDirectory(void) const
-{
-	return m_dirName;
-}
-
-void DirectoryScannerThread::stop(void)
-{
-	// Disconnect the signal
-	sigc::signal2<void, DocumentInfo, bool>::slot_list_type slotsList = m_signalFileFound.slots();
-	sigc::signal2<void, DocumentInfo, bool>::slot_list_type::iterator slotIter = slotsList.begin();
-	if (slotIter != slotsList.end())
-	{
-		if (slotIter->empty() == false)
-		{
-			slotIter->block();
-			slotIter->disconnect();
-		}
-	}
-	WorkerThread::stop();
-}
-
-sigc::signal2<void, DocumentInfo, bool>& DirectoryScannerThread::getFileFoundSignal(void)
-{
-	return m_signalFileFound;
-}
-
-void DirectoryScannerThread::cacheUpdate(const string &location, time_t mTime,
-	CrawlHistory &crawlHistory)
-{
-	m_updateCache[location] = mTime;
-
-	if (m_updateCache.size() > 500)
-	{
-		flushUpdates(crawlHistory);
-	}
-}
-
-void DirectoryScannerThread::flushUpdates(CrawlHistory &crawlHistory)
-{
-#ifdef DEBUG
-	cout << "DirectoryScannerThread::flushUpdates: flushing updates" << endl;
-#endif
-
-	// Update these records
-	crawlHistory.updateItems(m_updateCache, CrawlHistory::CRAWLED);
-	m_updateCache.clear();
-
-#ifdef DEBUG
-	cout << "DirectoryScannerThread::flushUpdates: flushed updates" << endl;
-#endif
-}
-
-void DirectoryScannerThread::foundFile(const DocumentInfo &docInfo)
-{
-	if ((docInfo.getLocation().empty() == true) ||
-		(m_done == true))
-	{
-		return;
-	}
-
-	if (m_inlineIndexing == true)
-	{
-		// Reset base class members
-		m_docInfo = docInfo;
-		m_docId = 0;
-		m_indexLocation = PinotSettings::getInstance().m_daemonIndexLocation;
-		m_update = false;
-
-		IndexingThread::doWork();
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::foundFile: indexed " << docInfo.getLocation() << " to " << m_docId << endl;
-#endif
-	}
-	else
-	{
-		// Delegate indexing
-		m_signalFileFound(docInfo, false);
-	}
-}
-
-bool DirectoryScannerThread::isIndexable(const string &entryName) const
-{
-	string entryDir(path_get_dirname(entryName) + "/");
-
-	// Is this under one of the locations configured for indexing ?
-	for (set<PinotSettings::IndexableLocation>::const_iterator locationIter = PinotSettings::getInstance().m_indexableLocations.begin();
-		locationIter != PinotSettings::getInstance().m_indexableLocations.end(); ++locationIter)
-	{
-		string locationDir(locationIter->m_name + "/");
-
-		if ((entryDir.length() >= locationDir.length()) &&
-			(entryDir.substr(0, locationDir.length()) == locationDir))
-		{
-			// Yes, it is
-#ifdef DEBUG
-			cout << "DirectoryScannerThread::isIndexable: under " << locationDir << endl;
-#endif
-			return true;
-		}
-	}
-
-	return false;
-}
-
-bool DirectoryScannerThread::scanEntry(const string &entryName, CrawlHistory &crawlHistory,
-	bool statLinks)
-{
-	string location("file://" + entryName);
-	DocumentInfo docInfo("", location, "", "");
-	CrawlHistory::CrawlStatus itemStatus = CrawlHistory::UNKNOWN;
-	time_t itemDate = time(NULL);
-	struct stat fileStat;
-	int entryStatus = 0;
-	bool scanSuccess = true, reportFile = false, itemExists = false;
-
-	if (entryName.empty() == true)
-	{
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::scanEntry: no name" << endl;
-#endif
-		return false;
-	}
-
-	// Skip . .. and dotfiles
-	Url urlObj(location);
-	if (urlObj.getFile()[0] == '.')
-	{
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::scanEntry: skipped dotfile " << urlObj.getFile() << endl;
-#endif
-		return false;
-	}
-#ifdef DEBUG
-	cout << "DirectoryScannerThread::scanEntry: checking " << entryName << endl;
-#endif
-
-	// Stat links, or the stuff it refers to ?
-	if (statLinks == true)
-	{
-		entryStatus = lstat(entryName.c_str(), &fileStat);
-	}
-	else
-	{
-		entryStatus = stat(entryName.c_str(), &fileStat);
-	}
-
-	if (entryStatus == -1)
-	{
-		entryStatus = errno;
-		scanSuccess = false;
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::scanEntry: stat failed with error " << entryStatus << endl;
-#endif
-	}
-	// Special processing applies if it's a symlink
-	else if (S_ISLNK(fileStat.st_mode))
-	{
-		string realEntryName(entryName);
-		string entryNameReferree;
-		bool isInIndexableLocation = false;
-
-		if (m_followSymLinks == false)
-		{
-#ifdef DEBUG
-			cout << "DirectoryScannerThread::scanEntry: skipped symlink " << entryName << endl;
-#endif
-			return false;
-		}
-
-		// Are we already following a symlink to a directory ?
-		if (m_currentLinks.empty() == false)
-		{
-			string linkToDir(m_currentLinks.top() + "/");
-
-			// Yes, we are
-			if ((entryName.length() > linkToDir.length()) &&
-				(entryName.substr(0, linkToDir.length()) == linkToDir))
-			{
-				// ...and this entry is below it
-				realEntryName.replace(0, linkToDir.length() - 1, m_currentLinkReferrees.top());
-#ifdef DEBUG
-				cout << "DirectoryScannerThread::scanEntry: really at " << realEntryName << endl;
-#endif
-				isInIndexableLocation = isIndexable(realEntryName);
-			}
-		}
-
-		char *pBuf = g_file_read_link(realEntryName.c_str(), NULL);
-		if (pBuf != NULL)
-		{
-			string linkLocation(filename_to_utf8(pBuf));
-			if (path_is_absolute(linkLocation) == true)
-			{
-				entryNameReferree = linkLocation;
-			}
-			else
-			{
-				string entryDir(path_get_dirname(realEntryName));
-				string::size_type prevSlashPos = 0, slashPos = linkLocation.find('/');
-
-				while (slashPos != string::npos)
-				{
-					string path(linkLocation.substr(prevSlashPos, slashPos - prevSlashPos));
-
-					if (path == "..")
-					{
-						string upDir(path_get_dirname(entryDir));
-						entryDir = upDir;
-					}
-					else if (path != ".")
-					{
-						entryDir += "/";
-						entryDir += path;
-					}
-#ifdef DEBUG
-					cout << "DirectoryScannerThread::scanEntry: symlink partially resolved to " << entryDir << endl;
-#endif
-
-					if (slashPos + 1 >= linkLocation.length())
-					{
-						// Nothing behind
-						prevSlashPos = string::npos;
-						break;
-					}
-
-					// Next
-					prevSlashPos = slashPos + 1;
-					slashPos = linkLocation.find('/', prevSlashPos);
-				}
-
-				// Remainder
-				if (prevSlashPos != string::npos)
-				{
-					string path(linkLocation.substr(prevSlashPos));
-
-					if (path == "..")
-					{
-						string upDir(path_get_dirname(entryDir));
-						entryDir = upDir;
-					}
-					else if (path != ".")
-					{
-						entryDir += "/";
-						entryDir += path;
-					}
-				}
-
-				entryNameReferree = entryDir;
-			}
-
-			if (entryNameReferree[entryNameReferree.length() - 1] == '/')
-			{
-				// Drop the terminating slash
-				entryNameReferree.resize(entryNameReferree.length() - 1);
-			}
-#ifdef DEBUG
-			cout << "DirectoryScannerThread::scanEntry: symlink resolved to " << entryNameReferree << endl;
-#endif
-
-			g_free(pBuf);
-		}
-
-		string referreeLocation("file://" + entryNameReferree);
-		CrawlHistory::CrawlStatus referreeItemStatus = CrawlHistory::UNKNOWN;
-		time_t referreeItemDate;
-
-		// Check whether this will be, or has already been crawled
-		// Referrees in indexable locations will be indexed later on
-		if ((isInIndexableLocation == false) &&
-			(isIndexable(entryNameReferree) == false) &&
-			(crawlHistory.hasItem(referreeLocation, referreeItemStatus, referreeItemDate) == false))
-		{
-			m_currentLinks.push(entryName);
-			m_currentLinkReferrees.push(entryNameReferree);
-
-			// Add a dummy entry for this referree
-			// It will ensure it's not indexed more than once and it shouldn't do any harm
-			crawlHistory.insertItem(referreeLocation, CrawlHistory::CRAWL_LINK, m_sourceId, itemDate);
-
-			// Do it again, this time by stat'ing what the link refers to
-			bool scannedReferree = scanEntry(entryName, crawlHistory, false);
-
-			m_currentLinks.pop();
-			m_currentLinkReferrees.pop();
-
-			return scannedReferree;
-		}
-		else
-		{
-			cout << "Skipping " << entryName << ": it links to " << entryNameReferree
-				<< " which will be crawled, or has already been crawled" << endl;
-
-			// This should ensure that only metadata is indexed
-			docInfo.setType("inode/symlink");
-			reportFile = true;
-		}
-	}
-
-	// Is this item in the database already ?
-	itemExists = crawlHistory.hasItem(location, itemStatus, itemDate);
-	if (itemExists == false)
-	{
-		// Record it
-		crawlHistory.insertItem(location, CrawlHistory::CRAWLING, m_sourceId, itemDate);
-	}
-	else if (m_fullScan == true)
-	{
-		// Change the status from TO_CRAWL to CRAWLING
-		crawlHistory.updateItem(location, CrawlHistory::CRAWLING, itemDate);
-	}
-
-	// If stat'ing didn't fail, see if it's a file or a directory
-	if ((entryStatus == 0) &&
-		(S_ISREG(fileStat.st_mode)))
-	{
-		// Is this file blacklisted ?
-		// We have to check early so that if necessary the file's status stays at TO_CRAWL
-		// and it is removed from the index at the end of this crawl
-		if (PinotSettings::getInstance().isBlackListed(entryName) == false)
-		{
-			reportFile = true;
-		}
-	}
-	else if ((entryStatus == 0) &&
-		(S_ISDIR(fileStat.st_mode)))
-	{
-		docInfo.setType("x-directory/normal");
-
-		// Can we scan this directory ?
-		if (((m_maxLevel == 0) ||
-			(m_currentLevel < m_maxLevel)) &&
-			(PinotSettings::getInstance().isBlackListed(entryName) == false))
-		{
-			++m_currentLevel;
-
-			// Open the directory
-			DIR *pDir = opendir(entryName.c_str());
-			if (pDir != NULL)
-			{
-#ifdef DEBUG
-				cout << "DirectoryScannerThread::scanEntry: entering " << entryName << endl;
-#endif
-				if (m_pMonitor != NULL)
-				{
-					// Monitor first so that we don't miss events
-					// If monitoring is not possible, record the first case
-					if ((m_pMonitor->addLocation(entryName, true) == false) &&
-						(entryStatus != MONITORING_FAILED))
-					{
-						entryStatus = MONITORING_FAILED;
-					}
-				}
-
-				// Iterate through this directory's entries
-				struct dirent *pDirEntry = readdir(pDir);
-				while ((m_done == false) &&
-					(pDirEntry != NULL))
-				{
-					char *pEntryName = pDirEntry->d_name;
-
-					// Skip . .. and dotfiles
-					if ((pEntryName != NULL) &&
-						(pEntryName[0] != '.'))
-					{
-						string subEntryName(entryName);
-
-						if (entryName[entryName.length() - 1] != '/')
-						{
-							subEntryName += "/";
-						}
-						subEntryName += pEntryName;
-
-						// Scan this entry
-						scanEntry(subEntryName, crawlHistory);
-					}
-
-					// Next entry
-					pDirEntry = readdir(pDir);
-				}
-#ifdef DEBUG
-				cout << "DirectoryScannerThread::scanEntry: leaving " << entryName << endl;
-#endif
-
-				// Close the directory
-				closedir(pDir);
-				--m_currentLevel;
-				reportFile = true;
-			}
-			else
-			{
-				entryStatus = errno;
-				scanSuccess = false;
-#ifdef DEBUG
-				cout << "DirectoryScannerThread::scanEntry: opendir failed with error " << entryStatus << endl;
-#endif
-			}
-		}
-	}
-	// Is it some unknown type ?
-	else if ((entryStatus == 0) &&
-		(!S_ISLNK(fileStat.st_mode)))
-	{
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::scanEntry: unknown entry type" << endl;
-#endif
-		entryStatus = ENOENT;
-		scanSuccess = false;
-	}
-
-	// Was it modified after the last crawl ?
-	if ((itemExists == true) &&
-		(itemDate >= fileStat.st_mtime))
-	{
-		// No, it wasn't
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::scanEntry: not reporting " << location
-			<< ", status " << itemStatus << endl;
-#endif
-		reportFile = false;
-	}
-
-	if (m_done == true)
-	{
-		// Don't record or report the file
-		reportFile = false;
-	}
-	// Did an error occur ?
-	else if (entryStatus != 0)
-	{
-		time_t timeNow = time(NULL);
-
-		// Record this error
-		crawlHistory.updateItem(location, CrawlHistory::CRAWL_ERROR, timeNow, entryStatus);
-
-		if (scanSuccess == false)
-		{
-			return scanSuccess;
-		}
-	}
-	// History of new or modified files, especially their timestamp, is always updated
-	// Others' are updated only if we are doing a full scan because
-	// the status has to be reset to CRAWLED, so that they are not unindexed
-	else if ((itemExists == false) ||
-		(reportFile == true) ||
-		(m_fullScan == true))
-	{
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::scanEntry: updating " << entryName << endl;
-#endif
-		cacheUpdate(location, fileStat.st_mtime, crawlHistory);
-	}
-
-	// If a major error occured, this won't be true
-	if (reportFile == true)
-	{
-		set<string> labels;
-		stringstream labelStream;
-
-		if (docInfo.getType().empty() == true)
-		{
-			// Scan the file
-			docInfo.setType(MIMEScanner::scanFile(entryName));
-		}
-		docInfo.setTimestamp(TimeConverter::toTimestamp(fileStat.st_mtime));
-		docInfo.setSize(fileStat.st_size);
-
-		// Insert a label that identifies the source
-		labelStream << "X-SOURCE" << m_sourceId;
-		labels.insert(labelStream.str());
-		docInfo.setLabels(labels);
-
-		foundFile(docInfo);
-	}
-
-	return scanSuccess;
-}
-
-void DirectoryScannerThread::doWork(void)
-{
-	CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-	MetaDataBackup metaData(PinotSettings::getInstance().getHistoryDatabaseName());
-	Timer scanTimer;
-	set<string> urls;
-	unsigned int currentOffset = 0;
-
-	if (m_dirName.empty() == true)
-	{
-		return;
-	}
-	scanTimer.start();
-
-	// Remove errors and links
-	crawlHistory.deleteItems(m_sourceId, CrawlHistory::CRAWL_ERROR);
-	crawlHistory.deleteItems(m_sourceId, CrawlHistory::CRAWL_LINK);
-	// ...and entries the previous instance didn't have time to crawl
-	crawlHistory.deleteItems(m_sourceId, CrawlHistory::CRAWLING);
-
-	if (m_fullScan == true)
-	{
-		cout << "Doing a full scan on " << m_dirName << endl;
-
-		// Update this source's items status so that we can detect files that have been deleted
-		crawlHistory.updateItemsStatus(CrawlHistory::TO_CRAWL, m_sourceId);
-	}
-
-	if (scanEntry(m_dirName, crawlHistory) == false)
-	{
-		m_errorNum = OPENDIR_FAILED;
-		m_errorParam = m_dirName;
-	}
-	flushUpdates(crawlHistory);
-	cout << "Scanned " << m_dirName << " in " << scanTimer.stop() << " ms" << endl;
-
-	if (m_done == true)
-	{
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::doWork: leaving cleanup until next crawl" << endl;
-#endif
-		return;
-	}
-
-	if (m_fullScan == true)
-	{
-		scanTimer.start();
-
-		// All files left with status TO_CRAWL were not found in this crawl
-		// Chances are they were removed after the last full scan
-		while ((m_pHandler != NULL) &&
-			(crawlHistory.getSourceItems(m_sourceId, CrawlHistory::TO_CRAWL, urls,
-				currentOffset, currentOffset + 100) > 0))
-		{
-			for (set<string>::const_iterator urlIter = urls.begin();
-				urlIter != urls.end(); ++urlIter)
-			{
-				// Inform the MonitorHandler
-				m_pHandler->fileDeleted(urlIter->substr(7));
-
-				// Delete this item
-				crawlHistory.deleteItem(*urlIter);
-				metaData.deleteItem(DocumentInfo("", *urlIter, "", ""), DocumentInfo::SERIAL_ALL);
-			}
-
-			// Next
-			if (urls.size() < 100)
-			{
-				break;
-			}
-			currentOffset += 100;
-		}
-		cout << "Cleaned up " << currentOffset + urls.size()
-			<< " history entries in " << scanTimer.stop() << " ms" << endl;
-	}
-
-	if (m_isReindex == true)
-	{
-		urls.clear();
-		currentOffset = 0;
-		scanTimer.start();
-
-		IndexInterface *pIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
-		// Restore user-set metadata, if any
-		while ((pIndex != NULL) &&
-			(pIndex->isGood() == true) &&
-			(metaData.getItems(string("file://") + m_dirName, urls,
-				currentOffset, currentOffset + 100) == true))
-		{
-			for (set<string>::const_iterator urlIter = urls.begin();
-				urlIter != urls.end(); ++urlIter)
-			{
-				unsigned int docId = pIndex->hasDocument(*urlIter);
-				if (docId == 0)
-				{
-					continue;
-				}
-
-				DocumentInfo docInfo("", *urlIter, "", "");
-				if (metaData.getItem(docInfo, DocumentInfo::SERIAL_ALL) == true)
-				{
-					pIndex->updateDocumentInfo(docId, docInfo);
-					pIndex->setDocumentLabels(docId, docInfo.getLabels(), true);
-				}
-			}
-
-			// Next
-			if (urls.size() < 100)
-			{
-				break;
-			}
-			currentOffset += 100;
-		}
-		cout << "Restored user-set metadata for " << currentOffset + urls.size()
-			<< " documents in " << scanTimer.stop() << " ms" << endl;
-	}
-}
-
-#ifdef HAVE_DBUS
-DBusServletThread::DBusServletThread(DaemonState *pServer, DBusServletInfo *pInfo) :
-	WorkerThread(),
-	m_pServer(pServer),
-	m_pServletInfo(pInfo),
-	m_mustQuit(false)
-{
-}
-
-DBusServletThread::~DBusServletThread()
-{
-}
-
-string DBusServletThread::getType(void) const
-{
-	return "DBusServletThread";
-}
-
-DBusServletInfo *DBusServletThread::getServletInfo(void) const
-{
-	return m_pServletInfo;
-}
-
-bool DBusServletThread::mustQuit(void) const
-{
-	return m_mustQuit;
-}
-
-void DBusServletThread::doWork(void)
-{
-	PinotSettings &settings = PinotSettings::getInstance();
-	IndexInterface *pIndex = settings.getIndex(settings.m_daemonIndexLocation);
-	MetaDataBackup metaData(settings.getHistoryDatabaseName());
-	DBusError error;
-	bool processedMessage = true, updateLabelsCache = false, flushIndex = false;
-
-	if ((m_pServer == NULL) ||
-		(m_pServletInfo == NULL) ||
-		(pIndex == NULL))
-	{
-		return;
-	}
-
-	dbus_error_init(&error);
-
-	// Access the settings' labels list directly
-	set<string> &labelsCache = settings.m_labels;
-	if (labelsCache.empty() == true)
-	{
-		pIndex->getLabels(labelsCache);
-	}
-
-#ifdef DEBUG
-	const char *pSender = dbus_message_get_sender(m_pServletInfo->m_pRequest);
-	if (pSender != NULL)
-	{
-		cout << "DBusServletThread::doWork: called by " << pSender << endl;
-	}
-	else
-	{
-		cout << "DBusServletThread::doWork: called by unknown sender" << endl;
-	}
-#endif
-
-	if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "GetStatistics") == TRUE)
-	{
-		CrawlHistory crawlHistory(settings.getHistoryDatabaseName());
-		unsigned int crawledFilesCount = crawlHistory.getItemsCount(CrawlHistory::CRAWLED);
-		unsigned int docsCount = pIndex->getDocumentsCount();
-		gboolean lowDiskSpace = FALSE, onBattery = FALSE, crawling = FALSE;
-
-#ifdef DEBUG
-		cout << "DBusServletThread::doWork: received GetStatistics" << endl;
-#endif
-		// Prepare the reply
-		if (m_pServletInfo->newReply() == true)
-		{
-			if (m_pServer->is_flag_set(DaemonState::LOW_DISK_SPACE) == true)
-			{
-				lowDiskSpace = TRUE;
-			}
-			if (m_pServer->is_flag_set(DaemonState::ON_BATTERY) == true)
-			{
-				onBattery = TRUE;
-			}
-			if (m_pServer->is_flag_set(DaemonState::CRAWLING) == true)
-			{
-				crawling = TRUE;
-			}
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: replying with " << crawledFilesCount
-				<< " " << docsCount << " " << lowDiskSpace << onBattery << crawling << endl;
-#endif
-
-			dbus_message_append_args(m_pServletInfo->m_pReply,
-				DBUS_TYPE_UINT32, &crawledFilesCount,
-				DBUS_TYPE_UINT32, &docsCount,
-				DBUS_TYPE_BOOLEAN, &lowDiskSpace,
-				DBUS_TYPE_BOOLEAN, &onBattery,
-				DBUS_TYPE_BOOLEAN, &crawling,
-				DBUS_TYPE_INVALID);
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "Reload") == TRUE)
-	{
-		if (dbus_message_get_args(m_pServletInfo->m_pRequest, &error,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			gboolean reloading = TRUE;
-
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received Reload" << endl;
-#endif
-			m_pServer->reload();
-
-			// Prepare the reply
-			if (m_pServletInfo->newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo->m_pReply,
-					DBUS_TYPE_BOOLEAN, &reloading,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "Stop") == TRUE)
-	{
-		if (dbus_message_get_args(m_pServletInfo->m_pRequest, &error,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			int exitStatus = EXIT_SUCCESS;
-
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received Stop" << endl;
-#endif
-			m_pServer->set_flag(DaemonState::STOPPED);
-
-			// Prepare the reply
-			if (m_pServletInfo->newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo->m_pReply,
-					DBUS_TYPE_INT32, &exitStatus,
-					DBUS_TYPE_INVALID);
-			}
-
-			m_mustQuit = true;
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "HasDocument") == TRUE)
-	{
-		char *pUrl = NULL;
-		unsigned int docId = 0;
-
-		if (dbus_message_get_args(m_pServletInfo->m_pRequest, &error,
-			DBUS_TYPE_STRING, &pUrl,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received HasDocument " << pUrl << endl;
-#endif
-			if (pUrl != NULL)
-			{
-				string url(pUrl);
-
-				// Check the index
-				docId = pIndex->hasDocument(url);
-			}
-
-			// Prepare the reply
-			if (m_pServletInfo->newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo->m_pReply,
-					DBUS_TYPE_UINT32, &docId,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "GetLabels") == TRUE)
-	{
-#ifdef DEBUG
-		cout << "DBusServletThread::doWork: received GetLabels" << endl;
-#endif
-		// This method doesn't take any argument
-		m_pServletInfo->m_pArray = g_ptr_array_new();
-
-		for (set<string>::const_iterator labelIter = labelsCache.begin();
-			labelIter != labelsCache.end(); ++labelIter)
-		{
-			string labelName(*labelIter);
-
-			g_ptr_array_add(m_pServletInfo->m_pArray, const_cast<char*>(labelName.c_str()));
-		}
-
-		// Prepare the reply
-		m_pServletInfo->newReplyWithArray();
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "AddLabel") == TRUE)
-	{
-		char *pLabel = NULL;
-
-		if (dbus_message_get_args(m_pServletInfo->m_pRequest, &error,
-			DBUS_TYPE_STRING, &pLabel,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received AddLabel " << pLabel << endl;
-#endif
-			if (pLabel != NULL)
-			{
-				string labelName(pLabel);
-
-				// Add the label
-				flushIndex = pIndex->addLabel(labelName);
-				// Is this a known label ?
-				if (labelsCache.find(labelName) == labelsCache.end())
-				{
-					// No, it isn't but that's okay
-					labelsCache.insert(labelName);
-					updateLabelsCache = true;
-				}
-			}
-
-			// Prepare the reply
-			if (m_pServletInfo->newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo->m_pReply,
-					DBUS_TYPE_STRING, &pLabel,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "RenameLabel") == TRUE)
-	{
-		char *pOldLabel = NULL;
-		char *pNewLabel = NULL;
-
-		if (dbus_message_get_args(m_pServletInfo->m_pRequest, &error,
-			DBUS_TYPE_STRING, &pOldLabel,
-			DBUS_TYPE_STRING, &pNewLabel,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			// Nothing to do, this was obsoleted
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received RenameLabel " << pOldLabel << ", " << pNewLabel << endl;
-#endif
-			
-			// Prepare the reply
-			if (m_pServletInfo->newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo->m_pReply,
-					DBUS_TYPE_STRING, &pNewLabel,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "DeleteLabel") == TRUE)
-	{
-		char *pLabel = NULL;
-
-		if (dbus_message_get_args(m_pServletInfo->m_pRequest, &error,
-			DBUS_TYPE_STRING, &pLabel,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received DeleteLabel " << pLabel << endl;
-#endif
-			if (pLabel != NULL)
-			{
-				// Delete the label
-				flushIndex = pIndex->deleteLabel(pLabel);
-				// Update the labels list
-				set<string>::const_iterator labelIter = labelsCache.find(pLabel);
-				if (labelIter != labelsCache.end())
-				{
-					labelsCache.erase(labelIter);
-					updateLabelsCache = true;
-				}
-
-				// Update the metadata backup
-				metaData.deleteLabel(pLabel);
-			}
-
-			// Prepare the reply
-			if (m_pServletInfo->newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo->m_pReply,
-					DBUS_TYPE_STRING, &pLabel,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "GetDocumentLabels") == TRUE)
-	{
-		unsigned int docId = 0;
-
-		if (dbus_message_get_args(m_pServletInfo->m_pRequest, &error,
-			DBUS_TYPE_UINT32, &docId,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			set<string> labels;
-
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received GetDocumentLabels " << docId << endl;
-#endif
-			if (pIndex->getDocumentLabels(docId, labels) == true)
-			{
-				m_pServletInfo->m_pArray = g_ptr_array_new();
-
-				for (set<string>::const_iterator labelIter = labels.begin();
-					labelIter != labels.end(); ++labelIter)
-				{
-					string labelName(*labelIter);
-
-					g_ptr_array_add(m_pServletInfo->m_pArray, const_cast<char*>(labelName.c_str()));
-				}
-
-				// Prepare the reply
-				m_pServletInfo->newReplyWithArray();
-			}
-			else
-			{
-				m_pServletInfo->newErrorReply("de.berlios.Pinot.GetDocumentLabels",
-					" failed");
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "SetDocumentLabels") == TRUE)
-	{
-		char **ppLabels = NULL;
-		dbus_uint32_t labelsCount = 0;
-		unsigned int docId = 0;
-		gboolean resetLabels = TRUE;
-
-		if (dbus_message_get_args(m_pServletInfo->m_pRequest, &error,
-			DBUS_TYPE_UINT32, &docId,
-			DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &ppLabels, &labelsCount,
-			DBUS_TYPE_BOOLEAN, &resetLabels,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			set<string> labels;
-
-			for (dbus_uint32_t labelIndex = 0; labelIndex < labelsCount; ++labelIndex)
-			{
-				if (ppLabels[labelIndex] == NULL)
-				{
-					break;
-				}
-
-				string labelName(ppLabels[labelIndex]);
-				labels.insert(labelName);
-				// Is this a known label ?
-				if (labelsCache.find(labelName) == labelsCache.end())
-				{
-					// No, it isn't but that's okay
-					labelsCache.insert(labelName);
-					updateLabelsCache = true;
-				}
-			}
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received SetDocumentLabels on ID " << docId
-				<< ", " << labelsCount << " labels" << ", " << resetLabels << endl;
-#endif
-
-			// Set labels
-			flushIndex = pIndex->setDocumentLabels(docId, labels, ((resetLabels == TRUE) ? true : false));
-
-			// Update the metadata backup
-			updateLabels(docId, metaData, pIndex, labels, resetLabels);
-
-			// Free container types
-			g_strfreev(ppLabels);
-
-			// Prepare the reply
-			if (m_pServletInfo->newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo->m_pReply,
-					DBUS_TYPE_UINT32, &docId,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "SetDocumentsLabels") == TRUE)
-	{
-		char **ppDocIds = NULL;
-		char **ppLabels = NULL;
-		dbus_uint32_t idsCount = 0;
-		dbus_uint32_t labelsCount = 0;
-		gboolean resetLabels = TRUE;
-
-		if (dbus_message_get_args(m_pServletInfo->m_pRequest, &error,
-			DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &ppDocIds, &idsCount,
-			DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &ppLabels, &labelsCount,
-			DBUS_TYPE_BOOLEAN, &resetLabels,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			set<unsigned int> docIds;
-			set<string> labels;
-
-			for (dbus_uint32_t idIndex = 0; idIndex < idsCount; ++idIndex)
-			{
-				if (ppDocIds[idIndex] == NULL)
-				{
-					break;
-				}
-
-				docIds.insert((unsigned int)atoi(ppDocIds[idIndex]));
-			}
-			for (dbus_uint32_t labelIndex = 0; labelIndex < labelsCount; ++labelIndex)
-			{
-				if (ppLabels[labelIndex] == NULL)
-				{
-					break;
-				}
-
-				string labelName(ppLabels[labelIndex]);
-				labels.insert(labelName);
-				// Is this a known label ?
-				if (labelsCache.find(labelName) == labelsCache.end())
-				{
-					// No, it isn't but that's okay
-					labelsCache.insert(labelName);
-					updateLabelsCache = true;
-				}
-			}
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received SetDocumentsLabels on " << docIds.size()
-				<< " IDs, " << labelsCount << " labels" << ", " << resetLabels << endl;
-#endif
-			// Set labels
-			if (pIndex->setDocumentsLabels(docIds, labels, ((resetLabels == TRUE) ? true : false)) == true)
-			{
-				resetLabels = TRUE;
-				flushIndex = true;
-			}
-
-			// Update the metadata backup
-			for (set<unsigned int>::const_iterator docIter = docIds.begin();
-				docIter != docIds.end(); ++docIter)
-			{
-				updateLabels(*docIter, metaData, pIndex, labels, resetLabels);
-			}
-
-			// Free container types
-			g_strfreev(ppDocIds);
-			g_strfreev(ppLabels);
-
-			// Prepare the reply
-			if (m_pServletInfo->newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo->m_pReply,
-					DBUS_TYPE_BOOLEAN, &resetLabels,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "GetDocumentInfo") == TRUE)
-	{
-		unsigned int docId = 0;
-
-		if (dbus_message_get_args(m_pServletInfo->m_pRequest, &error,
-			DBUS_TYPE_UINT32, &docId,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			DocumentInfo docInfo;
-
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received GetDocumentInfo on " << docId << endl;
-#endif
-			if (pIndex->getDocumentInfo(docId, docInfo) == true)
-			{
-				// Prepare the reply
-				if (m_pServletInfo->newReply() == true)
-				{
-					DBusMessageIter iter;
-
-					dbus_message_iter_init_append(m_pServletInfo->m_pReply, &iter);
-					if (DBusIndex::documentInfoToDBus(&iter, 0, docInfo) == false)
-					{
-						dbus_message_unref(m_pServletInfo->m_pReply);
-						m_pServletInfo->newErrorReply("de.berlios.Pinot.GetDocumentInfo",
-							"Unknown error");
-					}
-				}
-			}
-			else
-			{
-				m_pServletInfo->newErrorReply("de.berlios.Pinot.GetDocumentInfo",
-					"Unknown document");
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "SetDocumentInfo") == TRUE)
-	{
-		DBusMessageIter iter;
-		DocumentInfo docInfo;
-		unsigned int docId = 0;
-
-		dbus_message_iter_init(m_pServletInfo->m_pRequest, &iter);
-		if (DBusIndex::documentInfoFromDBus(&iter, docId, docInfo) == false)
-		{
-			m_pServletInfo->newErrorReply("de.berlios.Pinot.SetDocumentInfo",
-				"Unknown error");
-		}
-		else
-		{
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received SetDocumentInfo on " << docId << endl;
-#endif
-
-			// Update the document info
-			flushIndex = pIndex->updateDocumentInfo(docId, docInfo);
-
-			// Update the metadata backup
-			metaData.addItem(docInfo, DocumentInfo::SERIAL_FIELDS);
-
-			// Prepare the reply
-			if (m_pServletInfo->newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo->m_pReply,
-					DBUS_TYPE_UINT32, &docId,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "Query") == TRUE)
-	{
-		char *pSearchText = NULL;
-		char *pEngineType = NULL;
-		char *pEngineOption = NULL;
-		dbus_uint32_t startDoc = 0, maxHits = 0;
-
-		if (dbus_message_get_args(m_pServletInfo->m_pRequest, &error,
-			DBUS_TYPE_STRING, &pEngineType,
-			DBUS_TYPE_STRING, &pEngineOption,
-			DBUS_TYPE_STRING, &pSearchText,
-			DBUS_TYPE_UINT32, &startDoc,
-			DBUS_TYPE_UINT32, &maxHits,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			bool replyWithError = true;
-
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received Query " << pSearchText << ", " << startDoc << "/" << maxHits << endl;
-#endif
-			if (pSearchText != NULL)
-			{
-				stringstream queryNameStr;
-
-				// Give the query a unique name
-				queryNameStr << "DBUS" << m_id;
-				m_pServletInfo->m_simpleQuery = false;
-
-				QueryProperties queryProps(queryNameStr.str(), pSearchText);
-				queryProps.setMaximumResultsCount(maxHits);
-
-				string engineType, engineOption;
-
-				// Provide reasonable defaults 
-				if (((pEngineType == NULL) || (strlen(pEngineType) == 0)) &&
-					((pEngineOption == NULL) || (strlen(pEngineOption) == 0)))
-				{
-					engineType = settings.m_defaultBackend;
-					engineOption = settings.m_daemonIndexLocation;
-				}
-				else
-				{
-					engineType = pEngineType;
-					engineOption = pEngineOption;
-				}
-
-				m_pServletInfo->m_pThread = new EngineQueryThread(engineType,
-					engineType, engineOption, queryProps, startDoc);
-			}
-
-			if (replyWithError == true)
-			{
-				m_pServletInfo->newErrorReply("de.berlios.Pinot.SimpleQuery",
-					"Query failed");
-			}
-		}
-	}
-	// FIXME: this method will soon be obsoleted
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "SimpleQuery") == TRUE)
-	{
-		char *pSearchText = NULL;
-		dbus_uint32_t maxHits = 0;
-
-		if (dbus_message_get_args(m_pServletInfo->m_pRequest, &error,
-			DBUS_TYPE_STRING, &pSearchText,
-			DBUS_TYPE_UINT32, &maxHits,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			bool replyWithError = true;
-
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received SimpleQuery " << pSearchText << ", " << maxHits << endl;
-#endif
-			if (pSearchText != NULL)
-			{
-				stringstream queryNameStr;
-
-				// Give the query a unique name
-				queryNameStr << "DBUS" << m_id;
-				m_pServletInfo->m_simpleQuery = true;
-
-				QueryProperties queryProps(queryNameStr.str(), pSearchText);
-				queryProps.setMaximumResultsCount(maxHits);
-
-				m_pServletInfo->m_pThread = new EngineQueryThread(settings.m_defaultBackend,
-					settings.m_defaultBackend, settings.m_daemonIndexLocation,
-					queryProps, 0);
-			}
-
-			if (replyWithError == true)
-			{
-				m_pServletInfo->newErrorReply("de.berlios.Pinot.SimpleQuery",
-					"Query failed");
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "de.berlios.Pinot", "UpdateDocument") == TRUE)
-	{
-		unsigned int docId = 0;
-
-		if (dbus_message_get_args(m_pServletInfo->m_pRequest, &error,
-			DBUS_TYPE_UINT32, &docId,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			DocumentInfo docInfo;
-
-#ifdef DEBUG
-			cout << "DBusServletThread::doWork: received UpdateDocument " << docId << endl;
-#endif
-			if (pIndex->getDocumentInfo(docId, docInfo) == true)
-			{
-				// Update document
-				m_pServer->queue_index(docInfo);
-			}
-
-			// Prepare the reply
-			if (m_pServletInfo->newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo->m_pReply,
-					DBUS_TYPE_UINT32, &docId,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo->m_pRequest, "org.freedesktop.DBus.Introspectable", "Introspect") == TRUE)
-	{
-#ifdef DEBUG
-		cout << "DBusServletThread::doWork: received Introspect" << endl;
-#endif
-		if (loadXMLDescription() == true)
-		{
-			// Prepare the reply
-			if (m_pServletInfo->newReply() == true)
-			{
-				const char *pXmlData = g_xmlDescription.c_str();
-
-				dbus_message_append_args(m_pServletInfo->m_pReply,
-					DBUS_TYPE_STRING, &pXmlData,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else
-	{
-#ifdef DEBUG
-		cout << "DBusServletThread::doWork: foreign message for/from " << dbus_message_get_interface(m_pServletInfo->m_pRequest)
-			<< " " << dbus_message_get_member(m_pServletInfo->m_pRequest) << endl;
-#endif
-		processedMessage = false;
-	}
-
-	// Did an error occur ?
-	if (error.message != NULL)
-	{
-#ifdef DEBUG
-		cout << "DBusServletThread::doWork: error occured: " << error.message << endl;
-#endif
-		// Use the error message as reply
-		m_pServletInfo->newErrorReply(error.name, error.message);
-	}
-
-	dbus_error_free(&error);
-
-	// Set labels ?
-	if ((updateLabelsCache == true) &&
-		(pIndex->setLabels(labelsCache, false) == false))
-	{
-		// Updating failed... reset the cache
-		labelsCache.clear();
-		pIndex->getLabels(labelsCache);
-#ifdef DEBUG
-		cout << "DBusServletThread::doWork: failed to update labels" << endl;
-#endif
-	}
-
-	// Flush the index ?
-	if (flushIndex == true)
-	{
-		// Flush now for the sake of the client application
-		pIndex->flush();
-	}
-
-	delete pIndex;
-}
-#endif
-

Deleted: trunk/UI/GTK2/src/ServerThreads.h
===================================================================
--- trunk/UI/GTK2/src/ServerThreads.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/ServerThreads.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,111 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _SERVERTHREADS_HH
-#define _SERVERTHREADS_HH
-
-#include <string>
-#include <vector>
-#include <stack>
-#include <sigc++/sigc++.h>
-#include <glibmm/ustring.h>
-
-#include "DocumentInfo.h"
-#include "CrawlHistory.h"
-#include "MonitorInterface.h"
-#include "MonitorHandler.h"
-#include "QueryProperties.h"
-#include "DaemonState.h"
-#include "WorkerThreads.h"
-
-class DirectoryScannerThread : public IndexingThread
-{
-	public:
-		DirectoryScannerThread(const std::string &dirName, bool isSource,
-			bool fullScan, bool isReindex,
-			MonitorInterface *pMonitor, MonitorHandler *pHandler,
-			unsigned int maxLevel = 0, bool inlineIndexing = false,
-			bool followSymLinks = true);
-		virtual ~DirectoryScannerThread();
-
-		virtual std::string getType(void) const;
-
-		virtual std::string getDirectory(void) const;
-
-		virtual void stop(void);
-
-		sigc::signal2<void, DocumentInfo, bool>& getFileFoundSignal(void);
-
-	protected:
-		std::string m_dirName;
-		bool m_fullScan;
-		bool m_isReindex;
-		MonitorInterface *m_pMonitor;
-		MonitorHandler *m_pHandler;
-		unsigned int m_sourceId;
-		unsigned int m_currentLevel;
-		unsigned int m_maxLevel;
-		bool m_inlineIndexing;
-		bool m_followSymLinks;
-		sigc::signal2<void, DocumentInfo, bool> m_signalFileFound;
-		std::map<std::string, time_t> m_updateCache;
-		std::stack<std::string> m_currentLinks;
-		std::stack<std::string> m_currentLinkReferrees;
-
-		void cacheUpdate(const std::string &location, time_t mTime, CrawlHistory &crawlHistory);
-		void flushUpdates(CrawlHistory &crawlHistory);
-		void foundFile(const DocumentInfo &docInfo);
-		bool isIndexable(const std::string &entryName) const;
-		bool scanEntry(const std::string &entryName, CrawlHistory &crawlHistory,
-			bool statLinks = true);
-		virtual void doWork(void);
-
-	private:
-		DirectoryScannerThread(const DirectoryScannerThread &other);
-		DirectoryScannerThread &operator=(const DirectoryScannerThread &other);
-
-};
-
-#ifdef HAVE_DBUS
-class DBusServletThread : public WorkerThread
-{
-	public:
-		DBusServletThread(DaemonState *pServer, DBusServletInfo *pInfo);
-		virtual ~DBusServletThread();
-
-		virtual std::string getType(void) const;
-
-		DBusServletInfo *getServletInfo(void) const;
-
-		bool mustQuit(void) const;
-
-	protected:
-		DaemonState *m_pServer;
-		DBusServletInfo *m_pServletInfo;
-		bool m_mustQuit;
-
-		virtual void doWork(void);
-
-	private:
-		DBusServletThread(const DBusServletThread &other);
-		DBusServletThread &operator=(const DBusServletThread &other);
-
-};
-#endif
-
-#endif // _SERVERTHREADS_HH

Deleted: trunk/UI/GTK2/src/UniqueApplication.cpp
===================================================================
--- trunk/UI/GTK2/src/UniqueApplication.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/UniqueApplication.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,177 +0,0 @@
-/*
- *  Copyright 2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <sys/types.h>
-#include <signal.h>
-#include <unistd.h>
-#include <errno.h>
-#include <iostream>
-#include <fstream>
-#include <sstream>
-
-#include "UniqueApplication.h"
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-using std::fstream;
-using std::stringstream;
-
-UniqueApplication::UniqueApplication(const string &name)
-{
-#ifdef HAVE_UNIQUE
-	m_pApp = unique_app_new(name.c_str(), NULL);
-#ifdef DEBUG
-	if (m_pApp != NULL)
-	{
-		cout << "UniqueApplication: registered" << endl;
-	}
-	else
-	{
-		cout << "UniqueApplication: failed to register" << endl;
-	}
-#endif
-#endif
-}
-
-UniqueApplication::~UniqueApplication()
-{
-#ifdef HAVE_UNIQUE
-	if (m_pApp != NULL)
-	{
-		g_object_unref(m_pApp);
-	}
-#endif
-}
-
-bool UniqueApplication::isRunning(void)
-{
-#ifdef HAVE_UNIQUE
-	if ((m_pApp != NULL) &&
-		(unique_app_is_running(m_pApp) == TRUE))
-	{
-		return true;
-	}
-#endif
-
-	return false;
-}
-
-bool UniqueApplication::isRunning(const string &pidFileName, const string &processName)
-{
-	fstream pidFile;
-
-	// Open the PID file
-	pidFile.open(pidFileName.c_str(), std::ios::in);
-	if (pidFile.is_open() == false)
-	{
-		// The application may still be running even though the PID file doesn't exist
-		if (isRunning() == true)
-		{
-			return true;
-		}
-		// Keep going
-	}
-	else
-	{
-		pid_t processID = 0;
-		bool stillRunning = false, processDied = false;
-
-		pidFile >> processID;
-		pidFile.close();
-
-		// Is another process running ?
-		if (processID > 0)
-		{
-#ifdef HAVE_UNIQUE
-			if (m_pApp != NULL)
-			{
-				if (unique_app_is_running(m_pApp) == TRUE)
-				{
-					// It's still running
-					stillRunning = true;
-				}
-				else
-				{
-					// It most likely died
-					processDied = true;
-				}
-			}
-#else
-			fstream cmdLineFile;
-			stringstream cmdLineFileName;
-			bool checkProcess = true;
-
-			// FIXME: check for existence of /proc
-			cmdLineFileName << "/proc/" << processID << "/cmdline";
-			cmdLineFile.open(cmdLineFileName.str().c_str(), std::ios::in);
-			if (cmdLineFile.is_open() == true)
-			{
-				string cmdLine;
-
-				cmdLineFile >> cmdLine;
-				cmdLineFile.close();
-
-				if (cmdLine.find(processName) == string::npos)
-				{
-					// It's another process
-					checkProcess = false;
-					processDied = true;
-				}
-			}
-
-			if (checkProcess == true)
-			{
-				if (kill(processID, 0) == 0)
-				{
-					// It's still running
-					stillRunning = true;
-				}
-				else if (errno == ESRCH)
-				{
-					// This PID doesn't exist
-					processDied = true;
-				}
-			}
-#endif
-
-			if (stillRunning == true)
-			{
-				cout << "Process " << processName << " (" << processID << ") is still running" << endl;
-				return true;
-			}
-
-			if (processDied == true)
-			{
-				cerr << "Previous instance " << processID << " died prematurely" << endl;
-			}
-		}
-	}
-
-	// Now save our PID
-	pidFile.open(pidFileName.c_str(), std::ios::out);
-	if (pidFile.is_open() == true)
-	{
-		pidFile << getpid() << endl;
-		pidFile.close();
-	}
-
-	return false;
-}
-

Deleted: trunk/UI/GTK2/src/UniqueApplication.h
===================================================================
--- trunk/UI/GTK2/src/UniqueApplication.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/UniqueApplication.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,49 +0,0 @@
-/*
- *  Copyright 2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _UNIQUEAPPLICATION_HH
-#define _UNIQUEAPPLICATION_HH
-
-#include <string>
-
-#ifdef HAVE_UNIQUE
-#include <unique/unique.h>
-#endif
-
-class UniqueApplication
-{
-	public:
-		UniqueApplication(const std::string &name);
-		~UniqueApplication();
-
-		bool isRunning(void);
-
-		bool isRunning(const std::string &pidFileName,
-			const std::string &processName);
-
-	private:
-#ifdef HAVE_UNIQUE
-		UniqueApp *m_pApp;
-#endif
-
-		UniqueApplication(const UniqueApplication &other);
-		UniqueApplication &operator=(const UniqueApplication &other);
-
-};
-
-#endif // _UNIQUEAPPLICATION_HH

Deleted: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,2260 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <fcntl.h>
-#include <string.h>
-#include <signal.h>
-#include <time.h>
-#include <errno.h>
-#include <exception>
-#include <iostream>
-#include <fstream>
-#include <glibmm/miscutils.h>
-#include <glibmm/exception.h>
-
-#include "config.h"
-#include "NLS.h"
-#include "Languages.h"
-#include "MIMEScanner.h"
-#include "StringManip.h"
-#include "TimeConverter.h"
-#include "Timer.h"
-#include "Url.h"
-#include "HtmlFilter.h"
-#include "FilterUtils.h"
-#include "ActionQueue.h"
-#include "CrawlHistory.h"
-#include "QueryHistory.h"
-#include "DownloaderFactory.h"
-#include "FilterWrapper.h"
-#include "ModuleFactory.h"
-#include "WebEngine.h"
-#include "PinotSettings.h"
-#include "WorkerThreads.h"
-
-using namespace Glib;
-using namespace std;
-
-// A function object to stop threads with for_each()
-struct StopThreadFunc
-{
-public:
-	void operator()(map<unsigned int, WorkerThread *>::value_type &p)
-	{
-		p.second->stop();
-#ifdef DEBUG
-		cout << "StopThreadFunc: stopped thread " << p.second->getId() << endl;
-#endif
-		Thread::yield();
-	}
-};
-
-Dispatcher WorkerThread::m_dispatcher;
-pthread_mutex_t WorkerThread::m_dispatcherMutex = PTHREAD_MUTEX_INITIALIZER;
-bool WorkerThread::m_immediateFlush = true;
-
-string WorkerThread::errorToString(int errorNum)
-{
-	if (errorNum == 0)
-	{
-		return "";
-	}
-
-	if (errorNum < INDEX_ERROR)
-	{
-		return strerror(errorNum);
-	}
-
-	// Internal error codes
-	switch (errorNum)
-	{
-		case INDEX_ERROR:
-			return _("Index error");
-		case INDEXING_FAILED:
-			return _("Couldn't index document");
-		case UPDATE_FAILED:
-			return _("Couldn't update document");
-		case UNINDEXING_FAILED:
-			return _("Couldn't unindex document(s)");
-		case QUERY_FAILED:
-			return _("Couldn't run query on search engine");
-		case HISTORY_FAILED:
-			return _("Couldn't get history for search engine");
-		case DOWNLOAD_FAILED:
-			return _("Couldn't retrieve document");
-		case MONITORING_FAILED:
-			return _("File monitor error");
-		case OPENDIR_FAILED:
-			return _("Couldn't open directory");
-		case UNKNOWN_INDEX:
-			return _("Index doesn't exist");
-		case UNKNOWN_ENGINE:
-			return  _("Couldn't create search engine");
-		case UNSUPPORTED_TYPE:
-			return _("Cannot index document type");
-		case UNSUPPORTED_PROTOCOL:
-			return _("No downloader for this protocol");
-		case ROBOTS_FORBIDDEN:
-			return _("Robots META tag forbids indexing");
-		case NO_MONITORING:
-			return _("No monitoring handler");
-		default:
-			break;
-	}
-
-	return _("Unknown error");
-}
-
-Dispatcher &WorkerThread::getDispatcher(void)
-{
-	return m_dispatcher;
-}
-
-void WorkerThread::immediateFlush(bool doFlush)
-{
-	m_immediateFlush = doFlush;
-}
-
-WorkerThread::WorkerThread() :
-	m_startTime(time(NULL)),
-	m_id(ThreadsManager::get_next_id()),
-	m_background(false),
-	m_stopped(false),
-	m_done(false),
-	m_errorNum(0)
-{
-}
-
-WorkerThread::~WorkerThread()
-{
-}
-
-time_t WorkerThread::getStartTime(void) const
-{
-	return m_startTime;
-}
-
-void WorkerThread::setId(unsigned int id)
-{
-	m_id = id;
-}
-
-unsigned int WorkerThread::getId(void) const
-{
-	return m_id;
-}
-
-void WorkerThread::inBackground(void)
-{
-	m_background = true;
-}
-
-bool WorkerThread::isBackground(void) const
-{
-	return m_background;
-}
-
-bool WorkerThread::operator<(const WorkerThread &other) const
-{
-	return m_id < other.m_id;
-}
-
-Glib::Thread *WorkerThread::start(void)
-{
-#ifdef DEBUG
-	cout << "WorkerThread::start: " << getType() << " " << m_id << endl;
-#endif
-	// Create non-joinable threads
-	return Thread::create(sigc::mem_fun(*this, &WorkerThread::threadHandler), false);
-}
-
-void WorkerThread::stop(void)
-{
-	m_stopped = m_done = true;
-}
-
-bool WorkerThread::isStopped(void) const
-{
-	return m_stopped;
-}
-
-bool WorkerThread::isDone(void) const
-{
-	return m_done;
-}
-
-int WorkerThread::getErrorNum(void) const
-{
-	return m_errorNum;
-}
-
-string WorkerThread::getStatus(void) const
-{
-	string status(errorToString(m_errorNum));
-
-	if ((status.empty() == false) &&
-		(m_errorParam.empty() == false))
-	{
-		status += " (";
-		status += m_errorParam;
-		status += ")";
-	}
-
-	return status;
-}
-
-void WorkerThread::threadHandler(void)
-{
-#ifdef DEBUG
-	cout << "WorkerThread::threadHandler: thread " << m_id << endl;
-#endif
-	try
-	{
-		doWork();
-	}
-	catch (Glib::Exception &ex)
-	{
-		cerr << "Glib exception in thread " << m_id << ", type " << getType()
-			<< ":" << ex.what() << endl;
-		m_errorNum = UNKNOWN_ERROR;
-	}
-	catch (std::exception &ex)
-	{
-		cerr << "STL exception in thread " << m_id << ", type " << getType()
-			<< ":" << ex.what() << endl;
-		m_errorNum = UNKNOWN_ERROR;
-	}
-	catch (...)
-	{
-		cerr << "Unknown exception in thread " << m_id << ", type " << getType() << endl;
-		m_errorNum = UNKNOWN_ERROR;
-	}
-
-	emitSignal();
-}
-
-void WorkerThread::emitSignal(void)
-{
-	m_done = true;
-	if (pthread_mutex_lock(&m_dispatcherMutex) == 0)
-	{
-#ifdef DEBUG
-		cout << "WorkerThread::emitSignal: signaling end of thread " << m_id << endl;
-#endif
-		m_dispatcher();
-
-		pthread_mutex_unlock(&m_dispatcherMutex);
-	}
-}
-
-unsigned int ThreadsManager::m_nextThreadId = 1;
-
-ThreadsManager::ThreadsManager(const string &defaultIndexLocation,
-	unsigned int maxIndexThreads, unsigned int maxThreadsTime) :
-	m_defaultIndexLocation(defaultIndexLocation),
-	m_maxIndexThreads(maxIndexThreads),
-	m_backgroundThreadsCount(0),
-	m_foregroundThreadsMaxTime(maxThreadsTime),
-	m_numCPUs(1),
-	m_stopIndexing(false)
-{
-	pthread_rwlock_init(&m_threadsLock, NULL);
-	pthread_rwlock_init(&m_listsLock, NULL);
-
-#ifdef HAVE_SYSCONF
-	m_numCPUs = sysconf(_SC_NPROCESSORS_ONLN);
-#endif
-}
-
-ThreadsManager::~ThreadsManager()
-{
-	stop_threads();
-	// Destroy the read/write locks
-	pthread_rwlock_destroy(&m_listsLock);
-	pthread_rwlock_destroy(&m_threadsLock);
-}
-
-bool ThreadsManager::read_lock_threads(void)
-{
-	if (pthread_rwlock_rdlock(&m_threadsLock) == 0)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-bool ThreadsManager::write_lock_threads(void)
-{
-	if (pthread_rwlock_wrlock(&m_threadsLock) == 0)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-void ThreadsManager::unlock_threads(void)
-{
-	pthread_rwlock_unlock(&m_threadsLock);
-}
-
-bool ThreadsManager::read_lock_lists(void)
-{
-	if (pthread_rwlock_rdlock(&m_listsLock) == 0)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-bool ThreadsManager::write_lock_lists(void)
-{
-	if (pthread_rwlock_wrlock(&m_listsLock) == 0)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-void ThreadsManager::unlock_lists(void)
-{
-	pthread_rwlock_unlock(&m_listsLock);
-}
-
-WorkerThread *ThreadsManager::get_thread(void)
-{
-	time_t timeNow = time(NULL);
-	WorkerThread *pWorkerThread = NULL;
-
-	// Get the first thread that's finished
-	if (write_lock_threads() == true)
-	{
-		for (map<unsigned int, WorkerThread *>::iterator threadIter = m_threads.begin();
-			threadIter != m_threads.end(); ++threadIter)
-		{
-			unsigned int threadId = threadIter->first;
-
-			if (threadIter->second->isDone() == false)
-			{
-#ifdef DEBUG
-				cout << "ThreadsManager::get_thread: thread "
-					<< threadId << " is not done" << endl;
-#endif
-
-				// Foreground threads ought not to run very long
-				if ((threadIter->second->isBackground() == false) &&
-					(threadIter->second->getStartTime() + m_foregroundThreadsMaxTime < timeNow))
-				{
-					// This thread has been running for too long !
-					threadIter->second->stop();
-
-					cerr << "Stopped long-running thread " << threadId << endl;
-				}
-			}
-			else
-			{
-				// This one will do...
-				pWorkerThread = threadIter->second;
-				// Remove it
-				m_threads.erase(threadIter);
-#ifdef DEBUG
-				cout << "ThreadsManager::get_thread: thread " << threadId
-					<< " is done, " << m_threads.size() << " left" << endl;
-#endif
-				break;
-			}
-		}
-
-		unlock_threads();
-	}
-
-	if (pWorkerThread == NULL)
-	{
-		return NULL;
-	}
-
-	if (pWorkerThread->isBackground() == true)
-	{
-#ifdef DEBUG
-		cout << "ThreadsManager::get_thread: thread " << pWorkerThread->getId()
-			<< " was running in the background" << endl;
-#endif
-		--m_backgroundThreadsCount;
-	}
-
-	return pWorkerThread;
-}
-
-ustring ThreadsManager::index_document(const DocumentInfo &docInfo)
-{
-	string location(docInfo.getLocation());
-
-	if (m_stopIndexing == true)
-	{
-#ifdef DEBUG
-		cout << "ThreadsManager::index_document: stopped indexing" << endl;
-#endif
-		return _("Indexing was stopped");
-	}
-
-	if (location.empty() == true)
-	{
-		// Nothing to do
-		return "";
-	}
-
-	// If the document is a mail message, we can't index it again
-	Url urlObj(location);
-	if (urlObj.getProtocol() == "mailbox")
-	{
-		return _("Can't index mail here");
-	}
-
-	// Is the document being indexed/updated ?
-	if (write_lock_lists() == true)
-	{
-		bool beingProcessed = true;
-
-		if (m_beingIndexed.find(location) == m_beingIndexed.end())
-		{
-			m_beingIndexed.insert(location);
-			beingProcessed = false;
-		}
-
-		unlock_lists();
-
-		if (beingProcessed == true)
-		{
-			// FIXME: we may have to set labels on this document
-			ustring status(location);
-			status += " ";
-			status += _("is already being indexed");
-			return status;
-		}
-	}
-
-	// Is the document blacklisted ?
-	if (PinotSettings::getInstance().isBlackListed(location) == true)
-	{
-		ustring status(location);
-		status += " ";
-		status += _("is blacklisted");
-		return status;
-	}
-
-	start_thread(new IndexingThread(docInfo, m_defaultIndexLocation));
-
-	return "";
-}
-
-void ThreadsManager::clear_queues(void)
-{
-	if (write_lock_lists() == true)
-	{
-		m_beingIndexed.clear();
-
-		unlock_lists();
-
-		ActionQueue actionQueue(PinotSettings::getInstance().getHistoryDatabaseName(), get_application_name());
-
-		actionQueue.expireItems(time(NULL));
-
-		m_backgroundThreadsCount = 0;
-	}
-}
-
-unsigned int ThreadsManager::get_next_id(void)
-{
-	unsigned int nextThreadId = ++m_nextThreadId;
-
-	return nextThreadId;
-}
-
-bool ThreadsManager::start_thread(WorkerThread *pWorkerThread, bool inBackground)
-{
-	bool createdThread = false;
-
-	if (pWorkerThread == NULL)
-	{
-		return false;
-	}
-
-	if (inBackground == true)
-	{
-#ifdef DEBUG
-		cout << "ThreadsManager::start_thread: thread " << pWorkerThread->getId()
-			<< " will run in the background" << endl;
-#endif
-		pWorkerThread->inBackground();
-		++m_backgroundThreadsCount;
-	}
-#ifdef DEBUG
-	else cout << "ThreadsManager::start_thread: thread " << pWorkerThread->getId()
-			<< " will run in the foreground" << endl;
-#endif
-
-	// Insert
-	pair<map<unsigned int, WorkerThread *>::iterator, bool> threadPair;
-	if (write_lock_threads() == true)
-	{
-		threadPair = m_threads.insert(pair<unsigned int, WorkerThread *>(pWorkerThread->getId(), pWorkerThread));
-		if (threadPair.second == false)
-		{
-			delete pWorkerThread;
-			pWorkerThread = NULL;
-		}
-
-		unlock_threads();
-	}
-
-	// Start the thread
-	if (pWorkerThread != NULL)
-	{
-		Thread *pThread = pWorkerThread->start();
-		if (pThread != NULL)
-		{
-			createdThread = true;
-		}
-		else
-		{
-			// Erase
-			if (write_lock_threads() == true)
-			{
-				m_threads.erase(threadPair.first);
-
-				unlock_threads();
-			}
-			delete pWorkerThread;
-		}
-	}
-
-	return createdThread;
-}
-
-unsigned int ThreadsManager::get_threads_count(void)
-{
-	int count = 0;
-
-	if (read_lock_threads() == true)
-	{
-		count = m_threads.size() - m_backgroundThreadsCount;
-
-		unlock_threads();
-	}
-#ifdef DEBUG
-	cout << "ThreadsManager::get_threads_count: " << count << "/"
-		<< m_backgroundThreadsCount << " threads left" << endl;
-#endif
-
-	// A negative count would mean that a background thread
-	// exited without signaling
-	return (unsigned int)max(count , 0);
-}
-
-void ThreadsManager::stop_threads(void)
-{
-	if (m_threads.empty() == false)
-	{
-		if (write_lock_threads() == true)
-		{
-			// Stop threads
-			for_each(m_threads.begin(), m_threads.end(), StopThreadFunc());
-
-			unlock_threads();
-		}
-	}
-}
-
-void ThreadsManager::connect(void)
-{
-	// The previous manager may have been signalled by our threads
-	WorkerThread *pThread = get_thread();
-	while (pThread != NULL)
-	{
-		m_onThreadEndSignal(pThread);
-
-		// Next
-		pThread = get_thread();
-	}
-#ifdef DEBUG
-	cout << "ThreadsManager::connect: connecting" << endl;
-#endif
-
-	// Connect the dispatcher
-	m_threadsEndConnection = WorkerThread::getDispatcher().connect(
-		sigc::mem_fun(*this, &ThreadsManager::on_thread_signal));
-#ifdef DEBUG
-	cout << "ThreadsManager::connect: connected" << endl;
-#endif
-}
-
-void ThreadsManager::disconnect(void)
-{
-	m_threadsEndConnection.block();
-	m_threadsEndConnection.disconnect();
-#ifdef DEBUG
-	cout << "ThreadsManager::disconnect: disconnected" << endl;
-#endif
-}
-
-void ThreadsManager::on_thread_signal()
-{
-	WorkerThread *pThread = get_thread();
-	if (pThread == NULL)
-	{
-#ifdef DEBUG
-		cout << "ThreadsManager::on_thread_signal: foreign thread" << endl;
-#endif
-		return;
-	}
-	m_onThreadEndSignal(pThread);
-}
-
-ustring ThreadsManager::queue_index(const DocumentInfo &docInfo)
-{
-	bool addToQueue = false;
-
-	if (get_threads_count() >= m_maxIndexThreads)
-	{
-#ifdef DEBUG
-		cout << "ThreadsManager::queue_index: too many threads" << endl;
-#endif
-		addToQueue = true;
-	}
-#ifdef HAVE_GETLOADAVG
-	// Get the load averaged over the last minute
-	else
-	{
-		double averageLoad[3];
-
-		if (getloadavg(averageLoad, 3) != -1)
-		{
-			// FIXME: is LOADAVG_1MIN Solaris specific ?
-			if (averageLoad[0] >= (double)m_numCPUs * 4)
-			{
-				// Don't add to the load, queue this
-				addToQueue = true;
-			}
-		}
-	}
-#endif
-
-	if (addToQueue == true)
-	{
-		ActionQueue actionQueue(PinotSettings::getInstance().getHistoryDatabaseName(), get_application_name());
-
-		actionQueue.pushItem(ActionQueue::INDEX, docInfo);
-
-		return "";
-	}
-
-	return index_document(docInfo);
-}
-
-bool ThreadsManager::pop_queue(const string &urlWasIndexed)
-{
-	bool getItem = true;
-	bool foundItem = false;
-
-#ifdef DEBUG
-	cout << "ThreadsManager::pop_queue: called" << endl;
-#endif
-	if (get_threads_count() >= m_maxIndexThreads)
-	{
-#ifdef DEBUG
-		cout << "ThreadsManager::pop_queue: too many threads" << endl;
-#endif
-		getItem = false;
-	}
-
-	if (write_lock_lists() == true)
-	{
-		// Update the in-progress list
-		if (urlWasIndexed.empty() == false)
-		{
-			set<string>::iterator urlIter = m_beingIndexed.find(urlWasIndexed);
-			if (urlIter != m_beingIndexed.end())
-			{
-				m_beingIndexed.erase(urlIter);
-			}
-		}
-
-		unlock_lists();
-
-		// Get an item ?
-		if (getItem == true)
-		{
-			ActionQueue actionQueue(PinotSettings::getInstance().getHistoryDatabaseName(), get_application_name());
-			ActionQueue::ActionType type;
-			DocumentInfo docInfo;
-			string previousLocation;
-
-			while (actionQueue.popItem(type, docInfo) == true)
-			{
-				ustring status;
-
-				if (type != ActionQueue::INDEX)
-				{
-					continue;
-				}
-
-				if (docInfo.getLocation() == previousLocation)
-				{
-					// Something dodgy is going on, we got the same item twice !
-					status = previousLocation;
-					status += " ";
-					status += _("is already being indexed");
-				}
-				else
-				{
-					status = index_document(docInfo);
-				}
-
-				if (status.empty() == true)
-				{
-					foundItem = true;
-					break;
-				}
-
-				previousLocation = docInfo.getLocation();
-			}
-		}
-	}
-
-	return foundItem;
-}
-
-ListerThread::ListerThread(const PinotSettings::IndexProperties &indexProps,
-	unsigned int startDoc) :
-	WorkerThread(),
-	m_indexProps(indexProps),
-	m_startDoc(startDoc),
-	m_documentsCount(0)
-{
-}
-
-ListerThread::~ListerThread()
-{
-}
-
-string ListerThread::getType(void) const
-{
-	return "ListerThread";
-}
-
-PinotSettings::IndexProperties ListerThread::getIndexProperties(void) const
-{
-	return m_indexProps;
-}
-
-unsigned int ListerThread::getStartDoc(void) const
-{
-	return m_startDoc;
-}
-
-const vector<DocumentInfo> &ListerThread::getDocuments(void) const
-{
-	return m_documentsList;
-}
-
-unsigned int ListerThread::getDocumentsCount(void) const
-{
-	return m_documentsCount;
-}
-
-IndexBrowserThread::IndexBrowserThread(const PinotSettings::IndexProperties &indexProps,
-	unsigned int maxDocsCount, unsigned int startDoc) :
-	ListerThread(indexProps, startDoc),
-	m_maxDocsCount(maxDocsCount)
-{
-}
-
-IndexBrowserThread::~IndexBrowserThread()
-{
-}
-
-void IndexBrowserThread::doWork(void)
-{
-	set<unsigned int> docIDList;
-	set<string> docLabels;
-	unsigned int numDocs = 0;
-
-	if (m_indexProps.m_location.empty() == true)
-	{
-		m_errorNum = UNKNOWN_INDEX;
-		m_errorParam = m_indexProps.m_name.c_str();
-		return;
-	}
-
-	// Get the index at that location
-	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexProps.m_location);
-	if ((pIndex == NULL) ||
-		(pIndex->isGood() == false))
-	{
-		m_errorNum = INDEX_ERROR;
-		m_errorParam = m_indexProps.m_location;
-		if (pIndex != NULL)
-		{
-			delete pIndex;
-		}
-		return;
-	}
-
-	m_documentsCount = pIndex->getDocumentsCount();
-	if (m_documentsCount == 0)
-	{
-#ifdef DEBUG
-		cout << "IndexBrowserThread::doWork: no documents" << endl;
-#endif
-		return;
-	}
-
-#ifdef DEBUG
-	cout << "IndexBrowserThread::doWork: " << m_maxDocsCount << " off " << m_documentsCount
-		<< " documents to browse, starting at position " << m_startDoc << endl;
-#endif
-	pIndex->listDocuments(docIDList, m_maxDocsCount, m_startDoc);
-
-	m_documentsList.clear();
-	m_documentsList.reserve(m_maxDocsCount);
-
-	for (set<unsigned int>::iterator iter = docIDList.begin(); iter != docIDList.end(); ++iter)
-	{
-		unsigned int docId = (*iter);
-
-		if (m_done == true)
-		{
-			break;
-		}
-
-		DocumentInfo docInfo;
-		if (pIndex->getDocumentInfo(docId, docInfo) == true)
-		{
-			string type(docInfo.getType());
-
-			if (type.empty() == true)
-			{
-				docInfo.setType("text/html");
-			}
-			docInfo.setIsIndexed(m_indexProps.m_id, docId);
-
-			// Insert that document
-			m_documentsList.push_back(docInfo);
-			++numDocs;
-		}
-#ifdef DEBUG
-		else cout << "IndexBrowserThread::doWork: couldn't retrieve document " << docId << endl;
-#endif
-	}
-	delete pIndex;
-}
-
-QueryingThread::QueryingThread(const PinotSettings::IndexProperties &indexProps,
-	const QueryProperties &queryProps, unsigned int startDoc, bool listingIndex) :
-	ListerThread(indexProps, startDoc),
-	m_engineName(PinotSettings::getInstance().m_defaultBackend),
-	m_engineDisplayableName(indexProps.m_name),
-	m_engineOption(indexProps.m_location),
-	m_queryProps(queryProps),
-	m_listingIndex(listingIndex),
-	m_correctedSpelling(false),
-	m_isLive(true)
-{
-#ifdef DEBUG
-	cout << "QueryingThread: engine " << m_engineName << ", " << m_engineOption
-		<< ", mode " << m_listingIndex << endl;
-#endif
-}
-
-QueryingThread::QueryingThread(const string &engineName, const string &engineDisplayableName,
-	const string &engineOption, const QueryProperties &queryProps,
-	unsigned int startDoc) :
-	ListerThread(PinotSettings::IndexProperties(engineDisplayableName, engineOption, 0, false), startDoc),
-	m_engineName(engineName),
-	m_engineDisplayableName(engineDisplayableName),
-	m_engineOption(engineOption),
-	m_queryProps(queryProps),
-	m_listingIndex(false),
-	m_correctedSpelling(false),
-	m_isLive(true)
-{
-#ifdef DEBUG
-	cout << "QueryingThread: engine " << m_engineName << ", " << m_engineOption
-		<< ", mode 0" << endl;
-#endif
-}
-
-QueryingThread::~QueryingThread()
-{
-}
-
-string QueryingThread::getType(void) const
-{
-	if (m_listingIndex == true)
-	{
-		return ListerThread::getType();
-	}
-
-	return "QueryingThread";
-}
-
-bool QueryingThread::isLive(void) const
-{
-	return m_isLive;
-}
-
-string QueryingThread::getEngineName(void) const
-{
-	return m_engineDisplayableName;
-}
-
-QueryProperties QueryingThread::getQuery(bool &wasCorrected) const
-{
-	wasCorrected = m_correctedSpelling;
-	return m_queryProps;
-}
-
-string QueryingThread::getCharset(void) const
-{
-	return m_resultsCharset;
-}
-
-bool QueryingThread::findPlugin(void)
-{
-	string pluginName;
-
-	if ((m_engineName.empty() == true) &&
-		(m_engineOption.empty() == false))
-	{
-		pluginName = m_engineOption;
-	}
-	else if ((m_engineName.empty() == false) &&
-		(m_engineOption.empty() == true))
-	{
-		pluginName = m_engineName;
-	}
-
-	if (pluginName.empty() == false)
-	{
-		set<ModuleProperties> engines;
-		PinotSettings::getInstance().getSearchEngines(engines, "");
-#ifdef DEBUG
-		cout << "QueryingThread::findPlugin: looking for a plugin named " << pluginName << endl;
-#endif
-
-		// Is there a plugin with such a name ?
-		ModuleProperties modProps("sherlock", pluginName, "", "");
-		set<ModuleProperties>::const_iterator engineIter = engines.find(modProps);
-		if (engineIter == engines.end())
-		{
-			// Try again
-			modProps.m_name = "opensearch";
-			engineIter = engines.find(modProps);
-		}
-
-		if (engineIter != engines.end())
-		{
-			// Yes, there is !
-			m_engineName = engineIter->m_name;
-			m_engineDisplayableName = engineIter->m_longName;
-			m_engineOption = engineIter->m_option;
-#ifdef DEBUG
-			cout << "QueryingThread::findPlugin: found " << m_engineName << ", " << m_engineDisplayableName << ", " << m_engineOption << endl;
-#endif
-
-			return true;
-		}
-	}
-
-	return false;
-}
-
-EngineQueryThread::EngineQueryThread(const PinotSettings::IndexProperties &indexProps,
-	const QueryProperties &queryProps, unsigned int startDoc, bool listingIndex) :
-	QueryingThread(indexProps, queryProps, startDoc, listingIndex)
-{
-}
-
-EngineQueryThread::EngineQueryThread(const PinotSettings::IndexProperties &indexProps,
-	const QueryProperties &queryProps, const set<string> &limitToDocsSet,
-	unsigned int startDoc) :
-	QueryingThread(indexProps, queryProps, startDoc, false)
-{
-	copy(limitToDocsSet.begin(), limitToDocsSet.end(),
-		inserter(m_limitToDocsSet, m_limitToDocsSet.begin()));
-}
-
-EngineQueryThread::EngineQueryThread(const string &engineName, const string &engineDisplayableName,
-	const string &engineOption, const QueryProperties &queryProps, unsigned int startDoc) :
-	QueryingThread(engineName, engineDisplayableName, engineOption, queryProps, startDoc)
-{
-}
-
-EngineQueryThread::~EngineQueryThread()
-{
-}
-
-void EngineQueryThread::processResults(const vector<DocumentInfo> &resultsList)
-{
-	PinotSettings &settings = PinotSettings::getInstance();
-	IndexInterface *pDocsIndex = NULL;
-	IndexInterface *pDaemonIndex = NULL;
-	unsigned int indexId = 0;
-	bool isIndexQuery = false;
-
-	// Are we querying an index ?
-	if (ModuleFactory::isSupported(m_engineName, true) == true)
-	{
-		// Internal index ?
-		if ((m_engineOption == settings.m_docsIndexLocation) ||
-			(m_engineOption == settings.m_daemonIndexLocation))
-		{
-			indexId = settings.getIndexPropertiesByLocation(m_engineOption).m_id;
-			isIndexQuery = true;
-		}
-	}
-
-	// Will we have to query internal indices ?
-	if (isIndexQuery == false)
-	{
-		pDocsIndex = settings.getIndex(settings.m_docsIndexLocation);
-		pDaemonIndex = settings.getIndex(settings.m_daemonIndexLocation);
-	}
-
-	// Copy the results list
-	for (vector<DocumentInfo>::const_iterator resultIter = resultsList.begin();
-		resultIter != resultsList.end(); ++resultIter)
-	{
-		DocumentInfo currentDoc(*resultIter);
-		string title(_("No title"));
-		string location(currentDoc.getLocation());
-		string language(currentDoc.getLanguage());
-		unsigned int docId = 0;
-
-		// The title may contain formatting
-		if (currentDoc.getTitle().empty() == false)
-		{
-			title = FilterUtils::stripMarkup(currentDoc.getTitle());
-		}
-		currentDoc.setTitle(title);
-#ifdef DEBUG
-		cout << "EngineQueryThread::processResults: title is " << title << endl;
-#endif
-
-		// Use the query's language if the result's is unknown
-		if (language.empty() == true)
-		{
-			language = m_queryProps.getStemmingLanguage();
-		}
-		currentDoc.setLanguage(language);
-
-		if (isIndexQuery == true)
-		{
-			unsigned int tmpId = 0;
-
-			// The index engine should have set this
-			docId = currentDoc.getIsIndexed(tmpId);
-		}
-
-		// Is this in one of the indexes ?
-		if ((pDocsIndex != NULL) &&
-			(pDocsIndex->isGood() == true))
-		{
-			docId = pDocsIndex->hasDocument(location);
-			if (docId > 0)
-			{
-				indexId = settings.getIndexPropertiesByName(_("My Web Pages")).m_id;
-			}
-		}
-		if ((pDaemonIndex != NULL) &&
-			(pDaemonIndex->isGood() == true) &&
-			(docId == 0))
-		{
-			docId = pDaemonIndex->hasDocument(location);
-			if (docId > 0)
-			{
-				indexId = settings.getIndexPropertiesByName(_("My Documents")).m_id;
-			}
-		}
-
-		if (docId > 0)
-		{
-			currentDoc.setIsIndexed(indexId, docId);
-#ifdef DEBUG
-			cout << "EngineQueryThread::processResults: found in index " << indexId << endl;
-#endif
-		}
-#ifdef DEBUG
-		else cout << "EngineQueryThread::processResults: not found in any index" << endl;
-#endif
-
-		m_documentsList.push_back(currentDoc);
-	}
-
-	if (pDocsIndex != NULL)
-	{
-		delete pDocsIndex;
-	}
-	if (pDaemonIndex != NULL)
-	{
-		delete pDaemonIndex;
-	}
-}
-
-void EngineQueryThread::processResults(const vector<DocumentInfo> &resultsList,
-	unsigned int indexId)
-{
-	unsigned int zeroId = 0;
-
-	// Copy the results list
-	for (vector<DocumentInfo>::const_iterator resultIter = resultsList.begin();
-		resultIter != resultsList.end(); ++resultIter)
-	{
-		DocumentInfo currentDoc(*resultIter);
-
-		// The engine has no notion of index IDs
-		unsigned int docId = currentDoc.getIsIndexed(zeroId);
-		currentDoc.setIsIndexed(indexId, docId);
-
-		m_documentsList.push_back(currentDoc);
-	}
-}
-
-void EngineQueryThread::doWork(void)
-{
-	PinotSettings &settings = PinotSettings::getInstance();
-
-	// Get the SearchEngine
-	SearchEngineInterface *pEngine = ModuleFactory::getSearchEngine(m_engineName, m_engineOption);
-	if (pEngine == NULL)
-	{
-		// Try again
-		if (findPlugin() == true)
-		{
-			pEngine = ModuleFactory::getSearchEngine(m_engineName, m_engineOption);
-		}
-
-		if (pEngine == NULL)
-		{
-			m_errorNum = UNKNOWN_ENGINE;
-			m_errorParam = m_engineDisplayableName;
-			return;
-		}
-	}
-
-	// Set up the proxy
-	WebEngine *pWebEngine = dynamic_cast<WebEngine *>(pEngine);
-	if (pWebEngine != NULL)
-	{
-		DownloaderInterface *pDownloader = pWebEngine->getDownloader();
-		if ((pDownloader != NULL) &&
-			(settings.m_proxyEnabled == true) &&
-			(settings.m_proxyAddress.empty() == false))
-		{
-			char portStr[64];
-
-			pDownloader->setSetting("proxyaddress", settings.m_proxyAddress);
-			snprintf(portStr, 64, "%u", settings.m_proxyPort);
-			pDownloader->setSetting("proxyport", portStr);
-			pDownloader->setSetting("proxytype", settings.m_proxyType);
-		}
-
-		pWebEngine->setEditableValues(settings.m_editablePluginValues);
-	}
-
-	if (m_listingIndex == false)
-	{
-		pEngine->setLimitSet(m_limitToDocsSet);
-	}
-
-	// Run the query
-	pEngine->setDefaultOperator(SearchEngineInterface::DEFAULT_OP_AND);
-	if (pEngine->runQuery(m_queryProps, m_startDoc) == false)
-	{
-		m_errorNum = QUERY_FAILED;
-		m_errorParam = m_engineDisplayableName;
-	}
-	else
-	{
-		const vector<DocumentInfo> &resultsList = pEngine->getResults();
-
-		m_documentsList.clear();
-		m_documentsList.reserve(resultsList.size());
-		m_documentsCount = pEngine->getResultsCountEstimate();
-#ifdef DEBUG
-		cout << "EngineQueryThread::doWork: " << resultsList.size() << " off " << m_documentsCount
-			<< " results to process, starting at position " << m_startDoc << endl;
-#endif
-
-		m_resultsCharset = pEngine->getResultsCharset();
-		if (m_listingIndex == false)
-		{
-			processResults(resultsList);
-		}
-		else
-		{
-			processResults(resultsList,
-				PinotSettings::getInstance().getIndexPropertiesByName(m_engineDisplayableName).m_id);
-		}
-
-		// Don't spellcheck if the query was modified in any way
-		if (m_queryProps.getModified() == false)
-		{
-			string correctedFreeQuery(pEngine->getSpellingCorrection());
-
-			// Any spelling correction ?
-			if (correctedFreeQuery.empty() == false)
-			{
-				m_correctedSpelling = true;
-				m_queryProps.setFreeQuery(correctedFreeQuery);
-			}
-		}
-	}
-
-	delete pEngine;
-}
-
-EngineHistoryThread::EngineHistoryThread(const string &engineDisplayableName,
-	const QueryProperties &queryProps, unsigned int maxDocsCount) :
-	QueryingThread("", engineDisplayableName, "", queryProps, 0),
-	m_maxDocsCount(maxDocsCount)
-{
-	// Results are converted to UTF-8 prior to insertion in the history database
-	m_resultsCharset = "UTF-8";
-	m_isLive = false;
-}
-
-EngineHistoryThread::~EngineHistoryThread()
-{
-}
-
-void EngineHistoryThread::doWork(void)
-{
-	QueryHistory queryHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-
-	if (queryHistory.getItems(m_queryProps.getName(), m_engineDisplayableName,
-		m_maxDocsCount, m_documentsList) == false)
-	{
-		m_errorNum = HISTORY_FAILED;
-		m_errorParam = m_engineDisplayableName;
-	}
-	else if (m_documentsList.empty() == false)
-	{
-		// Get the first result's charset
-		queryHistory.getItemExtract(m_queryProps.getName(), m_engineDisplayableName,
-			m_documentsList.front().getLocation());
-	}
-}
-
-ExpandQueryThread::ExpandQueryThread(const QueryProperties &queryProps,
-	const set<string> &expandFromDocsSet) :
-	WorkerThread(),
-	m_queryProps(queryProps)
-{
-	copy(expandFromDocsSet.begin(), expandFromDocsSet.end(),
-		inserter(m_expandFromDocsSet, m_expandFromDocsSet.begin()));
-}
-
-ExpandQueryThread::~ExpandQueryThread()
-{
-}
-
-string ExpandQueryThread::getType(void) const
-{
-	return "ExpandQueryThread";
-}
-
-QueryProperties ExpandQueryThread::getQuery(void) const
-{
-	return m_queryProps;
-}
-
-const set<string> &ExpandQueryThread::getExpandTerms(void) const
-{
-	return m_expandTerms;
-}
-
-void ExpandQueryThread::doWork(void)
-{
-	// Get the SearchEngine
-	SearchEngineInterface *pEngine = ModuleFactory::getSearchEngine(PinotSettings::getInstance().m_defaultBackend, "MERGED");
-	if (pEngine == NULL)
-	{
-		m_errorNum = UNKNOWN_ENGINE;
-		m_errorParam = m_queryProps.getName();
-		return;
-	}
-
-	// Expand the query
-	pEngine->setExpandSet(m_expandFromDocsSet);
-
-	// Run the query
-	pEngine->setDefaultOperator(SearchEngineInterface::DEFAULT_OP_AND);
-	if (pEngine->runQuery(m_queryProps) == false)
-	{
-		m_errorNum = QUERY_FAILED;
-	}
-	else
-	{
-		// Copy the expand terms
-		const set<string> &expandTerms = pEngine->getExpandTerms();
-		copy(expandTerms.begin(), expandTerms.end(),
-			inserter(m_expandTerms, m_expandTerms.begin()));
-	}
-
-	delete pEngine;
-}
-
-LabelUpdateThread::LabelUpdateThread(const set<string> &labelsToAdd,
-	const set<string> &labelsToDelete) :
-	WorkerThread(),
-	m_resetLabels(false)
-{
-	copy(labelsToAdd.begin(), labelsToAdd.end(),
-		inserter(m_labelsToAdd, m_labelsToAdd.begin()));
-	copy(labelsToDelete.begin(), labelsToDelete.end(),
-		inserter(m_labelsToDelete, m_labelsToDelete.begin()));
-}
-
-LabelUpdateThread::LabelUpdateThread(const set<string> &labelsToAdd,
-	const set<unsigned int> &docsIds, const set<unsigned int> &daemonIds,
-	bool resetLabels) :
-	WorkerThread(),
-	m_resetLabels(resetLabels)
-{
-	copy(labelsToAdd.begin(), labelsToAdd.end(),
-		inserter(m_labelsToAdd, m_labelsToAdd.begin()));
-	copy(docsIds.begin(), docsIds.end(),
-		inserter(m_docsIds, m_docsIds.begin()));
-	copy(daemonIds.begin(), daemonIds.end(),
-		inserter(m_daemonIds, m_daemonIds.begin()));
-}
-
-LabelUpdateThread::~LabelUpdateThread()
-{
-}
-
-string LabelUpdateThread::getType(void) const
-{
-	return "LabelUpdateThread";
-}
-
-bool LabelUpdateThread::modifiedDocsIndex(void) const
-{
-	return !m_docsIds.empty();
-}
-
-bool LabelUpdateThread::modifiedDaemonIndex(void) const
-{
-	return !m_daemonIds.empty();
-}
-
-void LabelUpdateThread::doWork(void)
-{
-	bool actOnDocuments = false;
-
-	IndexInterface *pDocsIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_docsIndexLocation);
-	if (pDocsIndex == NULL)
-	{
-		m_errorNum = INDEX_ERROR;
-		m_errorParam = PinotSettings::getInstance().m_docsIndexLocation;
-		return;
-	}
-
-	IndexInterface *pDaemonIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
-	if (pDaemonIndex == NULL)
-	{
-		m_errorNum = INDEX_ERROR;
-		m_errorParam = PinotSettings::getInstance().m_daemonIndexLocation;
-		delete pDocsIndex;
-		return;
-	}
-
-	// Apply the labels to existing documents
-	if (m_docsIds.empty() == false)
-	{
-		pDocsIndex->setDocumentsLabels(m_docsIds, m_labelsToAdd, m_resetLabels);
-		actOnDocuments = true;
-	}
-	if (m_daemonIds.empty() == false)
-	{
-		pDaemonIndex->setDocumentsLabels(m_daemonIds, m_labelsToAdd, m_resetLabels);
-		actOnDocuments = true;
-	}
-
-	if (actOnDocuments == false)
-	{
-		// Add and/or delete labels on the daemon's index only
-		// The documents index is not required to have labels set
-		for (set<string>::iterator iter = m_labelsToAdd.begin(); iter != m_labelsToAdd.end(); ++iter)
-		{
-			pDaemonIndex->addLabel(*iter);
-		}
-		for (set<string>::iterator iter = m_labelsToDelete.begin(); iter != m_labelsToDelete.end(); ++iter)
-		{
-			pDaemonIndex->deleteLabel(*iter);
-		}
-	}
-
-	delete pDaemonIndex;
-	delete pDocsIndex;
-}
-
-DownloadingThread::DownloadingThread(const DocumentInfo &docInfo) :
-	WorkerThread(),
-	m_docInfo(docInfo),
-	m_pDoc(NULL),
-	m_pDownloader(NULL)
-{
-}
-
-DownloadingThread::DownloadingThread() :
-	WorkerThread(),
-	m_docInfo("", "", "", ""),
-	m_pDoc(NULL),
-	m_pDownloader(NULL)
-{
-}
-
-DownloadingThread::~DownloadingThread()
-{
-	if (m_pDoc != NULL)
-	{
-		delete m_pDoc;
-	}
-	if (m_pDownloader != NULL)
-	{
-		delete m_pDownloader;
-	}
-}
-
-string DownloadingThread::getType(void) const
-{
-	return "DownloadingThread";
-}
-
-string DownloadingThread::getURL(void) const
-{
-	return m_docInfo.getLocation();
-}
-
-const Document *DownloadingThread::getDocument(void) const
-{
-	return m_pDoc;
-}
-
-void DownloadingThread::doWork(void)
-{
-	if (m_pDoc != NULL)
-	{
-		delete m_pDoc;
-		m_pDoc = NULL;
-	}
-	if (m_pDownloader != NULL)
-	{
-		delete m_pDownloader;
-		m_pDownloader = NULL;
-	}
-
-	Url thisUrl(m_docInfo.getLocation());
-
-	// Get a Downloader, the default one will do
-	m_pDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
-	if (m_pDownloader == NULL)
-	{
-		m_errorNum = UNSUPPORTED_PROTOCOL;
-		m_errorParam = thisUrl.getProtocol();
-	}
-	else if (m_done == false)
-	{
-		Timer collectTimer;
-		PinotSettings &settings = PinotSettings::getInstance();
-
-		// Set up the proxy
-		if ((settings.m_proxyEnabled == true) &&
-			(settings.m_proxyAddress.empty() == false))
-		{
-			char portStr[64];
-
-			m_pDownloader->setSetting("proxyaddress", settings.m_proxyAddress);
-			snprintf(portStr, 64, "%u", settings.m_proxyPort);
-			m_pDownloader->setSetting("proxyport", portStr);
-			m_pDownloader->setSetting("proxytype", settings.m_proxyType);
-		}
-
-		collectTimer.start();
-
-		m_pDoc = m_pDownloader->retrieveUrl(m_docInfo);
-
-		cout << "Retrieved " << m_docInfo.getLocation() << " in " << collectTimer.stop() << " ms" << endl;
-	}
-
-	if (m_pDoc == NULL)
-	{
-		m_errorNum = DOWNLOAD_FAILED;
-		m_errorParam = m_docInfo.getLocation();
-	}
-}
-
-IndexingThread::IndexingThread(const DocumentInfo &docInfo, const string &indexLocation,
-	bool allowAllMIMETypes) :
-	DownloadingThread(docInfo),
-	m_docId(0),
-	m_indexLocation(indexLocation),
-	m_allowAllMIMETypes(allowAllMIMETypes),
-	m_update(false)
-{
-}
-
-IndexingThread::IndexingThread() :
-	DownloadingThread(),
-	m_docId(0),
-	m_indexLocation(""),
-	m_allowAllMIMETypes(true),
-	m_update(false)
-{
-}
-
-IndexingThread::~IndexingThread()
-{
-}
-
-string IndexingThread::getType(void) const
-{
-	return "IndexingThread";
-}
-
-const DocumentInfo &IndexingThread::getDocumentInfo(void) const
-{
-	return m_docInfo;
-}
-
-unsigned int IndexingThread::getDocumentID(void) const
-{
-	return m_docId;
-}
-
-bool IndexingThread::isNewDocument(void) const
-{
-	// If the thread is set to perform an update, the document isn't new
-	if (m_update == true)
-	{
-		return false;
-	}
-	return true;
-}
-
-void IndexingThread::doWork(void)
-{
-	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexLocation);
-	Url thisUrl(m_docInfo.getLocation());
-	bool reliableType = false, doDownload = true;
-
-	// First things first, get the index
-	if ((pIndex == NULL) ||
-		(pIndex->isGood() == false))
-	{
-		m_errorNum = INDEX_ERROR;
-		m_errorParam = m_indexLocation;
-		if (pIndex != NULL)
-		{
-			delete pIndex;
-		}
-		return;
-	}
-
-	// Is it an update ?
-	m_docId = pIndex->hasDocument(m_docInfo.getLocation());
-	if (m_docId > 0)
-	{
-		// Ignore robots directives on updates
-		m_update = true;
-	}
-
-	if (m_docInfo.getType().empty() == true)
-	{
-		m_docInfo.setType(MIMEScanner::scanUrl(thisUrl));
-	}
-	else if (thisUrl.isLocal() == true)
-	{
-		// There's a good chance the supplied type is accurate
-		// if the document is a local file
-		reliableType = true;
-	}
-
-	if (FilterUtils::isSupportedType(m_docInfo.getType()) == false)
-	{
-		// Skip unsupported types ?
-		if (m_allowAllMIMETypes == false)
-		{
-			m_errorNum = UNSUPPORTED_TYPE;
-			m_errorParam = m_docInfo.getType();
-			delete pIndex;
-
-			return;
-		}
-
-		if (reliableType == true)
-		{
-			doDownload = false;
-#ifdef DEBUG
-			cout << "IndexingThread::doWork: skipping download of unsupported type " << m_docInfo.getLocation() << endl;
-#endif
-		}
-	}
-	else
-	{
-		Dijon::Filter *pFilter = FilterUtils::getFilter(m_docInfo.getType());
-
-		if (pFilter != NULL)
-		{
-			// We may able to feed the document directly to the filter
-			if (((pFilter->is_data_input_ok(Dijon::Filter::DOCUMENT_FILE_NAME) == true) &&
-				(thisUrl.getProtocol() == "file")) ||
-				((pFilter->is_data_input_ok(Dijon::Filter::DOCUMENT_URI) == true) &&
-				(thisUrl.isLocal() == false)))
-			{
-				doDownload = false;
-#ifdef DEBUG
-				cout << "IndexingThread::doWork: let filter download " << m_docInfo.getLocation() << endl;
-#endif
-			}
-
-			delete pFilter;
-		}
-	}
-
-	// We may not have to download the document
-	if (doDownload == true)
-	{
-		DownloadingThread::doWork();
-	}
-	else
-	{
-		m_pDoc = new Document(m_docInfo);
-
-		m_pDoc->setTimestamp(m_docInfo.getTimestamp());
-		m_pDoc->setSize(m_docInfo.getSize());
-	}
-
-	if (m_pDoc != NULL)
-	{
-		string docType(m_pDoc->getType());
-		bool success = false;
-
-		// The type may have been obtained when downloading
-		if (docType.empty() == false)
-		{
-			// Use the document's type
-			m_docInfo.setType(docType);
-		}
-		else
-		{
-			// Use the type we were supplied with
-			m_pDoc->setType(m_docInfo.getType());
-		}
-
-		if (m_docInfo.getTitle().empty() == false)
-		{
-			// Use the title we were supplied with
-			m_pDoc->setTitle(m_docInfo.getTitle());
-		}
-		else
-		{
-			// Use the document's
-			m_docInfo.setTitle(m_pDoc->getTitle());
-		}
-#ifdef DEBUG
-		cout << "IndexingThread::doWork: title is " << m_pDoc->getTitle() << endl;
-#endif
-
-		// Check again as the downloader may have altered the MIME type
-		if (FilterUtils::isSupportedType(m_docInfo.getType()) == false)
-		{
-			// Skip unsupported types ?
-			if (m_allowAllMIMETypes == false)
-			{
-				m_errorNum = UNSUPPORTED_TYPE;
-				m_errorParam = m_docInfo.getType();
-				delete pIndex;
-
-				return;
-			}
-
-			// Let FilterWrapper handle unspported documents
-		}
-		else if ((PinotSettings::getInstance().m_ignoreRobotsDirectives == false) &&
-			(m_docInfo.getType().length() >= 9) &&
-			(m_docInfo.getType().substr(9) == "text/html"))
-		{
-			Dijon::HtmlFilter htmlFilter(m_docInfo.getType());
-
-			if ((FilterUtils::feedFilter(*m_pDoc, &htmlFilter) == true) &&
-				(htmlFilter.next_document() == true))
-			{
-				const map<string, string> &metaData = htmlFilter.get_meta_data();
-
-				// See if the document has a ROBOTS META tag
-				map<string, string>::const_iterator robotsIter = metaData.find("robots");
-				if (robotsIter != metaData.end())
-				{
-					string robotsDirectives(robotsIter->second);
-	
-					// Is indexing allowed ?
-					string::size_type pos1 = robotsDirectives.find("none");
-					string::size_type pos2 = robotsDirectives.find("noindex");
-					if ((pos1 != string::npos) ||
-						(pos2 != string::npos))
-					{
-						// No, it isn't
-						m_errorNum = ROBOTS_FORBIDDEN;
-						m_errorParam = m_docInfo.getLocation();
-						delete pIndex;
-
-						return;
-					}
-				}
-			}
-#ifdef DEBUG
-			else cout << "IndexingThread::doWork: couldn't check document for ROBOTS directive" << endl;
-#endif
-		}
-
-		if (m_done == false)
-		{
-			FilterWrapper wrapFilter(pIndex);
-
-			// Update an existing document or add to the index ?
-			if (m_update == true)
-			{
-				// Update the document
-				if (wrapFilter.updateDocument(*m_pDoc, m_docId) == true)
-				{
-#ifdef DEBUG
-					cout << "IndexingThread::doWork: updated " << m_pDoc->getLocation()
-						<< " at " << m_docId << endl;
-#endif
-					success = true;
-				}
-#ifdef DEBUG
-				else cout << "IndexingThread::doWork: couldn't update " << m_pDoc->getLocation() << endl;
-#endif
-			}
-			else
-			{
-				unsigned int docId = 0;
-#ifdef DEBUG
-				cout << "IndexingThread::doWork: " << m_docInfo.getLabels().size()
-					<< " labels for URL " << m_pDoc->getLocation() << endl;
-#endif
-
-				// Index the document
-				success = wrapFilter.indexDocument(*m_pDoc, m_docInfo.getLabels(), docId);
-				if (success == true)
-				{
-					m_docId = docId;
-#ifdef DEBUG
-					cout << "IndexingThread::doWork: indexed " << m_pDoc->getLocation()
-						<< " to " << m_docId << endl;
-#endif
-				}
-#ifdef DEBUG
-				else cout << "IndexingThread::doWork: couldn't index " << m_pDoc->getLocation() << endl;
-#endif
-			}
-
-			if (success == false)
-			{
-				m_errorNum = INDEXING_FAILED;
-				m_errorParam = m_docInfo.getLocation();
-			}
-			else
-			{
-				// Flush the index ?
-				if (m_immediateFlush == true)
-				{
-					pIndex->flush();
-				}
-
-				// The document properties may have changed
-				pIndex->getDocumentInfo(m_docId, m_docInfo);
-				m_docInfo.setIsIndexed(
-					PinotSettings::getInstance().getIndexPropertiesByLocation(m_indexLocation).m_id,
-					m_docId);
-			}
-		}
-	}
-#ifdef DEBUG
-	else cout << "IndexingThread::doWork: couldn't download " << m_docInfo.getLocation() << endl;
-#endif
-
-	delete pIndex;
-}
-
-UnindexingThread::UnindexingThread(const set<unsigned int> &docIdList) :
-	WorkerThread(),
-	m_indexLocation(PinotSettings::getInstance().m_docsIndexLocation),
-	m_docsCount(0)
-{
-	copy(docIdList.begin(), docIdList.end(), inserter(m_docIdList, m_docIdList.begin()));
-}
-
-UnindexingThread::UnindexingThread(const set<string> &labelNames, const string &indexLocation) :
-	WorkerThread(),
-	m_indexLocation(indexLocation),
-	m_docsCount(0)
-{
-	copy(labelNames.begin(), labelNames.end(), inserter(m_labelNames, m_labelNames.begin()));
-	if (indexLocation.empty() == true)
-	{
-		m_indexLocation = PinotSettings::getInstance().m_docsIndexLocation;
-	}
-}
-
-UnindexingThread::~UnindexingThread()
-{
-}
-
-string UnindexingThread::getType(void) const
-{
-	return "UnindexingThread";
-}
-
-unsigned int UnindexingThread::getDocumentsCount(void) const
-{
-	return m_docsCount;
-}
-
-void UnindexingThread::doWork(void)
-{
-	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexLocation);
-
-	if ((pIndex == NULL) ||
-		(pIndex->isGood() == false))
-	{
-		m_errorNum = INDEX_ERROR;
-		m_errorParam = m_indexLocation;
-		if (pIndex != NULL)
-		{
-			delete pIndex;
-		}
-		return;
-	}
-
-	// Be pessimistic and assume something will go wrong ;-)
-	m_errorNum = UNINDEXING_FAILED;
-
-	// Are we supposed to remove documents based on labels ?
-	if (m_docIdList.empty() == true)
-	{
-		// Yep, delete documents one label at a time
-		for (set<string>::iterator iter = m_labelNames.begin(); iter != m_labelNames.end(); ++iter)
-		{
-			string labelName = (*iter);
-
-			// By unindexing all documents that match the label,
-			// we effectively delete the label from the index
-			if (pIndex->unindexDocuments(labelName, IndexInterface::BY_LABEL) == true)
-			{
-#ifdef DEBUG
-				cout << "UnindexingThread::doWork: removed label " << labelName << endl;
-#endif
-				// OK
-				++m_docsCount;
-			}
-#ifdef DEBUG
-			else cout << "UnindexingThread::doWork: couldn't remove label " << labelName << endl;
-#endif
-		}
-
-		// Nothing to report
-		m_errorNum = 0;
-	}
-	else
-	{
-		for (set<unsigned int>::iterator iter = m_docIdList.begin(); iter != m_docIdList.end(); ++iter)
-		{
-			unsigned int docId = (*iter);
-
-			if (pIndex->unindexDocument(docId) == true)
-			{
-#ifdef DEBUG
-				cout << "UnindexingThread::doWork: removed " << docId << endl;
-#endif
-				// OK
-				++m_docsCount;
-			}
-#ifdef DEBUG
-			else cout << "UnindexingThread::doWork: couldn't remove " << docId << endl;
-#endif
-		}
-#ifdef DEBUG
-		cout << "UnindexingThread::doWork: removed " << m_docsCount << " documents" << endl;
-#endif
-	}
-
-	if (m_docsCount > 0)
-	{
-		// Flush the index ?
-		if (m_immediateFlush == true)
-		{
-			pIndex->flush();
-		}
-
-		// Nothing to report
-		m_errorNum = 0;
-	}
-
-	delete pIndex;
-}
-
-UpdateDocumentThread::UpdateDocumentThread(const PinotSettings::IndexProperties &indexProps, unsigned int docId,
-	const DocumentInfo &docInfo, bool updateLabels) :
-	WorkerThread(),
-	m_indexProps(indexProps),
-	m_docId(docId),
-	m_docInfo(docInfo),
-	m_updateLabels(updateLabels)
-{
-}
-
-UpdateDocumentThread::~UpdateDocumentThread()
-{
-}
-
-string UpdateDocumentThread::getType(void) const
-{
-	return "UpdateDocumentThread";
-}
-
-PinotSettings::IndexProperties UpdateDocumentThread::getIndexProperties(void) const
-{
-	return m_indexProps;
-}
-
-unsigned int UpdateDocumentThread::getDocumentID(void) const
-{
-	return m_docId;
-}
-
-const DocumentInfo &UpdateDocumentThread::getDocumentInfo(void) const
-{
-	return m_docInfo;
-}
-
-void UpdateDocumentThread::doWork(void)
-{
-	if (m_done == false)
-	{
-		if (m_indexProps.m_location.empty() == true)
-		{
-			m_errorNum = UNKNOWN_INDEX;
-			m_errorParam = m_indexProps.m_name.c_str();
-			return;
-		}
-
-		// Get the index at that location
-		IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexProps.m_location);
-		if ((pIndex == NULL) ||
-			(pIndex->isGood() == false))
-		{
-			m_errorNum = INDEX_ERROR;
-			m_errorParam = m_indexProps.m_location;
-			if (pIndex != NULL)
-			{
-				delete pIndex;
-			}
-			return;
-		}
-
-		// Update the DocumentInfo
-		if (pIndex->updateDocumentInfo(m_docId, m_docInfo) == false)
-		{
-			m_errorNum = UPDATE_FAILED;
-			m_errorParam = m_docInfo.getLocation();
-			return;
-		}
-		// ...and the labels if necessary
-		if (m_updateLabels == true)
-		{
-			if (pIndex->setDocumentLabels(m_docId, m_docInfo.getLabels()) == false)
-			{
-				m_errorNum = UPDATE_FAILED;
-				m_errorParam = m_docInfo.getLocation();
-				return;
-			}
-		}
-
-		// Flush the index ?
-		if (m_immediateFlush == true)
-		{
-			pIndex->flush();
-		}
-
-		delete pIndex;
-	}
-}
-
-MonitorThread::MonitorThread(MonitorInterface *pMonitor, MonitorHandler *pHandler,
-	bool checkHistory) :
-	WorkerThread(),
-	m_ctrlReadPipe(-1),
-	m_ctrlWritePipe(-1),
-	m_pMonitor(pMonitor),
-	m_pHandler(pHandler),
-	m_checkHistory(checkHistory)
-{
-	int pipeFds[2];
-
-#ifdef HAVE_PIPE
-	if (pipe(pipeFds) == 0)
-	{
-		// This pipe will allow to stop select()
-		m_ctrlReadPipe = pipeFds[0];
-		m_ctrlWritePipe = pipeFds[1];
-	}
-#endif
-}
-
-MonitorThread::~MonitorThread()
-{
-	if (m_ctrlReadPipe >= 0)
-	{
-		close(m_ctrlReadPipe);
-	}
-	if (m_ctrlWritePipe >= 0)
-	{
-		close(m_ctrlWritePipe);
-	}
-}
-
-string MonitorThread::getType(void) const
-{
-	return "MonitorThread";
-}
-
-void MonitorThread::stop(void)
-{
-	WorkerThread::stop();
-	if (m_ctrlWritePipe >= 0)
-	{
-		write(m_ctrlWritePipe, "X", 1);
-	}
-}
-
-void MonitorThread::processEvents(void)
-{
-	CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-	queue<MonitorEvent> events;
-
-#ifdef DEBUG
-	cout << "MonitorThread::processEvents: checking for events" << endl;
-#endif
-	if ((m_pMonitor == NULL) ||
-		(m_pMonitor->retrievePendingEvents(events) == false))
-	{
-#ifdef DEBUG
-		cout << "MonitorThread::processEvents: failed to retrieve pending events" << endl;
-#endif
-		return;
-	}
-#ifdef DEBUG
-	cout << "MonitorThread::processEvents: retrieved " << events.size() << " events" << endl;
-#endif
-
-	while ((events.empty() == false) &&
-		(m_done == false))
-	{
-		MonitorEvent &event = events.front();
-
-		if ((event.m_location.empty() == true) ||
-			(event.m_type == MonitorEvent::UNKNOWN))
-		{
-			// Next
-			events.pop();
-			continue;
-		}
-#ifdef DEBUG
-		cout << "MonitorThread::processEvents: event " << event.m_type << " on "
-			<< event.m_location << " " << event.m_isDirectory << endl;
-#endif
-
-		// Skip dotfiles and blacklisted files
-		Url urlObj("file://" + event.m_location);
-		if ((urlObj.getFile()[0] == '.') ||
-			(PinotSettings::getInstance().isBlackListed(event.m_location) == true))
-		{
-			// Next
-			events.pop();
-			continue;
-		}
-
-		// What's the event code ?
-		if (event.m_type == MonitorEvent::EXISTS)
-		{
-			if (event.m_isDirectory == false)
-			{
-				m_pHandler->fileExists(event.m_location);
-			}
-		}
-		else if (event.m_type == MonitorEvent::CREATED)
-		{
-			if (event.m_isDirectory == false)
-			{
-				m_pHandler->fileCreated(event.m_location);
-			}
-			else
-			{
-				m_pHandler->directoryCreated(event.m_location);
-			}
-		}
-		else if (event.m_type == MonitorEvent::WRITE_CLOSED)
-		{
-			if (event.m_isDirectory == false)
-			{
-				CrawlHistory::CrawlStatus status = CrawlHistory::UNKNOWN;
-				struct stat fileStat;
-				time_t itemDate = 0;
-
-				if (m_checkHistory == false)
-				{
-					m_pHandler->fileModified(event.m_location);
-				}
-				else if (crawlHistory.hasItem("file://" + event.m_location, status, itemDate) == true)
-				{
-					// Was the file actually modified ?
-					if ((stat(event.m_location.c_str(), &fileStat) == 0) &&
-						(itemDate < fileStat.st_mtime))
-					{
-						m_pHandler->fileModified(event.m_location);
-					}
-#ifdef DEBUG
-					else cout << "MonitorThread::processEvents: file wasn't modified" << endl;
-#endif
-				}
-#ifdef DEBUG
-				else cout << "MonitorThread::processEvents: file wasn't crawled" << endl;
-#endif
-			}
-		}
-		else if (event.m_type == MonitorEvent::MOVED)
-		{
-			if (event.m_isDirectory == false)
-			{
-				m_pHandler->fileMoved(event.m_location, event.m_previousLocation);
-			}
-			else
-			{
-				// We should receive this only if the destination directory is monitored too
-				m_pHandler->directoryMoved(event.m_location, event.m_previousLocation);
-			}
-		}
-		else if (event.m_type == MonitorEvent::DELETED)
-		{
-			if (event.m_isDirectory == false)
-			{
-				m_pHandler->fileDeleted(event.m_location);
-			}
-			else
-			{
-				// The monitor should have stopped monitoring this
-				// In practice, events for the files in this directory will already have been received 
-				m_pHandler->directoryDeleted(event.m_location);
-			}
-		}
-
-		// Next
-		events.pop();
-	}
-}
-
-void MonitorThread::doWork(void)
-{
-	if ((m_pHandler == NULL) ||
-		(m_pMonitor == NULL))
-	{
-		m_errorNum = NO_MONITORING;
-		return;
-	}
-
-	// Initialize the handler
-	m_pHandler->initialize();
-
-	// Get the list of files to monitor
-	const set<string> &fileNames = m_pHandler->getFileNames();
-	for (set<string>::const_iterator fileIter = fileNames.begin();
-		fileIter != fileNames.end(); ++fileIter)
-	{
-		m_pMonitor->addLocation(*fileIter, false);
-	}
-	// Directories, if any, are set elsewhere
-	// In the case of OnDiskHandler, they are set by DirectoryScannerThread
-
-	// There might already be events that need processing
-	processEvents();
-
-	// Wait for something to happen
-	while (m_done == false)
-	{
-		struct timeval selectTimeout;
-		fd_set listenSet;
-
-		selectTimeout.tv_sec = 60;
-		selectTimeout.tv_usec = 0;
-
-		FD_ZERO(&listenSet);
-		if (m_ctrlReadPipe >= 0)
-		{
-			FD_SET(m_ctrlReadPipe, &listenSet);
-		}
-
-		m_pHandler->flushIndex();
-
-		// The file descriptor may change over time
-		int monitorFd = m_pMonitor->getFileDescriptor();
-		FD_SET(monitorFd, &listenSet);
-		if (monitorFd < 0)
-		{
-			m_errorNum = MONITORING_FAILED;
-			return;
-		}
-
-		int fdCount = select(max(monitorFd, m_ctrlReadPipe) + 1, &listenSet, NULL, NULL, &selectTimeout);
-		if ((fdCount < 0) &&
-			(errno != EINTR))
-		{
-#ifdef DEBUG
-			cout << "MonitorThread::doWork: select() failed" << endl;
-#endif
-			break;
-		}
-		else if (FD_ISSET(monitorFd, &listenSet))
-		{
-			processEvents();
-		}
-	}
-}
-

Deleted: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,513 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _WORKERTHREADS_HH
-#define _WORKERTHREADS_HH
-
-#include <time.h>
-#include <string>
-#include <vector>
-#include <queue>
-#include <set>
-#include <map>
-#include <pthread.h>
-#include <sigc++/sigc++.h>
-#include <glibmm/dispatcher.h>
-#include <glibmm/thread.h>
-#include <glibmm/ustring.h>
-
-#include "Document.h"
-#include "DownloaderInterface.h"
-#include "MonitorInterface.h"
-#include "MonitorHandler.h"
-#include "QueryProperties.h"
-
-class WorkerThread
-{
-	public:
-		WorkerThread();
-		virtual ~WorkerThread();
-
-		typedef enum { UNKNOWN_ERROR = 10000, INDEX_ERROR, INDEXING_FAILED, UPDATE_FAILED, UNINDEXING_FAILED, \
-			QUERY_FAILED, HISTORY_FAILED, DOWNLOAD_FAILED, MONITORING_FAILED, OPENDIR_FAILED, \
-			UNKNOWN_INDEX, UNKNOWN_ENGINE, UNSUPPORTED_TYPE, UNSUPPORTED_PROTOCOL, \
-			ROBOTS_FORBIDDEN, NO_MONITORING } ThreadError;
-
-		static std::string errorToString(int errorNum);
-
-		static Glib::Dispatcher &getDispatcher(void);
-
-		static void immediateFlush(bool doFlush);
-
-		time_t getStartTime(void) const;
-
-		void setId(unsigned int id);
-
-		unsigned int getId(void) const;
-
-		void inBackground(void);
-
-		bool isBackground(void) const;
-
-		bool operator<(const WorkerThread &other) const;
-
-		Glib::Thread *start(void);
-
-		virtual std::string getType(void) const = 0;
-
-		virtual void stop(void);
-
-		bool isStopped(void) const;
-
-		bool isDone(void) const;
-
-		int getErrorNum(void) const;
-
-		std::string getStatus(void) const;
-
-	protected:
-		/// Use a Dispatcher for thread safety
-		static Glib::Dispatcher m_dispatcher;
-		static pthread_mutex_t m_dispatcherMutex;
-		static bool m_immediateFlush;
-		time_t m_startTime;
-		unsigned int m_id;
-		bool m_background;
-		bool m_stopped;
-		bool m_done;
-		int m_errorNum;
-		std::string m_errorParam;
-
-		void threadHandler(void);
-
-		virtual void doWork(void) = 0;
-
-		void emitSignal(void);
-
-	private:
-		WorkerThread(const WorkerThread &other);
-		WorkerThread &operator=(const WorkerThread &other);
-
-};
-
-class ThreadsManager : virtual public sigc::trackable
-{
-	public:
-		ThreadsManager(const std::string &defaultIndexLocation,
-			unsigned int maxIndexThreads,
-			unsigned int maxThreadsTime = 300);
-		virtual ~ThreadsManager();
-
-		static unsigned int get_next_id(void);
-
-		bool start_thread(WorkerThread *pWorkerThread, bool inBackground = false);
-
-		unsigned int get_threads_count(void);
-
-		void stop_threads(void);
-
-		virtual void connect(void);
-
-		virtual void disconnect(void);
-
-		void on_thread_signal();
-
-		bool read_lock_lists(void);
-
-		bool write_lock_lists(void);
-
-		void unlock_lists(void);
-
-		Glib::ustring queue_index(const DocumentInfo &docInfo);
-
-		bool pop_queue(const std::string &urlWasIndexed = "");
-
-	protected:
-		static unsigned int m_nextThreadId;
-		sigc::connection m_threadsEndConnection;
-		pthread_rwlock_t m_threadsLock;
-		pthread_rwlock_t m_listsLock;
-		std::map<unsigned int, WorkerThread *> m_threads;
-		std::string m_defaultIndexLocation;
-		unsigned int m_maxIndexThreads;
-		unsigned int m_backgroundThreadsCount;
-		unsigned int m_foregroundThreadsMaxTime;
-		long m_numCPUs;
-		sigc::signal1<void, WorkerThread *> m_onThreadEndSignal;
-		std::set<std::string> m_beingIndexed;
-		bool m_stopIndexing;
-
-		bool read_lock_threads(void);
-
-		bool write_lock_threads(void);
-
-		void unlock_threads(void);
-
-		WorkerThread *get_thread(void);
-
-		Glib::ustring index_document(const DocumentInfo &docInfo);
-
-		void clear_queues(void);
-
-	private:
-		ThreadsManager(const ThreadsManager &other);
-		ThreadsManager &operator=(const ThreadsManager &other);
-
-};
-
-class ListerThread : public WorkerThread
-{
-	public:
-		ListerThread(const PinotSettings::IndexProperties &indexProps,
-			unsigned int startDoc);
-		~ListerThread();
-
-		std::string getType(void) const;
-
-		PinotSettings::IndexProperties getIndexProperties(void) const;
-
-		unsigned int getStartDoc(void) const;
-
-		const std::vector<DocumentInfo> &getDocuments(void) const;
-
-		unsigned int getDocumentsCount(void) const;
-
-	protected:
-		PinotSettings::IndexProperties m_indexProps;
-		unsigned int m_startDoc;
-		std::vector<DocumentInfo> m_documentsList;
-		unsigned int m_documentsCount;
-
-	private:
-		ListerThread(const ListerThread &other);
-		ListerThread &operator=(const ListerThread &other);
-
-};
-
-class IndexBrowserThread : public ListerThread
-{
-	public:
-		IndexBrowserThread(const PinotSettings::IndexProperties &indexProps,
-			unsigned int maxDocsCount, unsigned int startDoc = 0);
-		~IndexBrowserThread();
-
-		std::string getLabelName(void) const;
-
-	protected:
-		unsigned int m_maxDocsCount;
-
-		virtual void doWork(void);
-
-	private:
-		IndexBrowserThread(const IndexBrowserThread &other);
-		IndexBrowserThread &operator=(const IndexBrowserThread &other);
-
-};
-
-class QueryingThread : public ListerThread
-{
-	public:
-		QueryingThread(const PinotSettings::IndexProperties &indexProps,
-			const QueryProperties &queryProps, unsigned int startDoc = 0,
-			bool listingIndex = false);
-		QueryingThread(const std::string &engineName, const std::string &engineDisplayableName,
-			const std::string &engineOption, const QueryProperties &queryProps,
-			unsigned int startDoc = 0);
-		virtual ~QueryingThread();
-
-		virtual std::string getType(void) const;
-
-		bool isLive(void) const;
-
-		std::string getEngineName(void) const;
-
-		QueryProperties getQuery(bool &wasCorrected) const;
-
-		std::string getCharset(void) const;
-
-	protected:
-		std::string m_engineName;
-		std::string m_engineDisplayableName;
-		std::string m_engineOption;
-		QueryProperties m_queryProps;
-		std::string m_resultsCharset;
-		bool m_listingIndex;
-		bool m_correctedSpelling;
-		bool m_isLive;
-
-		bool findPlugin(void);
-
-	private:
-		QueryingThread(const QueryingThread &other);
-		QueryingThread &operator=(const QueryingThread &other);
-
-};
-
-class EngineQueryThread : public QueryingThread
-{
-	public:
-		EngineQueryThread(const PinotSettings::IndexProperties &indexProps,
-			const QueryProperties &queryProps, unsigned int startDoc = 0,
-			bool listingIndex = false);
-		EngineQueryThread(const PinotSettings::IndexProperties &indexProps,
-			const QueryProperties &queryProps,
-			const std::set<std::string> &limitToDocsSet, unsigned int startDoc = 0);
-		EngineQueryThread(const std::string &engineName, const std::string &engineDisplayableName,
-			const std::string &engineOption, const QueryProperties &queryProps,
-			unsigned int startDoc = 0);
-		virtual ~EngineQueryThread();
-
-	protected:
-		std::set<std::string> m_limitToDocsSet;
-
-		virtual void processResults(const std::vector<DocumentInfo> &resultsList);
-
-		virtual void processResults(const std::vector<DocumentInfo> &resultsList,
-			unsigned int indexId);
-
-		virtual void doWork(void);
-
-	private:
-		EngineQueryThread(const EngineQueryThread &other);
-		EngineQueryThread &operator=(const EngineQueryThread &other);
-
-};
-
-class EngineHistoryThread : public QueryingThread
-{
-	public:
-		EngineHistoryThread(const std::string &engineDisplayableName,
-			const QueryProperties &queryProps, unsigned int maxDocsCount);
-		virtual ~EngineHistoryThread();
-
-	protected:
-		unsigned int m_maxDocsCount;
-
-		virtual void doWork(void);
-
-	private:
-		EngineHistoryThread(const EngineHistoryThread &other);
-		EngineHistoryThread &operator=(const EngineHistoryThread &other);
-
-};
-
-class ExpandQueryThread : public WorkerThread
-{
-	public:
-		ExpandQueryThread(const QueryProperties &queryProps,
-			const std::set<std::string> &expandFromDocsSet);
-		virtual ~ExpandQueryThread();
-
-		virtual std::string getType(void) const;
-
-		QueryProperties getQuery(void) const;
-
-		const std::set<std::string> &getExpandTerms(void) const;
-
-	protected:
-		QueryProperties m_queryProps;
-		std::set<std::string> m_expandFromDocsSet;
-		std::set<std::string> m_expandTerms;
-
-		virtual void doWork(void);
-
-	private:
-		ExpandQueryThread(const ExpandQueryThread &other);
-		ExpandQueryThread &operator=(const ExpandQueryThread &other);
-
-};
-
-class LabelUpdateThread : public WorkerThread
-{
-	public:
-		LabelUpdateThread(const std::set<std::string> &labelsToAdd,
-			const std::set<std::string> &labelsToDelete);
-		LabelUpdateThread(const std::set<std::string> &labelsToAdd,
-			const std::set<unsigned int> &docsIds,
-			const std::set<unsigned int> &daemonIds,
-			bool resetLabels);
-
-		virtual ~LabelUpdateThread();
-
-		virtual std::string getType(void) const;
-
-		bool modifiedDocsIndex(void) const;
-
-		bool modifiedDaemonIndex(void) const;
-
-	protected:
-		std::set<std::string> m_labelsToAdd;
-		std::set<std::string> m_labelsToDelete;
-		std::set<unsigned int> m_docsIds;
-		std::set<unsigned int> m_daemonIds;
-		bool m_resetLabels;
-
-		virtual void doWork(void);
-
-	private:
-		LabelUpdateThread(const LabelUpdateThread &other);
-		LabelUpdateThread &operator=(const LabelUpdateThread &other);
-
-};
-
-class DownloadingThread : public WorkerThread
-{
-	public:
-		DownloadingThread(const DocumentInfo &docInfo);
-		virtual ~DownloadingThread();
-
-		virtual std::string getType(void) const;
-
-		std::string getURL(void) const;
-
-		const Document *getDocument(void) const;
-
-	protected:
-		DocumentInfo m_docInfo;
-		Document *m_pDoc;
-		DownloaderInterface *m_pDownloader;
-
-		DownloadingThread();
-
-		virtual void doWork(void);
-
-	private:
-		DownloadingThread(const DownloadingThread &other);
-		DownloadingThread &operator=(const DownloadingThread &other);
-
-};
-
-class IndexingThread : public DownloadingThread
-{
-	public:
-		IndexingThread(const DocumentInfo &docInfo, const std::string &indexLocation,
-			bool allowAllMIMETypes = true);
-		virtual ~IndexingThread();
-
-		virtual std::string getType(void) const;
-
-		const DocumentInfo &getDocumentInfo(void) const;
-
-		std::string getLabelName(void) const;
-
-		unsigned int getDocumentID(void) const;
-
-		bool isNewDocument(void) const;
-
-	protected:
-		unsigned int m_docId;
-		std::string m_indexLocation;
-		bool m_allowAllMIMETypes;
-		bool m_update;
-
-		IndexingThread();
-
-		virtual void doWork(void);
-
-	private:
-		IndexingThread(const IndexingThread &other);
-		IndexingThread &operator=(const IndexingThread &other);
-
-};
-
-class UnindexingThread : public WorkerThread
-{
-	public:
-		// Unindex documents from the internal index
-		UnindexingThread(const std::set<unsigned int> &docIdList);
-		// Unindex from the given index documents that have one of the labels
-		UnindexingThread(const std::set<std::string> &labelNames, const std::string &indexLocation);
-		virtual ~UnindexingThread();
-
-		virtual std::string getType(void) const;
-
-		unsigned int getDocumentsCount(void) const;
-
-	protected:
-		std::set<unsigned int> m_docIdList;
-		std::set<std::string> m_labelNames;
-		std::string m_indexLocation;
-		unsigned int m_docsCount;
-
-		virtual void doWork(void);
-
-	private:
-		UnindexingThread(const UnindexingThread &other);
-		UnindexingThread &operator=(const UnindexingThread &other);
-
-};
-
-class UpdateDocumentThread : public WorkerThread
-{
-	public:
-		// Update a document's properties
-		UpdateDocumentThread(const PinotSettings::IndexProperties &indexProps,
-			unsigned int docId, const DocumentInfo &docInfo,
-			bool updateLabels);
-		virtual ~UpdateDocumentThread();
-
-		virtual std::string getType(void) const;
-
-		PinotSettings::IndexProperties getIndexProperties(void) const;
-
-		unsigned int getDocumentID(void) const;
-
-		const DocumentInfo &getDocumentInfo(void) const;
-
-	protected:
-		PinotSettings::IndexProperties m_indexProps;
-		unsigned int m_docId;
-		DocumentInfo m_docInfo;
-		bool m_updateLabels;
-
-		virtual void doWork(void);
-
-	private:
-		UpdateDocumentThread(const UpdateDocumentThread &other);
-		UpdateDocumentThread &operator=(const UpdateDocumentThread &other);
-
-};
-
-class MonitorThread : public WorkerThread
-{
-	public:
-		MonitorThread(MonitorInterface *pMonitor, MonitorHandler *pHandler,
-			bool checkHistory = true);
-		virtual ~MonitorThread();
-
-		virtual std::string getType(void) const;
-
-		virtual void stop(void);
-
-	protected:
-		int m_ctrlReadPipe;
-		int m_ctrlWritePipe;
-		MonitorInterface *m_pMonitor;
-		MonitorHandler *m_pHandler;
-		bool m_checkHistory;
-
-		void processEvents(void);
-		virtual void doWork(void);
-
-	private:
-		MonitorThread(const MonitorThread &other);
-		MonitorThread &operator=(const MonitorThread &other);
-
-};
-
-#endif // _WORKERTHREADS_HH

Deleted: trunk/UI/GTK2/src/de.berlios.Pinot.service.in
===================================================================
--- trunk/UI/GTK2/src/de.berlios.Pinot.service.in	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/de.berlios.Pinot.service.in	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,3 +0,0 @@
-[D-BUS Service]
-Name=de.berlios.Pinot
-Exec=@BINDIR@/pinot-dbus-daemon

Deleted: trunk/UI/GTK2/src/pinot-dbus-daemon.1
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.1	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.1	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,34 +0,0 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-DBUS-DAEMON "1" "January 2009" "pinot-dbus-daemon - pinot 0.90" "User Commands"
-.SH NAME
-pinot-dbus-daemon \- D-Bus search and index daemon
-.SH SYNOPSIS
-.B pinot-dbus-daemon
-[\fIOPTIONS\fR]
-.SH DESCRIPTION
-pinot\-dbus\-daemon \- D\-Bus search and index daemon
-.SH OPTIONS
-.TP
-\fB\-f\fR, \fB\-\-fullscan\fR
-force a full scan
-.TP
-\fB\-h\fR, \fB\-\-help\fR
-display this help and exit
-.TP
-\fB\-i\fR, \fB\-\-ignore\-version\fR
-ignore the index version number
-.TP
-\fB\-p\fR, \fB\-\-priority\fR
-set the daemon's priority (default 15)
-.TP
-\fB\-r\fR, \fB\-\-reindex\fR
-force a reindex
-.TP
-\fB\-v\fR, \fB\-\-version\fR
-output version information and exit
-.SH "REPORTING BUGS"
-Report bugs to fabricecolin at users.berlios.de
-.PP
-This is free software.  You may redistribute copies of it under the terms of
-the GNU General Public License <http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html>.
-There is NO WARRANTY, to the extent permitted by law.

Deleted: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,754 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <stdlib.h>
-#include <libintl.h>
-#include <getopt.h>
-#include <sys/time.h>
-#include <sys/resource.h>
-#include <sys/types.h>
-#include <signal.h>
-#include <unistd.h>
-#include <errno.h>
-#include <iostream>
-#include <sstream>
-#include <fstream>
-#include <cstring>
-#include <sigc++/sigc++.h>
-#include <glibmm.h>
-#include <glibmm/thread.h>
-#include <glibmm/ustring.h>
-#include <glibmm/miscutils.h>
-#include <glibmm/convert.h>
-
-#include "config.h"
-#include "NLS.h"
-#include "FilterFactory.h"
-#include "Languages.h"
-#include "MIMEScanner.h"
-#include "ModuleFactory.h"
-#include "ActionQueue.h"
-#include "CrawlHistory.h"
-#include "MetaDataBackup.h"
-#include "QueryHistory.h"
-#include "ViewHistory.h"
-#include "DownloaderInterface.h"
-#include "DaemonState.h"
-#include "PinotSettings.h"
-#include "ServerThreads.h"
-#include "UniqueApplication.h"
-
-using namespace std;
-
-static ofstream g_outputFile;
-static string g_pidFileName;
-static streambuf *g_coutBuf = NULL;
-static streambuf *g_cerrBuf = NULL;
-static struct option g_longOptions[] = {
-	{"fullscan", 0, 0, 'f'},
-	{"help", 0, 0, 'h'},
-	{"ignore-version", 0, 0, 'i'},
-	{"priority", 1, 0, 'p'},
-	{"reindex", 0, 0, 'r'},
-	{"version", 0, 0, 'v'},
-	{0, 0, 0, 0}
-};
-static const char *g_pinotDBusService = "de.berlios.Pinot";
-static const char *g_pinotDBusObjectPath = "/de/berlios/Pinot";
-static void unregisteredHandler(DBusConnection *pConnection, void *pData);
-static DBusHandlerResult messageHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData);
-static DBusObjectPathVTable g_callVTable = {
-	(DBusObjectPathUnregisterFunction)unregisteredHandler,
-        (DBusObjectPathMessageFunction)messageHandler,
-	NULL,
-};
-static Glib::RefPtr<Glib::MainLoop> g_refMainLoop;
-
-static void closeAll(void)
-{
-	cout << "Exiting..." << endl;
-
-	// Close everything
-	ModuleFactory::unloadModules();
-	Dijon::FilterFactory::unloadFilters();
-	Dijon::HtmlFilter::shutdown();
-
-	// Restore the stream buffers
-	if (g_coutBuf != NULL)
-	{
-		cout.rdbuf(g_coutBuf);
-	}
-	if (g_cerrBuf != NULL)
-	{
-		cerr.rdbuf(g_cerrBuf);
-	}
-	g_outputFile.close();
-	if (g_pidFileName.empty() == false)
-	{
-		unlink(g_pidFileName.c_str());
-	}
-
-	DownloaderInterface::shutdown();
-	MIMEScanner::shutdown();
-}
-
-static void quitAll(int sigNum)
-{
-	if (g_refMainLoop->is_running() == true)
-	{
-		cout << "Quitting..." << endl;
-
-		g_refMainLoop->quit();
-	}
-}
-
-static DBusHandlerResult filterHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
-{
-	DaemonState *pServer = (DaemonState *)pData;
-
-#ifdef DEBUG
-	cout << "filterHandler: called" << endl;
-#endif
-	// Are we about to be disconnected ?
-	if (dbus_message_is_signal(pMessage, DBUS_INTERFACE_LOCAL, "Disconnected") == TRUE)
-	{
-#ifdef DEBUG
-		cout << "filterHandler: received Disconnected" << endl;
-#endif
-		if (pServer != NULL)
-		{
-			pServer->set_flag(DaemonState::DISCONNECTED);
-		}
-		quitAll(0);
-	}
-	else if (dbus_message_is_signal(pMessage, DBUS_INTERFACE_DBUS, "NameOwnerChanged") == TRUE)
-	{
-#ifdef DEBUG
-		cout << "filterHandler: received NameOwnerChanged" << endl;
-#endif
-	}
-	// The first two signals are specified by the freedesktop.org Power Management spec v0.1 and v0.2
-	else if ((dbus_message_is_signal(pMessage, "org.freedesktop.PowerManagement", "BatteryStateChanged") == TRUE) ||
-		(dbus_message_is_signal(pMessage, "org.freedesktop.PowerManagement", "OnBatteryChanged") == TRUE) ||
-		(dbus_message_is_signal(pMessage, "org.gnome.PowerManager", "OnAcChanged") == TRUE))
-	{
-		DBusError error;
-		gboolean onBattery = FALSE;
-
-#ifdef DEBUG
-		cout << "filterHandler: received OnBatteryChanged" << endl;
-#endif
-		dbus_error_init(&error);
-		if ((dbus_message_get_args(pMessage, &error,
-			DBUS_TYPE_BOOLEAN, &onBattery,
-			DBUS_TYPE_INVALID) == TRUE) &&
-			(pData != NULL))
-		{
-			if (dbus_message_is_signal(pMessage, "org.gnome.PowerManager", "OnAcChanged") == TRUE)
-			{
-				// This tells us if we are on AC, not on battery
-				if (onBattery == TRUE)
-				{
-					onBattery = FALSE;
-				}
-				else
-				{
-					onBattery = TRUE;
-				}
-			}
-
-			if (onBattery == TRUE)
-			{
-				// We are now on battery
-				if (pServer != NULL)
-				{
-					pServer->set_flag(DaemonState::ON_BATTERY);
-					pServer->stop_crawling();
-				}
-
-				cout << "System is now on battery" << endl;
-			}
-			else
-			{
-				// Back on-line
-				if (pServer != NULL)
-				{
-					pServer->reset_flag(DaemonState::ON_BATTERY);
-					pServer->start_crawling();
-				}
-
-				cout << "System is now on AC" << endl;
-			}
-		}
-		dbus_error_free(&error);
-	}
-
-	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-}
-
-static void unregisteredHandler(DBusConnection *pConnection, void *pData)
-{
-#ifdef DEBUG
-	cout << "unregisteredHandler: called" << endl;
-#endif
-}
-
-static DBusHandlerResult messageHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
-{
-	DaemonState *pServer = (DaemonState *)pData;
-
-	if ((pConnection != NULL) &&
-		(pMessage != NULL))
-	{
-		dbus_connection_ref(pConnection);
-		dbus_message_ref(pMessage);
-
-		if (pServer != NULL)
-		{
-			DBusServletInfo *pInfo = new DBusServletInfo(pConnection, pMessage);
-
-			pServer->start_thread(new DBusServletThread(pServer, pInfo));
-		}
-	}
-
-	return DBUS_HANDLER_RESULT_HANDLED;
-}
-
-static bool getBatteryState(DBusGConnection *pBus, const string &name, const string &path,
-	const string &method, gboolean &result)
-{
-	bool callSuccess = true;
-
-	if ((pBus == NULL) ||
-		(name.empty() == true) ||
-		(path.empty() == true) ||
-		(method.empty() == true))
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = dbus_g_proxy_new_for_name(pBus, name.c_str(),
-		path.c_str(), name.c_str());
-	if (pBusProxy == NULL)
-	{
-		return false;
-	}
-
-	GError *pError = NULL;
-	if (dbus_g_proxy_call(pBusProxy, method.c_str(), &pError,
-		G_TYPE_INVALID,
-		G_TYPE_BOOLEAN, &result,
-		G_TYPE_INVALID) == FALSE)
-	{
-		if (pError != NULL)
-		{
-			cerr << "Couldn't get battery state: " << pError->message << endl;
-			g_error_free(pError);
-		}
-
-		callSuccess = false;
-	}
-
-	g_object_unref(pBusProxy);
-
-	return callSuccess;
-}
-
-int main(int argc, char **argv)
-{
-	int longOptionIndex = 0, priority = 15;
-	bool resetHistory = false;
-	bool resetLabels = false;
-	bool fullScan = false;
-	bool reindex = false;
-	bool ignoreVersion = false;
-
-	// Look at the options
-	int optionChar = getopt_long(argc, argv, "fhip:rv", g_longOptions, &longOptionIndex);
-	while (optionChar != -1)
-	{
-		switch (optionChar)
-		{
-			case 'f':
-				fullScan = true;
-				break;
-			case 'h':
-				// Help
-				cout << "pinot-dbus-daemon - D-Bus search and index daemon\n\n"
-					<< "Usage: pinot-dbus-daemon [OPTIONS]\n\n"
-					<< "Options:\n"
-					<< "  -f, --fullscan	force a full scan\n"
-					<< "  -h, --help		display this help and exit\n"
-					<< "  -i, --ignore-version	ignore the index version number\n"
-					<< "  -p, --priority	set the daemon's priority (default 15)\n"
-					<< "  -r, --reindex		force a reindex\n"
-					<< "  -v, --version		output version information and exit\n"
-					<< "\nReport bugs to " << PACKAGE_BUGREPORT << endl;
-				return EXIT_SUCCESS;
-			case 'i':
-				ignoreVersion = true;
-				break;
-			case 'p':
-				if (optarg != NULL)
-				{
-					int newPriority = atoi(optarg);
-					if ((newPriority >= -20) &&
-						(newPriority < 20))
-					{
-						priority = newPriority;
-					}
-				}
-				break;
-			case 'r':
-				reindex = true;
-				break;
-			case 'v':
-				cout << "pinot-dbus-daemon - " << PACKAGE_STRING << "\n\n" 
-					<< "This is free software.  You may redistribute copies of it under the terms of\n"
-					<< "the GNU General Public License <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>.\n"
-					<< "There is NO WARRANTY, to the extent permitted by law." << endl;
-				return EXIT_SUCCESS;
-			default:
-				return EXIT_FAILURE;
-		}
-
-		// Next option
-		optionChar = getopt_long(argc, argv, "fhip:rv", g_longOptions, &longOptionIndex);
-	}
-
-#if defined(ENABLE_NLS)
-	bindtextdomain(GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
-	bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
-	textdomain(GETTEXT_PACKAGE);
-#endif //ENABLE_NLS
-
-	// Initialize threads support before doing anything else
-	if (Glib::thread_supported() == false)
-	{
-		Glib::thread_init();
-	}
-	// Initialize the GType and the D-Bus thread system
-	g_type_init();
-#if DBUS_NUM_VERSION > 1000000
-	dbus_threads_init_default();
-#endif
-	dbus_g_thread_init();
-
-	g_refMainLoop = Glib::MainLoop::create();
-	Glib::set_application_name("Pinot DBus Daemon");
-
-	// This should make Xapian use Flint rather than Quartz
-	Glib::setenv("XAPIAN_PREFER_FLINT", "1");
-
-	// Make the locale follow the environment variables
-	setlocale(LC_ALL, "");
-	char *pLocale = setlocale(LC_ALL, NULL);
-	if (pLocale != NULL)
-	{
-		string locale(pLocale);
-
-		if (locale != "C")
-		{
-			bool appendUTF8 = false;
-
-			string::size_type pos = locale.find_last_of(".");
-			if ((pos != string::npos) &&
-				((strcasecmp(locale.substr(pos).c_str(), ".utf8") != 0) &&
-				(strcasecmp(locale.substr(pos).c_str(), ".utf-8") != 0)))
-			{
-				locale.resize(pos);
-				appendUTF8 = true;
-			}
-
-			if (appendUTF8 == true)
-			{
-				locale += ".UTF-8";
-
-				pLocale = setlocale(LC_ALL, locale.c_str());
-				if (pLocale != NULL)
-				{
-#ifdef DEBUG
-					cout << "Changed locale to " << pLocale << endl;
-#endif
-				}
-			}
-		}
-	}
-
-	// Make sure only one instance runs
-	UniqueApplication uniqueApp("de.berlios.PinotDBusDaemon");
-	string confDirectory = PinotSettings::getConfigurationDirectory();
-	g_pidFileName = confDirectory + "/pinot-dbus-daemon.pid";
-	if (chdir(confDirectory.c_str()) == 0)
-	{
-		if (uniqueApp.isRunning(g_pidFileName, "pinot-dbus-daemon") == true)
-		{
-			return EXIT_SUCCESS;
-		}
-
-		// Redirect cout and cerr to a file
-		string fileName(confDirectory);
-		fileName += "/pinot-dbus-daemon.log";
-		g_outputFile.open(fileName.c_str());
-		g_coutBuf = cout.rdbuf();
-		g_cerrBuf = cerr.rdbuf();
-		cout.rdbuf(g_outputFile.rdbuf());
-		cerr.rdbuf(g_outputFile.rdbuf());
-	}
-	else
-	{
-		// We can't rely on the PID file
-		if (uniqueApp.isRunning() == true)
-		{
-			return EXIT_SUCCESS;
-		}
-	}
-
-	// This will create the necessary directories on the first run
-	PinotSettings &settings = PinotSettings::getInstance();
-	// This is the daemon so disable client-side code 
-	settings.enableClientMode(false);
-
-	// Initialize utility classes
-	if (MIMEScanner::initialize(PinotSettings::getHomeDirectory() + "/.local",
-		string(SHARED_MIME_INFO_PREFIX)) == false)
-	{
-		cerr << "Couldn't load MIME settings" << endl;
-	}
-	DownloaderInterface::initialize();
-	// Load tokenizer libraries, if any
-	Dijon::HtmlFilter::initialize();
-	Dijon::FilterFactory::loadFilters(string(LIBDIR) + "/pinot/filters");
-	Dijon::FilterFactory::loadFilters(confDirectory + "/filters");
-	// Load backends, if any
-	ModuleFactory::loadModules(string(LIBDIR) + "/pinot/backends");
-	ModuleFactory::loadModules(confDirectory + "/backends");
-
-	// Localize language names
-	Languages::setIntlName(0, _("Unknown"));
-	Languages::setIntlName(1, _("Danish"));
-	Languages::setIntlName(2, _("Dutch"));
-	Languages::setIntlName(3, _("English"));
-	Languages::setIntlName(4, _("Finnish"));
-	Languages::setIntlName(5, _("French"));
-	Languages::setIntlName(6, _("German"));
-	Languages::setIntlName(7, _("Hungarian"));
-	Languages::setIntlName(8, _("Italian"));
-	Languages::setIntlName(9, _("Norwegian"));
-	Languages::setIntlName(10, _("Portuguese"));
-	Languages::setIntlName(11, _("Romanian"));
-	Languages::setIntlName(12, _("Russian"));
-	Languages::setIntlName(13, _("Spanish"));
-	Languages::setIntlName(14, _("Swedish"));
-	Languages::setIntlName(15, _("Turkish"));
-
-	// Load the settings
-	settings.load(PinotSettings::LOAD_ALL);
-
-	// Catch interrupts
-#ifdef HAVE_SIGACTION
-	struct sigaction newAction;
-	sigemptyset(&newAction.sa_mask);
-	newAction.sa_flags = 0;
-	newAction.sa_handler = quitAll;
-	sigaction(SIGINT, &newAction, NULL);
-	sigaction(SIGQUIT, &newAction, NULL);
-	sigaction(SIGTERM, &newAction, NULL);
-#else
-	signal(SIGINT, quitAll);
-#ifdef SIGQUIT
-	signal(SIGQUIT, quitAll);
-#endif
-	signal(SIGTERM, quitAll);
-#endif
-
-	// Open the daemon index in read-write mode 
-	bool wasObsoleteFormat = false;
-	if (ModuleFactory::openOrCreateIndex(settings.m_defaultBackend, settings.m_daemonIndexLocation, wasObsoleteFormat, false) == false)
-	{
-		cerr << "Couldn't open index " << settings.m_daemonIndexLocation << endl;
-		return EXIT_FAILURE;
-	}
-	if (wasObsoleteFormat == true)
-	{
-		resetHistory = resetLabels = true;
-	}
-
-	// Do the same for the history database
-	PinotSettings::checkHistoryDatabase();
-	string historyDatabase(settings.getHistoryDatabaseName());
-	if ((historyDatabase.empty() == true) ||
-		(ActionQueue::create(historyDatabase) == false) ||
-		(CrawlHistory::create(historyDatabase) == false) ||
-		(MetaDataBackup::create(historyDatabase) == false) ||
-		(QueryHistory::create(historyDatabase) == false) ||
-		(ViewHistory::create(historyDatabase) == false))
-	{
-		cerr << "Couldn't create history database " << historyDatabase << endl;
-		return EXIT_FAILURE;
-	}
-	else
-	{
-		ActionQueue actionQueue(historyDatabase, Glib::get_application_name());
-		QueryHistory queryHistory(historyDatabase);
-		ViewHistory viewHistory(historyDatabase);
-		time_t timeNow = time(NULL);
-		unsigned int actionsCount = actionQueue.getItemsCount(ActionQueue::INDEX);
-
-		// Don't expire actions left from last time
-		actionsCount += actionQueue.getItemsCount(ActionQueue::UNINDEX);
-		cout << actionsCount << " actions left" << endl;
-
-		// Expire the rest
-		queryHistory.expireItems(timeNow);
-		viewHistory.expireItems(timeNow);
-	}
-
-	atexit(closeAll);
-
-	// Change the daemon's priority
-	if (setpriority(PRIO_PROCESS, 0, priority) == -1)
-	{
-		cerr << "Couldn't set scheduling priority to " << priority << endl;
-	}
-#ifdef DEBUG
-	else cout << "Set priority to " << priority << endl;
-#endif
-
-	GError *pError = NULL;
-	DBusGConnection *pBus = dbus_g_bus_get(DBUS_BUS_SESSION, &pError);
-	if (pBus == NULL)
-	{
-		if (pError != NULL)
-		{
-			cerr << "Couldn't open bus connection: " << pError->message << endl;
-			if (pError->message != NULL)
-			{
-				cerr << "Error is " << pError->message << endl;
-			}
-			g_error_free(pError);
-		}
-
-		return EXIT_FAILURE;
-	}
-
-	DBusConnection *pConnection = dbus_g_connection_get_connection(pBus);
-	if (pConnection == NULL)
-	{
-		cerr << "Couldn't get connection" << endl;
-		return EXIT_FAILURE;
-	}
-
-	DBusError error;
-	DaemonState server;
-	IndexInterface *pIndex = NULL;
-
-	dbus_error_init(&error);
-	dbus_connection_set_exit_on_disconnect(pConnection, FALSE);
-	dbus_connection_setup_with_g_main(pConnection, NULL);
-
-	if (dbus_connection_register_object_path(pConnection, g_pinotDBusObjectPath,
-		&g_callVTable, &server) == TRUE)
-	{
-		// Request to be identified by this name
-		// FIXME: flags are currently broken ?
-		dbus_bus_request_name(pConnection, g_pinotDBusService, 0, &error);
-		if (dbus_error_is_set(&error) == FALSE)
-		{
-			// See power management signals
-			dbus_bus_add_match(pConnection,
-				"type='signal',interface='org.freedesktop.PowerManagement'", &error);
-			dbus_bus_add_match(pConnection,
-				"type='signal',interface='org.gnome.PowerManager'", &error);
-
-			dbus_connection_add_filter(pConnection,
-				(DBusHandleMessageFunction)filterHandler, &server, NULL);
-		}
-		else
-		{
-			cerr << "Couldn't obtain name " << g_pinotDBusService << endl;
-			if (error.message != NULL)
-			{
-				cerr << "Error is " << error.message << endl;
-			}
-		}
-
-		try
-		{
-			set<string> labels;
-			bool gotLabels = false;
-			bool onBattery = false;
-
-			pIndex = settings.getIndex(settings.m_daemonIndexLocation);
-			if (pIndex != NULL)
-			{
-				string indexVersion(pIndex->getMetadata("version"));
-
-				gotLabels = pIndex->getLabels(labels);
-
-				// What version is the index at ?
-				if (indexVersion.empty() == true)
-				{
-					indexVersion = "0.0";
-				}
-				if (ignoreVersion == true)
-				{
-					// Better reset labels, they may have been lost too
-					resetLabels = true;
-				}
-				else if (indexVersion < PINOT_INDEX_MIN_VERSION)
-				{
-					cout << "Upgrading index from version " << indexVersion << " to " << VERSION << endl;
-
-					reindex = true;
-				}
-				if (reindex == true)
-				{
-					// Reset the index so that all documents are reindexed
-					pIndex->reset();
-
-					cout << "Reset index" << endl;
-
-					resetHistory = resetLabels = true;
-				}
-
-				pIndex->setMetadata("version", VERSION);
-				pIndex->setMetadata("dbus-status", "Running");
-			}
-
-			if (resetHistory == true)
-			{
-				CrawlHistory history(historyDatabase);
-				map<unsigned int, string> sources;
-
-				// Reset the history
-				history.getSources(sources);
-				for (std::map<unsigned int, string>::iterator sourceIter = sources.begin();
-					sourceIter != sources.end(); ++sourceIter)
-				{
-					history.deleteItems(sourceIter->first);
-					history.deleteSource(sourceIter->first);
-				}
-
-				cout << "Reset crawler history" << endl;
-			}
-
-			if ((resetLabels == true) &&
-				(pIndex != NULL))
-			{
-				// Re-apply the labels list
-				if (gotLabels == false)
-				{
-					// If this is an upgrade from a version < 0.80, the labels list
-					// needs to be pulled from the configuration file
-					pIndex->setLabels(settings.m_labels, true);
-
-					cout << "Set labels as per the configuration file" << endl;
-				}
-				else
-				{
-					pIndex->setLabels(labels, true);
-				}
-			}
-
-			// Connect to the quit signal
-			server.getQuitSignal().connect(sigc::ptr_fun(&quitAll));
-
-			// Connect to threads' finished signal
-			server.connect();
-
-			// Try and get the battery state
-			gboolean result = FALSE;
-			if ((getBatteryState(pBus, "org.freedesktop.PowerManagement",
-				"/org/freedesktop/PowerManagement", "GetOnBattery", result) == true) ||
-				(getBatteryState(pBus, "org.freedesktop.PowerManagement",
-				"/org/freedesktop/PowerManagement", "GetBatteryState", result) == true))
-			{
-				if (result == TRUE)
-				{
-					onBattery = true;
-				}
-			}
-			else if (getBatteryState(pBus, "org.gnome.PowerManager",
-				"/org/gnome/PowerManager", "GetOnAc", result) == true)
-			{
-				if (result == FALSE)
-				{
-					onBattery = true;
-				}
-			}
-			if (onBattery == true)
-			{
-				// We are on battery
-				server.set_flag(DaemonState::ON_BATTERY);
-				server.stop_crawling();
-
-				cout << "System is on battery" << endl;
-			}
-
-			server.start(fullScan, reindex);
-
-			// Run the main loop
-			g_refMainLoop->run();
-
-		}
-		catch (const Glib::Exception &e)
-		{
-			cerr << e.what() << endl;
-			return EXIT_FAILURE;
-		}
-		catch (const char *pMsg)
-		{
-			cerr << pMsg << endl;
-			return EXIT_FAILURE;
-		}
-		catch (...)
-		{
-			cerr << "Unknown exception" << endl;
-			return EXIT_FAILURE;
-		}
-	}
-	else
-	{
-		cerr << "Couldn't register object path" << endl;
-	}
-	dbus_error_free(&error);
-
-	if (pIndex != NULL)
-	{
-		if (server.is_flag_set(DaemonState::DISCONNECTED) == true)
-		{
-			pIndex->setMetadata("dbus-status", "Disconnected");
-		}
-		else if (server.is_flag_set(DaemonState::STOPPED) == true)
-		{
-			pIndex->setMetadata("dbus-status", "Stopped");
-		}
-		else
-		{
-			pIndex->setMetadata("dbus-status", "");
-		}
-		delete pIndex;
-	}
-
-	// Stop everything
-	server.disconnect();
-	server.stop_threads();
-
-	return EXIT_SUCCESS;
-}

Deleted: trunk/UI/GTK2/src/pinot-dbus-daemon.xml
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,181 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" ?>
-<node>
-  <interface name="org.freedesktop.DBus.Introspectable">
-    <method name="Introspect">
-      <arg type="s" name="data" direction="out"/>
-    </method>
-  </interface>
-  <!--
-	WARNING: This interface WILL change before 1.0 is released !
-	-->
-  <interface name="de.berlios.Pinot">
-    <!--
-	Retrieves statistics.
-	 crawledCount: the number of documents crawled
-	 docsCount: the number of documents in the index
-	-->
-    <method name="GetStatistics">
-      <annotation name="de.berlios.Pinot.GetStatistics" value="pinotDBus"/>
-      <arg type="u" name="crawledCount" direction="out"/>
-      <arg type="u" name="docsCount" direction="out"/>
-      <arg type="b" name="lowDiskSpace" direction="out" />
-      <arg type="b" name="onBattery" direction="out" />
-      <arg type="b" name="crawling" direction="out" />
-    </method>
-    <!--
-	Instructs the daemon program to reload the configuration file.
-	 reloading: TRUE if the configuration is being reloaded
-	-->
-    <method name="Reload">
-      <annotation name="de.berlios.Pinot.Reload" value="pinotDBus"/>
-      <arg type="b" name="reloading" direction="out" />
-    </method>
-    <!--
-	Stops the daemon program.
-	 exitStatus: the daemon's exit status
-	-->
-    <method name="Stop">
-      <annotation name="de.berlios.Pinot.Stop" value="pinotDBus"/>
-      <arg type="i" name="exitStatus" direction="out" />
-    </method>
-    <!--
-	Checks if a URL is indexed.
-	 docId: the document's ID
-	-->
-    <method name="HasDocument">
-      <annotation name="de.berlios.Pinot.HasDocument" value="pinotDBus"/>
-      <arg type="s" name="url" direction="in"/>
-      <arg type="u" name="docId" direction="out"/>
-    </method>
-    <!--
-	Gets the list of known labels.
-	 labels: array of labels
-	-->
-    <method name="GetLabels">
-      <annotation name="de.berlios.Pinot.GetLabels" value="pinotDBus"/>
-      <arg type="as" name="labels" direction="out"/>
-    </method>
-    <!--
-	Adds a label.
-	 label: the name of the new label
-        This method shouldn't be used by applications other than Pinot.
-	-->
-    <method name="AddLabel">
-      <annotation name="de.berlios.Pinot.AddLabel" value="pinotDBus"/>
-      <arg type="s" name="label" direction="in"/>
-      <arg type="s" name="label" direction="out"/>
-    </method>
-    <!--
-	Deletes a label.
-	 label: the name of the label to delete
-        This method shouldn't be used by applications other than Pinot.
-	-->
-    <method name="DeleteLabel">
-      <annotation name="de.berlios.Pinot.DeleteLabel" value="pinotDBus"/>
-      <arg type="s" name="label" direction="in"/>
-      <arg type="s" name="label" direction="out"/>
-    </method>
-    <!--
-	Retrieves a document's labels.
-	 docId: the document's ID
-	 labels: array of labels applied to the document
-	-->
-    <method name="GetDocumentLabels">
-      <annotation name="de.berlios.Pinot.GetDocumentLabels" value="pinotDBus"/>
-      <arg type="u" name="docId" direction="in"/>
-      <arg type="as" name="labels" direction="out"/>
-    </method>
-    <!--
-	Sets a document's labels.
-	 docId: the document's ID
-	 labels: array of labels to apply to the document
-	 resetLabels: TRUE if existing labels should be unset
-	-->
-    <method name="SetDocumentLabels">
-      <annotation name="de.berlios.Pinot.SetDocumentLabels" value="pinotDBus"/>
-      <arg type="u" name="docId" direction="in"/>
-      <arg type="as" name="labels" direction="in"/>
-      <arg type="b" name="resetLabels" direction="in"/>
-      <arg type="u" name="docId" direction="out"/>
-    </method>
-    <!--
-	Sets labels on a group of documents.
-	 docIds: array of document IDs
-	 labels: array of labels to apply to the documents
-	 resetLabels: TRUE if existing labels should be unset
-	-->
-    <method name="SetDocumentsLabels">
-      <annotation name="de.berlios.Pinot.SetDocumentsLabels" value="pinotDBus"/>
-      <arg type="as" name="docIds" direction="in"/>
-      <arg type="as" name="labels" direction="in"/>
-      <arg type="b" name="resetLabels" direction="in"/>
-      <arg type="b" name="status" direction="out"/>
-    </method>
-    <!--
-	Retrieves information about a document.
-	 docId: the document's ID
-	 fields : array of (s name, s value) structures with name one of
-	 "caption", "url", "type", "language", "modtime", "size", "extract"
-	-->
-    <method name="GetDocumentInfo">
-      <annotation name="de.berlios.Pinot.GetDocumentInfo" value="pinotDBus"/>
-      <arg type="u" name="docId" direction="in"/>
-      <arg type="a(ss)" name="fields" direction="out"/>
-    </method>
-    <!--
-	Sets information about a document.
-	 docId: the document's ID
-	 fields : array of (s name, s value) structures with name one of
-	 "caption", "url", "type", "language", "modtime", "size", "extract"
-	-->
-    <method name="SetDocumentInfo">
-      <annotation name="de.berlios.Pinot.SetDocumentInfo" value="pinotDBus"/>
-      <arg type="u" name="docId" direction="in"/>
-      <arg type="a(ss)" name="fields" direction="in"/>
-      <arg type="u" name="docId" direction="out"/>
-    </method>
-    <!--
-	Queries the index.
-	 engineType : engine type (defaults to "xapian"). See pinot-search(1) for a list of supported types
-	 engineName : engine name (defaults to "~/.pinot/daemon"). See pinot-search(1) for examples
-	 searchText : search text, as would be entered in Pinot's live query field
-	 startDoc: the first result to return, starting from 0
-	 maxHits: the maximum number of hits desired
-	 estimatedHits: an estimate of the total number of hits
-	 hitsList: hit properties
-	-->
-    <method name="Query">
-      <annotation name="de.berlios.Pinot.Query" value="pinotDBus"/>
-      <arg type="s" name="engineType" direction="in" />
-      <arg type="s" name="engineName" direction="in" />
-      <arg type="s" name="searchText" direction="in" />
-      <arg type="u" name="startDoc" direction="in" />
-      <arg type="u" name="maxHits" direction="in" />
-      <arg type="u" name="estimatedHits" direction="out" />
-      <arg type="aa(ss)" name="hitsList" direction="out" />
-    </method>
-    <!--
-	Queries the index.
-	 searchText : search text, as would be entered in Pinot's live query field
-	 maxHits: the maximum number of hits desired
-	 docIds: array of document IDs
-	 docIdsCount: the number of document IDs in the array
-        WARNING: this method is obsolete
-	-->
-    <method name="SimpleQuery">
-      <annotation name="de.berlios.Pinot.SimpleQuery" value="pinotDBus"/>
-      <arg type="s" name="searchText" direction="in" />
-      <arg type="u" name="maxHits" direction="in" />
-      <arg type="as" name="docIds" direction="out" />
-    </method>
-    <!--
-	Updates a document.
-	 docId: the document's ID
-	-->
-    <method name="UpdateDocument">
-      <annotation name="de.berlios.Pinot.UpdateDocument" value="pinotDBus"/>
-      <arg type="u" name="docId" direction="in"/>
-      <arg type="u" name="docId" direction="out"/>
-    </method>
-  </interface>
-</node>

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/configure.in	2009-02-01 11:04:31 UTC (rev 1530)
@@ -439,8 +439,8 @@
 AC_CHECK_FUNCS(getloadavg)
 AC_CHECK_FUNCS(pipe)
 
-AC_OUTPUT( pinot.spec UI/GTK2/src/de.berlios.Pinot.service Makefile \
+AC_OUTPUT( pinot.spec Core/de.berlios.Pinot.service Makefile \
 	Utils/Makefile Tokenize/Makefile SQL/Makefile po/Makefile.in Collect/Makefile \
 	IndexSearch/Google/Makefile IndexSearch/Xapian/Makefile IndexSearch/XesamGLib/Makefile \
-	IndexSearch/Makefile Monitor/Makefile UI/GTK2/src/Makefile )
+	IndexSearch/Makefile Monitor/Makefile Core/Makefile UI/GTK2/src/Makefile )
 

Modified: trunk/po/POTFILES.in
===================================================================
--- trunk/po/POTFILES.in	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/po/POTFILES.in	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,5 +1,12 @@
 # List of source files containing translatable strings.
-UI/GTK2/src/DaemonState.cpp
+Core/DaemonState.cpp
+Core/OnDiskHandler.cpp
+Core/pinot-dbus-daemon.cc
+Core/PinotSettings.cpp
+Core/PinotUtils.cpp
+Core/ServerThreads.cpp
+Core/UniqueApplication.cpp
+Core/WorkerThreads.cpp
 UI/GTK2/src/EnginesTree.cpp
 UI/GTK2/src/indexDialog.cc
 UI/GTK2/src/indexDialog_glade.cc
@@ -14,11 +21,7 @@
 UI/GTK2/src/mainWindow_glade.cc
 UI/GTK2/src/ModelColumns.cpp
 UI/GTK2/src/Notebook.cpp
-UI/GTK2/src/OnDiskHandler.cpp
 UI/GTK2/src/pinot.cc
-UI/GTK2/src/pinot-dbus-daemon.cc
-UI/GTK2/src/PinotSettings.cpp
-UI/GTK2/src/PinotUtils.cpp
 UI/GTK2/src/prefsWindow.cc
 UI/GTK2/src/prefsWindow_glade.cc
 UI/GTK2/src/propertiesDialog.cc
@@ -28,4 +31,3 @@
 UI/GTK2/src/ResultsTree.cpp
 UI/GTK2/src/statisticsDialog.cc
 UI/GTK2/src/statisticsDialog_glade.cc
-UI/GTK2/src/WorkerThreads.cpp



From fabricecolin at mail.berlios.de  Sun Feb  1 12:48:33 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 1 Feb 2009 12:48:33 +0100
Subject: [Pinot-svn] r1531 - in trunk: Core UI/GTK2/src
Message-ID: <200902011148.n11BmXmK014882@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-01 12:47:02 +0100 (Sun, 01 Feb 2009)
New Revision: 1531

Added:
   trunk/Core/pinot-dbus-daemon.cpp
   trunk/UI/GTK2/src/EnginesTree.cc
   trunk/UI/GTK2/src/EnginesTree.hh
   trunk/UI/GTK2/src/IndexPage.cc
   trunk/UI/GTK2/src/IndexPage.hh
   trunk/UI/GTK2/src/ModelColumns.cc
   trunk/UI/GTK2/src/ModelColumns.hh
   trunk/UI/GTK2/src/Notebook.cc
   trunk/UI/GTK2/src/Notebook.hh
   trunk/UI/GTK2/src/ResultsTree.cc
   trunk/UI/GTK2/src/ResultsTree.hh
Removed:
   trunk/Core/pinot-dbus-daemon.cc
   trunk/UI/GTK2/src/EnginesTree.cpp
   trunk/UI/GTK2/src/EnginesTree.h
   trunk/UI/GTK2/src/IndexPage.cpp
   trunk/UI/GTK2/src/IndexPage.h
   trunk/UI/GTK2/src/ModelColumns.cpp
   trunk/UI/GTK2/src/ModelColumns.h
   trunk/UI/GTK2/src/Notebook.cpp
   trunk/UI/GTK2/src/Notebook.h
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/ResultsTree.h
Modified:
   trunk/Core/Makefile.am
   trunk/UI/GTK2/src/Makefile.am
   trunk/UI/GTK2/src/importDialog.hh
   trunk/UI/GTK2/src/indexDialog.hh
   trunk/UI/GTK2/src/mainWindow.hh
   trunk/UI/GTK2/src/prefsWindow.hh
   trunk/UI/GTK2/src/propertiesDialog.hh
   trunk/UI/GTK2/src/queryDialog.hh
   trunk/UI/GTK2/src/statisticsDialog.hh
Log:
Use the same naming conventions as glademm where appropriate.


Modified: trunk/Core/Makefile.am
===================================================================
--- trunk/Core/Makefile.am	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/Core/Makefile.am	2009-02-01 11:47:02 UTC (rev 1531)
@@ -20,9 +20,6 @@
 	UniqueApplication.cpp \
 	WorkerThreads.cpp
 
-pinot_dbus_daemon_SOURCES = \
-	pinot-dbus-daemon.cc
-
 if HAVE_DBUS
 bin_PROGRAMS = pinot-dbus-daemon
 endif
@@ -58,3 +55,7 @@
 	@GLIBMM_LIBS@ @DBUS_LIBS@ @GTHREAD_LIBS@ @XML_LIBS@ \
 	@HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
 
+pinot_dbus_daemon_SOURCES = pinot-dbus-daemon.cpp
+
+pinot_index_DEPENDENCIES = libCore.la
+

Deleted: trunk/Core/pinot-dbus-daemon.cc
===================================================================
--- trunk/Core/pinot-dbus-daemon.cc	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/Core/pinot-dbus-daemon.cc	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,754 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <stdlib.h>
-#include <libintl.h>
-#include <getopt.h>
-#include <sys/time.h>
-#include <sys/resource.h>
-#include <sys/types.h>
-#include <signal.h>
-#include <unistd.h>
-#include <errno.h>
-#include <iostream>
-#include <sstream>
-#include <fstream>
-#include <cstring>
-#include <sigc++/sigc++.h>
-#include <glibmm.h>
-#include <glibmm/thread.h>
-#include <glibmm/ustring.h>
-#include <glibmm/miscutils.h>
-#include <glibmm/convert.h>
-
-#include "config.h"
-#include "NLS.h"
-#include "FilterFactory.h"
-#include "Languages.h"
-#include "MIMEScanner.h"
-#include "ModuleFactory.h"
-#include "ActionQueue.h"
-#include "CrawlHistory.h"
-#include "MetaDataBackup.h"
-#include "QueryHistory.h"
-#include "ViewHistory.h"
-#include "DownloaderInterface.h"
-#include "DaemonState.h"
-#include "PinotSettings.h"
-#include "ServerThreads.h"
-#include "UniqueApplication.h"
-
-using namespace std;
-
-static ofstream g_outputFile;
-static string g_pidFileName;
-static streambuf *g_coutBuf = NULL;
-static streambuf *g_cerrBuf = NULL;
-static struct option g_longOptions[] = {
-	{"fullscan", 0, 0, 'f'},
-	{"help", 0, 0, 'h'},
-	{"ignore-version", 0, 0, 'i'},
-	{"priority", 1, 0, 'p'},
-	{"reindex", 0, 0, 'r'},
-	{"version", 0, 0, 'v'},
-	{0, 0, 0, 0}
-};
-static const char *g_pinotDBusService = "de.berlios.Pinot";
-static const char *g_pinotDBusObjectPath = "/de/berlios/Pinot";
-static void unregisteredHandler(DBusConnection *pConnection, void *pData);
-static DBusHandlerResult messageHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData);
-static DBusObjectPathVTable g_callVTable = {
-	(DBusObjectPathUnregisterFunction)unregisteredHandler,
-        (DBusObjectPathMessageFunction)messageHandler,
-	NULL,
-};
-static Glib::RefPtr<Glib::MainLoop> g_refMainLoop;
-
-static void closeAll(void)
-{
-	cout << "Exiting..." << endl;
-
-	// Close everything
-	ModuleFactory::unloadModules();
-	Dijon::FilterFactory::unloadFilters();
-	Dijon::HtmlFilter::shutdown();
-
-	// Restore the stream buffers
-	if (g_coutBuf != NULL)
-	{
-		cout.rdbuf(g_coutBuf);
-	}
-	if (g_cerrBuf != NULL)
-	{
-		cerr.rdbuf(g_cerrBuf);
-	}
-	g_outputFile.close();
-	if (g_pidFileName.empty() == false)
-	{
-		unlink(g_pidFileName.c_str());
-	}
-
-	DownloaderInterface::shutdown();
-	MIMEScanner::shutdown();
-}
-
-static void quitAll(int sigNum)
-{
-	if (g_refMainLoop->is_running() == true)
-	{
-		cout << "Quitting..." << endl;
-
-		g_refMainLoop->quit();
-	}
-}
-
-static DBusHandlerResult filterHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
-{
-	DaemonState *pServer = (DaemonState *)pData;
-
-#ifdef DEBUG
-	cout << "filterHandler: called" << endl;
-#endif
-	// Are we about to be disconnected ?
-	if (dbus_message_is_signal(pMessage, DBUS_INTERFACE_LOCAL, "Disconnected") == TRUE)
-	{
-#ifdef DEBUG
-		cout << "filterHandler: received Disconnected" << endl;
-#endif
-		if (pServer != NULL)
-		{
-			pServer->set_flag(DaemonState::DISCONNECTED);
-		}
-		quitAll(0);
-	}
-	else if (dbus_message_is_signal(pMessage, DBUS_INTERFACE_DBUS, "NameOwnerChanged") == TRUE)
-	{
-#ifdef DEBUG
-		cout << "filterHandler: received NameOwnerChanged" << endl;
-#endif
-	}
-	// The first two signals are specified by the freedesktop.org Power Management spec v0.1 and v0.2
-	else if ((dbus_message_is_signal(pMessage, "org.freedesktop.PowerManagement", "BatteryStateChanged") == TRUE) ||
-		(dbus_message_is_signal(pMessage, "org.freedesktop.PowerManagement", "OnBatteryChanged") == TRUE) ||
-		(dbus_message_is_signal(pMessage, "org.gnome.PowerManager", "OnAcChanged") == TRUE))
-	{
-		DBusError error;
-		gboolean onBattery = FALSE;
-
-#ifdef DEBUG
-		cout << "filterHandler: received OnBatteryChanged" << endl;
-#endif
-		dbus_error_init(&error);
-		if ((dbus_message_get_args(pMessage, &error,
-			DBUS_TYPE_BOOLEAN, &onBattery,
-			DBUS_TYPE_INVALID) == TRUE) &&
-			(pData != NULL))
-		{
-			if (dbus_message_is_signal(pMessage, "org.gnome.PowerManager", "OnAcChanged") == TRUE)
-			{
-				// This tells us if we are on AC, not on battery
-				if (onBattery == TRUE)
-				{
-					onBattery = FALSE;
-				}
-				else
-				{
-					onBattery = TRUE;
-				}
-			}
-
-			if (onBattery == TRUE)
-			{
-				// We are now on battery
-				if (pServer != NULL)
-				{
-					pServer->set_flag(DaemonState::ON_BATTERY);
-					pServer->stop_crawling();
-				}
-
-				cout << "System is now on battery" << endl;
-			}
-			else
-			{
-				// Back on-line
-				if (pServer != NULL)
-				{
-					pServer->reset_flag(DaemonState::ON_BATTERY);
-					pServer->start_crawling();
-				}
-
-				cout << "System is now on AC" << endl;
-			}
-		}
-		dbus_error_free(&error);
-	}
-
-	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-}
-
-static void unregisteredHandler(DBusConnection *pConnection, void *pData)
-{
-#ifdef DEBUG
-	cout << "unregisteredHandler: called" << endl;
-#endif
-}
-
-static DBusHandlerResult messageHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
-{
-	DaemonState *pServer = (DaemonState *)pData;
-
-	if ((pConnection != NULL) &&
-		(pMessage != NULL))
-	{
-		dbus_connection_ref(pConnection);
-		dbus_message_ref(pMessage);
-
-		if (pServer != NULL)
-		{
-			DBusServletInfo *pInfo = new DBusServletInfo(pConnection, pMessage);
-
-			pServer->start_thread(new DBusServletThread(pServer, pInfo));
-		}
-	}
-
-	return DBUS_HANDLER_RESULT_HANDLED;
-}
-
-static bool getBatteryState(DBusGConnection *pBus, const string &name, const string &path,
-	const string &method, gboolean &result)
-{
-	bool callSuccess = true;
-
-	if ((pBus == NULL) ||
-		(name.empty() == true) ||
-		(path.empty() == true) ||
-		(method.empty() == true))
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = dbus_g_proxy_new_for_name(pBus, name.c_str(),
-		path.c_str(), name.c_str());
-	if (pBusProxy == NULL)
-	{
-		return false;
-	}
-
-	GError *pError = NULL;
-	if (dbus_g_proxy_call(pBusProxy, method.c_str(), &pError,
-		G_TYPE_INVALID,
-		G_TYPE_BOOLEAN, &result,
-		G_TYPE_INVALID) == FALSE)
-	{
-		if (pError != NULL)
-		{
-			cerr << "Couldn't get battery state: " << pError->message << endl;
-			g_error_free(pError);
-		}
-
-		callSuccess = false;
-	}
-
-	g_object_unref(pBusProxy);
-
-	return callSuccess;
-}
-
-int main(int argc, char **argv)
-{
-	int longOptionIndex = 0, priority = 15;
-	bool resetHistory = false;
-	bool resetLabels = false;
-	bool fullScan = false;
-	bool reindex = false;
-	bool ignoreVersion = false;
-
-	// Look at the options
-	int optionChar = getopt_long(argc, argv, "fhip:rv", g_longOptions, &longOptionIndex);
-	while (optionChar != -1)
-	{
-		switch (optionChar)
-		{
-			case 'f':
-				fullScan = true;
-				break;
-			case 'h':
-				// Help
-				cout << "pinot-dbus-daemon - D-Bus search and index daemon\n\n"
-					<< "Usage: pinot-dbus-daemon [OPTIONS]\n\n"
-					<< "Options:\n"
-					<< "  -f, --fullscan	force a full scan\n"
-					<< "  -h, --help		display this help and exit\n"
-					<< "  -i, --ignore-version	ignore the index version number\n"
-					<< "  -p, --priority	set the daemon's priority (default 15)\n"
-					<< "  -r, --reindex		force a reindex\n"
-					<< "  -v, --version		output version information and exit\n"
-					<< "\nReport bugs to " << PACKAGE_BUGREPORT << endl;
-				return EXIT_SUCCESS;
-			case 'i':
-				ignoreVersion = true;
-				break;
-			case 'p':
-				if (optarg != NULL)
-				{
-					int newPriority = atoi(optarg);
-					if ((newPriority >= -20) &&
-						(newPriority < 20))
-					{
-						priority = newPriority;
-					}
-				}
-				break;
-			case 'r':
-				reindex = true;
-				break;
-			case 'v':
-				cout << "pinot-dbus-daemon - " << PACKAGE_STRING << "\n\n" 
-					<< "This is free software.  You may redistribute copies of it under the terms of\n"
-					<< "the GNU General Public License <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>.\n"
-					<< "There is NO WARRANTY, to the extent permitted by law." << endl;
-				return EXIT_SUCCESS;
-			default:
-				return EXIT_FAILURE;
-		}
-
-		// Next option
-		optionChar = getopt_long(argc, argv, "fhip:rv", g_longOptions, &longOptionIndex);
-	}
-
-#if defined(ENABLE_NLS)
-	bindtextdomain(GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
-	bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
-	textdomain(GETTEXT_PACKAGE);
-#endif //ENABLE_NLS
-
-	// Initialize threads support before doing anything else
-	if (Glib::thread_supported() == false)
-	{
-		Glib::thread_init();
-	}
-	// Initialize the GType and the D-Bus thread system
-	g_type_init();
-#if DBUS_NUM_VERSION > 1000000
-	dbus_threads_init_default();
-#endif
-	dbus_g_thread_init();
-
-	g_refMainLoop = Glib::MainLoop::create();
-	Glib::set_application_name("Pinot DBus Daemon");
-
-	// This should make Xapian use Flint rather than Quartz
-	Glib::setenv("XAPIAN_PREFER_FLINT", "1");
-
-	// Make the locale follow the environment variables
-	setlocale(LC_ALL, "");
-	char *pLocale = setlocale(LC_ALL, NULL);
-	if (pLocale != NULL)
-	{
-		string locale(pLocale);
-
-		if (locale != "C")
-		{
-			bool appendUTF8 = false;
-
-			string::size_type pos = locale.find_last_of(".");
-			if ((pos != string::npos) &&
-				((strcasecmp(locale.substr(pos).c_str(), ".utf8") != 0) &&
-				(strcasecmp(locale.substr(pos).c_str(), ".utf-8") != 0)))
-			{
-				locale.resize(pos);
-				appendUTF8 = true;
-			}
-
-			if (appendUTF8 == true)
-			{
-				locale += ".UTF-8";
-
-				pLocale = setlocale(LC_ALL, locale.c_str());
-				if (pLocale != NULL)
-				{
-#ifdef DEBUG
-					cout << "Changed locale to " << pLocale << endl;
-#endif
-				}
-			}
-		}
-	}
-
-	// Make sure only one instance runs
-	UniqueApplication uniqueApp("de.berlios.PinotDBusDaemon");
-	string confDirectory = PinotSettings::getConfigurationDirectory();
-	g_pidFileName = confDirectory + "/pinot-dbus-daemon.pid";
-	if (chdir(confDirectory.c_str()) == 0)
-	{
-		if (uniqueApp.isRunning(g_pidFileName, "pinot-dbus-daemon") == true)
-		{
-			return EXIT_SUCCESS;
-		}
-
-		// Redirect cout and cerr to a file
-		string fileName(confDirectory);
-		fileName += "/pinot-dbus-daemon.log";
-		g_outputFile.open(fileName.c_str());
-		g_coutBuf = cout.rdbuf();
-		g_cerrBuf = cerr.rdbuf();
-		cout.rdbuf(g_outputFile.rdbuf());
-		cerr.rdbuf(g_outputFile.rdbuf());
-	}
-	else
-	{
-		// We can't rely on the PID file
-		if (uniqueApp.isRunning() == true)
-		{
-			return EXIT_SUCCESS;
-		}
-	}
-
-	// This will create the necessary directories on the first run
-	PinotSettings &settings = PinotSettings::getInstance();
-	// This is the daemon so disable client-side code 
-	settings.enableClientMode(false);
-
-	// Initialize utility classes
-	if (MIMEScanner::initialize(PinotSettings::getHomeDirectory() + "/.local",
-		string(SHARED_MIME_INFO_PREFIX)) == false)
-	{
-		cerr << "Couldn't load MIME settings" << endl;
-	}
-	DownloaderInterface::initialize();
-	// Load tokenizer libraries, if any
-	Dijon::HtmlFilter::initialize();
-	Dijon::FilterFactory::loadFilters(string(LIBDIR) + "/pinot/filters");
-	Dijon::FilterFactory::loadFilters(confDirectory + "/filters");
-	// Load backends, if any
-	ModuleFactory::loadModules(string(LIBDIR) + "/pinot/backends");
-	ModuleFactory::loadModules(confDirectory + "/backends");
-
-	// Localize language names
-	Languages::setIntlName(0, _("Unknown"));
-	Languages::setIntlName(1, _("Danish"));
-	Languages::setIntlName(2, _("Dutch"));
-	Languages::setIntlName(3, _("English"));
-	Languages::setIntlName(4, _("Finnish"));
-	Languages::setIntlName(5, _("French"));
-	Languages::setIntlName(6, _("German"));
-	Languages::setIntlName(7, _("Hungarian"));
-	Languages::setIntlName(8, _("Italian"));
-	Languages::setIntlName(9, _("Norwegian"));
-	Languages::setIntlName(10, _("Portuguese"));
-	Languages::setIntlName(11, _("Romanian"));
-	Languages::setIntlName(12, _("Russian"));
-	Languages::setIntlName(13, _("Spanish"));
-	Languages::setIntlName(14, _("Swedish"));
-	Languages::setIntlName(15, _("Turkish"));
-
-	// Load the settings
-	settings.load(PinotSettings::LOAD_ALL);
-
-	// Catch interrupts
-#ifdef HAVE_SIGACTION
-	struct sigaction newAction;
-	sigemptyset(&newAction.sa_mask);
-	newAction.sa_flags = 0;
-	newAction.sa_handler = quitAll;
-	sigaction(SIGINT, &newAction, NULL);
-	sigaction(SIGQUIT, &newAction, NULL);
-	sigaction(SIGTERM, &newAction, NULL);
-#else
-	signal(SIGINT, quitAll);
-#ifdef SIGQUIT
-	signal(SIGQUIT, quitAll);
-#endif
-	signal(SIGTERM, quitAll);
-#endif
-
-	// Open the daemon index in read-write mode 
-	bool wasObsoleteFormat = false;
-	if (ModuleFactory::openOrCreateIndex(settings.m_defaultBackend, settings.m_daemonIndexLocation, wasObsoleteFormat, false) == false)
-	{
-		cerr << "Couldn't open index " << settings.m_daemonIndexLocation << endl;
-		return EXIT_FAILURE;
-	}
-	if (wasObsoleteFormat == true)
-	{
-		resetHistory = resetLabels = true;
-	}
-
-	// Do the same for the history database
-	PinotSettings::checkHistoryDatabase();
-	string historyDatabase(settings.getHistoryDatabaseName());
-	if ((historyDatabase.empty() == true) ||
-		(ActionQueue::create(historyDatabase) == false) ||
-		(CrawlHistory::create(historyDatabase) == false) ||
-		(MetaDataBackup::create(historyDatabase) == false) ||
-		(QueryHistory::create(historyDatabase) == false) ||
-		(ViewHistory::create(historyDatabase) == false))
-	{
-		cerr << "Couldn't create history database " << historyDatabase << endl;
-		return EXIT_FAILURE;
-	}
-	else
-	{
-		ActionQueue actionQueue(historyDatabase, Glib::get_application_name());
-		QueryHistory queryHistory(historyDatabase);
-		ViewHistory viewHistory(historyDatabase);
-		time_t timeNow = time(NULL);
-		unsigned int actionsCount = actionQueue.getItemsCount(ActionQueue::INDEX);
-
-		// Don't expire actions left from last time
-		actionsCount += actionQueue.getItemsCount(ActionQueue::UNINDEX);
-		cout << actionsCount << " actions left" << endl;
-
-		// Expire the rest
-		queryHistory.expireItems(timeNow);
-		viewHistory.expireItems(timeNow);
-	}
-
-	atexit(closeAll);
-
-	// Change the daemon's priority
-	if (setpriority(PRIO_PROCESS, 0, priority) == -1)
-	{
-		cerr << "Couldn't set scheduling priority to " << priority << endl;
-	}
-#ifdef DEBUG
-	else cout << "Set priority to " << priority << endl;
-#endif
-
-	GError *pError = NULL;
-	DBusGConnection *pBus = dbus_g_bus_get(DBUS_BUS_SESSION, &pError);
-	if (pBus == NULL)
-	{
-		if (pError != NULL)
-		{
-			cerr << "Couldn't open bus connection: " << pError->message << endl;
-			if (pError->message != NULL)
-			{
-				cerr << "Error is " << pError->message << endl;
-			}
-			g_error_free(pError);
-		}
-
-		return EXIT_FAILURE;
-	}
-
-	DBusConnection *pConnection = dbus_g_connection_get_connection(pBus);
-	if (pConnection == NULL)
-	{
-		cerr << "Couldn't get connection" << endl;
-		return EXIT_FAILURE;
-	}
-
-	DBusError error;
-	DaemonState server;
-	IndexInterface *pIndex = NULL;
-
-	dbus_error_init(&error);
-	dbus_connection_set_exit_on_disconnect(pConnection, FALSE);
-	dbus_connection_setup_with_g_main(pConnection, NULL);
-
-	if (dbus_connection_register_object_path(pConnection, g_pinotDBusObjectPath,
-		&g_callVTable, &server) == TRUE)
-	{
-		// Request to be identified by this name
-		// FIXME: flags are currently broken ?
-		dbus_bus_request_name(pConnection, g_pinotDBusService, 0, &error);
-		if (dbus_error_is_set(&error) == FALSE)
-		{
-			// See power management signals
-			dbus_bus_add_match(pConnection,
-				"type='signal',interface='org.freedesktop.PowerManagement'", &error);
-			dbus_bus_add_match(pConnection,
-				"type='signal',interface='org.gnome.PowerManager'", &error);
-
-			dbus_connection_add_filter(pConnection,
-				(DBusHandleMessageFunction)filterHandler, &server, NULL);
-		}
-		else
-		{
-			cerr << "Couldn't obtain name " << g_pinotDBusService << endl;
-			if (error.message != NULL)
-			{
-				cerr << "Error is " << error.message << endl;
-			}
-		}
-
-		try
-		{
-			set<string> labels;
-			bool gotLabels = false;
-			bool onBattery = false;
-
-			pIndex = settings.getIndex(settings.m_daemonIndexLocation);
-			if (pIndex != NULL)
-			{
-				string indexVersion(pIndex->getMetadata("version"));
-
-				gotLabels = pIndex->getLabels(labels);
-
-				// What version is the index at ?
-				if (indexVersion.empty() == true)
-				{
-					indexVersion = "0.0";
-				}
-				if (ignoreVersion == true)
-				{
-					// Better reset labels, they may have been lost too
-					resetLabels = true;
-				}
-				else if (indexVersion < PINOT_INDEX_MIN_VERSION)
-				{
-					cout << "Upgrading index from version " << indexVersion << " to " << VERSION << endl;
-
-					reindex = true;
-				}
-				if (reindex == true)
-				{
-					// Reset the index so that all documents are reindexed
-					pIndex->reset();
-
-					cout << "Reset index" << endl;
-
-					resetHistory = resetLabels = true;
-				}
-
-				pIndex->setMetadata("version", VERSION);
-				pIndex->setMetadata("dbus-status", "Running");
-			}
-
-			if (resetHistory == true)
-			{
-				CrawlHistory history(historyDatabase);
-				map<unsigned int, string> sources;
-
-				// Reset the history
-				history.getSources(sources);
-				for (std::map<unsigned int, string>::iterator sourceIter = sources.begin();
-					sourceIter != sources.end(); ++sourceIter)
-				{
-					history.deleteItems(sourceIter->first);
-					history.deleteSource(sourceIter->first);
-				}
-
-				cout << "Reset crawler history" << endl;
-			}
-
-			if ((resetLabels == true) &&
-				(pIndex != NULL))
-			{
-				// Re-apply the labels list
-				if (gotLabels == false)
-				{
-					// If this is an upgrade from a version < 0.80, the labels list
-					// needs to be pulled from the configuration file
-					pIndex->setLabels(settings.m_labels, true);
-
-					cout << "Set labels as per the configuration file" << endl;
-				}
-				else
-				{
-					pIndex->setLabels(labels, true);
-				}
-			}
-
-			// Connect to the quit signal
-			server.getQuitSignal().connect(sigc::ptr_fun(&quitAll));
-
-			// Connect to threads' finished signal
-			server.connect();
-
-			// Try and get the battery state
-			gboolean result = FALSE;
-			if ((getBatteryState(pBus, "org.freedesktop.PowerManagement",
-				"/org/freedesktop/PowerManagement", "GetOnBattery", result) == true) ||
-				(getBatteryState(pBus, "org.freedesktop.PowerManagement",
-				"/org/freedesktop/PowerManagement", "GetBatteryState", result) == true))
-			{
-				if (result == TRUE)
-				{
-					onBattery = true;
-				}
-			}
-			else if (getBatteryState(pBus, "org.gnome.PowerManager",
-				"/org/gnome/PowerManager", "GetOnAc", result) == true)
-			{
-				if (result == FALSE)
-				{
-					onBattery = true;
-				}
-			}
-			if (onBattery == true)
-			{
-				// We are on battery
-				server.set_flag(DaemonState::ON_BATTERY);
-				server.stop_crawling();
-
-				cout << "System is on battery" << endl;
-			}
-
-			server.start(fullScan, reindex);
-
-			// Run the main loop
-			g_refMainLoop->run();
-
-		}
-		catch (const Glib::Exception &e)
-		{
-			cerr << e.what() << endl;
-			return EXIT_FAILURE;
-		}
-		catch (const char *pMsg)
-		{
-			cerr << pMsg << endl;
-			return EXIT_FAILURE;
-		}
-		catch (...)
-		{
-			cerr << "Unknown exception" << endl;
-			return EXIT_FAILURE;
-		}
-	}
-	else
-	{
-		cerr << "Couldn't register object path" << endl;
-	}
-	dbus_error_free(&error);
-
-	if (pIndex != NULL)
-	{
-		if (server.is_flag_set(DaemonState::DISCONNECTED) == true)
-		{
-			pIndex->setMetadata("dbus-status", "Disconnected");
-		}
-		else if (server.is_flag_set(DaemonState::STOPPED) == true)
-		{
-			pIndex->setMetadata("dbus-status", "Stopped");
-		}
-		else
-		{
-			pIndex->setMetadata("dbus-status", "");
-		}
-		delete pIndex;
-	}
-
-	// Stop everything
-	server.disconnect();
-	server.stop_threads();
-
-	return EXIT_SUCCESS;
-}

Copied: trunk/Core/pinot-dbus-daemon.cpp (from rev 1530, trunk/Core/pinot-dbus-daemon.cc)

Copied: trunk/UI/GTK2/src/EnginesTree.cc (from rev 1529, trunk/UI/GTK2/src/EnginesTree.cpp)
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/EnginesTree.cc	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,407 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+#include <gtkmm/alignment.h>
+#include <gtkmm/box.h>
+#include <gtkmm/buttonbox.h>
+#include <gtkmm/image.h>
+#include <gtkmm/label.h>
+#include <gtkmm/stock.h>
+#include <gtkmm/textbuffer.h>
+
+#include "Url.h"
+#include "config.h"
+#include "NLS.h"
+#include "ModuleFactory.h"
+#include "PinotSettings.h"
+#include "PinotUtils.h"
+#include "EnginesTree.hh"
+
+using namespace std;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+EnginesTree::EnginesTree(VBox *enginesVbox, PinotSettings &settings) :
+	TreeView(),
+	m_settings(settings)
+{
+	ScrolledWindow *enginesScrolledwindow = manage(new ScrolledWindow());
+
+	// This is the actual engines tree
+	set_events(Gdk::BUTTON_PRESS_MASK);
+	set_flags(CAN_FOCUS);
+	set_headers_clickable(true);
+	set_headers_visible(true);
+	set_reorderable(false);
+	set_enable_search(false);
+	get_selection()->set_mode(SELECTION_MULTIPLE);
+	enginesScrolledwindow->set_flags(CAN_FOCUS);
+	enginesScrolledwindow->set_shadow_type(SHADOW_NONE);
+	enginesScrolledwindow->set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
+	enginesScrolledwindow->property_window_placement().set_value(CORNER_TOP_LEFT);
+	enginesScrolledwindow->add(*this);
+
+	// Position the scrolled window
+	enginesVbox->pack_start(*enginesScrolledwindow, Gtk::PACK_EXPAND_WIDGET, 0);
+
+	// Associate the columns model to the engines tree
+	m_refStore = TreeStore::create(m_enginesColumns);
+	set_model(m_refStore);
+
+	TreeViewColumn *pColumn = new TreeViewColumn(_("Search Engines"));
+	// Pack an icon renderer for engines icons
+	CellRendererPixbuf *pIconRenderer = new CellRendererPixbuf();
+	pColumn->pack_start(*manage(pIconRenderer), false);
+	pColumn->set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &EnginesTree::renderEngineIcon));
+	pColumn->pack_end(m_enginesColumns.m_name, false);
+	pColumn->set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
+	append_column(*manage(pColumn));
+
+	// Handle button presses
+	signal_button_press_event().connect_notify(sigc::mem_fun(*this, &EnginesTree::onButtonPressEvent));
+	// Control which rows can be selected
+	get_selection()->set_select_function(sigc::mem_fun(*this, &EnginesTree::onSelectionSelect));
+	// Listen for style changes
+	signal_style_changed().connect_notify(sigc::mem_fun(*this, &EnginesTree::onStyleChanged));
+
+	// Render the icons
+	m_engineFolderIconPixbuf = render_icon(Stock::DIRECTORY, ICON_SIZE_MENU, "MetaSE-pinot");
+
+	// Populate
+	populate();
+
+	// Show all
+	show();
+	enginesScrolledwindow->show();
+}
+
+EnginesTree::~EnginesTree()
+{
+}
+
+void EnginesTree::save(void)
+{
+	std::map<string, bool> &channels = m_settings.getSearchEnginesChannels();
+
+	TreeModel::Children children = m_refStore->children();
+	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
+	{
+		TreeModel::Row row = *iter;
+
+		if (row[m_enginesColumns.m_type] == EnginesModelColumns::ENGINE_FOLDER)
+		{
+			ustring channelName(row[m_enginesColumns.m_name]);
+			TreeModel::Path channelPath = m_refStore->get_path(iter);
+
+			std::map<string, bool>::iterator channelIter = channels.find(from_utf8(channelName));
+			if (channelIter != channels.end())
+			{
+#ifdef DEBUG
+				cout << "EnginesTree::save: " << channelName << " is " << row_expanded(channelPath) << endl;
+#endif
+				channelIter->second = row_expanded(channelPath);
+			}
+		}
+	}
+}
+
+void EnginesTree::renderEngineIcon(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (renderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *pIconRenderer = dynamic_cast<CellRendererPixbuf*>(renderer);
+	if (pIconRenderer != NULL)
+	{
+		// Is this an engine folder ?
+		if (row[m_enginesColumns.m_type] == EnginesModelColumns::ENGINE_FOLDER)
+		{
+			pIconRenderer->property_pixbuf() = m_engineFolderIconPixbuf;
+		}
+		else
+		{
+			pIconRenderer->property_pixbuf().reset_value();
+		}
+	}
+}
+
+//
+// Handles button presses.
+//
+void EnginesTree::onButtonPressEvent(GdkEventButton *ev)
+{
+	list<TreeModel::Path> selectedEngines = get_selection()->get_selected_rows();
+	// If there are more than one row selected, don't bother
+	if (selectedEngines.size() != 1)
+	{
+		return;
+	}
+
+	list<TreeModel::Path>::iterator enginePath = selectedEngines.begin();
+	if (enginePath == selectedEngines.end())
+	{
+		return;
+	}
+
+	TreeModel::iterator engineIter = m_refStore->get_iter(*enginePath);
+	TreeModel::Row engineRow = *engineIter;
+
+	// Check for double clicks
+	if (ev->type == GDK_2BUTTON_PRESS)
+	{
+#ifdef DEBUG
+		cout << "EnginesTree::onButtonPressEvent: double click on button " << ev->button << endl;
+#endif
+		// Make sure the engine is an external index
+		EnginesModelColumns::EngineType engineType = engineRow[m_enginesColumns.m_type];
+		if (engineType == EnginesModelColumns::INDEX_ENGINE)
+		{
+			ustring name = engineRow[m_enginesColumns.m_name];
+			ustring location = engineRow[m_enginesColumns.m_option];
+
+			m_signalDoubleClick(name, location);
+		}
+		else
+		{
+			// Is the row already expanded ?
+			if (row_expanded(*enginePath) == false)
+			{
+				// Expand it
+				expand_row(*enginePath, true);
+			}
+			else
+			{
+				// Collapse it
+				collapse_row(*enginePath);
+			}
+		}
+	}
+}
+
+//
+// Handles attempts to select rows.
+//
+bool EnginesTree::onSelectionSelect(const RefPtr<TreeModel>& model,
+		const TreeModel::Path& node_path, bool path_currently_selected)
+{
+	// All nodes can be selected
+	return true;
+}
+
+//
+// Handles GTK style changes.
+//
+void EnginesTree::onStyleChanged(const RefPtr<Style> &previous_style)
+{
+#ifdef DEBUG
+	cout << "EnginesTree::onStyleChanged: called" << endl;
+#endif
+	// FIXME: find better icons :-)
+	m_engineFolderIconPixbuf = render_icon(Stock::DIRECTORY, ICON_SIZE_MENU, "MetaSE-pinot");
+}
+
+//
+// Gets a list of selected items.
+//
+list<TreeModel::Path> EnginesTree::getSelection(void)
+{
+	return get_selection()->get_selected_rows();
+}
+
+/// Gets an iterator.
+TreeModel::iterator EnginesTree::getIter(TreeModel::Path enginePath)
+{
+	return m_refStore->get_iter(enginePath);
+}
+
+/// Gets the column record.
+EnginesModelColumns &EnginesTree::getColumnRecord(void)
+{
+	return m_enginesColumns;
+}
+
+//
+// Populate the tree.
+//
+void EnginesTree::populate(bool indexesOnly)
+{
+	set<ModuleProperties> engines;
+	ustring currentUserChannel(_("Current User"));
+	TreeModel::Row row;
+	TreeModel::iterator folderIter, localIter;
+	bool createCurrentUserChannel = true;
+
+	// Reset the whole tree
+	get_selection()->unselect_all();
+	m_refStore->clear();
+
+	// Populate the tree with search engines
+	std::map<string, bool> &channels = m_settings.getSearchEnginesChannels();
+	for (std::map<string, bool>::const_iterator channelIter = channels.begin();
+		channelIter != channels.end(); ++channelIter)
+	{
+		string channelName(channelIter->first);
+		bool isExpanded(channelIter->second);
+
+		// Enumerate search engines for this channel
+		engines.clear();
+		m_settings.getSearchEngines(engines, channelName);
+
+		if (engines.empty() == true)
+		{
+			continue;
+		}
+
+		folderIter = m_refStore->append();
+		row = *folderIter;
+
+		// Is this the current user channel ?
+		if (channelName == "X-Current-User-Channel")
+		{
+			row[m_enginesColumns.m_name] = currentUserChannel;
+		}
+		else
+		{
+			row[m_enginesColumns.m_name] = to_utf8(channelName);
+		}
+		row[m_enginesColumns.m_engineName] = "internal-folder";
+		row[m_enginesColumns.m_option] = "";
+		row[m_enginesColumns.m_type] = EnginesModelColumns::ENGINE_FOLDER;
+
+		if (channelName == "X-Current-User-Channel")
+		{
+			localIter = folderIter;
+			createCurrentUserChannel = false;
+		}
+		else if (createCurrentUserChannel == false)
+		{
+			// The current user channel stays at the bottom
+			m_refStore->iter_swap(folderIter, localIter);
+		}
+
+		std::set<ModuleProperties>::const_iterator engineIter = engines.begin();
+		for (; engineIter != engines.end(); ++engineIter)
+		{
+			ustring engineType(to_utf8(engineIter->m_name));
+			ustring engineName(to_utf8(engineIter->m_longName));
+
+			if (ModuleFactory::isSupported(engineType, true) == true)
+			{
+				// Skip this, it's only usable through a local engine
+				continue;
+			}
+
+			TreeModel::iterator iter = m_refStore->append(folderIter->children());
+			row = *iter;
+
+			row[m_enginesColumns.m_name] = engineName;
+			row[m_enginesColumns.m_engineName] = engineType;
+			row[m_enginesColumns.m_option] = engineIter->m_option;
+			row[m_enginesColumns.m_type] = EnginesModelColumns::WEB_ENGINE;
+#ifdef DEBUG
+			cout << "EnginesTree::populate: engine " << engineName << "/" << engineType << " at " << engineIter->m_option << endl;
+#endif
+		}
+
+		TreeModel::Path folderPath = m_refStore->get_path(folderIter);
+		if (isExpanded == true)
+		{
+			// Expand this
+			expand_row(folderPath, true);
+		}
+		else
+		{
+			// Collapse this
+			collapse_row(folderPath);
+		}
+	}
+
+	if (createCurrentUserChannel == true)
+	{
+		localIter = m_refStore->append();
+		row = *localIter;
+		row[m_enginesColumns.m_name] = currentUserChannel;
+		row[m_enginesColumns.m_engineName] = "internal-folder";
+		row[m_enginesColumns.m_option] = "";
+		row[m_enginesColumns.m_type] = EnginesModelColumns::ENGINE_FOLDER;
+	}
+
+	// Local engines
+	for (set<PinotSettings::IndexProperties>::const_iterator indexIter = m_settings.getIndexes().begin();
+		indexIter != m_settings.getIndexes().end(); ++indexIter)
+	{
+		EnginesModelColumns::EngineType indexType = EnginesModelColumns::INDEX_ENGINE;
+
+		if (indexIter->m_internal == true)
+		{
+			indexType = EnginesModelColumns::INTERNAL_INDEX_ENGINE;
+		}
+
+		TreeModel::iterator iter = m_refStore->append(localIter->children());
+		TreeModel::Row childRow = *iter;
+		childRow[m_enginesColumns.m_name] = indexIter->m_name;
+		childRow[m_enginesColumns.m_engineName] = m_settings.m_defaultBackend;
+		childRow[m_enginesColumns.m_option] = indexIter->m_location;
+		childRow[m_enginesColumns.m_type] = indexType;
+	}
+
+	// Expand this
+	expand_row(m_refStore->get_path(localIter), true);
+
+	get_selection()->select(localIter);
+}
+
+//
+// Clear the tree.
+//
+void EnginesTree::clear(void)
+{
+	// Unselect engines
+	get_selection()->unselect_all();
+
+	// Remove existing rows in the tree
+	TreeModel::Children children = m_refStore->children();
+	if (children.empty() == false)
+	{
+		TreeModel::Children::iterator iter = children.begin();
+		while (iter != children.end())
+		{
+			// Erase this row
+			m_refStore->erase(*iter);
+
+			// Get the new first row
+			children = m_refStore->children();
+			iter = children.begin();
+		}
+		m_refStore->clear();
+	}
+}
+
+//
+// Returns the double-click signal.
+//
+sigc::signal2<void, string, string>& EnginesTree::getDoubleClickSignal(void)
+{
+	return m_signalDoubleClick;
+}


Property changes on: trunk/UI/GTK2/src/EnginesTree.cc
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: trunk/UI/GTK2/src/EnginesTree.cpp
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.cpp	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/EnginesTree.cpp	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,407 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <iostream>
-#include <gtkmm/alignment.h>
-#include <gtkmm/box.h>
-#include <gtkmm/buttonbox.h>
-#include <gtkmm/image.h>
-#include <gtkmm/label.h>
-#include <gtkmm/stock.h>
-#include <gtkmm/textbuffer.h>
-
-#include "Url.h"
-#include "config.h"
-#include "NLS.h"
-#include "ModuleFactory.h"
-#include "PinotSettings.h"
-#include "PinotUtils.h"
-#include "EnginesTree.h"
-
-using namespace std;
-using namespace Glib;
-using namespace Gdk;
-using namespace Gtk;
-
-EnginesTree::EnginesTree(VBox *enginesVbox, PinotSettings &settings) :
-	TreeView(),
-	m_settings(settings)
-{
-	ScrolledWindow *enginesScrolledwindow = manage(new ScrolledWindow());
-
-	// This is the actual engines tree
-	set_events(Gdk::BUTTON_PRESS_MASK);
-	set_flags(CAN_FOCUS);
-	set_headers_clickable(true);
-	set_headers_visible(true);
-	set_reorderable(false);
-	set_enable_search(false);
-	get_selection()->set_mode(SELECTION_MULTIPLE);
-	enginesScrolledwindow->set_flags(CAN_FOCUS);
-	enginesScrolledwindow->set_shadow_type(SHADOW_NONE);
-	enginesScrolledwindow->set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
-	enginesScrolledwindow->property_window_placement().set_value(CORNER_TOP_LEFT);
-	enginesScrolledwindow->add(*this);
-
-	// Position the scrolled window
-	enginesVbox->pack_start(*enginesScrolledwindow, Gtk::PACK_EXPAND_WIDGET, 0);
-
-	// Associate the columns model to the engines tree
-	m_refStore = TreeStore::create(m_enginesColumns);
-	set_model(m_refStore);
-
-	TreeViewColumn *pColumn = new TreeViewColumn(_("Search Engines"));
-	// Pack an icon renderer for engines icons
-	CellRendererPixbuf *pIconRenderer = new CellRendererPixbuf();
-	pColumn->pack_start(*manage(pIconRenderer), false);
-	pColumn->set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &EnginesTree::renderEngineIcon));
-	pColumn->pack_end(m_enginesColumns.m_name, false);
-	pColumn->set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
-	append_column(*manage(pColumn));
-
-	// Handle button presses
-	signal_button_press_event().connect_notify(sigc::mem_fun(*this, &EnginesTree::onButtonPressEvent));
-	// Control which rows can be selected
-	get_selection()->set_select_function(sigc::mem_fun(*this, &EnginesTree::onSelectionSelect));
-	// Listen for style changes
-	signal_style_changed().connect_notify(sigc::mem_fun(*this, &EnginesTree::onStyleChanged));
-
-	// Render the icons
-	m_engineFolderIconPixbuf = render_icon(Stock::DIRECTORY, ICON_SIZE_MENU, "MetaSE-pinot");
-
-	// Populate
-	populate();
-
-	// Show all
-	show();
-	enginesScrolledwindow->show();
-}
-
-EnginesTree::~EnginesTree()
-{
-}
-
-void EnginesTree::save(void)
-{
-	std::map<string, bool> &channels = m_settings.getSearchEnginesChannels();
-
-	TreeModel::Children children = m_refStore->children();
-	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
-	{
-		TreeModel::Row row = *iter;
-
-		if (row[m_enginesColumns.m_type] == EnginesModelColumns::ENGINE_FOLDER)
-		{
-			ustring channelName(row[m_enginesColumns.m_name]);
-			TreeModel::Path channelPath = m_refStore->get_path(iter);
-
-			std::map<string, bool>::iterator channelIter = channels.find(from_utf8(channelName));
-			if (channelIter != channels.end())
-			{
-#ifdef DEBUG
-				cout << "EnginesTree::save: " << channelName << " is " << row_expanded(channelPath) << endl;
-#endif
-				channelIter->second = row_expanded(channelPath);
-			}
-		}
-	}
-}
-
-void EnginesTree::renderEngineIcon(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &iter)
-{
-	TreeModel::Row row = *iter;
-
-	if (renderer == NULL)
-	{
-		return;
-	}
-
-	CellRendererPixbuf *pIconRenderer = dynamic_cast<CellRendererPixbuf*>(renderer);
-	if (pIconRenderer != NULL)
-	{
-		// Is this an engine folder ?
-		if (row[m_enginesColumns.m_type] == EnginesModelColumns::ENGINE_FOLDER)
-		{
-			pIconRenderer->property_pixbuf() = m_engineFolderIconPixbuf;
-		}
-		else
-		{
-			pIconRenderer->property_pixbuf().reset_value();
-		}
-	}
-}
-
-//
-// Handles button presses.
-//
-void EnginesTree::onButtonPressEvent(GdkEventButton *ev)
-{
-	list<TreeModel::Path> selectedEngines = get_selection()->get_selected_rows();
-	// If there are more than one row selected, don't bother
-	if (selectedEngines.size() != 1)
-	{
-		return;
-	}
-
-	list<TreeModel::Path>::iterator enginePath = selectedEngines.begin();
-	if (enginePath == selectedEngines.end())
-	{
-		return;
-	}
-
-	TreeModel::iterator engineIter = m_refStore->get_iter(*enginePath);
-	TreeModel::Row engineRow = *engineIter;
-
-	// Check for double clicks
-	if (ev->type == GDK_2BUTTON_PRESS)
-	{
-#ifdef DEBUG
-		cout << "EnginesTree::onButtonPressEvent: double click on button " << ev->button << endl;
-#endif
-		// Make sure the engine is an external index
-		EnginesModelColumns::EngineType engineType = engineRow[m_enginesColumns.m_type];
-		if (engineType == EnginesModelColumns::INDEX_ENGINE)
-		{
-			ustring name = engineRow[m_enginesColumns.m_name];
-			ustring location = engineRow[m_enginesColumns.m_option];
-
-			m_signalDoubleClick(name, location);
-		}
-		else
-		{
-			// Is the row already expanded ?
-			if (row_expanded(*enginePath) == false)
-			{
-				// Expand it
-				expand_row(*enginePath, true);
-			}
-			else
-			{
-				// Collapse it
-				collapse_row(*enginePath);
-			}
-		}
-	}
-}
-
-//
-// Handles attempts to select rows.
-//
-bool EnginesTree::onSelectionSelect(const RefPtr<TreeModel>& model,
-		const TreeModel::Path& node_path, bool path_currently_selected)
-{
-	// All nodes can be selected
-	return true;
-}
-
-//
-// Handles GTK style changes.
-//
-void EnginesTree::onStyleChanged(const RefPtr<Style> &previous_style)
-{
-#ifdef DEBUG
-	cout << "EnginesTree::onStyleChanged: called" << endl;
-#endif
-	// FIXME: find better icons :-)
-	m_engineFolderIconPixbuf = render_icon(Stock::DIRECTORY, ICON_SIZE_MENU, "MetaSE-pinot");
-}
-
-//
-// Gets a list of selected items.
-//
-list<TreeModel::Path> EnginesTree::getSelection(void)
-{
-	return get_selection()->get_selected_rows();
-}
-
-/// Gets an iterator.
-TreeModel::iterator EnginesTree::getIter(TreeModel::Path enginePath)
-{
-	return m_refStore->get_iter(enginePath);
-}
-
-/// Gets the column record.
-EnginesModelColumns &EnginesTree::getColumnRecord(void)
-{
-	return m_enginesColumns;
-}
-
-//
-// Populate the tree.
-//
-void EnginesTree::populate(bool indexesOnly)
-{
-	set<ModuleProperties> engines;
-	ustring currentUserChannel(_("Current User"));
-	TreeModel::Row row;
-	TreeModel::iterator folderIter, localIter;
-	bool createCurrentUserChannel = true;
-
-	// Reset the whole tree
-	get_selection()->unselect_all();
-	m_refStore->clear();
-
-	// Populate the tree with search engines
-	std::map<string, bool> &channels = m_settings.getSearchEnginesChannels();
-	for (std::map<string, bool>::const_iterator channelIter = channels.begin();
-		channelIter != channels.end(); ++channelIter)
-	{
-		string channelName(channelIter->first);
-		bool isExpanded(channelIter->second);
-
-		// Enumerate search engines for this channel
-		engines.clear();
-		m_settings.getSearchEngines(engines, channelName);
-
-		if (engines.empty() == true)
-		{
-			continue;
-		}
-
-		folderIter = m_refStore->append();
-		row = *folderIter;
-
-		// Is this the current user channel ?
-		if (channelName == "X-Current-User-Channel")
-		{
-			row[m_enginesColumns.m_name] = currentUserChannel;
-		}
-		else
-		{
-			row[m_enginesColumns.m_name] = to_utf8(channelName);
-		}
-		row[m_enginesColumns.m_engineName] = "internal-folder";
-		row[m_enginesColumns.m_option] = "";
-		row[m_enginesColumns.m_type] = EnginesModelColumns::ENGINE_FOLDER;
-
-		if (channelName == "X-Current-User-Channel")
-		{
-			localIter = folderIter;
-			createCurrentUserChannel = false;
-		}
-		else if (createCurrentUserChannel == false)
-		{
-			// The current user channel stays at the bottom
-			m_refStore->iter_swap(folderIter, localIter);
-		}
-
-		std::set<ModuleProperties>::const_iterator engineIter = engines.begin();
-		for (; engineIter != engines.end(); ++engineIter)
-		{
-			ustring engineType(to_utf8(engineIter->m_name));
-			ustring engineName(to_utf8(engineIter->m_longName));
-
-			if (ModuleFactory::isSupported(engineType, true) == true)
-			{
-				// Skip this, it's only usable through a local engine
-				continue;
-			}
-
-			TreeModel::iterator iter = m_refStore->append(folderIter->children());
-			row = *iter;
-
-			row[m_enginesColumns.m_name] = engineName;
-			row[m_enginesColumns.m_engineName] = engineType;
-			row[m_enginesColumns.m_option] = engineIter->m_option;
-			row[m_enginesColumns.m_type] = EnginesModelColumns::WEB_ENGINE;
-#ifdef DEBUG
-			cout << "EnginesTree::populate: engine " << engineName << "/" << engineType << " at " << engineIter->m_option << endl;
-#endif
-		}
-
-		TreeModel::Path folderPath = m_refStore->get_path(folderIter);
-		if (isExpanded == true)
-		{
-			// Expand this
-			expand_row(folderPath, true);
-		}
-		else
-		{
-			// Collapse this
-			collapse_row(folderPath);
-		}
-	}
-
-	if (createCurrentUserChannel == true)
-	{
-		localIter = m_refStore->append();
-		row = *localIter;
-		row[m_enginesColumns.m_name] = currentUserChannel;
-		row[m_enginesColumns.m_engineName] = "internal-folder";
-		row[m_enginesColumns.m_option] = "";
-		row[m_enginesColumns.m_type] = EnginesModelColumns::ENGINE_FOLDER;
-	}
-
-	// Local engines
-	for (set<PinotSettings::IndexProperties>::const_iterator indexIter = m_settings.getIndexes().begin();
-		indexIter != m_settings.getIndexes().end(); ++indexIter)
-	{
-		EnginesModelColumns::EngineType indexType = EnginesModelColumns::INDEX_ENGINE;
-
-		if (indexIter->m_internal == true)
-		{
-			indexType = EnginesModelColumns::INTERNAL_INDEX_ENGINE;
-		}
-
-		TreeModel::iterator iter = m_refStore->append(localIter->children());
-		TreeModel::Row childRow = *iter;
-		childRow[m_enginesColumns.m_name] = indexIter->m_name;
-		childRow[m_enginesColumns.m_engineName] = m_settings.m_defaultBackend;
-		childRow[m_enginesColumns.m_option] = indexIter->m_location;
-		childRow[m_enginesColumns.m_type] = indexType;
-	}
-
-	// Expand this
-	expand_row(m_refStore->get_path(localIter), true);
-
-	get_selection()->select(localIter);
-}
-
-//
-// Clear the tree.
-//
-void EnginesTree::clear(void)
-{
-	// Unselect engines
-	get_selection()->unselect_all();
-
-	// Remove existing rows in the tree
-	TreeModel::Children children = m_refStore->children();
-	if (children.empty() == false)
-	{
-		TreeModel::Children::iterator iter = children.begin();
-		while (iter != children.end())
-		{
-			// Erase this row
-			m_refStore->erase(*iter);
-
-			// Get the new first row
-			children = m_refStore->children();
-			iter = children.begin();
-		}
-		m_refStore->clear();
-	}
-}
-
-//
-// Returns the double-click signal.
-//
-sigc::signal2<void, string, string>& EnginesTree::getDoubleClickSignal(void)
-{
-	return m_signalDoubleClick;
-}

Deleted: trunk/UI/GTK2/src/EnginesTree.h
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.h	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/EnginesTree.h	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,95 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _ENGINESTREE_HH
-#define _ENGINESTREE_HH
-
-#include <string>
-#include <vector>
-#include <set>
-#include <map>
-#include <sigc++/sigc++.h>
-#include <glibmm/refptr.h>
-#include <glibmm/ustring.h>
-#include <gdkmm/pixbuf.h>
-#include <gtkmm/box.h>
-#include <gtkmm/button.h>
-#include <gtkmm/menu.h>
-#include <gtkmm/scrolledwindow.h>
-#include <gtkmm/textview.h>
-#include <gtkmm/treestore.h>
-#include <gtkmm/treeview.h>
-#include <gtkmm/treeselection.h>
-
-#include "QueryProperties.h"
-#include "ModelColumns.h"
-#include "PinotSettings.h"
-
-class EnginesTree : public Gtk::TreeView
-{
-	public:
-		EnginesTree(Gtk::VBox *enginesVbox, PinotSettings &settings);
-		virtual ~EnginesTree();
-
-		/// Gets a list of selected items.
-		std::list<Gtk::TreeModel::Path> getSelection(void);
-
-		/// Gets an iterator.
-		Gtk::TreeModel::iterator getIter(Gtk::TreeModel::Path enginePath);
-
-		/// Gets the column record.
-		EnginesModelColumns &getColumnRecord(void);
-
-		/// Populate the tree.
-		void populate(bool indexesOnly = false);
-
-		/// Clear the tree.
-		void clear(void);
-
-		/// Save the tree's state.
-		void save(void);
-
-		/// Returns the double-click signal.
-		sigc::signal2<void, std::string, std::string>& getDoubleClickSignal(void);
-
-	protected:
-		Glib::RefPtr<Gtk::TreeStore> m_refStore;
-		PinotSettings &m_settings;
-		Glib::RefPtr<Gdk::Pixbuf> m_engineFolderIconPixbuf;
-		EnginesModelColumns m_enginesColumns;
-		sigc::signal2<void, std::string, std::string> m_signalDoubleClick;
-
-		void renderEngineIcon(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &iter);
-
-		/// Handles button presses.
-		void onButtonPressEvent(GdkEventButton *ev);
-
-		/// Handles attempts to select rows.
-		bool onSelectionSelect(const Glib::RefPtr<Gtk::TreeModel>& model,
-			const Gtk::TreeModel::Path& node_path, bool path_currently_selected);
-
-		/// Handles GTK style changes.
-		void onStyleChanged(const Glib::RefPtr<Gtk::Style> &previous_style);
-
-	private:
-		EnginesTree(const EnginesTree &other);
-		EnginesTree &operator=(const EnginesTree &other);
-
-};
-
-#endif // _ENGINESTREE_HH

Copied: trunk/UI/GTK2/src/EnginesTree.hh (from rev 1529, trunk/UI/GTK2/src/EnginesTree.h)
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/EnginesTree.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,95 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _ENGINESTREE_HH
+#define _ENGINESTREE_HH
+
+#include <string>
+#include <vector>
+#include <set>
+#include <map>
+#include <sigc++/sigc++.h>
+#include <glibmm/refptr.h>
+#include <glibmm/ustring.h>
+#include <gdkmm/pixbuf.h>
+#include <gtkmm/box.h>
+#include <gtkmm/button.h>
+#include <gtkmm/menu.h>
+#include <gtkmm/scrolledwindow.h>
+#include <gtkmm/textview.h>
+#include <gtkmm/treestore.h>
+#include <gtkmm/treeview.h>
+#include <gtkmm/treeselection.h>
+
+#include "QueryProperties.h"
+#include "PinotSettings.h"
+#include "ModelColumns.hh"
+
+class EnginesTree : public Gtk::TreeView
+{
+	public:
+		EnginesTree(Gtk::VBox *enginesVbox, PinotSettings &settings);
+		virtual ~EnginesTree();
+
+		/// Gets a list of selected items.
+		std::list<Gtk::TreeModel::Path> getSelection(void);
+
+		/// Gets an iterator.
+		Gtk::TreeModel::iterator getIter(Gtk::TreeModel::Path enginePath);
+
+		/// Gets the column record.
+		EnginesModelColumns &getColumnRecord(void);
+
+		/// Populate the tree.
+		void populate(bool indexesOnly = false);
+
+		/// Clear the tree.
+		void clear(void);
+
+		/// Save the tree's state.
+		void save(void);
+
+		/// Returns the double-click signal.
+		sigc::signal2<void, std::string, std::string>& getDoubleClickSignal(void);
+
+	protected:
+		Glib::RefPtr<Gtk::TreeStore> m_refStore;
+		PinotSettings &m_settings;
+		Glib::RefPtr<Gdk::Pixbuf> m_engineFolderIconPixbuf;
+		EnginesModelColumns m_enginesColumns;
+		sigc::signal2<void, std::string, std::string> m_signalDoubleClick;
+
+		void renderEngineIcon(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &iter);
+
+		/// Handles button presses.
+		void onButtonPressEvent(GdkEventButton *ev);
+
+		/// Handles attempts to select rows.
+		bool onSelectionSelect(const Glib::RefPtr<Gtk::TreeModel>& model,
+			const Gtk::TreeModel::Path& node_path, bool path_currently_selected);
+
+		/// Handles GTK style changes.
+		void onStyleChanged(const Glib::RefPtr<Gtk::Style> &previous_style);
+
+	private:
+		EnginesTree(const EnginesTree &other);
+		EnginesTree &operator=(const EnginesTree &other);
+
+};
+
+#endif // _ENGINESTREE_HH


Property changes on: trunk/UI/GTK2/src/EnginesTree.hh
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/UI/GTK2/src/IndexPage.cc (from rev 1529, trunk/UI/GTK2/src/IndexPage.cpp)
===================================================================
--- trunk/UI/GTK2/src/IndexPage.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/IndexPage.cc	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,286 @@
+/*
+ *  Copyright 2005,2006 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+#include <gtkmm/alignment.h>
+#include <gtkmm/buttonbox.h>
+#include <gtkmm/stock.h>
+#include <gtkmm/textbuffer.h>
+
+#include "config.h"
+#include "NLS.h"
+#include "PinotSettings.h"
+#include "PinotUtils.h"
+#include "IndexPage.hh"
+
+using namespace std;
+using namespace Glib;
+using namespace Gtk;
+
+IndexPage::IndexPage(const ustring &indexName, ResultsTree *pTree,
+	PinotSettings &settings) :
+	NotebookPageBox(indexName, NotebookPageBox::INDEX_PAGE, settings),
+	m_pQueryCombobox(NULL),
+	m_pBackButton(NULL),
+	m_pForwardButton(NULL),
+	m_docsCount(0),
+	m_firstDoc(0)
+{
+	m_pTree = pTree;
+	m_pQueryCombobox = manage(new ComboBoxText());
+
+	Image *image521 = manage(new Image(StockID("gtk-media-rewind"), IconSize(4)));
+	Label *label52 = manage(new Label(_("Show Previous")));
+	HBox *hbox45 = manage(new HBox(false, 2));
+	Alignment *alignment31 = manage(new Alignment(0.5, 0.5, 0, 0));
+	m_pBackButton = manage(new Button());
+
+	Image *image522 = manage(new Image(StockID("gtk-media-forward"), IconSize(4)));
+	Label *label53 = manage(new Label(_("Show Next")));
+	HBox *hbox46 = manage(new HBox(false, 2));
+	Alignment *alignment32 = manage(new Alignment(0.5, 0.5, 0, 0));
+	m_pForwardButton = manage(new Button());
+
+	HButtonBox *indexHbuttonbox = manage(new HButtonBox(BUTTONBOX_START, 0));
+	HBox *indexButtonsHbox = manage(new HBox(false, 0));
+
+	// Buttons
+	image521->set_alignment(0.5,0.5);
+	image521->set_padding(0,0);
+	label52->set_alignment(0.5,0.5);
+	label52->set_padding(0,0);
+	label52->set_justify(Gtk::JUSTIFY_LEFT);
+	label52->set_line_wrap(false);
+	label52->set_use_markup(false);
+	label52->set_selectable(false);
+	hbox45->pack_start(*image521, Gtk::PACK_SHRINK, 0);
+	hbox45->pack_start(*label52, Gtk::PACK_SHRINK, 0);
+	alignment31->add(*hbox45);
+	m_pBackButton->set_flags(Gtk::CAN_FOCUS);
+	m_pBackButton->set_flags(Gtk::CAN_DEFAULT);
+	m_pBackButton->set_relief(Gtk::RELIEF_NORMAL);
+	m_pBackButton->add(*alignment31);
+	image522->set_alignment(0.5,0.5);
+	image522->set_padding(0,0);
+	label53->set_alignment(0.5,0.5);
+	label53->set_padding(0,0);
+	label53->set_justify(Gtk::JUSTIFY_LEFT);
+	label53->set_line_wrap(false);
+	label53->set_use_markup(false);
+	label53->set_selectable(false);
+	hbox46->pack_start(*image522, Gtk::PACK_SHRINK, 0);
+	hbox46->pack_start(*label53, Gtk::PACK_SHRINK, 0);
+	alignment32->add(*hbox46);
+	m_pForwardButton->set_flags(Gtk::CAN_FOCUS);
+	m_pForwardButton->set_flags(Gtk::CAN_DEFAULT);
+	m_pForwardButton->set_relief(Gtk::RELIEF_NORMAL);
+	m_pForwardButton->add(*alignment32);
+
+	// Position everything
+	indexHbuttonbox->pack_start(*m_pBackButton);
+	indexHbuttonbox->pack_start(*m_pForwardButton);
+	indexButtonsHbox->pack_start(*m_pQueryCombobox, Gtk::PACK_SHRINK, 4);
+	indexButtonsHbox->pack_start(*indexHbuttonbox, Gtk::PACK_EXPAND_WIDGET, 4);
+	pack_start(*indexButtonsHbox, Gtk::PACK_SHRINK, 4);
+	if (pTree != NULL)
+	{
+		pack_start(*pTree->getResultsScrolledWindow());
+	}
+
+	// Populate
+	populateQueryCombobox("");
+
+	// Connect the signals
+	m_pBackButton->signal_clicked().connect(
+		sigc::mem_fun(*this, &IndexPage::onBackClicked));
+	m_pForwardButton->signal_clicked().connect(
+		sigc::mem_fun(*this, &IndexPage::onForwardClicked));
+
+	// Disable the buttons until something is being shown
+	m_pBackButton->set_sensitive(false);
+	m_pForwardButton->set_sensitive(false);
+
+	// Show all
+	m_pQueryCombobox->show();
+	image521->show();
+	label52->show();
+	hbox45->show();
+	alignment31->show();
+	m_pBackButton->show();
+	image522->show();
+	label53->show();
+	hbox46->show();
+	alignment32->show();
+	m_pForwardButton->show();
+	indexHbuttonbox->show();
+	indexButtonsHbox->show();
+	show();
+}
+
+IndexPage::~IndexPage()
+{
+}
+
+void IndexPage::onQueryChanged(void)
+{
+	m_queryName = m_pQueryCombobox->get_active_text();
+	if (m_pQueryCombobox->get_active_row_number() == 0)
+	{
+		m_queryName.clear();
+	}
+	m_signalQueryChanged(m_title, m_queryName);
+}
+
+void IndexPage::onBackClicked(void)
+{
+	m_signalBackClicked(m_title);
+}
+
+void IndexPage::onForwardClicked(void)
+{
+	m_signalForwardClicked(m_title);
+}
+
+//
+// Returns the name of the current query.
+//
+ustring IndexPage::getQueryName(void) const
+{
+	return m_queryName;
+}
+
+//
+// Populates the queries list.
+//
+void IndexPage::populateQueryCombobox(const string &queryName)
+{
+	// Disconnect the changed signal
+	if (m_queryChangedConnection.connected() == true)
+	{
+		m_queryChangedConnection.disconnect();
+	}
+
+	m_pQueryCombobox->clear_items();
+
+	m_pQueryCombobox->append_text(_("All"));
+
+	const std::map<string, QueryProperties> &queries = m_settings.getQueries();
+	for (std::map<string, QueryProperties>::const_iterator queryIter = queries.begin();
+		queryIter != queries.end(); ++queryIter)
+	{
+		m_pQueryCombobox->append_text(to_utf8(queryIter->first));
+	}
+
+	// Reconnect the signal
+	m_queryChangedConnection = m_pQueryCombobox->signal_changed().connect(
+		sigc::mem_fun(*this, &IndexPage::onQueryChanged));
+
+	if (queryName.empty() == false)
+	{
+		m_pQueryCombobox->set_active_text(queryName);
+		m_queryName = queryName;
+	}
+	else
+	{
+		m_pQueryCombobox->set_active(0);
+		m_queryName.clear();
+	}
+}
+
+//
+// Updates the state of the index buttons.
+//
+void IndexPage::updateButtonsState(unsigned int maxDocsCount)
+{
+#ifdef DEBUG
+	cout << "IndexPage::updateButtonsState: counts " << m_firstDoc
+		<< " " << m_docsCount << endl;
+#endif
+	if (m_firstDoc >= maxDocsCount)
+	{
+		m_pBackButton->set_sensitive(true);
+	}
+	else
+	{
+		m_pBackButton->set_sensitive(false);
+	}
+	if (m_docsCount > m_firstDoc + maxDocsCount)
+	{
+		m_pForwardButton->set_sensitive(true);
+	}
+	else
+	{
+		m_pForwardButton->set_sensitive(false);
+	}
+}
+
+//
+// Gets the number of documents.
+//
+unsigned int IndexPage::getDocumentsCount(void) const
+{
+	return m_docsCount;
+}
+
+//
+// Sets the number of documents.
+//
+void IndexPage::setDocumentsCount(unsigned int docsCount)
+{
+	m_docsCount = docsCount;
+}
+
+//
+// Gets the first document.
+//
+unsigned int IndexPage::getFirstDocument(void) const
+{
+	return m_firstDoc;
+}
+
+//
+// Sets the first document.
+//
+void IndexPage::setFirstDocument(unsigned int startDoc)
+{
+	m_firstDoc = startDoc;
+}
+
+//
+// Returns the changed query signal.
+//
+sigc::signal2<void, ustring, ustring>& IndexPage::getQueryChangedSignal(void)
+{
+	return m_signalQueryChanged;
+}
+
+//
+// Returns the back button clicked signal.
+//
+sigc::signal1<void, ustring>& IndexPage::getBackClickedSignal(void)
+{
+	return m_signalBackClicked;
+}
+
+//
+// Returns the forward button clicked signal.
+//
+sigc::signal1<void, ustring>& IndexPage::getForwardClickedSignal(void)
+{
+	return m_signalForwardClicked;
+}


Property changes on: trunk/UI/GTK2/src/IndexPage.cc
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: trunk/UI/GTK2/src/IndexPage.cpp
===================================================================
--- trunk/UI/GTK2/src/IndexPage.cpp	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/IndexPage.cpp	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,286 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <iostream>
-#include <gtkmm/alignment.h>
-#include <gtkmm/buttonbox.h>
-#include <gtkmm/stock.h>
-#include <gtkmm/textbuffer.h>
-
-#include "config.h"
-#include "NLS.h"
-#include "PinotSettings.h"
-#include "PinotUtils.h"
-#include "IndexPage.h"
-
-using namespace std;
-using namespace Glib;
-using namespace Gtk;
-
-IndexPage::IndexPage(const ustring &indexName, ResultsTree *pTree,
-	PinotSettings &settings) :
-	NotebookPageBox(indexName, NotebookPageBox::INDEX_PAGE, settings),
-	m_pQueryCombobox(NULL),
-	m_pBackButton(NULL),
-	m_pForwardButton(NULL),
-	m_docsCount(0),
-	m_firstDoc(0)
-{
-	m_pTree = pTree;
-	m_pQueryCombobox = manage(new ComboBoxText());
-
-	Image *image521 = manage(new Image(StockID("gtk-media-rewind"), IconSize(4)));
-	Label *label52 = manage(new Label(_("Show Previous")));
-	HBox *hbox45 = manage(new HBox(false, 2));
-	Alignment *alignment31 = manage(new Alignment(0.5, 0.5, 0, 0));
-	m_pBackButton = manage(new Button());
-
-	Image *image522 = manage(new Image(StockID("gtk-media-forward"), IconSize(4)));
-	Label *label53 = manage(new Label(_("Show Next")));
-	HBox *hbox46 = manage(new HBox(false, 2));
-	Alignment *alignment32 = manage(new Alignment(0.5, 0.5, 0, 0));
-	m_pForwardButton = manage(new Button());
-
-	HButtonBox *indexHbuttonbox = manage(new HButtonBox(BUTTONBOX_START, 0));
-	HBox *indexButtonsHbox = manage(new HBox(false, 0));
-
-	// Buttons
-	image521->set_alignment(0.5,0.5);
-	image521->set_padding(0,0);
-	label52->set_alignment(0.5,0.5);
-	label52->set_padding(0,0);
-	label52->set_justify(Gtk::JUSTIFY_LEFT);
-	label52->set_line_wrap(false);
-	label52->set_use_markup(false);
-	label52->set_selectable(false);
-	hbox45->pack_start(*image521, Gtk::PACK_SHRINK, 0);
-	hbox45->pack_start(*label52, Gtk::PACK_SHRINK, 0);
-	alignment31->add(*hbox45);
-	m_pBackButton->set_flags(Gtk::CAN_FOCUS);
-	m_pBackButton->set_flags(Gtk::CAN_DEFAULT);
-	m_pBackButton->set_relief(Gtk::RELIEF_NORMAL);
-	m_pBackButton->add(*alignment31);
-	image522->set_alignment(0.5,0.5);
-	image522->set_padding(0,0);
-	label53->set_alignment(0.5,0.5);
-	label53->set_padding(0,0);
-	label53->set_justify(Gtk::JUSTIFY_LEFT);
-	label53->set_line_wrap(false);
-	label53->set_use_markup(false);
-	label53->set_selectable(false);
-	hbox46->pack_start(*image522, Gtk::PACK_SHRINK, 0);
-	hbox46->pack_start(*label53, Gtk::PACK_SHRINK, 0);
-	alignment32->add(*hbox46);
-	m_pForwardButton->set_flags(Gtk::CAN_FOCUS);
-	m_pForwardButton->set_flags(Gtk::CAN_DEFAULT);
-	m_pForwardButton->set_relief(Gtk::RELIEF_NORMAL);
-	m_pForwardButton->add(*alignment32);
-
-	// Position everything
-	indexHbuttonbox->pack_start(*m_pBackButton);
-	indexHbuttonbox->pack_start(*m_pForwardButton);
-	indexButtonsHbox->pack_start(*m_pQueryCombobox, Gtk::PACK_SHRINK, 4);
-	indexButtonsHbox->pack_start(*indexHbuttonbox, Gtk::PACK_EXPAND_WIDGET, 4);
-	pack_start(*indexButtonsHbox, Gtk::PACK_SHRINK, 4);
-	if (pTree != NULL)
-	{
-		pack_start(*pTree->getResultsScrolledWindow());
-	}
-
-	// Populate
-	populateQueryCombobox("");
-
-	// Connect the signals
-	m_pBackButton->signal_clicked().connect(
-		sigc::mem_fun(*this, &IndexPage::onBackClicked));
-	m_pForwardButton->signal_clicked().connect(
-		sigc::mem_fun(*this, &IndexPage::onForwardClicked));
-
-	// Disable the buttons until something is being shown
-	m_pBackButton->set_sensitive(false);
-	m_pForwardButton->set_sensitive(false);
-
-	// Show all
-	m_pQueryCombobox->show();
-	image521->show();
-	label52->show();
-	hbox45->show();
-	alignment31->show();
-	m_pBackButton->show();
-	image522->show();
-	label53->show();
-	hbox46->show();
-	alignment32->show();
-	m_pForwardButton->show();
-	indexHbuttonbox->show();
-	indexButtonsHbox->show();
-	show();
-}
-
-IndexPage::~IndexPage()
-{
-}
-
-void IndexPage::onQueryChanged(void)
-{
-	m_queryName = m_pQueryCombobox->get_active_text();
-	if (m_pQueryCombobox->get_active_row_number() == 0)
-	{
-		m_queryName.clear();
-	}
-	m_signalQueryChanged(m_title, m_queryName);
-}
-
-void IndexPage::onBackClicked(void)
-{
-	m_signalBackClicked(m_title);
-}
-
-void IndexPage::onForwardClicked(void)
-{
-	m_signalForwardClicked(m_title);
-}
-
-//
-// Returns the name of the current query.
-//
-ustring IndexPage::getQueryName(void) const
-{
-	return m_queryName;
-}
-
-//
-// Populates the queries list.
-//
-void IndexPage::populateQueryCombobox(const string &queryName)
-{
-	// Disconnect the changed signal
-	if (m_queryChangedConnection.connected() == true)
-	{
-		m_queryChangedConnection.disconnect();
-	}
-
-	m_pQueryCombobox->clear_items();
-
-	m_pQueryCombobox->append_text(_("All"));
-
-	const std::map<string, QueryProperties> &queries = m_settings.getQueries();
-	for (std::map<string, QueryProperties>::const_iterator queryIter = queries.begin();
-		queryIter != queries.end(); ++queryIter)
-	{
-		m_pQueryCombobox->append_text(to_utf8(queryIter->first));
-	}
-
-	// Reconnect the signal
-	m_queryChangedConnection = m_pQueryCombobox->signal_changed().connect(
-		sigc::mem_fun(*this, &IndexPage::onQueryChanged));
-
-	if (queryName.empty() == false)
-	{
-		m_pQueryCombobox->set_active_text(queryName);
-		m_queryName = queryName;
-	}
-	else
-	{
-		m_pQueryCombobox->set_active(0);
-		m_queryName.clear();
-	}
-}
-
-//
-// Updates the state of the index buttons.
-//
-void IndexPage::updateButtonsState(unsigned int maxDocsCount)
-{
-#ifdef DEBUG
-	cout << "IndexPage::updateButtonsState: counts " << m_firstDoc
-		<< " " << m_docsCount << endl;
-#endif
-	if (m_firstDoc >= maxDocsCount)
-	{
-		m_pBackButton->set_sensitive(true);
-	}
-	else
-	{
-		m_pBackButton->set_sensitive(false);
-	}
-	if (m_docsCount > m_firstDoc + maxDocsCount)
-	{
-		m_pForwardButton->set_sensitive(true);
-	}
-	else
-	{
-		m_pForwardButton->set_sensitive(false);
-	}
-}
-
-//
-// Gets the number of documents.
-//
-unsigned int IndexPage::getDocumentsCount(void) const
-{
-	return m_docsCount;
-}
-
-//
-// Sets the number of documents.
-//
-void IndexPage::setDocumentsCount(unsigned int docsCount)
-{
-	m_docsCount = docsCount;
-}
-
-//
-// Gets the first document.
-//
-unsigned int IndexPage::getFirstDocument(void) const
-{
-	return m_firstDoc;
-}
-
-//
-// Sets the first document.
-//
-void IndexPage::setFirstDocument(unsigned int startDoc)
-{
-	m_firstDoc = startDoc;
-}
-
-//
-// Returns the changed query signal.
-//
-sigc::signal2<void, ustring, ustring>& IndexPage::getQueryChangedSignal(void)
-{
-	return m_signalQueryChanged;
-}
-
-//
-// Returns the back button clicked signal.
-//
-sigc::signal1<void, ustring>& IndexPage::getBackClickedSignal(void)
-{
-	return m_signalBackClicked;
-}
-
-//
-// Returns the forward button clicked signal.
-//
-sigc::signal1<void, ustring>& IndexPage::getForwardClickedSignal(void)
-{
-	return m_signalForwardClicked;
-}

Deleted: trunk/UI/GTK2/src/IndexPage.h
===================================================================
--- trunk/UI/GTK2/src/IndexPage.h	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/IndexPage.h	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,103 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _INDEXPAGE_HH
-#define _INDEXPAGE_HH
-
-#include <string>
-#include <vector>
-#include <sigc++/sigc++.h>
-#include <glibmm/refptr.h>
-#include <glibmm/ustring.h>
-#include <gtkmm/menu.h>
-#include <gdkmm/pixbuf.h>
-#include <gtkmm/comboboxtext.h>
-#include <gtkmm/button.h>
-#include <gtkmm/scrolledwindow.h>
-#include <gtkmm/textview.h>
-#include <gtkmm/treeview.h>
-#include <gtkmm/treeselection.h>
-
-#include "QueryProperties.h"
-#include "ResultsTree.h"
-#include "Notebook.h"
-#include "PinotSettings.h"
-
-class IndexPage : public NotebookPageBox
-{
-	public:
-		IndexPage(const Glib::ustring &indexName, ResultsTree *pTree,
-			PinotSettings &settings);
-		virtual ~IndexPage();
-
-		/// Returns the name of the current query.
-		Glib::ustring getQueryName(void) const;
-
-		/// Populates the queries list.
-		void populateQueryCombobox(const std::string &queryName);
-
-		/// Updates the state of the index buttons.
-		void updateButtonsState(unsigned int maxDocsCount);
-
-		/// Gets the number of documents.
-		unsigned int getDocumentsCount(void) const;
-
-		/// Sets the number of documents.
-		void setDocumentsCount(unsigned int docsCount);
-
-		/// Gets the first document.
-		unsigned int getFirstDocument(void) const;
-
-		/// Sets the first document.
-		void setFirstDocument(unsigned int startDoc);
-
-		/// Returns the changed query signal.
-		sigc::signal2<void, Glib::ustring, Glib::ustring>& getQueryChangedSignal(void);
-
-		/// Returns the back button clicked signal.
-		sigc::signal1<void, Glib::ustring>& getBackClickedSignal(void);
-
-		/// Returns the forward button clicked signal.
-		sigc::signal1<void, Glib::ustring>& getForwardClickedSignal(void);
-
-	protected:
-		Glib::ustring m_indexName;
-		Glib::ustring m_queryName;
-		Gtk::ComboBoxText *m_pQueryCombobox;
-		Gtk::Button *m_pBackButton;
-		Gtk::Button *m_pForwardButton;
-		unsigned int m_docsCount;
-		unsigned int m_firstDoc;
-		sigc::signal2<void, Glib::ustring, Glib::ustring> m_signalQueryChanged;
-		sigc::signal1<void, Glib::ustring> m_signalBackClicked;
-		sigc::signal1<void, Glib::ustring> m_signalForwardClicked;
-		sigc::connection m_queryChangedConnection;
-
-		void onQueryChanged(void);
-
-		void onBackClicked(void);
-
-		void onForwardClicked(void);
-
-	private:
-		IndexPage(const IndexPage &other);
-		IndexPage &operator=(const IndexPage &other);
-
-};
-
-#endif // _INDEXPAGE_HH

Copied: trunk/UI/GTK2/src/IndexPage.hh (from rev 1529, trunk/UI/GTK2/src/IndexPage.h)
===================================================================
--- trunk/UI/GTK2/src/IndexPage.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/IndexPage.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,103 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _INDEXPAGE_HH
+#define _INDEXPAGE_HH
+
+#include <string>
+#include <vector>
+#include <sigc++/sigc++.h>
+#include <glibmm/refptr.h>
+#include <glibmm/ustring.h>
+#include <gtkmm/menu.h>
+#include <gdkmm/pixbuf.h>
+#include <gtkmm/comboboxtext.h>
+#include <gtkmm/button.h>
+#include <gtkmm/scrolledwindow.h>
+#include <gtkmm/textview.h>
+#include <gtkmm/treeview.h>
+#include <gtkmm/treeselection.h>
+
+#include "QueryProperties.h"
+#include "PinotSettings.h"
+#include "ResultsTree.hh"
+#include "Notebook.hh"
+
+class IndexPage : public NotebookPageBox
+{
+	public:
+		IndexPage(const Glib::ustring &indexName, ResultsTree *pTree,
+			PinotSettings &settings);
+		virtual ~IndexPage();
+
+		/// Returns the name of the current query.
+		Glib::ustring getQueryName(void) const;
+
+		/// Populates the queries list.
+		void populateQueryCombobox(const std::string &queryName);
+
+		/// Updates the state of the index buttons.
+		void updateButtonsState(unsigned int maxDocsCount);
+
+		/// Gets the number of documents.
+		unsigned int getDocumentsCount(void) const;
+
+		/// Sets the number of documents.
+		void setDocumentsCount(unsigned int docsCount);
+
+		/// Gets the first document.
+		unsigned int getFirstDocument(void) const;
+
+		/// Sets the first document.
+		void setFirstDocument(unsigned int startDoc);
+
+		/// Returns the changed query signal.
+		sigc::signal2<void, Glib::ustring, Glib::ustring>& getQueryChangedSignal(void);
+
+		/// Returns the back button clicked signal.
+		sigc::signal1<void, Glib::ustring>& getBackClickedSignal(void);
+
+		/// Returns the forward button clicked signal.
+		sigc::signal1<void, Glib::ustring>& getForwardClickedSignal(void);
+
+	protected:
+		Glib::ustring m_indexName;
+		Glib::ustring m_queryName;
+		Gtk::ComboBoxText *m_pQueryCombobox;
+		Gtk::Button *m_pBackButton;
+		Gtk::Button *m_pForwardButton;
+		unsigned int m_docsCount;
+		unsigned int m_firstDoc;
+		sigc::signal2<void, Glib::ustring, Glib::ustring> m_signalQueryChanged;
+		sigc::signal1<void, Glib::ustring> m_signalBackClicked;
+		sigc::signal1<void, Glib::ustring> m_signalForwardClicked;
+		sigc::connection m_queryChangedConnection;
+
+		void onQueryChanged(void);
+
+		void onBackClicked(void);
+
+		void onForwardClicked(void);
+
+	private:
+		IndexPage(const IndexPage &other);
+		IndexPage &operator=(const IndexPage &other);
+
+};
+
+#endif // _INDEXPAGE_HH


Property changes on: trunk/UI/GTK2/src/IndexPage.hh
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: trunk/UI/GTK2/src/Makefile.am
===================================================================
--- trunk/UI/GTK2/src/Makefile.am	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/Makefile.am	2009-02-01 11:47:02 UTC (rev 1531)
@@ -17,11 +17,11 @@
 	queryDialog.hh \
 	statisticsDialog_glade.hh \
 	statisticsDialog.hh \
-	EnginesTree.h \
-	IndexPage.h \
-	ModelColumns.h \
-	Notebook.h \
-	ResultsTree.h
+	EnginesTree.hh \
+	IndexPage.hh \
+	ModelColumns.hh \
+	Notebook.hh \
+	ResultsTree.hh
 
 pinot_SOURCES = \
 	pinot.cc \
@@ -41,11 +41,11 @@
 	queryDialog.cc \
 	statisticsDialog_glade.cc \
 	statisticsDialog.cc \
-	EnginesTree.cpp \
-	IndexPage.cpp \
-	ModelColumns.cpp \
-	Notebook.cpp \
-	ResultsTree.cpp
+	EnginesTree.cc \
+	IndexPage.cc \
+	ModelColumns.cc \
+	Notebook.cc \
+	ResultsTree.cc
 
 bin_PROGRAMS = pinot
 

Copied: trunk/UI/GTK2/src/ModelColumns.cc (from rev 1529, trunk/UI/GTK2/src/ModelColumns.cpp)
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/ModelColumns.cc	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,117 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include "NLS.h"
+#include "ModelColumns.hh"
+
+ComboModelColumns::ComboModelColumns()
+{
+	add(m_name);
+}
+
+ComboModelColumns::~ComboModelColumns()
+{
+}
+
+EnginesModelColumns::EnginesModelColumns()
+{
+	add(m_name);
+	add(m_engineName);
+	add(m_option);
+	add(m_type);
+}
+
+EnginesModelColumns::~EnginesModelColumns()
+{
+}
+
+QueryModelColumns::QueryModelColumns()
+{
+	add(m_name);
+	add(m_lastRun);
+	add(m_lastRunTime);
+	add(m_summary);
+	add(m_properties);
+}
+
+QueryModelColumns::~QueryModelColumns()
+{
+}
+
+ResultsModelColumns::ResultsModelColumns()
+{
+	add(m_text);
+	add(m_url);
+	add(m_indexed);
+	add(m_viewed);
+	add(m_rankDiff);
+	add(m_score);
+	add(m_scoreText);
+	add(m_engines);
+	add(m_indexes);
+	add(m_docId);
+	add(m_resultType);
+	add(m_timestamp);
+	add(m_timestampTime);
+	add(m_serial);
+}
+
+ResultsModelColumns::~ResultsModelColumns()
+{
+}
+
+OtherIndexModelColumns::OtherIndexModelColumns()
+{
+	add(m_name);
+	add(m_location);
+}
+
+OtherIndexModelColumns::~OtherIndexModelColumns()
+{
+}
+
+LabelModelColumns::LabelModelColumns()
+{
+	add(m_enabled);
+	add(m_name);
+}
+
+LabelModelColumns::~LabelModelColumns()
+{
+}
+
+TimestampedModelColumns::TimestampedModelColumns()
+{
+	add(m_location);
+	add(m_mTime);
+}
+
+TimestampedModelColumns::~TimestampedModelColumns()
+{
+}
+
+IndexableModelColumns::IndexableModelColumns()
+{
+	add(m_monitor);
+	add(m_location);
+}
+
+IndexableModelColumns::~IndexableModelColumns()
+{
+}


Property changes on: trunk/UI/GTK2/src/ModelColumns.cc
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: trunk/UI/GTK2/src/ModelColumns.cpp
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.cpp	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/ModelColumns.cpp	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,117 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-#include "NLS.h"
-#include "ModelColumns.h"
-
-ComboModelColumns::ComboModelColumns()
-{
-	add(m_name);
-}
-
-ComboModelColumns::~ComboModelColumns()
-{
-}
-
-EnginesModelColumns::EnginesModelColumns()
-{
-	add(m_name);
-	add(m_engineName);
-	add(m_option);
-	add(m_type);
-}
-
-EnginesModelColumns::~EnginesModelColumns()
-{
-}
-
-QueryModelColumns::QueryModelColumns()
-{
-	add(m_name);
-	add(m_lastRun);
-	add(m_lastRunTime);
-	add(m_summary);
-	add(m_properties);
-}
-
-QueryModelColumns::~QueryModelColumns()
-{
-}
-
-ResultsModelColumns::ResultsModelColumns()
-{
-	add(m_text);
-	add(m_url);
-	add(m_indexed);
-	add(m_viewed);
-	add(m_rankDiff);
-	add(m_score);
-	add(m_scoreText);
-	add(m_engines);
-	add(m_indexes);
-	add(m_docId);
-	add(m_resultType);
-	add(m_timestamp);
-	add(m_timestampTime);
-	add(m_serial);
-}
-
-ResultsModelColumns::~ResultsModelColumns()
-{
-}
-
-OtherIndexModelColumns::OtherIndexModelColumns()
-{
-	add(m_name);
-	add(m_location);
-}
-
-OtherIndexModelColumns::~OtherIndexModelColumns()
-{
-}
-
-LabelModelColumns::LabelModelColumns()
-{
-	add(m_enabled);
-	add(m_name);
-}
-
-LabelModelColumns::~LabelModelColumns()
-{
-}
-
-TimestampedModelColumns::TimestampedModelColumns()
-{
-	add(m_location);
-	add(m_mTime);
-}
-
-TimestampedModelColumns::~TimestampedModelColumns()
-{
-}
-
-IndexableModelColumns::IndexableModelColumns()
-{
-	add(m_monitor);
-	add(m_location);
-}
-
-IndexableModelColumns::~IndexableModelColumns()
-{
-}

Deleted: trunk/UI/GTK2/src/ModelColumns.h
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.h	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/ModelColumns.h	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,149 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _MODELCOLUMNS_HH
-#define _MODELCOLUMNS_HH
-
-#include <time.h>
-#include <sys/types.h>
-#include <glibmm/refptr.h>
-#include <glibmm/ustring.h>
-#include <gdkmm/event.h>
-#include <gtkmm/treemodel.h>
-#include <gtkmm/treemodelcolumn.h>
-#include <gtkmm/optionmenu.h>
-
-#include "QueryProperties.h"
-
-/// Model column for text combo boxes.
-class ComboModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-	public:
-		ComboModelColumns();
-		virtual ~ComboModelColumns();
-
-		Gtk::TreeModelColumn<Glib::ustring> m_name;
-
-};
-
-/// Main window, model column for the search engines tree.
-class EnginesModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-	public:
-		EnginesModelColumns();
-		virtual ~EnginesModelColumns();
-
-		Gtk::TreeModelColumn<Glib::ustring> m_name;
-		Gtk::TreeModelColumn<Glib::ustring> m_engineName;
-		Gtk::TreeModelColumn<Glib::ustring> m_option;
-		typedef enum { ENGINE_SEPARATOR = 0, ENGINE_FOLDER,
-			WEB_ENGINE, INTERNAL_INDEX_ENGINE, INDEX_ENGINE } EngineType;
-		Gtk::TreeModelColumn<EngineType> m_type;
-
-};
-
-/// Main window, model column for the queries tree.
-class QueryModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-public:
-	QueryModelColumns();
-	virtual ~QueryModelColumns();
-
-	Gtk::TreeModelColumn<Glib::ustring> m_name;
-	Gtk::TreeModelColumn<Glib::ustring> m_lastRun;
-	Gtk::TreeModelColumn<time_t> m_lastRunTime;
-	Gtk::TreeModelColumn<Glib::ustring> m_summary;
-	Gtk::TreeModelColumn<QueryProperties> m_properties;
-
-};
-
-/// Main window, model column for the search results tree.
-class ResultsModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-public:
-	ResultsModelColumns();
-	virtual ~ResultsModelColumns();
-
-	Gtk::TreeModelColumn<Glib::ustring> m_text;
-	Gtk::TreeModelColumn<Glib::ustring> m_url;
-	Gtk::TreeModelColumn<bool> m_indexed;
-	Gtk::TreeModelColumn<bool> m_viewed;
-	Gtk::TreeModelColumn<int> m_rankDiff;
-	Gtk::TreeModelColumn<int> m_score;
-	Gtk::TreeModelColumn<Glib::ustring> m_scoreText;
-	Gtk::TreeModelColumn<unsigned int> m_engines;
-	Gtk::TreeModelColumn<unsigned int> m_indexes;
-	Gtk::TreeModelColumn<unsigned int> m_docId;
-	typedef enum { ROW_ENGINE = 0, ROW_HOST, ROW_RESULT, ROW_OTHER } RowType;
-	Gtk::TreeModelColumn<RowType> m_resultType;
-	Gtk::TreeModelColumn<Glib::ustring> m_timestamp;
-	Gtk::TreeModelColumn<time_t> m_timestampTime;
-	Gtk::TreeModelColumn<std::string> m_serial;
-
-};
-
-/// Preferences window, model column for the Xapian indexes tree.
-class OtherIndexModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-public:
-	OtherIndexModelColumns();
-	virtual ~OtherIndexModelColumns();
-
-	Gtk::TreeModelColumn<Glib::ustring> m_name;
-	Gtk::TreeModelColumn<Glib::ustring> m_location;
-
-};
-
-/// Preferences window, model column for the labels tree.
-/// Export/import window, model column for the labels tree.
-class LabelModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-public:
-	LabelModelColumns();
-	virtual ~LabelModelColumns();
-
-	Gtk::TreeModelColumn<bool> m_enabled;
-	Gtk::TreeModelColumn<Glib::ustring> m_name;
-
-};
-
-/// Preferences window, model column for the mail accounts tree.
-class TimestampedModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-public:
-	TimestampedModelColumns();
-	virtual ~TimestampedModelColumns();
-
-	Gtk::TreeModelColumn<Glib::ustring> m_location;
-	Gtk::TreeModelColumn<time_t> m_mTime;
-
-};
-
-/// Preferences window, model column for the directories tree.
-class IndexableModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-public:
-	IndexableModelColumns();
-	virtual ~IndexableModelColumns();
-
-	Gtk::TreeModelColumn<bool> m_monitor;
-	Gtk::TreeModelColumn<Glib::ustring> m_location;
-
-};
-
-#endif // _MODELCOLUMNS_HH

Copied: trunk/UI/GTK2/src/ModelColumns.hh (from rev 1529, trunk/UI/GTK2/src/ModelColumns.h)


Property changes on: trunk/UI/GTK2/src/ModelColumns.hh
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/UI/GTK2/src/Notebook.cc (from rev 1529, trunk/UI/GTK2/src/Notebook.cpp)
===================================================================
--- trunk/UI/GTK2/src/Notebook.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/Notebook.cc	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,267 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+#include <gtkmm/rc.h>
+
+#include "config.h"
+#include "NLS.h"
+#include "PinotUtils.h"
+#include "Notebook.hh"
+
+using namespace std;
+using namespace Glib;
+using namespace Gtk;
+
+NotebookPageBox::NotebookPageBox(const ustring &title, NotebookPageBox::PageType type,
+	PinotSettings &settings) :
+	VBox(),
+	m_title(title),
+	m_type(type),
+	m_settings(settings),
+	m_pTree(NULL)
+{
+}
+
+NotebookPageBox::~NotebookPageBox()
+{
+}
+
+//
+// Returns the page title.
+//
+ustring NotebookPageBox::getTitle(void) const
+{
+	return m_title;
+}
+
+//
+// Returns the page type.
+//
+NotebookPageBox::PageType NotebookPageBox::getType(void) const
+{
+	return m_type;
+}
+
+//
+// Returns the page's tree.
+//
+ResultsTree *NotebookPageBox::getTree(void) const
+{
+	return m_pTree;
+}
+
+ResultsPage::ResultsPage(const ustring &queryName, ResultsTree *pTree,
+	int parentHeight, PinotSettings &settings) :
+	NotebookPageBox(queryName, NotebookPageBox::RESULTS_PAGE, settings),
+	m_pLabel(NULL),
+	m_pCombobox(NULL),
+	m_pYesButton(NULL),
+	m_pCloseImage(NULL),
+	m_pCloseButton(NULL),
+	m_pHBox(NULL),
+	m_pVBox(NULL),
+	m_pVPaned(NULL)
+{
+	if (pTree != NULL)
+	{
+		m_pTree = pTree;
+		m_pLabel = manage(new Label(_("Did you mean ?")));
+		m_pCombobox = manage(new ComboBoxText());
+		m_pYesButton = manage(new Button(StockID("gtk-yes")));
+		m_pCloseImage = manage(new Image(StockID("gtk-close"), IconSize(ICON_SIZE_MENU)));
+		m_pCloseButton = manage(new Button());
+
+		m_pCloseImage->set_alignment(0, 0);
+		m_pCloseImage->set_padding(0, 0);
+		m_pCloseButton->set_relief(RELIEF_NONE);
+		m_pCloseButton->set_border_width(0);
+		m_pCloseButton->set_name("pinot-tab-close-button");
+		m_pCloseButton->set_tooltip_text(_("Close"));
+		m_pCloseButton->set_alignment(0, 0);
+		m_pCloseButton->add(*m_pCloseImage);
+		m_pHBox = manage(new HBox(false, 0));
+		m_pHBox->pack_start(*m_pLabel, Gtk::PACK_SHRINK, 4);
+		m_pHBox->pack_start(*m_pCombobox, Gtk::PACK_EXPAND_WIDGET, 4);
+		m_pHBox->pack_start(*m_pYesButton, Gtk::PACK_SHRINK, 4);
+		m_pHBox->pack_start(*m_pCloseButton, Gtk::PACK_SHRINK, 4);
+
+		m_pVBox = manage(new VBox(false, 0));
+		m_pVBox->pack_start(*m_pHBox, Gtk::PACK_SHRINK);
+		m_pVBox->pack_start(*pTree->getResultsScrolledWindow());
+
+		m_pVPaned = manage(new VPaned());
+		m_pVPaned->set_flags(Gtk::CAN_FOCUS);
+		m_pVPaned->set_position(105);
+		m_pVPaned->pack1(*m_pVBox, Gtk::EXPAND|Gtk::SHRINK);
+		m_pVPaned->pack2(*pTree->getExtractScrolledWindow(), Gtk::SHRINK);
+		pack_start(*m_pVPaned, Gtk::PACK_EXPAND_WIDGET);
+
+		// Give the extract 2/10th of the height
+		m_pVPaned->set_position((parentHeight * 8) / 10);
+
+		// Hide suggestions by default
+		onCloseButtonClicked();
+		m_pVBox->show();
+		m_pVPaned->show();
+
+		m_pYesButton->signal_clicked().connect(
+			sigc::mem_fun(*this, &ResultsPage::onYesButtonClicked), false);
+		m_pCloseButton->signal_clicked().connect(
+			sigc::mem_fun(*this, &ResultsPage::onCloseButtonClicked), false);
+	}
+
+	show();
+}
+
+ResultsPage::~ResultsPage()
+{
+}
+
+void ResultsPage::onYesButtonClicked()
+{
+	if (m_pCombobox == NULL)
+	{
+		return;
+	}
+
+	m_signalSuggest(m_title, m_pCombobox->get_active_text());
+}
+
+void ResultsPage::onCloseButtonClicked()
+{
+	// Just hide these
+	m_pLabel->hide();
+	m_pCombobox->hide();
+	m_pYesButton->hide();
+	m_pCloseImage->hide();
+	m_pCloseButton->hide();
+	m_pHBox->hide();
+}
+
+// Returns the suggest signal.
+sigc::signal2<void, ustring, ustring>& ResultsPage::getSuggestSignal(void)
+{
+	return m_signalSuggest;
+}
+
+//
+// Append a suggestion.
+//
+void ResultsPage::appendSuggestion(const ustring &text)
+{
+	if ((text.empty() == false) &&
+		(m_suggestions.find(text) == m_suggestions.end()))
+	{
+		ustring activeText(m_pCombobox->get_active_text());
+
+#ifdef DEBUG
+		cout << "ResultsPage::appendSuggestion: suggesting " << text << endl;
+#endif
+		m_suggestions.insert(text);
+		m_pCombobox->prepend_text(text);
+		if (activeText.empty() == true)
+		{
+			m_pCombobox->set_active(0);
+		}
+		else
+		{
+			m_pCombobox->set_active_text(activeText);
+		}
+	}
+
+	m_pLabel->show();
+	m_pCombobox->show();
+	m_pYesButton->show();
+	m_pCloseImage->show();
+	m_pCloseButton->show();
+	m_pHBox->show();
+}
+
+bool NotebookTabBox::m_initialized = false;
+
+NotebookTabBox::NotebookTabBox(const Glib::ustring &title, NotebookPageBox::PageType type) :
+	HBox(),
+	m_title(title),
+	m_pageType(type),
+	m_pTabLabel(NULL),
+	m_pTabImage(NULL),
+	m_pTabButton(NULL)
+{
+	if (m_initialized == false)
+	{
+		m_initialized = true;
+
+		// This was lifted from gnome-terminal's terminal-window.c
+		RC::parse_string("style \"pinot-tab-close-button-style\"\n"
+			"{\n"
+			"GtkWidget::focus-padding = 0\n"
+			"GtkWidget::focus-line-width = 0\n"
+			"xthickness = 0\n"
+			"ythickness = 0\n"
+			"}\n"
+			"widget \"*.pinot-tab-close-button\" style \"pinot-tab-close-button-style\"");
+	}
+
+	m_pTabLabel = manage(new Label(title));
+	m_pTabImage = manage(new Image(StockID("gtk-close"), IconSize(ICON_SIZE_MENU)));
+	m_pTabButton = manage(new Button());
+
+	m_pTabLabel->set_alignment(0, 0.5);
+	m_pTabLabel->set_padding(0, 0);
+	m_pTabLabel->set_justify(JUSTIFY_LEFT);
+	m_pTabLabel->set_line_wrap(false);
+	m_pTabLabel->set_use_markup(false);
+	m_pTabLabel->set_selectable(false);
+	m_pTabImage->set_alignment(0, 0);
+	m_pTabImage->set_padding(0, 0);
+	m_pTabButton->set_relief(RELIEF_NONE);
+	m_pTabButton->set_border_width(0);
+	m_pTabButton->set_name("pinot-tab-close-button");
+	m_pTabButton->set_tooltip_text(_("Close"));
+	m_pTabButton->set_alignment(0, 0);
+	m_pTabButton->add(*m_pTabImage);
+	pack_start(*m_pTabLabel);
+	pack_start(*m_pTabButton, PACK_SHRINK);
+	set_spacing(0);
+	set_homogeneous(false);
+	m_pTabLabel->show();
+	m_pTabImage->show();
+	m_pTabButton->show();
+	show();
+
+	m_pTabButton->signal_clicked().connect(
+		sigc::mem_fun(*this, &NotebookTabBox::onButtonClicked));
+}
+
+NotebookTabBox::~NotebookTabBox()
+{
+}
+
+void NotebookTabBox::onButtonClicked(void)
+{
+	m_signalClose(m_title, m_pageType);
+}
+
+//
+// Returns the close signal.
+//
+sigc::signal2<void, ustring, NotebookPageBox::PageType>& NotebookTabBox::getCloseSignal(void)
+{
+	return m_signalClose;
+}


Property changes on: trunk/UI/GTK2/src/Notebook.cc
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: trunk/UI/GTK2/src/Notebook.cpp
===================================================================
--- trunk/UI/GTK2/src/Notebook.cpp	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/Notebook.cpp	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,267 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <iostream>
-#include <gtkmm/rc.h>
-
-#include "config.h"
-#include "NLS.h"
-#include "Notebook.h"
-#include "PinotUtils.h"
-
-using namespace std;
-using namespace Glib;
-using namespace Gtk;
-
-NotebookPageBox::NotebookPageBox(const ustring &title, NotebookPageBox::PageType type,
-	PinotSettings &settings) :
-	VBox(),
-	m_title(title),
-	m_type(type),
-	m_settings(settings),
-	m_pTree(NULL)
-{
-}
-
-NotebookPageBox::~NotebookPageBox()
-{
-}
-
-//
-// Returns the page title.
-//
-ustring NotebookPageBox::getTitle(void) const
-{
-	return m_title;
-}
-
-//
-// Returns the page type.
-//
-NotebookPageBox::PageType NotebookPageBox::getType(void) const
-{
-	return m_type;
-}
-
-//
-// Returns the page's tree.
-//
-ResultsTree *NotebookPageBox::getTree(void) const
-{
-	return m_pTree;
-}
-
-ResultsPage::ResultsPage(const ustring &queryName, ResultsTree *pTree,
-	int parentHeight, PinotSettings &settings) :
-	NotebookPageBox(queryName, NotebookPageBox::RESULTS_PAGE, settings),
-	m_pLabel(NULL),
-	m_pCombobox(NULL),
-	m_pYesButton(NULL),
-	m_pCloseImage(NULL),
-	m_pCloseButton(NULL),
-	m_pHBox(NULL),
-	m_pVBox(NULL),
-	m_pVPaned(NULL)
-{
-	if (pTree != NULL)
-	{
-		m_pTree = pTree;
-		m_pLabel = manage(new Label(_("Did you mean ?")));
-		m_pCombobox = manage(new ComboBoxText());
-		m_pYesButton = manage(new Button(StockID("gtk-yes")));
-		m_pCloseImage = manage(new Image(StockID("gtk-close"), IconSize(ICON_SIZE_MENU)));
-		m_pCloseButton = manage(new Button());
-
-		m_pCloseImage->set_alignment(0, 0);
-		m_pCloseImage->set_padding(0, 0);
-		m_pCloseButton->set_relief(RELIEF_NONE);
-		m_pCloseButton->set_border_width(0);
-		m_pCloseButton->set_name("pinot-tab-close-button");
-		m_pCloseButton->set_tooltip_text(_("Close"));
-		m_pCloseButton->set_alignment(0, 0);
-		m_pCloseButton->add(*m_pCloseImage);
-		m_pHBox = manage(new HBox(false, 0));
-		m_pHBox->pack_start(*m_pLabel, Gtk::PACK_SHRINK, 4);
-		m_pHBox->pack_start(*m_pCombobox, Gtk::PACK_EXPAND_WIDGET, 4);
-		m_pHBox->pack_start(*m_pYesButton, Gtk::PACK_SHRINK, 4);
-		m_pHBox->pack_start(*m_pCloseButton, Gtk::PACK_SHRINK, 4);
-
-		m_pVBox = manage(new VBox(false, 0));
-		m_pVBox->pack_start(*m_pHBox, Gtk::PACK_SHRINK);
-		m_pVBox->pack_start(*pTree->getResultsScrolledWindow());
-
-		m_pVPaned = manage(new VPaned());
-		m_pVPaned->set_flags(Gtk::CAN_FOCUS);
-		m_pVPaned->set_position(105);
-		m_pVPaned->pack1(*m_pVBox, Gtk::EXPAND|Gtk::SHRINK);
-		m_pVPaned->pack2(*pTree->getExtractScrolledWindow(), Gtk::SHRINK);
-		pack_start(*m_pVPaned, Gtk::PACK_EXPAND_WIDGET);
-
-		// Give the extract 2/10th of the height
-		m_pVPaned->set_position((parentHeight * 8) / 10);
-
-		// Hide suggestions by default
-		onCloseButtonClicked();
-		m_pVBox->show();
-		m_pVPaned->show();
-
-		m_pYesButton->signal_clicked().connect(
-			sigc::mem_fun(*this, &ResultsPage::onYesButtonClicked), false);
-		m_pCloseButton->signal_clicked().connect(
-			sigc::mem_fun(*this, &ResultsPage::onCloseButtonClicked), false);
-	}
-
-	show();
-}
-
-ResultsPage::~ResultsPage()
-{
-}
-
-void ResultsPage::onYesButtonClicked()
-{
-	if (m_pCombobox == NULL)
-	{
-		return;
-	}
-
-	m_signalSuggest(m_title, m_pCombobox->get_active_text());
-}
-
-void ResultsPage::onCloseButtonClicked()
-{
-	// Just hide these
-	m_pLabel->hide();
-	m_pCombobox->hide();
-	m_pYesButton->hide();
-	m_pCloseImage->hide();
-	m_pCloseButton->hide();
-	m_pHBox->hide();
-}
-
-// Returns the suggest signal.
-sigc::signal2<void, ustring, ustring>& ResultsPage::getSuggestSignal(void)
-{
-	return m_signalSuggest;
-}
-
-//
-// Append a suggestion.
-//
-void ResultsPage::appendSuggestion(const ustring &text)
-{
-	if ((text.empty() == false) &&
-		(m_suggestions.find(text) == m_suggestions.end()))
-	{
-		ustring activeText(m_pCombobox->get_active_text());
-
-#ifdef DEBUG
-		cout << "ResultsPage::appendSuggestion: suggesting " << text << endl;
-#endif
-		m_suggestions.insert(text);
-		m_pCombobox->prepend_text(text);
-		if (activeText.empty() == true)
-		{
-			m_pCombobox->set_active(0);
-		}
-		else
-		{
-			m_pCombobox->set_active_text(activeText);
-		}
-	}
-
-	m_pLabel->show();
-	m_pCombobox->show();
-	m_pYesButton->show();
-	m_pCloseImage->show();
-	m_pCloseButton->show();
-	m_pHBox->show();
-}
-
-bool NotebookTabBox::m_initialized = false;
-
-NotebookTabBox::NotebookTabBox(const Glib::ustring &title, NotebookPageBox::PageType type) :
-	HBox(),
-	m_title(title),
-	m_pageType(type),
-	m_pTabLabel(NULL),
-	m_pTabImage(NULL),
-	m_pTabButton(NULL)
-{
-	if (m_initialized == false)
-	{
-		m_initialized = true;
-
-		// This was lifted from gnome-terminal's terminal-window.c
-		RC::parse_string("style \"pinot-tab-close-button-style\"\n"
-			"{\n"
-			"GtkWidget::focus-padding = 0\n"
-			"GtkWidget::focus-line-width = 0\n"
-			"xthickness = 0\n"
-			"ythickness = 0\n"
-			"}\n"
-			"widget \"*.pinot-tab-close-button\" style \"pinot-tab-close-button-style\"");
-	}
-
-	m_pTabLabel = manage(new Label(title));
-	m_pTabImage = manage(new Image(StockID("gtk-close"), IconSize(ICON_SIZE_MENU)));
-	m_pTabButton = manage(new Button());
-
-	m_pTabLabel->set_alignment(0, 0.5);
-	m_pTabLabel->set_padding(0, 0);
-	m_pTabLabel->set_justify(JUSTIFY_LEFT);
-	m_pTabLabel->set_line_wrap(false);
-	m_pTabLabel->set_use_markup(false);
-	m_pTabLabel->set_selectable(false);
-	m_pTabImage->set_alignment(0, 0);
-	m_pTabImage->set_padding(0, 0);
-	m_pTabButton->set_relief(RELIEF_NONE);
-	m_pTabButton->set_border_width(0);
-	m_pTabButton->set_name("pinot-tab-close-button");
-	m_pTabButton->set_tooltip_text(_("Close"));
-	m_pTabButton->set_alignment(0, 0);
-	m_pTabButton->add(*m_pTabImage);
-	pack_start(*m_pTabLabel);
-	pack_start(*m_pTabButton, PACK_SHRINK);
-	set_spacing(0);
-	set_homogeneous(false);
-	m_pTabLabel->show();
-	m_pTabImage->show();
-	m_pTabButton->show();
-	show();
-
-	m_pTabButton->signal_clicked().connect(
-		sigc::mem_fun(*this, &NotebookTabBox::onButtonClicked));
-}
-
-NotebookTabBox::~NotebookTabBox()
-{
-}
-
-void NotebookTabBox::onButtonClicked(void)
-{
-	m_signalClose(m_title, m_pageType);
-}
-
-//
-// Returns the close signal.
-//
-sigc::signal2<void, ustring, NotebookPageBox::PageType>& NotebookTabBox::getCloseSignal(void)
-{
-	return m_signalClose;
-}

Deleted: trunk/UI/GTK2/src/Notebook.h
===================================================================
--- trunk/UI/GTK2/src/Notebook.h	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/Notebook.h	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,114 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _NOTEBOOK_HH
-#define _NOTEBOOK_HH
-
-#include <set>
-#include <sigc++/sigc++.h>
-#include <glibmm/ustring.h>
-#include <gtkmm/box.h>
-#include <gtkmm/button.h>
-#include <gtkmm/comboboxtext.h>
-#include <gtkmm/image.h>
-#include <gtkmm/label.h>
-#include <gtkmm/paned.h>
-#include <gtkmm/textview.h>
-
-#include "PinotSettings.h"
-#include "ResultsTree.h"
-
-class NotebookPageBox : public Gtk::VBox
-{
-	public:
-		typedef enum { RESULTS_PAGE = 0, INDEX_PAGE } PageType;
-
-		NotebookPageBox(const Glib::ustring &title, PageType type,
-			PinotSettings &settings);
-		virtual ~NotebookPageBox();
-
-		/// Returns the page title.
-		Glib::ustring getTitle(void) const;
-
-		/// Returns the page type.
-		PageType getType(void) const;
-
-		/// Returns the page's tree.
-		virtual ResultsTree *getTree(void) const;
-
-	protected:
-		Glib::ustring m_title;
-		PageType m_type;
-		PinotSettings &m_settings;
-		ResultsTree *m_pTree;
-
-};
-
-class ResultsPage : public NotebookPageBox
-{
-	public:
-		ResultsPage(const Glib::ustring &queryName, ResultsTree *pTree,
-			int parentHeight, PinotSettings &settings);
-		virtual ~ResultsPage();
-
-		/// Returns the suggest signal.
-		sigc::signal2<void, Glib::ustring, Glib::ustring>& getSuggestSignal(void);
-
-		/// Append a suggestion.
-		void appendSuggestion(const Glib::ustring &text);
-
-	protected:
-		Gtk::Label *m_pLabel;
-		Gtk::ComboBoxText *m_pCombobox;
-		Gtk::Button *m_pYesButton;
-		Gtk::Image *m_pCloseImage;
-		Gtk::Button *m_pCloseButton;
-		Gtk::HBox *m_pHBox;
-		Gtk::VBox *m_pVBox;
-		Gtk::VPaned *m_pVPaned;
-		sigc::signal2<void, Glib::ustring, Glib::ustring> m_signalSuggest;
-		std::set<Glib::ustring> m_suggestions;
-		void onYesButtonClicked();
-
-		void onCloseButtonClicked();
-
-};
-
-class NotebookTabBox : public Gtk::HBox
-{
-	public:
-		NotebookTabBox(const Glib::ustring &title, NotebookPageBox::PageType type);
-		virtual ~NotebookTabBox();
-
-		/// Returns the close signal.
-		sigc::signal2<void, Glib::ustring, NotebookPageBox::PageType>& getCloseSignal(void);
-
-	protected:
-		static bool m_initialized;
-		Glib::ustring m_title;
-		NotebookPageBox::PageType m_pageType;
-		Gtk::Label *m_pTabLabel;
-		Gtk::Image *m_pTabImage;
-		Gtk::Button *m_pTabButton;
-		sigc::signal2<void, Glib::ustring, NotebookPageBox::PageType> m_signalClose;
-
-		void onButtonClicked(void);
-
-};
-
-#endif // _NOTEBOOK_HH

Copied: trunk/UI/GTK2/src/Notebook.hh (from rev 1529, trunk/UI/GTK2/src/Notebook.h)
===================================================================
--- trunk/UI/GTK2/src/Notebook.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/Notebook.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,114 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _NOTEBOOK_HH
+#define _NOTEBOOK_HH
+
+#include <set>
+#include <sigc++/sigc++.h>
+#include <glibmm/ustring.h>
+#include <gtkmm/box.h>
+#include <gtkmm/button.h>
+#include <gtkmm/comboboxtext.h>
+#include <gtkmm/image.h>
+#include <gtkmm/label.h>
+#include <gtkmm/paned.h>
+#include <gtkmm/textview.h>
+
+#include "PinotSettings.h"
+#include "ResultsTree.hh"
+
+class NotebookPageBox : public Gtk::VBox
+{
+	public:
+		typedef enum { RESULTS_PAGE = 0, INDEX_PAGE } PageType;
+
+		NotebookPageBox(const Glib::ustring &title, PageType type,
+			PinotSettings &settings);
+		virtual ~NotebookPageBox();
+
+		/// Returns the page title.
+		Glib::ustring getTitle(void) const;
+
+		/// Returns the page type.
+		PageType getType(void) const;
+
+		/// Returns the page's tree.
+		virtual ResultsTree *getTree(void) const;
+
+	protected:
+		Glib::ustring m_title;
+		PageType m_type;
+		PinotSettings &m_settings;
+		ResultsTree *m_pTree;
+
+};
+
+class ResultsPage : public NotebookPageBox
+{
+	public:
+		ResultsPage(const Glib::ustring &queryName, ResultsTree *pTree,
+			int parentHeight, PinotSettings &settings);
+		virtual ~ResultsPage();
+
+		/// Returns the suggest signal.
+		sigc::signal2<void, Glib::ustring, Glib::ustring>& getSuggestSignal(void);
+
+		/// Append a suggestion.
+		void appendSuggestion(const Glib::ustring &text);
+
+	protected:
+		Gtk::Label *m_pLabel;
+		Gtk::ComboBoxText *m_pCombobox;
+		Gtk::Button *m_pYesButton;
+		Gtk::Image *m_pCloseImage;
+		Gtk::Button *m_pCloseButton;
+		Gtk::HBox *m_pHBox;
+		Gtk::VBox *m_pVBox;
+		Gtk::VPaned *m_pVPaned;
+		sigc::signal2<void, Glib::ustring, Glib::ustring> m_signalSuggest;
+		std::set<Glib::ustring> m_suggestions;
+		void onYesButtonClicked();
+
+		void onCloseButtonClicked();
+
+};
+
+class NotebookTabBox : public Gtk::HBox
+{
+	public:
+		NotebookTabBox(const Glib::ustring &title, NotebookPageBox::PageType type);
+		virtual ~NotebookTabBox();
+
+		/// Returns the close signal.
+		sigc::signal2<void, Glib::ustring, NotebookPageBox::PageType>& getCloseSignal(void);
+
+	protected:
+		static bool m_initialized;
+		Glib::ustring m_title;
+		NotebookPageBox::PageType m_pageType;
+		Gtk::Label *m_pTabLabel;
+		Gtk::Image *m_pTabImage;
+		Gtk::Button *m_pTabButton;
+		sigc::signal2<void, Glib::ustring, NotebookPageBox::PageType> m_signalClose;
+
+		void onButtonClicked(void);
+
+};
+
+#endif // _NOTEBOOK_HH


Property changes on: trunk/UI/GTK2/src/Notebook.hh
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/UI/GTK2/src/ResultsTree.cc (from rev 1529, trunk/UI/GTK2/src/ResultsTree.cpp)
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/ResultsTree.cc	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,1656 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <ctype.h>
+#include <iostream>
+#include <gdkmm/color.h>
+#include <gtkmm/alignment.h>
+#include <gtkmm/box.h>
+#include <gtkmm/buttonbox.h>
+#include <gtkmm/image.h>
+#include <gtkmm/label.h>
+#include <gtkmm/stock.h>
+#include <gtkmm/cellrendererprogress.h>
+
+#include "config.h"
+#include "NLS.h"
+#include "StringManip.h"
+#include "TimeConverter.h"
+#include "Url.h"
+#include "QueryHistory.h"
+#include "ViewHistory.h"
+#include "PinotSettings.h"
+#include "PinotUtils.h"
+#include "ResultsTree.hh"
+
+using namespace std;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+ResultsTree::ResultsTree(const ustring &queryName, Menu *pPopupMenu,
+	GroupByMode groupMode, PinotSettings &settings) :
+	TreeView(),
+	m_treeName(queryName),
+	m_pPopupMenu(pPopupMenu),
+	m_pResultsScrolledwindow(NULL),
+	m_settings(settings),
+	m_pExtractScrolledwindow(NULL),
+	m_extractTextView(NULL),
+	m_showExtract(true),
+	m_groupMode(groupMode)
+{
+	TreeViewColumn *pColumn = NULL;
+
+	m_pResultsScrolledwindow = manage(new ScrolledWindow());
+	m_pExtractScrolledwindow = manage(new ScrolledWindow());
+	m_extractTextView = manage(new TextView());
+
+	// This is the actual results tree
+	set_events(Gdk::BUTTON_PRESS_MASK);
+	set_flags(CAN_FOCUS);
+	set_headers_clickable(true);
+	set_headers_visible(true);
+	set_rules_hint(true);
+	set_reorderable(false);
+	set_enable_search(true);
+	get_selection()->set_mode(SELECTION_MULTIPLE);
+	m_pResultsScrolledwindow->set_flags(CAN_FOCUS);
+	m_pResultsScrolledwindow->set_border_width(4);
+	m_pResultsScrolledwindow->set_shadow_type(SHADOW_NONE);
+	m_pResultsScrolledwindow->set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
+	m_pResultsScrolledwindow->property_window_placement().set_value(CORNER_TOP_LEFT);
+	m_pResultsScrolledwindow->add(*this);
+
+	// That's for the extract view
+	m_extractTextView->set_flags(CAN_FOCUS);
+	m_extractTextView->set_editable(false);
+	m_extractTextView->set_cursor_visible(false);
+	m_extractTextView->set_pixels_above_lines(0);
+	m_extractTextView->set_pixels_below_lines(0);
+	m_extractTextView->set_pixels_inside_wrap(0);
+	m_extractTextView->set_left_margin(0);
+	m_extractTextView->set_right_margin(0);
+	m_extractTextView->set_indent(0);
+	m_extractTextView->set_wrap_mode(WRAP_WORD);
+	m_extractTextView->set_justification(JUSTIFY_LEFT);
+	RefPtr<TextTag> refBoldTag = TextBuffer::Tag::create("bold");
+	refBoldTag->property_weight() = 900;
+	RefPtr<TextBuffer> refBuffer = m_extractTextView->get_buffer();
+	if (refBuffer)
+	{
+		refBuffer->get_tag_table()->add(refBoldTag); 
+	}
+	m_pExtractScrolledwindow->set_flags(CAN_FOCUS);
+	m_pExtractScrolledwindow->set_border_width(4);
+	m_pExtractScrolledwindow->set_shadow_type(SHADOW_NONE);
+	m_pExtractScrolledwindow->set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
+	m_pExtractScrolledwindow->property_window_placement().set_value(CORNER_TOP_LEFT);
+	m_pExtractScrolledwindow->add(*m_extractTextView);
+
+	// Associate the columns model to the results tree
+	m_refStore = TreeStore::create(m_resultsColumns);
+	set_model(m_refStore);
+
+	if (m_groupMode != FLAT)
+	{
+		// The first column is for the status icons
+		pColumn = new TreeViewColumn("");
+		// Pack an icon renderer for the viewed status
+		CellRendererPixbuf *pIconRenderer = new CellRendererPixbuf();
+		pColumn->pack_start(*manage(pIconRenderer), false);
+		pColumn->set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &ResultsTree::renderViewStatus));
+		// Pack a second icon renderer for the indexed status
+		pIconRenderer = new CellRendererPixbuf();
+		pColumn->pack_start(*manage(pIconRenderer), false);
+		pColumn->set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &ResultsTree::renderIndexStatus));
+		// And a third one for the ranking
+		pIconRenderer = new CellRendererPixbuf();
+		pColumn->pack_start(*manage(pIconRenderer), false);
+		pColumn->set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &ResultsTree::renderRanking));
+		pColumn->set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
+		append_column(*manage(pColumn));
+
+		// This is the score column
+		pColumn = new TreeViewColumn(_("Score"));
+		CellRendererProgress *pProgressRenderer = new CellRendererProgress();
+		pColumn->pack_start(*manage(pProgressRenderer));
+		pColumn->add_attribute(pProgressRenderer->property_text(), m_resultsColumns.m_scoreText);
+		pColumn->add_attribute(pProgressRenderer->property_value(), m_resultsColumns.m_score);
+		pColumn->set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
+		pColumn->set_sort_column(m_resultsColumns.m_score);
+		append_column(*manage(pColumn));
+	}
+
+	// This is the title column
+	pColumn = new TreeViewColumn(_("Title"));
+	CellRendererText *pTextRenderer = new CellRendererText();
+	pColumn->pack_start(*manage(pTextRenderer));
+	pColumn->set_cell_data_func(*pTextRenderer, sigc::mem_fun(*this, &ResultsTree::renderTitleColumn));
+	pColumn->add_attribute(pTextRenderer->property_text(), m_resultsColumns.m_text);
+	pColumn->set_resizable(true);
+	pColumn->set_sort_column(m_resultsColumns.m_text);
+	append_column(*manage(pColumn));
+
+	// URL
+	pColumn = create_column(_("URL"), m_resultsColumns.m_url, false, true, m_resultsColumns.m_url);
+	if (pColumn != NULL)
+	{
+		pColumn->set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
+		append_column(*manage(pColumn));
+	}
+
+	// The last column is for the timestamp
+	pColumn = create_column(_("Date"), m_resultsColumns.m_timestamp, false, true, m_resultsColumns.m_timestampTime);
+	if (pColumn != NULL)
+	{
+		pColumn->set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
+		append_column(*manage(pColumn));
+	}
+	
+	// Connect the signals
+	signal_button_press_event().connect_notify(
+		sigc::mem_fun(*this, &ResultsTree::onButtonPressEvent));
+	get_selection()->signal_changed().connect(
+		sigc::mem_fun(*this, &ResultsTree::onSelectionChanged));
+
+	// Enable interactive search
+	set_search_column(m_resultsColumns.m_text.index());
+	// Control which rows can be selected
+	get_selection()->set_select_function(sigc::mem_fun(*this, &ResultsTree::onSelectionSelect));
+	// Listen for style changes
+	signal_style_changed().connect_notify(sigc::mem_fun(*this, &ResultsTree::onStyleChanged));
+
+	// Render the icons
+	m_indexedIconPixbuf = render_icon(Stock::INDEX, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_viewededIconPixbuf = render_icon(Stock::YES, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_upIconPixbuf = render_icon(Stock::GO_UP, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_downIconPixbuf = render_icon(Stock::GO_DOWN, ICON_SIZE_MENU, "MetaSE-pinot");
+
+	// Show all
+	show();
+	m_pResultsScrolledwindow->show();
+	m_extractTextView->show();
+	m_pExtractScrolledwindow->show();
+}
+
+ResultsTree::~ResultsTree()
+{
+}
+
+void ResultsTree::renderViewStatus(CellRenderer *pRenderer, const TreeModel::iterator &iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (pRenderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *pIconRenderer = dynamic_cast<CellRendererPixbuf*>(pRenderer);
+	if (pIconRenderer != NULL)
+	{
+		// Has this result been already viewed ?
+		if ((row[m_resultsColumns.m_viewed] == true) &&
+			(m_viewededIconPixbuf))
+		{
+			pIconRenderer->property_pixbuf() = m_viewededIconPixbuf;
+		}
+		else
+		{
+			pIconRenderer->property_pixbuf().reset_value();
+		}
+	}
+}
+
+void ResultsTree::renderIndexStatus(CellRenderer *pRenderer, const TreeModel::iterator &iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (pRenderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *pIconRenderer = dynamic_cast<CellRendererPixbuf*>(pRenderer);
+	if (pIconRenderer != NULL)
+	{
+		// Is this result indexed ?
+		if ((row[m_resultsColumns.m_indexed] == true) &&
+			(m_indexedIconPixbuf))
+		{
+			pIconRenderer->property_pixbuf() = m_indexedIconPixbuf;
+		}
+		else
+		{
+			pIconRenderer->property_pixbuf().reset_value();
+		}
+	}
+}
+
+void ResultsTree::renderRanking(CellRenderer *pRenderer, const TreeModel::iterator &iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (pRenderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *pIconRenderer = dynamic_cast<CellRendererPixbuf*>(pRenderer);
+	if (pIconRenderer != NULL)
+	{
+		int rankDiff = row[m_resultsColumns.m_rankDiff];
+
+		// Has this result's score changed ?
+		if ((rankDiff > 0) &&
+			(rankDiff != 666))
+		{
+			pIconRenderer->property_pixbuf() = m_upIconPixbuf;
+		}
+		else if (rankDiff < 0)
+		{
+			pIconRenderer->property_pixbuf() = m_downIconPixbuf;
+		}
+		else
+		{
+			pIconRenderer->property_pixbuf().reset_value();
+		}
+	}
+}
+
+void ResultsTree::renderTitleColumn(CellRenderer *pRenderer, const TreeModel::iterator &iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (pRenderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererText *pTextRenderer = dynamic_cast<CellRendererText*>(pRenderer);
+	if (pTextRenderer != NULL)
+	{
+		// Is this result new ?
+		if (row[m_resultsColumns.m_rankDiff] == 666)
+		{
+			Color newColour;
+
+			newColour.set_red(m_settings.m_newResultsColourRed);
+			newColour.set_green(m_settings.m_newResultsColourGreen);
+			newColour.set_blue(m_settings.m_newResultsColourBlue);
+
+			// Change the row's background
+			pTextRenderer->property_background_gdk() = newColour;
+		}
+		else
+		{
+			pTextRenderer->property_background_gdk().reset_value();
+		}
+
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		if ((type == ResultsModelColumns::ROW_ENGINE) ||
+			(type == ResultsModelColumns::ROW_HOST))
+		{
+			ustring markup("<b>");
+			markup += row[m_resultsColumns.m_text];
+			markup += "</b>";
+			pTextRenderer->property_markup() = markup;
+		}
+	}
+}
+
+void ResultsTree::onButtonPressEvent(GdkEventButton *ev)
+{
+	// Check for popup click
+	if ((ev->type == GDK_BUTTON_PRESS) &&
+		(ev->button == 3) )
+	{
+		if (m_pPopupMenu != NULL)
+		{
+			m_pPopupMenu->popup(ev->button, ev->time);
+		}
+	}
+	// Check for double clicks
+	else if (ev->type == GDK_2BUTTON_PRESS)
+	{
+#ifdef DEBUG
+		cout << "ResultsTree::onButtonPressEvent: double click on button " << ev->button << endl;
+#endif
+		m_signalDoubleClick();
+	}
+}
+
+void ResultsTree::onSelectionChanged(void)
+{
+	m_signalSelectionChanged(m_treeName);
+}
+
+bool ResultsTree::onSelectionSelect(const RefPtr<TreeModel>& model,
+	const TreeModel::Path& node_path, bool path_currently_selected)
+{
+	const TreeModel::iterator iter = model->get_iter(node_path);
+	const TreeModel::Row row = *iter;
+
+	// In flat mode, don't bother about the extract
+	if ((path_currently_selected == false) &&
+		(m_groupMode != FLAT))
+	{
+		// Is this an actual result ?
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		if (type != ResultsModelColumns::ROW_RESULT)
+		{
+			return true;
+		}
+
+		RefPtr<TextBuffer> refBuffer = m_extractTextView->get_buffer();
+		if (refBuffer)
+		{
+			ustring extract(findResultsExtract(row));
+			ustring::size_type textPos = 0, boldPos = extract.find("<b>");
+
+			// Clear the extract
+			refBuffer->set_text("");
+
+#ifdef DEBUG
+			cout << "ResultsTree::onSelectionSelect: extract for " << row[m_resultsColumns.m_url] << endl;
+#endif
+			if (boldPos == ustring::npos)
+			{
+				refBuffer->set_text(extract);
+			}
+			else
+			{
+				TextBuffer::iterator bufferPos = refBuffer->begin();
+
+				while (boldPos != ustring::npos)
+				{
+					bufferPos = refBuffer->insert(bufferPos, extract.substr(textPos, boldPos - textPos));
+
+					textPos = boldPos + 3;
+					boldPos = extract.find("</b>", textPos);
+					if (boldPos == ustring::npos)
+					{
+						continue;
+					}
+					bufferPos = refBuffer->insert_with_tag(bufferPos, extract.substr(textPos, boldPos - textPos), "bold");
+
+					// Next
+					textPos = boldPos + 4;
+					boldPos = extract.find("<b>", textPos);
+				}
+
+				if (textPos + 1 < extract.length())
+				{
+					bufferPos = refBuffer->insert(bufferPos, extract.substr(textPos, boldPos - textPos));
+				}
+			}
+		}
+	}
+
+	return true;
+}
+
+void ResultsTree::onStyleChanged(const RefPtr<Style> &previous_style)
+{
+#ifdef DEBUG
+	cout << "ResultsTree::onStyleChanged: called" << endl;
+#endif
+	// FIXME: find better icons :-)
+	m_indexedIconPixbuf = render_icon(Stock::INDEX, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_viewededIconPixbuf = render_icon(Stock::YES, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_upIconPixbuf = render_icon(Stock::GO_UP, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_downIconPixbuf = render_icon(Stock::GO_DOWN, ICON_SIZE_MENU, "MetaSE-pinot");
+}
+
+//
+// Returns the results scrolled window.
+//
+ScrolledWindow *ResultsTree::getResultsScrolledWindow(void) const
+{
+	return m_pResultsScrolledwindow;
+}
+
+//
+// Returns the extract scrolled window.
+//
+ScrolledWindow *ResultsTree::getExtractScrolledWindow(void) const
+{
+	return m_pExtractScrolledwindow;
+}
+
+//
+// Returns the extract tree.
+//
+bool ResultsTree::focusOnExtract(void) const
+{
+	return m_extractTextView->is_focus();
+}
+
+//
+// Returns the extract.
+//
+ustring ResultsTree::getExtract(void) const
+{
+	ustring text;
+
+	RefPtr<TextBuffer> refBuffer = m_extractTextView->get_buffer();
+	if (refBuffer)
+	{
+		text = refBuffer->get_text();
+	}
+
+	return text;
+}
+
+//
+// Adds a set of results.
+// Returns true if something was added to the tree.
+//
+bool ResultsTree::addResults(const string &engineName, const vector<DocumentInfo> &resultsList,
+	const string &charset, bool updateHistory)
+{
+	std::map<string, TreeModel::iterator> updatedGroups;
+	ResultsModelColumns::RowType rootType;
+	unsigned int count = 0;
+
+	// What's the grouping criteria ?
+	if (m_groupMode == BY_ENGINE)
+	{
+		// By search engine
+		rootType = ResultsModelColumns::ROW_ENGINE;
+	}
+	else if (m_groupMode == BY_HOST)
+	{
+		// By host
+		rootType = ResultsModelColumns::ROW_HOST;
+	}
+
+	unsigned int indexId = 0;
+	unsigned int engineId = 0;
+
+	// Find out what the search engine ID is
+	if (engineName.empty() == false)
+	{
+		engineId = m_settings.getEngineId(engineName);
+		if (engineId == 0)
+		{
+			// Chances are this engine is an index
+			PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(engineName);
+			if (indexProps.m_location.empty() == false)
+			{
+				// Yes, it is
+				indexId = indexProps.m_id;
+				engineId = m_settings.getEngineId(m_settings.m_defaultBackend);
+#ifdef DEBUG
+				cout << "ResultsTree::addResults: engine is index " << engineName << " " << indexId << " " << engineId << endl;
+#endif
+			}
+#ifdef DEBUG
+			else cout << "ResultsTree::addResults: " << engineName << " is not an index" <<  endl;
+#endif
+		}
+#ifdef DEBUG
+		else cout << "ResultsTree::addResults: ID for engine " << engineName << " is " << engineId <<  endl;
+#endif
+	}
+
+	QueryHistory queryHistory(m_settings.getHistoryDatabaseName());
+	ViewHistory viewHistory(m_settings.getHistoryDatabaseName());
+	set<time_t> latestRuns;
+	time_t secondLastRunTime = 0;
+	bool isNewQuery = false;
+
+	// Is this a new query ?
+	if ((queryHistory.getLatestRuns(m_treeName, engineName, 2, latestRuns) == false) ||
+		(latestRuns.empty() == true))
+	{
+		isNewQuery = true;
+	}
+	else
+	{
+		set<time_t>::const_iterator runIter = latestRuns.begin();
+
+		// We only need to keep the last two runs
+		if (runIter != latestRuns.end())
+		{
+			++runIter;
+			if (runIter != latestRuns.end())
+			{
+				secondLastRunTime = (*runIter);
+			}
+		}
+	}
+#ifdef DEBUG
+	cout << "ResultsTree::addResults: " << resultsList.size() << " results with charset " << charset
+		<< ", second last run " << secondLastRunTime << endl;
+#endif
+
+	// Look at the results list
+	for (vector<DocumentInfo>::const_iterator resultIter = resultsList.begin();
+		resultIter != resultsList.end(); ++resultIter)
+	{
+		ustring title(to_utf8(resultIter->getTitle(), charset));
+		ustring location(to_utf8(resultIter->getLocation(), charset));
+		ustring timestamp(to_utf8(resultIter->getTimestamp()));
+		ustring extract(to_utf8(resultIter->getExtract(), charset));
+		string groupName;
+		TreeModel::iterator groupIter;
+		float currentScore = resultIter->getScore();
+		int rankDiff = 0;
+
+		if (m_groupMode != FLAT)
+		{
+			// What group should the result go to ?
+			if (rootType == ResultsModelColumns::ROW_HOST)
+			{
+				Url urlObj(location);
+				groupName = urlObj.getHost();
+			}
+			else
+			{
+				groupName = engineName;
+			}
+			// Add the group or get its position if it's already in
+			appendGroup(groupName, rootType, groupIter);
+
+			// Has the result's ranking changed ?
+			float oldestScore = 0;
+			float previousScore = queryHistory.hasItem(m_treeName, engineName,
+				location, oldestScore);
+#ifdef DEBUG
+			cout << "ResultsTree::addResults: " << location << " has scores "
+				<< previousScore << ", " << oldestScore << endl;
+#endif
+			if (previousScore > 0)
+			{
+				// Yes, it has
+				rankDiff = (int)(currentScore - previousScore);
+			}
+			else
+			{
+				// New results are displayed as such only if the query has already been run on the engine
+				if (isNewQuery == false)
+				{
+					// This is a magic value :-)
+					rankDiff = 666;
+				}
+			}
+
+			if (updateHistory == true)
+			{
+				queryHistory.insertItem(m_treeName, engineName, location,
+					title, extract, currentScore);
+			}
+		}
+
+		++count;
+
+		// We already got indexId from PinotSettings
+		unsigned int docIndexId = 0;
+		unsigned int docId = resultIter->getIsIndexed(docIndexId);
+		bool isIndexed = false;
+
+		if (docId > 0)
+		{
+			isIndexed = true;
+		}
+
+		// Has it been already viewed ?
+		bool wasViewed = viewHistory.hasItem(location);
+
+		// OK, add a row for this result within the group
+		TreeModel::iterator titleIter;
+		if (appendResult(title, location, (int)currentScore, rankDiff, isIndexed, wasViewed,
+			docId, timestamp, resultIter->serialize(),
+			engineId, indexId, titleIter, groupIter, true) == true)
+		{
+#ifdef DEBUG
+			cout << "ResultsTree::addResults: added row for result " << count
+				<< ", " << currentScore << ", " << isIndexed << " " << docId
+				<< " " << indexId << endl;
+#endif
+
+			if (groupIter)
+			{
+				// Update this map, so that we know which groups need updating
+				updatedGroups[groupName] = groupIter;
+			}
+		}
+	}
+
+	// Remove older items ?
+	if ((isNewQuery == false) &&
+		(updateHistory == true))
+	{
+#ifdef DEBUG
+		cout << "ResultsTree::addResults: removing items for " << m_treeName
+			<< ", " << engineName << " older than " << secondLastRunTime << endl;
+#endif
+		queryHistory.deleteItems(m_treeName, engineName, secondLastRunTime);
+	}
+
+	if (count > 0)
+	{
+#ifdef DEBUG
+		cout << "ResultsTree::addResults: " << updatedGroups.size() << " groups to update" << endl;
+#endif
+		// Update the groups to which we have added results
+		for (std::map<string, TreeModel::iterator>::iterator mapIter = updatedGroups.begin();
+			mapIter != updatedGroups.end(); mapIter++)
+		{
+			TreeModel::iterator groupIter = mapIter->second;
+			updateGroup(groupIter);
+		}
+
+		return true;
+	}
+	else if (m_groupMode == BY_ENGINE)
+	{
+		// If this didn't return any result, add an empty group
+		TreeModel::iterator groupIter;
+		appendGroup(engineName, rootType, groupIter);
+		updateGroup(groupIter);
+
+		return true;
+	}
+
+	return false;
+}
+
+//
+// Sets how results are grouped.
+//
+void ResultsTree::setGroupMode(GroupByMode groupMode)
+{
+	ResultsModelColumns::RowType currentType, newType;
+
+	if (m_groupMode == FLAT)
+	{
+		// No change possible
+		return;
+	}
+
+	if (m_groupMode == groupMode)
+	{
+		// No change
+		return;
+	}
+#ifdef DEBUG
+	cout << "ResultsTree::setGroupMode: set to " << groupMode << endl;
+#endif
+	m_groupMode = groupMode;
+
+	// Do we need to update the tree ?
+	TreeModel::Children children = m_refStore->children();
+	if (children.empty() == true)
+	{
+		return;
+	}
+
+	// What's the new grouping criteria ?
+	if (m_groupMode == BY_ENGINE)
+	{
+		// By search engine
+		currentType = ResultsModelColumns::ROW_HOST;
+		newType = ResultsModelColumns::ROW_ENGINE;
+	}
+	else
+	{
+		// By host
+		currentType = ResultsModelColumns::ROW_ENGINE;
+		newType = ResultsModelColumns::ROW_HOST;
+	}
+
+	// Clear the map
+	m_resultsGroups.clear();
+
+	// Unselect results
+	get_selection()->unselect_all();
+
+	TreeModel::Children::iterator iter = children.begin();
+	while (iter != children.end())
+	{
+		TreeModel::Row row = *iter;
+#ifdef DEBUG
+		cout << "ResultsTree::setGroupMode: looking at " << row[m_resultsColumns.m_url] << endl;
+#endif
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		// Skip new type and other rows
+		if ((type == newType) ||
+			(type == ResultsModelColumns::ROW_OTHER))
+		{
+			iter++;
+			continue;
+		}
+
+		TreeModel::Children groupChildren = iter->children();
+		TreeModel::Children::iterator childIter = groupChildren.begin();
+		// Type ROW_RESULT
+		while (childIter != groupChildren.end())
+		{
+			TreeModel::Row childRow = *childIter;
+			TreeModel::iterator groupIter, newIter;
+			bool success = false;
+
+			type = childRow[m_resultsColumns.m_resultType];
+			if (type == ResultsModelColumns::ROW_OTHER)
+			{
+				TreeModel::Children::iterator nextChildIter = childIter;
+				++nextChildIter;
+
+				// Erase this row
+				m_refStore->erase(childIter);
+				childIter = nextChildIter;
+				continue;
+			}
+
+			// We will need the URL and engines columns in all cases
+			string url(from_utf8(childRow[m_resultsColumns.m_url]));
+			unsigned int engineIds = childRow[m_resultsColumns.m_engines];
+			unsigned int indexIds = childRow[m_resultsColumns.m_indexes];
+
+			// Get the name of the group this should go into
+			if (m_groupMode == BY_HOST)
+			{
+				Url urlObj(url);
+#ifdef DEBUG
+				cout << "ResultsTree::setGroupMode: row " << url << endl;
+#endif
+				// Add group
+				if (appendGroup(urlObj.getHost(), newType, groupIter) == true)
+				{
+					// Add result
+					success = appendResult(childRow[m_resultsColumns.m_text],
+						childRow[m_resultsColumns.m_url],
+						childRow[m_resultsColumns.m_score],
+						childRow[m_resultsColumns.m_rankDiff],
+						childRow[m_resultsColumns.m_indexed],
+						childRow[m_resultsColumns.m_viewed],
+						childRow[m_resultsColumns.m_docId],
+						childRow[m_resultsColumns.m_timestamp],
+						childRow[m_resultsColumns.m_serial],
+						engineIds, indexIds,
+						newIter, groupIter, true);
+				}
+			}
+			else
+			{
+				// Look at the engines column and see which engines this result is for
+				set<string> engineNames;
+				m_settings.getEngineNames(engineIds, engineNames);
+				if (engineNames.empty() == false)
+				{
+#ifdef DEBUG
+					cout << "ResultsTree::setGroupMode: row is for " << engineNames.size() << " engine(s)" << endl;
+#endif
+					// Are there indexes in the list ?
+					set<string>::iterator backendIter = engineNames.find(m_settings.m_defaultBackend);
+					if ((backendIter != engineNames.end()) &&
+						(indexIds > 0))
+					{
+						// Erase this
+						engineNames.erase(backendIter);
+#ifdef DEBUG
+						cout << "ResultsTree::setGroupMode: row is for index(es) " << indexIds << endl;
+#endif
+
+						// Add entries for each index name so that we can loop once on engine names
+						set<string> indexNames;
+						m_settings.getIndexNames(indexIds, indexNames);
+						for (set<string>::iterator indexIter = indexNames.begin();
+							indexIter != indexNames.end(); ++indexIter)
+						{
+							string indexName(*indexIter);
+							engineNames.insert(indexName);
+#ifdef DEBUG
+							cout << "ResultsTree::setGroupMode: row is for index " << indexName << endl;
+#endif
+						}
+					}
+
+					for (set<string>::iterator engineIter = engineNames.begin();
+						engineIter != engineNames.end(); ++engineIter)
+					{
+						string engineName(*engineIter);
+						unsigned int indexId = 0;
+						unsigned int engineId = m_settings.getEngineId(engineName);
+
+						if (engineId == 0)
+						{
+							// This is actually an index, not an engine...
+							PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(engineName);
+							if (indexProps.m_location.empty() == false)
+							{
+								engineId = m_settings.getEngineId(m_settings.m_defaultBackend);
+							}
+#ifdef DEBUG
+							cout << "ResultsTree::setGroupMode: index " << indexId << endl;
+#endif
+						}
+#ifdef DEBUG
+						else cout << "ResultsTree::setGroupMode: no index" << endl;
+#endif
+
+						// Add group
+						if (appendGroup(engineName, newType, groupIter) == true)
+						{
+							// Add result
+							appendResult(childRow[m_resultsColumns.m_text],
+								childRow[m_resultsColumns.m_url],
+								childRow[m_resultsColumns.m_score],
+								childRow[m_resultsColumns.m_rankDiff],
+								childRow[m_resultsColumns.m_indexed],
+								childRow[m_resultsColumns.m_viewed],
+								childRow[m_resultsColumns.m_docId],
+								childRow[m_resultsColumns.m_timestamp],
+								childRow[m_resultsColumns.m_serial],
+								engineId, indexId,
+								newIter, groupIter, true);
+#ifdef DEBUG
+							cout << "ResultsTree::setGroupMode: row for " << engineName << endl;
+#endif
+						}
+					}
+
+					// FIXME: make sure at least one row was added
+					success = true;
+				}
+			}
+
+			if (success == true)
+			{
+				// Delete it
+				m_refStore->erase(*childIter);
+				childIter = groupChildren.begin();
+			}
+			else
+			{
+				// Don't delete anything then, just go to the next child
+				childIter++;
+			}
+		}
+
+		// Erase this row
+		m_refStore->erase(*iter);
+
+		// Get the new first row, that way we don't have to worry about iterators validity
+		iter = children.begin();
+	}
+
+	for (std::map<string, TreeModel::iterator>::iterator mapIter = m_resultsGroups.begin();
+		mapIter != m_resultsGroups.end(); mapIter++)
+	{
+		TreeModel::iterator groupIter = mapIter->second;
+		updateGroup(groupIter);
+	}
+
+	onSelectionChanged();
+}
+
+//
+// Gets the first selected item's URL.
+//
+ustring ResultsTree::getFirstSelectionURL(void)
+{
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return "";
+	}
+
+	list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+	TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+	TreeModel::Row row = *iter;
+
+	return row[m_resultsColumns.m_url];
+}
+
+//
+// Gets a list of selected items.
+//
+bool ResultsTree::getSelection(vector<DocumentInfo> &resultsList, bool skipIndexed)
+{
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return false;
+	}
+
+	// Go through selected items
+	for (list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+		itemPath != selectedItems.end(); ++itemPath)
+	{
+		TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		if (type != ResultsModelColumns::ROW_RESULT)
+		{
+			continue;
+		}
+
+		bool isIndexed = row[m_resultsColumns.m_indexed];
+		if ((skipIndexed == false) ||
+			(isIndexed == false))
+		{
+			DocumentInfo current;
+			string serial(row[m_resultsColumns.m_serial]);
+
+			current.deserialize(serial);
+
+			if (isIndexed == true)
+			{
+				set<string> indexNames;
+				unsigned int indexIds = row[m_resultsColumns.m_indexes];
+
+				m_settings.getIndexNames(indexIds, indexNames);
+				// Any internal index in there ?
+				for (set<string>::iterator indexIter = indexNames.begin(); indexIter != indexNames.end(); ++indexIter)
+				{
+					PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(*indexIter);
+					if (indexProps.m_internal == true)
+					{
+#ifdef DEBUG
+						cout << "ResultsTree::getSelection: result in internal index " << *indexIter << endl;
+#endif
+						current.setIsIndexed(indexProps.m_id, row[m_resultsColumns.m_docId]);
+						break;
+					}
+				}
+			}
+
+			resultsList.push_back(current);
+		}
+	}
+#ifdef DEBUG
+	cout << "ResultsTree::getSelection: " << resultsList.size() << " results selected" << endl;
+#endif
+
+	return true;
+}
+
+//
+// Sets the selected items' state.
+//
+void ResultsTree::setSelectionState(bool viewed)
+{
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return;
+	}
+
+	// Go through selected items
+	for (list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+		itemPath != selectedItems.end(); ++itemPath)
+	{
+		TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+  
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		if (type != ResultsModelColumns::ROW_RESULT)
+		{
+			continue;
+		}
+
+		if (viewed == true)
+		{
+			row[m_resultsColumns.m_viewed] = true;
+		}
+	}
+}
+
+//
+// Updates a result's properties.
+//
+bool ResultsTree::updateResult(const DocumentInfo &result)
+{
+	unsigned int indexId = 0;
+	unsigned int docId = result.getIsIndexed(indexId);
+
+	if (docId == 0)
+	{
+		return false;
+	}
+
+	// Go through the list
+	TreeModel::Children children = m_refStore->children();
+	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
+	{
+		TreeModel::Row row = *iter;
+
+		if (docId == row[m_resultsColumns.m_docId])
+		{
+			// FIXME: title, location should be converted based on the result's charset !
+			updateRow(row, result.getTitle(), result.getLocation(),
+				row[m_resultsColumns.m_score], row[m_resultsColumns.m_engines],
+				row[m_resultsColumns.m_indexes], docId,
+				to_utf8(result.getTimestamp()), result.serialize(),
+				ResultsModelColumns::ROW_RESULT,
+				row[m_resultsColumns.m_indexed], row[m_resultsColumns.m_viewed],
+				row[m_resultsColumns.m_rankDiff]);
+
+			return true;
+		}
+	}
+
+	return false;
+}
+
+//
+// Deletes the current selection.
+//
+bool ResultsTree::deleteSelection(void)
+{
+	bool empty = false;
+
+	// Go through selected items
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+	while (itemPath != selectedItems.end())
+	{
+		TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+		TreeModel::iterator parentIter;
+		bool updateParent = false;
+
+		// This could be a group that's in the map and should be removed first
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		if (type != ResultsModelColumns::ROW_RESULT)
+		{
+			string groupName(from_utf8(row[m_resultsColumns.m_text]));
+			std::map<string, TreeModel::iterator>::iterator mapIter = m_resultsGroups.find(groupName);
+			if (mapIter != m_resultsGroups.end())
+			{
+				m_resultsGroups.erase(mapIter);
+#ifdef DEBUG
+				cout << "ResultsTree::deleteSelection: erased group " << groupName << endl;
+#endif
+			}
+		}
+		else if (m_groupMode != FLAT)
+		{
+			// This item is a result
+			parentIter = row.parent();
+			updateParent = true;
+		}
+
+		// Unselect and erase
+		get_selection()->unselect(iter);
+		m_refStore->erase(row);
+
+		// Update group ?
+		if (updateParent == true)
+		{
+			// Update the group this result belongs to
+			updateGroup(parentIter);
+		}
+
+		selectedItems = get_selection()->get_selected_rows();
+		itemPath = selectedItems.begin();
+	}
+
+	TreeModel::Children children = m_refStore->children();
+	empty = children.empty();
+
+	refresh();
+
+	return empty;
+}
+
+//
+// Deletes results.
+//
+bool ResultsTree::deleteResults(const string &engineName)
+{
+	unsigned int indexId = 0;
+	unsigned int engineId = m_settings.getEngineId(engineName);
+	unsigned int count = 0;
+
+	if (engineId == 0)
+	{
+		// Chances are this engine is an index
+		PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(engineName);
+		if (indexProps.m_location.empty() == false)
+		{
+			// Yes, it is
+			indexId = indexProps.m_id;
+			engineId = m_settings.getEngineId(m_settings.m_defaultBackend);
+		}
+	}
+
+	TreeModel::Children groups = m_refStore->children();
+	for (TreeModel::Children::iterator parentIter = groups.begin();
+		parentIter != groups.end(); ++parentIter)
+	{
+		TreeModel::Row row = *parentIter;
+
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		if ((type != ResultsModelColumns::ROW_ENGINE) &&
+			(type != ResultsModelColumns::ROW_HOST))
+		{
+			continue;
+		}
+
+		TreeModel::Children children = parentIter->children();
+		TreeModel::Children::iterator iter = children.begin();
+		while (iter != children.end())
+		{
+			row = *iter;
+
+			type = row[m_resultsColumns.m_resultType];
+			if (((type == ResultsModelColumns::ROW_RESULT) &&
+				(row[m_resultsColumns.m_engines] == engineId) &&
+				(row[m_resultsColumns.m_indexes] == indexId)) ||
+				(type == ResultsModelColumns::ROW_OTHER))
+			{
+				TreeModel::Children::iterator nextIter = iter;
+				++nextIter;
+				++count;
+
+				// Erase this row
+				m_refStore->erase(*iter);
+				iter = nextIter;
+				continue;
+			}
+
+			// Next
+			++iter;
+		}
+	}
+
+	if (count > 0)
+	{
+		onSelectionChanged();
+#ifdef DEBUG
+		cout << "ResultsTree::deleteResults: erased " << count << " rows" << endl;
+#endif
+		return true;
+	}
+
+	return false;
+}
+
+//
+// Returns the number of rows.
+//
+unsigned int ResultsTree::getRowsCount(void)
+{
+	return m_refStore->children().size();
+}
+
+//
+// Refreshes the tree.
+//
+void ResultsTree::refresh(void)
+{
+	// FIXME: not sure why, but this helps with refreshing the tree
+	columns_autosize();
+}
+
+//
+// Clears the tree.
+//
+void ResultsTree::clear(void)
+{
+	// Unselect results
+	get_selection()->unselect_all();
+
+	// Remove existing rows in the tree
+	TreeModel::Children children = m_refStore->children();
+	if (children.empty() == false)
+	{
+		// Clear the groups map
+		m_resultsGroups.clear();
+
+		TreeModel::Children::iterator iter = children.begin();
+		while (iter != children.end())
+		{
+			// Erase this row
+			m_refStore->erase(*iter);
+
+			// Get the new first row
+			children = m_refStore->children();
+			iter = children.begin();
+		}
+		m_refStore->clear();
+
+		// Clear the extract
+		RefPtr<TextBuffer> refBuffer = m_extractTextView->get_buffer();
+		if (refBuffer)
+		{
+			refBuffer->set_text("");
+		}
+
+		onSelectionChanged();
+	}
+}
+
+//
+// Shows or hides the extract field.
+//
+void ResultsTree::showExtract(bool showExtract)
+{
+	m_showExtract = showExtract;
+	if (m_showExtract == true)
+	{
+		// Show the extract
+		m_pExtractScrolledwindow->show();
+	}
+	else
+	{
+		// Hide
+		m_pExtractScrolledwindow->hide();
+	}
+}
+
+//
+// Exports results to a file.
+//
+void ResultsTree::exportResults(const string &fileName,
+	const string &queryName, bool csvFormat)
+{
+	QueryProperties queryProps(queryName, "");
+	ResultsExporter *pExporter = NULL;
+	unsigned int maxResultsCount = 0;
+
+	if (fileName.empty() == true)
+	{
+		return;
+	}
+
+	if (csvFormat == true)
+	{
+		pExporter = new CSVExporter(fileName,
+			queryProps);
+	}
+	else
+	{
+		pExporter = new OpenSearchExporter(fileName,
+			queryProps);
+	}
+
+	// How many results are there altogether ?
+	TreeModel::Children children = m_refStore->children();
+	if (m_groupMode == FLAT)
+	{
+		maxResultsCount = children.size();
+	}
+	else for (TreeModel::Children::iterator iter = children.begin();
+		iter != children.end(); ++iter)
+	{
+		TreeModel::Row row = *iter;
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+
+		if ((type != ResultsModelColumns::ROW_ENGINE) &&
+			(type != ResultsModelColumns::ROW_HOST))
+		{
+			continue;
+		}
+
+		TreeModel::Children groupChildren = iter->children();
+		maxResultsCount += groupChildren.size();
+	}
+#ifdef DEBUG
+	cout << "ResultsTree::exportResults: " << maxResultsCount << " results to export" << endl;
+#endif
+
+	// Start
+	pExporter->exportStart("", maxResultsCount);
+
+	if (m_groupMode == FLAT)
+	{
+		exportResults(children, queryName, pExporter);
+	}
+	else for (TreeModel::Children::iterator iter = children.begin();
+		iter != children.end(); ++iter)
+	{
+		TreeModel::Row row = *iter;
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+
+		if ((type != ResultsModelColumns::ROW_ENGINE) &&
+			(type != ResultsModelColumns::ROW_HOST))
+		{
+			continue;
+		}
+
+		TreeModel::Children groupChildren = iter->children();
+		exportResults(groupChildren, queryName, pExporter);
+	}
+
+	// End
+	pExporter->exportEnd();
+
+	delete pExporter;
+}
+
+//
+// Exports results to a file.
+//
+void ResultsTree::exportResults(TreeModel::Children &groupChildren,
+	const string &queryName, ResultsExporter *pExporter)
+{
+	QueryHistory queryHistory(m_settings.getHistoryDatabaseName());
+
+	for (TreeModel::Children::iterator childIter = groupChildren.begin();
+		childIter != groupChildren.end(); ++childIter)
+	{
+		TreeModel::Row childRow = *childIter;
+		ResultsModelColumns::RowType type = childRow[m_resultsColumns.m_resultType];
+
+		if (type == ResultsModelColumns::ROW_OTHER)
+		{
+			continue;
+		}
+
+		set<string> engineNames, indexNames;
+		DocumentInfo result;
+		string engineName, serial(childRow[m_resultsColumns.m_serial]);
+		unsigned int engineIds = childRow[m_resultsColumns.m_engines];
+		unsigned int indexIds = childRow[m_resultsColumns.m_indexes];
+
+#ifdef DEBUG
+		cout << "ResultsTree::exportResults: engines " << engineIds << ", indexes " << indexIds << endl;
+#endif
+		result.deserialize(serial);
+		m_settings.getEngineNames(engineIds, engineNames);
+		if (engineNames.empty() == false)
+		{
+			// Get the first engine this result was obtained from
+			engineName = *engineNames.begin();
+			if (engineName == m_settings.m_defaultBackend)
+			{
+				m_settings.getIndexNames(indexIds, indexNames);
+				if (indexNames.empty() == false)
+				{
+					// Use the name of the first index as engine name
+					engineName = (*indexNames.begin());
+				}
+			}
+		}
+		if (m_groupMode != FLAT)
+		{
+			result.setExtract(queryHistory.getItemExtract(from_utf8(queryName),
+				engineName, result.getLocation()));
+		}
+		else
+		{
+			engineName = m_treeName;
+		}
+		result.setTimestamp(from_utf8(childRow[m_resultsColumns.m_timestamp]));
+
+		// Export this
+		if (pExporter != NULL)
+		{
+			pExporter->exportResult(engineName, result);
+		}
+	}
+}
+
+//
+// Returns the changed selection signal.
+//
+sigc::signal1<void, ustring>& ResultsTree::getSelectionChangedSignal(void)
+{
+	return m_signalSelectionChanged;
+}
+
+//
+// Returns the double-click signal.
+//
+sigc::signal0<void>& ResultsTree::getDoubleClickSignal(void)
+{
+	return m_signalDoubleClick;
+}
+
+//
+// Adds a new row in the results tree.
+//
+bool ResultsTree::appendResult(const ustring &text, const ustring &url,
+	int score, int rankDiff, bool isIndexed, bool wasViewed,
+	unsigned int docId, const ustring &timestamp,
+	const string &serial, unsigned int engineId,
+	unsigned int indexId, TreeModel::iterator &newRowIter,
+	const TreeModel::iterator &parentIter, bool noDuplicates)
+{
+	if (!parentIter)
+	{
+#ifdef DEBUG
+		cout << "ResultsTree::appendResult: no parent" << endl;
+#endif
+		newRowIter = m_refStore->append();
+	}
+	else
+	{
+		const TreeModel::Row parentRow = *parentIter;
+
+		// Merge duplicates within groups ?
+		if (noDuplicates == true)
+		{
+			// Look for a row with the same URL and query. For instance, in group
+			// by host mode, if a page is returned by several search engines, it
+			// should appear only once
+			TreeModel::Children children = parentRow.children();
+			if (children.empty() == false)
+			{
+				for (TreeModel::Children::iterator childIter = children.begin();
+					childIter != children.end(); ++childIter)
+				{
+					TreeModel::Row row = *childIter;
+					if (row[m_resultsColumns.m_url] == url)
+					{
+						// Update the engines column...
+						row[m_resultsColumns.m_engines] = row[m_resultsColumns.m_engines] | engineId;
+						// ...and the indexes column too
+						row[m_resultsColumns.m_indexes] = row[m_resultsColumns.m_indexes] | engineId;
+
+						newRowIter = childIter;
+						return true;
+					}
+				}
+			}
+		}
+
+		newRowIter = m_refStore->append(parentRow.children());
+	}
+
+	TreeModel::Row childRow = *newRowIter;
+	updateRow(childRow, text, url, score, engineId, indexId,
+		docId, timestamp, serial, ResultsModelColumns::ROW_RESULT, isIndexed,
+		wasViewed, rankDiff);
+
+	return true;
+}
+
+//
+// Adds a results group
+//
+bool ResultsTree::appendGroup(const string &groupName, ResultsModelColumns::RowType groupType,
+	TreeModel::iterator &groupIter)
+{
+	bool success = false;
+
+	// Is this group already in ?
+	std::map<string, TreeModel::iterator>::iterator mapIter = m_resultsGroups.find(groupName);
+	if (mapIter == m_resultsGroups.end())
+	{
+		// No, it isn't: insert a new group in the tree
+		groupIter = m_refStore->append();
+		TreeModel::Row groupRow = *groupIter;
+		updateRow(groupRow, groupName,
+			"", 0, 0, 0, 0, "", "", groupType,
+			false, false, 0);
+
+		// Update the map
+		m_resultsGroups[groupName] = groupIter;
+		success = true;
+#ifdef DEBUG
+		cout << "ResultsTree::appendGroup: updated map with " << groupName << endl;
+#endif
+	}
+	else
+	{
+		// Yes, it is
+		groupIter = mapIter->second;
+#ifdef DEBUG
+		cout << "ResultsTree::appendGroup: found " << groupName << " in map" << endl;
+#endif
+		success = true;
+	}
+
+	return success;
+}
+
+//
+// Updates a results group.
+//
+void ResultsTree::updateGroup(TreeModel::iterator &groupIter)
+{
+	TreeModel::Row groupRow = (*groupIter);
+	int averageScore = 0;
+
+	// Check the iterator doesn't point to a result
+	ResultsModelColumns::RowType type = groupRow[m_resultsColumns.m_resultType];
+	if (type == ResultsModelColumns::ROW_RESULT)
+	{
+		return;
+	}
+
+	// Modify the "score" column to indicate the number of results in that group
+	TreeModel::Children groupChildren = groupIter->children();
+	if (groupChildren.empty() == false)
+	{
+		for (TreeModel::Children::iterator childIter = groupChildren.begin();
+			childIter != groupChildren.end(); ++childIter)
+		{
+			TreeModel::Row row = *childIter;
+
+			averageScore += row[m_resultsColumns.m_score];
+		}
+
+		averageScore = (int)(averageScore / groupChildren.size());
+	}
+	else
+	{
+		TreeModel::Row groupRow = *groupIter;
+		TreeModel::iterator childIter = m_refStore->append(groupRow.children());
+		TreeModel::Row childRow = *childIter;
+
+		updateRow(childRow, _("No results"), "", 0, 0, 0, 0,
+			"", "", ResultsModelColumns::ROW_OTHER, false, false, 0);
+	}
+	groupRow[m_resultsColumns.m_score] = averageScore;
+
+	// Expand this group
+	TreeModel::Path groupPath = m_refStore->get_path(groupIter);
+	expand_row(groupPath, true);
+}
+
+//
+// Updates a row.
+//
+void ResultsTree::updateRow(TreeModel::Row &row, const ustring &text,
+	const ustring &url, int score, 	unsigned int engineId, unsigned int indexId,
+	unsigned int docId, const ustring &timestamp, const string &serial,
+	ResultsModelColumns::RowType resultType, bool indexed, bool viewed, int rankDiff)
+{
+	try
+	{
+		row[m_resultsColumns.m_text] = text;
+		row[m_resultsColumns.m_url] = url;
+		row[m_resultsColumns.m_score] = score;
+		row[m_resultsColumns.m_scoreText] = "";
+		row[m_resultsColumns.m_engines] = engineId;
+		row[m_resultsColumns.m_indexes] = indexId;
+		row[m_resultsColumns.m_docId] = docId;
+		row[m_resultsColumns.m_resultType] = resultType;
+		row[m_resultsColumns.m_timestamp] = timestamp;
+		row[m_resultsColumns.m_timestampTime] = TimeConverter::fromTimestamp(from_utf8(timestamp));
+		row[m_resultsColumns.m_serial] = serial;
+
+		row[m_resultsColumns.m_indexed] = indexed;
+		row[m_resultsColumns.m_viewed] = viewed;
+		row[m_resultsColumns.m_rankDiff] = rankDiff;
+	}
+	catch (Error &error)
+	{
+#ifdef DEBUG
+		cout << "ResultsTree::updateRow: " << error.what() << endl;
+#endif
+	}
+	catch (...)
+	{
+#ifdef DEBUG
+		cout << "ResultsTree::updateRow: caught unknown exception" << endl;
+#endif
+	}
+}
+
+//
+// Retrieves the extract to show for the given row.
+//
+ustring ResultsTree::findResultsExtract(const Gtk::TreeModel::Row &row)
+{
+	QueryHistory queryHistory(m_settings.getHistoryDatabaseName());
+	set<string> engineNames, indexNames;
+	string url(from_utf8(row[m_resultsColumns.m_url]));
+	string extract;
+	unsigned int engineIds = row[m_resultsColumns.m_engines];
+	unsigned int indexIds = row[m_resultsColumns.m_indexes];
+
+#ifdef DEBUG
+	cout << "ResultsTree::findResultsExtract: " << url << " has engines " << engineIds << ", indexes " << indexIds << endl;
+#endif
+	m_settings.getEngineNames(engineIds, engineNames);
+	for (set<string>::const_iterator engineIter = engineNames.begin();
+		engineIter != engineNames.end(); ++engineIter)
+	{
+		string engineName(*engineIter);
+
+		indexNames.clear();
+		if (engineName == m_settings.m_defaultBackend)
+		{
+			m_settings.getIndexNames(indexIds, indexNames);
+		}
+		else
+		{
+			// That's not an index but pretend it is
+			indexNames.insert(engineName);
+		}
+
+		for (set<string>::const_iterator indexIter = indexNames.begin();
+			indexIter != indexNames.end(); ++indexIter)
+		{
+			// Use the name of this index as engine name
+			engineName = (*indexNames.begin());
+
+#ifdef DEBUG
+			cout << "ResultsTree::findResultsExtract: engine or index " << engineName << endl;
+#endif
+			extract = queryHistory.getItemExtract(from_utf8(m_treeName), engineName, url);
+			if (extract.empty() == false)
+			{
+				// Stop here
+				return extract;
+			}
+		}
+	}
+
+	return "";
+}


Property changes on: trunk/UI/GTK2/src/ResultsTree.cc
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,1656 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <ctype.h>
-#include <iostream>
-#include <gdkmm/color.h>
-#include <gtkmm/alignment.h>
-#include <gtkmm/box.h>
-#include <gtkmm/buttonbox.h>
-#include <gtkmm/image.h>
-#include <gtkmm/label.h>
-#include <gtkmm/stock.h>
-#include <gtkmm/cellrendererprogress.h>
-
-#include "config.h"
-#include "NLS.h"
-#include "StringManip.h"
-#include "TimeConverter.h"
-#include "Url.h"
-#include "QueryHistory.h"
-#include "ViewHistory.h"
-#include "PinotSettings.h"
-#include "PinotUtils.h"
-#include "ResultsTree.h"
-
-using namespace std;
-using namespace Glib;
-using namespace Gdk;
-using namespace Gtk;
-
-ResultsTree::ResultsTree(const ustring &queryName, Menu *pPopupMenu,
-	GroupByMode groupMode, PinotSettings &settings) :
-	TreeView(),
-	m_treeName(queryName),
-	m_pPopupMenu(pPopupMenu),
-	m_pResultsScrolledwindow(NULL),
-	m_settings(settings),
-	m_pExtractScrolledwindow(NULL),
-	m_extractTextView(NULL),
-	m_showExtract(true),
-	m_groupMode(groupMode)
-{
-	TreeViewColumn *pColumn = NULL;
-
-	m_pResultsScrolledwindow = manage(new ScrolledWindow());
-	m_pExtractScrolledwindow = manage(new ScrolledWindow());
-	m_extractTextView = manage(new TextView());
-
-	// This is the actual results tree
-	set_events(Gdk::BUTTON_PRESS_MASK);
-	set_flags(CAN_FOCUS);
-	set_headers_clickable(true);
-	set_headers_visible(true);
-	set_rules_hint(true);
-	set_reorderable(false);
-	set_enable_search(true);
-	get_selection()->set_mode(SELECTION_MULTIPLE);
-	m_pResultsScrolledwindow->set_flags(CAN_FOCUS);
-	m_pResultsScrolledwindow->set_border_width(4);
-	m_pResultsScrolledwindow->set_shadow_type(SHADOW_NONE);
-	m_pResultsScrolledwindow->set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
-	m_pResultsScrolledwindow->property_window_placement().set_value(CORNER_TOP_LEFT);
-	m_pResultsScrolledwindow->add(*this);
-
-	// That's for the extract view
-	m_extractTextView->set_flags(CAN_FOCUS);
-	m_extractTextView->set_editable(false);
-	m_extractTextView->set_cursor_visible(false);
-	m_extractTextView->set_pixels_above_lines(0);
-	m_extractTextView->set_pixels_below_lines(0);
-	m_extractTextView->set_pixels_inside_wrap(0);
-	m_extractTextView->set_left_margin(0);
-	m_extractTextView->set_right_margin(0);
-	m_extractTextView->set_indent(0);
-	m_extractTextView->set_wrap_mode(WRAP_WORD);
-	m_extractTextView->set_justification(JUSTIFY_LEFT);
-	RefPtr<TextTag> refBoldTag = TextBuffer::Tag::create("bold");
-	refBoldTag->property_weight() = 900;
-	RefPtr<TextBuffer> refBuffer = m_extractTextView->get_buffer();
-	if (refBuffer)
-	{
-		refBuffer->get_tag_table()->add(refBoldTag); 
-	}
-	m_pExtractScrolledwindow->set_flags(CAN_FOCUS);
-	m_pExtractScrolledwindow->set_border_width(4);
-	m_pExtractScrolledwindow->set_shadow_type(SHADOW_NONE);
-	m_pExtractScrolledwindow->set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
-	m_pExtractScrolledwindow->property_window_placement().set_value(CORNER_TOP_LEFT);
-	m_pExtractScrolledwindow->add(*m_extractTextView);
-
-	// Associate the columns model to the results tree
-	m_refStore = TreeStore::create(m_resultsColumns);
-	set_model(m_refStore);
-
-	if (m_groupMode != FLAT)
-	{
-		// The first column is for the status icons
-		pColumn = new TreeViewColumn("");
-		// Pack an icon renderer for the viewed status
-		CellRendererPixbuf *pIconRenderer = new CellRendererPixbuf();
-		pColumn->pack_start(*manage(pIconRenderer), false);
-		pColumn->set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &ResultsTree::renderViewStatus));
-		// Pack a second icon renderer for the indexed status
-		pIconRenderer = new CellRendererPixbuf();
-		pColumn->pack_start(*manage(pIconRenderer), false);
-		pColumn->set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &ResultsTree::renderIndexStatus));
-		// And a third one for the ranking
-		pIconRenderer = new CellRendererPixbuf();
-		pColumn->pack_start(*manage(pIconRenderer), false);
-		pColumn->set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &ResultsTree::renderRanking));
-		pColumn->set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
-		append_column(*manage(pColumn));
-
-		// This is the score column
-		pColumn = new TreeViewColumn(_("Score"));
-		CellRendererProgress *pProgressRenderer = new CellRendererProgress();
-		pColumn->pack_start(*manage(pProgressRenderer));
-		pColumn->add_attribute(pProgressRenderer->property_text(), m_resultsColumns.m_scoreText);
-		pColumn->add_attribute(pProgressRenderer->property_value(), m_resultsColumns.m_score);
-		pColumn->set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
-		pColumn->set_sort_column(m_resultsColumns.m_score);
-		append_column(*manage(pColumn));
-	}
-
-	// This is the title column
-	pColumn = new TreeViewColumn(_("Title"));
-	CellRendererText *pTextRenderer = new CellRendererText();
-	pColumn->pack_start(*manage(pTextRenderer));
-	pColumn->set_cell_data_func(*pTextRenderer, sigc::mem_fun(*this, &ResultsTree::renderTitleColumn));
-	pColumn->add_attribute(pTextRenderer->property_text(), m_resultsColumns.m_text);
-	pColumn->set_resizable(true);
-	pColumn->set_sort_column(m_resultsColumns.m_text);
-	append_column(*manage(pColumn));
-
-	// URL
-	pColumn = create_column(_("URL"), m_resultsColumns.m_url, false, true, m_resultsColumns.m_url);
-	if (pColumn != NULL)
-	{
-		pColumn->set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
-		append_column(*manage(pColumn));
-	}
-
-	// The last column is for the timestamp
-	pColumn = create_column(_("Date"), m_resultsColumns.m_timestamp, false, true, m_resultsColumns.m_timestampTime);
-	if (pColumn != NULL)
-	{
-		pColumn->set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
-		append_column(*manage(pColumn));
-	}
-	
-	// Connect the signals
-	signal_button_press_event().connect_notify(
-		sigc::mem_fun(*this, &ResultsTree::onButtonPressEvent));
-	get_selection()->signal_changed().connect(
-		sigc::mem_fun(*this, &ResultsTree::onSelectionChanged));
-
-	// Enable interactive search
-	set_search_column(m_resultsColumns.m_text.index());
-	// Control which rows can be selected
-	get_selection()->set_select_function(sigc::mem_fun(*this, &ResultsTree::onSelectionSelect));
-	// Listen for style changes
-	signal_style_changed().connect_notify(sigc::mem_fun(*this, &ResultsTree::onStyleChanged));
-
-	// Render the icons
-	m_indexedIconPixbuf = render_icon(Stock::INDEX, ICON_SIZE_MENU, "MetaSE-pinot");
-	m_viewededIconPixbuf = render_icon(Stock::YES, ICON_SIZE_MENU, "MetaSE-pinot");
-	m_upIconPixbuf = render_icon(Stock::GO_UP, ICON_SIZE_MENU, "MetaSE-pinot");
-	m_downIconPixbuf = render_icon(Stock::GO_DOWN, ICON_SIZE_MENU, "MetaSE-pinot");
-
-	// Show all
-	show();
-	m_pResultsScrolledwindow->show();
-	m_extractTextView->show();
-	m_pExtractScrolledwindow->show();
-}
-
-ResultsTree::~ResultsTree()
-{
-}
-
-void ResultsTree::renderViewStatus(CellRenderer *pRenderer, const TreeModel::iterator &iter)
-{
-	TreeModel::Row row = *iter;
-
-	if (pRenderer == NULL)
-	{
-		return;
-	}
-
-	CellRendererPixbuf *pIconRenderer = dynamic_cast<CellRendererPixbuf*>(pRenderer);
-	if (pIconRenderer != NULL)
-	{
-		// Has this result been already viewed ?
-		if ((row[m_resultsColumns.m_viewed] == true) &&
-			(m_viewededIconPixbuf))
-		{
-			pIconRenderer->property_pixbuf() = m_viewededIconPixbuf;
-		}
-		else
-		{
-			pIconRenderer->property_pixbuf().reset_value();
-		}
-	}
-}
-
-void ResultsTree::renderIndexStatus(CellRenderer *pRenderer, const TreeModel::iterator &iter)
-{
-	TreeModel::Row row = *iter;
-
-	if (pRenderer == NULL)
-	{
-		return;
-	}
-
-	CellRendererPixbuf *pIconRenderer = dynamic_cast<CellRendererPixbuf*>(pRenderer);
-	if (pIconRenderer != NULL)
-	{
-		// Is this result indexed ?
-		if ((row[m_resultsColumns.m_indexed] == true) &&
-			(m_indexedIconPixbuf))
-		{
-			pIconRenderer->property_pixbuf() = m_indexedIconPixbuf;
-		}
-		else
-		{
-			pIconRenderer->property_pixbuf().reset_value();
-		}
-	}
-}
-
-void ResultsTree::renderRanking(CellRenderer *pRenderer, const TreeModel::iterator &iter)
-{
-	TreeModel::Row row = *iter;
-
-	if (pRenderer == NULL)
-	{
-		return;
-	}
-
-	CellRendererPixbuf *pIconRenderer = dynamic_cast<CellRendererPixbuf*>(pRenderer);
-	if (pIconRenderer != NULL)
-	{
-		int rankDiff = row[m_resultsColumns.m_rankDiff];
-
-		// Has this result's score changed ?
-		if ((rankDiff > 0) &&
-			(rankDiff != 666))
-		{
-			pIconRenderer->property_pixbuf() = m_upIconPixbuf;
-		}
-		else if (rankDiff < 0)
-		{
-			pIconRenderer->property_pixbuf() = m_downIconPixbuf;
-		}
-		else
-		{
-			pIconRenderer->property_pixbuf().reset_value();
-		}
-	}
-}
-
-void ResultsTree::renderTitleColumn(CellRenderer *pRenderer, const TreeModel::iterator &iter)
-{
-	TreeModel::Row row = *iter;
-
-	if (pRenderer == NULL)
-	{
-		return;
-	}
-
-	CellRendererText *pTextRenderer = dynamic_cast<CellRendererText*>(pRenderer);
-	if (pTextRenderer != NULL)
-	{
-		// Is this result new ?
-		if (row[m_resultsColumns.m_rankDiff] == 666)
-		{
-			Color newColour;
-
-			newColour.set_red(m_settings.m_newResultsColourRed);
-			newColour.set_green(m_settings.m_newResultsColourGreen);
-			newColour.set_blue(m_settings.m_newResultsColourBlue);
-
-			// Change the row's background
-			pTextRenderer->property_background_gdk() = newColour;
-		}
-		else
-		{
-			pTextRenderer->property_background_gdk().reset_value();
-		}
-
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		if ((type == ResultsModelColumns::ROW_ENGINE) ||
-			(type == ResultsModelColumns::ROW_HOST))
-		{
-			ustring markup("<b>");
-			markup += row[m_resultsColumns.m_text];
-			markup += "</b>";
-			pTextRenderer->property_markup() = markup;
-		}
-	}
-}
-
-void ResultsTree::onButtonPressEvent(GdkEventButton *ev)
-{
-	// Check for popup click
-	if ((ev->type == GDK_BUTTON_PRESS) &&
-		(ev->button == 3) )
-	{
-		if (m_pPopupMenu != NULL)
-		{
-			m_pPopupMenu->popup(ev->button, ev->time);
-		}
-	}
-	// Check for double clicks
-	else if (ev->type == GDK_2BUTTON_PRESS)
-	{
-#ifdef DEBUG
-		cout << "ResultsTree::onButtonPressEvent: double click on button " << ev->button << endl;
-#endif
-		m_signalDoubleClick();
-	}
-}
-
-void ResultsTree::onSelectionChanged(void)
-{
-	m_signalSelectionChanged(m_treeName);
-}
-
-bool ResultsTree::onSelectionSelect(const RefPtr<TreeModel>& model,
-	const TreeModel::Path& node_path, bool path_currently_selected)
-{
-	const TreeModel::iterator iter = model->get_iter(node_path);
-	const TreeModel::Row row = *iter;
-
-	// In flat mode, don't bother about the extract
-	if ((path_currently_selected == false) &&
-		(m_groupMode != FLAT))
-	{
-		// Is this an actual result ?
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		if (type != ResultsModelColumns::ROW_RESULT)
-		{
-			return true;
-		}
-
-		RefPtr<TextBuffer> refBuffer = m_extractTextView->get_buffer();
-		if (refBuffer)
-		{
-			ustring extract(findResultsExtract(row));
-			ustring::size_type textPos = 0, boldPos = extract.find("<b>");
-
-			// Clear the extract
-			refBuffer->set_text("");
-
-#ifdef DEBUG
-			cout << "ResultsTree::onSelectionSelect: extract for " << row[m_resultsColumns.m_url] << endl;
-#endif
-			if (boldPos == ustring::npos)
-			{
-				refBuffer->set_text(extract);
-			}
-			else
-			{
-				TextBuffer::iterator bufferPos = refBuffer->begin();
-
-				while (boldPos != ustring::npos)
-				{
-					bufferPos = refBuffer->insert(bufferPos, extract.substr(textPos, boldPos - textPos));
-
-					textPos = boldPos + 3;
-					boldPos = extract.find("</b>", textPos);
-					if (boldPos == ustring::npos)
-					{
-						continue;
-					}
-					bufferPos = refBuffer->insert_with_tag(bufferPos, extract.substr(textPos, boldPos - textPos), "bold");
-
-					// Next
-					textPos = boldPos + 4;
-					boldPos = extract.find("<b>", textPos);
-				}
-
-				if (textPos + 1 < extract.length())
-				{
-					bufferPos = refBuffer->insert(bufferPos, extract.substr(textPos, boldPos - textPos));
-				}
-			}
-		}
-	}
-
-	return true;
-}
-
-void ResultsTree::onStyleChanged(const RefPtr<Style> &previous_style)
-{
-#ifdef DEBUG
-	cout << "ResultsTree::onStyleChanged: called" << endl;
-#endif
-	// FIXME: find better icons :-)
-	m_indexedIconPixbuf = render_icon(Stock::INDEX, ICON_SIZE_MENU, "MetaSE-pinot");
-	m_viewededIconPixbuf = render_icon(Stock::YES, ICON_SIZE_MENU, "MetaSE-pinot");
-	m_upIconPixbuf = render_icon(Stock::GO_UP, ICON_SIZE_MENU, "MetaSE-pinot");
-	m_downIconPixbuf = render_icon(Stock::GO_DOWN, ICON_SIZE_MENU, "MetaSE-pinot");
-}
-
-//
-// Returns the results scrolled window.
-//
-ScrolledWindow *ResultsTree::getResultsScrolledWindow(void) const
-{
-	return m_pResultsScrolledwindow;
-}
-
-//
-// Returns the extract scrolled window.
-//
-ScrolledWindow *ResultsTree::getExtractScrolledWindow(void) const
-{
-	return m_pExtractScrolledwindow;
-}
-
-//
-// Returns the extract tree.
-//
-bool ResultsTree::focusOnExtract(void) const
-{
-	return m_extractTextView->is_focus();
-}
-
-//
-// Returns the extract.
-//
-ustring ResultsTree::getExtract(void) const
-{
-	ustring text;
-
-	RefPtr<TextBuffer> refBuffer = m_extractTextView->get_buffer();
-	if (refBuffer)
-	{
-		text = refBuffer->get_text();
-	}
-
-	return text;
-}
-
-//
-// Adds a set of results.
-// Returns true if something was added to the tree.
-//
-bool ResultsTree::addResults(const string &engineName, const vector<DocumentInfo> &resultsList,
-	const string &charset, bool updateHistory)
-{
-	std::map<string, TreeModel::iterator> updatedGroups;
-	ResultsModelColumns::RowType rootType;
-	unsigned int count = 0;
-
-	// What's the grouping criteria ?
-	if (m_groupMode == BY_ENGINE)
-	{
-		// By search engine
-		rootType = ResultsModelColumns::ROW_ENGINE;
-	}
-	else if (m_groupMode == BY_HOST)
-	{
-		// By host
-		rootType = ResultsModelColumns::ROW_HOST;
-	}
-
-	unsigned int indexId = 0;
-	unsigned int engineId = 0;
-
-	// Find out what the search engine ID is
-	if (engineName.empty() == false)
-	{
-		engineId = m_settings.getEngineId(engineName);
-		if (engineId == 0)
-		{
-			// Chances are this engine is an index
-			PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(engineName);
-			if (indexProps.m_location.empty() == false)
-			{
-				// Yes, it is
-				indexId = indexProps.m_id;
-				engineId = m_settings.getEngineId(m_settings.m_defaultBackend);
-#ifdef DEBUG
-				cout << "ResultsTree::addResults: engine is index " << engineName << " " << indexId << " " << engineId << endl;
-#endif
-			}
-#ifdef DEBUG
-			else cout << "ResultsTree::addResults: " << engineName << " is not an index" <<  endl;
-#endif
-		}
-#ifdef DEBUG
-		else cout << "ResultsTree::addResults: ID for engine " << engineName << " is " << engineId <<  endl;
-#endif
-	}
-
-	QueryHistory queryHistory(m_settings.getHistoryDatabaseName());
-	ViewHistory viewHistory(m_settings.getHistoryDatabaseName());
-	set<time_t> latestRuns;
-	time_t secondLastRunTime = 0;
-	bool isNewQuery = false;
-
-	// Is this a new query ?
-	if ((queryHistory.getLatestRuns(m_treeName, engineName, 2, latestRuns) == false) ||
-		(latestRuns.empty() == true))
-	{
-		isNewQuery = true;
-	}
-	else
-	{
-		set<time_t>::const_iterator runIter = latestRuns.begin();
-
-		// We only need to keep the last two runs
-		if (runIter != latestRuns.end())
-		{
-			++runIter;
-			if (runIter != latestRuns.end())
-			{
-				secondLastRunTime = (*runIter);
-			}
-		}
-	}
-#ifdef DEBUG
-	cout << "ResultsTree::addResults: " << resultsList.size() << " results with charset " << charset
-		<< ", second last run " << secondLastRunTime << endl;
-#endif
-
-	// Look at the results list
-	for (vector<DocumentInfo>::const_iterator resultIter = resultsList.begin();
-		resultIter != resultsList.end(); ++resultIter)
-	{
-		ustring title(to_utf8(resultIter->getTitle(), charset));
-		ustring location(to_utf8(resultIter->getLocation(), charset));
-		ustring timestamp(to_utf8(resultIter->getTimestamp()));
-		ustring extract(to_utf8(resultIter->getExtract(), charset));
-		string groupName;
-		TreeModel::iterator groupIter;
-		float currentScore = resultIter->getScore();
-		int rankDiff = 0;
-
-		if (m_groupMode != FLAT)
-		{
-			// What group should the result go to ?
-			if (rootType == ResultsModelColumns::ROW_HOST)
-			{
-				Url urlObj(location);
-				groupName = urlObj.getHost();
-			}
-			else
-			{
-				groupName = engineName;
-			}
-			// Add the group or get its position if it's already in
-			appendGroup(groupName, rootType, groupIter);
-
-			// Has the result's ranking changed ?
-			float oldestScore = 0;
-			float previousScore = queryHistory.hasItem(m_treeName, engineName,
-				location, oldestScore);
-#ifdef DEBUG
-			cout << "ResultsTree::addResults: " << location << " has scores "
-				<< previousScore << ", " << oldestScore << endl;
-#endif
-			if (previousScore > 0)
-			{
-				// Yes, it has
-				rankDiff = (int)(currentScore - previousScore);
-			}
-			else
-			{
-				// New results are displayed as such only if the query has already been run on the engine
-				if (isNewQuery == false)
-				{
-					// This is a magic value :-)
-					rankDiff = 666;
-				}
-			}
-
-			if (updateHistory == true)
-			{
-				queryHistory.insertItem(m_treeName, engineName, location,
-					title, extract, currentScore);
-			}
-		}
-
-		++count;
-
-		// We already got indexId from PinotSettings
-		unsigned int docIndexId = 0;
-		unsigned int docId = resultIter->getIsIndexed(docIndexId);
-		bool isIndexed = false;
-
-		if (docId > 0)
-		{
-			isIndexed = true;
-		}
-
-		// Has it been already viewed ?
-		bool wasViewed = viewHistory.hasItem(location);
-
-		// OK, add a row for this result within the group
-		TreeModel::iterator titleIter;
-		if (appendResult(title, location, (int)currentScore, rankDiff, isIndexed, wasViewed,
-			docId, timestamp, resultIter->serialize(),
-			engineId, indexId, titleIter, groupIter, true) == true)
-		{
-#ifdef DEBUG
-			cout << "ResultsTree::addResults: added row for result " << count
-				<< ", " << currentScore << ", " << isIndexed << " " << docId
-				<< " " << indexId << endl;
-#endif
-
-			if (groupIter)
-			{
-				// Update this map, so that we know which groups need updating
-				updatedGroups[groupName] = groupIter;
-			}
-		}
-	}
-
-	// Remove older items ?
-	if ((isNewQuery == false) &&
-		(updateHistory == true))
-	{
-#ifdef DEBUG
-		cout << "ResultsTree::addResults: removing items for " << m_treeName
-			<< ", " << engineName << " older than " << secondLastRunTime << endl;
-#endif
-		queryHistory.deleteItems(m_treeName, engineName, secondLastRunTime);
-	}
-
-	if (count > 0)
-	{
-#ifdef DEBUG
-		cout << "ResultsTree::addResults: " << updatedGroups.size() << " groups to update" << endl;
-#endif
-		// Update the groups to which we have added results
-		for (std::map<string, TreeModel::iterator>::iterator mapIter = updatedGroups.begin();
-			mapIter != updatedGroups.end(); mapIter++)
-		{
-			TreeModel::iterator groupIter = mapIter->second;
-			updateGroup(groupIter);
-		}
-
-		return true;
-	}
-	else if (m_groupMode == BY_ENGINE)
-	{
-		// If this didn't return any result, add an empty group
-		TreeModel::iterator groupIter;
-		appendGroup(engineName, rootType, groupIter);
-		updateGroup(groupIter);
-
-		return true;
-	}
-
-	return false;
-}
-
-//
-// Sets how results are grouped.
-//
-void ResultsTree::setGroupMode(GroupByMode groupMode)
-{
-	ResultsModelColumns::RowType currentType, newType;
-
-	if (m_groupMode == FLAT)
-	{
-		// No change possible
-		return;
-	}
-
-	if (m_groupMode == groupMode)
-	{
-		// No change
-		return;
-	}
-#ifdef DEBUG
-	cout << "ResultsTree::setGroupMode: set to " << groupMode << endl;
-#endif
-	m_groupMode = groupMode;
-
-	// Do we need to update the tree ?
-	TreeModel::Children children = m_refStore->children();
-	if (children.empty() == true)
-	{
-		return;
-	}
-
-	// What's the new grouping criteria ?
-	if (m_groupMode == BY_ENGINE)
-	{
-		// By search engine
-		currentType = ResultsModelColumns::ROW_HOST;
-		newType = ResultsModelColumns::ROW_ENGINE;
-	}
-	else
-	{
-		// By host
-		currentType = ResultsModelColumns::ROW_ENGINE;
-		newType = ResultsModelColumns::ROW_HOST;
-	}
-
-	// Clear the map
-	m_resultsGroups.clear();
-
-	// Unselect results
-	get_selection()->unselect_all();
-
-	TreeModel::Children::iterator iter = children.begin();
-	while (iter != children.end())
-	{
-		TreeModel::Row row = *iter;
-#ifdef DEBUG
-		cout << "ResultsTree::setGroupMode: looking at " << row[m_resultsColumns.m_url] << endl;
-#endif
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		// Skip new type and other rows
-		if ((type == newType) ||
-			(type == ResultsModelColumns::ROW_OTHER))
-		{
-			iter++;
-			continue;
-		}
-
-		TreeModel::Children groupChildren = iter->children();
-		TreeModel::Children::iterator childIter = groupChildren.begin();
-		// Type ROW_RESULT
-		while (childIter != groupChildren.end())
-		{
-			TreeModel::Row childRow = *childIter;
-			TreeModel::iterator groupIter, newIter;
-			bool success = false;
-
-			type = childRow[m_resultsColumns.m_resultType];
-			if (type == ResultsModelColumns::ROW_OTHER)
-			{
-				TreeModel::Children::iterator nextChildIter = childIter;
-				++nextChildIter;
-
-				// Erase this row
-				m_refStore->erase(childIter);
-				childIter = nextChildIter;
-				continue;
-			}
-
-			// We will need the URL and engines columns in all cases
-			string url(from_utf8(childRow[m_resultsColumns.m_url]));
-			unsigned int engineIds = childRow[m_resultsColumns.m_engines];
-			unsigned int indexIds = childRow[m_resultsColumns.m_indexes];
-
-			// Get the name of the group this should go into
-			if (m_groupMode == BY_HOST)
-			{
-				Url urlObj(url);
-#ifdef DEBUG
-				cout << "ResultsTree::setGroupMode: row " << url << endl;
-#endif
-				// Add group
-				if (appendGroup(urlObj.getHost(), newType, groupIter) == true)
-				{
-					// Add result
-					success = appendResult(childRow[m_resultsColumns.m_text],
-						childRow[m_resultsColumns.m_url],
-						childRow[m_resultsColumns.m_score],
-						childRow[m_resultsColumns.m_rankDiff],
-						childRow[m_resultsColumns.m_indexed],
-						childRow[m_resultsColumns.m_viewed],
-						childRow[m_resultsColumns.m_docId],
-						childRow[m_resultsColumns.m_timestamp],
-						childRow[m_resultsColumns.m_serial],
-						engineIds, indexIds,
-						newIter, groupIter, true);
-				}
-			}
-			else
-			{
-				// Look at the engines column and see which engines this result is for
-				set<string> engineNames;
-				m_settings.getEngineNames(engineIds, engineNames);
-				if (engineNames.empty() == false)
-				{
-#ifdef DEBUG
-					cout << "ResultsTree::setGroupMode: row is for " << engineNames.size() << " engine(s)" << endl;
-#endif
-					// Are there indexes in the list ?
-					set<string>::iterator backendIter = engineNames.find(m_settings.m_defaultBackend);
-					if ((backendIter != engineNames.end()) &&
-						(indexIds > 0))
-					{
-						// Erase this
-						engineNames.erase(backendIter);
-#ifdef DEBUG
-						cout << "ResultsTree::setGroupMode: row is for index(es) " << indexIds << endl;
-#endif
-
-						// Add entries for each index name so that we can loop once on engine names
-						set<string> indexNames;
-						m_settings.getIndexNames(indexIds, indexNames);
-						for (set<string>::iterator indexIter = indexNames.begin();
-							indexIter != indexNames.end(); ++indexIter)
-						{
-							string indexName(*indexIter);
-							engineNames.insert(indexName);
-#ifdef DEBUG
-							cout << "ResultsTree::setGroupMode: row is for index " << indexName << endl;
-#endif
-						}
-					}
-
-					for (set<string>::iterator engineIter = engineNames.begin();
-						engineIter != engineNames.end(); ++engineIter)
-					{
-						string engineName(*engineIter);
-						unsigned int indexId = 0;
-						unsigned int engineId = m_settings.getEngineId(engineName);
-
-						if (engineId == 0)
-						{
-							// This is actually an index, not an engine...
-							PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(engineName);
-							if (indexProps.m_location.empty() == false)
-							{
-								engineId = m_settings.getEngineId(m_settings.m_defaultBackend);
-							}
-#ifdef DEBUG
-							cout << "ResultsTree::setGroupMode: index " << indexId << endl;
-#endif
-						}
-#ifdef DEBUG
-						else cout << "ResultsTree::setGroupMode: no index" << endl;
-#endif
-
-						// Add group
-						if (appendGroup(engineName, newType, groupIter) == true)
-						{
-							// Add result
-							appendResult(childRow[m_resultsColumns.m_text],
-								childRow[m_resultsColumns.m_url],
-								childRow[m_resultsColumns.m_score],
-								childRow[m_resultsColumns.m_rankDiff],
-								childRow[m_resultsColumns.m_indexed],
-								childRow[m_resultsColumns.m_viewed],
-								childRow[m_resultsColumns.m_docId],
-								childRow[m_resultsColumns.m_timestamp],
-								childRow[m_resultsColumns.m_serial],
-								engineId, indexId,
-								newIter, groupIter, true);
-#ifdef DEBUG
-							cout << "ResultsTree::setGroupMode: row for " << engineName << endl;
-#endif
-						}
-					}
-
-					// FIXME: make sure at least one row was added
-					success = true;
-				}
-			}
-
-			if (success == true)
-			{
-				// Delete it
-				m_refStore->erase(*childIter);
-				childIter = groupChildren.begin();
-			}
-			else
-			{
-				// Don't delete anything then, just go to the next child
-				childIter++;
-			}
-		}
-
-		// Erase this row
-		m_refStore->erase(*iter);
-
-		// Get the new first row, that way we don't have to worry about iterators validity
-		iter = children.begin();
-	}
-
-	for (std::map<string, TreeModel::iterator>::iterator mapIter = m_resultsGroups.begin();
-		mapIter != m_resultsGroups.end(); mapIter++)
-	{
-		TreeModel::iterator groupIter = mapIter->second;
-		updateGroup(groupIter);
-	}
-
-	onSelectionChanged();
-}
-
-//
-// Gets the first selected item's URL.
-//
-ustring ResultsTree::getFirstSelectionURL(void)
-{
-	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
-	if (selectedItems.empty() == true)
-	{
-		return "";
-	}
-
-	list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
-	TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
-	TreeModel::Row row = *iter;
-
-	return row[m_resultsColumns.m_url];
-}
-
-//
-// Gets a list of selected items.
-//
-bool ResultsTree::getSelection(vector<DocumentInfo> &resultsList, bool skipIndexed)
-{
-	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
-	if (selectedItems.empty() == true)
-	{
-		return false;
-	}
-
-	// Go through selected items
-	for (list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
-		itemPath != selectedItems.end(); ++itemPath)
-	{
-		TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
-		TreeModel::Row row = *iter;
-
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		if (type != ResultsModelColumns::ROW_RESULT)
-		{
-			continue;
-		}
-
-		bool isIndexed = row[m_resultsColumns.m_indexed];
-		if ((skipIndexed == false) ||
-			(isIndexed == false))
-		{
-			DocumentInfo current;
-			string serial(row[m_resultsColumns.m_serial]);
-
-			current.deserialize(serial);
-
-			if (isIndexed == true)
-			{
-				set<string> indexNames;
-				unsigned int indexIds = row[m_resultsColumns.m_indexes];
-
-				m_settings.getIndexNames(indexIds, indexNames);
-				// Any internal index in there ?
-				for (set<string>::iterator indexIter = indexNames.begin(); indexIter != indexNames.end(); ++indexIter)
-				{
-					PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(*indexIter);
-					if (indexProps.m_internal == true)
-					{
-#ifdef DEBUG
-						cout << "ResultsTree::getSelection: result in internal index " << *indexIter << endl;
-#endif
-						current.setIsIndexed(indexProps.m_id, row[m_resultsColumns.m_docId]);
-						break;
-					}
-				}
-			}
-
-			resultsList.push_back(current);
-		}
-	}
-#ifdef DEBUG
-	cout << "ResultsTree::getSelection: " << resultsList.size() << " results selected" << endl;
-#endif
-
-	return true;
-}
-
-//
-// Sets the selected items' state.
-//
-void ResultsTree::setSelectionState(bool viewed)
-{
-	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
-	if (selectedItems.empty() == true)
-	{
-		return;
-	}
-
-	// Go through selected items
-	for (list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
-		itemPath != selectedItems.end(); ++itemPath)
-	{
-		TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
-		TreeModel::Row row = *iter;
-  
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		if (type != ResultsModelColumns::ROW_RESULT)
-		{
-			continue;
-		}
-
-		if (viewed == true)
-		{
-			row[m_resultsColumns.m_viewed] = true;
-		}
-	}
-}
-
-//
-// Updates a result's properties.
-//
-bool ResultsTree::updateResult(const DocumentInfo &result)
-{
-	unsigned int indexId = 0;
-	unsigned int docId = result.getIsIndexed(indexId);
-
-	if (docId == 0)
-	{
-		return false;
-	}
-
-	// Go through the list
-	TreeModel::Children children = m_refStore->children();
-	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
-	{
-		TreeModel::Row row = *iter;
-
-		if (docId == row[m_resultsColumns.m_docId])
-		{
-			// FIXME: title, location should be converted based on the result's charset !
-			updateRow(row, result.getTitle(), result.getLocation(),
-				row[m_resultsColumns.m_score], row[m_resultsColumns.m_engines],
-				row[m_resultsColumns.m_indexes], docId,
-				to_utf8(result.getTimestamp()), result.serialize(),
-				ResultsModelColumns::ROW_RESULT,
-				row[m_resultsColumns.m_indexed], row[m_resultsColumns.m_viewed],
-				row[m_resultsColumns.m_rankDiff]);
-
-			return true;
-		}
-	}
-
-	return false;
-}
-
-//
-// Deletes the current selection.
-//
-bool ResultsTree::deleteSelection(void)
-{
-	bool empty = false;
-
-	// Go through selected items
-	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
-	list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
-	while (itemPath != selectedItems.end())
-	{
-		TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
-		TreeModel::Row row = *iter;
-		TreeModel::iterator parentIter;
-		bool updateParent = false;
-
-		// This could be a group that's in the map and should be removed first
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		if (type != ResultsModelColumns::ROW_RESULT)
-		{
-			string groupName(from_utf8(row[m_resultsColumns.m_text]));
-			std::map<string, TreeModel::iterator>::iterator mapIter = m_resultsGroups.find(groupName);
-			if (mapIter != m_resultsGroups.end())
-			{
-				m_resultsGroups.erase(mapIter);
-#ifdef DEBUG
-				cout << "ResultsTree::deleteSelection: erased group " << groupName << endl;
-#endif
-			}
-		}
-		else if (m_groupMode != FLAT)
-		{
-			// This item is a result
-			parentIter = row.parent();
-			updateParent = true;
-		}
-
-		// Unselect and erase
-		get_selection()->unselect(iter);
-		m_refStore->erase(row);
-
-		// Update group ?
-		if (updateParent == true)
-		{
-			// Update the group this result belongs to
-			updateGroup(parentIter);
-		}
-
-		selectedItems = get_selection()->get_selected_rows();
-		itemPath = selectedItems.begin();
-	}
-
-	TreeModel::Children children = m_refStore->children();
-	empty = children.empty();
-
-	refresh();
-
-	return empty;
-}
-
-//
-// Deletes results.
-//
-bool ResultsTree::deleteResults(const string &engineName)
-{
-	unsigned int indexId = 0;
-	unsigned int engineId = m_settings.getEngineId(engineName);
-	unsigned int count = 0;
-
-	if (engineId == 0)
-	{
-		// Chances are this engine is an index
-		PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(engineName);
-		if (indexProps.m_location.empty() == false)
-		{
-			// Yes, it is
-			indexId = indexProps.m_id;
-			engineId = m_settings.getEngineId(m_settings.m_defaultBackend);
-		}
-	}
-
-	TreeModel::Children groups = m_refStore->children();
-	for (TreeModel::Children::iterator parentIter = groups.begin();
-		parentIter != groups.end(); ++parentIter)
-	{
-		TreeModel::Row row = *parentIter;
-
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		if ((type != ResultsModelColumns::ROW_ENGINE) &&
-			(type != ResultsModelColumns::ROW_HOST))
-		{
-			continue;
-		}
-
-		TreeModel::Children children = parentIter->children();
-		TreeModel::Children::iterator iter = children.begin();
-		while (iter != children.end())
-		{
-			row = *iter;
-
-			type = row[m_resultsColumns.m_resultType];
-			if (((type == ResultsModelColumns::ROW_RESULT) &&
-				(row[m_resultsColumns.m_engines] == engineId) &&
-				(row[m_resultsColumns.m_indexes] == indexId)) ||
-				(type == ResultsModelColumns::ROW_OTHER))
-			{
-				TreeModel::Children::iterator nextIter = iter;
-				++nextIter;
-				++count;
-
-				// Erase this row
-				m_refStore->erase(*iter);
-				iter = nextIter;
-				continue;
-			}
-
-			// Next
-			++iter;
-		}
-	}
-
-	if (count > 0)
-	{
-		onSelectionChanged();
-#ifdef DEBUG
-		cout << "ResultsTree::deleteResults: erased " << count << " rows" << endl;
-#endif
-		return true;
-	}
-
-	return false;
-}
-
-//
-// Returns the number of rows.
-//
-unsigned int ResultsTree::getRowsCount(void)
-{
-	return m_refStore->children().size();
-}
-
-//
-// Refreshes the tree.
-//
-void ResultsTree::refresh(void)
-{
-	// FIXME: not sure why, but this helps with refreshing the tree
-	columns_autosize();
-}
-
-//
-// Clears the tree.
-//
-void ResultsTree::clear(void)
-{
-	// Unselect results
-	get_selection()->unselect_all();
-
-	// Remove existing rows in the tree
-	TreeModel::Children children = m_refStore->children();
-	if (children.empty() == false)
-	{
-		// Clear the groups map
-		m_resultsGroups.clear();
-
-		TreeModel::Children::iterator iter = children.begin();
-		while (iter != children.end())
-		{
-			// Erase this row
-			m_refStore->erase(*iter);
-
-			// Get the new first row
-			children = m_refStore->children();
-			iter = children.begin();
-		}
-		m_refStore->clear();
-
-		// Clear the extract
-		RefPtr<TextBuffer> refBuffer = m_extractTextView->get_buffer();
-		if (refBuffer)
-		{
-			refBuffer->set_text("");
-		}
-
-		onSelectionChanged();
-	}
-}
-
-//
-// Shows or hides the extract field.
-//
-void ResultsTree::showExtract(bool showExtract)
-{
-	m_showExtract = showExtract;
-	if (m_showExtract == true)
-	{
-		// Show the extract
-		m_pExtractScrolledwindow->show();
-	}
-	else
-	{
-		// Hide
-		m_pExtractScrolledwindow->hide();
-	}
-}
-
-//
-// Exports results to a file.
-//
-void ResultsTree::exportResults(const string &fileName,
-	const string &queryName, bool csvFormat)
-{
-	QueryProperties queryProps(queryName, "");
-	ResultsExporter *pExporter = NULL;
-	unsigned int maxResultsCount = 0;
-
-	if (fileName.empty() == true)
-	{
-		return;
-	}
-
-	if (csvFormat == true)
-	{
-		pExporter = new CSVExporter(fileName,
-			queryProps);
-	}
-	else
-	{
-		pExporter = new OpenSearchExporter(fileName,
-			queryProps);
-	}
-
-	// How many results are there altogether ?
-	TreeModel::Children children = m_refStore->children();
-	if (m_groupMode == FLAT)
-	{
-		maxResultsCount = children.size();
-	}
-	else for (TreeModel::Children::iterator iter = children.begin();
-		iter != children.end(); ++iter)
-	{
-		TreeModel::Row row = *iter;
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-
-		if ((type != ResultsModelColumns::ROW_ENGINE) &&
-			(type != ResultsModelColumns::ROW_HOST))
-		{
-			continue;
-		}
-
-		TreeModel::Children groupChildren = iter->children();
-		maxResultsCount += groupChildren.size();
-	}
-#ifdef DEBUG
-	cout << "ResultsTree::exportResults: " << maxResultsCount << " results to export" << endl;
-#endif
-
-	// Start
-	pExporter->exportStart("", maxResultsCount);
-
-	if (m_groupMode == FLAT)
-	{
-		exportResults(children, queryName, pExporter);
-	}
-	else for (TreeModel::Children::iterator iter = children.begin();
-		iter != children.end(); ++iter)
-	{
-		TreeModel::Row row = *iter;
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-
-		if ((type != ResultsModelColumns::ROW_ENGINE) &&
-			(type != ResultsModelColumns::ROW_HOST))
-		{
-			continue;
-		}
-
-		TreeModel::Children groupChildren = iter->children();
-		exportResults(groupChildren, queryName, pExporter);
-	}
-
-	// End
-	pExporter->exportEnd();
-
-	delete pExporter;
-}
-
-//
-// Exports results to a file.
-//
-void ResultsTree::exportResults(TreeModel::Children &groupChildren,
-	const string &queryName, ResultsExporter *pExporter)
-{
-	QueryHistory queryHistory(m_settings.getHistoryDatabaseName());
-
-	for (TreeModel::Children::iterator childIter = groupChildren.begin();
-		childIter != groupChildren.end(); ++childIter)
-	{
-		TreeModel::Row childRow = *childIter;
-		ResultsModelColumns::RowType type = childRow[m_resultsColumns.m_resultType];
-
-		if (type == ResultsModelColumns::ROW_OTHER)
-		{
-			continue;
-		}
-
-		set<string> engineNames, indexNames;
-		DocumentInfo result;
-		string engineName, serial(childRow[m_resultsColumns.m_serial]);
-		unsigned int engineIds = childRow[m_resultsColumns.m_engines];
-		unsigned int indexIds = childRow[m_resultsColumns.m_indexes];
-
-#ifdef DEBUG
-		cout << "ResultsTree::exportResults: engines " << engineIds << ", indexes " << indexIds << endl;
-#endif
-		result.deserialize(serial);
-		m_settings.getEngineNames(engineIds, engineNames);
-		if (engineNames.empty() == false)
-		{
-			// Get the first engine this result was obtained from
-			engineName = *engineNames.begin();
-			if (engineName == m_settings.m_defaultBackend)
-			{
-				m_settings.getIndexNames(indexIds, indexNames);
-				if (indexNames.empty() == false)
-				{
-					// Use the name of the first index as engine name
-					engineName = (*indexNames.begin());
-				}
-			}
-		}
-		if (m_groupMode != FLAT)
-		{
-			result.setExtract(queryHistory.getItemExtract(from_utf8(queryName),
-				engineName, result.getLocation()));
-		}
-		else
-		{
-			engineName = m_treeName;
-		}
-		result.setTimestamp(from_utf8(childRow[m_resultsColumns.m_timestamp]));
-
-		// Export this
-		if (pExporter != NULL)
-		{
-			pExporter->exportResult(engineName, result);
-		}
-	}
-}
-
-//
-// Returns the changed selection signal.
-//
-sigc::signal1<void, ustring>& ResultsTree::getSelectionChangedSignal(void)
-{
-	return m_signalSelectionChanged;
-}
-
-//
-// Returns the double-click signal.
-//
-sigc::signal0<void>& ResultsTree::getDoubleClickSignal(void)
-{
-	return m_signalDoubleClick;
-}
-
-//
-// Adds a new row in the results tree.
-//
-bool ResultsTree::appendResult(const ustring &text, const ustring &url,
-	int score, int rankDiff, bool isIndexed, bool wasViewed,
-	unsigned int docId, const ustring &timestamp,
-	const string &serial, unsigned int engineId,
-	unsigned int indexId, TreeModel::iterator &newRowIter,
-	const TreeModel::iterator &parentIter, bool noDuplicates)
-{
-	if (!parentIter)
-	{
-#ifdef DEBUG
-		cout << "ResultsTree::appendResult: no parent" << endl;
-#endif
-		newRowIter = m_refStore->append();
-	}
-	else
-	{
-		const TreeModel::Row parentRow = *parentIter;
-
-		// Merge duplicates within groups ?
-		if (noDuplicates == true)
-		{
-			// Look for a row with the same URL and query. For instance, in group
-			// by host mode, if a page is returned by several search engines, it
-			// should appear only once
-			TreeModel::Children children = parentRow.children();
-			if (children.empty() == false)
-			{
-				for (TreeModel::Children::iterator childIter = children.begin();
-					childIter != children.end(); ++childIter)
-				{
-					TreeModel::Row row = *childIter;
-					if (row[m_resultsColumns.m_url] == url)
-					{
-						// Update the engines column...
-						row[m_resultsColumns.m_engines] = row[m_resultsColumns.m_engines] | engineId;
-						// ...and the indexes column too
-						row[m_resultsColumns.m_indexes] = row[m_resultsColumns.m_indexes] | engineId;
-
-						newRowIter = childIter;
-						return true;
-					}
-				}
-			}
-		}
-
-		newRowIter = m_refStore->append(parentRow.children());
-	}
-
-	TreeModel::Row childRow = *newRowIter;
-	updateRow(childRow, text, url, score, engineId, indexId,
-		docId, timestamp, serial, ResultsModelColumns::ROW_RESULT, isIndexed,
-		wasViewed, rankDiff);
-
-	return true;
-}
-
-//
-// Adds a results group
-//
-bool ResultsTree::appendGroup(const string &groupName, ResultsModelColumns::RowType groupType,
-	TreeModel::iterator &groupIter)
-{
-	bool success = false;
-
-	// Is this group already in ?
-	std::map<string, TreeModel::iterator>::iterator mapIter = m_resultsGroups.find(groupName);
-	if (mapIter == m_resultsGroups.end())
-	{
-		// No, it isn't: insert a new group in the tree
-		groupIter = m_refStore->append();
-		TreeModel::Row groupRow = *groupIter;
-		updateRow(groupRow, groupName,
-			"", 0, 0, 0, 0, "", "", groupType,
-			false, false, 0);
-
-		// Update the map
-		m_resultsGroups[groupName] = groupIter;
-		success = true;
-#ifdef DEBUG
-		cout << "ResultsTree::appendGroup: updated map with " << groupName << endl;
-#endif
-	}
-	else
-	{
-		// Yes, it is
-		groupIter = mapIter->second;
-#ifdef DEBUG
-		cout << "ResultsTree::appendGroup: found " << groupName << " in map" << endl;
-#endif
-		success = true;
-	}
-
-	return success;
-}
-
-//
-// Updates a results group.
-//
-void ResultsTree::updateGroup(TreeModel::iterator &groupIter)
-{
-	TreeModel::Row groupRow = (*groupIter);
-	int averageScore = 0;
-
-	// Check the iterator doesn't point to a result
-	ResultsModelColumns::RowType type = groupRow[m_resultsColumns.m_resultType];
-	if (type == ResultsModelColumns::ROW_RESULT)
-	{
-		return;
-	}
-
-	// Modify the "score" column to indicate the number of results in that group
-	TreeModel::Children groupChildren = groupIter->children();
-	if (groupChildren.empty() == false)
-	{
-		for (TreeModel::Children::iterator childIter = groupChildren.begin();
-			childIter != groupChildren.end(); ++childIter)
-		{
-			TreeModel::Row row = *childIter;
-
-			averageScore += row[m_resultsColumns.m_score];
-		}
-
-		averageScore = (int)(averageScore / groupChildren.size());
-	}
-	else
-	{
-		TreeModel::Row groupRow = *groupIter;
-		TreeModel::iterator childIter = m_refStore->append(groupRow.children());
-		TreeModel::Row childRow = *childIter;
-
-		updateRow(childRow, _("No results"), "", 0, 0, 0, 0,
-			"", "", ResultsModelColumns::ROW_OTHER, false, false, 0);
-	}
-	groupRow[m_resultsColumns.m_score] = averageScore;
-
-	// Expand this group
-	TreeModel::Path groupPath = m_refStore->get_path(groupIter);
-	expand_row(groupPath, true);
-}
-
-//
-// Updates a row.
-//
-void ResultsTree::updateRow(TreeModel::Row &row, const ustring &text,
-	const ustring &url, int score, 	unsigned int engineId, unsigned int indexId,
-	unsigned int docId, const ustring &timestamp, const string &serial,
-	ResultsModelColumns::RowType resultType, bool indexed, bool viewed, int rankDiff)
-{
-	try
-	{
-		row[m_resultsColumns.m_text] = text;
-		row[m_resultsColumns.m_url] = url;
-		row[m_resultsColumns.m_score] = score;
-		row[m_resultsColumns.m_scoreText] = "";
-		row[m_resultsColumns.m_engines] = engineId;
-		row[m_resultsColumns.m_indexes] = indexId;
-		row[m_resultsColumns.m_docId] = docId;
-		row[m_resultsColumns.m_resultType] = resultType;
-		row[m_resultsColumns.m_timestamp] = timestamp;
-		row[m_resultsColumns.m_timestampTime] = TimeConverter::fromTimestamp(from_utf8(timestamp));
-		row[m_resultsColumns.m_serial] = serial;
-
-		row[m_resultsColumns.m_indexed] = indexed;
-		row[m_resultsColumns.m_viewed] = viewed;
-		row[m_resultsColumns.m_rankDiff] = rankDiff;
-	}
-	catch (Error &error)
-	{
-#ifdef DEBUG
-		cout << "ResultsTree::updateRow: " << error.what() << endl;
-#endif
-	}
-	catch (...)
-	{
-#ifdef DEBUG
-		cout << "ResultsTree::updateRow: caught unknown exception" << endl;
-#endif
-	}
-}
-
-//
-// Retrieves the extract to show for the given row.
-//
-ustring ResultsTree::findResultsExtract(const Gtk::TreeModel::Row &row)
-{
-	QueryHistory queryHistory(m_settings.getHistoryDatabaseName());
-	set<string> engineNames, indexNames;
-	string url(from_utf8(row[m_resultsColumns.m_url]));
-	string extract;
-	unsigned int engineIds = row[m_resultsColumns.m_engines];
-	unsigned int indexIds = row[m_resultsColumns.m_indexes];
-
-#ifdef DEBUG
-	cout << "ResultsTree::findResultsExtract: " << url << " has engines " << engineIds << ", indexes " << indexIds << endl;
-#endif
-	m_settings.getEngineNames(engineIds, engineNames);
-	for (set<string>::const_iterator engineIter = engineNames.begin();
-		engineIter != engineNames.end(); ++engineIter)
-	{
-		string engineName(*engineIter);
-
-		indexNames.clear();
-		if (engineName == m_settings.m_defaultBackend)
-		{
-			m_settings.getIndexNames(indexIds, indexNames);
-		}
-		else
-		{
-			// That's not an index but pretend it is
-			indexNames.insert(engineName);
-		}
-
-		for (set<string>::const_iterator indexIter = indexNames.begin();
-			indexIter != indexNames.end(); ++indexIter)
-		{
-			// Use the name of this index as engine name
-			engineName = (*indexNames.begin());
-
-#ifdef DEBUG
-			cout << "ResultsTree::findResultsExtract: engine or index " << engineName << endl;
-#endif
-			extract = queryHistory.getItemExtract(from_utf8(m_treeName), engineName, url);
-			if (extract.empty() == false)
-			{
-				// Stop here
-				return extract;
-			}
-		}
-	}
-
-	return "";
-}

Deleted: trunk/UI/GTK2/src/ResultsTree.h
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.h	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/ResultsTree.h	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,189 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _RESULTSTREE_HH
-#define _RESULTSTREE_HH
-
-#include <string>
-#include <vector>
-#include <set>
-#include <map>
-#include <sigc++/sigc++.h>
-#include <glibmm/refptr.h>
-#include <glibmm/ustring.h>
-#include <gdkmm/pixbuf.h>
-#include <gtkmm/button.h>
-#include <gtkmm/menu.h>
-#include <gtkmm/scrolledwindow.h>
-#include <gtkmm/treestore.h>
-#include <gtkmm/textview.h>
-#include <gtkmm/treeview.h>
-#include <gtkmm/treeselection.h>
-
-#include "ResultsExporter.h"
-#include "ModelColumns.h"
-#include "PinotSettings.h"
-
-class ResultsTree : public Gtk::TreeView
-{
-	public:
-		typedef enum { BY_ENGINE = 0, BY_HOST, FLAT } GroupByMode;
-
-		ResultsTree(const Glib::ustring &name, Gtk::Menu *pPopupMenu,
-			GroupByMode groupMode, PinotSettings &settings);
-		virtual ~ResultsTree();
-
-		/// Returns the results scrolled window.
-		Gtk::ScrolledWindow *getResultsScrolledWindow(void) const;
-
-		/// Returns the extract scrolled window.
-		Gtk::ScrolledWindow *getExtractScrolledWindow(void) const;
-
-		/// Returns whether the extract text view has the focus.
-		bool focusOnExtract(void) const;
-
-		/// Returns the extract.
-		Glib::ustring getExtract(void) const;
-
-		/**
-		  * Adds a set of results.
-		  * Returns true if something was added to the tree.
-		  */
-		bool addResults(const std::string &engineName, const std::vector<DocumentInfo> &resultsList,
-			const std::string &charset, bool updateHistory);
-
-		/// Sets how results are grouped.
-		void setGroupMode(GroupByMode groupMode);
-
-		/// Gets the first selected item's URL.
-		Glib::ustring getFirstSelectionURL(void);
-
-		/// Gets a list of selected items.
-		bool getSelection(std::vector<DocumentInfo> &resultsList, bool skipIndexed = false);
-
-		/// Sets the selected items' state.
-		void setSelectionState(bool viewed);
-
-		/// Updates a result's properties.
-		bool updateResult(const DocumentInfo &result);
-
-		/**
-		  * Deletes the current selection.
-		  * Returns true if the tree is then empty.
-		  */
-		bool deleteSelection(void);
-
-		/// Deletes results.
-		bool deleteResults(const std::string &engineName);
-
-		/// Returns the number of rows.
-		unsigned int getRowsCount(void);
-
-		/// Refreshes the tree.
-		void refresh(void);
-
-		/// Clears the tree.
-		void clear(void);
-
-		/// Shows or hides the extract field.
-		void showExtract(bool showExtract = true);
-
-		/// Exports results to a file.
-		void exportResults(const std::string &fileName,
-			const string &queryName, bool csvFormat);
-
-		/// Returns the changed selection signal.
-		sigc::signal1<void, Glib::ustring>& getSelectionChangedSignal(void);
-
-		/// Returns the double-click signal.
-		sigc::signal0<void>& getDoubleClickSignal(void);
-
-	protected:
-		Glib::ustring m_treeName;
-		Gtk::Menu *m_pPopupMenu;
-		Gtk::ScrolledWindow *m_pResultsScrolledwindow;
-		Glib::RefPtr<Gtk::TreeStore> m_refStore;
-		sigc::signal1<void, Glib::ustring> m_signalSelectionChanged;
-		sigc::signal0<void> m_signalDoubleClick;
-		PinotSettings &m_settings;
-		Glib::RefPtr<Gdk::Pixbuf> m_indexedIconPixbuf;
-		Glib::RefPtr<Gdk::Pixbuf> m_viewededIconPixbuf;
-		Glib::RefPtr<Gdk::Pixbuf> m_upIconPixbuf;
-		Glib::RefPtr<Gdk::Pixbuf> m_downIconPixbuf;
-		std::map<std::string, Gtk::TreeModel::iterator> m_resultsGroups;
-		ResultsModelColumns m_resultsColumns;
-		Gtk::ScrolledWindow *m_pExtractScrolledwindow;
-		Gtk::TextView *m_extractTextView;
-		ComboModelColumns m_extractColumns;
-		bool m_showExtract;
-		GroupByMode m_groupMode;
-
-		void renderViewStatus(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &iter);
-
-		void renderIndexStatus(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &iter);
-
-		void renderRanking(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &iter);
-
-		void renderTitleColumn(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &iter);
-
-		void onButtonPressEvent(GdkEventButton *ev);
-
-		void onSelectionChanged(void);
-
-		bool onSelectionSelect(const Glib::RefPtr<Gtk::TreeModel>& model,
-			const Gtk::TreeModel::Path& node_path, bool path_currently_selected);
-
-		/// Handles GTK style changes.
-		void onStyleChanged(const Glib::RefPtr<Gtk::Style> &previous_style);
-
-		/// Adds a results group.
-		bool appendGroup(const std::string &groupName, ResultsModelColumns::RowType groupType,
-			Gtk::TreeModel::iterator &groupIter);
-
-		/// Adds a new row in the results tree.
-		bool appendResult(const Glib::ustring &text, const Glib::ustring &url,
-			int score, int rankDiff, bool isIndexed, bool wasViewed,
-			unsigned int docId, const Glib::ustring &timestamp, const std::string &serial,
-			unsigned int engineId, unsigned int indexId,
-			Gtk::TreeModel::iterator &newRowIter,
-			const Gtk::TreeModel::iterator &parentIter,
-			bool noDuplicates = false);
-
-		/// Updates a results group.
-		void updateGroup(Gtk::TreeModel::iterator &groupIter);
-
-		/// Updates a row.
-		void updateRow(Gtk::TreeModel::Row &row, const Glib::ustring &text,
-			const Glib::ustring &url, int score, unsigned int engineId, unsigned int indexId,
-			unsigned int docId, const Glib::ustring &timestamp, const std::string &serial,
-			ResultsModelColumns::RowType resultType, bool indexed, bool viewed, int rankDiff);
-
-		/// Retrieves the extract to show for the given row.
-		Glib::ustring findResultsExtract(const Gtk::TreeModel::Row &row);
-
-		/// Exports results to a file.
-		void exportResults(Gtk::TreeModel::Children &groupChildren,
-			const string &queryName, ResultsExporter *pExporter);
-
-	private:
-		ResultsTree(const ResultsTree &other);
-		ResultsTree &operator=(const ResultsTree &other);
-
-};
-
-#endif // _RESULTSTREE_HH

Copied: trunk/UI/GTK2/src/ResultsTree.hh (from rev 1529, trunk/UI/GTK2/src/ResultsTree.h)
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/ResultsTree.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,189 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _RESULTSTREE_HH
+#define _RESULTSTREE_HH
+
+#include <string>
+#include <vector>
+#include <set>
+#include <map>
+#include <sigc++/sigc++.h>
+#include <glibmm/refptr.h>
+#include <glibmm/ustring.h>
+#include <gdkmm/pixbuf.h>
+#include <gtkmm/button.h>
+#include <gtkmm/menu.h>
+#include <gtkmm/scrolledwindow.h>
+#include <gtkmm/treestore.h>
+#include <gtkmm/textview.h>
+#include <gtkmm/treeview.h>
+#include <gtkmm/treeselection.h>
+
+#include "ResultsExporter.h"
+#include "PinotSettings.h"
+#include "ModelColumns.hh"
+
+class ResultsTree : public Gtk::TreeView
+{
+	public:
+		typedef enum { BY_ENGINE = 0, BY_HOST, FLAT } GroupByMode;
+
+		ResultsTree(const Glib::ustring &name, Gtk::Menu *pPopupMenu,
+			GroupByMode groupMode, PinotSettings &settings);
+		virtual ~ResultsTree();
+
+		/// Returns the results scrolled window.
+		Gtk::ScrolledWindow *getResultsScrolledWindow(void) const;
+
+		/// Returns the extract scrolled window.
+		Gtk::ScrolledWindow *getExtractScrolledWindow(void) const;
+
+		/// Returns whether the extract text view has the focus.
+		bool focusOnExtract(void) const;
+
+		/// Returns the extract.
+		Glib::ustring getExtract(void) const;
+
+		/**
+		  * Adds a set of results.
+		  * Returns true if something was added to the tree.
+		  */
+		bool addResults(const std::string &engineName, const std::vector<DocumentInfo> &resultsList,
+			const std::string &charset, bool updateHistory);
+
+		/// Sets how results are grouped.
+		void setGroupMode(GroupByMode groupMode);
+
+		/// Gets the first selected item's URL.
+		Glib::ustring getFirstSelectionURL(void);
+
+		/// Gets a list of selected items.
+		bool getSelection(std::vector<DocumentInfo> &resultsList, bool skipIndexed = false);
+
+		/// Sets the selected items' state.
+		void setSelectionState(bool viewed);
+
+		/// Updates a result's properties.
+		bool updateResult(const DocumentInfo &result);
+
+		/**
+		  * Deletes the current selection.
+		  * Returns true if the tree is then empty.
+		  */
+		bool deleteSelection(void);
+
+		/// Deletes results.
+		bool deleteResults(const std::string &engineName);
+
+		/// Returns the number of rows.
+		unsigned int getRowsCount(void);
+
+		/// Refreshes the tree.
+		void refresh(void);
+
+		/// Clears the tree.
+		void clear(void);
+
+		/// Shows or hides the extract field.
+		void showExtract(bool showExtract = true);
+
+		/// Exports results to a file.
+		void exportResults(const std::string &fileName,
+			const string &queryName, bool csvFormat);
+
+		/// Returns the changed selection signal.
+		sigc::signal1<void, Glib::ustring>& getSelectionChangedSignal(void);
+
+		/// Returns the double-click signal.
+		sigc::signal0<void>& getDoubleClickSignal(void);
+
+	protected:
+		Glib::ustring m_treeName;
+		Gtk::Menu *m_pPopupMenu;
+		Gtk::ScrolledWindow *m_pResultsScrolledwindow;
+		Glib::RefPtr<Gtk::TreeStore> m_refStore;
+		sigc::signal1<void, Glib::ustring> m_signalSelectionChanged;
+		sigc::signal0<void> m_signalDoubleClick;
+		PinotSettings &m_settings;
+		Glib::RefPtr<Gdk::Pixbuf> m_indexedIconPixbuf;
+		Glib::RefPtr<Gdk::Pixbuf> m_viewededIconPixbuf;
+		Glib::RefPtr<Gdk::Pixbuf> m_upIconPixbuf;
+		Glib::RefPtr<Gdk::Pixbuf> m_downIconPixbuf;
+		std::map<std::string, Gtk::TreeModel::iterator> m_resultsGroups;
+		ResultsModelColumns m_resultsColumns;
+		Gtk::ScrolledWindow *m_pExtractScrolledwindow;
+		Gtk::TextView *m_extractTextView;
+		ComboModelColumns m_extractColumns;
+		bool m_showExtract;
+		GroupByMode m_groupMode;
+
+		void renderViewStatus(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &iter);
+
+		void renderIndexStatus(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &iter);
+
+		void renderRanking(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &iter);
+
+		void renderTitleColumn(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &iter);
+
+		void onButtonPressEvent(GdkEventButton *ev);
+
+		void onSelectionChanged(void);
+
+		bool onSelectionSelect(const Glib::RefPtr<Gtk::TreeModel>& model,
+			const Gtk::TreeModel::Path& node_path, bool path_currently_selected);
+
+		/// Handles GTK style changes.
+		void onStyleChanged(const Glib::RefPtr<Gtk::Style> &previous_style);
+
+		/// Adds a results group.
+		bool appendGroup(const std::string &groupName, ResultsModelColumns::RowType groupType,
+			Gtk::TreeModel::iterator &groupIter);
+
+		/// Adds a new row in the results tree.
+		bool appendResult(const Glib::ustring &text, const Glib::ustring &url,
+			int score, int rankDiff, bool isIndexed, bool wasViewed,
+			unsigned int docId, const Glib::ustring &timestamp, const std::string &serial,
+			unsigned int engineId, unsigned int indexId,
+			Gtk::TreeModel::iterator &newRowIter,
+			const Gtk::TreeModel::iterator &parentIter,
+			bool noDuplicates = false);
+
+		/// Updates a results group.
+		void updateGroup(Gtk::TreeModel::iterator &groupIter);
+
+		/// Updates a row.
+		void updateRow(Gtk::TreeModel::Row &row, const Glib::ustring &text,
+			const Glib::ustring &url, int score, unsigned int engineId, unsigned int indexId,
+			unsigned int docId, const Glib::ustring &timestamp, const std::string &serial,
+			ResultsModelColumns::RowType resultType, bool indexed, bool viewed, int rankDiff);
+
+		/// Retrieves the extract to show for the given row.
+		Glib::ustring findResultsExtract(const Gtk::TreeModel::Row &row);
+
+		/// Exports results to a file.
+		void exportResults(Gtk::TreeModel::Children &groupChildren,
+			const string &queryName, ResultsExporter *pExporter);
+
+	private:
+		ResultsTree(const ResultsTree &other);
+		ResultsTree &operator=(const ResultsTree &other);
+
+};
+
+#endif // _RESULTSTREE_HH


Property changes on: trunk/UI/GTK2/src/ResultsTree.hh
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: trunk/UI/GTK2/src/importDialog.hh
===================================================================
--- trunk/UI/GTK2/src/importDialog.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/importDialog.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005,2006 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -27,7 +27,7 @@
 #include <glibmm/ustring.h>
 
 #include "DocumentInfo.h"
-#include "ModelColumns.h"
+#include "ModelColumns.hh"
 #include "importDialog_glade.hh"
 
 class importDialog : public importDialog_glade

Modified: trunk/UI/GTK2/src/indexDialog.hh
===================================================================
--- trunk/UI/GTK2/src/indexDialog.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/indexDialog.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005,2006 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
 
 #include <glibmm/ustring.h>
 
-#include "ModelColumns.h"
+#include "ModelColumns.hh"
 #include "indexDialog_glade.hh"
 
 class indexDialog : public indexDialog_glade

Modified: trunk/UI/GTK2/src/mainWindow.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/mainWindow.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005-2008 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -39,13 +39,13 @@
 #include "QueryProperties.h"
 #include "MonitorInterface.h"
 #include "MonitorHandler.h"
-#include "EnginesTree.h"
-#include "IndexPage.h"
-#include "ModelColumns.h"
-#include "Notebook.h"
 #include "PinotSettings.h"
-#include "ResultsTree.h"
 #include "WorkerThreads.h"
+#include "EnginesTree.hh"
+#include "IndexPage.hh"
+#include "ModelColumns.hh"
+#include "Notebook.hh"
+#include "ResultsTree.hh"
 #include "mainWindow_glade.hh"
 
 class mainWindow : public mainWindow_glade

Modified: trunk/UI/GTK2/src/prefsWindow.hh
===================================================================
--- trunk/UI/GTK2/src/prefsWindow.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/prefsWindow.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -27,9 +27,9 @@
 #include <glibmm/ustring.h>
 #include <gtkmm/liststore.h>
 
-#include "ModelColumns.h"
 #include "PinotSettings.h"
 #include "WorkerThreads.h"
+#include "ModelColumns.hh"
 #include "prefsWindow_glade.hh"
 
 class prefsWindow : public prefsWindow_glade

Modified: trunk/UI/GTK2/src/propertiesDialog.hh
===================================================================
--- trunk/UI/GTK2/src/propertiesDialog.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/propertiesDialog.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005,2006 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -26,7 +26,7 @@
 #include <gtkmm/liststore.h>
 
 #include "DocumentInfo.h"
-#include "ModelColumns.h"
+#include "ModelColumns.hh"
 #include "propertiesDialog_glade.hh"
 
 class propertiesDialog : public propertiesDialog_glade

Modified: trunk/UI/GTK2/src/queryDialog.hh
===================================================================
--- trunk/UI/GTK2/src/queryDialog.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/queryDialog.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005,2006 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by

Modified: trunk/UI/GTK2/src/statisticsDialog.hh
===================================================================
--- trunk/UI/GTK2/src/statisticsDialog.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/statisticsDialog.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -25,8 +25,8 @@
 #include <glibmm/refptr.h>
 #include <gtkmm/treestore.h>
 
-#include "ModelColumns.h"
 #include "WorkerThreads.h"
+#include "ModelColumns.hh"
 #include "statisticsDialog_glade.hh"
 
 class statisticsDialog : public statisticsDialog_glade



From fabricecolin at mail.berlios.de  Sun Feb  1 12:49:19 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 1 Feb 2009 12:49:19 +0100
Subject: [Pinot-svn] r1532 - trunk/po
Message-ID: <200902011149.n11BnJuZ015716@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-01 12:49:12 +0100 (Sun, 01 Feb 2009)
New Revision: 1532

Modified:
   trunk/po/POTFILES.in
Log:
Files were renamed.


Modified: trunk/po/POTFILES.in
===================================================================
--- trunk/po/POTFILES.in	2009-02-01 11:47:02 UTC (rev 1531)
+++ trunk/po/POTFILES.in	2009-02-01 11:49:12 UTC (rev 1532)
@@ -1,26 +1,26 @@
 # List of source files containing translatable strings.
 Core/DaemonState.cpp
 Core/OnDiskHandler.cpp
-Core/pinot-dbus-daemon.cc
+Core/pinot-dbus-daemon.cpp
 Core/PinotSettings.cpp
 Core/PinotUtils.cpp
 Core/ServerThreads.cpp
 Core/UniqueApplication.cpp
 Core/WorkerThreads.cpp
-UI/GTK2/src/EnginesTree.cpp
+UI/GTK2/src/EnginesTree.cc
 UI/GTK2/src/indexDialog.cc
 UI/GTK2/src/indexDialog_glade.cc
 UI/GTK2/src/importDialog.cc
 UI/GTK2/src/importDialog_glade.cc
 UI/GTK2/src/indexDialog.cc
 UI/GTK2/src/indexDialog_glade.cc
-UI/GTK2/src/IndexPage.cpp
+UI/GTK2/src/IndexPage.cc
 UI/GTK2/src/launcherDialog.cc
 UI/GTK2/src/launcherDialog_glade.cc
 UI/GTK2/src/mainWindow.cc
 UI/GTK2/src/mainWindow_glade.cc
-UI/GTK2/src/ModelColumns.cpp
-UI/GTK2/src/Notebook.cpp
+UI/GTK2/src/ModelColumns.cc
+UI/GTK2/src/Notebook.cc
 UI/GTK2/src/pinot.cc
 UI/GTK2/src/prefsWindow.cc
 UI/GTK2/src/prefsWindow_glade.cc
@@ -28,6 +28,6 @@
 UI/GTK2/src/propertiesDialog_glade.cc
 UI/GTK2/src/queryDialog.cc
 UI/GTK2/src/queryDialog_glade.cc
-UI/GTK2/src/ResultsTree.cpp
+UI/GTK2/src/ResultsTree.cc
 UI/GTK2/src/statisticsDialog.cc
 UI/GTK2/src/statisticsDialog_glade.cc



From fabricecolin at mail.berlios.de  Sun Feb  1 12:55:44 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 1 Feb 2009 12:55:44 +0100
Subject: [Pinot-svn] r1533 - trunk/Core
Message-ID: <200902011155.n11Btiji023163@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-01 12:55:37 +0100 (Sun, 01 Feb 2009)
New Revision: 1533

Modified:
   trunk/Core/Makefile.am
Log:
Daemon specifics don't need be in libCore.


Modified: trunk/Core/Makefile.am
===================================================================
--- trunk/Core/Makefile.am	2009-02-01 11:49:12 UTC (rev 1532)
+++ trunk/Core/Makefile.am	2009-02-01 11:55:37 UTC (rev 1533)
@@ -12,8 +12,6 @@
 noinst_LTLIBRARIES = libCore.la
 
 libCore_la_SOURCES = \
-	DaemonState.cpp \
-	OnDiskHandler.cpp \
 	PinotSettings.cpp \
 	PinotUtils.cpp \
 	ServerThreads.cpp \
@@ -55,7 +53,10 @@
 	@GLIBMM_LIBS@ @DBUS_LIBS@ @GTHREAD_LIBS@ @XML_LIBS@ \
 	@HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
 
-pinot_dbus_daemon_SOURCES = pinot-dbus-daemon.cpp
+pinot_dbus_daemon_SOURCES = \
+	DaemonState.cpp \
+	OnDiskHandler.cpp \
+	pinot-dbus-daemon.cpp
 
-pinot_index_DEPENDENCIES = libCore.la
+pinot_dbus_daemon_DEPENDENCIES = libCore.la
 



From fabricecolin at mail.berlios.de  Sun Feb  1 14:54:07 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 1 Feb 2009 14:54:07 +0100
Subject: [Pinot-svn] r1534 - in trunk: Core UI/GTK2/src
Message-ID: <200902011354.n11Ds7b0030728@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-01 14:53:59 +0100 (Sun, 01 Feb 2009)
New Revision: 1534

Modified:
   trunk/Core/pinot-dbus-daemon.cpp
   trunk/UI/GTK2/src/pinot.cc
Log:
Removed reference to tokenizer libraries.


Modified: trunk/Core/pinot-dbus-daemon.cpp
===================================================================
--- trunk/Core/pinot-dbus-daemon.cpp	2009-02-01 11:55:37 UTC (rev 1533)
+++ trunk/Core/pinot-dbus-daemon.cpp	2009-02-01 13:53:59 UTC (rev 1534)
@@ -392,7 +392,7 @@
 
 	// Make sure only one instance runs
 	UniqueApplication uniqueApp("de.berlios.PinotDBusDaemon");
-	string confDirectory = PinotSettings::getConfigurationDirectory();
+	string confDirectory(PinotSettings::getConfigurationDirectory());
 	g_pidFileName = confDirectory + "/pinot-dbus-daemon.pid";
 	if (chdir(confDirectory.c_str()) == 0)
 	{
@@ -431,7 +431,7 @@
 		cerr << "Couldn't load MIME settings" << endl;
 	}
 	DownloaderInterface::initialize();
-	// Load tokenizer libraries, if any
+	// Load filter libraries, if any
 	Dijon::HtmlFilter::initialize();
 	Dijon::FilterFactory::loadFilters(string(LIBDIR) + "/pinot/filters");
 	Dijon::FilterFactory::loadFilters(confDirectory + "/filters");

Modified: trunk/UI/GTK2/src/pinot.cc
===================================================================
--- trunk/UI/GTK2/src/pinot.cc	2009-02-01 11:55:37 UTC (rev 1533)
+++ trunk/UI/GTK2/src/pinot.cc	2009-02-01 13:53:59 UTC (rev 1534)
@@ -219,7 +219,7 @@
 	settings.enableClientMode(true);
 #endif
 
-	string confDirectory = PinotSettings::getConfigurationDirectory();
+	string confDirectory(PinotSettings::getConfigurationDirectory());
 	if (chdir(confDirectory.c_str()) == 0)
 	{
 		// Redirect cout and cerr to a file
@@ -246,7 +246,7 @@
 		cerr << "Couldn't load MIME settings" << endl;
 	}
 	DownloaderInterface::initialize();
-	// Load tokenizer libraries, if any
+	// Load filter libraries, if any
 	Dijon::HtmlFilter::initialize();
 	Dijon::FilterFactory::loadFilters(string(LIBDIR) + "/pinot/filters");
 	Dijon::FilterFactory::loadFilters(confDirectory + "/filters");



From fabricecolin at mail.berlios.de  Sun Feb  1 15:00:06 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 1 Feb 2009 15:00:06 +0100
Subject: [Pinot-svn] r1535 - in trunk: . Core IndexSearch
Message-ID: <200902011400.n11E060W031322@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-01 14:59:46 +0100 (Sun, 01 Feb 2009)
New Revision: 1535

Added:
   trunk/Core/pinot-search.1
   trunk/Core/pinot-search.cpp
Removed:
   trunk/IndexSearch/pinot-search.1
   trunk/IndexSearch/pinot-search.cpp
Modified:
   trunk/Core/Makefile.am
   trunk/IndexSearch/Makefile.am
   trunk/Makefile.am
Log:
Moved pinot-search to Core. Use PinotSettings for proxy parameters and plugins'
editable parameters. Added -r/--storedquery option to find a stored query by
name and run it.


Modified: trunk/Core/Makefile.am
===================================================================
--- trunk/Core/Makefile.am	2009-02-01 13:53:59 UTC (rev 1534)
+++ trunk/Core/Makefile.am	2009-02-01 13:59:46 UTC (rev 1535)
@@ -19,7 +19,9 @@
 	WorkerThreads.cpp
 
 if HAVE_DBUS
-bin_PROGRAMS = pinot-dbus-daemon
+bin_PROGRAMS = pinot-search pinot-dbus-daemon
+#else
+bin_PROGRAMS = pinot-search
 endif
 
 AM_CXXFLAGS = \
@@ -38,6 +40,23 @@
 AM_CXXFLAGS += -DHAVE_DBUS
 endif
 
+pinot_search_LDFLAGS = \
+	-rdynamic
+
+pinot_search_LDADD = \
+	-L$(top_builddir)/Utils \
+	-L$(top_builddir)/Tokenize \
+	-L$(top_builddir)/Collect \
+	-L$(top_builddir)/IndexSearch \
+	-lCore -lIndexSearch -lCollect -lTokenize -lUtils -lBasicUtils \
+	@GLIBMM_LIBS@ @DBUS_LIBS@ \
+	@XML_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
+
+pinot_search_SOURCES = \
+	pinot-search.cpp
+
+pinot_search_DEPENDENCIES = libCore.la
+
 pinot_dbus_daemon_LDFLAGS = \
 	-rdynamic
 

Copied: trunk/Core/pinot-search.1 (from rev 1533, trunk/IndexSearch/pinot-search.1)


Property changes on: trunk/Core/pinot-search.1
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/pinot-search.cpp (from rev 1533, trunk/IndexSearch/pinot-search.cpp)
===================================================================
--- trunk/IndexSearch/pinot-search.cpp	2009-02-01 11:55:37 UTC (rev 1533)
+++ trunk/Core/pinot-search.cpp	2009-02-01 13:59:46 UTC (rev 1535)
@@ -0,0 +1,412 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <getopt.h>
+#include <iostream>
+#include <fstream>
+#include <string>
+
+#include "config.h"
+#include "NLS.h"
+#include "Languages.h"
+#include "MIMEScanner.h"
+#include "Url.h"
+#include "DownloaderFactory.h"
+#include "ModuleFactory.h"
+#include "ResultsExporter.h"
+#include "WebEngine.h"
+#include "PinotSettings.h"
+
+using namespace std;
+
+static struct option g_longOptions[] = {
+	{"datefirst", 0, 0, 'd'},
+	{"help", 0, 0, 'h'},
+	{"locationonly", 0, 0, 'l'},
+	{"max", 1, 0, 'm'},
+	{"storedquery", 0, 0, 'r'},
+	{"stemming", 1, 0, 's'},
+	{"tocsv", 1, 0, 'c'},
+	{"toxml", 1, 0, 'x'},
+	{"version", 0, 0, 'v'},
+	{"xesamql", 0, 0, 'q'},
+	{"xesamul", 0, 0, 'u'},
+	{0, 0, 0, 0}
+};
+
+static bool loadFile(const string &xesamFile, string &fileContents)
+{
+	ifstream inputFile;
+	bool readFile = false;
+
+	inputFile.open(xesamFile.c_str());
+	if (inputFile.good() == true)
+	{
+		inputFile.seekg(0, ios::end);
+		int length = inputFile.tellg();
+		inputFile.seekg(0, ios::beg);
+
+		char *pFileBuffer = new char[length + 1];
+		inputFile.read(pFileBuffer, length);
+		if (inputFile.fail() == false)
+		{
+			pFileBuffer[length] = '\0';
+
+			fileContents = string(pFileBuffer, length);
+			readFile = true;
+		}
+		delete[] pFileBuffer;
+	}
+	inputFile.close();
+
+	return readFile;
+}
+
+static void printHelp(void)
+{
+	map<ModuleProperties, bool> engines;
+
+	// Help
+	ModuleFactory::loadModules(string(LIBDIR) + string("/pinot/backends"));
+	ModuleFactory::getSupportedEngines(engines);
+	ModuleFactory::unloadModules();
+	cout << "pinot-search - Query search engines from the command-line\n\n"
+		<< "Usage: pinot-search [OPTIONS] SEARCHENGINETYPE SEARCHENGINENAME|SEARCHENGINEOPTION QUERYINPUT\n\n"
+		<< "Options:\n"
+		<< "  -d, --datefirst           sort by date then by relevance\n"
+		<< "  -h, --help                display this help and exit\n"
+		<< "  -l, --locationonly        only show the location of each result\n"
+		<< "  -m, --max                 maximum number of results (default 10)\n"
+		<< "  -r, --storedquery         query input is the name of a stored query\n"
+		<< "  -s, --stemming            stemming language (in English)\n"
+		<< "  -c, --tocsv               file to export results in CSV format to\n"
+		<< "  -x, --toxml               file to export results in XML format to\n"
+		<< "  -v, --version             output version information and exit\n"
+		<< "  -q, --xesamql             query input is a file containing Xesam QL\n"
+		<< "  -u, --xesamul             query input is a file containing Xesam UL\n\n"
+		<< "Supported search engine types are :";
+	for (map<ModuleProperties, bool>::const_iterator engineIter = engines.begin(); engineIter != engines.end(); ++engineIter)
+	{
+		cout << " '" << engineIter->first.m_name << "'";
+	}
+	cout << "\n\nExamples:\n"
+		<< "pinot-search opensearch " << PREFIX << "/share/pinot/engines/KrustyDescription.xml \"clowns\"\n\n"
+		<< "pinot-search --max 20 sherlock --seteditable \"Bozo App ID:1234567890\" " << PREFIX << "/share/pinot/engines/Bozo.src \"clowns\"\n\n"
+		<< "pinot-search googleapi mygoogleapikey \"clowns\"\n\n"
+		<< "pinot-search xapian ~/.pinot/index \"label:Clowns\"\n\n"
+		<< "pinot-search --stemming english xapian somehostname:12345 \"clowning\"\n\n"
+		<< "pinot-search --xesamul xapian ~/.pinot/index some_xesamul_query.txt\n\n"
+		<< "pinot-search --xesamql xesam - some_xesamql_query.xml\n\n"
+		<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
+}
+
+int main(int argc, char **argv)
+{
+	QueryProperties::QueryType queryType = QueryProperties::XAPIAN_QP;
+	string engineType, option, csvExport, xmlExport, stemLanguage;
+	unsigned int maxResultsCount = 10; 
+	int longOptionIndex = 0;
+	bool printResults = true;
+	bool sortByDate = false;
+	bool locationOnly = false;
+	bool isStoredQuery = false;
+
+	// Look at the options
+	int optionChar = getopt_long(argc, argv, "c:dhlm:qrs:uvx:", g_longOptions, &longOptionIndex);
+	while (optionChar != -1)
+	{
+		switch (optionChar)
+		{
+			case 'c':
+				if (optarg != NULL)
+				{
+					csvExport = optarg;
+					printResults = false;
+				}
+				break;
+			case 'd':
+				sortByDate = true;
+				break;
+			case 'h':
+				printHelp();
+				return EXIT_SUCCESS;
+			case 'l':
+				locationOnly = true;
+				break;
+			case 'm':
+				if (optarg != NULL)
+				{
+					maxResultsCount = (unsigned int )atoi(optarg);
+				}
+				break;
+			case 'q':
+				queryType = QueryProperties::XESAM_QL;
+				break;
+			case 'r':
+				isStoredQuery = true;
+				break;
+			case 's':
+				if (optarg != NULL)
+				{
+					stemLanguage = optarg;
+				}
+				break;
+			case 'u':
+				queryType = QueryProperties::XESAM_UL;
+				break;
+			case 'v':
+				cout << "pinot-search - " << PACKAGE_STRING << "\n\n"
+					<< "This is free software.  You may redistribute copies of it under the terms of\n"
+					<< "the GNU General Public License <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>.\n"
+					<< "There is NO WARRANTY, to the extent permitted by law." << endl;
+				return EXIT_SUCCESS;
+			case 'x':
+				if (optarg != NULL)
+				{
+					xmlExport = optarg;
+					printResults = false;
+				}
+				break;
+			default:
+				return EXIT_FAILURE;
+		}
+
+		// Next option
+		optionChar = getopt_long(argc, argv, "c:dhlm:qrs:uvx:", g_longOptions, &longOptionIndex);
+	}
+
+	if (argc == 1)
+	{
+		printHelp();
+		return EXIT_SUCCESS;
+	}
+
+	if ((argc < 4) ||
+		(argc - optind != 3))
+	{
+		cerr << "Wrong number of parameters" << endl;
+		return EXIT_FAILURE;
+	}
+
+	// This will create the necessary directories on the first run
+	PinotSettings &settings = PinotSettings::getInstance();
+	string confDirectory(PinotSettings::getConfigurationDirectory());
+
+	if (MIMEScanner::initialize(PinotSettings::getHomeDirectory() + "/.local",
+		string(SHARED_MIME_INFO_PREFIX)) == false)
+	{
+		cerr << "Couldn't load MIME settings" << endl;
+	}
+	DownloaderInterface::initialize();
+	ModuleFactory::loadModules(string(LIBDIR) + string("/pinot/backends"));
+	ModuleFactory::loadModules(confDirectory + "/backends");
+
+	// Localize language names
+	Languages::setIntlName(0, _("Unknown"));
+	Languages::setIntlName(1, _("Danish"));
+	Languages::setIntlName(2, _("Dutch"));
+	Languages::setIntlName(3, _("English"));
+	Languages::setIntlName(4, _("Finnish"));
+	Languages::setIntlName(5, _("French"));
+	Languages::setIntlName(6, _("German"));
+	Languages::setIntlName(7, _("Hungarian"));
+	Languages::setIntlName(8, _("Italian"));
+	Languages::setIntlName(9, _("Norwegian"));
+	Languages::setIntlName(10, _("Portuguese"));
+	Languages::setIntlName(11, _("Romanian"));
+	Languages::setIntlName(12, _("Russian"));
+	Languages::setIntlName(13, _("Spanish"));
+	Languages::setIntlName(14, _("Swedish"));
+	Languages::setIntlName(15, _("Turkish"));
+
+	// Load the settings
+	settings.load(PinotSettings::LOAD_ALL);
+
+	engineType = argv[optind];
+	option = argv[optind + 1];
+	char *pQueryInput = argv[optind + 2];
+
+	// Set the query
+	QueryProperties queryProps("pinot-search", "", queryType);
+	if (queryType == QueryProperties::XAPIAN_QP)
+	{
+		if (isStoredQuery == true)
+		{
+			const map<string, QueryProperties> &queries = settings.getQueries();
+			map<string, QueryProperties>::const_iterator queryIter = queries.find(pQueryInput);
+			if (queryIter != queries.end())
+			{
+				queryProps = queryIter->second;
+			}
+			else
+			{
+				cerr << "Couldn't find stored query " << pQueryInput << endl;
+
+				DownloaderInterface::shutdown();
+				MIMEScanner::shutdown();
+
+				return EXIT_FAILURE;
+			}
+		}
+		else
+		{
+			queryProps.setFreeQuery(pQueryInput);
+		}
+	}
+	else if (isStoredQuery == true)
+	{
+		cerr << "Options -r and -q/-u are incompatible" << endl;
+
+		DownloaderInterface::shutdown();
+		MIMEScanner::shutdown();
+
+		return EXIT_FAILURE;
+	}
+	else
+	{
+		string fileContents;
+
+		// Load the query from file
+		if (loadFile(pQueryInput, fileContents) == false)
+		{
+			cerr << "Couldn't load query from file " << pQueryInput << endl;
+
+			DownloaderInterface::shutdown();
+			MIMEScanner::shutdown();
+
+			return EXIT_FAILURE;
+		}
+
+		queryProps.setFreeQuery(fileContents);
+	}
+	queryProps.setStemmingLanguage(stemLanguage);
+	queryProps.setMaximumResultsCount(maxResultsCount);
+	if (sortByDate == true)
+	{
+		queryProps.setSortOrder(QueryProperties::DATE);
+	}
+
+	// Which SearchEngine ?
+	SearchEngineInterface *pEngine = ModuleFactory::getSearchEngine(engineType, option);
+	if (pEngine == NULL)
+	{
+		cerr << "Couldn't obtain search engine instance" << endl;
+
+		DownloaderInterface::shutdown();
+		MIMEScanner::shutdown();
+
+		return EXIT_FAILURE;
+	}
+
+	// Set up the proxy
+	WebEngine *pWebEngine = dynamic_cast<WebEngine *>(pEngine);
+	if (pWebEngine != NULL)
+	{
+		DownloaderInterface *pDownloader = pWebEngine->getDownloader();
+		if ((pDownloader != NULL) &&
+			(settings.m_proxyEnabled == true) &&
+			(settings.m_proxyAddress.empty() == false))
+		{
+			char portStr[64];
+
+			pDownloader->setSetting("proxyaddress", settings.m_proxyAddress);
+			snprintf(portStr, 64, "%u", settings.m_proxyPort);
+			pDownloader->setSetting("proxyport", portStr);
+			pDownloader->setSetting("proxytype", settings.m_proxyType);
+		}
+
+		pWebEngine->setEditableValues(settings.m_editablePluginValues);
+	}
+
+	pEngine->setDefaultOperator(SearchEngineInterface::DEFAULT_OP_AND);
+	if (pEngine->runQuery(queryProps) == true)
+	{
+		string resultsPage;
+
+		const vector<DocumentInfo> &resultsList = pEngine->getResults();
+		if (resultsList.empty() == false)
+		{
+			if (printResults == true)
+			{
+				unsigned int count = 0;
+
+				vector<DocumentInfo>::const_iterator resultIter = resultsList.begin();
+				while (resultIter != resultsList.end())
+				{
+					string rawUrl(resultIter->getLocation());
+
+					if (locationOnly == false)
+					{
+						cout << count << " Location : '" << rawUrl << "'"<< endl;
+						cout << count << " Title    : " << resultIter->getTitle() << endl;
+						cout << count << " Type     : " << resultIter->getType() << endl;
+						cout << count << " Language : " << resultIter->getLanguage() << endl;
+						cout << count << " Date     : " << resultIter->getTimestamp() << endl;
+						cout << count << " Size     : " << resultIter->getSize() << endl;
+						cout << count << " Extract  : " << resultIter->getExtract() << endl;
+						cout << count << " Score    : " << resultIter->getScore() << endl;
+					}
+					else
+					{
+						cout << rawUrl << endl;
+					}
+					++count;
+
+					// Next
+					++resultIter;
+				}
+			}
+			else
+			{
+				string engineName(ModuleFactory::getSearchEngineName(engineType, option));
+
+				if (csvExport.empty() == false)
+				{
+					CSVExporter exporter(csvExport, queryProps);
+
+					exporter.exportResults(engineName, maxResultsCount, resultsList);
+				}
+
+				if (xmlExport.empty() == false)
+				{
+					OpenSearchExporter exporter(xmlExport, queryProps);
+
+					exporter.exportResults(engineName, maxResultsCount, resultsList);
+				}
+			}
+		}
+		else
+		{
+			cerr << "No results" << endl;
+		}
+	}
+	else
+	{
+		cerr << "Couldn't run query on search engine " << engineType << endl;
+	}
+
+	delete pEngine;
+
+	ModuleFactory::unloadModules();
+	DownloaderInterface::shutdown();
+	MIMEScanner::shutdown();
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/Core/pinot-search.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: trunk/IndexSearch/Makefile.am
===================================================================
--- trunk/IndexSearch/Makefile.am	2009-02-01 13:53:59 UTC (rev 1534)
+++ trunk/IndexSearch/Makefile.am	2009-02-01 13:59:46 UTC (rev 1535)
@@ -46,9 +46,9 @@
 endif
 
 if HAVE_DBUS
-bin_PROGRAMS = pinot-index pinot-label pinot-search
+bin_PROGRAMS = pinot-index pinot-label
 else
-bin_PROGRAMS = pinot-index pinot-search
+bin_PROGRAMS = pinot-index
 endif
 
 pinot_index_LDFLAGS = \
@@ -80,24 +80,6 @@
 
 pinot_label_DEPENDENCIES = libIndex.la
 
-pinot_search_LDFLAGS = \
-	-rdynamic
-
-pinot_search_LDADD = \
-	-L$(top_builddir)/Utils \
-	-L$(top_builddir)/Tokenize \
-	-L$(top_builddir)/Collect \
-	-L$(top_builddir)/IndexSearch/Google \
-	-L$(top_builddir)/IndexSearch/xesam \
-	-lIndexSearch -lCollect -lTokenize -lUtils -lBasicUtils \
-	@GLIBMM_LIBS@ @DBUS_LIBS@ \
-	@XML_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
-
-pinot_search_SOURCES = \
-	pinot-search.cpp
-
-pinot_search_DEPENDENCIES = libIndexSearch.la
-
 AM_CXXFLAGS = \
 	@MISC_CFLAGS@ \
 	-I$(top_srcdir)/Utils \

Deleted: trunk/IndexSearch/pinot-search.1
===================================================================
--- trunk/IndexSearch/pinot-search.1	2009-02-01 13:53:59 UTC (rev 1534)
+++ trunk/IndexSearch/pinot-search.1	2009-02-01 13:59:46 UTC (rev 1535)
@@ -1,74 +0,0 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-SEARCH "1" "January 2009" "pinot-search - pinot 0.90" "User Commands"
-.SH NAME
-pinot-search \- Query search engines from the command-line
-.SH SYNOPSIS
-.B pinot-search
-[\fIOPTIONS\fR] \fISEARCHENGINETYPE SEARCHENGINENAME|SEARCHENGINEOPTION QUERYINPUT\fR
-.SH DESCRIPTION
-pinot\-search \- Query search engines from the command\-line
-.SH OPTIONS
-.TP
-\fB\-d\fR, \fB\-\-datefirst\fR
-sort by date then by relevance
-.TP
-\fB\-h\fR, \fB\-\-help\fR
-display this help and exit
-.TP
-\fB\-l\fR, \fB\-\-locationonly\fR
-only show the location of each result
-.TP
-\fB\-m\fR, \fB\-\-max\fR
-maximum number of results (default 10)
-.TP
-\fB\-a\fR, \fB\-\-proxyaddress\fR
-proxy address
-.TP
-\fB\-p\fR, \fB\-\-proxyport\fR
-proxy port
-.TP
-\fB\-t\fR, \fB\-\-proxytype\fR
-proxy type (default HTTP, SOCKS4, SOCKS5)
-.TP
-\fB\-s\fR, \fB\-\-stemming\fR
-stemming language (in English)
-.TP
-\fB\-e\fR, \fB\-\-seteditable\fR
-plugin editable parameter, name:value pair
-.TP
-\fB\-c\fR, \fB\-\-tocsv\fR
-file to export results in CSV format to
-.TP
-\fB\-x\fR, \fB\-\-toxml\fR
-file to export results in XML format to
-.TP
-\fB\-v\fR, \fB\-\-version\fR
-output version information and exit
-.TP
-\fB\-q\fR, \fB\-\-xesamql\fR
-query input is a file containing Xesam QL
-.TP
-\fB\-u\fR, \fB\-\-xesamul\fR
-query input is a file containing Xesam UL
-.PP
-Supported search engine types are : 'opensearch' 'sherlock' 'xapian'
-.SH EXAMPLES
-pinot\-search opensearch /usr/share/pinot/engines/KrustyDescription.xml "clowns"
-.PP
-pinot\-search \fB\-\-max\fR 20 sherlock \fB\-\-seteditable\fR "Bozo App ID:1234567890" /usr/share/pinot/engines/Bozo.src "clowns"
-.PP
-pinot\-search googleapi mygoogleapikey "clowns"
-.PP
-pinot\-search xapian ~/.pinot/index "label:Clowns"
-.PP
-pinot\-search \fB\-\-stemming\fR english xapian somehostname:12345 "clowning"
-.PP
-pinot\-search \fB\-\-xesamul\fR xapian ~/.pinot/index some_xesamul_query.txt
-.PP
-pinot\-search \fB\-\-xesamql\fR xesam \- some_xesamql_query.xml
-.SH "REPORTING BUGS"
-Report bugs to fabricecolin at users.berlios.de
-.PP
-This is free software.  You may redistribute copies of it under the terms of
-the GNU General Public License <http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html>.
-There is NO WARRANTY, to the extent permitted by law.

Deleted: trunk/IndexSearch/pinot-search.cpp
===================================================================
--- trunk/IndexSearch/pinot-search.cpp	2009-02-01 13:53:59 UTC (rev 1534)
+++ trunk/IndexSearch/pinot-search.cpp	2009-02-01 13:59:46 UTC (rev 1535)
@@ -1,398 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <getopt.h>
-#include <iostream>
-#include <fstream>
-#include <string>
-
-#include "config.h"
-#include "Languages.h"
-#include "MIMEScanner.h"
-#include "Url.h"
-#include "DownloaderFactory.h"
-#include "ModuleFactory.h"
-#include "ResultsExporter.h"
-#include "WebEngine.h"
-
-using namespace std;
-
-static struct option g_longOptions[] = {
-	{"datefirst", 0, 0, 'd'},
-	{"help", 0, 0, 'h'},
-	{"locationonly", 0, 0, 'l'},
-	{"max", 1, 0, 'm'},
-	{"proxyaddress", 1, 0, 'a'},
-	{"proxyport", 1, 0, 'p'},
-	{"proxytype", 1, 0, 't'},
-	{"seteditable", 1, 0, 'e'},
-	{"stemming", 1, 0, 's'},
-	{"tocsv", 1, 0, 'c'},
-	{"toxml", 1, 0, 'x'},
-	{"version", 0, 0, 'v'},
-	{"xesamql", 0, 0, 'q'},
-	{"xesamul", 0, 0, 'u'},
-	{0, 0, 0, 0}
-};
-
-static bool loadFile(const string &xesamFile, string &fileContents)
-{
-	ifstream inputFile;
-	bool readFile = false;
-
-	inputFile.open(xesamFile.c_str());
-	if (inputFile.good() == true)
-	{
-		inputFile.seekg(0, ios::end);
-		int length = inputFile.tellg();
-		inputFile.seekg(0, ios::beg);
-
-		char *pFileBuffer = new char[length + 1];
-		inputFile.read(pFileBuffer, length);
-		if (inputFile.fail() == false)
-		{
-			pFileBuffer[length] = '\0';
-
-			fileContents = string(pFileBuffer, length);
-			readFile = true;
-		}
-		delete[] pFileBuffer;
-	}
-	inputFile.close();
-
-	return readFile;
-}
-
-static void printHelp(void)
-{
-	map<ModuleProperties, bool> engines;
-
-	// Help
-	ModuleFactory::loadModules(string(LIBDIR) + string("/pinot/backends"));
-	ModuleFactory::getSupportedEngines(engines);
-	ModuleFactory::unloadModules();
-	cout << "pinot-search - Query search engines from the command-line\n\n"
-		<< "Usage: pinot-search [OPTIONS] SEARCHENGINETYPE SEARCHENGINENAME|SEARCHENGINEOPTION QUERYINPUT\n\n"
-		<< "Options:\n"
-		<< "  -d, --datefirst           sort by date then by relevance\n"
-		<< "  -h, --help                display this help and exit\n"
-		<< "  -l, --locationonly        only show the location of each result\n"
-		<< "  -m, --max                 maximum number of results (default 10)\n"
-		<< "  -a, --proxyaddress        proxy address\n"
-		<< "  -p, --proxyport           proxy port\n"
-		<< "  -t, --proxytype           proxy type (default HTTP, SOCKS4, SOCKS5)\n"
-		<< "  -s, --stemming            stemming language (in English)\n"
-		<< "  -e, --seteditable         plugin editable parameter, name:value pair\n"
-		<< "  -c, --tocsv               file to export results in CSV format to\n"
-		<< "  -x, --toxml               file to export results in XML format to\n"
-		<< "  -v, --version             output version information and exit\n"
-		<< "  -q, --xesamql             query input is a file containing Xesam QL\n"
-		<< "  -u, --xesamul             query input is a file containing Xesam UL\n\n"
-		<< "Supported search engine types are :";
-	for (map<ModuleProperties, bool>::const_iterator engineIter = engines.begin(); engineIter != engines.end(); ++engineIter)
-	{
-		cout << " '" << engineIter->first.m_name << "'";
-	}
-	cout << "\n\nExamples:\n"
-		<< "pinot-search opensearch " << PREFIX << "/share/pinot/engines/KrustyDescription.xml \"clowns\"\n\n"
-		<< "pinot-search --max 20 sherlock --seteditable \"Bozo App ID:1234567890\" " << PREFIX << "/share/pinot/engines/Bozo.src \"clowns\"\n\n"
-		<< "pinot-search googleapi mygoogleapikey \"clowns\"\n\n"
-		<< "pinot-search xapian ~/.pinot/index \"label:Clowns\"\n\n"
-		<< "pinot-search --stemming english xapian somehostname:12345 \"clowning\"\n\n"
-		<< "pinot-search --xesamul xapian ~/.pinot/index some_xesamul_query.txt\n\n"
-		<< "pinot-search --xesamql xesam - some_xesamql_query.xml\n\n"
-		<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
-}
-
-int main(int argc, char **argv)
-{
-	QueryProperties::QueryType queryType = QueryProperties::XAPIAN_QP;
-	string engineType, option, csvExport, xmlExport, proxyAddress, proxyPort, proxyType, editableParameter, stemLanguage;
-	unsigned int maxResultsCount = 10; 
-	int longOptionIndex = 0;
-	bool printResults = true;
-	bool sortByDate = false;
-	bool locationOnly = false;
-
-	// Look at the options
-	int optionChar = getopt_long(argc, argv, "a:c:de:hlm:p:qs:t:uvx:", g_longOptions, &longOptionIndex);
-	while (optionChar != -1)
-	{
-		switch (optionChar)
-		{
-			case 'a':
-				if (optarg != NULL)
-				{
-					proxyAddress = optarg;
-				}
-				break;
-			case 'c':
-				if (optarg != NULL)
-				{
-					csvExport = optarg;
-					printResults = false;
-				}
-				break;
-			case 'd':
-				sortByDate = true;
-				break;
-			case 'e':
-				if (optarg != NULL)
-				{
-					editableParameter = optarg;
-				}
-				break;
-			case 'h':
-				printHelp();
-				return EXIT_SUCCESS;
-			case 'l':
-				locationOnly = true;
-				break;
-			case 'm':
-				if (optarg != NULL)
-				{
-					maxResultsCount = (unsigned int )atoi(optarg);
-				}
-				break;
-			case 'p':
-				if (optarg != NULL)
-				{
-					proxyPort = optarg;
-				}
-				break;
-			case 'q':
-				queryType = QueryProperties::XESAM_QL;
-				break;
-			case 's':
-				if (optarg != NULL)
-				{
-					stemLanguage = optarg;
-				}
-				break;
-			case 't':
-				if (optarg != NULL)
-				{
-					proxyType = optarg;
-				}
-				break;
-			case 'u':
-				queryType = QueryProperties::XESAM_UL;
-				break;
-			case 'v':
-				cout << "pinot-search - " << PACKAGE_STRING << "\n\n"
-					<< "This is free software.  You may redistribute copies of it under the terms of\n"
-					<< "the GNU General Public License <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>.\n"
-					<< "There is NO WARRANTY, to the extent permitted by law." << endl;
-				return EXIT_SUCCESS;
-			case 'x':
-				if (optarg != NULL)
-				{
-					xmlExport = optarg;
-					printResults = false;
-				}
-				break;
-			default:
-				return EXIT_FAILURE;
-		}
-
-		// Next option
-		optionChar = getopt_long(argc, argv, "a:c:de:hlm:p:qs:t:uvx:", g_longOptions, &longOptionIndex);
-	}
-
-	if (argc == 1)
-	{
-		printHelp();
-		return EXIT_SUCCESS;
-	}
-
-	if ((argc < 4) ||
-		(argc - optind != 3))
-	{
-		cerr << "Wrong number of parameters" << endl;
-		return EXIT_FAILURE;
-	}
-
-	MIMEScanner::initialize("", "");
-	DownloaderInterface::initialize();
-	ModuleFactory::loadModules(string(LIBDIR) + string("/pinot/backends"));
-
-	// Localize language names
-	Languages::setIntlName(0, "Unknown");
-	Languages::setIntlName(1, "Danish");
-	Languages::setIntlName(2, "Dutch");
-	Languages::setIntlName(3, "English");
-	Languages::setIntlName(4, "Finnish");
-	Languages::setIntlName(5, "French");
-	Languages::setIntlName(6, "German");
-	Languages::setIntlName(7, "Hungarian");
-	Languages::setIntlName(8, "Italian");
-	Languages::setIntlName(9, "Norwegian");
-	Languages::setIntlName(10, "Portuguese");
-	Languages::setIntlName(11, "Romanian");
-	Languages::setIntlName(12, "Russian");
-	Languages::setIntlName(13, "Spanish");
-	Languages::setIntlName(14, "Swedish");
-	Languages::setIntlName(15, "Turkish");
-
-	engineType = argv[optind];
-	option = argv[optind + 1];
-	char *pQueryInput = argv[optind + 2];
-
-	// Which SearchEngine ?
-	SearchEngineInterface *pEngine = ModuleFactory::getSearchEngine(engineType, option);
-	if (pEngine == NULL)
-	{
-		cerr << "Couldn't obtain search engine instance" << endl;
-
-		DownloaderInterface::shutdown();
-		MIMEScanner::shutdown();
-
-		return EXIT_FAILURE;
-	}
-
-	// Set up the proxy
-	WebEngine *pWebEngine = dynamic_cast<WebEngine *>(pEngine);
-	if (pWebEngine != NULL)
-	{
-		DownloaderInterface *pDownloader = pWebEngine->getDownloader();
-		if ((pDownloader != NULL) &&
-			(proxyAddress.empty() == false) &&
-			(proxyPort.empty() == false))
-		{
-			pDownloader->setSetting("proxyaddress", proxyAddress);
-			pDownloader->setSetting("proxyport", proxyPort);
-			pDownloader->setSetting("proxytype", proxyType);
-		}
-
-		string::size_type colonPos = editableParameter.find(':');
-		if (colonPos != string::npos)
-		{
-			map<string, string> editableValues;
-
-			editableValues[editableParameter.substr(0, colonPos)] = editableParameter.substr(colonPos + 1);
-			pWebEngine->setEditableValues(editableValues);
-		}
-	}
-
-	// Set the query
-	QueryProperties queryProps("pinot-search", "", queryType);
-	if (queryType == QueryProperties::XAPIAN_QP)
-	{
-		queryProps.setFreeQuery(pQueryInput);
-	}
-	else
-	{
-		string fileContents;
-
-		// Load the query from file
-		if (loadFile(pQueryInput, fileContents) == false)
-		{
-			cerr << "Couldn't load query from file " << pQueryInput << endl;
-
-			DownloaderInterface::shutdown();
-			MIMEScanner::shutdown();
-
-			return EXIT_FAILURE;
-		}
-
-		queryProps.setFreeQuery(fileContents);
-	}
-	queryProps.setStemmingLanguage(stemLanguage);
-	queryProps.setMaximumResultsCount(maxResultsCount);
-	if (sortByDate == true)
-	{
-		queryProps.setSortOrder(QueryProperties::DATE);
-	}
-
-	pEngine->setDefaultOperator(SearchEngineInterface::DEFAULT_OP_AND);
-	if (pEngine->runQuery(queryProps) == true)
-	{
-		string resultsPage;
-
-		const vector<DocumentInfo> &resultsList = pEngine->getResults();
-		if (resultsList.empty() == false)
-		{
-			if (printResults == true)
-			{
-				unsigned int count = 0;
-
-				vector<DocumentInfo>::const_iterator resultIter = resultsList.begin();
-				while (resultIter != resultsList.end())
-				{
-					string rawUrl(resultIter->getLocation());
-
-					if (locationOnly == false)
-					{
-						cout << count << " Location : '" << rawUrl << "'"<< endl;
-						cout << count << " Title    : " << resultIter->getTitle() << endl;
-						cout << count << " Type     : " << resultIter->getType() << endl;
-						cout << count << " Language : " << resultIter->getLanguage() << endl;
-						cout << count << " Date     : " << resultIter->getTimestamp() << endl;
-						cout << count << " Size     : " << resultIter->getSize() << endl;
-						cout << count << " Extract  : " << resultIter->getExtract() << endl;
-						cout << count << " Score    : " << resultIter->getScore() << endl;
-					}
-					else
-					{
-						cout << rawUrl << endl;
-					}
-					++count;
-
-					// Next
-					++resultIter;
-				}
-			}
-			else
-			{
-				string engineName(ModuleFactory::getSearchEngineName(engineType, option));
-
-				if (csvExport.empty() == false)
-				{
-					CSVExporter exporter(csvExport, queryProps);
-
-					exporter.exportResults(engineName, maxResultsCount, resultsList);
-				}
-
-				if (xmlExport.empty() == false)
-				{
-					OpenSearchExporter exporter(xmlExport, queryProps);
-
-					exporter.exportResults(engineName, maxResultsCount, resultsList);
-				}
-			}
-		}
-		else
-		{
-			cerr << "No results" << endl;
-		}
-	}
-	else
-	{
-		cerr << "Couldn't run query on search engine " << engineType << endl;
-	}
-
-	delete pEngine;
-
-	ModuleFactory::unloadModules();
-	DownloaderInterface::shutdown();
-	MIMEScanner::shutdown();
-
-	return EXIT_SUCCESS;
-}

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2009-02-01 13:53:59 UTC (rev 1534)
+++ trunk/Makefile.am	2009-02-01 13:59:46 UTC (rev 1535)
@@ -8,7 +8,7 @@
 	pinot*.desktop pinot.spec \
 	IndexSearch/Plugins/*src IndexSearch/Plugins/*.xml \
 	IndexSearch/pinot-index.1 IndexSearch/pinot-label.1 \
-	IndexSearch/pinot-search.1 UI/GTK2/src/pinot.1 \
+	Core/pinot-search.1 UI/GTK2/src/pinot.1 \
 	Core/pinot-dbus-daemon.1 Core/pinot-dbus-daemon.xml \
 	Core/de.berlios.Pinot.service \
 	UI/GTK2/xapian-powered.png UI/icons/48x48/pinot.png \
@@ -18,12 +18,12 @@
 	scripts/bash/*.sh scripts/python/*.py
 
 man_MANS = IndexSearch/pinot-index.1 IndexSearch/pinot-label.1 \
-	IndexSearch/pinot-search.1 Core/pinot-dbus-daemon.1 UI/GTK2/src/pinot.1
+	Core/pinot-search.1 Core/pinot-dbus-daemon.1 UI/GTK2/src/pinot.1
 
 manuals:
 	@help2man --no-info --name "Index documents from the command-line" IndexSearch/pinot-index       >IndexSearch/pinot-index.1
 	@help2man --no-info --name "Label files from the command-line" IndexSearch/pinot-label           >IndexSearch/pinot-label.1
-	@help2man --no-info --name "Query search engines from the command-line" IndexSearch/pinot-search >IndexSearch/pinot-search.1
+	@help2man --no-info --name "Query search engines from the command-line" IndexSearch/pinot-search >Core/pinot-search.1
 	@help2man --no-info --name "D-Bus search and index daemon" Core/pinot-dbus-daemon                >Core/pinot-dbus-daemon.1
 	@help2man --no-info --name "A metasearch tool for the Free Desktop" UI/GTK2/src/pinot            >UI/GTK2/src/pinot.1
 



From fabricecolin at mail.berlios.de  Sun Feb  1 15:29:00 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 1 Feb 2009 15:29:00 +0100
Subject: [Pinot-svn] r1536 - in trunk: . Core
Message-ID: <200902011429.n11ET0dE001619@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-01 15:28:52 +0100 (Sun, 01 Feb 2009)
New Revision: 1536

Modified:
   trunk/Core/Makefile.am
   trunk/Makefile.am
Log:
Minor fixes.


Modified: trunk/Core/Makefile.am
===================================================================
--- trunk/Core/Makefile.am	2009-02-01 13:59:46 UTC (rev 1535)
+++ trunk/Core/Makefile.am	2009-02-01 14:28:52 UTC (rev 1536)
@@ -20,7 +20,7 @@
 
 if HAVE_DBUS
 bin_PROGRAMS = pinot-search pinot-dbus-daemon
-#else
+else
 bin_PROGRAMS = pinot-search
 endif
 

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2009-02-01 13:59:46 UTC (rev 1535)
+++ trunk/Makefile.am	2009-02-01 14:28:52 UTC (rev 1536)
@@ -21,11 +21,11 @@
 	Core/pinot-search.1 Core/pinot-dbus-daemon.1 UI/GTK2/src/pinot.1
 
 manuals:
-	@help2man --no-info --name "Index documents from the command-line" IndexSearch/pinot-index       >IndexSearch/pinot-index.1
-	@help2man --no-info --name "Label files from the command-line" IndexSearch/pinot-label           >IndexSearch/pinot-label.1
-	@help2man --no-info --name "Query search engines from the command-line" IndexSearch/pinot-search >Core/pinot-search.1
-	@help2man --no-info --name "D-Bus search and index daemon" Core/pinot-dbus-daemon                >Core/pinot-dbus-daemon.1
-	@help2man --no-info --name "A metasearch tool for the Free Desktop" UI/GTK2/src/pinot            >UI/GTK2/src/pinot.1
+	@help2man --no-info --name "Index documents from the command-line" IndexSearch/pinot-index >IndexSearch/pinot-index.1
+	@help2man --no-info --name "Label files from the command-line" IndexSearch/pinot-label     >IndexSearch/pinot-label.1
+	@help2man --no-info --name "Query search engines from the command-line" Core/pinot-search  >Core/pinot-search.1
+	@help2man --no-info --name "D-Bus search and index daemon" Core/pinot-dbus-daemon          >Core/pinot-dbus-daemon.1
+	@help2man --no-info --name "A metasearch tool for the Free Desktop" UI/GTK2/src/pinot      >UI/GTK2/src/pinot.1
 
 install-data-local:
 	@ln -fs $(bindir)/pinot $(DESTDIR)$(bindir)/pinot-prefs



From fabricecolin at mail.berlios.de  Mon Feb  2 14:44:21 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Mon, 2 Feb 2009 14:44:21 +0100
Subject: [Pinot-svn] r1537 - in trunk: . Core IndexSearch
Message-ID: <200902021344.n12DiLBR019106@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-02 14:44:00 +0100 (Mon, 02 Feb 2009)
New Revision: 1537

Added:
   trunk/Core/pinot-index.1
   trunk/Core/pinot-index.cpp
Removed:
   trunk/IndexSearch/pinot-index.1
   trunk/IndexSearch/pinot-index.cpp
Modified:
   trunk/Core/Makefile.am
   trunk/IndexSearch/Makefile.am
   trunk/Makefile.am
Log:
Moved pinot-index to Core. Use PinotSettings for proxy parameters.
The -d/--db option may be the name of an index.


Modified: trunk/Core/Makefile.am
===================================================================
--- trunk/Core/Makefile.am	2009-02-01 14:28:52 UTC (rev 1536)
+++ trunk/Core/Makefile.am	2009-02-02 13:44:00 UTC (rev 1537)
@@ -19,9 +19,9 @@
 	WorkerThreads.cpp
 
 if HAVE_DBUS
-bin_PROGRAMS = pinot-search pinot-dbus-daemon
+bin_PROGRAMS = pinot-index pinot-search pinot-dbus-daemon
 else
-bin_PROGRAMS = pinot-search
+bin_PROGRAMS = pinot-index pinot-search
 endif
 
 AM_CXXFLAGS = \
@@ -40,6 +40,22 @@
 AM_CXXFLAGS += -DHAVE_DBUS
 endif
 
+pinot_index_LDFLAGS = \
+	-rdynamic
+
+pinot_index_LDADD = \
+	-L$(top_builddir)/Utils \
+	-L$(top_builddir)/Tokenize \
+	-L$(top_builddir)/Collect \
+	-L$(top_builddir)/IndexSearch \
+	-lCore -lIndexSearch -lCollect -lTokenize -lUtils -lBasicUtils \
+	@GLIBMM_LIBS@ @DBUS_LIBS@ \
+	@XML_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
+
+pinot_index_SOURCES = pinot-index.cpp
+
+pinot_index_DEPENDENCIES = libCore.la
+
 pinot_search_LDFLAGS = \
 	-rdynamic
 

Copied: trunk/Core/pinot-index.1 (from rev 1536, trunk/IndexSearch/pinot-index.1)
===================================================================
--- trunk/IndexSearch/pinot-index.1	2009-02-01 14:28:52 UTC (rev 1536)
+++ trunk/Core/pinot-index.1	2009-02-02 13:44:00 UTC (rev 1537)
@@ -0,0 +1,43 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
+.TH PINOT-INDEX "1" "February 2009" "pinot-index - pinot 0.90" "User Commands"
+.SH NAME
+pinot-index \- Index documents from the command-line
+.SH SYNOPSIS
+.B pinot-index
+[\fIOPTIONS\fR] \fIURLS\fR
+.SH DESCRIPTION
+pinot\-index \- Index documents from the command\-line
+.SH OPTIONS
+.TP
+\fB\-b\fR, \fB\-\-backend\fR
+name of back\-end to use (default xapian)
+.TP
+\fB\-c\fR, \fB\-\-check\fR
+check whether the given URL is in the index
+.TP
+\fB\-d\fR, \fB\-\-db\fR
+path to, or name of, index to use (mandatory)
+.TP
+\fB\-h\fR, \fB\-\-help\fR
+display this help and exit
+.TP
+\fB\-i\fR, \fB\-\-index\fR
+index the given URL
+.TP
+\fB\-s\fR, \fB\-\-showinfo\fR
+show information about the document
+.TP
+\fB\-v\fR, \fB\-\-version\fR
+output version information and exit
+.PP
+Supported back\-ends are : 'xapian'
+.SH EXAMPLES
+pinot\-index \fB\-\-check\fR \fB\-\-showinfo\fR \fB\-\-backend\fR xapian \fB\-\-db\fR ~/.pinot/daemon file:///home/fabrice/Documents/Bozo.txt
+.PP
+pinot\-index \fB\-\-index\fR \fB\-\-db\fR "My Web Pages" http://pinot.berlios.de/
+.SH "REPORTING BUGS"
+Report bugs to fabricecolin at users.berlios.de
+.PP
+This is free software.  You may redistribute copies of it under the terms of
+the GNU General Public License <http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html>.
+There is NO WARRANTY, to the extent permitted by law.


Property changes on: trunk/Core/pinot-index.1
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/pinot-index.cpp (from rev 1536, trunk/IndexSearch/pinot-index.cpp)
===================================================================
--- trunk/IndexSearch/pinot-index.cpp	2009-02-01 14:28:52 UTC (rev 1536)
+++ trunk/Core/pinot-index.cpp	2009-02-02 13:44:00 UTC (rev 1537)
@@ -0,0 +1,373 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#include <getopt.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <iostream>
+#include <string>
+#include <fstream>
+
+#include "config.h"
+#include "NLS.h"
+#include "Languages.h"
+#include "MIMEScanner.h"
+#include "Url.h"
+#include "FilterFactory.h"
+#include "DownloaderFactory.h"
+#include "FilterWrapper.h"
+#include "ModuleFactory.h"
+#include "PinotSettings.h"
+
+using namespace std;
+
+static struct option g_longOptions[] = {
+	{"backend", 1, 0, 'b'},
+	{"check", 0, 0, 'c'},
+	{"db", 1, 0, 'd'},
+	{"help", 0, 0, 'h'},
+	{"index", 0, 0, 'i'},
+	{"showinfo", 0, 0, 's'},
+	{"version", 0, 0, 'v'},
+	{0, 0, 0, 0}
+};
+
+static void printHelp(void)
+{
+	map<ModuleProperties, bool> engines;
+
+	// Help
+	ModuleFactory::loadModules(string(LIBDIR) + string("/pinot/backends"));
+	ModuleFactory::getSupportedEngines(engines);
+	cout << "pinot-index - Index documents from the command-line\n\n"
+		<< "Usage: pinot-index [OPTIONS] URLS\n\n"
+		<< "Options:\n"
+		<< "  -b, --backend             name of back-end to use (default " << PinotSettings::getInstance().m_defaultBackend << ")\n"
+		<< "  -c, --check               check whether the given URL is in the index\n"
+		<< "  -d, --db                  path to, or name of, index to use (mandatory)\n"
+		<< "  -h, --help                display this help and exit\n"
+		<< "  -i, --index               index the given URL\n"
+		<< "  -s, --showinfo            show information about the document\n"
+		<< "  -v, --version             output version information and exit\n\n"
+		<< "Supported back-ends are :";
+	for (map<ModuleProperties, bool>::const_iterator engineIter = engines.begin(); engineIter != engines.end(); ++engineIter)
+	{
+		if ((engineIter->second == true) &&
+			(ModuleFactory::isSupported(engineIter->first.m_name, true) == true))
+		{
+			cout << " '" << engineIter->first.m_name << "'";
+		}
+	}
+	ModuleFactory::unloadModules();
+	cout << "\n\nExamples:\n"
+		<< "pinot-index --check --showinfo --backend xapian --db ~/.pinot/daemon file:///home/fabrice/Documents/Bozo.txt\n\n"
+		<< "pinot-index --index --db \"My Web Pages\" http://pinot.berlios.de/\n\n"
+		<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
+}
+
+static void closeAll(void)
+{
+	// Close everything
+	ModuleFactory::unloadModules();
+	Dijon::FilterFactory::unloadFilters();
+	Dijon::HtmlFilter::shutdown();
+	DownloaderInterface::shutdown();
+	MIMEScanner::shutdown();
+}
+
+int main(int argc, char **argv)
+{
+	string type, option;
+	string backendType, databaseName;
+	int longOptionIndex = 0;
+	unsigned int docId = 0;
+	bool checkDocument = false, indexDocument = false, showInfo = false, success = false;
+
+	// Look at the options
+	int optionChar = getopt_long(argc, argv, "b:cd:hisv", g_longOptions, &longOptionIndex);
+	while (optionChar != -1)
+	{
+		set<string> engines;
+
+		switch (optionChar)
+		{
+			case 'b':
+				if (optarg != NULL)
+				{
+					backendType = optarg;
+				}
+				break;
+			case 'c':
+				checkDocument = true;
+				break;
+			case 'd':
+				if (optarg != NULL)
+				{
+					databaseName = optarg;
+				}
+				break;
+			case 'h':
+				printHelp();
+				return EXIT_SUCCESS;
+			case 'i':
+				indexDocument = true;
+				break;
+			case 's':
+				showInfo = true;
+				break;
+			case 'v':
+				cout << "pinot-index - " << PACKAGE_STRING << "\n\n"
+					<< "This is free software.  You may redistribute copies of it under the terms of\n"
+					<< "the GNU General Public License <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>.\n"
+					<< "There is NO WARRANTY, to the extent permitted by law." << endl;
+				return EXIT_SUCCESS;
+			default:
+				return EXIT_FAILURE;
+		}
+
+		// Next option
+		optionChar = getopt_long(argc, argv, "b:cd:hisv", g_longOptions, &longOptionIndex);
+	}
+
+	if (argc == 1)
+	{
+		printHelp();
+		return EXIT_SUCCESS;
+	}
+
+	if ((argc < 2) ||
+		(argc - optind == 0))
+	{
+		cerr << "Not enough parameters" << endl;
+		return EXIT_FAILURE;
+	}
+
+	if (((indexDocument == false) &&
+		(checkDocument == false)) ||
+		(databaseName.empty() == true))
+	{
+		cerr << "Incorrect parameters" << endl;
+		return EXIT_FAILURE;
+	}
+
+	// This will create the necessary directories on the first run
+	PinotSettings &settings = PinotSettings::getInstance();
+	string confDirectory(PinotSettings::getConfigurationDirectory());
+
+	if (MIMEScanner::initialize(PinotSettings::getHomeDirectory() + "/.local",
+		string(SHARED_MIME_INFO_PREFIX)) == false)
+	{
+		cerr << "Couldn't load MIME settings" << endl;
+	}
+	DownloaderInterface::initialize();
+	Dijon::HtmlFilter::initialize();
+	Dijon::FilterFactory::loadFilters(string(LIBDIR) + string("/pinot/filters"));
+	ModuleFactory::loadModules(string(LIBDIR) + string("/pinot/backends"));
+	ModuleFactory::loadModules(confDirectory + "/backends");
+
+	// Localize language names
+	Languages::setIntlName(0, _("Unknown"));
+	Languages::setIntlName(1, _("Danish"));
+	Languages::setIntlName(2, _("Dutch"));
+	Languages::setIntlName(3, _("English"));
+	Languages::setIntlName(4, _("Finnish"));
+	Languages::setIntlName(5, _("French"));
+	Languages::setIntlName(6, _("German"));
+	Languages::setIntlName(7, _("Hungarian"));
+	Languages::setIntlName(8, _("Italian"));
+	Languages::setIntlName(9, _("Norwegian"));
+	Languages::setIntlName(10, _("Portuguese"));
+	Languages::setIntlName(11, _("Romanian"));
+	Languages::setIntlName(12, _("Russian"));
+	Languages::setIntlName(13, _("Spanish"));
+	Languages::setIntlName(14, _("Swedish"));
+	Languages::setIntlName(15, _("Turkish"));
+
+	// Load the settings
+	settings.load(PinotSettings::LOAD_ALL);
+
+	atexit(closeAll);
+
+	if (backendType.empty() == true)
+	{
+		backendType = settings.m_defaultBackend;
+	}
+
+	// Is this a known index name ?
+	PinotSettings::IndexProperties indexProps = settings.getIndexPropertiesByName(databaseName);
+	if (indexProps.m_name.empty() == true)
+	{
+		// No, it's not
+		indexProps.m_location = databaseName;
+	}
+
+	// Make sure the index is open in the correct mode
+	bool wasObsoleteFormat = false;
+	if (ModuleFactory::openOrCreateIndex(backendType, indexProps.m_location, wasObsoleteFormat, (indexDocument ? false : true)) == false)
+	{
+		cerr << "Couldn't open index " << indexProps.m_location << endl;
+
+		return EXIT_FAILURE;
+	}
+
+	// Get a read-write index of the given type
+	IndexInterface *pIndex = ModuleFactory::getIndex(backendType, indexProps.m_location);
+	if (pIndex == NULL)
+	{
+		cerr << "Couldn't obtain index for " << indexProps.m_location << endl;
+
+		return EXIT_FAILURE;
+	}
+
+	while (optind < argc)
+	{
+		string urlParam(argv[optind]);
+
+		if (checkDocument == true)
+		{
+			if (pIndex->isGood() == true)
+			{
+				docId = pIndex->hasDocument(urlParam);
+				if (docId > 0)
+				{
+					cout << urlParam << ": document ID " << docId << endl;
+					success = true;
+				}
+			}
+		}
+		if (indexDocument == true)
+		{
+			Url thisUrl(urlParam);
+
+			// Which Downloader ?
+			DownloaderInterface *pDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
+			if (pDownloader == NULL)
+			{
+				cerr << "Couldn't obtain downloader for protocol " << thisUrl.getProtocol() << endl;
+
+				success = false;
+
+				// Next
+				++optind;
+				continue;
+			}
+
+			// Set up the proxy
+			if ((settings.m_proxyEnabled == true) &&
+				(settings.m_proxyAddress.empty() == false))
+			{
+				char portStr[64];
+
+				pDownloader->setSetting("proxyaddress", settings.m_proxyAddress);
+				snprintf(portStr, 64, "%u", settings.m_proxyPort);
+				pDownloader->setSetting("proxyport", portStr);
+				pDownloader->setSetting("proxytype", settings.m_proxyType);
+			}
+
+			DocumentInfo docInfo("", urlParam, MIMEScanner::scanUrl(thisUrl), "");
+			Document *pDoc = pDownloader->retrieveUrl(docInfo);
+			if (pDoc == NULL)
+			{
+				cerr << "Couldn't download " << urlParam << endl;
+			}
+			else
+			{
+				FilterWrapper wrapFilter(pIndex);
+				set<string> labels;
+
+				// Update an existing document or add to the index ?
+				docId = pIndex->hasDocument(urlParam);
+				if (docId > 0)
+				{
+					// Update the document
+					if (wrapFilter.updateDocument(*pDoc, docId) == true)
+					{
+						success = true;
+					}
+				}
+				else
+				{
+					// Index the document
+					success = wrapFilter.indexDocument(*pDoc, labels, docId);
+				}
+
+				if (success == true)
+				{
+					// Flush the index
+					pIndex->flush();
+				}
+
+				delete pDoc;
+			}
+
+			delete pDownloader;
+		}
+		if ((showInfo == true) &&
+			(docId > 0))
+		{
+			DocumentInfo docInfo;
+			set<string> labels;
+
+			cout << "Index version       : " << pIndex->getMetadata("version") << endl;
+
+			if (pIndex->getDocumentInfo(docId, docInfo) == true)
+			{
+				cout << "Location : '" << docInfo.getLocation() << "'" << endl;
+				cout << "Title    : " << docInfo.getTitle() << endl;
+				cout << "Type     : " << docInfo.getType() << endl;
+				cout << "Language : " << docInfo.getLanguage() << endl;
+				cout << "Date     : " << docInfo.getTimestamp() << endl;
+				cout << "Size     : " << docInfo.getSize() << endl;
+			}
+			if (pIndex->getDocumentLabels(docId, labels) == true)
+			{
+				cout << "Labels   : ";
+				for (set<string>::const_iterator labelIter = labels.begin();
+					labelIter != labels.end(); ++labelIter)
+				{
+					if (labelIter->substr(0, 2) == "X-")
+					{
+						continue;
+					}
+					cout << "[" << Url::escapeUrl(*labelIter) << "]";
+				}
+				cout << endl;
+			}
+
+			vector<MIMEAction> typeActions;
+			MIMEScanner::getDefaultActions(docInfo.getType(), typeActions);
+			for (vector<MIMEAction>::const_iterator actionIter = typeActions.begin();
+				actionIter != typeActions.end(); ++actionIter)
+			{
+				cout << "Action   : '" << actionIter->m_name << "' " << actionIter->m_exec << endl;
+			}
+		}
+
+		// Next
+		++optind;
+	}
+	delete pIndex;
+
+	// Did whatever operation we carried out succeed ?
+	if (success == true)
+	{
+		return EXIT_SUCCESS;
+	}
+
+	return EXIT_FAILURE;
+}


Property changes on: trunk/Core/pinot-index.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: trunk/IndexSearch/Makefile.am
===================================================================
--- trunk/IndexSearch/Makefile.am	2009-02-01 14:28:52 UTC (rev 1536)
+++ trunk/IndexSearch/Makefile.am	2009-02-02 13:44:00 UTC (rev 1537)
@@ -46,27 +46,9 @@
 endif
 
 if HAVE_DBUS
-bin_PROGRAMS = pinot-index pinot-label
-else
-bin_PROGRAMS = pinot-index
+bin_PROGRAMS = pinot-label
 endif
 
-pinot_index_LDFLAGS = \
-	-rdynamic
-
-pinot_index_LDADD = \
-	-L$(top_builddir)/Utils \
-	-L$(top_builddir)/Tokenize \
-	-L$(top_builddir)/Collect \
-	-L$(top_builddir)/IndexSearch/Google \
-	-lIndexSearch -lCollect -lTokenize -lUtils -lBasicUtils \
-	@GLIBMM_LIBS@ @DBUS_LIBS@ \
-	@XML_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
-
-pinot_index_SOURCES = pinot-index.cpp
-
-pinot_index_DEPENDENCIES = libIndexSearch.la
-
 pinot_label_LDFLAGS = \
 	-rdynamic
 

Deleted: trunk/IndexSearch/pinot-index.1
===================================================================
--- trunk/IndexSearch/pinot-index.1	2009-02-01 14:28:52 UTC (rev 1536)
+++ trunk/IndexSearch/pinot-index.1	2009-02-02 13:44:00 UTC (rev 1537)
@@ -1,52 +0,0 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-INDEX "1" "January 2009" "pinot-index - pinot 0.90" "User Commands"
-.SH NAME
-pinot-index \- Index documents from the command-line
-.SH SYNOPSIS
-.B pinot-index
-[\fIOPTIONS\fR] \fIURLS\fR
-.SH DESCRIPTION
-pinot\-index \- Index documents from the command\-line
-.SH OPTIONS
-.TP
-\fB\-b\fR, \fB\-\-backend\fR
-name of back\-end to use (default xapian)
-.TP
-\fB\-c\fR, \fB\-\-check\fR
-check whether the given URL is in the index
-.TP
-\fB\-d\fR, \fB\-\-db\fR
-path to index to use (mandatory)
-.TP
-\fB\-h\fR, \fB\-\-help\fR
-display this help and exit
-.TP
-\fB\-i\fR, \fB\-\-index\fR
-index the given URL
-.TP
-\fB\-a\fR, \fB\-\-proxyaddress\fR
-proxy address
-.TP
-\fB\-p\fR, \fB\-\-proxyport\fR
-proxy port
-.TP
-\fB\-t\fR, \fB\-\-proxytype\fR
-proxy type (default HTTP, SOCKS4, SOCKS5)
-.TP
-\fB\-s\fR, \fB\-\-showinfo\fR
-show information about the document
-.TP
-\fB\-v\fR, \fB\-\-version\fR
-output version information and exit
-.PP
-Supported back\-ends are : 'xapian'
-.SH EXAMPLES
-pinot\-index \fB\-\-check\fR \fB\-\-showinfo\fR \fB\-\-backend\fR xapian \fB\-\-db\fR ~/.pinot/daemon file:///home/fabrice/Documents/Bozo.txt
-.PP
-pinot\-index \fB\-\-index\fR \fB\-\-db\fR ~/.pinot/index http://pinot.berlios.de/
-.SH "REPORTING BUGS"
-Report bugs to fabricecolin at users.berlios.de
-.PP
-This is free software.  You may redistribute copies of it under the terms of
-the GNU General Public License <http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html>.
-There is NO WARRANTY, to the extent permitted by law.

Deleted: trunk/IndexSearch/pinot-index.cpp
===================================================================
--- trunk/IndexSearch/pinot-index.cpp	2009-02-01 14:28:52 UTC (rev 1536)
+++ trunk/IndexSearch/pinot-index.cpp	2009-02-02 13:44:00 UTC (rev 1537)
@@ -1,370 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
- 
-#include <getopt.h>
-#include <cstdlib>
-#include <cstdio>
-#include <iostream>
-#include <string>
-#include <fstream>
-
-#include "config.h"
-#include "Languages.h"
-#include "MIMEScanner.h"
-#include "Url.h"
-#include "FilterFactory.h"
-#include "DownloaderFactory.h"
-#include "FilterWrapper.h"
-#include "ModuleFactory.h"
-#include "config.h"
-
-using namespace std;
-
-static struct option g_longOptions[] = {
-	{"backend", 1, 0, 'b'},
-	{"check", 0, 0, 'c'},
-	{"db", 1, 0, 'd'},
-	{"help", 0, 0, 'h'},
-	{"index", 0, 0, 'i'},
-	{"proxyaddress", 1, 0, 'a'},
-	{"proxyport", 1, 0, 'p'},
-	{"proxytype", 1, 0, 't'},
-	{"showinfo", 0, 0, 's'},
-	{"version", 0, 0, 'v'},
-	{0, 0, 0, 0}
-};
-
-static void printHelp(void)
-{
-	map<ModuleProperties, bool> engines;
-
-	// Help
-	ModuleFactory::loadModules(string(LIBDIR) + string("/pinot/backends"));
-	ModuleFactory::getSupportedEngines(engines);
-	cout << "pinot-index - Index documents from the command-line\n\n"
-		<< "Usage: pinot-index [OPTIONS] URLS\n\n"
-		<< "Options:\n"
-		<< "  -b, --backend             name of back-end to use (default xapian)\n"
-		<< "  -c, --check               check whether the given URL is in the index\n"
-		<< "  -d, --db                  path to index to use (mandatory)\n"
-		<< "  -h, --help                display this help and exit\n"
-		<< "  -i, --index               index the given URL\n"
-		<< "  -a, --proxyaddress        proxy address\n"
-		<< "  -p, --proxyport           proxy port\n"
-		<< "  -t, --proxytype           proxy type (default HTTP, SOCKS4, SOCKS5)\n"
-		<< "  -s, --showinfo            show information about the document\n"
-		<< "  -v, --version             output version information and exit\n\n"
-		<< "Supported back-ends are :";
-	for (map<ModuleProperties, bool>::const_iterator engineIter = engines.begin(); engineIter != engines.end(); ++engineIter)
-	{
-		if ((engineIter->second == true) &&
-			(ModuleFactory::isSupported(engineIter->first.m_name, true) == true))
-		{
-			cout << " '" << engineIter->first.m_name << "'";
-		}
-	}
-	ModuleFactory::unloadModules();
-	cout << "\n\nExamples:\n"
-		<< "pinot-index --check --showinfo --backend xapian --db ~/.pinot/daemon file:///home/fabrice/Documents/Bozo.txt\n\n"
-		<< "pinot-index --index --db ~/.pinot/index http://pinot.berlios.de/\n\n"
-		<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
-}
-
-static void closeAll(void)
-{
-	// Close everything
-	ModuleFactory::unloadModules();
-	Dijon::FilterFactory::unloadFilters();
-	Dijon::HtmlFilter::shutdown();
-	DownloaderInterface::shutdown();
-	MIMEScanner::shutdown();
-}
-
-int main(int argc, char **argv)
-{
-	string type, option;
-	// Use back-end xapian by default for backward compatibility
-	string backendType("xapian"), databaseName, proxyAddress, proxyPort, proxyType;
-	int longOptionIndex = 0;
-	unsigned int docId = 0;
-	bool checkDocument = false, indexDocument = false, showInfo = false, success = false;
-
-	// Look at the options
-	int optionChar = getopt_long(argc, argv, "a:b:cd:hip:t:sv", g_longOptions, &longOptionIndex);
-	while (optionChar != -1)
-	{
-		set<string> engines;
-
-		switch (optionChar)
-		{
-			case 'a':
-				if (optarg != NULL)
-				{
-					proxyAddress = optarg;
-				}
-				break;
-			case 'b':
-				if (optarg != NULL)
-				{
-					backendType = optarg;
-				}
-				break;
-			case 'c':
-				checkDocument = true;
-				break;
-			case 'd':
-				if (optarg != NULL)
-				{
-					databaseName = optarg;
-				}
-				break;
-			case 'h':
-				printHelp();
-				return EXIT_SUCCESS;
-			case 'i':
-				indexDocument = true;
-				break;
-			case 'p':
-				if (optarg != NULL)
-				{
-					proxyPort = optarg;
-				}
-				break;
-			case 's':
-				showInfo = true;
-				break;
-			case 't':
-				if (optarg != NULL)
-				{
-					proxyType = optarg;
-				}
-				break;
-			case 'v':
-				cout << "pinot-index - " << PACKAGE_STRING << "\n\n"
-					<< "This is free software.  You may redistribute copies of it under the terms of\n"
-					<< "the GNU General Public License <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>.\n"
-					<< "There is NO WARRANTY, to the extent permitted by law." << endl;
-				return EXIT_SUCCESS;
-			default:
-				return EXIT_FAILURE;
-		}
-
-		// Next option
-		optionChar = getopt_long(argc, argv, "a:b:cd:hip:t:sv", g_longOptions, &longOptionIndex);
-	}
-
-	if (argc == 1)
-	{
-		printHelp();
-		return EXIT_SUCCESS;
-	}
-
-	if ((argc < 2) ||
-		(argc - optind == 0))
-	{
-		cerr << "Not enough parameters" << endl;
-		return EXIT_FAILURE;
-	}
-
-	if (((indexDocument == false) &&
-		(checkDocument == false)) ||
-		(backendType.empty() == true) ||
-		(databaseName.empty() == true))
-	{
-		cerr << "Incorrect parameters" << endl;
-		return EXIT_FAILURE;
-	}
-
-	MIMEScanner::initialize("", "");
-	DownloaderInterface::initialize();
-	Dijon::HtmlFilter::initialize();
-	Dijon::FilterFactory::loadFilters(string(LIBDIR) + string("/pinot/filters"));
-	ModuleFactory::loadModules(string(LIBDIR) + string("/pinot/backends"));
-
-	// Localize language names
-	Languages::setIntlName (0, "Unknown");
-	Languages::setIntlName (1, "Danish");
-	Languages::setIntlName (2, "Dutch");
-	Languages::setIntlName (3, "English");
-	Languages::setIntlName (4, "Finnish");
-	Languages::setIntlName (5, "French");
-	Languages::setIntlName (6, "German");
-	Languages::setIntlName (7, "Hungarian");
-	Languages::setIntlName (8, "Italian");
-	Languages::setIntlName (9, "Norwegian");
-	Languages::setIntlName (10, "Portuguese");
-	Languages::setIntlName (11, "Romanian");
-	Languages::setIntlName (12, "Russian");
-	Languages::setIntlName (13, "Spanish");
-	Languages::setIntlName (14, "Swedish");
-	Languages::setIntlName (15, "Turkish");
-
-	atexit(closeAll);
-
-	// Make sure the index is open in the correct mode
-	bool wasObsoleteFormat = false;
-	if (ModuleFactory::openOrCreateIndex(backendType, databaseName, wasObsoleteFormat, (indexDocument ? false : true)) == false)
-	{
-		cerr << "Couldn't open index " << databaseName << endl;
-
-		return EXIT_FAILURE;
-	}
-
-	// Get a read-write index of the given type
-	IndexInterface *pIndex = ModuleFactory::getIndex(backendType, databaseName);
-	if (pIndex == NULL)
-	{
-		cerr << "Couldn't obtain index for " << databaseName << endl;
-
-		return EXIT_FAILURE;
-	}
-
-	while (optind < argc)
-	{
-		string urlParam(argv[optind]);
-
-		if (checkDocument == true)
-		{
-			if (pIndex->isGood() == true)
-			{
-				docId = pIndex->hasDocument(urlParam);
-				if (docId > 0)
-				{
-					cout << urlParam << ": document ID " << docId << endl;
-					success = true;
-				}
-			}
-		}
-		if (indexDocument == true)
-		{
-			Url thisUrl(urlParam);
-
-			// Which Downloader ?
-			DownloaderInterface *pDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
-			if (pDownloader == NULL)
-			{
-				cerr << "Couldn't obtain downloader for protocol " << thisUrl.getProtocol() << endl;
-
-				success = false;
-
-				// Next
-				++optind;
-				continue;
-			}
-
-			// Set up the proxy
-			if ((proxyAddress.empty() == false) &&
-				(proxyPort.empty() == false))
-			{
-				pDownloader->setSetting("proxyaddress", proxyAddress);
-				pDownloader->setSetting("proxyport", proxyPort);
-				pDownloader->setSetting("proxytype", proxyType);
-			}
-
-			DocumentInfo docInfo("", urlParam, MIMEScanner::scanUrl(thisUrl), "");
-			Document *pDoc = pDownloader->retrieveUrl(docInfo);
-			if (pDoc == NULL)
-			{
-				cerr << "Couldn't download " << urlParam << endl;
-			}
-			else
-			{
-				FilterWrapper wrapFilter(pIndex);
-				set<string> labels;
-
-				// Update an existing document or add to the index ?
-				docId = pIndex->hasDocument(urlParam);
-				if (docId > 0)
-				{
-					// Update the document
-					if (wrapFilter.updateDocument(*pDoc, docId) == true)
-					{
-						success = true;
-					}
-				}
-				else
-				{
-					// Index the document
-					success = wrapFilter.indexDocument(*pDoc, labels, docId);
-				}
-
-				if (success == true)
-				{
-					// Flush the index
-					pIndex->flush();
-				}
-
-				delete pDoc;
-			}
-
-			delete pDownloader;
-		}
-		if ((showInfo == true) &&
-			(docId > 0))
-		{
-			DocumentInfo docInfo;
-			set<string> labels;
-
-			cout << "Index version       : " << pIndex->getMetadata("version") << endl;
-
-			if (pIndex->getDocumentInfo(docId, docInfo) == true)
-			{
-				cout << "Location : '" << docInfo.getLocation() << "'" << endl;
-				cout << "Title    : " << docInfo.getTitle() << endl;
-				cout << "Type     : " << docInfo.getType() << endl;
-				cout << "Language : " << docInfo.getLanguage() << endl;
-				cout << "Date     : " << docInfo.getTimestamp() << endl;
-				cout << "Size     : " << docInfo.getSize() << endl;
-			}
-			if (pIndex->getDocumentLabels(docId, labels) == true)
-			{
-				cout << "Labels   : ";
-				for (set<string>::const_iterator labelIter = labels.begin();
-					labelIter != labels.end(); ++labelIter)
-				{
-					if (labelIter->substr(0, 2) == "X-")
-					{
-						continue;
-					}
-					cout << "[" << Url::escapeUrl(*labelIter) << "]";
-				}
-				cout << endl;
-			}
-
-			vector<MIMEAction> typeActions;
-			MIMEScanner::getDefaultActions(docInfo.getType(), typeActions);
-			for (vector<MIMEAction>::const_iterator actionIter = typeActions.begin();
-				actionIter != typeActions.end(); ++actionIter)
-			{
-				cout << "Action   : '" << actionIter->m_name << "' " << actionIter->m_exec << endl;
-			}
-		}
-
-		// Next
-		++optind;
-	}
-	delete pIndex;
-
-	// Did whatever operation we carried out succeed ?
-	if (success == true)
-	{
-		return EXIT_SUCCESS;
-	}
-
-	return EXIT_FAILURE;
-}

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2009-02-01 14:28:52 UTC (rev 1536)
+++ trunk/Makefile.am	2009-02-02 13:44:00 UTC (rev 1537)
@@ -7,7 +7,7 @@
 	textcat_conf.txt textcat3_conf.txt \
 	pinot*.desktop pinot.spec \
 	IndexSearch/Plugins/*src IndexSearch/Plugins/*.xml \
-	IndexSearch/pinot-index.1 IndexSearch/pinot-label.1 \
+	Core/pinot-index.1 IndexSearch/pinot-label.1 \
 	Core/pinot-search.1 UI/GTK2/src/pinot.1 \
 	Core/pinot-dbus-daemon.1 Core/pinot-dbus-daemon.xml \
 	Core/de.berlios.Pinot.service \
@@ -17,11 +17,11 @@
 	UI/GTK2/metase-gtk2.glade UI/GTK2/metase-gtk2.gladep \
 	scripts/bash/*.sh scripts/python/*.py
 
-man_MANS = IndexSearch/pinot-index.1 IndexSearch/pinot-label.1 \
+man_MANS = Core/pinot-index.1 IndexSearch/pinot-label.1 \
 	Core/pinot-search.1 Core/pinot-dbus-daemon.1 UI/GTK2/src/pinot.1
 
 manuals:
-	@help2man --no-info --name "Index documents from the command-line" IndexSearch/pinot-index >IndexSearch/pinot-index.1
+	@help2man --no-info --name "Index documents from the command-line" Core/pinot-index >Core/pinot-index.1
 	@help2man --no-info --name "Label files from the command-line" IndexSearch/pinot-label     >IndexSearch/pinot-label.1
 	@help2man --no-info --name "Query search engines from the command-line" Core/pinot-search  >Core/pinot-search.1
 	@help2man --no-info --name "D-Bus search and index daemon" Core/pinot-dbus-daemon          >Core/pinot-dbus-daemon.1



From fabricecolin at mail.berlios.de  Mon Feb  2 14:59:31 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Mon, 2 Feb 2009 14:59:31 +0100
Subject: [Pinot-svn] r1538 - in trunk: Core IndexSearch UI/GTK2/src
Message-ID: <200902021359.n12DxVaF020117@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-02 14:59:23 +0100 (Mon, 02 Feb 2009)
New Revision: 1538

Modified:
   trunk/Core/pinot-dbus-daemon.1
   trunk/Core/pinot-search.1
   trunk/IndexSearch/pinot-label.1
   trunk/UI/GTK2/src/pinot.1
Log:
Updated manual pages.


Modified: trunk/Core/pinot-dbus-daemon.1
===================================================================
--- trunk/Core/pinot-dbus-daemon.1	2009-02-02 13:44:00 UTC (rev 1537)
+++ trunk/Core/pinot-dbus-daemon.1	2009-02-02 13:59:23 UTC (rev 1538)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-DBUS-DAEMON "1" "January 2009" "pinot-dbus-daemon - pinot 0.90" "User Commands"
+.TH PINOT-DBUS-DAEMON "1" "February 2009" "pinot-dbus-daemon - pinot 0.90" "User Commands"
 .SH NAME
 pinot-dbus-daemon \- D-Bus search and index daemon
 .SH SYNOPSIS

Modified: trunk/Core/pinot-search.1
===================================================================
--- trunk/Core/pinot-search.1	2009-02-02 13:44:00 UTC (rev 1537)
+++ trunk/Core/pinot-search.1	2009-02-02 13:59:23 UTC (rev 1538)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-SEARCH "1" "January 2009" "pinot-search - pinot 0.90" "User Commands"
+.TH PINOT-SEARCH "1" "February 2009" "pinot-search - pinot 0.90" "User Commands"
 .SH NAME
 pinot-search \- Query search engines from the command-line
 .SH SYNOPSIS
@@ -21,21 +21,12 @@
 \fB\-m\fR, \fB\-\-max\fR
 maximum number of results (default 10)
 .TP
-\fB\-a\fR, \fB\-\-proxyaddress\fR
-proxy address
+\fB\-r\fR, \fB\-\-storedquery\fR
+query input is the name of a stored query
 .TP
-\fB\-p\fR, \fB\-\-proxyport\fR
-proxy port
-.TP
-\fB\-t\fR, \fB\-\-proxytype\fR
-proxy type (default HTTP, SOCKS4, SOCKS5)
-.TP
 \fB\-s\fR, \fB\-\-stemming\fR
 stemming language (in English)
 .TP
-\fB\-e\fR, \fB\-\-seteditable\fR
-plugin editable parameter, name:value pair
-.TP
 \fB\-c\fR, \fB\-\-tocsv\fR
 file to export results in CSV format to
 .TP
@@ -55,7 +46,7 @@
 .SH EXAMPLES
 pinot\-search opensearch /usr/share/pinot/engines/KrustyDescription.xml "clowns"
 .PP
-pinot\-search \fB\-\-max\fR 20 sherlock \fB\-\-seteditable\fR "Bozo App ID:1234567890" /usr/share/pinot/engines/Bozo.src "clowns"
+pinot\-search \fB\-\-max\fR 20 sherlock /usr/share/pinot/engines/Bozo.src "clowns"
 .PP
 pinot\-search googleapi mygoogleapikey "clowns"
 .PP

Modified: trunk/IndexSearch/pinot-label.1
===================================================================
--- trunk/IndexSearch/pinot-label.1	2009-02-02 13:44:00 UTC (rev 1537)
+++ trunk/IndexSearch/pinot-label.1	2009-02-02 13:59:23 UTC (rev 1538)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-LABEL "1" "January 2009" "pinot-label - pinot 0.90" "User Commands"
+.TH PINOT-LABEL "1" "February 2009" "pinot-label - pinot 0.90" "User Commands"
 .SH NAME
 pinot-label \- Label files from the command-line
 .SH SYNOPSIS

Modified: trunk/UI/GTK2/src/pinot.1
===================================================================
--- trunk/UI/GTK2/src/pinot.1	2009-02-02 13:44:00 UTC (rev 1537)
+++ trunk/UI/GTK2/src/pinot.1	2009-02-02 13:59:23 UTC (rev 1538)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT "1" "January 2009" "pinot - pinot 0.90" "User Commands"
+.TH PINOT "1" "February 2009" "pinot - pinot 0.90" "User Commands"
 .SH NAME
 pinot \- A metasearch tool for the Free Desktop
 .SH SYNOPSIS



From fabricecolin at mail.berlios.de  Tue Feb  3 14:14:54 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Tue, 3 Feb 2009 14:14:54 +0100
Subject: [Pinot-svn] r1539 - trunk/Utils
Message-ID: <200902031314.n13DEs4o003342@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-03 14:14:49 +0100 (Tue, 03 Feb 2009)
New Revision: 1539

Modified:
   trunk/Utils/Url.cpp
   trunk/Utils/Url.h
Log:
Url::resolvePath() is based on the path resolver code written for ServerThreads.


Modified: trunk/Utils/Url.cpp
===================================================================
--- trunk/Utils/Url.cpp	2009-02-02 13:59:23 UTC (rev 1538)
+++ trunk/Utils/Url.cpp	2009-02-03 13:14:49 UTC (rev 1539)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005-2008 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -16,12 +16,16 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include <stdio.h>
+#include <iostream>
+#include <glibmm/miscutils.h>
+
 #include "StringManip.h"
 #include "Url.h"
 
-#include <stdio.h>
-
 using std::string;
+using std::cout;
+using std::endl;
 
 static const int g_rfc2396Encoded[] = {
 	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 0x00 - 0x0f */
@@ -444,6 +448,70 @@
 	return unescapedUrl;
 }
 
+/// Resolves a path.
+string Url::resolvePath(const string &currentDir, const string &location)
+{
+	string currentLocation(currentDir);
+	string::size_type prevSlashPos = 0, slashPos = location.find('/');
+
+	if (currentDir.empty() == true)
+	{
+		return "";
+	}
+
+	while (slashPos != string::npos)
+	{
+		string path(location.substr(prevSlashPos, slashPos - prevSlashPos));
+
+		if (path == "..")
+		{
+			string upDir(Glib::path_get_dirname(currentLocation));
+			currentLocation = upDir;
+		}
+		else if (path != ".")
+		{
+			currentLocation += "/";
+			currentLocation += path;
+		}
+#ifdef DEBUG
+		cout << "Url::resolvePath: partially resolved to " << currentLocation << endl;
+#endif
+
+		if (slashPos + 1 >= location.length())
+		{
+			// Nothing behind
+			prevSlashPos = string::npos;
+			break;
+		}
+
+		// Next
+		prevSlashPos = slashPos + 1;
+		slashPos = location.find('/', prevSlashPos);
+	}
+
+	// Remainder
+	if (prevSlashPos != string::npos)
+	{
+		string path(location.substr(prevSlashPos));
+
+		if (path == "..")
+		{
+			string upDir(Glib::path_get_dirname(currentLocation));
+			currentLocation = upDir;
+		}
+		else if (path != ".")
+		{
+			currentLocation += "/";
+			currentLocation += path;
+		}
+	}
+#ifdef DEBUG
+	cout << "Url::resolvePath: resolved to " << currentLocation << endl;
+#endif
+
+	return currentLocation;
+}
+
 string Url::getProtocol(void) const
 {
 	return m_protocol;

Modified: trunk/Utils/Url.h
===================================================================
--- trunk/Utils/Url.h	2009-02-02 13:59:23 UTC (rev 1538)
+++ trunk/Utils/Url.h	2009-02-03 13:14:49 UTC (rev 1539)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005-2008 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -23,7 +23,7 @@
 
 #include "Visibility.h"
 
-/// This dissects and manipulates URLs returned by search engines.
+/// This dissects and manipulates URLs.
 class PINOT_EXPORT Url
 {
 	public:
@@ -48,6 +48,9 @@
 		/// Unescapes an URL.
 		static std::string unescapeUrl(const std::string &escapedUrl);
 
+		/// Resolves a path.
+		static std::string resolvePath(const std::string &currentDir, const std::string &location);
+
 		/// Returns the protocol, eg "file".
 		std::string getProtocol(void) const;
 



From fabricecolin at mail.berlios.de  Tue Feb  3 14:25:15 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Tue, 3 Feb 2009 14:25:15 +0100
Subject: [Pinot-svn] r1540 - trunk/Core
Message-ID: <200902031325.n13DPFHO004380@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-03 14:25:11 +0100 (Tue, 03 Feb 2009)
New Revision: 1540

Modified:
   trunk/Core/pinot-index.cpp
Log:
Urls passed as parameters may exclude "file://", be relative paths.
Support for gettext().


Modified: trunk/Core/pinot-index.cpp
===================================================================
--- trunk/Core/pinot-index.cpp	2009-02-03 13:14:49 UTC (rev 1539)
+++ trunk/Core/pinot-index.cpp	2009-02-03 13:25:11 UTC (rev 1540)
@@ -22,6 +22,7 @@
 #include <iostream>
 #include <string>
 #include <fstream>
+#include <glibmm/miscutils.h>
 
 #include "config.h"
 #include "NLS.h"
@@ -75,7 +76,7 @@
 	}
 	ModuleFactory::unloadModules();
 	cout << "\n\nExamples:\n"
-		<< "pinot-index --check --showinfo --backend xapian --db ~/.pinot/daemon file:///home/fabrice/Documents/Bozo.txt\n\n"
+		<< "pinot-index --check --showinfo --backend xapian --db ~/.pinot/daemon ../Bozo.txt\n\n"
 		<< "pinot-index --index --db \"My Web Pages\" http://pinot.berlios.de/\n\n"
 		<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
 }
@@ -144,6 +145,12 @@
 		optionChar = getopt_long(argc, argv, "b:cd:hisv", g_longOptions, &longOptionIndex);
 	}
 
+#if defined(ENABLE_NLS)
+	bindtextdomain(GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
+	bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
+	textdomain(GETTEXT_PACKAGE);
+#endif //ENABLE_NLS
+
 	if (argc == 1)
 	{
 		printHelp();
@@ -238,6 +245,45 @@
 	{
 		string urlParam(argv[optind]);
 
+		// Is this a relative path ?
+		if (Glib::path_is_absolute(urlParam) == false)
+		{
+			char *pCurrentDir = (char *)malloc(sizeof(char) * PATH_MAX);
+
+			if (pCurrentDir != NULL)
+			{
+				if (getcwd(pCurrentDir, PATH_MAX) != NULL)
+				{
+					urlParam = Url::resolvePath(pCurrentDir, argv[optind]);
+#ifdef DEBUG
+					cout << "URL resolved to " << urlParam << endl;
+#endif
+				}
+
+				free(pCurrentDir);
+			}
+		}
+
+		Url thisUrl(urlParam);
+
+		// Rewrite the URL, dropping user name and password which we don't support
+		urlParam = thisUrl.getProtocol();
+		urlParam += "://";
+		if (thisUrl.isLocal() == false)
+		{
+			urlParam += thisUrl.getHost();
+			urlParam += "/";
+		}
+		urlParam += thisUrl.getLocation();
+		if (thisUrl.getFile().empty() == false)
+		{
+			urlParam += "/";
+			urlParam += thisUrl.getFile();
+		}
+#ifdef DEBUG
+		cout << "URL rewritten to " << urlParam << endl;
+#endif
+
 		if (checkDocument == true)
 		{
 			if (pIndex->isGood() == true)
@@ -252,8 +298,6 @@
 		}
 		if (indexDocument == true)
 		{
-			Url thisUrl(urlParam);
-
 			// Which Downloader ?
 			DownloaderInterface *pDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
 			if (pDownloader == NULL)



From fabricecolin at mail.berlios.de  Tue Feb  3 14:26:02 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Tue, 3 Feb 2009 14:26:02 +0100
Subject: [Pinot-svn] r1541 - trunk/Core
Message-ID: <200902031326.n13DQ2Fc004521@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-03 14:25:58 +0100 (Tue, 03 Feb 2009)
New Revision: 1541

Modified:
   trunk/Core/pinot-search.cpp
Log:
Support for gettext().


Modified: trunk/Core/pinot-search.cpp
===================================================================
--- trunk/Core/pinot-search.cpp	2009-02-03 13:25:11 UTC (rev 1540)
+++ trunk/Core/pinot-search.cpp	2009-02-03 13:25:58 UTC (rev 1541)
@@ -108,7 +108,7 @@
 	}
 	cout << "\n\nExamples:\n"
 		<< "pinot-search opensearch " << PREFIX << "/share/pinot/engines/KrustyDescription.xml \"clowns\"\n\n"
-		<< "pinot-search --max 20 sherlock --seteditable \"Bozo App ID:1234567890\" " << PREFIX << "/share/pinot/engines/Bozo.src \"clowns\"\n\n"
+		<< "pinot-search --max 20 sherlock " << PREFIX << "/share/pinot/engines/Bozo.src \"clowns\"\n\n"
 		<< "pinot-search googleapi mygoogleapikey \"clowns\"\n\n"
 		<< "pinot-search xapian ~/.pinot/index \"label:Clowns\"\n\n"
 		<< "pinot-search --stemming english xapian somehostname:12345 \"clowning\"\n\n"
@@ -192,6 +192,12 @@
 		optionChar = getopt_long(argc, argv, "c:dhlm:qrs:uvx:", g_longOptions, &longOptionIndex);
 	}
 
+#if defined(ENABLE_NLS)
+	bindtextdomain(GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
+	bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
+	textdomain(GETTEXT_PACKAGE);
+#endif //ENABLE_NLS
+
 	if (argc == 1)
 	{
 		printHelp();



From fabricecolin at mail.berlios.de  Wed Feb  4 12:36:41 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Wed, 4 Feb 2009 12:36:41 +0100
Subject: [Pinot-svn] r1542 - trunk/Core
Message-ID: <200902041136.n14BafvJ008891@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-04 12:36:33 +0100 (Wed, 04 Feb 2009)
New Revision: 1542

Modified:
   trunk/Core/ServerThreads.cpp
Log:
Use Url::resolvePath().


Modified: trunk/Core/ServerThreads.cpp
===================================================================
--- trunk/Core/ServerThreads.cpp	2009-02-03 13:25:58 UTC (rev 1541)
+++ trunk/Core/ServerThreads.cpp	2009-02-04 11:36:33 UTC (rev 1542)
@@ -381,56 +381,8 @@
 			else
 			{
 				string entryDir(path_get_dirname(realEntryName));
-				string::size_type prevSlashPos = 0, slashPos = linkLocation.find('/');
 
-				while (slashPos != string::npos)
-				{
-					string path(linkLocation.substr(prevSlashPos, slashPos - prevSlashPos));
-
-					if (path == "..")
-					{
-						string upDir(path_get_dirname(entryDir));
-						entryDir = upDir;
-					}
-					else if (path != ".")
-					{
-						entryDir += "/";
-						entryDir += path;
-					}
-#ifdef DEBUG
-					cout << "DirectoryScannerThread::scanEntry: symlink partially resolved to " << entryDir << endl;
-#endif
-
-					if (slashPos + 1 >= linkLocation.length())
-					{
-						// Nothing behind
-						prevSlashPos = string::npos;
-						break;
-					}
-
-					// Next
-					prevSlashPos = slashPos + 1;
-					slashPos = linkLocation.find('/', prevSlashPos);
-				}
-
-				// Remainder
-				if (prevSlashPos != string::npos)
-				{
-					string path(linkLocation.substr(prevSlashPos));
-
-					if (path == "..")
-					{
-						string upDir(path_get_dirname(entryDir));
-						entryDir = upDir;
-					}
-					else if (path != ".")
-					{
-						entryDir += "/";
-						entryDir += path;
-					}
-				}
-
-				entryNameReferree = entryDir;
+				entryNameReferree = Url::resolvePath(entryDir, linkLocation);
 			}
 
 			if (entryNameReferree[entryNameReferree.length() - 1] == '/')



From fabricecolin at mail.berlios.de  Thu Feb  5 14:17:01 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Thu, 5 Feb 2009 14:17:01 +0100
Subject: [Pinot-svn] r1543 - trunk/Core
Message-ID: <200902051317.n15DH1ZL013429@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-05 14:16:55 +0100 (Thu, 05 Feb 2009)
New Revision: 1543

Modified:
   trunk/Core/pinot-index.cpp
Log:
Resolve local URLs only.


Modified: trunk/Core/pinot-index.cpp
===================================================================
--- trunk/Core/pinot-index.cpp	2009-02-04 11:36:33 UTC (rev 1542)
+++ trunk/Core/pinot-index.cpp	2009-02-05 13:16:55 UTC (rev 1543)
@@ -244,9 +244,11 @@
 	while (optind < argc)
 	{
 		string urlParam(argv[optind]);
+		Url thisUrl(urlParam);
 
 		// Is this a relative path ?
-		if (Glib::path_is_absolute(urlParam) == false)
+		if ((thisUrl.isLocal() == true) &&
+			(Glib::path_is_absolute(urlParam) == false))
 		{
 			char *pCurrentDir = (char *)malloc(sizeof(char) * PATH_MAX);
 
@@ -264,7 +266,7 @@
 			}
 		}
 
-		Url thisUrl(urlParam);
+		thisUrl = urlParam;
 
 		// Rewrite the URL, dropping user name and password which we don't support
 		urlParam = thisUrl.getProtocol();



From fabricecolin at mail.berlios.de  Fri Feb  6 15:43:31 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Fri, 6 Feb 2009 15:43:31 +0100
Subject: [Pinot-svn] r1544 - trunk/Core
Message-ID: <200902061443.n16EhVlB001927@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-06 15:43:22 +0100 (Fri, 06 Feb 2009)
New Revision: 1544

Modified:
   trunk/Core/ServerThreads.cpp
   trunk/Core/ServerThreads.h
   trunk/Core/WorkerThreads.cpp
   trunk/Core/WorkerThreads.h
Log:
Moved crawl history and monitoring out of DirectoryScanner so that it's usable
outside of the daemon, and moved the class to WorkerThreads.
Crawler inherits from DirectoryScanner and handles crawl history and monitoring.


Modified: trunk/Core/ServerThreads.cpp
===================================================================
--- trunk/Core/ServerThreads.cpp	2009-02-05 13:16:55 UTC (rev 1543)
+++ trunk/Core/ServerThreads.cpp	2009-02-06 14:43:22 UTC (rev 1544)
@@ -16,9 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#include <sys/types.h>
-#include <dirent.h>
-#include <sys/stat.h>
 #include <unistd.h>
 #include <stdlib.h>
 #include <fcntl.h>
@@ -31,7 +28,6 @@
 #include <fstream>
 #include <sstream>
 #include <glibmm/miscutils.h>
-#include <glibmm/convert.h>
 
 #include "config.h"
 #include "NLS.h"
@@ -39,7 +35,6 @@
 #include "TimeConverter.h"
 #include "Timer.h"
 #include "Url.h"
-#include "CrawlHistory.h"
 #include "MetaDataBackup.h"
 #ifdef HAVE_DBUS
 #include "DBusIndex.h"
@@ -120,33 +115,28 @@
 	return readFile;
 }
 
-DirectoryScannerThread::DirectoryScannerThread(const string &dirName, bool isSource,
-	bool fullScan, bool isReindex,
-	MonitorInterface *pMonitor, MonitorHandler *pHandler,
-	unsigned int maxLevel, bool inlineIndexing, bool followSymLinks) :
-	IndexingThread(),
-	m_dirName(dirName),
+CrawlerThread::CrawlerThread(const string &dirName,
+	bool isSource, bool fullScan, bool isReindex,
+	MonitorInterface *pMonitor, MonitorHandler *pHandler) :
+	DirectoryScannerThread(dirName,
+		PinotSettings::getInstance().m_daemonIndexLocation,
+		0, false, true),
 	m_fullScan(fullScan),
 	m_isReindex(isReindex),
+	m_sourceId(0),
 	m_pMonitor(pMonitor),
 	m_pHandler(pHandler),
-	m_sourceId(0),
-	m_currentLevel(0),
-	m_maxLevel(maxLevel),
-	m_inlineIndexing(inlineIndexing),
-	m_followSymLinks(followSymLinks)
+	m_crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName())
 {
 	if (m_dirName.empty() == false)
 	{
-		CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-
 		if (isSource == true)
 		{
 			// Does this source exist ?
-			if (crawlHistory.hasSource("file://" + m_dirName, m_sourceId) == false)
+			if (m_crawlHistory.hasSource("file://" + m_dirName, m_sourceId) == false)
 			{
 				// Create it
-				m_sourceId = crawlHistory.insertSource("file://" + m_dirName);
+				m_sourceId = m_crawlHistory.insertSource("file://" + m_dirName);
 			}
 		}
 		else
@@ -174,97 +164,31 @@
 	}
 }
 
-DirectoryScannerThread::~DirectoryScannerThread()
+CrawlerThread::~CrawlerThread()
 {
 }
 
-string DirectoryScannerThread::getType(void) const
+string CrawlerThread::getType(void) const
 {
-	return "DirectoryScannerThread";
+	return "CrawlerThread";
 }
 
-string DirectoryScannerThread::getDirectory(void) const
+void CrawlerThread::cacheUpdate(const string &location, time_t itemDate)
 {
-	return m_dirName;
-}
-
-void DirectoryScannerThread::stop(void)
-{
-	// Disconnect the signal
-	sigc::signal2<void, DocumentInfo, bool>::slot_list_type slotsList = m_signalFileFound.slots();
-	sigc::signal2<void, DocumentInfo, bool>::slot_list_type::iterator slotIter = slotsList.begin();
-	if (slotIter != slotsList.end())
+	if (m_fullScan == false)
 	{
-		if (slotIter->empty() == false)
-		{
-			slotIter->block();
-			slotIter->disconnect();
-		}
+		return;
 	}
-	WorkerThread::stop();
-}
 
-sigc::signal2<void, DocumentInfo, bool>& DirectoryScannerThread::getFileFoundSignal(void)
-{
-	return m_signalFileFound;
-}
-
-void DirectoryScannerThread::cacheUpdate(const string &location, time_t mTime,
-	CrawlHistory &crawlHistory)
-{
-	m_updateCache[location] = mTime;
-
+	m_updateCache[location] = itemDate;
 	if (m_updateCache.size() > 500)
 	{
-		flushUpdates(crawlHistory);
+		flushUpdates();
 	}
 }
 
-void DirectoryScannerThread::flushUpdates(CrawlHistory &crawlHistory)
+bool CrawlerThread::isIndexable(const string &entryName) const
 {
-#ifdef DEBUG
-	cout << "DirectoryScannerThread::flushUpdates: flushing updates" << endl;
-#endif
-
-	// Update these records
-	crawlHistory.updateItems(m_updateCache, CrawlHistory::CRAWLED);
-	m_updateCache.clear();
-
-#ifdef DEBUG
-	cout << "DirectoryScannerThread::flushUpdates: flushed updates" << endl;
-#endif
-}
-
-void DirectoryScannerThread::foundFile(const DocumentInfo &docInfo)
-{
-	if ((docInfo.getLocation().empty() == true) ||
-		(m_done == true))
-	{
-		return;
-	}
-
-	if (m_inlineIndexing == true)
-	{
-		// Reset base class members
-		m_docInfo = docInfo;
-		m_docId = 0;
-		m_indexLocation = PinotSettings::getInstance().m_daemonIndexLocation;
-		m_update = false;
-
-		IndexingThread::doWork();
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::foundFile: indexed " << docInfo.getLocation() << " to " << m_docId << endl;
-#endif
-	}
-	else
-	{
-		// Delegate indexing
-		m_signalFileFound(docInfo, false);
-	}
-}
-
-bool DirectoryScannerThread::isIndexable(const string &entryName) const
-{
 	string entryDir(path_get_dirname(entryName) + "/");
 
 	// Is this under one of the locations configured for indexing ?
@@ -278,7 +202,7 @@
 		{
 			// Yes, it is
 #ifdef DEBUG
-			cout << "DirectoryScannerThread::isIndexable: under " << locationDir << endl;
+			cout << "CrawlerThread::isIndexable: under " << locationDir << endl;
 #endif
 			return true;
 		}
@@ -287,334 +211,78 @@
 	return false;
 }
 
-bool DirectoryScannerThread::scanEntry(const string &entryName, CrawlHistory &crawlHistory,
-	bool statLinks)
+bool CrawlerThread::wasCrawled(const string &location, time_t &itemDate)
 {
-	string location("file://" + entryName);
-	DocumentInfo docInfo("", location, "", "");
 	CrawlHistory::CrawlStatus itemStatus = CrawlHistory::UNKNOWN;
-	time_t itemDate = time(NULL);
-	struct stat fileStat;
-	int entryStatus = 0;
-	bool scanSuccess = true, reportFile = false, itemExists = false;
 
-	if (entryName.empty() == true)
-	{
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::scanEntry: no name" << endl;
-#endif
-		return false;
-	}
+	return m_crawlHistory.hasItem(location, itemStatus, itemDate);
+}
 
-	// Skip . .. and dotfiles
-	Url urlObj(location);
-	if (urlObj.getFile()[0] == '.')
-	{
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::scanEntry: skipped dotfile " << urlObj.getFile() << endl;
-#endif
-		return false;
-	}
-#ifdef DEBUG
-	cout << "DirectoryScannerThread::scanEntry: checking " << entryName << endl;
-#endif
-
-	// Stat links, or the stuff it refers to ?
-	if (statLinks == true)
-	{
-		entryStatus = lstat(entryName.c_str(), &fileStat);
-	}
-	else
-	{
-		entryStatus = stat(entryName.c_str(), &fileStat);
-	}
-
-	if (entryStatus == -1)
-	{
-		entryStatus = errno;
-		scanSuccess = false;
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::scanEntry: stat failed with error " << entryStatus << endl;
-#endif
-	}
-	// Special processing applies if it's a symlink
-	else if (S_ISLNK(fileStat.st_mode))
-	{
-		string realEntryName(entryName);
-		string entryNameReferree;
-		bool isInIndexableLocation = false;
-
-		if (m_followSymLinks == false)
-		{
-#ifdef DEBUG
-			cout << "DirectoryScannerThread::scanEntry: skipped symlink " << entryName << endl;
-#endif
-			return false;
-		}
-
-		// Are we already following a symlink to a directory ?
-		if (m_currentLinks.empty() == false)
-		{
-			string linkToDir(m_currentLinks.top() + "/");
-
-			// Yes, we are
-			if ((entryName.length() > linkToDir.length()) &&
-				(entryName.substr(0, linkToDir.length()) == linkToDir))
-			{
-				// ...and this entry is below it
-				realEntryName.replace(0, linkToDir.length() - 1, m_currentLinkReferrees.top());
-#ifdef DEBUG
-				cout << "DirectoryScannerThread::scanEntry: really at " << realEntryName << endl;
-#endif
-				isInIndexableLocation = isIndexable(realEntryName);
-			}
-		}
-
-		char *pBuf = g_file_read_link(realEntryName.c_str(), NULL);
-		if (pBuf != NULL)
-		{
-			string linkLocation(filename_to_utf8(pBuf));
-			if (path_is_absolute(linkLocation) == true)
-			{
-				entryNameReferree = linkLocation;
-			}
-			else
-			{
-				string entryDir(path_get_dirname(realEntryName));
-
-				entryNameReferree = Url::resolvePath(entryDir, linkLocation);
-			}
-
-			if (entryNameReferree[entryNameReferree.length() - 1] == '/')
-			{
-				// Drop the terminating slash
-				entryNameReferree.resize(entryNameReferree.length() - 1);
-			}
-#ifdef DEBUG
-			cout << "DirectoryScannerThread::scanEntry: symlink resolved to " << entryNameReferree << endl;
-#endif
-
-			g_free(pBuf);
-		}
-
-		string referreeLocation("file://" + entryNameReferree);
-		CrawlHistory::CrawlStatus referreeItemStatus = CrawlHistory::UNKNOWN;
-		time_t referreeItemDate;
-
-		// Check whether this will be, or has already been crawled
-		// Referrees in indexable locations will be indexed later on
-		if ((isInIndexableLocation == false) &&
-			(isIndexable(entryNameReferree) == false) &&
-			(crawlHistory.hasItem(referreeLocation, referreeItemStatus, referreeItemDate) == false))
-		{
-			m_currentLinks.push(entryName);
-			m_currentLinkReferrees.push(entryNameReferree);
-
-			// Add a dummy entry for this referree
-			// It will ensure it's not indexed more than once and it shouldn't do any harm
-			crawlHistory.insertItem(referreeLocation, CrawlHistory::CRAWL_LINK, m_sourceId, itemDate);
-
-			// Do it again, this time by stat'ing what the link refers to
-			bool scannedReferree = scanEntry(entryName, crawlHistory, false);
-
-			m_currentLinks.pop();
-			m_currentLinkReferrees.pop();
-
-			return scannedReferree;
-		}
-		else
-		{
-			cout << "Skipping " << entryName << ": it links to " << entryNameReferree
-				<< " which will be crawled, or has already been crawled" << endl;
-
-			// This should ensure that only metadata is indexed
-			docInfo.setType("inode/symlink");
-			reportFile = true;
-		}
-	}
-
-	// Is this item in the database already ?
-	itemExists = crawlHistory.hasItem(location, itemStatus, itemDate);
+void CrawlerThread::recordCrawling(const string &location, bool itemExists, time_t &itemDate)
+{
 	if (itemExists == false)
 	{
 		// Record it
-		crawlHistory.insertItem(location, CrawlHistory::CRAWLING, m_sourceId, itemDate);
+		m_crawlHistory.insertItem(location, CrawlHistory::CRAWLING, m_sourceId, itemDate);
 	}
 	else if (m_fullScan == true)
 	{
 		// Change the status from TO_CRAWL to CRAWLING
-		crawlHistory.updateItem(location, CrawlHistory::CRAWLING, itemDate);
+		m_crawlHistory.updateItem(location, CrawlHistory::CRAWLING, itemDate);
 	}
+}
 
-	// If stat'ing didn't fail, see if it's a file or a directory
-	if ((entryStatus == 0) &&
-		(S_ISREG(fileStat.st_mode)))
+void CrawlerThread::recordError(const string &location, int errorCode)
+{
+	m_crawlHistory.updateItem(location, CrawlHistory::CRAWL_ERROR, time(NULL), errorCode);
+}
+
+void CrawlerThread::recordSymlink(const string &location, time_t itemDate)
+{
+	m_crawlHistory.insertItem(location, CrawlHistory::CRAWL_LINK, m_sourceId, itemDate);
+}
+
+bool CrawlerThread::monitorEntry(const string &entryName)
+{
+	if (m_pMonitor != NULL)
 	{
-		// Is this file blacklisted ?
-		// We have to check early so that if necessary the file's status stays at TO_CRAWL
-		// and it is removed from the index at the end of this crawl
-		if (PinotSettings::getInstance().isBlackListed(entryName) == false)
-		{
-			reportFile = true;
-		}
+		return m_pMonitor->addLocation(entryName, true);
 	}
-	else if ((entryStatus == 0) &&
-		(S_ISDIR(fileStat.st_mode)))
-	{
-		docInfo.setType("x-directory/normal");
 
-		// Can we scan this directory ?
-		if (((m_maxLevel == 0) ||
-			(m_currentLevel < m_maxLevel)) &&
-			(PinotSettings::getInstance().isBlackListed(entryName) == false))
-		{
-			++m_currentLevel;
+	return false;
+}
 
-			// Open the directory
-			DIR *pDir = opendir(entryName.c_str());
-			if (pDir != NULL)
-			{
-#ifdef DEBUG
-				cout << "DirectoryScannerThread::scanEntry: entering " << entryName << endl;
-#endif
-				if (m_pMonitor != NULL)
-				{
-					// Monitor first so that we don't miss events
-					// If monitoring is not possible, record the first case
-					if ((m_pMonitor->addLocation(entryName, true) == false) &&
-						(entryStatus != MONITORING_FAILED))
-					{
-						entryStatus = MONITORING_FAILED;
-					}
-				}
+void CrawlerThread::foundFile(const DocumentInfo &docInfo)
+{
+	DocumentInfo docInfoWithLabels(docInfo);
+	set<string> labels;
+	stringstream labelStream;
 
-				// Iterate through this directory's entries
-				struct dirent *pDirEntry = readdir(pDir);
-				while ((m_done == false) &&
-					(pDirEntry != NULL))
-				{
-					char *pEntryName = pDirEntry->d_name;
+	// Insert a label that identifies the source
+	labelStream << "X-SOURCE" << m_sourceId;
+	labels.insert(labelStream.str());
+	docInfoWithLabels.setLabels(labels);
 
-					// Skip . .. and dotfiles
-					if ((pEntryName != NULL) &&
-						(pEntryName[0] != '.'))
-					{
-						string subEntryName(entryName);
+	DirectoryScannerThread::foundFile(docInfoWithLabels);
+}
 
-						if (entryName[entryName.length() - 1] != '/')
-						{
-							subEntryName += "/";
-						}
-						subEntryName += pEntryName;
-
-						// Scan this entry
-						scanEntry(subEntryName, crawlHistory);
-					}
-
-					// Next entry
-					pDirEntry = readdir(pDir);
-				}
+void CrawlerThread::flushUpdates(void)
+{
 #ifdef DEBUG
-				cout << "DirectoryScannerThread::scanEntry: leaving " << entryName << endl;
+	cout << "CrawlerThread::flushUpdates: flushing updates" << endl;
 #endif
 
-				// Close the directory
-				closedir(pDir);
-				--m_currentLevel;
-				reportFile = true;
-			}
-			else
-			{
-				entryStatus = errno;
-				scanSuccess = false;
-#ifdef DEBUG
-				cout << "DirectoryScannerThread::scanEntry: opendir failed with error " << entryStatus << endl;
-#endif
-			}
-		}
-	}
-	// Is it some unknown type ?
-	else if ((entryStatus == 0) &&
-		(!S_ISLNK(fileStat.st_mode)))
-	{
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::scanEntry: unknown entry type" << endl;
-#endif
-		entryStatus = ENOENT;
-		scanSuccess = false;
-	}
+	// Update these records
+	m_crawlHistory.updateItems(m_updateCache, CrawlHistory::CRAWLED);
+	m_updateCache.clear();
 
-	// Was it modified after the last crawl ?
-	if ((itemExists == true) &&
-		(itemDate >= fileStat.st_mtime))
-	{
-		// No, it wasn't
 #ifdef DEBUG
-		cout << "DirectoryScannerThread::scanEntry: not reporting " << location
-			<< ", status " << itemStatus << endl;
+	cout << "CrawlerThread::flushUpdates: flushed updates" << endl;
 #endif
-		reportFile = false;
-	}
-
-	if (m_done == true)
-	{
-		// Don't record or report the file
-		reportFile = false;
-	}
-	// Did an error occur ?
-	else if (entryStatus != 0)
-	{
-		time_t timeNow = time(NULL);
-
-		// Record this error
-		crawlHistory.updateItem(location, CrawlHistory::CRAWL_ERROR, timeNow, entryStatus);
-
-		if (scanSuccess == false)
-		{
-			return scanSuccess;
-		}
-	}
-	// History of new or modified files, especially their timestamp, is always updated
-	// Others' are updated only if we are doing a full scan because
-	// the status has to be reset to CRAWLED, so that they are not unindexed
-	else if ((itemExists == false) ||
-		(reportFile == true) ||
-		(m_fullScan == true))
-	{
-#ifdef DEBUG
-		cout << "DirectoryScannerThread::scanEntry: updating " << entryName << endl;
-#endif
-		cacheUpdate(location, fileStat.st_mtime, crawlHistory);
-	}
-
-	// If a major error occured, this won't be true
-	if (reportFile == true)
-	{
-		set<string> labels;
-		stringstream labelStream;
-
-		if (docInfo.getType().empty() == true)
-		{
-			// Scan the file
-			docInfo.setType(MIMEScanner::scanFile(entryName));
-		}
-		docInfo.setTimestamp(TimeConverter::toTimestamp(fileStat.st_mtime));
-		docInfo.setSize(fileStat.st_size);
-
-		// Insert a label that identifies the source
-		labelStream << "X-SOURCE" << m_sourceId;
-		labels.insert(labelStream.str());
-		docInfo.setLabels(labels);
-
-		foundFile(docInfo);
-	}
-
-	return scanSuccess;
 }
 
-void DirectoryScannerThread::doWork(void)
+void CrawlerThread::doWork(void)
 {
-	CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
 	MetaDataBackup metaData(PinotSettings::getInstance().getHistoryDatabaseName());
 	Timer scanTimer;
 	set<string> urls;
@@ -627,31 +295,31 @@
 	scanTimer.start();
 
 	// Remove errors and links
-	crawlHistory.deleteItems(m_sourceId, CrawlHistory::CRAWL_ERROR);
-	crawlHistory.deleteItems(m_sourceId, CrawlHistory::CRAWL_LINK);
+	m_crawlHistory.deleteItems(m_sourceId, CrawlHistory::CRAWL_ERROR);
+	m_crawlHistory.deleteItems(m_sourceId, CrawlHistory::CRAWL_LINK);
 	// ...and entries the previous instance didn't have time to crawl
-	crawlHistory.deleteItems(m_sourceId, CrawlHistory::CRAWLING);
+	m_crawlHistory.deleteItems(m_sourceId, CrawlHistory::CRAWLING);
 
 	if (m_fullScan == true)
 	{
 		cout << "Doing a full scan on " << m_dirName << endl;
 
 		// Update this source's items status so that we can detect files that have been deleted
-		crawlHistory.updateItemsStatus(CrawlHistory::TO_CRAWL, m_sourceId);
+		m_crawlHistory.updateItemsStatus(CrawlHistory::TO_CRAWL, m_sourceId);
 	}
 
-	if (scanEntry(m_dirName, crawlHistory) == false)
+	if (scanEntry(m_dirName) == false)
 	{
 		m_errorNum = OPENDIR_FAILED;
 		m_errorParam = m_dirName;
 	}
-	flushUpdates(crawlHistory);
+	flushUpdates();
 	cout << "Scanned " << m_dirName << " in " << scanTimer.stop() << " ms" << endl;
 
 	if (m_done == true)
 	{
 #ifdef DEBUG
-		cout << "DirectoryScannerThread::doWork: leaving cleanup until next crawl" << endl;
+		cout << "CrawlerThread::doWork: leaving cleanup until next crawl" << endl;
 #endif
 		return;
 	}
@@ -663,7 +331,7 @@
 		// All files left with status TO_CRAWL were not found in this crawl
 		// Chances are they were removed after the last full scan
 		while ((m_pHandler != NULL) &&
-			(crawlHistory.getSourceItems(m_sourceId, CrawlHistory::TO_CRAWL, urls,
+			(m_crawlHistory.getSourceItems(m_sourceId, CrawlHistory::TO_CRAWL, urls,
 				currentOffset, currentOffset + 100) > 0))
 		{
 			for (set<string>::const_iterator urlIter = urls.begin();
@@ -673,7 +341,7 @@
 				m_pHandler->fileDeleted(urlIter->substr(7));
 
 				// Delete this item
-				crawlHistory.deleteItem(*urlIter);
+				m_crawlHistory.deleteItem(*urlIter);
 				metaData.deleteItem(DocumentInfo("", *urlIter, "", ""), DocumentInfo::SERIAL_ALL);
 			}
 

Modified: trunk/Core/ServerThreads.h
===================================================================
--- trunk/Core/ServerThreads.h	2009-02-05 13:16:55 UTC (rev 1543)
+++ trunk/Core/ServerThreads.h	2009-02-06 14:43:22 UTC (rev 1544)
@@ -33,51 +33,42 @@
 #include "DaemonState.h"
 #include "WorkerThreads.h"
 
-class DirectoryScannerThread : public IndexingThread
+class CrawlerThread : public DirectoryScannerThread
 {
 	public:
-		DirectoryScannerThread(const std::string &dirName, bool isSource,
-			bool fullScan, bool isReindex,
-			MonitorInterface *pMonitor, MonitorHandler *pHandler,
-			unsigned int maxLevel = 0, bool inlineIndexing = false,
-			bool followSymLinks = true);
-		virtual ~DirectoryScannerThread();
+		CrawlerThread(const std::string &dirName,
+			bool isSource, bool fullScan, bool isReindex,
+			MonitorInterface *pMonitor, MonitorHandler *pHandler);
+		virtual ~CrawlerThread();
 
 		virtual std::string getType(void) const;
 
-		virtual std::string getDirectory(void) const;
-
-		virtual void stop(void);
-
-		sigc::signal2<void, DocumentInfo, bool>& getFileFoundSignal(void);
-
 	protected:
-		std::string m_dirName;
 		bool m_fullScan;
 		bool m_isReindex;
+		unsigned int m_sourceId;
 		MonitorInterface *m_pMonitor;
 		MonitorHandler *m_pHandler;
-		unsigned int m_sourceId;
-		unsigned int m_currentLevel;
-		unsigned int m_maxLevel;
-		bool m_inlineIndexing;
-		bool m_followSymLinks;
-		sigc::signal2<void, DocumentInfo, bool> m_signalFileFound;
+		CrawlHistory m_crawlHistory;
 		std::map<std::string, time_t> m_updateCache;
 		std::stack<std::string> m_currentLinks;
 		std::stack<std::string> m_currentLinkReferrees;
 
-		void cacheUpdate(const std::string &location, time_t mTime, CrawlHistory &crawlHistory);
-		void flushUpdates(CrawlHistory &crawlHistory);
-		void foundFile(const DocumentInfo &docInfo);
-		bool isIndexable(const std::string &entryName) const;
-		bool scanEntry(const std::string &entryName, CrawlHistory &crawlHistory,
-			bool statLinks = true);
+		virtual void cacheUpdate(const std::string &location, time_t itemDate);
+		virtual bool isIndexable(const std::string &entryName) const;
+		virtual bool wasCrawled(const std::string &location, time_t &itemDate);
+		virtual void recordCrawling(const std::string &location, bool itemExists, time_t &itemDate);
+		virtual void recordError(const std::string &location, int errorCode);
+		virtual void recordSymlink(const std::string &location, time_t itemDate);
+		virtual bool monitorEntry(const std::string &entryName);
+		virtual void foundFile(const DocumentInfo &docInfo);
+
+		void flushUpdates(void);
 		virtual void doWork(void);
 
 	private:
-		DirectoryScannerThread(const DirectoryScannerThread &other);
-		DirectoryScannerThread &operator=(const DirectoryScannerThread &other);
+		CrawlerThread(const CrawlerThread &other);
+		CrawlerThread &operator=(const CrawlerThread &other);
 
 };
 

Modified: trunk/Core/WorkerThreads.cpp
===================================================================
--- trunk/Core/WorkerThreads.cpp	2009-02-05 13:16:55 UTC (rev 1543)
+++ trunk/Core/WorkerThreads.cpp	2009-02-06 14:43:22 UTC (rev 1544)
@@ -17,6 +17,7 @@
  */
 
 #include <sys/types.h>
+#include <dirent.h>
 #include <sys/stat.h>
 #include <unistd.h>
 #include <stdlib.h>
@@ -30,6 +31,7 @@
 #include <iostream>
 #include <fstream>
 #include <glibmm/miscutils.h>
+#include <glibmm/convert.h>
 #include <glibmm/exception.h>
 
 #include "config.h"
@@ -465,7 +467,16 @@
 		return status;
 	}
 
-	start_thread(new IndexingThread(docInfo, m_defaultIndexLocation));
+	if (urlObj.isLocal() == true)
+	{
+		// This handles both directories and files
+		start_thread(new DirectoryScannerThread(urlObj.getLocation() + "/" + urlObj.getFile(),
+			m_defaultIndexLocation, 0, true, true));
+	}
+	else
+	{
+		start_thread(new IndexingThread(docInfo, m_defaultIndexLocation));
+	}
 
 	return "";
 }
@@ -2258,3 +2269,448 @@
 	}
 }
 
+DirectoryScannerThread::DirectoryScannerThread(const string &dirName,
+	const string &indexLocation, unsigned int maxLevel,
+	bool inlineIndexing, bool followSymLinks) :
+	IndexingThread(),
+	m_dirName(dirName),
+	m_currentLevel(0),
+	m_maxLevel(maxLevel),
+	m_inlineIndexing(inlineIndexing),
+	m_followSymLinks(followSymLinks)
+{
+	m_indexLocation = indexLocation;
+}
+
+DirectoryScannerThread::~DirectoryScannerThread()
+{
+}
+
+string DirectoryScannerThread::getType(void) const
+{
+	if (m_inlineIndexing == true)
+	{
+		return IndexingThread::getType();
+	}
+
+	return "DirectoryScannerThread";
+}
+
+string DirectoryScannerThread::getDirectory(void) const
+{
+	return m_dirName;
+}
+
+void DirectoryScannerThread::stop(void)
+{
+	// Disconnect the signal
+	sigc::signal2<void, DocumentInfo, bool>::slot_list_type slotsList = m_signalFileFound.slots();
+	sigc::signal2<void, DocumentInfo, bool>::slot_list_type::iterator slotIter = slotsList.begin();
+	if (slotIter != slotsList.end())
+	{
+		if (slotIter->empty() == false)
+		{
+			slotIter->block();
+			slotIter->disconnect();
+		}
+	}
+	WorkerThread::stop();
+}
+
+sigc::signal2<void, DocumentInfo, bool>& DirectoryScannerThread::getFileFoundSignal(void)
+{
+	return m_signalFileFound;
+}
+
+void DirectoryScannerThread::cacheUpdate(const string &location, time_t itemDate)
+{
+	// Nothing to do by default
+}
+
+bool DirectoryScannerThread::isIndexable(const string &entryName) const
+{
+	string entryDir(path_get_dirname(entryName) + "/");
+
+	// Is this under the directory being scanned ?
+	if ((entryDir.length() >= m_dirName.length()) &&
+		(entryDir.substr(0, m_dirName.length()) == m_dirName))
+	{
+		// Yes, it is
+#ifdef DEBUG
+		cout << "DirectoryScannerThread::isIndexable: under " << m_dirName << endl;
+#endif
+		return true;
+	}
+
+	return false;
+}
+
+bool DirectoryScannerThread::wasCrawled(const string &location, time_t &itemDate)
+{
+	// This information is unknown
+	return false;
+}
+
+void DirectoryScannerThread::recordCrawling(const string &location, bool itemExists, time_t &itemDate)
+{
+	// Nothing to do by default
+}
+
+void DirectoryScannerThread::recordError(const string &location, int errorCode)
+{
+	// Nothing to do by default
+}
+
+void DirectoryScannerThread::recordSymlink(const string &location, time_t itemDate)
+{
+	// Nothing to do by default
+}
+
+bool DirectoryScannerThread::monitorEntry(const string &entryName)
+{
+	// Nothing to do by default
+	return true;
+}
+
+void DirectoryScannerThread::foundFile(const DocumentInfo &docInfo)
+{
+	if ((docInfo.getLocation().empty() == true) ||
+		(m_done == true))
+	{
+		return;
+	}
+
+	if (m_inlineIndexing == true)
+	{
+		// Reset base class members
+		m_docInfo = docInfo;
+		m_docId = 0;
+		m_update = false;
+
+		IndexingThread::doWork();
+#ifdef DEBUG
+		cout << "DirectoryScannerThread::foundFile: indexed " << docInfo.getLocation() << " to " << m_docId << endl;
+#endif
+	}
+	else
+	{
+		// Delegate indexing
+		m_signalFileFound(docInfo, false);
+	}
+}
+
+bool DirectoryScannerThread::scanEntry(const string &entryName,
+	bool statLinks)
+{
+	string location("file://" + entryName);
+	DocumentInfo docInfo("", location, "", "");
+	time_t itemDate = time(NULL);
+	struct stat fileStat;
+	int entryStatus = 0;
+	bool scanSuccess = true, reportFile = false, itemExists = false;
+
+	if (entryName.empty() == true)
+	{
+#ifdef DEBUG
+		cout << "DirectoryScannerThread::scanEntry: no name" << endl;
+#endif
+		return false;
+	}
+
+	// Skip . .. and dotfiles
+	Url urlObj(location);
+	if (urlObj.getFile()[0] == '.')
+	{
+#ifdef DEBUG
+		cout << "DirectoryScannerThread::scanEntry: skipped dotfile " << urlObj.getFile() << endl;
+#endif
+		return false;
+	}
+#ifdef DEBUG
+	cout << "DirectoryScannerThread::scanEntry: checking " << entryName << endl;
+#endif
+
+	// Stat links, or the stuff it refers to ?
+	if (statLinks == true)
+	{
+		entryStatus = lstat(entryName.c_str(), &fileStat);
+	}
+	else
+	{
+		entryStatus = stat(entryName.c_str(), &fileStat);
+	}
+
+	if (entryStatus == -1)
+	{
+		entryStatus = errno;
+		scanSuccess = false;
+#ifdef DEBUG
+		cout << "DirectoryScannerThread::scanEntry: stat failed with error " << entryStatus << endl;
+#endif
+	}
+	// Special processing applies if it's a symlink
+	else if (S_ISLNK(fileStat.st_mode))
+	{
+		string realEntryName(entryName);
+		string entryNameReferree;
+		bool isInIndexableLocation = false;
+
+		if (m_followSymLinks == false)
+		{
+#ifdef DEBUG
+			cout << "DirectoryScannerThread::scanEntry: skipped symlink " << entryName << endl;
+#endif
+			return false;
+		}
+
+		// Are we already following a symlink to a directory ?
+		if (m_currentLinks.empty() == false)
+		{
+			string linkToDir(m_currentLinks.top() + "/");
+
+			// Yes, we are
+			if ((entryName.length() > linkToDir.length()) &&
+				(entryName.substr(0, linkToDir.length()) == linkToDir))
+			{
+				// ...and this entry is below it
+				realEntryName.replace(0, linkToDir.length() - 1, m_currentLinkReferrees.top());
+#ifdef DEBUG
+				cout << "DirectoryScannerThread::scanEntry: really at " << realEntryName << endl;
+#endif
+				isInIndexableLocation = isIndexable(realEntryName);
+			}
+		}
+
+		char *pBuf = g_file_read_link(realEntryName.c_str(), NULL);
+		if (pBuf != NULL)
+		{
+			string linkLocation(filename_to_utf8(pBuf));
+			if (path_is_absolute(linkLocation) == true)
+			{
+				entryNameReferree = linkLocation;
+			}
+			else
+			{
+				string entryDir(path_get_dirname(realEntryName));
+
+				entryNameReferree = Url::resolvePath(entryDir, linkLocation);
+			}
+
+			if (entryNameReferree[entryNameReferree.length() - 1] == '/')
+			{
+				// Drop the terminating slash
+				entryNameReferree.resize(entryNameReferree.length() - 1);
+			}
+#ifdef DEBUG
+			cout << "DirectoryScannerThread::scanEntry: symlink resolved to " << entryNameReferree << endl;
+#endif
+
+			g_free(pBuf);
+		}
+
+		string referreeLocation("file://" + entryNameReferree);
+		time_t referreeItemDate;
+
+		// Check whether this will be, or has already been crawled
+		// Referrees in indexable locations will be indexed later on
+		if ((isInIndexableLocation == false) &&
+			(isIndexable(entryNameReferree) == false) &&
+			(wasCrawled(referreeLocation, referreeItemDate) == false))
+		{
+			m_currentLinks.push(entryName);
+			m_currentLinkReferrees.push(entryNameReferree);
+
+			// Add a dummy entry for this referree
+			// It will ensure it's not indexed more than once and it shouldn't do any harm
+			recordSymlink(referreeLocation, itemDate);
+
+			// Do it again, this time by stat'ing what the link refers to
+			bool scannedReferree = scanEntry(entryName, false);
+
+			m_currentLinks.pop();
+			m_currentLinkReferrees.pop();
+
+			return scannedReferree;
+		}
+		else
+		{
+			cout << "Skipping " << entryName << ": it links to " << entryNameReferree
+				<< " which will be crawled, or has already been crawled" << endl;
+
+			// This should ensure that only metadata is indexed
+			docInfo.setType("inode/symlink");
+			reportFile = true;
+		}
+	}
+
+	// Is this item in the database already ?
+	itemExists = wasCrawled(location, itemDate);
+	// Put it in if necessary
+	recordCrawling(location, itemExists, itemDate);
+
+	// If stat'ing didn't fail, see if it's a file or a directory
+	if ((entryStatus == 0) &&
+		(S_ISREG(fileStat.st_mode)))
+	{
+		// Is this file blacklisted ?
+		// We have to check early so that if necessary the file's status stays at TO_CRAWL
+		// and it is removed from the index at the end of this crawl
+		if (PinotSettings::getInstance().isBlackListed(entryName) == false)
+		{
+			reportFile = true;
+		}
+	}
+	else if ((entryStatus == 0) &&
+		(S_ISDIR(fileStat.st_mode)))
+	{
+		docInfo.setType("x-directory/normal");
+
+		// Can we scan this directory ?
+		if (((m_maxLevel == 0) ||
+			(m_currentLevel < m_maxLevel)) &&
+			(PinotSettings::getInstance().isBlackListed(entryName) == false))
+		{
+			++m_currentLevel;
+
+			// Open the directory
+			DIR *pDir = opendir(entryName.c_str());
+			if (pDir != NULL)
+			{
+#ifdef DEBUG
+				cout << "DirectoryScannerThread::scanEntry: entering " << entryName << endl;
+#endif
+				// Monitor first so that we don't miss events
+				// If monitoring is not possible, record the first case
+				if ((monitorEntry(entryName) == false) &&
+					(entryStatus != MONITORING_FAILED))
+				{
+					entryStatus = MONITORING_FAILED;
+				}
+
+				// Iterate through this directory's entries
+				struct dirent *pDirEntry = readdir(pDir);
+				while ((m_done == false) &&
+					(pDirEntry != NULL))
+				{
+					char *pEntryName = pDirEntry->d_name;
+
+					// Skip . .. and dotfiles
+					if ((pEntryName != NULL) &&
+						(pEntryName[0] != '.'))
+					{
+						string subEntryName(entryName);
+
+						if (entryName[entryName.length() - 1] != '/')
+						{
+							subEntryName += "/";
+						}
+						subEntryName += pEntryName;
+
+						// Scan this entry
+						scanEntry(subEntryName);
+					}
+
+					// Next entry
+					pDirEntry = readdir(pDir);
+				}
+#ifdef DEBUG
+				cout << "DirectoryScannerThread::scanEntry: leaving " << entryName << endl;
+#endif
+
+				// Close the directory
+				closedir(pDir);
+				--m_currentLevel;
+				reportFile = true;
+			}
+			else
+			{
+				entryStatus = errno;
+				scanSuccess = false;
+#ifdef DEBUG
+				cout << "DirectoryScannerThread::scanEntry: opendir failed with error " << entryStatus << endl;
+#endif
+			}
+		}
+	}
+	// Is it some unknown type ?
+	else if ((entryStatus == 0) &&
+		(!S_ISLNK(fileStat.st_mode)))
+	{
+#ifdef DEBUG
+		cout << "DirectoryScannerThread::scanEntry: unknown entry type" << endl;
+#endif
+		entryStatus = ENOENT;
+		scanSuccess = false;
+	}
+
+	// Was it modified after the last crawl ?
+	if ((itemExists == true) &&
+		(itemDate >= fileStat.st_mtime))
+	{
+		// No, it wasn't
+#ifdef DEBUG
+		cout << "DirectoryScannerThread::scanEntry: not reporting " << location << endl;
+#endif
+		reportFile = false;
+	}
+
+	if (m_done == true)
+	{
+		// Don't record or report the file
+		reportFile = false;
+	}
+	// Did an error occur ?
+	else if (entryStatus != 0)
+	{
+		// Record this error
+		recordError(location, entryStatus);
+
+		if (scanSuccess == false)
+		{
+			return scanSuccess;
+		}
+	}
+	// History of new or modified files, especially their timestamp, is always updated
+	// Others' are updated only if we are doing a full scan because
+	// the status has to be reset to CRAWLED, so that they are not unindexed
+	else if ((itemExists == false) ||
+		(reportFile == true))
+	{
+		cacheUpdate(location, fileStat.st_mtime);
+	}
+
+	// If a major error occured, this won't be true
+	if (reportFile == true)
+	{
+		if (docInfo.getType().empty() == true)
+		{
+			// Scan the file
+			docInfo.setType(MIMEScanner::scanFile(entryName));
+		}
+		docInfo.setTimestamp(TimeConverter::toTimestamp(fileStat.st_mtime));
+		docInfo.setSize(fileStat.st_size);
+
+		foundFile(docInfo);
+	}
+
+	return scanSuccess;
+}
+
+void DirectoryScannerThread::doWork(void)
+{
+	Timer scanTimer;
+
+	if (m_dirName.empty() == true)
+	{
+		return;
+	}
+	scanTimer.start();
+
+	if (scanEntry(m_dirName) == false)
+	{
+		m_errorNum = OPENDIR_FAILED;
+		m_errorParam = m_dirName;
+	}
+	cout << "Scanned " << m_dirName << " in " << scanTimer.stop() << " ms" << endl;
+}
+

Modified: trunk/Core/WorkerThreads.h
===================================================================
--- trunk/Core/WorkerThreads.h	2009-02-05 13:16:55 UTC (rev 1543)
+++ trunk/Core/WorkerThreads.h	2009-02-06 14:43:22 UTC (rev 1544)
@@ -25,6 +25,7 @@
 #include <queue>
 #include <set>
 #include <map>
+#include <stack>
 #include <pthread.h>
 #include <sigc++/sigc++.h>
 #include <glibmm/dispatcher.h>
@@ -510,4 +511,49 @@
 
 };
 
+class DirectoryScannerThread : public IndexingThread
+{
+	public:
+		DirectoryScannerThread(const std::string &dirName,
+			const std::string &indexLocation, unsigned int maxLevel = 0,
+			bool inlineIndexing = false, bool followSymLinks = true);
+		virtual ~DirectoryScannerThread();
+
+		virtual std::string getType(void) const;
+
+		virtual std::string getDirectory(void) const;
+
+		virtual void stop(void);
+
+		sigc::signal2<void, DocumentInfo, bool>& getFileFoundSignal(void);
+
+	protected:
+		std::string m_dirName;
+		unsigned int m_currentLevel;
+		unsigned int m_maxLevel;
+		bool m_inlineIndexing;
+		bool m_followSymLinks;
+		sigc::signal2<void, DocumentInfo, bool> m_signalFileFound;
+		std::stack<std::string> m_currentLinks;
+		std::stack<std::string> m_currentLinkReferrees;
+
+		virtual void cacheUpdate(const std::string &location, time_t itemDate);
+		virtual bool isIndexable(const std::string &entryName) const;
+		virtual bool wasCrawled(const std::string &location, time_t &itemDate);
+		virtual void recordCrawling(const std::string &location, bool itemExists, time_t &itemDate);
+		virtual void recordError(const std::string &location, int errorCode);
+		virtual void recordSymlink(const std::string &location, time_t itemDate);
+		virtual bool monitorEntry(const std::string &entryName);
+		virtual void foundFile(const DocumentInfo &docInfo);
+
+		bool scanEntry(const std::string &entryName,
+			bool statLinks = true);
+		virtual void doWork(void);
+
+	private:
+		DirectoryScannerThread(const DirectoryScannerThread &other);
+		DirectoryScannerThread &operator=(const DirectoryScannerThread &other);
+
+};
+
 #endif // _WORKERTHREADS_HH



From fabricecolin at mail.berlios.de  Fri Feb  6 15:44:02 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Fri, 6 Feb 2009 15:44:02 +0100
Subject: [Pinot-svn] r1545 - trunk/Core
Message-ID: <200902061444.n16Ei2tV002295@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-06 15:43:55 +0100 (Fri, 06 Feb 2009)
New Revision: 1545

Modified:
   trunk/Core/pinot-dbus-daemon.cpp
Log:
Minor includes fix.


Modified: trunk/Core/pinot-dbus-daemon.cpp
===================================================================
--- trunk/Core/pinot-dbus-daemon.cpp	2009-02-06 14:43:22 UTC (rev 1544)
+++ trunk/Core/pinot-dbus-daemon.cpp	2009-02-06 14:43:55 UTC (rev 1545)
@@ -28,7 +28,8 @@
 #include <iostream>
 #include <sstream>
 #include <fstream>
-#include <cstring>
+#include <string.h>
+#include <strings.h>
 #include <sigc++/sigc++.h>
 #include <glibmm.h>
 #include <glibmm/thread.h>



From fabricecolin at mail.berlios.de  Fri Feb  6 15:47:36 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Fri, 6 Feb 2009 15:47:36 +0100
Subject: [Pinot-svn] r1546 - trunk/Core
Message-ID: <200902061447.n16ElaAZ003752@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-06 15:47:31 +0100 (Fri, 06 Feb 2009)
New Revision: 1546

Modified:
   trunk/Core/pinot-index.cpp
Log:
IndexingState is a ThreadsManager subclass that enables this program to rely on
IndexingThread and DirectoryScannerThread. In practice, this means it can index
directories recursively at last.


Modified: trunk/Core/pinot-index.cpp
===================================================================
--- trunk/Core/pinot-index.cpp	2009-02-06 14:43:55 UTC (rev 1545)
+++ trunk/Core/pinot-index.cpp	2009-02-06 14:47:31 UTC (rev 1546)
@@ -19,10 +19,14 @@
 #include <getopt.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <strings.h>
 #include <iostream>
 #include <string>
 #include <fstream>
+#include <glibmm.h>
+#include <glibmm/thread.h>
 #include <glibmm/miscutils.h>
+#include <sigc++/sigc++.h>
 
 #include "config.h"
 #include "NLS.h"
@@ -33,7 +37,9 @@
 #include "DownloaderFactory.h"
 #include "FilterWrapper.h"
 #include "ModuleFactory.h"
+#include "ActionQueue.h"
 #include "PinotSettings.h"
+#include "WorkerThreads.h"
 
 using namespace std;
 
@@ -47,7 +53,70 @@
 	{"version", 0, 0, 'v'},
 	{0, 0, 0, 0}
 };
+static Glib::RefPtr<Glib::MainLoop> g_refMainLoop;
 
+class IndexingState : public ThreadsManager
+{
+	public:
+		IndexingState(const string &indexLocation) :
+			ThreadsManager(indexLocation, 1, 60),
+			m_docId(0)
+		{
+			m_onThreadEndSignal.connect(sigc::mem_fun(*this, &IndexingState::on_thread_end));
+		}
+
+		~IndexingState()
+		{
+		}
+
+		void on_thread_end(WorkerThread *pThread)
+		{
+			string indexedUrl;
+
+			if (pThread == NULL)
+			{
+				return;
+			}
+
+			string type(pThread->getType());
+			bool isStopped = pThread->isStopped();
+#ifdef DEBUG
+			cout << "IndexingState::on_thread_end: end of thread " << type << " " << pThread->getId() << endl;
+#endif
+
+			// What type of thread was it ?
+			if ((isStopped == false) &&
+				((type == "IndexingThread") || (type == "DirectoryScannerThread")))
+			{
+				IndexingThread *pIndexThread = dynamic_cast<IndexingThread *>(pThread);
+				if (pIndexThread == NULL)
+				{
+					delete pThread;
+					return;
+				}
+
+				// Get the document ID of the URL we have just indexed
+				m_docId = pIndexThread->getDocumentID();
+			}
+
+			// Delete the thread
+			delete pThread;
+
+			// Stop there
+			g_refMainLoop->quit();
+		}
+
+		unsigned int getDocumentID(void) const
+		{
+			return m_docId;
+		}
+
+	protected:
+		unsigned int m_docId;
+
+};
+static IndexingState *g_pState = NULL;
+
 static void printHelp(void)
 {
 	map<ModuleProperties, bool> engines;
@@ -91,12 +160,21 @@
 	MIMEScanner::shutdown();
 }
 
+static void quitAll(int sigNum)
+{
+	if (g_refMainLoop->is_running() == true)
+	{
+		cout << "Quitting..." << endl;
+
+		g_refMainLoop->quit();
+	}
+}
+
 int main(int argc, char **argv)
 {
 	string type, option;
 	string backendType, databaseName;
 	int longOptionIndex = 0;
-	unsigned int docId = 0;
 	bool checkDocument = false, indexDocument = false, showInfo = false, success = false;
 
 	// Look at the options
@@ -172,6 +250,18 @@
 		return EXIT_FAILURE;
 	}
 
+	// Initialize threads support before doing anything else
+	if (Glib::thread_supported() == false)
+	{
+		Glib::thread_init();
+	}
+
+	g_refMainLoop = Glib::MainLoop::create();
+	Glib::set_application_name("Pinot Indexer");
+
+	// This should make Xapian use Flint rather than Quartz
+	Glib::setenv("XAPIAN_PREFER_FLINT", "1");
+
 	// This will create the necessary directories on the first run
 	PinotSettings &settings = PinotSettings::getInstance();
 	string confDirectory(PinotSettings::getConfigurationDirectory());
@@ -208,13 +298,23 @@
 	// Load the settings
 	settings.load(PinotSettings::LOAD_ALL);
 
-	atexit(closeAll);
+	// Catch interrupts
+#ifdef HAVE_SIGACTION
+	struct sigaction newAction;
+	sigemptyset(&newAction.sa_mask);
+	newAction.sa_flags = 0;
+	newAction.sa_handler = quitAll;
+	sigaction(SIGINT, &newAction, NULL);
+	sigaction(SIGQUIT, &newAction, NULL);
+	sigaction(SIGTERM, &newAction, NULL);
+#else
+	signal(SIGINT, quitAll);
+#ifdef SIGQUIT
+	signal(SIGQUIT, quitAll);
+#endif
+	signal(SIGTERM, quitAll);
+#endif
 
-	if (backendType.empty() == true)
-	{
-		backendType = settings.m_defaultBackend;
-	}
-
 	// Is this a known index name ?
 	PinotSettings::IndexProperties indexProps = settings.getIndexPropertiesByName(databaseName);
 	if (indexProps.m_name.empty() == true)
@@ -223,6 +323,11 @@
 		indexProps.m_location = databaseName;
 	}
 
+	if (backendType.empty() == true)
+	{
+		backendType = settings.m_defaultBackend;
+	}
+
 	// Make sure the index is open in the correct mode
 	bool wasObsoleteFormat = false;
 	if (ModuleFactory::openOrCreateIndex(backendType, indexProps.m_location, wasObsoleteFormat, (indexDocument ? false : true)) == false)
@@ -232,6 +337,25 @@
 		return EXIT_FAILURE;
 	}
 
+	// Do the same for the history database
+	string historyDatabase(settings.getHistoryDatabaseName());
+	if ((historyDatabase.empty() == true) ||
+		(ActionQueue::create(historyDatabase) == false))
+	{
+		cerr << "Couldn't create history database " << historyDatabase << endl;
+		return EXIT_FAILURE;
+	}
+	else
+	{
+		ActionQueue actionQueue(historyDatabase, Glib::get_application_name());
+		time_t timeNow = time(NULL);
+
+		// Expire
+		actionQueue.expireItems(timeNow);
+	}
+
+	atexit(closeAll);
+
 	// Get a read-write index of the given type
 	IndexInterface *pIndex = ModuleFactory::getIndex(backendType, indexProps.m_location);
 	if (pIndex == NULL)
@@ -266,9 +390,8 @@
 			}
 		}
 
+		// Rewrite the URL, dropping user name and password which we don't support
 		thisUrl = urlParam;
-
-		// Rewrite the URL, dropping user name and password which we don't support
 		urlParam = thisUrl.getProtocol();
 		urlParam += "://";
 		if (thisUrl.isLocal() == false)
@@ -286,6 +409,9 @@
 		cout << "URL rewritten to " << urlParam << endl;
 #endif
 
+		DocumentInfo docInfo("", urlParam, MIMEScanner::scanUrl(thisUrl), "");
+		unsigned int docId = 0;
+
 		if (checkDocument == true)
 		{
 			if (pIndex->isGood() == true)
@@ -300,73 +426,27 @@
 		}
 		if (indexDocument == true)
 		{
-			// Which Downloader ?
-			DownloaderInterface *pDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
-			if (pDownloader == NULL)
+			if (g_pState == NULL)
 			{
-				cerr << "Couldn't obtain downloader for protocol " << thisUrl.getProtocol() << endl;
-
-				success = false;
-
-				// Next
-				++optind;
-				continue;
+				g_pState = new IndexingState(indexProps.m_location);
 			}
 
-			// Set up the proxy
-			if ((settings.m_proxyEnabled == true) &&
-				(settings.m_proxyAddress.empty() == false))
-			{
-				char portStr[64];
+			// Connect to threads' finished signal
+			g_pState->connect();
 
-				pDownloader->setSetting("proxyaddress", settings.m_proxyAddress);
-				snprintf(portStr, 64, "%u", settings.m_proxyPort);
-				pDownloader->setSetting("proxyport", portStr);
-				pDownloader->setSetting("proxytype", settings.m_proxyType);
-			}
+			g_pState->queue_index(docInfo);
 
-			DocumentInfo docInfo("", urlParam, MIMEScanner::scanUrl(thisUrl), "");
-			Document *pDoc = pDownloader->retrieveUrl(docInfo);
-			if (pDoc == NULL)
-			{
-				cerr << "Couldn't download " << urlParam << endl;
-			}
-			else
-			{
-				FilterWrapper wrapFilter(pIndex);
-				set<string> labels;
+			// Run the main loop
+			g_refMainLoop->run();
 
-				// Update an existing document or add to the index ?
-				docId = pIndex->hasDocument(urlParam);
-				if (docId > 0)
-				{
-					// Update the document
-					if (wrapFilter.updateDocument(*pDoc, docId) == true)
-					{
-						success = true;
-					}
-				}
-				else
-				{
-					// Index the document
-					success = wrapFilter.indexDocument(*pDoc, labels, docId);
-				}
+			// Stop everything
+			g_pState->disconnect();
 
-				if (success == true)
-				{
-					// Flush the index
-					pIndex->flush();
-				}
-
-				delete pDoc;
-			}
-
-			delete pDownloader;
+			docId = g_pState->getDocumentID();
 		}
 		if ((showInfo == true) &&
 			(docId > 0))
 		{
-			DocumentInfo docInfo;
 			set<string> labels;
 
 			cout << "Index version       : " << pIndex->getMetadata("version") << endl;
@@ -408,6 +488,10 @@
 		++optind;
 	}
 	delete pIndex;
+	if (g_pState == NULL)
+	{
+		delete g_pState;
+	}
 
 	// Did whatever operation we carried out succeed ?
 	if (success == true)



From fabricecolin at mail.berlios.de  Fri Feb  6 15:50:00 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Fri, 6 Feb 2009 15:50:00 +0100
Subject: [Pinot-svn] r1547 - trunk/Core
Message-ID: <200902061450.n16Eo0bw005007@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-06 15:49:54 +0100 (Fri, 06 Feb 2009)
New Revision: 1547

Modified:
   trunk/Core/DaemonState.cpp
Log:
Swapped DirectoryScanner for Crawler threads.


Modified: trunk/Core/DaemonState.cpp
===================================================================
--- trunk/Core/DaemonState.cpp	2009-02-06 14:47:31 UTC (rev 1546)
+++ trunk/Core/DaemonState.cpp	2009-02-06 14:49:54 UTC (rev 1547)
@@ -111,19 +111,19 @@
 	return availableMbSize;
 }
 
-// A function object to stop DirectoryScanner threads with for_each()
-struct StopScannerThreadFunc
+// A function object to stop Crawler threads with for_each()
+struct StopCrawlerThreadFunc
 {
 public:
 	void operator()(map<unsigned int, WorkerThread *>::value_type &p)
 	{
 		string type(p.second->getType());
 
-		if (type == "DirectoryScannerThread")
+		if (type == "CrawlerThread")
 		{
 			p.second->stop();
 #ifdef DEBUG
-			cout << "StopScannerThreadFunc: stopped thread " << p.second->getId() << endl;
+			cout << "StopCrawlerThreadFunc: stopped thread " << p.second->getId() << endl;
 #endif
 		}
 	}
@@ -421,7 +421,7 @@
 	string locationToCrawl(location.m_name);
 	bool doMonitoring = location.m_monitor;
 	bool isSource = location.m_isSource;
-	DirectoryScannerThread *pScannerThread = NULL;
+	CrawlerThread *pCrawlerThread = NULL;
 
 	// Can we go ahead and crawl ?
 	if ((is_flag_set(LOW_DISK_SPACE) == true) ||
@@ -442,17 +442,17 @@
 	{
 		// Monitoring is not necessary, but we still have to pass the handler
 		// so that we can act on documents that have been deleted
-		pScannerThread = new DirectoryScannerThread(locationToCrawl, isSource,
+		pCrawlerThread = new CrawlerThread(locationToCrawl, isSource,
 			m_fullScan, m_isReindex, NULL, m_pDiskHandler);
 	}
 	else
 	{
-		pScannerThread = new DirectoryScannerThread(locationToCrawl, isSource,
+		pCrawlerThread = new CrawlerThread(locationToCrawl, isSource,
 			m_fullScan, m_isReindex, m_pDiskMonitor, m_pDiskHandler);
 	}
-	pScannerThread->getFileFoundSignal().connect(sigc::mem_fun(*this, &DaemonState::on_message_filefound));
+	pCrawlerThread->getFileFoundSignal().connect(sigc::mem_fun(*this, &DaemonState::on_message_filefound));
 
-	if (start_thread(pScannerThread, true) == true)
+	if (start_thread(pCrawlerThread, true) == true)
 	{
 		++m_crawlers;
 		set_flag(CRAWLING);
@@ -582,8 +582,8 @@
 	{
 		if (m_threads.empty() == false)
 		{
-			// Stop all DirectoryScanner threads
-			for_each(m_threads.begin(), m_threads.end(), StopScannerThreadFunc());
+			// Stop all Crawler threads
+			for_each(m_threads.begin(), m_threads.end(), StopCrawlerThreadFunc());
 		}
 
 		unlock_threads();
@@ -606,17 +606,17 @@
 #endif
 
 	// What type of thread was it ?
-	if (type == "DirectoryScannerThread")
+	if (type == "CrawlerThread")
 	{
-		DirectoryScannerThread *pScannerThread = dynamic_cast<DirectoryScannerThread *>(pThread);
-		if (pScannerThread == NULL)
+		CrawlerThread *pCrawlerThread = dynamic_cast<CrawlerThread *>(pThread);
+		if (pCrawlerThread == NULL)
 		{
 			delete pThread;
 			return;
 		}
 		--m_crawlers;
 #ifdef DEBUG
-		cout << "DaemonState::on_thread_end: done crawling " << pScannerThread->getDirectory() << endl;
+		cout << "DaemonState::on_thread_end: done crawling " << pCrawlerThread->getDirectory() << endl;
 #endif
 
 		// Explicitely flush the index once a directory has been crawled



From fabricecolin at mail.berlios.de  Sat Feb  7 05:17:45 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sat, 7 Feb 2009 05:17:45 +0100
Subject: [Pinot-svn] r1548 - trunk/Utils
Message-ID: <200902070417.n174HjNW015311@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-07 05:17:39 +0100 (Sat, 07 Feb 2009)
New Revision: 1548

Modified:
   trunk/Utils/Url.cpp
   trunk/Utils/Url.h
Log:
Additional Url constructor for absolute and relative paths.


Modified: trunk/Utils/Url.cpp
===================================================================
--- trunk/Utils/Url.cpp	2009-02-06 14:49:54 UTC (rev 1547)
+++ trunk/Utils/Url.cpp	2009-02-07 04:17:39 UTC (rev 1548)
@@ -51,8 +51,40 @@
 	parse(url);
 }
 
-Url::~Url()
+Url::Url(const string &path, const string &parentPath)
 {
+	string absoluteUrl;
+
+	// Is this a relative path ?
+	if (Glib::path_is_absolute(path) == false)
+	{
+		if (parentPath.empty() == true)
+		{
+			char *pCurrentDir = (char *)malloc(sizeof(char) * PATH_MAX);
+
+			if (pCurrentDir != NULL)
+			{
+				if (getcwd(pCurrentDir, PATH_MAX) != NULL)
+				{
+					absoluteUrl = Url::resolvePath(pCurrentDir, path);
+				}
+				free(pCurrentDir);
+			}
+		}
+		else
+		{
+			absoluteUrl = Url::resolvePath(parentPath, path);
+		}
+	}
+
+	if (absoluteUrl.empty() == false)
+	{
+		parse(absoluteUrl);
+	}
+	else
+	{
+		parse(path);
+	}
 }
 
 Url::Url(const Url &other) :
@@ -66,6 +98,10 @@
 {
 }
 
+Url::~Url()
+{
+}
+
 Url& Url::operator=(const Url& other)
 {
 	if (this != &other)

Modified: trunk/Utils/Url.h
===================================================================
--- trunk/Utils/Url.h	2009-02-06 14:49:54 UTC (rev 1547)
+++ trunk/Utils/Url.h	2009-02-07 04:17:39 UTC (rev 1548)
@@ -28,6 +28,7 @@
 {
 	public:
 		Url(const std::string &url);
+		Url(const std::string &path, const std::string &parentPath);
 		Url(const Url &other);
 		virtual ~Url();
 



From fabricecolin at mail.berlios.de  Sat Feb  7 05:20:14 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sat, 7 Feb 2009 05:20:14 +0100
Subject: [Pinot-svn] r1549 - in trunk: Core IndexSearch
Message-ID: <200902070420.n174KELC015436@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-07 05:20:06 +0100 (Sat, 07 Feb 2009)
New Revision: 1549

Modified:
   trunk/Core/Makefile.am
   trunk/Core/pinot-index.cpp
   trunk/IndexSearch/pinot-label.cpp
Log:
Let Url deal with relative paths.


Modified: trunk/Core/Makefile.am
===================================================================
--- trunk/Core/Makefile.am	2009-02-07 04:17:39 UTC (rev 1548)
+++ trunk/Core/Makefile.am	2009-02-07 04:20:06 UTC (rev 1549)
@@ -14,7 +14,6 @@
 libCore_la_SOURCES = \
 	PinotSettings.cpp \
 	PinotUtils.cpp \
-	ServerThreads.cpp \
 	UniqueApplication.cpp \
 	WorkerThreads.cpp
 
@@ -46,11 +45,14 @@
 pinot_index_LDADD = \
 	-L$(top_builddir)/Utils \
 	-L$(top_builddir)/Tokenize \
+	-L$(top_builddir)/SQL \
+	-L$(top_builddir)/Monitor \
 	-L$(top_builddir)/Collect \
 	-L$(top_builddir)/IndexSearch \
-	-lCore -lIndexSearch -lCollect -lTokenize -lUtils -lBasicUtils \
-	@GLIBMM_LIBS@ @DBUS_LIBS@ \
-	@XML_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
+	-lCore -lIndexSearch -lMonitor -lCollect -lSQL \
+	-lTokenize -lUtils -lBasicUtils @LIBS@ \
+	@GLIBMM_LIBS@ @DBUS_LIBS@ @GTHREAD_LIBS@ @XML_LIBS@ \
+	@HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
 
 pinot_index_SOURCES = pinot-index.cpp
 
@@ -64,7 +66,8 @@
 	-L$(top_builddir)/Tokenize \
 	-L$(top_builddir)/Collect \
 	-L$(top_builddir)/IndexSearch \
-	-lCore -lIndexSearch -lCollect -lTokenize -lUtils -lBasicUtils \
+	-lCore -lIndexSearch -lCollect -lTokenize \
+	-lUtils -lBasicUtils @LIBS@ \
 	@GLIBMM_LIBS@ @DBUS_LIBS@ \
 	@XML_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
 
@@ -91,6 +94,7 @@
 pinot_dbus_daemon_SOURCES = \
 	DaemonState.cpp \
 	OnDiskHandler.cpp \
+	ServerThreads.cpp \
 	pinot-dbus-daemon.cpp
 
 pinot_dbus_daemon_DEPENDENCIES = libCore.la

Modified: trunk/Core/pinot-index.cpp
===================================================================
--- trunk/Core/pinot-index.cpp	2009-02-07 04:17:39 UTC (rev 1548)
+++ trunk/Core/pinot-index.cpp	2009-02-07 04:20:06 UTC (rev 1549)
@@ -368,30 +368,9 @@
 	while (optind < argc)
 	{
 		string urlParam(argv[optind]);
-		Url thisUrl(urlParam);
+		Url thisUrl(urlParam, "");
 
-		// Is this a relative path ?
-		if ((thisUrl.isLocal() == true) &&
-			(Glib::path_is_absolute(urlParam) == false))
-		{
-			char *pCurrentDir = (char *)malloc(sizeof(char) * PATH_MAX);
-
-			if (pCurrentDir != NULL)
-			{
-				if (getcwd(pCurrentDir, PATH_MAX) != NULL)
-				{
-					urlParam = Url::resolvePath(pCurrentDir, argv[optind]);
-#ifdef DEBUG
-					cout << "URL resolved to " << urlParam << endl;
-#endif
-				}
-
-				free(pCurrentDir);
-			}
-		}
-
 		// Rewrite the URL, dropping user name and password which we don't support
-		thisUrl = urlParam;
 		urlParam = thisUrl.getProtocol();
 		urlParam += "://";
 		if (thisUrl.isLocal() == false)

Modified: trunk/IndexSearch/pinot-label.cpp
===================================================================
--- trunk/IndexSearch/pinot-label.cpp	2009-02-07 04:17:39 UTC (rev 1548)
+++ trunk/IndexSearch/pinot-label.cpp	2009-02-07 04:20:06 UTC (rev 1549)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2007 Fabrice Colin
+ *  Copyright 2007-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -17,10 +17,8 @@
  */
  
 #include <getopt.h>
-#include <sys/types.h>
-#include <pwd.h>
+#include <stdlib.h>
 #include <iostream>
-#include <cstdlib>
 #include <string>
 #include <set>
 
@@ -62,27 +60,6 @@
 	cout << endl;
 }
 
-static string getHomeDirectory(void)
-{
-	struct passwd *pPasswd = getpwuid(geteuid());
-
-	if ((pPasswd != NULL) &&
-		(pPasswd->pw_dir != NULL))
-	{
-		return pPasswd->pw_dir;
-	}
-	else
-	{
-		char *homeDir = getenv("HOME");
-		if (homeDir != NULL)
-		{
-			return homeDir;
-		}
-	}
-
-	return "~";
-}
-
 static void printHelp(void)
 {
 	// Help
@@ -190,11 +167,25 @@
 	while (optind < argc)
 	{
 		string fileParam(argv[optind]);
+		Url thisUrl(fileParam, "");
 
+		// Rewrite it as a local URL
+		string urlParam(thisUrl.getProtocol());
+		urlParam += "://";
+		urlParam += thisUrl.getLocation();
+		if (thisUrl.getFile().empty() == false)
+		{
+			urlParam += "/";
+			urlParam += thisUrl.getFile();
+		}
+#ifdef DEBUG
+		cout << "URL rewritten to " << urlParam << endl;
+#endif
+
 		if ((getDocumentLabels == true) ||
 			(setDocumentLabels == true))
 		{
-			docId = index.hasDocument(string("file://") + fileParam);
+			docId = index.hasDocument(urlParam);
 			if (docId == 0)
 			{
 				cerr << fileParam << " is not indexed" << endl;



From fabricecolin at mail.berlios.de  Sat Feb  7 10:36:08 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sat, 7 Feb 2009 10:36:08 +0100
Subject: [Pinot-svn] r1550 - trunk/Utils
Message-ID: <200902070936.n179a8SK001894@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-07 10:36:04 +0100 (Sat, 07 Feb 2009)
New Revision: 1550

Modified:
   trunk/Utils/Url.cpp
Log:
Fix for previous check-in.


Modified: trunk/Utils/Url.cpp
===================================================================
--- trunk/Utils/Url.cpp	2009-02-07 04:20:06 UTC (rev 1549)
+++ trunk/Utils/Url.cpp	2009-02-07 09:36:04 UTC (rev 1550)
@@ -56,7 +56,9 @@
 	string absoluteUrl;
 
 	// Is this a relative path ?
-	if (Glib::path_is_absolute(path) == false)
+	string::size_type pos = path.find("://");
+	if ((pos == string::npos) &&
+		(Glib::path_is_absolute(path) == false))
 	{
 		if (parentPath.empty() == true)
 		{



From fabricecolin at mail.berlios.de  Sat Feb  7 10:37:45 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sat, 7 Feb 2009 10:37:45 +0100
Subject: [Pinot-svn] r1551 - trunk/Core
Message-ID: <200902070937.n179bjQI002090@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-07 10:37:40 +0100 (Sat, 07 Feb 2009)
New Revision: 1551

Modified:
   trunk/Core/pinot-index.1
   trunk/Core/pinot-index.cpp
Log:
Make it clear that -d/--db is mandatory.


Modified: trunk/Core/pinot-index.1
===================================================================
--- trunk/Core/pinot-index.1	2009-02-07 09:36:04 UTC (rev 1550)
+++ trunk/Core/pinot-index.1	2009-02-07 09:37:40 UTC (rev 1551)
@@ -4,7 +4,7 @@
 pinot-index \- Index documents from the command-line
 .SH SYNOPSIS
 .B pinot-index
-[\fIOPTIONS\fR] \fIURLS\fR
+[\fIOPTIONS\fR] \fI--db DATABASE URLS\fR
 .SH DESCRIPTION
 pinot\-index \- Index documents from the command\-line
 .SH OPTIONS
@@ -32,7 +32,7 @@
 .PP
 Supported back\-ends are : 'xapian'
 .SH EXAMPLES
-pinot\-index \fB\-\-check\fR \fB\-\-showinfo\fR \fB\-\-backend\fR xapian \fB\-\-db\fR ~/.pinot/daemon file:///home/fabrice/Documents/Bozo.txt
+pinot\-index \fB\-\-check\fR \fB\-\-showinfo\fR \fB\-\-backend\fR xapian \fB\-\-db\fR ~/.pinot/daemon ../Bozo.txt
 .PP
 pinot\-index \fB\-\-index\fR \fB\-\-db\fR "My Web Pages" http://pinot.berlios.de/
 .SH "REPORTING BUGS"

Modified: trunk/Core/pinot-index.cpp
===================================================================
--- trunk/Core/pinot-index.cpp	2009-02-07 09:36:04 UTC (rev 1550)
+++ trunk/Core/pinot-index.cpp	2009-02-07 09:37:40 UTC (rev 1551)
@@ -125,7 +125,7 @@
 	ModuleFactory::loadModules(string(LIBDIR) + string("/pinot/backends"));
 	ModuleFactory::getSupportedEngines(engines);
 	cout << "pinot-index - Index documents from the command-line\n\n"
-		<< "Usage: pinot-index [OPTIONS] URLS\n\n"
+		<< "Usage: pinot-index [OPTIONS] --db DATABASE URLS\n\n"
 		<< "Options:\n"
 		<< "  -b, --backend             name of back-end to use (default " << PinotSettings::getInstance().m_defaultBackend << ")\n"
 		<< "  -c, --check               check whether the given URL is in the index\n"



From fabricecolin at mail.berlios.de  Thu Feb 12 15:02:57 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Thu, 12 Feb 2009 15:02:57 +0100
Subject: [Pinot-svn] r1552 - in trunk: Core UI/GTK2/src po
Message-ID: <200902121402.n1CE2vEd018443@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-12 15:02:28 +0100 (Thu, 12 Feb 2009)
New Revision: 1552

Added:
   trunk/UI/GTK2/src/UIThreads.cc
   trunk/UI/GTK2/src/UIThreads.hh
Modified:
   trunk/Core/WorkerThreads.cpp
   trunk/Core/WorkerThreads.h
   trunk/Core/pinot-index.cpp
   trunk/UI/GTK2/src/Makefile.am
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/mainWindow.hh
   trunk/UI/GTK2/src/prefsWindow.hh
   trunk/UI/GTK2/src/statisticsDialog.hh
   trunk/po/POTFILES.in
Log:
ThreadsManager needs to know whether local files should be scanned with
DirectoryScanner or indexed right away with IndexingThread. This only makes
sense in pinot-index and the UI.
Moved UI-specific thread classes to UIThreads.


Modified: trunk/Core/WorkerThreads.cpp
===================================================================
--- trunk/Core/WorkerThreads.cpp	2009-02-07 09:37:40 UTC (rev 1551)
+++ trunk/Core/WorkerThreads.cpp	2009-02-12 14:02:28 UTC (rev 1552)
@@ -46,7 +46,6 @@
 #include "FilterUtils.h"
 #include "ActionQueue.h"
 #include "CrawlHistory.h"
-#include "QueryHistory.h"
 #include "DownloaderFactory.h"
 #include "FilterWrapper.h"
 #include "ModuleFactory.h"
@@ -272,11 +271,13 @@
 unsigned int ThreadsManager::m_nextThreadId = 1;
 
 ThreadsManager::ThreadsManager(const string &defaultIndexLocation,
-	unsigned int maxIndexThreads, unsigned int maxThreadsTime) :
+	unsigned int maxIndexThreads, unsigned int maxThreadsTime,
+	bool scanLocalFiles) :
 	m_defaultIndexLocation(defaultIndexLocation),
 	m_maxIndexThreads(maxIndexThreads),
 	m_backgroundThreadsCount(0),
 	m_foregroundThreadsMaxTime(maxThreadsTime),
+	m_scanLocalFiles(scanLocalFiles),
 	m_numCPUs(1),
 	m_stopIndexing(false)
 {
@@ -467,7 +468,8 @@
 		return status;
 	}
 
-	if (urlObj.isLocal() == true)
+	if ((m_scanLocalFiles == true) &&
+		(urlObj.isLocal() == true))
 	{
 		// This handles both directories and files
 		start_thread(new DirectoryScannerThread(urlObj.getLocation() + "/" + urlObj.getFile(),
@@ -796,93 +798,6 @@
 	return m_documentsCount;
 }
 
-IndexBrowserThread::IndexBrowserThread(const PinotSettings::IndexProperties &indexProps,
-	unsigned int maxDocsCount, unsigned int startDoc) :
-	ListerThread(indexProps, startDoc),
-	m_maxDocsCount(maxDocsCount)
-{
-}
-
-IndexBrowserThread::~IndexBrowserThread()
-{
-}
-
-void IndexBrowserThread::doWork(void)
-{
-	set<unsigned int> docIDList;
-	set<string> docLabels;
-	unsigned int numDocs = 0;
-
-	if (m_indexProps.m_location.empty() == true)
-	{
-		m_errorNum = UNKNOWN_INDEX;
-		m_errorParam = m_indexProps.m_name.c_str();
-		return;
-	}
-
-	// Get the index at that location
-	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexProps.m_location);
-	if ((pIndex == NULL) ||
-		(pIndex->isGood() == false))
-	{
-		m_errorNum = INDEX_ERROR;
-		m_errorParam = m_indexProps.m_location;
-		if (pIndex != NULL)
-		{
-			delete pIndex;
-		}
-		return;
-	}
-
-	m_documentsCount = pIndex->getDocumentsCount();
-	if (m_documentsCount == 0)
-	{
-#ifdef DEBUG
-		cout << "IndexBrowserThread::doWork: no documents" << endl;
-#endif
-		return;
-	}
-
-#ifdef DEBUG
-	cout << "IndexBrowserThread::doWork: " << m_maxDocsCount << " off " << m_documentsCount
-		<< " documents to browse, starting at position " << m_startDoc << endl;
-#endif
-	pIndex->listDocuments(docIDList, m_maxDocsCount, m_startDoc);
-
-	m_documentsList.clear();
-	m_documentsList.reserve(m_maxDocsCount);
-
-	for (set<unsigned int>::iterator iter = docIDList.begin(); iter != docIDList.end(); ++iter)
-	{
-		unsigned int docId = (*iter);
-
-		if (m_done == true)
-		{
-			break;
-		}
-
-		DocumentInfo docInfo;
-		if (pIndex->getDocumentInfo(docId, docInfo) == true)
-		{
-			string type(docInfo.getType());
-
-			if (type.empty() == true)
-			{
-				docInfo.setType("text/html");
-			}
-			docInfo.setIsIndexed(m_indexProps.m_id, docId);
-
-			// Insert that document
-			m_documentsList.push_back(docInfo);
-			++numDocs;
-		}
-#ifdef DEBUG
-		else cout << "IndexBrowserThread::doWork: couldn't retrieve document " << docId << endl;
-#endif
-	}
-	delete pIndex;
-}
-
 QueryingThread::QueryingThread(const PinotSettings::IndexProperties &indexProps,
 	const QueryProperties &queryProps, unsigned int startDoc, bool listingIndex) :
 	ListerThread(indexProps, startDoc),
@@ -1248,192 +1163,6 @@
 	delete pEngine;
 }
 
-EngineHistoryThread::EngineHistoryThread(const string &engineDisplayableName,
-	const QueryProperties &queryProps, unsigned int maxDocsCount) :
-	QueryingThread("", engineDisplayableName, "", queryProps, 0),
-	m_maxDocsCount(maxDocsCount)
-{
-	// Results are converted to UTF-8 prior to insertion in the history database
-	m_resultsCharset = "UTF-8";
-	m_isLive = false;
-}
-
-EngineHistoryThread::~EngineHistoryThread()
-{
-}
-
-void EngineHistoryThread::doWork(void)
-{
-	QueryHistory queryHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-
-	if (queryHistory.getItems(m_queryProps.getName(), m_engineDisplayableName,
-		m_maxDocsCount, m_documentsList) == false)
-	{
-		m_errorNum = HISTORY_FAILED;
-		m_errorParam = m_engineDisplayableName;
-	}
-	else if (m_documentsList.empty() == false)
-	{
-		// Get the first result's charset
-		queryHistory.getItemExtract(m_queryProps.getName(), m_engineDisplayableName,
-			m_documentsList.front().getLocation());
-	}
-}
-
-ExpandQueryThread::ExpandQueryThread(const QueryProperties &queryProps,
-	const set<string> &expandFromDocsSet) :
-	WorkerThread(),
-	m_queryProps(queryProps)
-{
-	copy(expandFromDocsSet.begin(), expandFromDocsSet.end(),
-		inserter(m_expandFromDocsSet, m_expandFromDocsSet.begin()));
-}
-
-ExpandQueryThread::~ExpandQueryThread()
-{
-}
-
-string ExpandQueryThread::getType(void) const
-{
-	return "ExpandQueryThread";
-}
-
-QueryProperties ExpandQueryThread::getQuery(void) const
-{
-	return m_queryProps;
-}
-
-const set<string> &ExpandQueryThread::getExpandTerms(void) const
-{
-	return m_expandTerms;
-}
-
-void ExpandQueryThread::doWork(void)
-{
-	// Get the SearchEngine
-	SearchEngineInterface *pEngine = ModuleFactory::getSearchEngine(PinotSettings::getInstance().m_defaultBackend, "MERGED");
-	if (pEngine == NULL)
-	{
-		m_errorNum = UNKNOWN_ENGINE;
-		m_errorParam = m_queryProps.getName();
-		return;
-	}
-
-	// Expand the query
-	pEngine->setExpandSet(m_expandFromDocsSet);
-
-	// Run the query
-	pEngine->setDefaultOperator(SearchEngineInterface::DEFAULT_OP_AND);
-	if (pEngine->runQuery(m_queryProps) == false)
-	{
-		m_errorNum = QUERY_FAILED;
-	}
-	else
-	{
-		// Copy the expand terms
-		const set<string> &expandTerms = pEngine->getExpandTerms();
-		copy(expandTerms.begin(), expandTerms.end(),
-			inserter(m_expandTerms, m_expandTerms.begin()));
-	}
-
-	delete pEngine;
-}
-
-LabelUpdateThread::LabelUpdateThread(const set<string> &labelsToAdd,
-	const set<string> &labelsToDelete) :
-	WorkerThread(),
-	m_resetLabels(false)
-{
-	copy(labelsToAdd.begin(), labelsToAdd.end(),
-		inserter(m_labelsToAdd, m_labelsToAdd.begin()));
-	copy(labelsToDelete.begin(), labelsToDelete.end(),
-		inserter(m_labelsToDelete, m_labelsToDelete.begin()));
-}
-
-LabelUpdateThread::LabelUpdateThread(const set<string> &labelsToAdd,
-	const set<unsigned int> &docsIds, const set<unsigned int> &daemonIds,
-	bool resetLabels) :
-	WorkerThread(),
-	m_resetLabels(resetLabels)
-{
-	copy(labelsToAdd.begin(), labelsToAdd.end(),
-		inserter(m_labelsToAdd, m_labelsToAdd.begin()));
-	copy(docsIds.begin(), docsIds.end(),
-		inserter(m_docsIds, m_docsIds.begin()));
-	copy(daemonIds.begin(), daemonIds.end(),
-		inserter(m_daemonIds, m_daemonIds.begin()));
-}
-
-LabelUpdateThread::~LabelUpdateThread()
-{
-}
-
-string LabelUpdateThread::getType(void) const
-{
-	return "LabelUpdateThread";
-}
-
-bool LabelUpdateThread::modifiedDocsIndex(void) const
-{
-	return !m_docsIds.empty();
-}
-
-bool LabelUpdateThread::modifiedDaemonIndex(void) const
-{
-	return !m_daemonIds.empty();
-}
-
-void LabelUpdateThread::doWork(void)
-{
-	bool actOnDocuments = false;
-
-	IndexInterface *pDocsIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_docsIndexLocation);
-	if (pDocsIndex == NULL)
-	{
-		m_errorNum = INDEX_ERROR;
-		m_errorParam = PinotSettings::getInstance().m_docsIndexLocation;
-		return;
-	}
-
-	IndexInterface *pDaemonIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
-	if (pDaemonIndex == NULL)
-	{
-		m_errorNum = INDEX_ERROR;
-		m_errorParam = PinotSettings::getInstance().m_daemonIndexLocation;
-		delete pDocsIndex;
-		return;
-	}
-
-	// Apply the labels to existing documents
-	if (m_docsIds.empty() == false)
-	{
-		pDocsIndex->setDocumentsLabels(m_docsIds, m_labelsToAdd, m_resetLabels);
-		actOnDocuments = true;
-	}
-	if (m_daemonIds.empty() == false)
-	{
-		pDaemonIndex->setDocumentsLabels(m_daemonIds, m_labelsToAdd, m_resetLabels);
-		actOnDocuments = true;
-	}
-
-	if (actOnDocuments == false)
-	{
-		// Add and/or delete labels on the daemon's index only
-		// The documents index is not required to have labels set
-		for (set<string>::iterator iter = m_labelsToAdd.begin(); iter != m_labelsToAdd.end(); ++iter)
-		{
-			pDaemonIndex->addLabel(*iter);
-		}
-		for (set<string>::iterator iter = m_labelsToDelete.begin(); iter != m_labelsToDelete.end(); ++iter)
-		{
-			pDaemonIndex->deleteLabel(*iter);
-		}
-	}
-
-	delete pDaemonIndex;
-	delete pDocsIndex;
-}
-
 DownloadingThread::DownloadingThread(const DocumentInfo &docInfo) :
 	WorkerThread(),
 	m_docInfo(docInfo),
@@ -1673,9 +1402,12 @@
 
 	if (m_pDoc != NULL)
 	{
+		Timer indexTimer;
 		string docType(m_pDoc->getType());
 		bool success = false;
 
+		indexTimer.start();
+
 		// The type may have been obtained when downloading
 		if (docType.empty() == false)
 		{
@@ -1815,6 +1547,8 @@
 				m_docInfo.setIsIndexed(
 					PinotSettings::getInstance().getIndexPropertiesByLocation(m_indexLocation).m_id,
 					m_docId);
+
+				cout << "Indexed " << m_docInfo.getLocation() << " in " << indexTimer.stop() << " ms" << endl;
 			}
 		}
 	}
@@ -1942,93 +1676,6 @@
 	delete pIndex;
 }
 
-UpdateDocumentThread::UpdateDocumentThread(const PinotSettings::IndexProperties &indexProps, unsigned int docId,
-	const DocumentInfo &docInfo, bool updateLabels) :
-	WorkerThread(),
-	m_indexProps(indexProps),
-	m_docId(docId),
-	m_docInfo(docInfo),
-	m_updateLabels(updateLabels)
-{
-}
-
-UpdateDocumentThread::~UpdateDocumentThread()
-{
-}
-
-string UpdateDocumentThread::getType(void) const
-{
-	return "UpdateDocumentThread";
-}
-
-PinotSettings::IndexProperties UpdateDocumentThread::getIndexProperties(void) const
-{
-	return m_indexProps;
-}
-
-unsigned int UpdateDocumentThread::getDocumentID(void) const
-{
-	return m_docId;
-}
-
-const DocumentInfo &UpdateDocumentThread::getDocumentInfo(void) const
-{
-	return m_docInfo;
-}
-
-void UpdateDocumentThread::doWork(void)
-{
-	if (m_done == false)
-	{
-		if (m_indexProps.m_location.empty() == true)
-		{
-			m_errorNum = UNKNOWN_INDEX;
-			m_errorParam = m_indexProps.m_name.c_str();
-			return;
-		}
-
-		// Get the index at that location
-		IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexProps.m_location);
-		if ((pIndex == NULL) ||
-			(pIndex->isGood() == false))
-		{
-			m_errorNum = INDEX_ERROR;
-			m_errorParam = m_indexProps.m_location;
-			if (pIndex != NULL)
-			{
-				delete pIndex;
-			}
-			return;
-		}
-
-		// Update the DocumentInfo
-		if (pIndex->updateDocumentInfo(m_docId, m_docInfo) == false)
-		{
-			m_errorNum = UPDATE_FAILED;
-			m_errorParam = m_docInfo.getLocation();
-			return;
-		}
-		// ...and the labels if necessary
-		if (m_updateLabels == true)
-		{
-			if (pIndex->setDocumentLabels(m_docId, m_docInfo.getLabels()) == false)
-			{
-				m_errorNum = UPDATE_FAILED;
-				m_errorParam = m_docInfo.getLocation();
-				return;
-			}
-		}
-
-		// Flush the index ?
-		if (m_immediateFlush == true)
-		{
-			pIndex->flush();
-		}
-
-		delete pIndex;
-	}
-}
-
 MonitorThread::MonitorThread(MonitorInterface *pMonitor, MonitorHandler *pHandler,
 	bool checkHistory) :
 	WorkerThread(),

Modified: trunk/Core/WorkerThreads.h
===================================================================
--- trunk/Core/WorkerThreads.h	2009-02-07 09:37:40 UTC (rev 1551)
+++ trunk/Core/WorkerThreads.h	2009-02-12 14:02:28 UTC (rev 1552)
@@ -111,7 +111,8 @@
 	public:
 		ThreadsManager(const std::string &defaultIndexLocation,
 			unsigned int maxIndexThreads,
-			unsigned int maxThreadsTime = 300);
+			unsigned int maxThreadsTime = 300,
+			bool scanLocalFiles = false);
 		virtual ~ThreadsManager();
 
 		static unsigned int get_next_id(void);
@@ -148,6 +149,7 @@
 		unsigned int m_maxIndexThreads;
 		unsigned int m_backgroundThreadsCount;
 		unsigned int m_foregroundThreadsMaxTime;
+		bool m_scanLocalFiles;
 		long m_numCPUs;
 		sigc::signal1<void, WorkerThread *> m_onThreadEndSignal;
 		std::set<std::string> m_beingIndexed;
@@ -200,26 +202,6 @@
 
 };
 
-class IndexBrowserThread : public ListerThread
-{
-	public:
-		IndexBrowserThread(const PinotSettings::IndexProperties &indexProps,
-			unsigned int maxDocsCount, unsigned int startDoc = 0);
-		~IndexBrowserThread();
-
-		std::string getLabelName(void) const;
-
-	protected:
-		unsigned int m_maxDocsCount;
-
-		virtual void doWork(void);
-
-	private:
-		IndexBrowserThread(const IndexBrowserThread &other);
-		IndexBrowserThread &operator=(const IndexBrowserThread &other);
-
-};
-
 class QueryingThread : public ListerThread
 {
 	public:
@@ -289,83 +271,6 @@
 
 };
 
-class EngineHistoryThread : public QueryingThread
-{
-	public:
-		EngineHistoryThread(const std::string &engineDisplayableName,
-			const QueryProperties &queryProps, unsigned int maxDocsCount);
-		virtual ~EngineHistoryThread();
-
-	protected:
-		unsigned int m_maxDocsCount;
-
-		virtual void doWork(void);
-
-	private:
-		EngineHistoryThread(const EngineHistoryThread &other);
-		EngineHistoryThread &operator=(const EngineHistoryThread &other);
-
-};
-
-class ExpandQueryThread : public WorkerThread
-{
-	public:
-		ExpandQueryThread(const QueryProperties &queryProps,
-			const std::set<std::string> &expandFromDocsSet);
-		virtual ~ExpandQueryThread();
-
-		virtual std::string getType(void) const;
-
-		QueryProperties getQuery(void) const;
-
-		const std::set<std::string> &getExpandTerms(void) const;
-
-	protected:
-		QueryProperties m_queryProps;
-		std::set<std::string> m_expandFromDocsSet;
-		std::set<std::string> m_expandTerms;
-
-		virtual void doWork(void);
-
-	private:
-		ExpandQueryThread(const ExpandQueryThread &other);
-		ExpandQueryThread &operator=(const ExpandQueryThread &other);
-
-};
-
-class LabelUpdateThread : public WorkerThread
-{
-	public:
-		LabelUpdateThread(const std::set<std::string> &labelsToAdd,
-			const std::set<std::string> &labelsToDelete);
-		LabelUpdateThread(const std::set<std::string> &labelsToAdd,
-			const std::set<unsigned int> &docsIds,
-			const std::set<unsigned int> &daemonIds,
-			bool resetLabels);
-
-		virtual ~LabelUpdateThread();
-
-		virtual std::string getType(void) const;
-
-		bool modifiedDocsIndex(void) const;
-
-		bool modifiedDaemonIndex(void) const;
-
-	protected:
-		std::set<std::string> m_labelsToAdd;
-		std::set<std::string> m_labelsToDelete;
-		std::set<unsigned int> m_docsIds;
-		std::set<unsigned int> m_daemonIds;
-		bool m_resetLabels;
-
-		virtual void doWork(void);
-
-	private:
-		LabelUpdateThread(const LabelUpdateThread &other);
-		LabelUpdateThread &operator=(const LabelUpdateThread &other);
-
-};
-
 class DownloadingThread : public WorkerThread
 {
 	public:
@@ -453,37 +358,6 @@
 
 };
 
-class UpdateDocumentThread : public WorkerThread
-{
-	public:
-		// Update a document's properties
-		UpdateDocumentThread(const PinotSettings::IndexProperties &indexProps,
-			unsigned int docId, const DocumentInfo &docInfo,
-			bool updateLabels);
-		virtual ~UpdateDocumentThread();
-
-		virtual std::string getType(void) const;
-
-		PinotSettings::IndexProperties getIndexProperties(void) const;
-
-		unsigned int getDocumentID(void) const;
-
-		const DocumentInfo &getDocumentInfo(void) const;
-
-	protected:
-		PinotSettings::IndexProperties m_indexProps;
-		unsigned int m_docId;
-		DocumentInfo m_docInfo;
-		bool m_updateLabels;
-
-		virtual void doWork(void);
-
-	private:
-		UpdateDocumentThread(const UpdateDocumentThread &other);
-		UpdateDocumentThread &operator=(const UpdateDocumentThread &other);
-
-};
-
 class MonitorThread : public WorkerThread
 {
 	public:

Modified: trunk/Core/pinot-index.cpp
===================================================================
--- trunk/Core/pinot-index.cpp	2009-02-07 09:37:40 UTC (rev 1551)
+++ trunk/Core/pinot-index.cpp	2009-02-12 14:02:28 UTC (rev 1552)
@@ -59,7 +59,7 @@
 {
 	public:
 		IndexingState(const string &indexLocation) :
-			ThreadsManager(indexLocation, 1, 60),
+			ThreadsManager(indexLocation, 1, 60, true),
 			m_docId(0)
 		{
 			m_onThreadEndSignal.connect(sigc::mem_fun(*this, &IndexingState::on_thread_end));

Modified: trunk/UI/GTK2/src/Makefile.am
===================================================================
--- trunk/UI/GTK2/src/Makefile.am	2009-02-07 09:37:40 UTC (rev 1551)
+++ trunk/UI/GTK2/src/Makefile.am	2009-02-12 14:02:28 UTC (rev 1552)
@@ -21,7 +21,8 @@
 	IndexPage.hh \
 	ModelColumns.hh \
 	Notebook.hh \
-	ResultsTree.hh
+	ResultsTree.hh \
+	UIThreads.hh
 
 pinot_SOURCES = \
 	pinot.cc \
@@ -45,7 +46,8 @@
 	IndexPage.cc \
 	ModelColumns.cc \
 	Notebook.cc \
-	ResultsTree.cc
+	ResultsTree.cc \
+	UIThreads.cc
 
 bin_PROGRAMS = pinot
 

Added: trunk/UI/GTK2/src/UIThreads.cc
===================================================================
--- trunk/UI/GTK2/src/UIThreads.cc	2009-02-07 09:37:40 UTC (rev 1551)
+++ trunk/UI/GTK2/src/UIThreads.cc	2009-02-12 14:02:28 UTC (rev 1552)
@@ -0,0 +1,397 @@
+/*
+ *  Copyright 2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <string.h>
+#include <signal.h>
+#include <exception>
+#include <iostream>
+
+#include "config.h"
+#include "NLS.h"
+#include "QueryHistory.h"
+#include "ModuleFactory.h"
+#include "PinotSettings.h"
+#include "UIThreads.hh"
+
+using namespace Glib;
+using namespace std;
+
+IndexBrowserThread::IndexBrowserThread(const PinotSettings::IndexProperties &indexProps,
+	unsigned int maxDocsCount, unsigned int startDoc) :
+	ListerThread(indexProps, startDoc),
+	m_maxDocsCount(maxDocsCount)
+{
+}
+
+IndexBrowserThread::~IndexBrowserThread()
+{
+}
+
+void IndexBrowserThread::doWork(void)
+{
+	set<unsigned int> docIDList;
+	set<string> docLabels;
+	unsigned int numDocs = 0;
+
+	if (m_indexProps.m_location.empty() == true)
+	{
+		m_errorNum = UNKNOWN_INDEX;
+		m_errorParam = m_indexProps.m_name.c_str();
+		return;
+	}
+
+	// Get the index at that location
+	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexProps.m_location);
+	if ((pIndex == NULL) ||
+		(pIndex->isGood() == false))
+	{
+		m_errorNum = INDEX_ERROR;
+		m_errorParam = m_indexProps.m_location;
+		if (pIndex != NULL)
+		{
+			delete pIndex;
+		}
+		return;
+	}
+
+	m_documentsCount = pIndex->getDocumentsCount();
+	if (m_documentsCount == 0)
+	{
+#ifdef DEBUG
+		cout << "IndexBrowserThread::doWork: no documents" << endl;
+#endif
+		return;
+	}
+
+#ifdef DEBUG
+	cout << "IndexBrowserThread::doWork: " << m_maxDocsCount << " off " << m_documentsCount
+		<< " documents to browse, starting at position " << m_startDoc << endl;
+#endif
+	pIndex->listDocuments(docIDList, m_maxDocsCount, m_startDoc);
+
+	m_documentsList.clear();
+	m_documentsList.reserve(m_maxDocsCount);
+
+	for (set<unsigned int>::iterator iter = docIDList.begin(); iter != docIDList.end(); ++iter)
+	{
+		unsigned int docId = (*iter);
+
+		if (m_done == true)
+		{
+			break;
+		}
+
+		DocumentInfo docInfo;
+		if (pIndex->getDocumentInfo(docId, docInfo) == true)
+		{
+			string type(docInfo.getType());
+
+			if (type.empty() == true)
+			{
+				docInfo.setType("text/html");
+			}
+			docInfo.setIsIndexed(m_indexProps.m_id, docId);
+
+			// Insert that document
+			m_documentsList.push_back(docInfo);
+			++numDocs;
+		}
+#ifdef DEBUG
+		else cout << "IndexBrowserThread::doWork: couldn't retrieve document " << docId << endl;
+#endif
+	}
+	delete pIndex;
+}
+
+EngineHistoryThread::EngineHistoryThread(const string &engineDisplayableName,
+	const QueryProperties &queryProps, unsigned int maxDocsCount) :
+	QueryingThread("", engineDisplayableName, "", queryProps, 0),
+	m_maxDocsCount(maxDocsCount)
+{
+	// Results are converted to UTF-8 prior to insertion in the history database
+	m_resultsCharset = "UTF-8";
+	m_isLive = false;
+}
+
+EngineHistoryThread::~EngineHistoryThread()
+{
+}
+
+void EngineHistoryThread::doWork(void)
+{
+	QueryHistory queryHistory(PinotSettings::getInstance().getHistoryDatabaseName());
+
+	if (queryHistory.getItems(m_queryProps.getName(), m_engineDisplayableName,
+		m_maxDocsCount, m_documentsList) == false)
+	{
+		m_errorNum = HISTORY_FAILED;
+		m_errorParam = m_engineDisplayableName;
+	}
+	else if (m_documentsList.empty() == false)
+	{
+		// Get the first result's charset
+		queryHistory.getItemExtract(m_queryProps.getName(), m_engineDisplayableName,
+			m_documentsList.front().getLocation());
+	}
+}
+
+ExpandQueryThread::ExpandQueryThread(const QueryProperties &queryProps,
+	const set<string> &expandFromDocsSet) :
+	WorkerThread(),
+	m_queryProps(queryProps)
+{
+	copy(expandFromDocsSet.begin(), expandFromDocsSet.end(),
+		inserter(m_expandFromDocsSet, m_expandFromDocsSet.begin()));
+}
+
+ExpandQueryThread::~ExpandQueryThread()
+{
+}
+
+string ExpandQueryThread::getType(void) const
+{
+	return "ExpandQueryThread";
+}
+
+QueryProperties ExpandQueryThread::getQuery(void) const
+{
+	return m_queryProps;
+}
+
+const set<string> &ExpandQueryThread::getExpandTerms(void) const
+{
+	return m_expandTerms;
+}
+
+void ExpandQueryThread::doWork(void)
+{
+	// Get the SearchEngine
+	SearchEngineInterface *pEngine = ModuleFactory::getSearchEngine(PinotSettings::getInstance().m_defaultBackend, "MERGED");
+	if (pEngine == NULL)
+	{
+		m_errorNum = UNKNOWN_ENGINE;
+		m_errorParam = m_queryProps.getName();
+		return;
+	}
+
+	// Expand the query
+	pEngine->setExpandSet(m_expandFromDocsSet);
+
+	// Run the query
+	pEngine->setDefaultOperator(SearchEngineInterface::DEFAULT_OP_AND);
+	if (pEngine->runQuery(m_queryProps) == false)
+	{
+		m_errorNum = QUERY_FAILED;
+	}
+	else
+	{
+		// Copy the expand terms
+		const set<string> &expandTerms = pEngine->getExpandTerms();
+		copy(expandTerms.begin(), expandTerms.end(),
+			inserter(m_expandTerms, m_expandTerms.begin()));
+	}
+
+	delete pEngine;
+}
+
+LabelUpdateThread::LabelUpdateThread(const set<string> &labelsToAdd,
+	const set<string> &labelsToDelete) :
+	WorkerThread(),
+	m_resetLabels(false)
+{
+	copy(labelsToAdd.begin(), labelsToAdd.end(),
+		inserter(m_labelsToAdd, m_labelsToAdd.begin()));
+	copy(labelsToDelete.begin(), labelsToDelete.end(),
+		inserter(m_labelsToDelete, m_labelsToDelete.begin()));
+}
+
+LabelUpdateThread::LabelUpdateThread(const set<string> &labelsToAdd,
+	const set<unsigned int> &docsIds, const set<unsigned int> &daemonIds,
+	bool resetLabels) :
+	WorkerThread(),
+	m_resetLabels(resetLabels)
+{
+	copy(labelsToAdd.begin(), labelsToAdd.end(),
+		inserter(m_labelsToAdd, m_labelsToAdd.begin()));
+	copy(docsIds.begin(), docsIds.end(),
+		inserter(m_docsIds, m_docsIds.begin()));
+	copy(daemonIds.begin(), daemonIds.end(),
+		inserter(m_daemonIds, m_daemonIds.begin()));
+}
+
+LabelUpdateThread::~LabelUpdateThread()
+{
+}
+
+string LabelUpdateThread::getType(void) const
+{
+	return "LabelUpdateThread";
+}
+
+bool LabelUpdateThread::modifiedDocsIndex(void) const
+{
+	return !m_docsIds.empty();
+}
+
+bool LabelUpdateThread::modifiedDaemonIndex(void) const
+{
+	return !m_daemonIds.empty();
+}
+
+void LabelUpdateThread::doWork(void)
+{
+	bool actOnDocuments = false;
+
+	IndexInterface *pDocsIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_docsIndexLocation);
+	if (pDocsIndex == NULL)
+	{
+		m_errorNum = INDEX_ERROR;
+		m_errorParam = PinotSettings::getInstance().m_docsIndexLocation;
+		return;
+	}
+
+	IndexInterface *pDaemonIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
+	if (pDaemonIndex == NULL)
+	{
+		m_errorNum = INDEX_ERROR;
+		m_errorParam = PinotSettings::getInstance().m_daemonIndexLocation;
+		delete pDocsIndex;
+		return;
+	}
+
+	// Apply the labels to existing documents
+	if (m_docsIds.empty() == false)
+	{
+		pDocsIndex->setDocumentsLabels(m_docsIds, m_labelsToAdd, m_resetLabels);
+		actOnDocuments = true;
+	}
+	if (m_daemonIds.empty() == false)
+	{
+		pDaemonIndex->setDocumentsLabels(m_daemonIds, m_labelsToAdd, m_resetLabels);
+		actOnDocuments = true;
+	}
+
+	if (actOnDocuments == false)
+	{
+		// Add and/or delete labels on the daemon's index only
+		// The documents index is not required to have labels set
+		for (set<string>::iterator iter = m_labelsToAdd.begin(); iter != m_labelsToAdd.end(); ++iter)
+		{
+			pDaemonIndex->addLabel(*iter);
+		}
+		for (set<string>::iterator iter = m_labelsToDelete.begin(); iter != m_labelsToDelete.end(); ++iter)
+		{
+			pDaemonIndex->deleteLabel(*iter);
+		}
+	}
+
+	delete pDaemonIndex;
+	delete pDocsIndex;
+}
+
+UpdateDocumentThread::UpdateDocumentThread(const PinotSettings::IndexProperties &indexProps, unsigned int docId,
+	const DocumentInfo &docInfo, bool updateLabels) :
+	WorkerThread(),
+	m_indexProps(indexProps),
+	m_docId(docId),
+	m_docInfo(docInfo),
+	m_updateLabels(updateLabels)
+{
+}
+
+UpdateDocumentThread::~UpdateDocumentThread()
+{
+}
+
+string UpdateDocumentThread::getType(void) const
+{
+	return "UpdateDocumentThread";
+}
+
+PinotSettings::IndexProperties UpdateDocumentThread::getIndexProperties(void) const
+{
+	return m_indexProps;
+}
+
+unsigned int UpdateDocumentThread::getDocumentID(void) const
+{
+	return m_docId;
+}
+
+const DocumentInfo &UpdateDocumentThread::getDocumentInfo(void) const
+{
+	return m_docInfo;
+}
+
+void UpdateDocumentThread::doWork(void)
+{
+	if (m_done == false)
+	{
+		if (m_indexProps.m_location.empty() == true)
+		{
+			m_errorNum = UNKNOWN_INDEX;
+			m_errorParam = m_indexProps.m_name.c_str();
+			return;
+		}
+
+		// Get the index at that location
+		IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexProps.m_location);
+		if ((pIndex == NULL) ||
+			(pIndex->isGood() == false))
+		{
+			m_errorNum = INDEX_ERROR;
+			m_errorParam = m_indexProps.m_location;
+			if (pIndex != NULL)
+			{
+				delete pIndex;
+			}
+			return;
+		}
+
+		// Update the DocumentInfo
+		if (pIndex->updateDocumentInfo(m_docId, m_docInfo) == false)
+		{
+			m_errorNum = UPDATE_FAILED;
+			m_errorParam = m_docInfo.getLocation();
+			return;
+		}
+		// ...and the labels if necessary
+		if (m_updateLabels == true)
+		{
+			if (pIndex->setDocumentLabels(m_docId, m_docInfo.getLabels()) == false)
+			{
+				m_errorNum = UPDATE_FAILED;
+				m_errorParam = m_docInfo.getLocation();
+				return;
+			}
+		}
+
+		// Flush the index ?
+		if (m_immediateFlush == true)
+		{
+			pIndex->flush();
+		}
+
+		delete pIndex;
+	}
+}
+

Added: trunk/UI/GTK2/src/UIThreads.hh
===================================================================
--- trunk/UI/GTK2/src/UIThreads.hh	2009-02-07 09:37:40 UTC (rev 1551)
+++ trunk/UI/GTK2/src/UIThreads.hh	2009-02-12 14:02:28 UTC (rev 1552)
@@ -0,0 +1,158 @@
+/*
+ *  Copyright 2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _UITHREADS_HH
+#define _UITHREADS_HH
+
+#include <string>
+#include <set>
+#include <glibmm/ustring.h>
+
+#include "DocumentInfo.h"
+#include "QueryProperties.h"
+#include "WorkerThreads.h"
+
+class IndexBrowserThread : public ListerThread
+{
+	public:
+		IndexBrowserThread(const PinotSettings::IndexProperties &indexProps,
+			unsigned int maxDocsCount, unsigned int startDoc = 0);
+		~IndexBrowserThread();
+
+		std::string getLabelName(void) const;
+
+	protected:
+		unsigned int m_maxDocsCount;
+
+		virtual void doWork(void);
+
+	private:
+		IndexBrowserThread(const IndexBrowserThread &other);
+		IndexBrowserThread &operator=(const IndexBrowserThread &other);
+
+};
+
+class EngineHistoryThread : public QueryingThread
+{
+	public:
+		EngineHistoryThread(const std::string &engineDisplayableName,
+			const QueryProperties &queryProps, unsigned int maxDocsCount);
+		virtual ~EngineHistoryThread();
+
+	protected:
+		unsigned int m_maxDocsCount;
+
+		virtual void doWork(void);
+
+	private:
+		EngineHistoryThread(const EngineHistoryThread &other);
+		EngineHistoryThread &operator=(const EngineHistoryThread &other);
+
+};
+
+class ExpandQueryThread : public WorkerThread
+{
+	public:
+		ExpandQueryThread(const QueryProperties &queryProps,
+			const std::set<std::string> &expandFromDocsSet);
+		virtual ~ExpandQueryThread();
+
+		virtual std::string getType(void) const;
+
+		QueryProperties getQuery(void) const;
+
+		const std::set<std::string> &getExpandTerms(void) const;
+
+	protected:
+		QueryProperties m_queryProps;
+		std::set<std::string> m_expandFromDocsSet;
+		std::set<std::string> m_expandTerms;
+
+		virtual void doWork(void);
+
+	private:
+		ExpandQueryThread(const ExpandQueryThread &other);
+		ExpandQueryThread &operator=(const ExpandQueryThread &other);
+
+};
+
+class LabelUpdateThread : public WorkerThread
+{
+	public:
+		LabelUpdateThread(const std::set<std::string> &labelsToAdd,
+			const std::set<std::string> &labelsToDelete);
+		LabelUpdateThread(const std::set<std::string> &labelsToAdd,
+			const std::set<unsigned int> &docsIds,
+			const std::set<unsigned int> &daemonIds,
+			bool resetLabels);
+
+		virtual ~LabelUpdateThread();
+
+		virtual std::string getType(void) const;
+
+		bool modifiedDocsIndex(void) const;
+
+		bool modifiedDaemonIndex(void) const;
+
+	protected:
+		std::set<std::string> m_labelsToAdd;
+		std::set<std::string> m_labelsToDelete;
+		std::set<unsigned int> m_docsIds;
+		std::set<unsigned int> m_daemonIds;
+		bool m_resetLabels;
+
+		virtual void doWork(void);
+
+	private:
+		LabelUpdateThread(const LabelUpdateThread &other);
+		LabelUpdateThread &operator=(const LabelUpdateThread &other);
+
+};
+
+class UpdateDocumentThread : public WorkerThread
+{
+	public:
+		// Update a document's properties
+		UpdateDocumentThread(const PinotSettings::IndexProperties &indexProps,
+			unsigned int docId, const DocumentInfo &docInfo,
+			bool updateLabels);
+		virtual ~UpdateDocumentThread();
+
+		virtual std::string getType(void) const;
+
+		PinotSettings::IndexProperties getIndexProperties(void) const;
+
+		unsigned int getDocumentID(void) const;
+
+		const DocumentInfo &getDocumentInfo(void) const;
+
+	protected:
+		PinotSettings::IndexProperties m_indexProps;
+		unsigned int m_docId;
+		DocumentInfo m_docInfo;
+		bool m_updateLabels;
+
+		virtual void doWork(void);
+
+	private:
+		UpdateDocumentThread(const UpdateDocumentThread &other);
+		UpdateDocumentThread &operator=(const UpdateDocumentThread &other);
+
+};
+
+#endif // _UITHREADS_HH

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2009-02-07 09:37:40 UTC (rev 1551)
+++ trunk/UI/GTK2/src/mainWindow.cc	2009-02-12 14:02:28 UTC (rev 1552)
@@ -102,7 +102,7 @@
 }
 
 mainWindow::InternalState::InternalState(unsigned int maxIndexThreads, mainWindow *pWindow) :
-	ThreadsManager(PinotSettings::getInstance().m_docsIndexLocation, maxIndexThreads, 60),
+	ThreadsManager(PinotSettings::getInstance().m_docsIndexLocation, maxIndexThreads, 60, true),
 	m_liveQueryLength(0),
 	m_currentPage(0),
 	m_browsingIndex(false)

Modified: trunk/UI/GTK2/src/mainWindow.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow.hh	2009-02-07 09:37:40 UTC (rev 1551)
+++ trunk/UI/GTK2/src/mainWindow.hh	2009-02-12 14:02:28 UTC (rev 1552)
@@ -40,12 +40,12 @@
 #include "MonitorInterface.h"
 #include "MonitorHandler.h"
 #include "PinotSettings.h"
-#include "WorkerThreads.h"
 #include "EnginesTree.hh"
 #include "IndexPage.hh"
 #include "ModelColumns.hh"
 #include "Notebook.hh"
 #include "ResultsTree.hh"
+#include "UIThreads.hh"
 #include "mainWindow_glade.hh"
 
 class mainWindow : public mainWindow_glade

Modified: trunk/UI/GTK2/src/prefsWindow.hh
===================================================================
--- trunk/UI/GTK2/src/prefsWindow.hh	2009-02-07 09:37:40 UTC (rev 1551)
+++ trunk/UI/GTK2/src/prefsWindow.hh	2009-02-12 14:02:28 UTC (rev 1552)
@@ -28,8 +28,8 @@
 #include <gtkmm/liststore.h>
 
 #include "PinotSettings.h"
-#include "WorkerThreads.h"
 #include "ModelColumns.hh"
+#include "UIThreads.hh"
 #include "prefsWindow_glade.hh"
 
 class prefsWindow : public prefsWindow_glade

Modified: trunk/UI/GTK2/src/statisticsDialog.hh
===================================================================
--- trunk/UI/GTK2/src/statisticsDialog.hh	2009-02-07 09:37:40 UTC (rev 1551)
+++ trunk/UI/GTK2/src/statisticsDialog.hh	2009-02-12 14:02:28 UTC (rev 1552)
@@ -25,8 +25,8 @@
 #include <glibmm/refptr.h>
 #include <gtkmm/treestore.h>
 
-#include "WorkerThreads.h"
 #include "ModelColumns.hh"
+#include "UIThreads.hh"
 #include "statisticsDialog_glade.hh"
 
 class statisticsDialog : public statisticsDialog_glade

Modified: trunk/po/POTFILES.in
===================================================================
--- trunk/po/POTFILES.in	2009-02-07 09:37:40 UTC (rev 1551)
+++ trunk/po/POTFILES.in	2009-02-12 14:02:28 UTC (rev 1552)
@@ -31,3 +31,4 @@
 UI/GTK2/src/ResultsTree.cc
 UI/GTK2/src/statisticsDialog.cc
 UI/GTK2/src/statisticsDialog_glade.cc
+UI/GTK2/src/UIThreads.cc



From fabricecolin at mail.berlios.de  Thu Feb 12 15:04:09 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Thu, 12 Feb 2009 15:04:09 +0100
Subject: [Pinot-svn] r1553 - trunk/Core
Message-ID: <200902121404.n1CE49qn018501@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-12 15:04:00 +0100 (Thu, 12 Feb 2009)
New Revision: 1553

Modified:
   trunk/Core/ServerThreads.cpp
Log:
Don't have monitorEntry() return false if no monitor is available, this would
log an error.


Modified: trunk/Core/ServerThreads.cpp
===================================================================
--- trunk/Core/ServerThreads.cpp	2009-02-12 14:02:28 UTC (rev 1552)
+++ trunk/Core/ServerThreads.cpp	2009-02-12 14:04:00 UTC (rev 1553)
@@ -249,7 +249,7 @@
 		return m_pMonitor->addLocation(entryName, true);
 	}
 
-	return false;
+	return true;
 }
 
 void CrawlerThread::foundFile(const DocumentInfo &docInfo)



From fabricecolin at mail.berlios.de  Thu Feb 12 15:06:11 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Thu, 12 Feb 2009 15:06:11 +0100
Subject: [Pinot-svn] r1554 - trunk
Message-ID: <200902121406.n1CE6B1n018617@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-12 15:06:02 +0100 (Thu, 12 Feb 2009)
New Revision: 1554

Modified:
   trunk/pinot-dbus-daemon.desktop
   trunk/pinot-prefs.desktop
   trunk/pinot.desktop
Log:
Removed deprecated Encoding field.


Modified: trunk/pinot-dbus-daemon.desktop
===================================================================
--- trunk/pinot-dbus-daemon.desktop	2009-02-12 14:04:00 UTC (rev 1553)
+++ trunk/pinot-dbus-daemon.desktop	2009-02-12 14:06:02 UTC (rev 1554)
@@ -1,5 +1,4 @@
 [Desktop Entry]
-Encoding=UTF-8
 Name=Pinot
 Comment=Search your documents
 Exec=pinot-dbus-daemon

Modified: trunk/pinot-prefs.desktop
===================================================================
--- trunk/pinot-prefs.desktop	2009-02-12 14:04:00 UTC (rev 1553)
+++ trunk/pinot-prefs.desktop	2009-02-12 14:06:02 UTC (rev 1554)
@@ -1,5 +1,4 @@
 [Desktop Entry]
-Encoding=UTF-8
 Name=File Indexing and Search
 Comment=Configure Pinot to index your files
 Exec=pinot-prefs

Modified: trunk/pinot.desktop
===================================================================
--- trunk/pinot.desktop	2009-02-12 14:04:00 UTC (rev 1553)
+++ trunk/pinot.desktop	2009-02-12 14:06:02 UTC (rev 1554)
@@ -1,5 +1,4 @@
 [Desktop Entry]
-Encoding=UTF-8
 Name=Pinot Metasearch Tool
 Name[de]=Pinot Werkzeug zur Metasuche
 Name[es]=Herramienta metabuscador Pinot



From fabricecolin at mail.berlios.de  Sat Feb 14 03:39:24 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sat, 14 Feb 2009 03:39:24 +0100
Subject: [Pinot-svn] r1555 - trunk
Message-ID: <200902140239.n1E2dO0d001305@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-14 03:39:19 +0100 (Sat, 14 Feb 2009)
New Revision: 1555

Modified:
   trunk/README
Log:
Specify that attachments and documents embedded in mbox email are indexed, and
can be opened from the UI.


Modified: trunk/README
===================================================================
--- trunk/README	2009-02-12 14:06:02 UTC (rev 1554)
+++ trunk/README	2009-02-14 02:39:19 UTC (rev 1555)
@@ -266,7 +266,7 @@
     * plain text
     * HTML
     * XML
-    * mbox
+    * mbox, including attachments and embedded documents
     * MP3 and Ogg Vorbis
     * JPEG
 
@@ -283,13 +283,11 @@
     * DEB (dpkg required)
 
   For other document types, Pinot will only index metadata such as name,
-  location etc...
+  location etc... If you wish to add support for another document type, and
+  know of a command-line program that can handle that type, add it to
+  external-filters.xml, located in /etc/pinot/.
 
-  If you wish to add support for another document type, and know of a
-  command-line program that can convert that type to plain text, XML or HTML,
-  add it to external-filters.xml, located in /etc/pinot/.
 
-
 9. File patterns
 
 



From fabricecolin at mail.berlios.de  Sun Feb 15 03:22:17 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 15 Feb 2009 03:22:17 +0100
Subject: [Pinot-svn] r1556 - in trunk: Core Utils
Message-ID: <200902150222.n1F2MHGp016120@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-15 03:22:11 +0100 (Sun, 15 Feb 2009)
New Revision: 1556

Modified:
   trunk/Core/ServerThreads.cpp
   trunk/Core/WorkerThreads.cpp
   trunk/Utils/TimeConverter.cpp
Log:
Fixed some memory leaks :
- when converting to a timestamp (struct tm)
- when reapplying user-set metadata (Index)
- when skipping the download of local files (Document)


Modified: trunk/Core/ServerThreads.cpp
===================================================================
--- trunk/Core/ServerThreads.cpp	2009-02-14 02:39:19 UTC (rev 1555)
+++ trunk/Core/ServerThreads.cpp	2009-02-15 02:22:11 UTC (rev 1556)
@@ -363,9 +363,13 @@
 		scanTimer.start();
 
 		IndexInterface *pIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
+		if (pIndex == NULL)
+		{
+			return;
+		}
+
 		// Restore user-set metadata, if any
-		while ((pIndex != NULL) &&
-			(pIndex->isGood() == true) &&
+		while ((pIndex->isGood() == true) &&
 			(metaData.getItems(string("file://") + m_dirName, urls,
 				currentOffset, currentOffset + 100) == true))
 		{
@@ -395,6 +399,8 @@
 		}
 		cout << "Restored user-set metadata for " << currentOffset + urls.size()
 			<< " documents in " << scanTimer.stop() << " ms" << endl;
+
+		delete pIndex;
 	}
 }
 

Modified: trunk/Core/WorkerThreads.cpp
===================================================================
--- trunk/Core/WorkerThreads.cpp	2009-02-14 02:39:19 UTC (rev 1555)
+++ trunk/Core/WorkerThreads.cpp	2009-02-15 02:22:11 UTC (rev 1556)
@@ -1394,6 +1394,11 @@
 	}
 	else
 	{
+		if (m_pDoc != NULL)
+		{
+			delete m_pDoc;
+			m_pDoc = NULL;
+		}
 		m_pDoc = new Document(m_docInfo);
 
 		m_pDoc->setTimestamp(m_docInfo.getTimestamp());

Modified: trunk/Utils/TimeConverter.cpp
===================================================================
--- trunk/Utils/TimeConverter.cpp	2009-02-14 02:39:19 UTC (rev 1555)
+++ trunk/Utils/TimeConverter.cpp	2009-02-15 02:22:11 UTC (rev 1556)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005-2008 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -146,6 +146,8 @@
 		if (strftime(timeStr, 64, "%a, %d %b %Y %H:%M:%S %Z", pTimeTm) > 0)
 #endif
 		{
+			delete pTimeTm;
+
 			return timeStr;
 		}
 	}



From fabricecolin at mail.berlios.de  Sun Feb 15 03:23:43 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 15 Feb 2009 03:23:43 +0100
Subject: [Pinot-svn] r1557 - trunk/Core
Message-ID: <200902150223.n1F2NhqA016191@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-15 03:23:39 +0100 (Sun, 15 Feb 2009)
New Revision: 1557

Modified:
   trunk/Core/pinot-index.cpp
Log:
Don't allow threads to flush the index.
Delete the state object before exit.


Modified: trunk/Core/pinot-index.cpp
===================================================================
--- trunk/Core/pinot-index.cpp	2009-02-15 02:22:11 UTC (rev 1556)
+++ trunk/Core/pinot-index.cpp	2009-02-15 02:23:39 UTC (rev 1557)
@@ -62,6 +62,9 @@
 			ThreadsManager(indexLocation, 1, 60, true),
 			m_docId(0)
 		{
+			// Disable implicit flushing
+			WorkerThread::immediateFlush(false);
+
 			m_onThreadEndSignal.connect(sigc::mem_fun(*this, &IndexingState::on_thread_end));
 		}
 
@@ -97,6 +100,15 @@
 
 				// Get the document ID of the URL we have just indexed
 				m_docId = pIndexThread->getDocumentID();
+
+				// Explicitely flush the index once a directory has been crawled
+				IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_defaultIndexLocation);
+				if (pIndex != NULL)
+				{
+					pIndex->flush();
+
+					delete pIndex;
+				}
 			}
 
 			// Delete the thread
@@ -467,7 +479,7 @@
 		++optind;
 	}
 	delete pIndex;
-	if (g_pState == NULL)
+	if (g_pState != NULL)
 	{
 		delete g_pState;
 	}



From fabricecolin at mail.berlios.de  Sun Feb 15 03:25:09 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 15 Feb 2009 03:25:09 +0100
Subject: [Pinot-svn] r1558 - in trunk: . Core
Message-ID: <200902150225.n1F2P9Ha016235@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-15 03:25:00 +0100 (Sun, 15 Feb 2009)
New Revision: 1558

Modified:
   trunk/Core/pinot-dbus-daemon.cpp
   trunk/configure.in
Log:
If linux/sched.h is available, use sched_setscheduler(SCHED_IDLE) in place of
setpriority().


Modified: trunk/Core/pinot-dbus-daemon.cpp
===================================================================
--- trunk/Core/pinot-dbus-daemon.cpp	2009-02-15 02:23:39 UTC (rev 1557)
+++ trunk/Core/pinot-dbus-daemon.cpp	2009-02-15 02:25:00 UTC (rev 1558)
@@ -16,11 +16,17 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include "config.h"
 #include <stdlib.h>
 #include <libintl.h>
 #include <getopt.h>
+#ifdef HAVE_LINUX_SCHED_H
+#include <linux/sched.h>
+#include <sched.h>
+#else
 #include <sys/time.h>
 #include <sys/resource.h>
+#endif
 #include <sys/types.h>
 #include <signal.h>
 #include <unistd.h>
@@ -37,7 +43,6 @@
 #include <glibmm/miscutils.h>
 #include <glibmm/convert.h>
 
-#include "config.h"
 #include "NLS.h"
 #include "FilterFactory.h"
 #include "Languages.h"
@@ -522,13 +527,23 @@
 
 	atexit(closeAll);
 
+#ifdef HAVE_LINUX_SCHED_H
+	// Set the scheduling policy
+	struct sched_param schedParam;
+	if (sched_getparam(0, &schedParam) == -1)
+	{
+		cerr << "Couldn't get current scheduling policy" << endl;
+	}
+	else if (sched_setscheduler(0, SCHED_IDLE, &schedParam) == -1)
+	{
+		cerr << "Couldn't set scheduling policy" << endl;
+	}
+#else
 	// Change the daemon's priority
 	if (setpriority(PRIO_PROCESS, 0, priority) == -1)
 	{
 		cerr << "Couldn't set scheduling priority to " << priority << endl;
 	}
-#ifdef DEBUG
-	else cout << "Set priority to " << priority << endl;
 #endif
 
 	GError *pError = NULL;

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2009-02-15 02:23:39 UTC (rev 1557)
+++ trunk/configure.in	2009-02-15 02:25:00 UTC (rev 1558)
@@ -369,7 +369,7 @@
 MISC_LIBS="$PTHREAD_LIBS"
 AC_SUBST(MISC_CFLAGS)
 AC_SUBST(MISC_LIBS)
-AC_CHECK_HEADERS([sys/vfs.h sys/statfs.h sys/mount.h sys/statvfs.h attr/xattr.h dlfcn.h regex.h fnmatch.h pwd.h])
+AC_CHECK_HEADERS([sys/vfs.h sys/statfs.h sys/mount.h sys/statvfs.h attr/xattr.h dlfcn.h regex.h fnmatch.h pwd.h linux/sched.h])
 PKG_CHECK_MODULES(MIMEINFO, shared-mime-info )
 SHARED_MIME_INFO_PREFIX=`pkg-config --variable=prefix shared-mime-info`
 AC_SUBST(SHARED_MIME_INFO_PREFIX)



From fabricecolin at mail.berlios.de  Sun Feb 15 13:19:51 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 15 Feb 2009 13:19:51 +0100
Subject: [Pinot-svn] r1559 - trunk/Core
Message-ID: <200902151219.n1FCJpa1007328@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-15 13:19:43 +0100 (Sun, 15 Feb 2009)
New Revision: 1559

Modified:
   trunk/Core/WorkerThreads.cpp
   trunk/Core/WorkerThreads.h
Log:
Cache what type of downloader DownloadingThread last got to avoid getting a new
one every time. IndexingThread doesn't get a new Index on every call to its
doWork() method.
Look for the ROBOTS meta tag in remote documents only.


Modified: trunk/Core/WorkerThreads.cpp
===================================================================
--- trunk/Core/WorkerThreads.cpp	2009-02-15 02:25:00 UTC (rev 1558)
+++ trunk/Core/WorkerThreads.cpp	2009-02-15 12:19:43 UTC (rev 1559)
@@ -1208,21 +1208,36 @@
 
 void DownloadingThread::doWork(void)
 {
+	Url thisUrl(m_docInfo.getLocation());
+	bool getDownloader = true;
+
 	if (m_pDoc != NULL)
 	{
 		delete m_pDoc;
 		m_pDoc = NULL;
 	}
+
+	// Get a Downloader
 	if (m_pDownloader != NULL)
 	{
-		delete m_pDownloader;
-		m_pDownloader = NULL;
+		// Same protocol as what we now need ?
+		if (m_protocol == thisUrl.getProtocol())
+		{
+			getDownloader = false;
+		}
+		else
+		{
+			delete m_pDownloader;
+			m_pDownloader = NULL;
+			m_protocol.clear();
+		}
 	}
+	if (getDownloader == true)
+	{
+		m_protocol = thisUrl.getProtocol();
+		m_pDownloader = DownloaderFactory::getDownloader(m_protocol);
+	}
 
-	Url thisUrl(m_docInfo.getLocation());
-
-	// Get a Downloader, the default one will do
-	m_pDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
 	if (m_pDownloader == NULL)
 	{
 		m_errorNum = UNSUPPORTED_PROTOCOL;
@@ -1234,7 +1249,8 @@
 		PinotSettings &settings = PinotSettings::getInstance();
 
 		// Set up the proxy
-		if ((settings.m_proxyEnabled == true) &&
+		if ((getDownloader == true) &&
+			(settings.m_proxyEnabled == true) &&
 			(settings.m_proxyAddress.empty() == false))
 		{
 			char portStr[64];
@@ -1262,24 +1278,30 @@
 IndexingThread::IndexingThread(const DocumentInfo &docInfo, const string &indexLocation,
 	bool allowAllMIMETypes) :
 	DownloadingThread(docInfo),
-	m_docId(0),
+	m_pIndex(NULL),
 	m_indexLocation(indexLocation),
 	m_allowAllMIMETypes(allowAllMIMETypes),
-	m_update(false)
+	m_update(false),
+	m_docId(0)
 {
 }
 
-IndexingThread::IndexingThread() :
+IndexingThread::IndexingThread(const string &indexLocation) :
 	DownloadingThread(),
-	m_docId(0),
-	m_indexLocation(""),
+	m_pIndex(NULL),
+	m_indexLocation(indexLocation),
 	m_allowAllMIMETypes(true),
-	m_update(false)
+	m_update(false),
+	m_docId(0)
 {
 }
 
 IndexingThread::~IndexingThread()
 {
+	if (m_pIndex != NULL)
+	{
+		delete m_pIndex;
+	}
 }
 
 string IndexingThread::getType(void) const
@@ -1309,25 +1331,24 @@
 
 void IndexingThread::doWork(void)
 {
-	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexLocation);
 	Url thisUrl(m_docInfo.getLocation());
 	bool reliableType = false, doDownload = true;
 
 	// First things first, get the index
-	if ((pIndex == NULL) ||
-		(pIndex->isGood() == false))
+	if (m_pIndex == NULL)
 	{
+		m_pIndex = PinotSettings::getInstance().getIndex(m_indexLocation);
+	}
+	if ((m_pIndex == NULL) ||
+		(m_pIndex->isGood() == false))
+	{
 		m_errorNum = INDEX_ERROR;
 		m_errorParam = m_indexLocation;
-		if (pIndex != NULL)
-		{
-			delete pIndex;
-		}
 		return;
 	}
 
 	// Is it an update ?
-	m_docId = pIndex->hasDocument(m_docInfo.getLocation());
+	m_docId = m_pIndex->hasDocument(m_docInfo.getLocation());
 	if (m_docId > 0)
 	{
 		// Ignore robots directives on updates
@@ -1352,7 +1373,6 @@
 		{
 			m_errorNum = UNSUPPORTED_TYPE;
 			m_errorParam = m_docInfo.getType();
-			delete pIndex;
 
 			return;
 		}
@@ -1447,7 +1467,6 @@
 			{
 				m_errorNum = UNSUPPORTED_TYPE;
 				m_errorParam = m_docInfo.getType();
-				delete pIndex;
 
 				return;
 			}
@@ -1455,6 +1474,7 @@
 			// Let FilterWrapper handle unspported documents
 		}
 		else if ((PinotSettings::getInstance().m_ignoreRobotsDirectives == false) &&
+			(thisUrl.isLocal() == false) &&
 			(m_docInfo.getType().length() >= 9) &&
 			(m_docInfo.getType().substr(9) == "text/html"))
 		{
@@ -1480,7 +1500,6 @@
 						// No, it isn't
 						m_errorNum = ROBOTS_FORBIDDEN;
 						m_errorParam = m_docInfo.getLocation();
-						delete pIndex;
 
 						return;
 					}
@@ -1493,7 +1512,7 @@
 
 		if (m_done == false)
 		{
-			FilterWrapper wrapFilter(pIndex);
+			FilterWrapper wrapFilter(m_pIndex);
 
 			// Update an existing document or add to the index ?
 			if (m_update == true)
@@ -1544,11 +1563,11 @@
 				// Flush the index ?
 				if (m_immediateFlush == true)
 				{
-					pIndex->flush();
+					m_pIndex->flush();
 				}
 
 				// The document properties may have changed
-				pIndex->getDocumentInfo(m_docId, m_docInfo);
+				m_pIndex->getDocumentInfo(m_docId, m_docInfo);
 				m_docInfo.setIsIndexed(
 					PinotSettings::getInstance().getIndexPropertiesByLocation(m_indexLocation).m_id,
 					m_docId);
@@ -1560,8 +1579,6 @@
 #ifdef DEBUG
 	else cout << "IndexingThread::doWork: couldn't download " << m_docInfo.getLocation() << endl;
 #endif
-
-	delete pIndex;
 }
 
 UnindexingThread::UnindexingThread(const set<unsigned int> &docIdList) :
@@ -1924,14 +1941,13 @@
 DirectoryScannerThread::DirectoryScannerThread(const string &dirName,
 	const string &indexLocation, unsigned int maxLevel,
 	bool inlineIndexing, bool followSymLinks) :
-	IndexingThread(),
+	IndexingThread(indexLocation),
 	m_dirName(dirName),
 	m_currentLevel(0),
 	m_maxLevel(maxLevel),
 	m_inlineIndexing(inlineIndexing),
 	m_followSymLinks(followSymLinks)
 {
-	m_indexLocation = indexLocation;
 }
 
 DirectoryScannerThread::~DirectoryScannerThread()

Modified: trunk/Core/WorkerThreads.h
===================================================================
--- trunk/Core/WorkerThreads.h	2009-02-15 02:25:00 UTC (rev 1558)
+++ trunk/Core/WorkerThreads.h	2009-02-15 12:19:43 UTC (rev 1559)
@@ -287,6 +287,7 @@
 		DocumentInfo m_docInfo;
 		Document *m_pDoc;
 		DownloaderInterface *m_pDownloader;
+		std::string m_protocol;
 
 		DownloadingThread();
 
@@ -303,6 +304,7 @@
 	public:
 		IndexingThread(const DocumentInfo &docInfo, const std::string &indexLocation,
 			bool allowAllMIMETypes = true);
+		IndexingThread(const std::string &indexLocation);
 		virtual ~IndexingThread();
 
 		virtual std::string getType(void) const;
@@ -316,10 +318,11 @@
 		bool isNewDocument(void) const;
 
 	protected:
-		unsigned int m_docId;
+		IndexInterface *m_pIndex;
 		std::string m_indexLocation;
 		bool m_allowAllMIMETypes;
 		bool m_update;
+		unsigned int m_docId;
 
 		IndexingThread();
 



From fabricecolin at mail.berlios.de  Sun Feb 15 15:31:24 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sun, 15 Feb 2009 15:31:24 +0100
Subject: [Pinot-svn] r1560 - in trunk: Core SQL
Message-ID: <200902151431.n1FEVOK7023777@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-15 15:31:13 +0100 (Sun, 15 Feb 2009)
New Revision: 1560

Modified:
   trunk/Core/DaemonState.cpp
   trunk/Core/ServerThreads.cpp
   trunk/SQL/CrawlHistory.cpp
   trunk/SQL/CrawlHistory.h
Log:
Be selective when changing the status of crawled items on full scan. The status
of links shouldn't be changed or they would be skipped during the crawl and
what they point to would get unindexed.


Modified: trunk/Core/DaemonState.cpp
===================================================================
--- trunk/Core/DaemonState.cpp	2009-02-15 12:19:43 UTC (rev 1559)
+++ trunk/Core/DaemonState.cpp	2009-02-15 14:31:13 UTC (rev 1560)
@@ -514,7 +514,9 @@
 		CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
 
 		// Update all items status so that we can get rid of files from deleted sources
-		crawlHistory.updateItemsStatus(CrawlHistory::TO_CRAWL, 0, true);
+		crawlHistory.updateItemsStatus(CrawlHistory::CRAWLING, CrawlHistory::TO_CRAWL, 0, true);
+		crawlHistory.updateItemsStatus(CrawlHistory::CRAWLED, CrawlHistory::TO_CRAWL, 0, true);
+		crawlHistory.updateItemsStatus(CrawlHistory::CRAWL_ERROR, CrawlHistory::TO_CRAWL, 0, true);
 	}
 
 	// Initiate crawling

Modified: trunk/Core/ServerThreads.cpp
===================================================================
--- trunk/Core/ServerThreads.cpp	2009-02-15 12:19:43 UTC (rev 1559)
+++ trunk/Core/ServerThreads.cpp	2009-02-15 14:31:13 UTC (rev 1560)
@@ -305,7 +305,7 @@
 		cout << "Doing a full scan on " << m_dirName << endl;
 
 		// Update this source's items status so that we can detect files that have been deleted
-		m_crawlHistory.updateItemsStatus(CrawlHistory::TO_CRAWL, m_sourceId);
+		m_crawlHistory.updateItemsStatus(CrawlHistory::CRAWLED, CrawlHistory::TO_CRAWL, m_sourceId);
 	}
 
 	if (scanEntry(m_dirName) == false)

Modified: trunk/SQL/CrawlHistory.cpp
===================================================================
--- trunk/SQL/CrawlHistory.cpp	2009-02-15 12:19:43 UTC (rev 1559)
+++ trunk/SQL/CrawlHistory.cpp	2009-02-15 14:31:13 UTC (rev 1560)
@@ -340,8 +340,8 @@
 }
 
 /// Updates the status of items en masse.
-bool CrawlHistory::updateItemsStatus(CrawlStatus newStatus, unsigned int sourceId,
-	bool allSources)
+bool CrawlHistory::updateItemsStatus(CrawlStatus oldStatus, CrawlStatus newStatus,
+	unsigned int sourceId, bool allSources)
 {
 	SQLResults *results = NULL;
 	bool success = false;
@@ -349,15 +349,15 @@
 	if (allSources == false)
 	{
 		results = executeStatement("UPDATE CrawlHistory \
-			SET Status='%q' WHERE SourceId='%u';",
-			statusToText(newStatus).c_str(), sourceId);
+			SET Status='%q' WHERE SourceId='%u' AND Status='%q';",
+			statusToText(newStatus).c_str(), sourceId, statusToText(oldStatus).c_str());
 	}
 	else
 	{
 		// Ignore the source
 		results = executeStatement("UPDATE CrawlHistory \
-			SET Status='%q';",
-			statusToText(newStatus).c_str());
+			SET Status='%q' AND Status='%q';",
+			statusToText(newStatus).c_str(), statusToText(oldStatus).c_str());
 	}
 
 	if (results != NULL)

Modified: trunk/SQL/CrawlHistory.h
===================================================================
--- trunk/SQL/CrawlHistory.h	2009-02-15 12:19:43 UTC (rev 1559)
+++ trunk/SQL/CrawlHistory.h	2009-02-15 14:31:13 UTC (rev 1560)
@@ -64,8 +64,8 @@
 		bool updateItems(const std::map<std::string, time_t> urls, CrawlStatus status);
 
 		/// Updates the status of items en masse.
-		bool updateItemsStatus(CrawlStatus newStatus, unsigned int sourceId,
-			bool allSources = false);
+		bool updateItemsStatus(CrawlStatus oldStatus, CrawlStatus newStatus,
+			unsigned int sourceId, bool allSources = false);
 
 		/// Gets the error number and date for a URL.
 		int getErrorDetails(const std::string &url, time_t &date);



From fabricecolin at mail.berlios.de  Mon Feb 16 15:14:23 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Mon, 16 Feb 2009 15:14:23 +0100
Subject: [Pinot-svn] r1561 - in trunk: . Core
Message-ID: <200902161414.n1GEENtE012953@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-16 15:14:13 +0100 (Mon, 16 Feb 2009)
New Revision: 1561

Modified:
   trunk/Core/pinot-index.1
   trunk/Core/pinot-index.cpp
   trunk/README
Log:
Running pinot-index --index on My Web Pages or My Documents isn't a good idea.


Modified: trunk/Core/pinot-index.1
===================================================================
--- trunk/Core/pinot-index.1	2009-02-15 14:31:13 UTC (rev 1560)
+++ trunk/Core/pinot-index.1	2009-02-16 14:14:13 UTC (rev 1561)
@@ -34,7 +34,9 @@
 .SH EXAMPLES
 pinot\-index \fB\-\-check\fR \fB\-\-showinfo\fR \fB\-\-backend\fR xapian \fB\-\-db\fR ~/.pinot/daemon ../Bozo.txt
 .PP
-pinot\-index \fB\-\-index\fR \fB\-\-db\fR "My Web Pages" http://pinot.berlios.de/
+pinot\-index \fB\-\-index\fR \fB\-\-db\fR CoolStuff http://pinot.berlios.de/
+.PP
+Indexing documents to My Web Pages or My Documents with pinot\-index is not recommended
 .SH "REPORTING BUGS"
 Report bugs to fabricecolin at users.berlios.de
 .PP

Modified: trunk/Core/pinot-index.cpp
===================================================================
--- trunk/Core/pinot-index.cpp	2009-02-15 14:31:13 UTC (rev 1560)
+++ trunk/Core/pinot-index.cpp	2009-02-16 14:14:13 UTC (rev 1561)
@@ -158,7 +158,8 @@
 	ModuleFactory::unloadModules();
 	cout << "\n\nExamples:\n"
 		<< "pinot-index --check --showinfo --backend xapian --db ~/.pinot/daemon ../Bozo.txt\n\n"
-		<< "pinot-index --index --db \"My Web Pages\" http://pinot.berlios.de/\n\n"
+		<< "pinot-index --index --db CoolStuff http://pinot.berlios.de/\n\n"
+		<< "Indexing documents to My Web Pages or My Documents with pinot-index is not recommended\n\n"
 		<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
 }
 

Modified: trunk/README
===================================================================
--- trunk/README	2009-02-15 14:31:13 UTC (rev 1560)
+++ trunk/README	2009-02-16 14:14:13 UTC (rev 1561)
@@ -168,7 +168,12 @@
   If you want to exclude any specific files or directories from indexing, use
   patterns as described in section "9. File patterns".
 
+  The pinot-index program allows indexing and peeking at documents' properties
+  from the command-line. Using the -i/--index option with the My Documents or
+  My Web Pages index is not recommended. For more details, see the manual page
+  for pinot-index(1).
 
+
 6. Searching
 
 



From fabricecolin at mail.berlios.de  Wed Feb 18 12:29:28 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Wed, 18 Feb 2009 12:29:28 +0100
Subject: [Pinot-svn] r1562 - trunk
Message-ID: <200902181129.n1IBTSqa021837@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-18 12:29:22 +0100 (Wed, 18 Feb 2009)
New Revision: 1562

Modified:
   trunk/configure.in
Log:
Disable check for linux/sched.h, and therefore support for SCHED_IDLE, for the
time being. See :
http://lkml.org/lkml/2009/1/11/70
http://lkml.org/lkml/2009/1/22/416
http://lkml.org/lkml/2009/1/30/297
Thanks to John Werden for reporting this.


Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2009-02-16 14:14:13 UTC (rev 1561)
+++ trunk/configure.in	2009-02-18 11:29:22 UTC (rev 1562)
@@ -369,7 +369,7 @@
 MISC_LIBS="$PTHREAD_LIBS"
 AC_SUBST(MISC_CFLAGS)
 AC_SUBST(MISC_LIBS)
-AC_CHECK_HEADERS([sys/vfs.h sys/statfs.h sys/mount.h sys/statvfs.h attr/xattr.h dlfcn.h regex.h fnmatch.h pwd.h linux/sched.h])
+AC_CHECK_HEADERS([sys/vfs.h sys/statfs.h sys/mount.h sys/statvfs.h attr/xattr.h dlfcn.h regex.h fnmatch.h pwd.h])
 PKG_CHECK_MODULES(MIMEINFO, shared-mime-info )
 SHARED_MIME_INFO_PREFIX=`pkg-config --variable=prefix shared-mime-info`
 AC_SUBST(SHARED_MIME_INFO_PREFIX)



From fabricecolin at mail.berlios.de  Sat Feb 28 03:46:22 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sat, 28 Feb 2009 03:46:22 +0100
Subject: [Pinot-svn] r1563 - trunk/Tokenize
Message-ID: <200902280246.n1S2kMb7022077@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-28 03:46:18 +0100 (Sat, 28 Feb 2009)
New Revision: 1563

Modified:
   trunk/Tokenize/Makefile.am
Log:
HtmlParser files.


Modified: trunk/Tokenize/Makefile.am
===================================================================
--- trunk/Tokenize/Makefile.am	2009-02-18 11:29:22 UTC (rev 1562)
+++ trunk/Tokenize/Makefile.am	2009-02-28 02:46:18 UTC (rev 1563)
@@ -10,6 +10,7 @@
 	$(top_srcdir)/Tokenize/filters/FilterFactory.h \
 	$(top_srcdir)/Tokenize/filters/GMimeMboxFilter.h \
 	$(top_srcdir)/Tokenize/filters/HtmlFilter.h \
+	$(top_srcdir)/Tokenize/filters/HtmlParser.h \
 	$(top_srcdir)/Tokenize/filters/TagLibMusicFilter.h \
 	$(top_srcdir)/Tokenize/filters/TextFilter.h \
 	$(top_srcdir)/Tokenize/filters/XmlFilter.h
@@ -57,6 +58,7 @@
 	$(top_srcdir)/Tokenize/filters/Filter.cc \
 	$(top_srcdir)/Tokenize/filters/FilterFactory.cc \
 	$(top_srcdir)/Tokenize/filters/HtmlFilter.cc \
+	$(top_srcdir)/Tokenize/filters/HtmlParser.cc \
 	$(top_srcdir)/Tokenize/filters/TextFilter.cc \
 	$(top_srcdir)/Tokenize/filters/XmlFilter.cc
 



From fabricecolin at mail.berlios.de  Sat Feb 28 07:37:50 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sat, 28 Feb 2009 07:37:50 +0100
Subject: [Pinot-svn] r1564 - in trunk: Core UI/GTK2/src
Message-ID: <200902280637.n1S6boGd029851@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-28 07:37:41 +0100 (Sat, 28 Feb 2009)
New Revision: 1564

Modified:
   trunk/Core/PinotSettings.cpp
   trunk/Core/pinot-dbus-daemon.cpp
   trunk/Core/pinot-index.cpp
   trunk/UI/GTK2/src/pinot.cc
Log:
PinotSettings::getInstance() will initialize libxml2.
HtmlFilter doesn't need initializing any more.
Don't unload filters at exit time to avoid a so far unexplained crash.


Modified: trunk/Core/PinotSettings.cpp
===================================================================
--- trunk/Core/PinotSettings.cpp	2009-02-28 02:46:18 UTC (rev 1563)
+++ trunk/Core/PinotSettings.cpp	2009-02-28 06:37:41 UTC (rev 1564)
@@ -36,6 +36,7 @@
 
 #include <glibmm/convert.h>
 #include <glibmm/date.h>
+#include <libxml/parser.h>
 #include <libxml++/parsers/domparser.h>
 #include <libxml++/nodes/node.h>
 #include <libxml++/nodes/textnode.h>
@@ -161,6 +162,9 @@
 
 PinotSettings &PinotSettings::getInstance(void)
 {
+	// Initialize libxml2
+	xmlInitParser();
+
 	return m_instance;
 }
 

Modified: trunk/Core/pinot-dbus-daemon.cpp
===================================================================
--- trunk/Core/pinot-dbus-daemon.cpp	2009-02-28 02:46:18 UTC (rev 1563)
+++ trunk/Core/pinot-dbus-daemon.cpp	2009-02-28 06:37:41 UTC (rev 1564)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005-2008 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -91,8 +91,6 @@
 
 	// Close everything
 	ModuleFactory::unloadModules();
-	Dijon::FilterFactory::unloadFilters();
-	Dijon::HtmlFilter::shutdown();
 
 	// Restore the stream buffers
 	if (g_coutBuf != NULL)
@@ -438,7 +436,6 @@
 	}
 	DownloaderInterface::initialize();
 	// Load filter libraries, if any
-	Dijon::HtmlFilter::initialize();
 	Dijon::FilterFactory::loadFilters(string(LIBDIR) + "/pinot/filters");
 	Dijon::FilterFactory::loadFilters(confDirectory + "/filters");
 	// Load backends, if any

Modified: trunk/Core/pinot-index.cpp
===================================================================
--- trunk/Core/pinot-index.cpp	2009-02-28 02:46:18 UTC (rev 1563)
+++ trunk/Core/pinot-index.cpp	2009-02-28 06:37:41 UTC (rev 1564)
@@ -167,8 +167,6 @@
 {
 	// Close everything
 	ModuleFactory::unloadModules();
-	Dijon::FilterFactory::unloadFilters();
-	Dijon::HtmlFilter::shutdown();
 	DownloaderInterface::shutdown();
 	MIMEScanner::shutdown();
 }
@@ -285,7 +283,6 @@
 		cerr << "Couldn't load MIME settings" << endl;
 	}
 	DownloaderInterface::initialize();
-	Dijon::HtmlFilter::initialize();
 	Dijon::FilterFactory::loadFilters(string(LIBDIR) + string("/pinot/filters"));
 	ModuleFactory::loadModules(string(LIBDIR) + string("/pinot/backends"));
 	ModuleFactory::loadModules(confDirectory + "/backends");

Modified: trunk/UI/GTK2/src/pinot.cc
===================================================================
--- trunk/UI/GTK2/src/pinot.cc	2009-02-28 02:46:18 UTC (rev 1563)
+++ trunk/UI/GTK2/src/pinot.cc	2009-02-28 06:37:41 UTC (rev 1564)
@@ -74,8 +74,6 @@
 
 	// Close everything
 	ModuleFactory::unloadModules();
-	Dijon::FilterFactory::unloadFilters();
-	Dijon::HtmlFilter::shutdown();
 
 	// Restore the stream buffers
 	if (g_coutBuf != NULL)
@@ -247,7 +245,6 @@
 	}
 	DownloaderInterface::initialize();
 	// Load filter libraries, if any
-	Dijon::HtmlFilter::initialize();
 	Dijon::FilterFactory::loadFilters(string(LIBDIR) + "/pinot/filters");
 	Dijon::FilterFactory::loadFilters(confDirectory + "/filters");
 	// Load backends, if any



From fabricecolin at mail.berlios.de  Sat Feb 28 12:37:33 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sat, 28 Feb 2009 12:37:33 +0100
Subject: [Pinot-svn] r1565 - trunk/Core
Message-ID: <200902281137.n1SBbX3J014105@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-28 12:37:26 +0100 (Sat, 28 Feb 2009)
New Revision: 1565

Modified:
   trunk/Core/DaemonState.cpp
   trunk/Core/DaemonState.h
Log:
Flush the index explicitely when a crawler returns and no other is started.


Modified: trunk/Core/DaemonState.cpp
===================================================================
--- trunk/Core/DaemonState.cpp	2009-02-28 06:37:41 UTC (rev 1564)
+++ trunk/Core/DaemonState.cpp	2009-02-28 11:37:26 UTC (rev 1565)
@@ -430,7 +430,7 @@
 #ifdef DEBUG
 		cout << "DaemonState::crawl_location: crawling was stopped" << endl;
 #endif
-		return true;
+		return false;
 	}
 
 	if (locationToCrawl.empty() == true)
@@ -529,8 +529,10 @@
 	m_reload = true;
 }
 
-void DaemonState::start_crawling(void)
+bool DaemonState::start_crawling(void)
 {
+	bool startedCrawler = false;
+
 	if (write_lock_lists() == true)
 	{
 #ifdef DEBUG
@@ -546,7 +548,7 @@
 			{
 				PinotSettings::IndexableLocation nextLocation(m_crawlQueue.front());
 
-				crawl_location(nextLocation);
+				startedCrawler = crawl_location(nextLocation);
 			}
 			else if (m_fullScan == true)
 			{
@@ -576,6 +578,7 @@
 		unlock_lists();
 	}
 
+	return startedCrawler;
 }
 
 void DaemonState::stop_crawling(void)
@@ -621,15 +624,6 @@
 		cout << "DaemonState::on_thread_end: done crawling " << pCrawlerThread->getDirectory() << endl;
 #endif
 
-		// Explicitely flush the index once a directory has been crawled
-		IndexInterface *pIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
-		if (pIndex != NULL)
-		{
-			pIndex->flush();
-
-			delete pIndex;
-		}
-
 		if (isStopped == false)
 		{
 			// Pop the queue
@@ -637,7 +631,17 @@
 		}
 		// Else, the directory wasn't fully crawled so better leave it in the queue
 
-		start_crawling();
+		if (start_crawling() == false)
+		{
+			// Flush the index if no new crawler was started
+			IndexInterface *pIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
+			if (pIndex != NULL)
+			{
+				pIndex->flush();
+
+				delete pIndex;
+			}
+		}
 	}
 	else if (type == "IndexingThread")
 	{

Modified: trunk/Core/DaemonState.h
===================================================================
--- trunk/Core/DaemonState.h	2009-02-28 06:37:41 UTC (rev 1564)
+++ trunk/Core/DaemonState.h	2009-02-28 11:37:26 UTC (rev 1565)
@@ -84,7 +84,7 @@
 
 		void reload(void);
 
-		void start_crawling(void);
+		bool start_crawling(void);
 
 		void stop_crawling(void);
 



From fabricecolin at mail.berlios.de  Sat Feb 28 13:44:15 2009
From: fabricecolin at mail.berlios.de (fabricecolin at mail.berlios.de)
Date: Sat, 28 Feb 2009 13:44:15 +0100
Subject: [Pinot-svn] r1566 - trunk/Utils
Message-ID: <200902281244.n1SCiF2i028095@sheep.berlios.de>

Author: fabricecolin
Date: 2009-02-28 13:44:09 +0100 (Sat, 28 Feb 2009)
New Revision: 1566

Modified:
   trunk/Utils/Url.cpp
Log:
Missing include.


Modified: trunk/Utils/Url.cpp
===================================================================
--- trunk/Utils/Url.cpp	2009-02-28 11:37:26 UTC (rev 1565)
+++ trunk/Utils/Url.cpp	2009-02-28 12:44:09 UTC (rev 1566)
@@ -17,6 +17,7 @@
  */
 
 #include <stdio.h>
+#include <unistd.h>
 #include <iostream>
 #include <glibmm/miscutils.h>
 



