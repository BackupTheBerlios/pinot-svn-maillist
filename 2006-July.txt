From fabricecolin at berlios.de  Tue Jul  4 13:29:12 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 4 Jul 2006 13:29:12 +0200
Subject: [Pinot-svn] r341 - trunk/po
Message-ID: <200607041129.k64BTCJE030913@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-04 13:29:03 +0200 (Tue, 04 Jul 2006)
New Revision: 341

Modified:
   trunk/po/es.po
   trunk/po/fr.po
Log:
Updated translations.


Modified: trunk/po/es.po
===================================================================
--- trunk/po/es.po	2006-07-03 13:39:30 UTC (rev 340)
+++ trunk/po/es.po	2006-07-04 11:29:03 UTC (rev 341)
@@ -8,7 +8,7 @@
 msgstr ""
 "Project-Id-Version: pinot 0.49\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2006-06-09 23:18+0800\n"
+"POT-Creation-Date: 2006-06-29 22:27+0800\n"
 "PO-Revision-Date: 2006-01-30 16:44+0800\n"
 "Last-Translator: Jes?s Tramullas <jesus at tramullas.com>\n"
 "Language-Team: es <jesus at tramullas.com>\n"
@@ -24,20 +24,20 @@
 msgid "Current User"
 msgstr "Usuario"
 
-#: UI/GTK2/src/EnginesTree.cpp:339 UI/GTK2/src/mainWindow.cc:230
-#: UI/GTK2/src/mainWindow.cc:332 UI/GTK2/src/mainWindow.cc:335
-#: UI/GTK2/src/mainWindow.cc:517 UI/GTK2/src/mainWindow.cc:970
-#: UI/GTK2/src/mainWindow.cc:1026 UI/GTK2/src/mainWindow.cc:1046
-#: UI/GTK2/src/mainWindow.cc:1081 UI/GTK2/src/mainWindow.cc:1644
-#: UI/GTK2/src/PinotSettings.cpp:204 UI/GTK2/src/PinotSettings.cpp:926
-#: UI/GTK2/src/PinotSettings.cpp:982
+#: UI/GTK2/src/EnginesTree.cpp:339 UI/GTK2/src/mainWindow.cc:234
+#: UI/GTK2/src/mainWindow.cc:344 UI/GTK2/src/mainWindow.cc:347
+#: UI/GTK2/src/mainWindow.cc:573 UI/GTK2/src/mainWindow.cc:1165
+#: UI/GTK2/src/mainWindow.cc:1221 UI/GTK2/src/mainWindow.cc:1241
+#: UI/GTK2/src/mainWindow.cc:1276 UI/GTK2/src/mainWindow.cc:1800
+#: UI/GTK2/src/mainWindow.cc:1863 UI/GTK2/src/PinotSettings.cpp:216
+#: UI/GTK2/src/PinotSettings.cpp:1016 UI/GTK2/src/PinotSettings.cpp:1072
 msgid "My Documents"
 msgstr "Mis documentos"
 
-#: UI/GTK2/src/EnginesTree.cpp:343 UI/GTK2/src/mainWindow.cc:338
-#: UI/GTK2/src/mainWindow.cc:341 UI/GTK2/src/MboxHandler.cpp:159
-#: UI/GTK2/src/PinotSettings.cpp:205 UI/GTK2/src/PinotSettings.cpp:927
-#: UI/GTK2/src/PinotSettings.cpp:983 UI/GTK2/src/prefsDialog_glade.cc:112
+#: UI/GTK2/src/EnginesTree.cpp:343 UI/GTK2/src/mainWindow.cc:350
+#: UI/GTK2/src/mainWindow.cc:353 UI/GTK2/src/MboxHandler.cpp:200
+#: UI/GTK2/src/PinotSettings.cpp:217 UI/GTK2/src/PinotSettings.cpp:1017
+#: UI/GTK2/src/PinotSettings.cpp:1073 UI/GTK2/src/prefsDialog_glade.cc:112
 msgid "My Email"
 msgstr "Mi email"
 
@@ -50,7 +50,7 @@
 msgstr "Directorio"
 
 #: UI/GTK2/src/importDialog.cc:115 UI/GTK2/src/IndexTree.cpp:68
-#: UI/GTK2/src/ResultsTree.cpp:129
+#: UI/GTK2/src/ResultsTree.cpp:131
 msgid "URL"
 msgstr "URL"
 
@@ -95,7 +95,7 @@
 msgid "Apply label:"
 msgstr "Etiqueta aplicada:"
 
-#: UI/GTK2/src/importDialog_glade.cc:90 UI/GTK2/src/mainWindow_glade.cc:204
+#: UI/GTK2/src/importDialog_glade.cc:90 UI/GTK2/src/mainWindow_glade.cc:213
 msgid "Import"
 msgstr "Importar"
 
@@ -107,7 +107,7 @@
 msgid "Index location"
 msgstr "Localizaci?n del ?ndice"
 
-#: UI/GTK2/src/indexDialog_glade.cc:62 UI/GTK2/src/queryDialog_glade.cc:60
+#: UI/GTK2/src/indexDialog_glade.cc:62 UI/GTK2/src/queryDialog_glade.cc:65
 msgid "Name:"
 msgstr "Nombre:"
 
@@ -119,7 +119,7 @@
 msgid "External index"
 msgstr "?ndice externo"
 
-#: UI/GTK2/src/IndexTree.cpp:63 UI/GTK2/src/ResultsTree.cpp:120
+#: UI/GTK2/src/IndexTree.cpp:63 UI/GTK2/src/ResultsTree.cpp:121
 msgid "Title"
 msgstr "T?tulo"
 
@@ -147,355 +147,375 @@
 msgid "Last Run"
 msgstr "?ltima ejecuci?n"
 
-#: UI/GTK2/src/mainWindow.cc:175
+#: UI/GTK2/src/mainWindow.cc:179
 msgid "Summary"
 msgstr "Sumario"
 
-#: UI/GTK2/src/mainWindow.cc:208
+#: UI/GTK2/src/mainWindow.cc:212
 msgid "Add index"
 msgstr "A?adir ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:209
+#: UI/GTK2/src/mainWindow.cc:213
 msgid "Remove index"
 msgstr "Borrar ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:225
+#: UI/GTK2/src/mainWindow.cc:229
 msgid "Ready"
 msgstr "Listo"
 
-#: UI/GTK2/src/mainWindow.cc:269
+#: UI/GTK2/src/mainWindow.cc:273
 msgid "N/A"
 msgstr "Desconocido"
 
-#: UI/GTK2/src/mainWindow.cc:279
+#: UI/GTK2/src/mainWindow.cc:283
 msgid "<undefined>"
 msgstr "<indefinido>"
 
-#: UI/GTK2/src/mainWindow.cc:455
+#: UI/GTK2/src/mainWindow.cc:502
 msgid "Result location is"
 msgstr "La localizaci?n del resultado es"
 
-#: UI/GTK2/src/mainWindow.cc:527
+#: UI/GTK2/src/mainWindow.cc:583
 msgid "Document location is"
 msgstr "La localizaci?n del documento es"
 
-#: UI/GTK2/src/mainWindow.cc:766
+#: UI/GTK2/src/mainWindow.cc:900
 msgid "Showing"
 msgstr "Mostrando"
 
-#: UI/GTK2/src/mainWindow.cc:771
+#: UI/GTK2/src/mainWindow.cc:905
 msgid "off"
 msgstr "desactivado"
 
-#: UI/GTK2/src/mainWindow.cc:776
+#: UI/GTK2/src/mainWindow.cc:910
 msgid "documents, starting at"
 msgstr "documentos comenzando en"
 
-#: UI/GTK2/src/mainWindow.cc:812
+#: UI/GTK2/src/mainWindow.cc:946
 msgid "Query"
 msgstr "B?squeda"
 
-#: UI/GTK2/src/mainWindow.cc:816 UI/GTK2/src/mainWindow.cc:2672
+#: UI/GTK2/src/mainWindow.cc:950 UI/GTK2/src/mainWindow.cc:2929
 msgid "on"
 msgstr "en"
 
-#: UI/GTK2/src/mainWindow.cc:820
+#: UI/GTK2/src/mainWindow.cc:954
 msgid "ended"
 msgstr "finalizado"
 
-#: UI/GTK2/src/mainWindow.cc:899
+#: UI/GTK2/src/mainWindow.cc:1032
+msgid "More Like"
+msgstr "M?s como"
+
+#: UI/GTK2/src/mainWindow.cc:1094
 msgid "Updated label(s)"
 msgstr "Etiqueta(s) actualizada(s)"
 
-#: UI/GTK2/src/mainWindow.cc:980
+#: UI/GTK2/src/mainWindow.cc:1175
 msgid "Updated document"
 msgstr "Documento actualizado"
 
-#: UI/GTK2/src/mainWindow.cc:995
+#: UI/GTK2/src/mainWindow.cc:1190
 msgid "Indexed"
 msgstr "Indizado"
 
-#: UI/GTK2/src/mainWindow.cc:1047
+#: UI/GTK2/src/mainWindow.cc:1242
 msgid "Unindexed document(s)"
 msgstr "Documento(s) no indizado(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1092
+#: UI/GTK2/src/mainWindow.cc:1287
 msgid "Updated document properties"
 msgstr "Propiedades del documento actualizadas"
 
-#: UI/GTK2/src/mainWindow.cc:1139
+#: UI/GTK2/src/mainWindow.cc:1334
 msgid "Couldn't rename index, name"
 msgstr "No se pudo renombrar ?ndice, nombre"
 
-#: UI/GTK2/src/mainWindow.cc:1143 UI/GTK2/src/mainWindow.cc:1978
-#: UI/GTK2/src/mainWindow.cc:2506
+#: UI/GTK2/src/mainWindow.cc:1338 UI/GTK2/src/mainWindow.cc:2232
+#: UI/GTK2/src/mainWindow.cc:2763
 msgid "is already in use"
 msgstr "ya est? en uso"
 
-#: UI/GTK2/src/mainWindow.cc:1156
+#: UI/GTK2/src/mainWindow.cc:1351
 msgid "Couldn't rename index"
 msgstr "No se pudo renombrar el ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:1169
+#: UI/GTK2/src/mainWindow.cc:1364
 msgid "Edited index"
 msgstr "?ndice editado"
 
-#: UI/GTK2/src/mainWindow.cc:1599 UI/GTK2/src/mainWindow.cc:1688
+#: UI/GTK2/src/mainWindow.cc:1751 UI/GTK2/src/mainWindow.cc:2387
+msgid "Live query"
+msgstr "B?squeda activa"
+
+#: UI/GTK2/src/mainWindow.cc:1776
+msgid "Couldn't find query"
+msgstr "No se pudo a?adir la b?squeda"
+
+#: UI/GTK2/src/mainWindow.cc:1815 UI/GTK2/src/mainWindow.cc:1907
 msgid "Please set a location for the index first"
 msgstr "Por favor, primero fije una localizaci?n para el ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:1635
+#: UI/GTK2/src/mainWindow.cc:1854
 msgid "Import Document(s)"
 msgstr "Importar Documento(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1761 UI/GTK2/src/WorkerThreads.cpp:425
-#: UI/GTK2/src/WorkerThreads.cpp:1142
+#: UI/GTK2/src/mainWindow.cc:1980 UI/GTK2/src/WorkerThreads.cpp:425
+#: UI/GTK2/src/WorkerThreads.cpp:1172
 msgid "Index"
 msgstr "?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:1765 UI/GTK2/src/WorkerThreads.cpp:429
-#: UI/GTK2/src/WorkerThreads.cpp:1146
+#: UI/GTK2/src/mainWindow.cc:1984 UI/GTK2/src/WorkerThreads.cpp:429
+#: UI/GTK2/src/WorkerThreads.cpp:1176
 msgid "doesn't exist"
 msgstr "no existe"
 
-#: UI/GTK2/src/mainWindow.cc:1866
+#: UI/GTK2/src/mainWindow.cc:2120
 msgid "Remove this document from the index ?"
 msgstr "?Borrar este documento del ?ndice?"
 
-#: UI/GTK2/src/mainWindow.cc:1885
+#: UI/GTK2/src/mainWindow.cc:2139
 msgid "Remove these documents from the index ?"
 msgstr "?Borrar este documento del ?ndice?"
 
-#: UI/GTK2/src/mainWindow.cc:1929
+#: UI/GTK2/src/mainWindow.cc:2183
 msgid "A metasearch tool for the Free Desktop"
 msgstr "Una herramienta metabuscador para el escritorio libre"
 
-#: UI/GTK2/src/mainWindow.cc:1930
+#: UI/GTK2/src/mainWindow.cc:2184
 msgid "(C) 2005-2006 Fabrice Colin"
 msgstr "(C) 2005-2006 Fabrice Colin"
 
-#: UI/GTK2/src/mainWindow.cc:1974
+#: UI/GTK2/src/mainWindow.cc:2228
 msgid "Index name"
 msgstr "Nombre del ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:1989
+#: UI/GTK2/src/mainWindow.cc:2243
 msgid "Couldn't add index"
 msgstr "No se pudo a?adir el ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:2003
+#: UI/GTK2/src/mainWindow.cc:2257
 msgid "Added new index"
 msgstr "A?adido un nuevo ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:2038
+#: UI/GTK2/src/mainWindow.cc:2292
 msgid "Couldn't remove index"
 msgstr "No se pudo borrar el ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:2133
-msgid "Live query"
-msgstr "B?squeda activa"
-
-#: UI/GTK2/src/mainWindow.cc:2290
+#: UI/GTK2/src/mainWindow.cc:2544
 msgid "At least one task hasn't completed yet. Quit now ?"
 msgstr "Al menos una tarea no ha finalizado. ?Parar ahora?"
 
-#: UI/GTK2/src/mainWindow.cc:2502
+#: UI/GTK2/src/mainWindow.cc:2759
 msgid "Query name"
 msgstr "Nombre la b?squeda"
 
-#: UI/GTK2/src/mainWindow.cc:2529
+#: UI/GTK2/src/mainWindow.cc:2786
 msgid "Couldn't update query"
 msgstr "No se pudo actualizar la b?squeda"
 
-#: UI/GTK2/src/mainWindow.cc:2537
+#: UI/GTK2/src/mainWindow.cc:2794
 msgid "Edited query"
 msgstr "B?squeda editada"
 
-#: UI/GTK2/src/mainWindow.cc:2544
+#: UI/GTK2/src/mainWindow.cc:2801
 msgid "Couldn't add query"
 msgstr "No se pudo a?adir la b?squeda"
 
-#: UI/GTK2/src/mainWindow.cc:2552
+#: UI/GTK2/src/mainWindow.cc:2809
 msgid "Added new query"
 msgstr "A?adida una nueva b?squeda"
 
-#: UI/GTK2/src/mainWindow.cc:2566
+#: UI/GTK2/src/mainWindow.cc:2823
 msgid "Query is not set"
 msgstr "B?squeda no definida"
 
-#: UI/GTK2/src/mainWindow.cc:2577
+#: UI/GTK2/src/mainWindow.cc:2834
 msgid "No search engine selected"
 msgstr "Motor de b?squeda no seleccionado"
 
-#: UI/GTK2/src/mainWindow.cc:2659
+#: UI/GTK2/src/mainWindow.cc:2916
 msgid "Please set the Google API key first"
 msgstr "Por favor, primero configure el API de Google"
 
-#: UI/GTK2/src/mainWindow.cc:2668
+#: UI/GTK2/src/mainWindow.cc:2925
 msgid "Running query"
 msgstr "Ejecutando la b?squeda"
 
-#: UI/GTK2/src/mainWindow.cc:2775
+#: UI/GTK2/src/mainWindow.cc:3049
 msgid "is already indexed or is being indexed"
 msgstr "ya ha sido indizado, o se est? indizando"
 
-#: UI/GTK2/src/mainWindow_glade.cc:118
+#: UI/GTK2/src/mainWindow.cc:3147
+msgid "No default application defined for type"
+msgstr "No hay aplicaci?n predefinida para el tipo"
+
+#: UI/GTK2/src/mainWindow_glade.cc:121
 msgid "Query:"
 msgstr "B?squeda:"
 
-#: UI/GTK2/src/mainWindow_glade.cc:130
+#: UI/GTK2/src/mainWindow_glade.cc:133
 msgid "Edit"
 msgstr "Editar"
 
-#: UI/GTK2/src/mainWindow_glade.cc:139
+#: UI/GTK2/src/mainWindow_glade.cc:142
 msgid "Stored queries"
 msgstr "B?squedas guardadas"
 
-#: UI/GTK2/src/mainWindow_glade.cc:174
+#: UI/GTK2/src/mainWindow_glade.cc:177
 msgid "Search Engine"
 msgstr "Motor de b?squeda"
 
-#: UI/GTK2/src/mainWindow_glade.cc:177
+#: UI/GTK2/src/mainWindow_glade.cc:180
 msgid "Host Name"
 msgstr "Nombre del servidor"
 
-#: UI/GTK2/src/mainWindow_glade.cc:180
+#: UI/GTK2/src/mainWindow_glade.cc:183
 msgid "Show Extract"
 msgstr "Mostrar extra?dos"
 
-#: UI/GTK2/src/mainWindow_glade.cc:183
+#: UI/GTK2/src/mainWindow_glade.cc:186
 msgid "Group By"
 msgstr "Agrupar por"
 
-#: UI/GTK2/src/mainWindow_glade.cc:186
+#: UI/GTK2/src/mainWindow_glade.cc:189
 msgid "Clear List"
 msgstr "Limpiar la lista"
 
-#: UI/GTK2/src/mainWindow_glade.cc:192
+#: UI/GTK2/src/mainWindow_glade.cc:195
+msgid "More Like This"
+msgstr "Documentos similares"
+
+#: UI/GTK2/src/mainWindow_glade.cc:201
 msgid "Vie_w"
 msgstr "Ver"
 
-#: UI/GTK2/src/mainWindow_glade.cc:195
+#: UI/GTK2/src/mainWindow_glade.cc:204
 msgid "View Cache"
 msgstr "Ver la cache"
 
-#: UI/GTK2/src/mainWindow_glade.cc:198 UI/GTK2/src/mainWindow_glade.cc:234
+#: UI/GTK2/src/mainWindow_glade.cc:207 UI/GTK2/src/mainWindow_glade.cc:243
 msgid "_Index"
 msgstr "?ndice"
 
-#: UI/GTK2/src/mainWindow_glade.cc:201
+#: UI/GTK2/src/mainWindow_glade.cc:210
 msgid "List Contents Of"
 msgstr "Listar el contenido de"
 
-#: UI/GTK2/src/mainWindow_glade.cc:210
+#: UI/GTK2/src/mainWindow_glade.cc:219
 msgid "View"
 msgstr "Ver"
 
-#: UI/GTK2/src/mainWindow_glade.cc:213
+#: UI/GTK2/src/mainWindow_glade.cc:222
 msgid "Update"
 msgstr "Actualizar"
 
-#: UI/GTK2/src/mainWindow_glade.cc:216
+#: UI/GTK2/src/mainWindow_glade.cc:225
 msgid "Unindex"
 msgstr "Des-indizar"
 
-#: UI/GTK2/src/mainWindow_glade.cc:219
+#: UI/GTK2/src/mainWindow_glade.cc:228
 #: UI/GTK2/src/propertiesDialog_glade.cc:146
 msgid "Properties"
 msgstr "Propiedades"
 
-#: UI/GTK2/src/mainWindow_glade.cc:222
+#: UI/GTK2/src/mainWindow_glade.cc:231
 msgid "_About"
 msgstr "Sobre"
 
-#: UI/GTK2/src/mainWindow_glade.cc:225
+#: UI/GTK2/src/mainWindow_glade.cc:234
 msgid "_Session"
 msgstr "Sesi?n"
 
-#: UI/GTK2/src/mainWindow_glade.cc:228
+#: UI/GTK2/src/mainWindow_glade.cc:237
 msgid "_Edit"
 msgstr "Editar"
 
-#: UI/GTK2/src/mainWindow_glade.cc:231
+#: UI/GTK2/src/mainWindow_glade.cc:240
 msgid "_Results"
 msgstr "Resultados"
 
-#: UI/GTK2/src/mainWindow_glade.cc:237
+#: UI/GTK2/src/mainWindow_glade.cc:246
 msgid "_Help"
 msgstr "Ayuda"
 
-#: UI/GTK2/src/mainWindow_glade.cc:364
+#: UI/GTK2/src/mainWindow_glade.cc:375
 msgid "Pinot"
 msgstr "Pinot"
 
 #: UI/GTK2/src/pinot.cc:156
+msgid "Unknown"
+msgstr "Desconocido"
+
+#: UI/GTK2/src/pinot.cc:157
 msgid "Danish"
 msgstr "Dan?s"
 
-#: UI/GTK2/src/pinot.cc:157
+#: UI/GTK2/src/pinot.cc:158
 msgid "Dutch"
 msgstr "Holand?s"
 
-#: UI/GTK2/src/pinot.cc:158
+#: UI/GTK2/src/pinot.cc:159
 msgid "English"
 msgstr "Ingl?s"
 
-#: UI/GTK2/src/pinot.cc:159
+#: UI/GTK2/src/pinot.cc:160
 msgid "Finnish"
 msgstr "Finland?s"
 
-#: UI/GTK2/src/pinot.cc:160
+#: UI/GTK2/src/pinot.cc:161
 msgid "French"
 msgstr "Franc?s"
 
-#: UI/GTK2/src/pinot.cc:161
+#: UI/GTK2/src/pinot.cc:162
 msgid "German"
 msgstr "Alem?n"
 
-#: UI/GTK2/src/pinot.cc:162
+#: UI/GTK2/src/pinot.cc:163
 msgid "Italian"
 msgstr "Italiano"
 
-#: UI/GTK2/src/pinot.cc:163
+#: UI/GTK2/src/pinot.cc:164
 msgid "Norwegian"
 msgstr "Noruego"
 
-#: UI/GTK2/src/pinot.cc:164
+#: UI/GTK2/src/pinot.cc:165
 msgid "Portuguese"
 msgstr "Portugu?s"
 
-#: UI/GTK2/src/pinot.cc:165
+#: UI/GTK2/src/pinot.cc:166
 msgid "Russian"
 msgstr "Ruso"
 
-#: UI/GTK2/src/pinot.cc:166
+#: UI/GTK2/src/pinot.cc:167
 msgid "Spanish"
 msgstr "Espa?ol"
 
-#: UI/GTK2/src/pinot.cc:167
+#: UI/GTK2/src/pinot.cc:168
 msgid "Swedish"
 msgstr "Sueco"
 
-#: UI/GTK2/src/pinot.cc:190 UI/GTK2/src/pinot.cc:198
+#: UI/GTK2/src/pinot.cc:192 UI/GTK2/src/pinot.cc:200
 msgid "Couldn't open index"
 msgstr "No se pudo abrir el ?ndice"
 
-#: UI/GTK2/src/pinot.cc:208
+#: UI/GTK2/src/pinot.cc:210
 msgid "Couldn't create history database"
 msgstr "No se pudo crear la base de datos del hist?rico"
 
-#: UI/GTK2/src/PinotSettings.cpp:209
+#: UI/GTK2/src/PinotSettings.cpp:222
 msgid "Important"
 msgstr "Importante"
 
-#: UI/GTK2/src/PinotSettings.cpp:210
+#: UI/GTK2/src/PinotSettings.cpp:223
 msgid "New"
 msgstr "Nuevo"
 
-#: UI/GTK2/src/PinotSettings.cpp:211
+#: UI/GTK2/src/PinotSettings.cpp:224
 msgid "Personal"
 msgstr "Personal"
 
-#: UI/GTK2/src/PinotSettings.cpp:762
+#: UI/GTK2/src/PinotSettings.cpp:852
 msgid "Unclassified"
 msgstr "No clasificado"
 
@@ -571,15 +591,15 @@
 msgid "Preferences"
 msgstr "Preferencias"
 
-#: UI/GTK2/src/propertiesDialog.cc:46
+#: UI/GTK2/src/propertiesDialog.cc:49
 msgid "Label"
 msgstr "Etiqueta"
 
-#: UI/GTK2/src/propertiesDialog.cc:84
-msgid "Unknown"
-msgstr "Desconocido"
+#: UI/GTK2/src/propertiesDialog.cc:62
+msgid "Per document"
+msgstr "Documento"
 
-#: UI/GTK2/src/propertiesDialog_glade.cc:66
+#: UI/GTK2/src/prorpertiesDialog_glade.cc:66
 msgid "Language:"
 msgstr "Idioma:"
 
@@ -591,59 +611,59 @@
 msgid "Any"
 msgstr "Cualquiera"
 
-#: UI/GTK2/src/queryDialog_glade.cc:70
+#: UI/GTK2/src/queryDialog_glade.cc:75
 msgid "Index all results with label"
 msgstr "Indizar todos los resultados con la etiqueta"
 
-#: UI/GTK2/src/queryDialog_glade.cc:72
+#: UI/GTK2/src/queryDialog_glade.cc:77
 msgid "Any of the words:"
 msgstr "Cualquiera de las palabras:"
 
-#: UI/GTK2/src/queryDialog_glade.cc:73
+#: UI/GTK2/src/queryDialog_glade.cc:78
 msgid "File name:"
 msgstr "Nombre de fichero:"
 
-#: UI/GTK2/src/queryDialog_glade.cc:74
+#: UI/GTK2/src/queryDialog_glade.cc:79
 msgid "Number of results:"
 msgstr "N?mero de resultados:"
 
-#: UI/GTK2/src/queryDialog_glade.cc:77
+#: UI/GTK2/src/queryDialog_glade.cc:82
 msgid "Host name:"
 msgstr "Nombre del servidor:"
 
-#: UI/GTK2/src/queryDialog_glade.cc:78
+#: UI/GTK2/src/queryDialog_glade.cc:83
 msgid "None of the words:"
 msgstr "Ninguna de las palabras:"
 
-#: UI/GTK2/src/queryDialog_glade.cc:83
+#: UI/GTK2/src/queryDialog_glade.cc:88
 msgid "All engines"
 msgstr "Todos los motores"
 
-#: UI/GTK2/src/queryDialog_glade.cc:84
+#: UI/GTK2/src/queryDialog_glade.cc:89
 msgid "Limit to documents that match"
 msgstr "Limitar a los documentos que coincidan"
 
-#: UI/GTK2/src/queryDialog_glade.cc:87
+#: UI/GTK2/src/queryDialog_glade.cc:92
 msgid "the exact phrase:"
 msgstr "la frase exacta"
 
-#: UI/GTK2/src/queryDialog_glade.cc:88
+#: UI/GTK2/src/queryDialog_glade.cc:93
 msgid "the language:"
 msgstr "el idioma"
 
-#: UI/GTK2/src/queryDialog_glade.cc:92
+#: UI/GTK2/src/queryDialog_glade.cc:97
 msgid "all the words:"
 msgstr "todas las palabras:"
 
-#: UI/GTK2/src/queryDialog_glade.cc:93
+#: UI/GTK2/src/queryDialog_glade.cc:98
 msgid "the label:"
 msgstr "la etiqueta"
 
-#: UI/GTK2/src/queryDialog_glade.cc:98
+#: UI/GTK2/src/queryDialog_glade.cc:103
 msgid "Indexes only"
 msgstr "S?lo ?ndices"
 
-#: UI/GTK2/src/queryDialog_glade.cc:283
+#: UI/GTK2/src/queryDialog_glade.cc:288
 msgid "Query parameters"
 msgstr "Par?metros de b?squeda"
 
@@ -651,100 +671,100 @@
 msgid "Stopped browsing"
 msgstr "Exploraci?n detenida"
 
-#: UI/GTK2/src/WorkerThreads.cpp:437 UI/GTK2/src/WorkerThreads.cpp:638
-#: UI/GTK2/src/WorkerThreads.cpp:647 UI/GTK2/src/WorkerThreads.cpp:835
-#: UI/GTK2/src/WorkerThreads.cpp:1035 UI/GTK2/src/WorkerThreads.cpp:1154
+#: UI/GTK2/src/WorkerThreads.cpp:437 UI/GTK2/src/WorkerThreads.cpp:668
+#: UI/GTK2/src/WorkerThreads.cpp:677 UI/GTK2/src/WorkerThreads.cpp:865
+#: UI/GTK2/src/WorkerThreads.cpp:1065 UI/GTK2/src/WorkerThreads.cpp:1184
 msgid "Index error on"
 msgstr "Error en el ?ndice"
 
-#: UI/GTK2/src/WorkerThreads.cpp:542
+#: UI/GTK2/src/WorkerThreads.cpp:560
 msgid "Stopped querying"
 msgstr "B?squeda detenida"
 
-#: UI/GTK2/src/WorkerThreads.cpp:554
+#: UI/GTK2/src/WorkerThreads.cpp:572
 msgid "Couldn't create search engine"
 msgstr "No se pudo crear el motor de b?squeda"
 
-#: UI/GTK2/src/WorkerThreads.cpp:565
+#: UI/GTK2/src/WorkerThreads.cpp:589
 msgid "Couldn't run query on search engine"
 msgstr "No se pudo ejecutar la b?squeda contra el motor"
 
-#: UI/GTK2/src/WorkerThreads.cpp:581
+#: UI/GTK2/src/WorkerThreads.cpp:605
 msgid "No title"
 msgstr "Sin t?tulo"
 
-#: UI/GTK2/src/WorkerThreads.cpp:629
+#: UI/GTK2/src/WorkerThreads.cpp:659
 msgid "Stopped querying index labels"
 msgstr "Detenida la b?squeda de etiquetas de ?ndice"
 
-#: UI/GTK2/src/WorkerThreads.cpp:706
+#: UI/GTK2/src/WorkerThreads.cpp:736
 msgid "Stopped retrieval of"
 msgstr "Detenida la recuperaci?n de"
 
-#: UI/GTK2/src/WorkerThreads.cpp:740
+#: UI/GTK2/src/WorkerThreads.cpp:770
 msgid "Couldn't obtain downloader for protocol"
 msgstr "No se pudo usar un recuperador para el protocolo"
 
-#: UI/GTK2/src/WorkerThreads.cpp:752
+#: UI/GTK2/src/WorkerThreads.cpp:782
 msgid "Couldn't retrieve"
 msgstr "No se pudo descargar"
 
-#: UI/GTK2/src/WorkerThreads.cpp:820
+#: UI/GTK2/src/WorkerThreads.cpp:850
 msgid "Stopped indexing"
 msgstr "Detenida la indizaci?n"
 
-#: UI/GTK2/src/WorkerThreads.cpp:865
+#: UI/GTK2/src/WorkerThreads.cpp:895
 msgid "Cannot index document type"
 msgstr "No se pudo indizar el tipo de documento"
 
-#: UI/GTK2/src/WorkerThreads.cpp:869
+#: UI/GTK2/src/WorkerThreads.cpp:899
 msgid "at"
 msgstr "a"
 
-#: UI/GTK2/src/WorkerThreads.cpp:893
+#: UI/GTK2/src/WorkerThreads.cpp:923
 msgid "Couldn't tokenize"
 msgstr "No se pudo extraer cadenas"
 
-#: UI/GTK2/src/WorkerThreads.cpp:913
+#: UI/GTK2/src/WorkerThreads.cpp:943
 msgid "Robots META tag forbids indexing"
 msgstr "La etiqueta META Robots proh?be la indizaci?n"
 
-#: UI/GTK2/src/WorkerThreads.cpp:968
+#: UI/GTK2/src/WorkerThreads.cpp:998
 msgid "Couldn't index"
 msgstr "No se pudo indizar"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1023
+#: UI/GTK2/src/WorkerThreads.cpp:1053
 msgid "Stopped unindexing document(s)"
 msgstr "Detenida la des-indizaci?n de documento(s)"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1042
+#: UI/GTK2/src/WorkerThreads.cpp:1072
 msgid "Couldn't unindex document(s)"
 msgstr "No se pudo des-indizar lo(s) documento(s)"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1127
+#: UI/GTK2/src/WorkerThreads.cpp:1157
 msgid "Stopped document update for"
 msgstr "Detenida la actualizaci?n del documento por"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1162
+#: UI/GTK2/src/WorkerThreads.cpp:1192
 msgid "Couldn't update document"
 msgstr "No se pudo actualizar el documento"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1212
+#: UI/GTK2/src/WorkerThreads.cpp:1242
 msgid "Stopped monitoring"
 msgstr "Detenida la monitorizaci?n"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1229
+#: UI/GTK2/src/WorkerThreads.cpp:1259
 msgid "No monitoring handler"
 msgstr "No hay monitorizaci?n"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1281
+#: UI/GTK2/src/WorkerThreads.cpp:1311
 msgid "Couldn't initialize file monitor"
 msgstr "No se puede inicializar el monitor de archivo"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1395
+#: UI/GTK2/src/WorkerThreads.cpp:1425
 msgid "Stopped scanning"
 msgstr "Detenida la exploraci?n"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1553
+#: UI/GTK2/src/WorkerThreads.cpp:1583
 msgid "Couldn't open directory"
 msgstr "No se pudo abrir el directorio"

Modified: trunk/po/fr.po
===================================================================
--- trunk/po/fr.po	2006-07-03 13:39:30 UTC (rev 340)
+++ trunk/po/fr.po	2006-07-04 11:29:03 UTC (rev 341)
@@ -8,7 +8,7 @@
 msgstr ""
 "Project-Id-Version: pinot 0.49\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2006-06-09 23:18+0800\n"
+"POT-Creation-Date: 2006-06-29 22:27+0800\n"
 "PO-Revision-Date: 2006-01-20 19:44+0800\n"
 "Last-Translator: Fabrice Colin <colinf at chez.com>\n"
 "Language-Team: fr <colinf at chez.com>\n"
@@ -24,20 +24,20 @@
 msgid "Current User"
 msgstr "Utilisateur"
 
-#: UI/GTK2/src/EnginesTree.cpp:339 UI/GTK2/src/mainWindow.cc:230
-#: UI/GTK2/src/mainWindow.cc:332 UI/GTK2/src/mainWindow.cc:335
-#: UI/GTK2/src/mainWindow.cc:517 UI/GTK2/src/mainWindow.cc:970
-#: UI/GTK2/src/mainWindow.cc:1026 UI/GTK2/src/mainWindow.cc:1046
-#: UI/GTK2/src/mainWindow.cc:1081 UI/GTK2/src/mainWindow.cc:1644
-#: UI/GTK2/src/PinotSettings.cpp:204 UI/GTK2/src/PinotSettings.cpp:926
-#: UI/GTK2/src/PinotSettings.cpp:982
+#: UI/GTK2/src/EnginesTree.cpp:339 UI/GTK2/src/mainWindow.cc:234
+#: UI/GTK2/src/mainWindow.cc:344 UI/GTK2/src/mainWindow.cc:347
+#: UI/GTK2/src/mainWindow.cc:573 UI/GTK2/src/mainWindow.cc:1165
+#: UI/GTK2/src/mainWindow.cc:1221 UI/GTK2/src/mainWindow.cc:1241
+#: UI/GTK2/src/mainWindow.cc:1276 UI/GTK2/src/mainWindow.cc:1800
+#: UI/GTK2/src/mainWindow.cc:1863 UI/GTK2/src/PinotSettings.cpp:216
+#: UI/GTK2/src/PinotSettings.cpp:1016 UI/GTK2/src/PinotSettings.cpp:1072
 msgid "My Documents"
 msgstr "Mes Documents"
 
-#: UI/GTK2/src/EnginesTree.cpp:343 UI/GTK2/src/mainWindow.cc:338
-#: UI/GTK2/src/mainWindow.cc:341 UI/GTK2/src/MboxHandler.cpp:159
-#: UI/GTK2/src/PinotSettings.cpp:205 UI/GTK2/src/PinotSettings.cpp:927
-#: UI/GTK2/src/PinotSettings.cpp:983 UI/GTK2/src/prefsDialog_glade.cc:112
+#: UI/GTK2/src/EnginesTree.cpp:343 UI/GTK2/src/mainWindow.cc:350
+#: UI/GTK2/src/mainWindow.cc:353 UI/GTK2/src/MboxHandler.cpp:200
+#: UI/GTK2/src/PinotSettings.cpp:217 UI/GTK2/src/PinotSettings.cpp:1017
+#: UI/GTK2/src/PinotSettings.cpp:1073 UI/GTK2/src/prefsDialog_glade.cc:112
 msgid "My Email"
 msgstr "Mon Courrier"
 
@@ -50,7 +50,7 @@
 msgstr "Repertoire"
 
 #: UI/GTK2/src/importDialog.cc:115 UI/GTK2/src/IndexTree.cpp:68
-#: UI/GTK2/src/ResultsTree.cpp:129
+#: UI/GTK2/src/ResultsTree.cpp:131
 msgid "URL"
 msgstr "URL"
 
@@ -95,7 +95,7 @@
 msgid "Apply label:"
 msgstr "Appliquer l'etiquette:"
 
-#: UI/GTK2/src/importDialog_glade.cc:90 UI/GTK2/src/mainWindow_glade.cc:204
+#: UI/GTK2/src/importDialog_glade.cc:90 UI/GTK2/src/mainWindow_glade.cc:213
 msgid "Import"
 msgstr "Importer"
 
@@ -107,7 +107,7 @@
 msgid "Index location"
 msgstr "Chemin de l'index"
 
-#: UI/GTK2/src/indexDialog_glade.cc:62 UI/GTK2/src/queryDialog_glade.cc:60
+#: UI/GTK2/src/indexDialog_glade.cc:62 UI/GTK2/src/queryDialog_glade.cc:65
 msgid "Name:"
 msgstr "Nom:"
 
@@ -119,7 +119,7 @@
 msgid "External index"
 msgstr "Index externe"
 
-#: UI/GTK2/src/IndexTree.cpp:63 UI/GTK2/src/ResultsTree.cpp:120
+#: UI/GTK2/src/IndexTree.cpp:63 UI/GTK2/src/ResultsTree.cpp:121
 msgid "Title"
 msgstr "Titre"
 
@@ -147,355 +147,375 @@
 msgid "Last Run"
 msgstr "Derniere Utilisation"
 
-#: UI/GTK2/src/mainWindow.cc:175
+#: UI/GTK2/src/mainWindow.cc:179
 msgid "Summary"
 msgstr "Sommaire"
 
-#: UI/GTK2/src/mainWindow.cc:208
+#: UI/GTK2/src/mainWindow.cc:212
 msgid "Add index"
 msgstr "Ajouter un index"
 
-#: UI/GTK2/src/mainWindow.cc:209
+#: UI/GTK2/src/mainWindow.cc:213
 msgid "Remove index"
 msgstr "Enlever un index"
 
-#: UI/GTK2/src/mainWindow.cc:225
+#: UI/GTK2/src/mainWindow.cc:229
 msgid "Ready"
 msgstr "Pret"
 
-#: UI/GTK2/src/mainWindow.cc:269
+#: UI/GTK2/src/mainWindow.cc:273
 msgid "N/A"
 msgstr "Inconnue"
 
-#: UI/GTK2/src/mainWindow.cc:279
+#: UI/GTK2/src/mainWindow.cc:283
 msgid "<undefined>"
 msgstr "<inconnu>"
 
-#: UI/GTK2/src/mainWindow.cc:455
+#: UI/GTK2/src/mainWindow.cc:502
 msgid "Result location is"
 msgstr "Le chemin du resultat est"
 
-#: UI/GTK2/src/mainWindow.cc:527
+#: UI/GTK2/src/mainWindow.cc:583
 msgid "Document location is"
 msgstr "Le chemin du document is"
 
-#: UI/GTK2/src/mainWindow.cc:766
+#: UI/GTK2/src/mainWindow.cc:900
 msgid "Showing"
 msgstr "Listant"
 
-#: UI/GTK2/src/mainWindow.cc:771
+#: UI/GTK2/src/mainWindow.cc:905
 msgid "off"
 msgstr "documents,"
 
-#: UI/GTK2/src/mainWindow.cc:776
+#: UI/GTK2/src/mainWindow.cc:910
 msgid "documents, starting at"
 msgstr "au total, a partir de"
 
-#: UI/GTK2/src/mainWindow.cc:812
+#: UI/GTK2/src/mainWindow.cc:946
 msgid "Query"
 msgstr "La recherche"
 
-#: UI/GTK2/src/mainWindow.cc:816 UI/GTK2/src/mainWindow.cc:2672
+#: UI/GTK2/src/mainWindow.cc:950 UI/GTK2/src/mainWindow.cc:2929
 msgid "on"
 msgstr "sur"
 
-#: UI/GTK2/src/mainWindow.cc:820
+#: UI/GTK2/src/mainWindow.cc:954
 msgid "ended"
 msgstr "est terminee"
 
-#: UI/GTK2/src/mainWindow.cc:899
+#: UI/GTK2/src/mainWindow.cc:1032
+msgid "More Like"
+msgstr "Similaire a"
+
+#: UI/GTK2/src/mainWindow.cc:1094
 msgid "Updated label(s)"
 msgstr "Mis a jour l(es) etiquette(s)"
 
-#: UI/GTK2/src/mainWindow.cc:980
+#: UI/GTK2/src/mainWindow.cc:1175
 msgid "Updated document"
 msgstr "Mis a jour le document"
 
-#: UI/GTK2/src/mainWindow.cc:995
+#: UI/GTK2/src/mainWindow.cc:1190
 msgid "Indexed"
 msgstr "Indexe"
 
-#: UI/GTK2/src/mainWindow.cc:1047
+#: UI/GTK2/src/mainWindow.cc:1242
 msgid "Unindexed document(s)"
 msgstr "Desindexe le(s) document(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1092
+#: UI/GTK2/src/mainWindow.cc:1287
 msgid "Updated document properties"
 msgstr "Mis a jour les proprietes du document"
 
-#: UI/GTK2/src/mainWindow.cc:1139
+#: UI/GTK2/src/mainWindow.cc:1334
 msgid "Couldn't rename index, name"
 msgstr "N'a pas pu renommer l'index, le nom"
 
-#: UI/GTK2/src/mainWindow.cc:1143 UI/GTK2/src/mainWindow.cc:1978
-#: UI/GTK2/src/mainWindow.cc:2506
+#: UI/GTK2/src/mainWindow.cc:1338 UI/GTK2/src/mainWindow.cc:2232
+#: UI/GTK2/src/mainWindow.cc:2763
 msgid "is already in use"
 msgstr "est deja utilise"
 
-#: UI/GTK2/src/mainWindow.cc:1156
+#: UI/GTK2/src/mainWindow.cc:1351
 msgid "Couldn't rename index"
 msgstr "N'a pas pu renommer l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1169
+#: UI/GTK2/src/mainWindow.cc:1364
 msgid "Edited index"
 msgstr "Edite l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1599 UI/GTK2/src/mainWindow.cc:1688
+#: UI/GTK2/src/mainWindow.cc:1751 UI/GTK2/src/mainWindow.cc:2387
+msgid "Live query"
+msgstr "Recherche"
+
+#: UI/GTK2/src/mainWindow.cc:1776
+msgid "Couldn't find query"
+msgstr "N'a pas pu trouver la recherche"
+
+#: UI/GTK2/src/mainWindow.cc:1815 UI/GTK2/src/mainWindow.cc:1907
 msgid "Please set a location for the index first"
 msgstr "Donnez un chemin a l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1635
+#: UI/GTK2/src/mainWindow.cc:1854
 msgid "Import Document(s)"
 msgstr "Import de Document(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1761 UI/GTK2/src/WorkerThreads.cpp:425
-#: UI/GTK2/src/WorkerThreads.cpp:1142
+#: UI/GTK2/src/mainWindow.cc:1980 UI/GTK2/src/WorkerThreads.cpp:425
+#: UI/GTK2/src/WorkerThreads.cpp:1172
 msgid "Index"
 msgstr "L'index"
 
-#: UI/GTK2/src/mainWindow.cc:1765 UI/GTK2/src/WorkerThreads.cpp:429
-#: UI/GTK2/src/WorkerThreads.cpp:1146
+#: UI/GTK2/src/mainWindow.cc:1984 UI/GTK2/src/WorkerThreads.cpp:429
+#: UI/GTK2/src/WorkerThreads.cpp:1176
 msgid "doesn't exist"
 msgstr "n'existe pas"
 
-#: UI/GTK2/src/mainWindow.cc:1866
+#: UI/GTK2/src/mainWindow.cc:2120
 msgid "Remove this document from the index ?"
 msgstr "Enlever ce document de l'index ?"
 
-#: UI/GTK2/src/mainWindow.cc:1885
+#: UI/GTK2/src/mainWindow.cc:2139
 msgid "Remove these documents from the index ?"
 msgstr "Enlever ces documents de l'index ?"
 
-#: UI/GTK2/src/mainWindow.cc:1929
+#: UI/GTK2/src/mainWindow.cc:2183
 msgid "A metasearch tool for the Free Desktop"
 msgstr "Un outil de recherche pour le Bureau Libre"
 
-#: UI/GTK2/src/mainWindow.cc:1930
+#: UI/GTK2/src/mainWindow.cc:2184
 msgid "(C) 2005-2006 Fabrice Colin"
 msgstr "(C) 2005-2006 Fabrice Colin"
 
-#: UI/GTK2/src/mainWindow.cc:1974
+#: UI/GTK2/src/mainWindow.cc:2228
 msgid "Index name"
 msgstr "Nom de l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1989
+#: UI/GTK2/src/mainWindow.cc:2243
 msgid "Couldn't add index"
 msgstr "N'a pas pu ajouter l'index"
 
-#: UI/GTK2/src/mainWindow.cc:2003
+#: UI/GTK2/src/mainWindow.cc:2257
 msgid "Added new index"
 msgstr "Ajoute un nouvel index"
 
-#: UI/GTK2/src/mainWindow.cc:2038
+#: UI/GTK2/src/mainWindow.cc:2292
 msgid "Couldn't remove index"
 msgstr "N'a pas pu enlever l'index"
 
-#: UI/GTK2/src/mainWindow.cc:2133
-msgid "Live query"
-msgstr "Recherche"
-
-#: UI/GTK2/src/mainWindow.cc:2290
+#: UI/GTK2/src/mainWindow.cc:2544
 msgid "At least one task hasn't completed yet. Quit now ?"
 msgstr "Au moins une tache n'est pas terminee. Quitter maintenant ?"
 
-#: UI/GTK2/src/mainWindow.cc:2502
+#: UI/GTK2/src/mainWindow.cc:2759
 msgid "Query name"
 msgstr "Nom de la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2529
+#: UI/GTK2/src/mainWindow.cc:2786
 msgid "Couldn't update query"
 msgstr "N'a pas pu mettre a jour la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2537
+#: UI/GTK2/src/mainWindow.cc:2794
 msgid "Edited query"
 msgstr "Edite la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2544
+#: UI/GTK2/src/mainWindow.cc:2801
 msgid "Couldn't add query"
 msgstr "N'a pas pu ajouter la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2552
+#: UI/GTK2/src/mainWindow.cc:2809
 msgid "Added new query"
 msgstr "Ajoute une nouvelle recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2566
+#: UI/GTK2/src/mainWindow.cc:2823
 msgid "Query is not set"
 msgstr "Recherche indefinie"
 
-#: UI/GTK2/src/mainWindow.cc:2577
+#: UI/GTK2/src/mainWindow.cc:2834
 msgid "No search engine selected"
 msgstr "Pas de moteur selectionne"
 
-#: UI/GTK2/src/mainWindow.cc:2659
+#: UI/GTK2/src/mainWindow.cc:2916
 msgid "Please set the Google API key first"
 msgstr "Configurez la clef de l'API Google "
 
-#: UI/GTK2/src/mainWindow.cc:2668
+#: UI/GTK2/src/mainWindow.cc:2925
 msgid "Running query"
 msgstr "Recherche en cours"
 
-#: UI/GTK2/src/mainWindow.cc:2775
+#: UI/GTK2/src/mainWindow.cc:3049
 msgid "is already indexed or is being indexed"
 msgstr "est deja indexe ou est en cours d'indexation"
 
-#: UI/GTK2/src/mainWindow_glade.cc:118
+#: UI/GTK2/src/mainWindow.cc:3147
+msgid "No default application defined for type"
+msgstr "Pas d'application definie pour le type"
+
+#: UI/GTK2/src/mainWindow_glade.cc:121
 msgid "Query:"
 msgstr "Recherche:"
 
-#: UI/GTK2/src/mainWindow_glade.cc:130
+#: UI/GTK2/src/mainWindow_glade.cc:133
 msgid "Edit"
 msgstr "Editer"
 
-#: UI/GTK2/src/mainWindow_glade.cc:139
+#: UI/GTK2/src/mainWindow_glade.cc:142
 msgid "Stored queries"
 msgstr "Recherches sauvegardees"
 
-#: UI/GTK2/src/mainWindow_glade.cc:174
+#: UI/GTK2/src/mainWindow_glade.cc:177
 msgid "Search Engine"
 msgstr "Moteurs"
 
-#: UI/GTK2/src/mainWindow_glade.cc:177
+#: UI/GTK2/src/mainWindow_glade.cc:180
 msgid "Host Name"
 msgstr "Nom de machine"
 
-#: UI/GTK2/src/mainWindow_glade.cc:180
+#: UI/GTK2/src/mainWindow_glade.cc:183
 msgid "Show Extract"
 msgstr "Montrer l'Extrait"
 
-#: UI/GTK2/src/mainWindow_glade.cc:183
+#: UI/GTK2/src/mainWindow_glade.cc:186
 msgid "Group By"
 msgstr "Grouper Par"
 
-#: UI/GTK2/src/mainWindow_glade.cc:186
+#: UI/GTK2/src/mainWindow_glade.cc:189
 msgid "Clear List"
 msgstr "Nettoyer la Liste"
 
-#: UI/GTK2/src/mainWindow_glade.cc:192
+#: UI/GTK2/src/mainWindow_glade.cc:195
+msgid "More Like This"
+msgstr "Documents similaires"
+
+#: UI/GTK2/src/mainWindow_glade.cc:201
 msgid "Vie_w"
 msgstr "Voir"
 
-#: UI/GTK2/src/mainWindow_glade.cc:195
+#: UI/GTK2/src/mainWindow_glade.cc:204
 msgid "View Cache"
 msgstr "Voir le Cache"
 
-#: UI/GTK2/src/mainWindow_glade.cc:198 UI/GTK2/src/mainWindow_glade.cc:234
+#: UI/GTK2/src/mainWindow_glade.cc:207 UI/GTK2/src/mainWindow_glade.cc:243
 msgid "_Index"
 msgstr "Index"
 
-#: UI/GTK2/src/mainWindow_glade.cc:201
+#: UI/GTK2/src/mainWindow_glade.cc:210
 msgid "List Contents Of"
 msgstr "Lister le Contenu de"
 
-#: UI/GTK2/src/mainWindow_glade.cc:210
+#: UI/GTK2/src/mainWindow_glade.cc:219
 msgid "View"
 msgstr "Voir"
 
-#: UI/GTK2/src/mainWindow_glade.cc:213
+#: UI/GTK2/src/mainWindow_glade.cc:222
 msgid "Update"
 msgstr "Mettre a Jour"
 
-#: UI/GTK2/src/mainWindow_glade.cc:216
+#: UI/GTK2/src/mainWindow_glade.cc:225
 msgid "Unindex"
 msgstr "Desindexer"
 
-#: UI/GTK2/src/mainWindow_glade.cc:219
+#: UI/GTK2/src/mainWindow_glade.cc:228
 #: UI/GTK2/src/propertiesDialog_glade.cc:146
 msgid "Properties"
 msgstr "Proprietes"
 
-#: UI/GTK2/src/mainWindow_glade.cc:222
+#: UI/GTK2/src/mainWindow_glade.cc:231
 msgid "_About"
 msgstr "A Propos"
 
-#: UI/GTK2/src/mainWindow_glade.cc:225
+#: UI/GTK2/src/mainWindow_glade.cc:234
 msgid "_Session"
 msgstr "Session"
 
-#: UI/GTK2/src/mainWindow_glade.cc:228
+#: UI/GTK2/src/mainWindow_glade.cc:237
 msgid "_Edit"
 msgstr "Editer"
 
-#: UI/GTK2/src/mainWindow_glade.cc:231
+#: UI/GTK2/src/mainWindow_glade.cc:240
 msgid "_Results"
 msgstr "Resultats"
 
-#: UI/GTK2/src/mainWindow_glade.cc:237
+#: UI/GTK2/src/mainWindow_glade.cc:246
 msgid "_Help"
 msgstr "Aide"
 
-#: UI/GTK2/src/mainWindow_glade.cc:364
+#: UI/GTK2/src/mainWindow_glade.cc:375
 msgid "Pinot"
 msgstr "Pinot"
 
 #: UI/GTK2/src/pinot.cc:156
+msgid "Unknown"
+msgstr "Inconnu"
+
+#: UI/GTK2/src/pinot.cc:157
 msgid "Danish"
 msgstr "Danois"
 
-#: UI/GTK2/src/pinot.cc:157
+#: UI/GTK2/src/pinot.cc:158
 msgid "Dutch"
 msgstr "Hollandais"
 
-#: UI/GTK2/src/pinot.cc:158
+#: UI/GTK2/src/pinot.cc:159
 msgid "English"
 msgstr "Anglais"
 
-#: UI/GTK2/src/pinot.cc:159
+#: UI/GTK2/src/pinot.cc:160
 msgid "Finnish"
 msgstr "Finlandais"
 
-#: UI/GTK2/src/pinot.cc:160
+#: UI/GTK2/src/pinot.cc:161
 msgid "French"
 msgstr "Francais"
 
-#: UI/GTK2/src/pinot.cc:161
+#: UI/GTK2/src/pinot.cc:162
 msgid "German"
 msgstr "Allemand"
 
-#: UI/GTK2/src/pinot.cc:162
+#: UI/GTK2/src/pinot.cc:163
 msgid "Italian"
 msgstr "Italien"
 
-#: UI/GTK2/src/pinot.cc:163
+#: UI/GTK2/src/pinot.cc:164
 msgid "Norwegian"
 msgstr "Norvegien"
 
-#: UI/GTK2/src/pinot.cc:164
+#: UI/GTK2/src/pinot.cc:165
 msgid "Portuguese"
 msgstr "Portugais"
 
-#: UI/GTK2/src/pinot.cc:165
+#: UI/GTK2/src/pinot.cc:166
 msgid "Russian"
 msgstr "Russe"
 
-#: UI/GTK2/src/pinot.cc:166
+#: UI/GTK2/src/pinot.cc:167
 msgid "Spanish"
 msgstr "Espagnol"
 
-#: UI/GTK2/src/pinot.cc:167
+#: UI/GTK2/src/pinot.cc:168
 msgid "Swedish"
 msgstr "Suedois"
 
-#: UI/GTK2/src/pinot.cc:190 UI/GTK2/src/pinot.cc:198
+#: UI/GTK2/src/pinot.cc:192 UI/GTK2/src/pinot.cc:200
 msgid "Couldn't open index"
 msgstr "N'a pas pu ouvrir l'index"
 
-#: UI/GTK2/src/pinot.cc:208
+#: UI/GTK2/src/pinot.cc:210
 msgid "Couldn't create history database"
 msgstr "N'a pas pu creer la base d'historiques"
 
-#: UI/GTK2/src/PinotSettings.cpp:209
+#: UI/GTK2/src/PinotSettings.cpp:222
 msgid "Important"
 msgstr "Important"
 
-#: UI/GTK2/src/PinotSettings.cpp:210
+#: UI/GTK2/src/PinotSettings.cpp:223
 msgid "New"
 msgstr "Nouveau"
 
-#: UI/GTK2/src/PinotSettings.cpp:211
+#: UI/GTK2/src/PinotSettings.cpp:224
 msgid "Personal"
 msgstr "Personnel"
 
-#: UI/GTK2/src/PinotSettings.cpp:762
+#: UI/GTK2/src/PinotSettings.cpp:852
 msgid "Unclassified"
 msgstr "Sans classification"
 
@@ -571,13 +591,13 @@
 msgid "Preferences"
 msgstr "Preferences"
 
-#: UI/GTK2/src/propertiesDialog.cc:46
+#: UI/GTK2/src/propertiesDialog.cc:49
 msgid "Label"
 msgstr "L'etiquette"
 
-#: UI/GTK2/src/propertiesDialog.cc:84
-msgid "Unknown"
-msgstr "Inconnu"
+#: UI/GTK2/src/propertiesDialog.cc:62
+msgid "Per document"
+msgstr "Par document"
 
 #: UI/GTK2/src/propertiesDialog_glade.cc:66
 msgid "Language:"
@@ -591,59 +611,59 @@
 msgid "Any"
 msgstr "N'importe"
 
-#: UI/GTK2/src/queryDialog_glade.cc:70
+#: UI/GTK2/src/queryDialog_glade.cc:75
 msgid "Index all results with label"
 msgstr "Indexer tous les resultats avec l'etiquette"
 
-#: UI/GTK2/src/queryDialog_glade.cc:72
+#: UI/GTK2/src/queryDialog_glade.cc:77
 msgid "Any of the words:"
 msgstr "N'importe lequel des mots:"
 
-#: UI/GTK2/src/queryDialog_glade.cc:73
+#: UI/GTK2/src/queryDialog_glade.cc:78
 msgid "File name:"
 msgstr "Nom de ficher:"
 
-#: UI/GTK2/src/queryDialog_glade.cc:74
+#: UI/GTK2/src/queryDialog_glade.cc:79
 msgid "Number of results:"
 msgstr "Nombre de resultats:"
 
-#: UI/GTK2/src/queryDialog_glade.cc:77
+#: UI/GTK2/src/queryDialog_glade.cc:82
 msgid "Host name:"
 msgstr "Nom de machine:"
 
-#: UI/GTK2/src/queryDialog_glade.cc:78
+#: UI/GTK2/src/queryDialog_glade.cc:83
 msgid "None of the words:"
 msgstr "Aucun des mots:"
 
-#: UI/GTK2/src/queryDialog_glade.cc:83
+#: UI/GTK2/src/queryDialog_glade.cc:88
 msgid "All engines"
 msgstr "Tous les moteurs"
 
-#: UI/GTK2/src/queryDialog_glade.cc:84
+#: UI/GTK2/src/queryDialog_glade.cc:89
 msgid "Limit to documents that match"
 msgstr "Limiter aux documents qui ont"
 
-#: UI/GTK2/src/queryDialog_glade.cc:87
+#: UI/GTK2/src/queryDialog_glade.cc:92
 msgid "the exact phrase:"
 msgstr "la phrase"
 
-#: UI/GTK2/src/queryDialog_glade.cc:88
+#: UI/GTK2/src/queryDialog_glade.cc:93
 msgid "the language:"
 msgstr "la langue"
 
-#: UI/GTK2/src/queryDialog_glade.cc:92
+#: UI/GTK2/src/queryDialog_glade.cc:97
 msgid "all the words:"
 msgstr "tous les mots"
 
-#: UI/GTK2/src/queryDialog_glade.cc:93
+#: UI/GTK2/src/queryDialog_glade.cc:98
 msgid "the label:"
 msgstr "l'etiquette"
 
-#: UI/GTK2/src/queryDialog_glade.cc:98
+#: UI/GTK2/src/queryDialog_glade.cc:103
 msgid "Indexes only"
 msgstr "Indexes"
 
-#: UI/GTK2/src/queryDialog_glade.cc:283
+#: UI/GTK2/src/queryDialog_glade.cc:288
 msgid "Query parameters"
 msgstr "Parametres de la recherche"
 
@@ -651,100 +671,100 @@
 msgid "Stopped browsing"
 msgstr "Arrete de parcourir l'index"
 
-#: UI/GTK2/src/WorkerThreads.cpp:437 UI/GTK2/src/WorkerThreads.cpp:638
-#: UI/GTK2/src/WorkerThreads.cpp:647 UI/GTK2/src/WorkerThreads.cpp:835
-#: UI/GTK2/src/WorkerThreads.cpp:1035 UI/GTK2/src/WorkerThreads.cpp:1154
+#: UI/GTK2/src/WorkerThreads.cpp:437 UI/GTK2/src/WorkerThreads.cpp:668
+#: UI/GTK2/src/WorkerThreads.cpp:677 UI/GTK2/src/WorkerThreads.cpp:865
+#: UI/GTK2/src/WorkerThreads.cpp:1065 UI/GTK2/src/WorkerThreads.cpp:1184
 msgid "Index error on"
 msgstr "Erreur sur l'index"
 
-#: UI/GTK2/src/WorkerThreads.cpp:542
+#: UI/GTK2/src/WorkerThreads.cpp:560
 msgid "Stopped querying"
 msgstr "Arrete la recherche"
 
-#: UI/GTK2/src/WorkerThreads.cpp:554
+#: UI/GTK2/src/WorkerThreads.cpp:572
 msgid "Couldn't create search engine"
 msgstr "N'a pas pu creer le moteur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:565
+#: UI/GTK2/src/WorkerThreads.cpp:589
 msgid "Couldn't run query on search engine"
 msgstr "N'a pas pu lancer la recherche sur le moteur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:581
+#: UI/GTK2/src/WorkerThreads.cpp:605
 msgid "No title"
 msgstr "Pas de titre"
 
-#: UI/GTK2/src/WorkerThreads.cpp:629
+#: UI/GTK2/src/WorkerThreads.cpp:659
 msgid "Stopped querying index labels"
 msgstr "Arrete la recherche d'etiquettes"
 
-#: UI/GTK2/src/WorkerThreads.cpp:706
+#: UI/GTK2/src/WorkerThreads.cpp:736
 msgid "Stopped retrieval of"
 msgstr "Arrete le telechargement de"
 
-#: UI/GTK2/src/WorkerThreads.cpp:740
+#: UI/GTK2/src/WorkerThreads.cpp:770
 msgid "Couldn't obtain downloader for protocol"
 msgstr "N'a pas pu obtenir un brouteur pour"
 
-#: UI/GTK2/src/WorkerThreads.cpp:752
+#: UI/GTK2/src/WorkerThreads.cpp:782
 msgid "Couldn't retrieve"
 msgstr "N'a pas pu telecharger"
 
-#: UI/GTK2/src/WorkerThreads.cpp:820
+#: UI/GTK2/src/WorkerThreads.cpp:850
 msgid "Stopped indexing"
 msgstr "Arrete l'indexation"
 
-#: UI/GTK2/src/WorkerThreads.cpp:865
+#: UI/GTK2/src/WorkerThreads.cpp:895
 msgid "Cannot index document type"
 msgstr "Impossible d'indexer ce type de documents"
 
-#: UI/GTK2/src/WorkerThreads.cpp:869
+#: UI/GTK2/src/WorkerThreads.cpp:899
 msgid "at"
 msgstr "a"
 
-#: UI/GTK2/src/WorkerThreads.cpp:893
+#: UI/GTK2/src/WorkerThreads.cpp:923
 msgid "Couldn't tokenize"
 msgstr "N'a pas pu extraire les termes de"
 
-#: UI/GTK2/src/WorkerThreads.cpp:913
+#: UI/GTK2/src/WorkerThreads.cpp:943
 msgid "Robots META tag forbids indexing"
 msgstr "Le META tag Robots interdit d'indexer"
 
-#: UI/GTK2/src/WorkerThreads.cpp:968
+#: UI/GTK2/src/WorkerThreads.cpp:998
 msgid "Couldn't index"
 msgstr "N'a pas pu indexer"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1023
+#: UI/GTK2/src/WorkerThreads.cpp:1053
 msgid "Stopped unindexing document(s)"
 msgstr "Arrete d'indexer les document(s)"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1042
+#: UI/GTK2/src/WorkerThreads.cpp:1072
 msgid "Couldn't unindex document(s)"
 msgstr "N'a pas pu desindexer le(s) document(s)"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1127
+#: UI/GTK2/src/WorkerThreads.cpp:1157
 msgid "Stopped document update for"
 msgstr "Arrete la mise a jour pour"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1162
+#: UI/GTK2/src/WorkerThreads.cpp:1192
 msgid "Couldn't update document"
 msgstr "N'a pas pu mettre a jour le document"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1212
+#: UI/GTK2/src/WorkerThreads.cpp:1242
 msgid "Stopped monitoring"
 msgstr "Arrete la surveillance"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1229
+#: UI/GTK2/src/WorkerThreads.cpp:1259
 msgid "No monitoring handler"
 msgstr "Pas de moniteur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1281
+#: UI/GTK2/src/WorkerThreads.cpp:1311
 msgid "Couldn't initialize file monitor"
 msgstr "N'a pas pu initializer le moniteur de fichiers"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1395
+#: UI/GTK2/src/WorkerThreads.cpp:1425
 msgid "Stopped scanning"
 msgstr "Arrete de scanner"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1553
+#: UI/GTK2/src/WorkerThreads.cpp:1583
 msgid "Couldn't open directory"
 msgstr "N'a pas pu ouvrir le repertoire"



From fabricecolin at berlios.de  Wed Jul  5 13:07:15 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 5 Jul 2006 13:07:15 +0200
Subject: [Pinot-svn] r342 - trunk
Message-ID: <200607051107.k65B7Fos009080@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-05 13:07:09 +0200 (Wed, 05 Jul 2006)
New Revision: 342

Modified:
   trunk/NEWS
Log:
Releasing v0.50.


Modified: trunk/NEWS
===================================================================
--- trunk/NEWS	2006-07-04 11:29:03 UTC (rev 341)
+++ trunk/NEWS	2006-07-05 11:07:09 UTC (rev 342)
@@ -1,4 +1,4 @@
-??? version_0_5_0
+2006/07/05 version_0_5_0
 Tokenize :
  - switched to pdftotext, which seems to support more files than pdftohtml
 SQL :
@@ -15,6 +15,7 @@
   (if they are indexed) and creates a "More Like ..." query
  - set the indexed status icon when results are indexed
  - view results on double clicks
+ - show a message if there is no application defined for a file's type
  - most tree columns can be sorted at last ! :-)
  - work-around for bizarre bug that causes a segfault when creating a query
   that indexes and labels results based on a language filter



From fabricecolin at berlios.de  Wed Jul  5 13:41:51 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 5 Jul 2006 13:41:51 +0200
Subject: [Pinot-svn] r343 - in trunk: . Collect Search UI/GTK2/src
Message-ID: <200607051141.k65Bfp3R021782@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-05 13:41:48 +0200 (Wed, 05 Jul 2006)
New Revision: 343

Modified:
   trunk/Collect/pinot-collect.1
   trunk/README
   trunk/Search/pinot-search.1
   trunk/UI/GTK2/src/pinot.1
Log:
Clarified README, updated date of man pages.


Modified: trunk/Collect/pinot-collect.1
===================================================================
--- trunk/Collect/pinot-collect.1	2006-07-05 11:07:09 UTC (rev 342)
+++ trunk/Collect/pinot-collect.1	2006-07-05 11:41:48 UTC (rev 343)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-COLLECT "1" "June 2006" "pinot-collect - pinot 0.50" "User Commands"
+.TH PINOT-COLLECT "1" "July 2006" "pinot-collect - pinot 0.50" "User Commands"
 .SH NAME
 pinot-collect \- Download an URL from the command-line
 .SH SYNOPSIS

Modified: trunk/README
===================================================================
--- trunk/README	2006-07-05 11:07:09 UTC (rev 342)
+++ trunk/README	2006-07-05 11:41:48 UTC (rev 343)
@@ -1,9 +1,9 @@
-Pinot, http://pinot.berlios.de/
+Pinot http://pinot.berlios.de/
 
-Pinot is a metasearch tool for the X-Window desktop. It acts as a front-end for
-search engines such as Google (with support for the SOAP API), All The Web,
-Ask Jeeves, etc.. and allows one to index relevant results locally and query
-the index.
+Pinot is a metasearch tool for the Free Desktop. It acts as a front-end
+for search engines such as Google (with support for the SOAP API), Yahoo!,
+MSN, etc... and allows one to index relevant results locally and query the
+index.
 It was developed and tested on GNU/Linux and should work on other Unix-like systems.
 
 Dependencies :
@@ -53,8 +53,9 @@
 unzip							5.52
 http://www.info-zip.org/pub/infozip/UnZip.html
 
-pdftohtml						0.36
-http://pdftohtml.sourceforge.net/
+pdftotext						3.00
+http://www.foolabs.com/xpdf/
+http://poppler.freedesktop.org/
 
 antiword						0.36.1
 http://www.winfield.demon.nl/
@@ -65,13 +66,9 @@
 TagLib							1.4
 http://ktown.kde.org/~wheeler/taglib/
 
-glademm (4)						2.12.0 cvs
-http://home.wtal.de/petig/Gtk/index.html
-
 (1) enabled with "./configure --with-http=neon|curl"
 (2) enabled with "./configure --with-soap=yes"
 (3) for building only
-(4) to optionally regenerate the GUI code
 
 FAQ :
 -----

Modified: trunk/Search/pinot-search.1
===================================================================
--- trunk/Search/pinot-search.1	2006-07-05 11:07:09 UTC (rev 342)
+++ trunk/Search/pinot-search.1	2006-07-05 11:41:48 UTC (rev 343)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-SEARCH "1" "June 2006" "pinot-search - pinot 0.50" "User Commands"
+.TH PINOT-SEARCH "1" "July 2006" "pinot-search - pinot 0.50" "User Commands"
 .SH NAME
 pinot-search \- Query search engines from the command-line
 .SH SYNOPSIS

Modified: trunk/UI/GTK2/src/pinot.1
===================================================================
--- trunk/UI/GTK2/src/pinot.1	2006-07-05 11:07:09 UTC (rev 342)
+++ trunk/UI/GTK2/src/pinot.1	2006-07-05 11:41:48 UTC (rev 343)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT "1" "June 2006" "pinot - pinot 0.50" "User Commands"
+.TH PINOT "1" "July 2006" "pinot - pinot 0.50" "User Commands"
 .SH NAME
 pinot \- A metasearch tool for the Free Desktop
 .SH SYNOPSIS



From fabricecolin at berlios.de  Wed Jul  5 14:01:03 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 5 Jul 2006 14:01:03 +0200
Subject: [Pinot-svn] r344 - tags
Message-ID: <200607051201.k65C13kg027681@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-05 14:01:01 +0200 (Wed, 05 Jul 2006)
New Revision: 344

Added:
   tags/version_0_5_0/
Log:
Version 0.50, the "Allez Les Bleus !" release.


Copied: tags/version_0_5_0 (from rev 343, trunk)



From fabricecolin at berlios.de  Fri Jul  7 14:41:01 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 7 Jul 2006 14:41:01 +0200
Subject: [Pinot-svn] r345 - trunk/Search
Message-ID: <200607071241.k67Cf1JJ007640@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-07 14:40:59 +0200 (Fri, 07 Jul 2006)
New Revision: 345

Modified:
   trunk/Search/AbstractGenerator.cpp
Log:
Catch all possible exceptions thrown by Xapian in generateAbstract() to avoid
aborting the whole query. For instance, since position lists are not supported
by the remote backend, generateAbstract() would throw an exception and thus
prevent from querying a remote index.


Modified: trunk/Search/AbstractGenerator.cpp
===================================================================
--- trunk/Search/AbstractGenerator.cpp	2006-07-05 12:01:01 UTC (rev 344)
+++ trunk/Search/AbstractGenerator.cpp	2006-07-07 12:40:59 UTC (rev 345)
@@ -136,6 +136,7 @@
 #ifdef DEBUG
 			cout << "AbstractGenerator::generateAbstract: " << error.get_msg() << endl;
 #endif
+			return "";
 		}
 
 #ifdef DEBUG
@@ -166,31 +167,41 @@
 		<< bestPosition << ":" << startPosition << " with weight " << bestWeight << endl;
 #endif
 
-	// Go through the position list of each term
-	for (Xapian::TermIterator termIter = m_pIndex->termlist_begin(docId);
-		termIter != m_pIndex->termlist_end(docId); ++termIter)
+	try
 	{
-		string termName(*termIter);
-
-		// Skip prefixed terms
-		if (isupper((int)termName[0]) != 0)
+		// Go through the position list of each term
+		for (Xapian::TermIterator termIter = m_pIndex->termlist_begin(docId);
+			termIter != m_pIndex->termlist_end(docId); ++termIter)
 		{
-			continue;
-		}
+			string termName(*termIter);
 
-		for (Xapian::PositionIterator positionIter = m_pIndex->positionlist_begin(docId, termName);
-			positionIter != m_pIndex->positionlist_end(docId, termName); ++positionIter)
-		{
-			Xapian::termpos termPos = *positionIter;
+			// Skip prefixed terms
+			if (isupper((int)termName[0]) != 0)
+			{
+				continue;
+			}
 
-			// ...and get those that fall in the abstract window
-			if ((startPosition <= termPos + 1) &&
-				(termPos < startPosition + m_wordsCount))
+			for (Xapian::PositionIterator positionIter = m_pIndex->positionlist_begin(docId, termName);
+				positionIter != m_pIndex->positionlist_end(docId, termName); ++positionIter)
 			{
-				wordsBuffer[termPos] = termName;
+				Xapian::termpos termPos = *positionIter;
+
+				// ...and get those that fall in the abstract window
+				if ((startPosition <= termPos + 1) &&
+					(termPos < startPosition + m_wordsCount))
+				{
+					wordsBuffer[termPos] = termName;
+				}
 			}
 		}
 	}
+	catch (const Xapian::Error &error)
+	{
+#ifdef DEBUG
+		cout << "AbstractGenerator::generateAbstract: " << error.get_msg() << endl;
+#endif
+		return "";
+	}
 
 	for (map<Xapian::termpos, string>::iterator wordIter = wordsBuffer.begin();
 		wordIter != wordsBuffer.end(); ++wordIter)



From fabricecolin at berlios.de  Wed Jul 12 14:15:15 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 12 Jul 2006 14:15:15 +0200
Subject: [Pinot-svn] r346 - in trunk: . UI/GTK2/src po
Message-ID: <200607121215.k6CCFFXE003567@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-12 14:15:12 +0200 (Wed, 12 Jul 2006)
New Revision: 346

Added:
   trunk/UI/GTK2/src/pinot-dbus-daemon.cc
   trunk/UI/GTK2/src/pinot-dbus-daemon.xml
Modified:
   trunk/Makefile.am
   trunk/configure.in
   trunk/pinot.spec.in
   trunk/po/POTFILES.in
Log:
First shot at writing a D-Bus daemon that supports the method
de.berlios.Pinot.Index.
Bindings can be generated from pinot-dbus-daemon.xml with dbus-binding-tool.


Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2006-07-07 12:40:59 UTC (rev 345)
+++ trunk/Makefile.am	2006-07-12 12:15:12 UTC (rev 346)
@@ -8,7 +8,8 @@
 	pinot.spec textcat_conf.txt Search/Plugins/*src Search/Plugins/*.xml \
 	Collect/pinot-collect.1 Search/pinot-search.1 UI/GTK2/src/pinot.1 \
 	globalconfig.xml UI/GTK2/xapian-powered.png UI/GTK2/pinot.png \
-	UI/GTK2/metase-gtk2.glade UI/GTK2/metase-gtk2.gladep
+	UI/GTK2/metase-gtk2.glade UI/GTK2/metase-gtk2.gladep \
+	UI/GTK2/src/pinot-dbus-daemon.xml
 
 man_MANS = Collect/pinot-collect.1 Search/pinot-search.1 UI/GTK2/src/pinot.1
 
@@ -18,6 +19,7 @@
 	$(INSTALL_DATA) UI/GTK2/xapian-powered.png $(DESTDIR)$(datadir)/pinot/xapian-powered.png
 	$(INSTALL_DATA) UI/GTK2/metase-gtk2.glade $(DESTDIR)$(datadir)/pinot/metase-gtk2.glade
 	$(INSTALL_DATA) UI/GTK2/metase-gtk2.gladep $(DESTDIR)$(datadir)/pinot/metase-gtk2.gladep
+	$(INSTALL_DATA) UI/GTK2/src/pinot-dbus-daemon.xml $(DESTDIR)$(datadir)/pinot/pinot-dbus-daemon.xml
 	$(INSTALL_DATA) textcat_conf.txt $(DESTDIR)$(datadir)/pinot/textcat_conf.txt
 	$(mkinstalldirs) $(DESTDIR)$(datadir)/pinot/engines
 	$(INSTALL_DATA) Search/Plugins/*.src $(DESTDIR)$(datadir)/pinot/engines/

Added: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-07-07 12:40:59 UTC (rev 345)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-07-12 12:15:12 UTC (rev 346)
@@ -0,0 +1,398 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+#include <libintl.h>
+#include <getopt.h>
+#include <iostream>
+#include <fstream>
+#include <glibmm.h>
+#include <glibmm/thread.h>
+#include <glibmm/ustring.h>
+#include <glibmm/convert.h>
+#include <glibmm/object.h>
+extern "C"
+{
+#define DBUS_API_SUBJECT_TO_CHANGE
+#include <dbus/dbus.h>
+#include <dbus/dbus-glib.h>
+#include <dbus/dbus-glib-lowlevel.h>
+}
+#include <glibmm/main.h>
+
+#include "DocumentInfo.h"
+#include "TokenizerFactory.h"
+#include "Languages.h"
+#include "MIMEScanner.h"
+#include "XapianDatabase.h"
+#include "XapianDatabaseFactory.h"
+#include "QueryHistory.h"
+#include "ViewHistory.h"
+#include "DownloaderInterface.h"
+#include "config.h"
+#include "NLS.h"
+#include "PinotSettings.h"
+
+using namespace std;
+
+static ofstream outputFile;
+static streambuf *coutBuf = NULL;
+static streambuf *cerrBuf = NULL;
+static struct option g_longOptions[] = {
+	{"help", 0, 0, 'h'},
+	{"version", 0, 0, 'v'},
+	{0, 0, 0, 0}
+};
+static const char *g_pinotDBusService = "de.berlios.Pinot";
+static const char *g_pinotDBusObjectPath = "/de/berlios/Pinot";
+static DBusHandlerResult objectPathHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData);
+static DBusObjectPathVTable g_callVTable = {
+	NULL,
+	objectPathHandler,
+	NULL,
+};
+static Glib::RefPtr<Glib::MainLoop> g_refMainLoop;
+
+static void closeAll(void)
+{
+	cout << "Exiting..." << endl;
+
+	// Close all indexes we may have opened
+	XapianDatabaseFactory::closeAll();
+
+	// Close the tokenizer libraries
+	TokenizerFactory::unloadTokenizers();
+
+	// Restore the stream buffers
+	if (coutBuf != NULL)
+	{
+		cout.rdbuf(coutBuf);
+	}
+	if (cerrBuf != NULL)
+	{
+		cerr.rdbuf(cerrBuf);
+	}
+	outputFile.close();
+
+	DownloaderInterface::shutdown();
+	MIMEScanner::shutdown();
+}
+
+static void quitAll(int sigNum)
+{
+	if (g_refMainLoop->is_running() == true)
+	{
+		cout << "Quitting..." << endl;
+
+		g_refMainLoop->quit();
+	}
+}
+
+static DBusHandlerResult objectPathHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
+{
+#ifdef DEBUG
+	cout << "objectPathHandler: called" << endl;
+#endif
+	if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "Index") == TRUE)
+	{
+		return DBUS_HANDLER_RESULT_HANDLED;
+	}
+
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+static DBusHandlerResult messageBusFilter(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
+{
+	DBusMessage *pReply = NULL;
+	bool processedMessage = false;
+
+#ifdef DEBUG
+	cout << "messageBusFilter: called" << endl;
+#endif
+
+	// Are we about to be disconnected ?
+	if (dbus_message_is_signal(pMessage, DBUS_INTERFACE_LOCAL, "Disconnected") == TRUE)
+	{
+		// FIXME: is this legal ?
+		Glib::RefPtr<Glib::MainLoop> g_refMainLoop = Glib::MainLoop::create(true);
+
+		// Tell the main loop to quit
+		g_refMainLoop->quit();
+
+		return DBUS_HANDLER_RESULT_HANDLED;
+	}
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "Index") == TRUE)
+	{
+		DBusError error;
+		char *pTitle = NULL;
+		char *pLocation = NULL;
+		char *pType = NULL;
+		char *pLanguage = NULL;
+		char *pLabel = NULL;
+		dbus_uint64_t docId = 0;
+
+		// Simple types are returned as const references and don't need to be freed
+		dbus_error_init(&error);
+		if (dbus_message_get_args(pMessage, &error,
+			DBUS_TYPE_STRING, &pTitle,
+			DBUS_TYPE_STRING, &pLocation,
+			DBUS_TYPE_STRING, &pType,
+			DBUS_TYPE_STRING, &pLanguage,
+			DBUS_TYPE_STRING, &pLabel,
+			DBUS_TYPE_UINT64, &docId,
+			DBUS_TYPE_INVALID) == TRUE)
+		{
+			DocumentInfo docInfo(pTitle, pLocation, pType, pLanguage);
+
+#ifdef DEBUG
+			cout << "messageBusFilter: received " << pTitle << ", " << pLocation
+				<< ", " << pType << ", " << pLanguage << ", " << pLabel
+				<< ", " << docId << endl;
+#endif
+			// FIXME: index docInfo
+
+			// Prepare the reply
+			pReply = dbus_message_new_method_return(pMessage);
+			if (pReply != NULL)
+			{
+				dbus_message_append_args(pReply,
+					DBUS_TYPE_UINT64, &docId, DBUS_TYPE_INVALID);
+			}
+		}
+		else
+		{
+			// Use the error message as reply
+			pReply = dbus_message_new_error(pMessage, error.name, error.message);
+		}
+		dbus_error_free(&error);
+
+		processedMessage = true;
+	}
+#ifdef DEBUG
+	else cout << "messageBusFilter: message for foreign object" << endl;
+#endif
+
+	// Send a reply ?
+	if (pReply != NULL)
+	{
+		if (dbus_message_get_no_reply(pMessage) == FALSE)
+		{
+			dbus_connection_send(pConnection, pReply, NULL);
+#ifdef DEBUG
+			cout << "messageBusFilter: sent reply" << endl;
+#endif
+		}
+#ifdef DEBUG
+		else cout << "messageBusFilter: no need to send a reply" << endl;
+#endif
+
+		dbus_message_unref(pReply);
+	}
+
+	if (processedMessage == true)
+	{
+		return DBUS_HANDLER_RESULT_HANDLED;
+	}
+
+	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+}
+
+int main(int argc, char **argv)
+{
+	string prefixDir(PREFIX);
+	struct sigaction newAction;
+	int longOptionIndex = 0;
+
+	// Look at the options
+	int optionChar = getopt_long(argc, argv, "hv", g_longOptions, &longOptionIndex);
+	while (optionChar != -1)
+	{
+		switch (optionChar)
+		{
+			case 'h':
+				// Help
+				cout << "pinot-dbus-daemon - D-Bus search and index daemon\n\n"
+					<< "Usage: pinot-dbus-daemon [OPTIONS]\n\n"
+					<< "Options:\n"
+					<< "  -h, --help		display this help and exit\n"
+					<< "  -v, --version		output version information and exit\n"
+					<< "\nReport bugs to " << PACKAGE_BUGREPORT << endl;
+				return EXIT_SUCCESS;
+			case 'v':
+				cout << "pinot-dbus-daemon - " << PACKAGE_STRING << "\n\n" 
+					<< "This is free software.  You may redistribute copies of it under the terms of\n"
+					<< "the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\n"
+					<< "There is NO WARRANTY, to the extent permitted by law." << endl;
+				return EXIT_SUCCESS;
+			default:
+				return EXIT_FAILURE;
+		}
+
+		// Next option
+		optionChar = getopt_long(argc, argv, "hv", g_longOptions, &longOptionIndex);
+	}
+
+#if defined(ENABLE_NLS)
+	bindtextdomain(GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
+	bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
+	textdomain(GETTEXT_PACKAGE);
+#endif //ENABLE_NLS
+
+	MIMEScanner::initialize();
+	DownloaderInterface::initialize();
+	Glib::thread_init();
+
+	// This will create the necessary directories on the first run
+	PinotSettings &settings = PinotSettings::getInstance();
+
+	string confDirectory = PinotSettings::getConfigurationDirectory();
+	chdir(confDirectory.c_str());
+
+	// Redirect cout and cerr to a file
+	string logFileName = confDirectory;
+	logFileName += "/pinot-dbus-daemon.log";
+	outputFile.open(logFileName.c_str());
+	coutBuf = cout.rdbuf();
+	cerrBuf = cerr.rdbuf();
+	cout.rdbuf(outputFile.rdbuf());
+	cerr.rdbuf(outputFile.rdbuf());
+
+	// Localize language names
+	Languages::setIntlName(0, _("Unknown"));
+	Languages::setIntlName(1, _("Danish"));
+	Languages::setIntlName(2, _("Dutch"));
+	Languages::setIntlName(3, _("English"));
+	Languages::setIntlName(4, _("Finnish"));
+	Languages::setIntlName(5, _("French"));
+	Languages::setIntlName(6, _("German"));
+	Languages::setIntlName(7, _("Italian"));
+	Languages::setIntlName(8, _("Norwegian"));
+	Languages::setIntlName(9, _("Portuguese"));
+	Languages::setIntlName(10, _("Russian"));
+	Languages::setIntlName(11, _("Spanish"));
+	Languages::setIntlName(12, _("Swedish"));
+
+	// Load search engines
+	settings.loadSearchEngines(prefixDir + string("/share/pinot/engines"));
+	settings.loadSearchEngines(confDirectory + string("/engines"));
+	// Load tokenizer libraries, if any
+	TokenizerFactory::loadTokenizers(prefixDir + string("/share/pinot/tokenizers"));
+	TokenizerFactory::loadTokenizers(confDirectory + string("/tokenizers"));
+	// Load the settings
+	settings.loadGlobal(prefixDir + string("/share/pinot/globalconfig.xml"));
+	settings.load();
+
+	// Catch interrupts
+	sigemptyset(&newAction.sa_mask);
+	newAction.sa_flags = 0;
+	newAction.sa_handler = quitAll;
+	sigaction(SIGINT, &newAction, NULL);
+	sigaction(SIGQUIT, &newAction, NULL);
+
+#if 0
+	// Ensure Xapian will be able to deal with internal indices
+	XapianDatabase *pDb = XapianDatabaseFactory::getDatabase(settings.m_indexLocation, false);
+	if ((pDb == NULL) ||
+		(pDb->isOpen() == false))
+	{
+		cerr << _("Couldn't open index") << " " << settings.m_indexLocation << endl;;
+	}
+	pDb = XapianDatabaseFactory::getDatabase(settings.m_mailIndexLocation, false);
+	if ((pDb == NULL) ||
+		(pDb->isOpen() == false))
+	{
+		cerr << _("Couldn't open index") << " " << settings.m_mailIndexLocation << endl;
+	}
+#endif
+
+	// Do the same for the history database
+	if ((settings.m_historyDatabase.empty() == true) ||
+		(QueryHistory::create(settings.m_historyDatabase) == false) ||
+		(ViewHistory::create(settings.m_historyDatabase) == false))
+	{
+		cerr << _("Couldn't create history database") << " " << settings.m_historyDatabase << endl;
+	}
+	else
+	{
+		QueryHistory queryHistory(settings.m_historyDatabase);
+		ViewHistory viewHistory(settings.m_historyDatabase);
+		time_t timeNow = time(NULL);
+
+		// Expire items older than a month
+		queryHistory.expireItems(timeNow - 2592000);
+		viewHistory.expireItems(timeNow - 2592000);
+	}
+
+	atexit(closeAll);
+
+	// Initialize the D-Bus thread system
+	dbus_g_thread_init();
+
+	GError *pError = NULL;
+	DBusGConnection *pBus = dbus_g_bus_get(DBUS_BUS_SESSION, &pError);
+	if (pBus == NULL)
+	{
+		if (pError != NULL)
+		{
+			cerr << "Couldn't open connection: " << pError->message << endl;
+			g_error_free(pError);
+		}
+
+		return EXIT_FAILURE;
+	}
+
+	// Listen for messages from all objects
+	DBusConnection *pConnection = dbus_g_connection_get_connection(pBus);
+	if (pConnection != NULL)
+	{
+		DBusError error;
+
+		dbus_error_init(&error);
+		dbus_connection_set_exit_on_disconnect(pConnection, FALSE);
+		dbus_connection_setup_with_g_main(pConnection, NULL);
+
+		dbus_connection_add_filter(pConnection, messageBusFilter, NULL, NULL);
+		if (dbus_error_is_set(&error) == FALSE)
+		{
+			// Request to be identified by this name
+			// FIXME: flags are currently broken ?
+			dbus_bus_request_name(pConnection, g_pinotDBusService, 0, &error);
+			if ((dbus_error_is_set(&error) == FALSE) &&
+				(dbus_connection_register_object_path(pConnection, g_pinotDBusObjectPath,
+					&g_callVTable, NULL) == TRUE))
+			{
+				// Run the main loop
+				g_refMainLoop = Glib::MainLoop::create();
+				g_refMainLoop->run();
+			}
+			else
+			{
+				cerr << "Couldn't register object path: " << pError->message << endl;
+			}
+		}
+		else
+		{
+			cerr << "Couldn't add filter: " << pError->message << endl;
+		}
+		dbus_error_free(&error);
+	}
+	dbus_connection_close(pConnection);
+	dbus_g_connection_unref(pBus);
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/UI/GTK2/src/pinot-dbus-daemon.xml
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2006-07-07 12:40:59 UTC (rev 345)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2006-07-12 12:15:12 UTC (rev 346)
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<node name="/de/berlios/Pinot">
+  <interface name="de.berlios.Pinot">
+    <method name="Index">
+      <annotation name="de.berlios.Pinot.Index" value="pinotDBus"/>
+      <arg type="s" name="title" direction="in"/>
+      <arg type="s" name="location" direction="in"/>
+      <arg type="s" name="type" direction="in"/>
+      <arg type="s" name="language" direction="in"/>
+      <arg type="s" name="label" direction="in"/>
+      <arg type="u" name="currentId" direction="in"/>
+      <arg type="u" name="newId" direction="out"/>
+    </method>
+  </interface>
+</node>

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2006-07-07 12:40:59 UTC (rev 345)
+++ trunk/configure.in	2006-07-12 12:15:12 UTC (rev 346)
@@ -162,6 +162,9 @@
 INDEX_LIBS="$XAPIAN_LIBS -ltextcat"
 AC_SUBST(INDEX_CFLAGS)
 AC_SUBST(INDEX_LIBS)
+PKG_CHECK_MODULES(DBUS, dbus-glib-1)
+AC_SUBST(DBUS_CFLAGS)
+AC_SUBST(DBUS_LIBS)
 PKG_CHECK_MODULES(SIGCPP, sigc++-2.0 >= 2.0 )
 AC_SUBST(SIGCPP_CFLAGS)
 AC_SUBST(SIGCPP_LIBS)

Modified: trunk/pinot.spec.in
===================================================================
--- trunk/pinot.spec.in	2006-07-07 12:40:59 UTC (rev 345)
+++ trunk/pinot.spec.in	2006-07-12 12:15:12 UTC (rev 346)
@@ -75,6 +75,7 @@
 %{_datadir}/pinot/xapian-powered.png
 %{_datadir}/pinot/metase-gtk2.glade
 %{_datadir}/pinot/metase-gtk2.gladep
+%{_datadir}/pinot/pinot-dbus-daemon.xml
 %{_datadir}/pinot/textcat_conf.txt
 %{_datadir}/pinot/*.src
 %dir %{_datadir}/pinot/engines/

Modified: trunk/po/POTFILES.in
===================================================================
--- trunk/po/POTFILES.in	2006-07-07 12:40:59 UTC (rev 345)
+++ trunk/po/POTFILES.in	2006-07-12 12:15:12 UTC (rev 346)
@@ -12,6 +12,7 @@
 UI/GTK2/src/MboxHandler.cpp
 UI/GTK2/src/Notebook.cpp
 UI/GTK2/src/pinot.cc
+UI/GTK2/src/pinot-dbus-daemon.cc
 UI/GTK2/src/PinotSettings.cpp
 UI/GTK2/src/PinotUtils.cpp
 UI/GTK2/src/prefsDialog.cc



From fabricecolin at mail.berlios.de  Fri Jul 14 14:08:57 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 14 Jul 2006 14:08:57 +0200
Subject: [Pinot-svn] r347 - trunk/UI/GTK2/src
Message-ID: <200607141208.k6EC8vpk008083@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-14 14:08:55 +0200 (Fri, 14 Jul 2006)
New Revision: 347

Modified:
   trunk/UI/GTK2/src/ModelColumns.cpp
   trunk/UI/GTK2/src/ModelColumns.h
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/ResultsTree.h
Log:
Score column gives some visual cue as to the relevance of results.


Modified: trunk/UI/GTK2/src/ModelColumns.cpp
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.cpp	2006-07-12 12:15:12 UTC (rev 346)
+++ trunk/UI/GTK2/src/ModelColumns.cpp	2006-07-14 12:08:55 UTC (rev 347)
@@ -59,6 +59,7 @@
 	add(m_viewed);
 	add(m_rankDiff);
 	add(m_score);
+	add(m_scoreText);
 	add(m_engines);
 	add(m_indexes);
 	add(m_type);

Modified: trunk/UI/GTK2/src/ModelColumns.h
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.h	2006-07-12 12:15:12 UTC (rev 346)
+++ trunk/UI/GTK2/src/ModelColumns.h	2006-07-14 12:08:55 UTC (rev 347)
@@ -80,7 +80,8 @@
 	Gtk::TreeModelColumn<bool> m_indexed;
 	Gtk::TreeModelColumn<bool> m_viewed;
 	Gtk::TreeModelColumn<int> m_rankDiff;
-	Gtk::TreeModelColumn<Glib::ustring> m_score;
+	Gtk::TreeModelColumn<int> m_score;
+	Gtk::TreeModelColumn<Glib::ustring> m_scoreText;
 	Gtk::TreeModelColumn<unsigned int> m_engines;
 	Gtk::TreeModelColumn<unsigned int> m_indexes;
 	typedef enum { RESULT_ROOT = 0, RESULT_TITLE, RESULT_HOST, RESULT_OTHER } ResultType;

Modified: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2006-07-12 12:15:12 UTC (rev 346)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2006-07-14 12:08:55 UTC (rev 347)
@@ -23,6 +23,7 @@
 #include <gtkmm/label.h>
 #include <gtkmm/stock.h>
 #include <gtkmm/textbuffer.h>
+#include <gtkmm/cellrendererprogress.h>
 
 #include "StringManip.h"
 #include "Url.h"
@@ -99,7 +100,7 @@
 	m_refStore = TreeStore::create(m_resultsColumns);
 	set_model(m_refStore);
 
-	// The first column is for the score and status icons
+	// The first column is for the status icons
 	TreeViewColumn *pColumn = new TreeViewColumn("");
 	// Pack an icon renderer for the viewed status
 	CellRendererPixbuf *pIconRenderer = new CellRendererPixbuf();
@@ -114,15 +115,24 @@
 	pColumn->pack_start(*manage(pIconRenderer), false);
 	pColumn->set_cell_data_func(*pIconRenderer, SigC::slot(*this, &ResultsTree::renderRanking));
 	pColumn->set_resizable(true);
+	append_column(*manage(pColumn));
+
+	// This is the score column
+	pColumn = new TreeViewColumn(_("Score"));
+	CellRendererProgress *pProgressRenderer = new CellRendererProgress();
+	pColumn->pack_start(*manage(pProgressRenderer));
+	pColumn->add_attribute(pProgressRenderer->property_text(), m_resultsColumns.m_scoreText);
+	pColumn->add_attribute(pProgressRenderer->property_value(), m_resultsColumns.m_score);
+	pColumn->set_resizable(true);
 	pColumn->set_sort_column(m_resultsColumns.m_score);
 	append_column(*manage(pColumn));
 
 	// This is the title column
 	pColumn = new TreeViewColumn(_("Title"));
-	CellRendererText *textCellRenderer = new CellRendererText();
-	pColumn->pack_start(*manage(textCellRenderer));
-	pColumn->set_cell_data_func(*textCellRenderer, SigC::slot(*this, &ResultsTree::renderBackgroundColour));
-	pColumn->add_attribute(textCellRenderer->property_text(), m_resultsColumns.m_text);
+	CellRendererText *pTextRenderer = new CellRendererText();
+	pColumn->pack_start(*manage(pTextRenderer));
+	pColumn->set_cell_data_func(*pTextRenderer, SigC::slot(*this, &ResultsTree::renderBackgroundColour));
+	pColumn->add_attribute(pTextRenderer->property_text(), m_resultsColumns.m_text);
 	pColumn->set_resizable(true);
 	pColumn->set_sort_column(m_resultsColumns.m_text);
 	append_column(*manage(pColumn));
@@ -429,12 +439,12 @@
 // Returns true if something was added to the tree.
 //
 bool ResultsTree::addResults(QueryProperties &queryProps, const string &engineName,
-	const vector<Result> &resultsList, const string &charset, bool groupBySearchEngine)
+	const vector<Result> &resultsList, const string &charset,
+	bool groupBySearchEngine)
 {
 	std::map<string, TreeModel::iterator> updatedGroups;
-	string queryName(queryProps.getName());
+	ResultsModelColumns::ResultType rootType;
 	unsigned int count = 0;
-	ResultsModelColumns::ResultType rootType;
 
 	// Get this query's terms
 	queryProps.getTerms(m_queryTerms);
@@ -477,14 +487,14 @@
 
 	QueryHistory history(m_settings.m_historyDatabase);
 	bool isNewQuery = false;
-	if (history.getLastRun(queryName, engineName).empty() == true)
+	if (history.getLastRun(m_queryName, engineName).empty() == true)
 	{
 		isNewQuery = true;
 	}
 
 	// Look at the results list
 #ifdef DEBUG
-	cout << "ResultsTree::addResults: " << resultsList.size() << " results to display" << endl;
+	cout << "ResultsTree::addResults: " << resultsList.size() << " results" << endl;
 #endif
 	for (vector<Result>::const_iterator resultIter = resultsList.begin();
 		resultIter != resultsList.end(); ++resultIter)
@@ -493,7 +503,6 @@
 		ustring location(to_utf8(resultIter->getLocation(), charset));
 		ustring extract(to_utf8(resultIter->getExtract(), charset));
 		float currentScore = resultIter->getScore();
-		string score;
 		int rankDiff = 0;
 
 		// What group should the result go to ?
@@ -517,7 +526,7 @@
 
 			// Has the result's ranking changed ?
 			float oldestScore = 0;
-			float previousScore = history.hasItem(queryName, engineName,
+			float previousScore = history.hasItem(m_queryName, engineName,
 				location, oldestScore);
 			if (previousScore > 0)
 			{
@@ -540,11 +549,11 @@
 			}
 
 			++count;
-			if (appendResult(title, location, currentScore, rankDiff,
+			if (appendResult(title, location, (int)currentScore, rankDiff,
 				engineId, indexId, titleIter, &(*groupIter), true) == true)
 			{
 #ifdef DEBUG
-				cout << "ResultsTree::addResults: added row for result " << count << endl;
+				cout << "ResultsTree::addResults: added row for result " << count << ", " << currentScore << endl;
 #endif
 
 				// Update this map, so that we know which groups need updating
@@ -670,7 +679,7 @@
 						// Add result
 						success = appendResult(childRow[m_resultsColumns.m_text],
 							childRow[m_resultsColumns.m_url],
-							(float)atof(from_utf8(childRow[m_resultsColumns.m_score]).c_str()),
+							childRow[m_resultsColumns.m_score],
 							childRow[m_resultsColumns.m_rankDiff],
 							engineIds, indexIds, newIter, &(*groupIter), true);
 					}
@@ -728,7 +737,7 @@
 								// Add result
 								appendResult(childRow[m_resultsColumns.m_text],
 									childRow[m_resultsColumns.m_url],
-									(float)atof(from_utf8(childRow[m_resultsColumns.m_score]).c_str()),
+									childRow[m_resultsColumns.m_score],
 									childRow[m_resultsColumns.m_rankDiff],
 									engineId, indexId,
 									newIter, &(*groupIter), true);
@@ -1076,7 +1085,7 @@
 // Adds a new row in the results tree.
 //
 bool ResultsTree::appendResult(const ustring &text, const ustring &url,
-	float score, int rankDiff, unsigned int engineId, unsigned int indexId,
+	int score, int rankDiff, unsigned int engineId, unsigned int indexId,
 	TreeModel::iterator &newRowIter, const TreeModel::Row *parentRow, bool noDuplicates)
 {
 	if (parentRow == NULL)
@@ -1136,12 +1145,8 @@
 	// Has it been already viewed ?
 	bool wasViewed = viewHistory.hasItem(url);
 
-	char scoreStr[128];
-	snprintf(scoreStr, 128, "%.f", score);
-
 	TreeModel::Row childRow = *newRowIter;
-	updateRow(childRow, text, url, scoreStr,
-		engineId, indexId,
+	updateRow(childRow, text, url, score, engineId, indexId,
 		ResultsModelColumns::RESULT_TITLE, isIndexed,
 		wasViewed, rankDiff);
 
@@ -1164,7 +1169,7 @@
 		groupIter = m_refStore->append();
 		TreeModel::Row groupRow = *groupIter;
 		updateRow(groupRow, to_utf8(groupName),
-			"", "", 0, 0, groupType,
+			"", 0, 0, 0, groupType,
 			false, false, false);
 
 		// Update the map
@@ -1193,6 +1198,7 @@
 void ResultsTree::updateGroup(TreeModel::iterator &groupIter)
 {
 	TreeModel::Row groupRow = (*groupIter);
+	int averageScore = 0;
 
 	// Check the iterator doesn't point to a result
 	if (groupRow[m_resultsColumns.m_type] == ResultsModelColumns::RESULT_TITLE)
@@ -1202,11 +1208,23 @@
 
 	// Modify the "score" column to indicate the number of results in that group
 	TreeModel::Children groupChildren = groupIter->children();
-	char scoreStr[64];
-	snprintf(scoreStr, 64, "%u", groupChildren.size());
-	groupRow[m_resultsColumns.m_score] = scoreStr;
+	if (groupChildren.empty() == false)
+	{
+		for (TreeModel::Children::iterator childIter = groupChildren.begin();
+			childIter != groupChildren.end(); ++childIter)
+		{
+			TreeModel::Row row = *childIter;
+
+			averageScore += row[m_resultsColumns.m_score];
+		}
+
+		averageScore = (int)(averageScore / groupChildren.size());
+	}
+	groupRow[m_resultsColumns.m_score] = averageScore;
+
 #ifdef DEBUG
-	cout << "ResultsTree::updateGroup: group " << groupRow[m_resultsColumns.m_text] << " has " << groupChildren.size() << " children" << endl;
+	cout << "ResultsTree::updateGroup: group " << groupRow[m_resultsColumns.m_text]
+		<< " has score " << averageScore << endl;
 #endif
 
 	// Expand this group
@@ -1218,13 +1236,13 @@
 // Updates a row.
 //
 void ResultsTree::updateRow(TreeModel::Row &row, const ustring &text,
-	const ustring &url, const ustring &score,
-	unsigned int engineId,  unsigned int indexId,
+	const ustring &url, int score, unsigned int engineId,  unsigned int indexId,
 	ResultsModelColumns::ResultType type, bool indexed, bool viewed, int rankDiff)
 {
 	row[m_resultsColumns.m_text] = text;
 	row[m_resultsColumns.m_url] = url;
 	row[m_resultsColumns.m_score] = score;
+	row[m_resultsColumns.m_scoreText] = "";
 	row[m_resultsColumns.m_engines] = engineId;
 	row[m_resultsColumns.m_indexes] = indexId;
 	row[m_resultsColumns.m_type] = type;

Modified: trunk/UI/GTK2/src/ResultsTree.h
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.h	2006-07-12 12:15:12 UTC (rev 346)
+++ trunk/UI/GTK2/src/ResultsTree.h	2006-07-14 12:08:55 UTC (rev 347)
@@ -140,7 +140,7 @@
 
 		/// Adds a new row in the results tree.
 		bool appendResult(const Glib::ustring &text, const Glib::ustring &url,
-			float score, int rankDiff, unsigned int engineId, unsigned int indexId,
+			int score, int rankDiff, unsigned int engineId, unsigned int indexId,
 			Gtk::TreeModel::iterator &newRowIter,
 			const Gtk::TreeModel::Row *parentRow = NULL, bool noDuplicates = false);
 
@@ -149,8 +149,7 @@
 
 		/// Updates a row.
 		void updateRow(Gtk::TreeModel::Row &row, const Glib::ustring &text,
-			const Glib::ustring &url, const Glib::ustring &score,
-			unsigned int engineId, unsigned int indexId,
+			const Glib::ustring &url, int score, unsigned int engineId, unsigned int indexId,
 			ResultsModelColumns::ResultType type, bool indexed, bool viewed, int rankDiff);
 
 	private:



From fabricecolin at mail.berlios.de  Fri Jul 14 14:13:23 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 14 Jul 2006 14:13:23 +0200
Subject: [Pinot-svn] r348 - in trunk: UI/GTK2/src Utils
Message-ID: <200607141213.k6ECDNPE009344@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-14 14:12:57 +0200 (Fri, 14 Jul 2006)
New Revision: 348

Modified:
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
   trunk/UI/GTK2/src/importDialog.cc
   trunk/UI/GTK2/src/importDialog.hh
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/mainWindow.hh
   trunk/Utils/DocumentInfo.cpp
   trunk/Utils/DocumentInfo.h
Log:
Simplified/refactored indexing code in the UI. Moved stuff useful to both the
UI and the future D-Bus daemon into ThreadsManager when it makes sense.
DocumentInfo can now hold a labels set.


Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-07-14 12:08:55 UTC (rev 347)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-07-14 12:12:57 UTC (rev 348)
@@ -161,24 +161,27 @@
 	m_dispatcher.emit();
 }
 
-ThreadsManager::ThreadsManager() :
+ThreadsManager::ThreadsManager(unsigned int maxIndexThreads) :
 	SigC::Object(),
+	m_maxIndexThreads(maxIndexThreads),
 	m_nextId(1),
 	m_backgroundThreadsCount(0)
 {
-	pthread_rwlock_init(&m_rwLock, NULL);
+	pthread_rwlock_init(&m_threadsLock, NULL);
+	pthread_rwlock_init(&m_listsLock, NULL);
 }
 
 ThreadsManager::~ThreadsManager()
 {
 	stop_threads();
-	// Destroy the read/write lock
-	pthread_rwlock_destroy(&m_rwLock);
+	// Destroy the read/write locks
+	pthread_rwlock_destroy(&m_listsLock);
+	pthread_rwlock_destroy(&m_threadsLock);
 }
 
-bool ThreadsManager::read_lock(void)
+bool ThreadsManager::read_lock_threads(void)
 {
-	if (pthread_rwlock_rdlock(&m_rwLock) == 0)
+	if (pthread_rwlock_rdlock(&m_threadsLock) == 0)
 	{
 		return true;
 	}
@@ -186,9 +189,9 @@
 	return false;
 }
 
-bool ThreadsManager::write_lock(void)
+bool ThreadsManager::write_lock_threads(void)
 {
-	if (pthread_rwlock_wrlock(&m_rwLock) == 0)
+	if (pthread_rwlock_wrlock(&m_threadsLock) == 0)
 	{
 		return true;
 	}
@@ -196,17 +199,42 @@
 	return false;
 }
 
-void ThreadsManager::unlock(void)
+void ThreadsManager::unlock_threads(void)
 {
-	pthread_rwlock_unlock(&m_rwLock);
+	pthread_rwlock_unlock(&m_threadsLock);
 }
 
+bool ThreadsManager::read_lock_lists(void)
+{
+	if (pthread_rwlock_rdlock(&m_listsLock) == 0)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+bool ThreadsManager::write_lock_lists(void)
+{
+	if (pthread_rwlock_wrlock(&m_listsLock) == 0)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+void ThreadsManager::unlock_lists(void)
+{
+	pthread_rwlock_unlock(&m_listsLock);
+}
+
 WorkerThread *ThreadsManager::get_thread(void)
 {
 	WorkerThread *pWorkerThread = NULL;
 
 	// Get the first thread that's finished
-	if (read_lock() == true)
+	if (read_lock_threads() == true)
 	{
 		for (map<WorkerThread *, Thread *>::iterator threadIter = m_threads.begin();
 			threadIter != m_threads.end(); ++threadIter)
@@ -226,7 +254,7 @@
 #endif
 		}
 
-		unlock();
+		unlock_threads();
 	}
 
 	if (pWorkerThread == NULL)
@@ -242,6 +270,60 @@
 	return pWorkerThread;
 }
 
+bool ThreadsManager::index_document(const DocumentInfo &docInfo)
+{
+	string location(docInfo.getLocation());
+
+	if (location.empty() == true)
+	{
+		// Nothing to do
+		return false;
+	}
+
+	// If the document is mail, we can't index it again
+	Url urlObj(location);
+	if (urlObj.getProtocol() == "mailbox")
+	{
+		return false;
+	}
+
+	// Is it an update ?
+	XapianIndex docsIndex(PinotSettings::getInstance().m_indexLocation);
+	unsigned int docId = docsIndex.hasDocument(docInfo.getLocation());
+	if (docId > 0)
+	{
+		// Yes, it is
+		start_thread(new IndexingThread(docInfo, docId));
+	}
+	else
+	{
+		bool isNewDocument = false;
+
+		// Is the document being indexed ?
+		if (write_lock_lists() == true)
+		{
+			if (m_beingIndexed.find(location) == m_beingIndexed.end())
+			{
+				m_beingIndexed.insert(location);
+				isNewDocument = true;
+			}
+
+			unlock_lists();
+		}
+
+		if (isNewDocument == false)
+		{
+			// FIXME: the document is being indexed but we may have to set labels on it
+			return false;
+		}
+
+		// This is a new document
+		start_thread(new IndexingThread(docInfo));
+	}
+
+	return true;
+}
+
 bool ThreadsManager::start_thread(WorkerThread *pWorkerThread, bool inBackground)
 {
 	if (pWorkerThread == NULL)
@@ -264,11 +346,11 @@
 	}
 
 	// Insert
-	if (write_lock() == true)
+	if (write_lock_threads() == true)
 	{
 		m_threads[pWorkerThread] = pThread;
 
-		unlock();
+		unlock_threads();
 	}
 	++m_nextId;
 
@@ -279,11 +361,11 @@
 {
 	int count = 0;
 
-	if (read_lock() == true)
+	if (read_lock_threads() == true)
 	{
 		count = m_threads.size() - m_backgroundThreadsCount;
 
-		unlock();
+		unlock_threads();
 	}
 #ifdef DEBUG
 	cout << "ThreadsManager::get_threads_count: " << count << " threads left" << endl;
@@ -308,12 +390,12 @@
 {
 	if (m_threads.empty() == false)
 	{
-		if (read_lock() == true)
+		if (read_lock_threads() == true)
 		{
 			for_each(m_threads.begin(), m_threads.end(), DeleteMapPointer());
 			m_threads.clear();
 
-			unlock();
+			unlock_threads();
 		}
 	}
 }
@@ -363,6 +445,63 @@
 	m_onThreadEndSignal.emit(pThread);
 }
 
+bool ThreadsManager::queue_index(const DocumentInfo &docInfo)
+{
+	if (get_threads_count() >= m_maxIndexThreads)
+	{
+		if (write_lock_lists() == true)
+		{
+			m_indexQueue.insert(docInfo);
+
+			unlock_lists();
+		}
+
+		return true;
+	}
+
+	return index_document(docInfo);
+}
+
+bool ThreadsManager::pop_queue(void)
+{
+	if (get_threads_count() >= m_maxIndexThreads)
+	{
+#ifdef DEBUG
+		cout << "ThreadsManager::pop_queue: too many threads" << endl;
+#endif
+		return false;
+	}
+
+	DocumentInfo docInfo;
+	bool foundItem = false;
+
+	if (write_lock_lists() == true)
+	{
+		if (m_indexQueue.empty() == false)
+		{
+			// Get the first item
+			std::set<DocumentInfo>::iterator queueIter = m_indexQueue.begin();
+			if (queueIter != m_indexQueue.end())
+			{
+				docInfo = *queueIter;
+				foundItem = true;
+
+				m_indexQueue.erase(queueIter);
+			}
+		}
+
+		unlock_lists();
+	}
+
+	if (foundItem == false)
+	{
+		// Nothing to do
+		return false;
+	}
+
+	return index_document(docInfo);
+}
+
 IndexBrowserThread::IndexBrowserThread(const string &indexName,
 	const string &labelName, unsigned int maxDocsCount, unsigned int startDoc) :
 	WorkerThread(),
@@ -785,11 +924,10 @@
 	}
 }
 
-IndexingThread::IndexingThread(const DocumentInfo &docInfo, const string &labelName,
-	unsigned int docId, bool allowAllMIMETypes) :
+IndexingThread::IndexingThread(const DocumentInfo &docInfo, unsigned int docId,
+	bool allowAllMIMETypes) :
 	DownloadingThread(docInfo, false),
 	m_docInfo(docInfo),
-	m_labelName(labelName),
 	m_docId(docId),
 	m_allowAllMIMETypes(allowAllMIMETypes)
 {
@@ -822,11 +960,6 @@
 	return m_docInfo;
 }
 
-string IndexingThread::getLabelName(void) const
-{
-	return m_labelName;
-}
-
 unsigned int IndexingThread::getDocumentID(void) const
 {
 	return m_docId;
@@ -949,42 +1082,26 @@
 
 		if (m_done == false)
 		{
-			set<string> labels;
+			const set<string> &labels = m_docInfo.getLabels();
 
 			index.setStemmingMode(IndexInterface::STORE_BOTH);
 
 			// Update an existing document or add to the index ?
 			if (m_update == true)
 			{
-				// Get the document's current labels
-				index.getDocumentLabels(m_docId, labels);
-
 				// Update the document
 				if (index.updateDocument(m_docId, *pTokens) == true)
 				{
-					if (m_labelName.empty() == false)
-					{
-						// Add the label if it's a new one
-						if (labels.find(m_labelName) == labels.end())
-						{
-							labels.clear();
-							labels.insert(m_labelName);
-
-							index.setDocumentLabels(m_docId, labels, false);
-						}
-					}
 					success = true;
 				}
+
+				// Set the document's labels
+				index.setDocumentLabels(m_docId, labels, false);
 			}
 			else
 			{
 				unsigned int docId = 0;
 
-				if (m_labelName.empty() == false)
-				{
-					labels.insert(m_labelName);
-				}
-
 				// Index the document
 				success = index.indexDocument(*pTokens, labels, docId);
 				if (success == true)
@@ -999,7 +1116,7 @@
 				m_status += " ";
 				m_status += m_docInfo.getLocation();
 			}
-			else if (m_done == false)
+			else
 			{
 				// Flush the index
 				index.flush();

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2006-07-14 12:08:55 UTC (rev 347)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2006-07-14 12:12:57 UTC (rev 348)
@@ -91,10 +91,10 @@
 class ThreadsManager : public SigC::Object
 {
 	public:
-		ThreadsManager();
+		ThreadsManager(unsigned int maxIndexThreads);
 		virtual ~ThreadsManager();
 
-		bool start_thread(WorkerThread *pWorkerThread, bool inBackground);
+		bool start_thread(WorkerThread *pWorkerThread, bool inBackground = false);
 
 		unsigned int get_threads_count(void);
 
@@ -108,19 +108,34 @@
 
 		void on_thread_end();
 
+		bool read_lock_lists(void);
+
+		bool write_lock_lists(void);
+
+		void unlock_lists(void);
+
+		bool queue_index(const DocumentInfo &docInfo);
+
+		bool pop_queue(void);
+
+		std::set<std::string> m_beingIndexed;
+
 	protected:
 		SigC::Connection m_threadsEndConnection;
-		// Read/write lock
-		pthread_rwlock_t m_rwLock;
+		pthread_rwlock_t m_threadsLock;
+		pthread_rwlock_t m_listsLock;
 		std::map<WorkerThread *, Glib::Thread *> m_threads;
+		unsigned int m_maxIndexThreads;
 		unsigned int m_nextId;
 		unsigned int m_backgroundThreadsCount;
 		SigC::Signal1<void, WorkerThread *> m_onThreadEndSignal;
+		std::set<DocumentInfo> m_indexQueue;
 
-		bool read_lock(void);
-		bool write_lock(void);
-		void unlock(void);
+		bool read_lock_threads(void);
+		bool write_lock_threads(void);
+		void unlock_threads(void);
 		WorkerThread *get_thread(void);
+		bool index_document(const DocumentInfo &docInfo);
 
 	private:
 		ThreadsManager(const ThreadsManager &other);
@@ -257,8 +272,8 @@
 class IndexingThread : public DownloadingThread
 {
 	public:
-		IndexingThread(const DocumentInfo &docInfo, const std::string &labelName,
-			unsigned int docId = 0, bool allowAllMIMETypes = false);
+		IndexingThread(const DocumentInfo &docInfo, unsigned int docId = 0,
+			bool allowAllMIMETypes = false);
 		virtual ~IndexingThread();
 
 		virtual std::string getType(void) const;
@@ -275,7 +290,6 @@
 
 	protected:
 		DocumentInfo m_docInfo;
-		std::string m_labelName;
 		unsigned int m_docId;
 		bool m_allowAllMIMETypes;
 		std::string m_indexLocation;

Modified: trunk/UI/GTK2/src/importDialog.cc
===================================================================
--- trunk/UI/GTK2/src/importDialog.cc	2006-07-14 12:08:55 UTC (rev 347)
+++ trunk/UI/GTK2/src/importDialog.cc	2006-07-14 12:12:57 UTC (rev 348)
@@ -38,8 +38,8 @@
 
 string importDialog::InternalState::m_defaultDirectory = "";
 
-importDialog::InternalState::InternalState(importDialog *pWindow) :
-	ThreadsManager(),
+importDialog::InternalState::InternalState(unsigned int maxIndexThreads, importDialog *pWindow) :
+	ThreadsManager(maxIndexThreads),
 	m_importing(false)
 {
 	m_onThreadEndSignal.connect(SigC::slot(*pWindow, &importDialog::on_thread_end));
@@ -54,7 +54,7 @@
 	m_docsCount(0),
 	m_importDirectory(false),
 	m_pScannerThread(NULL),
-	m_state(this)
+	m_state(10, this)
 {
 	set_title(title);
 
@@ -168,17 +168,19 @@
 
 bool importDialog::on_import_url(const string &location)
 {
-	Url urlObj(location);
-
 	XapianIndex index(PinotSettings::getInstance().m_indexLocation);
 	IndexingThread *pThread = NULL;
+	Url urlObj(location);
+	set<string> labels;
 	string title = from_utf8(m_title);
 	unsigned int docId = 0;
 
 	if (index.isGood() == true)
 	{
 		docId = index.hasDocument(location);
+		index.getDocumentLabels(docId, labels);
 	}
+	labels.insert(m_labelName);
 
 	if (m_importDirectory == true)
 	{
@@ -188,17 +190,19 @@
 		}
 		title += urlObj.getFile();
 	}
+
 	DocumentInfo docInfo(title, location, MIMEScanner::scanUrl(urlObj), "");
+	docInfo.setLabels(labels);
 
 	if (docId > 0)
 	{
 		// This document needs updating
 		index.getDocumentInfo(docId, docInfo);
-		pThread = new IndexingThread(docInfo, m_labelName, docId);
+		pThread = new IndexingThread(docInfo, docId);
 	}
 	else
 	{
-		pThread = new IndexingThread(docInfo, m_labelName);
+		pThread = new IndexingThread(docInfo);
 	}
 
 	// Launch the new thread

Modified: trunk/UI/GTK2/src/importDialog.hh
===================================================================
--- trunk/UI/GTK2/src/importDialog.hh	2006-07-14 12:08:55 UTC (rev 347)
+++ trunk/UI/GTK2/src/importDialog.hh	2006-07-14 12:12:57 UTC (rev 348)
@@ -70,7 +70,7 @@
 	class InternalState : public ThreadsManager
 	{
 		public:
-			InternalState(importDialog *pWindow);
+			InternalState(unsigned int maxIndexThreads, importDialog *pWindow);
 			~InternalState();
 
 			// Directory scanning

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2006-07-14 12:08:55 UTC (rev 347)
+++ trunk/UI/GTK2/src/mainWindow.cc	2006-07-14 12:12:57 UTC (rev 348)
@@ -63,57 +63,21 @@
 
 // FIXME: this ought to be configurable
 unsigned int mainWindow::m_maxDocsCount = 100;
-unsigned int mainWindow::m_maxThreads = 2;
+unsigned int mainWindow::m_maxIndexThreads = 2;
 
-mainWindow::InternalState::InternalState(mainWindow *pWindow) :
-	ThreadsManager(),
+mainWindow::InternalState::InternalState(unsigned int maxIndexThreads, mainWindow *pWindow) :
+	ThreadsManager(maxIndexThreads),
 	m_liveQueryLength(0),
 	m_currentPage(0),
 	m_browsingIndex(false)
 {
-	pthread_rwlock_init(&m_listsLock, NULL);
 	m_onThreadEndSignal.connect(SigC::slot(*pWindow, &mainWindow::on_thread_end));
 }
 
 mainWindow::InternalState::~InternalState()
 {
-	pthread_rwlock_destroy(&m_listsLock);
 }
 
-bool mainWindow::InternalState::read_lock_lists(unsigned int where)
-{
-	if (pthread_rwlock_rdlock(&m_listsLock) == 0)
-	{
-#ifdef DEBUG
-		cout << "mainWindow::read_lock_lists: " << where << endl;
-#endif
-		return true;
-	}
-
-	return false;
-}
-
-bool mainWindow::InternalState::write_lock_lists(unsigned int where)
-{
-	if (pthread_rwlock_wrlock(&m_listsLock) == 0)
-	{
-#ifdef DEBUG
-		cout << "mainWindow::write_lock_lists: " << where << endl;
-#endif
-		return true;
-	}
-
-	return false;
-}
-
-void mainWindow::InternalState::unlock_lists(void)
-{
-	pthread_rwlock_unlock(&m_listsLock);
-#ifdef DEBUG
-	cout << "mainWindow::unlock_lists" << endl;
-#endif
-}
-
 //
 // Constructor
 //
@@ -123,7 +87,7 @@
 	m_pNotebook(NULL),
 	m_pIndexMenu(NULL),
 	m_pCacheMenu(NULL),
-	m_state(this)
+	m_state(m_maxIndexThreads, this)
 {
 	// Reposition and resize the window
 	// Make sure the coordinates and sizes make sense
@@ -650,7 +614,7 @@
 			SigC::slot(*this, &mainWindow::on_indexForwardButton_clicked));
 
 		// Append the page
-		if (m_state.write_lock_lists(1) == true)
+		if (m_state.write_lock_lists() == true)
 		{
 			int pageNum = m_pNotebook->append_page(*pIndexPage, *pTab);
 			m_pNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
@@ -824,7 +788,7 @@
 	int pageNum = get_page_number(title, type);
 	if (pageNum >= 0)
 	{
-		if (m_state.write_lock_lists(2) == true)
+		if (m_state.write_lock_lists() == true)
 		{
 			// Remove the page
 			m_pNotebook->remove_page(pageNum);
@@ -985,7 +949,7 @@
 				SigC::slot(*this, &mainWindow::on_viewresults_activate));
 
 			// Append the page
-			if (m_state.write_lock_lists(3) == true)
+			if (m_state.write_lock_lists() == true)
 			{
 				pageNum = m_pNotebook->append_page(*pResultsPage, *pTab);
 				m_pNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
@@ -1018,10 +982,14 @@
 			for (vector<Result>::const_iterator resultIter = resultsList.begin();
 				resultIter != resultsList.end(); ++resultIter)
 			{
-				// Queue this action
-				queue_index(DocumentInfo(resultIter->getTitle(), resultIter->getLocation(),
-					resultIter->getType(), resultIter->getLanguage()),
-					labelName);
+				set<string> labels;
+				DocumentInfo docInfo(resultIter->getTitle(), resultIter->getLocation(),
+					resultIter->getType(), resultIter->getLanguage());
+
+				// Queue this
+				labels.insert(labelName);
+				docInfo.setLabels(labels);
+				m_state.queue_index(docInfo);
 			}
 		}
 
@@ -1192,7 +1160,7 @@
 			status += to_utf8(url);
 
 			// Update the in-progress list
-			if (m_state.write_lock_lists(4) == true)
+			if (m_state.write_lock_lists() == true)
 			{
 				set<string>::iterator urlIter = m_state.m_beingIndexed.find(url);
 				if (urlIter != m_state.m_beingIndexed.end())
@@ -1292,7 +1260,7 @@
 	delete pThread;;
 
 	// We might be able to run a queued action
-	check_queue();
+	m_state.pop_queue();
 
 	// Any threads left to return ?
 	if (m_state.get_threads_count() == 0)
@@ -1367,18 +1335,10 @@
 //
 // Message reception from ListenerThread
 //
-void mainWindow::on_message_reception(DocumentInfo docInfo, string labelName)
+void mainWindow::on_message_reception(DocumentInfo docInfo)
 {
-	string location = docInfo.getLocation();
-
-	if (location.empty() == false)
-	{
-#ifdef DEBUG
-		cout << "mainWindow::on_message_reception: indexing " << location << endl;
-#endif
-		// Queue this
-		queue_index(docInfo, labelName);
-	}
+	// Queue this
+	m_state.queue_index(docInfo);
 }
 
 //
@@ -1418,7 +1378,7 @@
 	// FIXME: if mail accounts are configured, make sure the MonitorThread
 	// is running and knows about the new accounts
 
-	if (m_state.read_lock_lists(5) == true)
+	if (m_state.read_lock_lists() == true)
 	{
 		for (int pageNum = 0; pageNum < m_pNotebook->get_n_pages(); ++pageNum)
 		{
@@ -1834,7 +1794,7 @@
 #ifdef DEBUG
 					cout << "mainWindow::on_indexresults_activate: URL is " << resultIter->getLocation() << endl;
 #endif
-					queue_index(*resultIter, "");
+					m_state.queue_index(*resultIter);
 				}
 
 				// We can update the rows right now
@@ -1944,7 +1904,7 @@
 		DocumentInfo docInfo(docIter->getTitle(), url,
 			docIter->getType(), docIter->getLanguage());
 		docInfo.setTimestamp(docIter->getTimestamp());
-		queue_index(docInfo, "");
+		m_state.queue_index(docInfo);
 	}
 }
 
@@ -2609,7 +2569,7 @@
 {
 	NotebookPageBox *pNotebookPage = NULL;
 
-	if (m_state.read_lock_lists(6) == true)
+	if (m_state.read_lock_lists() == true)
 	{
 		Widget *pPage = m_pNotebook->get_nth_page(m_pNotebook->get_current_page());
 		if (pPage != NULL)
@@ -2630,7 +2590,7 @@
 {
 	NotebookPageBox *pNotebookPage = NULL;
 
-	if (m_state.read_lock_lists(7) == true)
+	if (m_state.read_lock_lists() == true)
 	{
 		for (int pageNum = 0; pageNum < m_pNotebook->get_n_pages(); ++pageNum)
 		{
@@ -2667,7 +2627,7 @@
 {
 	int pageNumber = -1;
 
-	if (m_state.read_lock_lists(8) == true)
+	if (m_state.read_lock_lists() == true)
 	{
 		for (int pageNum = 0; pageNum < m_pNotebook->get_n_pages(); ++pageNum)
 		{
@@ -2698,40 +2658,6 @@
 }
 
 //
-// Queues additions to the index.
-//
-bool mainWindow::queue_index(const DocumentInfo &docInfo,
-	const string &labelName)
-{
-	if (m_state.get_threads_count() >= m_maxThreads)
-	{
-		if (m_state.write_lock_lists(9) == true)
-		{
-			m_state.m_indexQueue[docInfo] = labelName;
-
-			m_state.unlock_lists();
-		}
-
-		return true;
-	}
-
-	// Is it an update ?
-	XapianIndex docsIndex(m_settings.m_indexLocation);
-	unsigned int docId = docsIndex.hasDocument(docInfo.getLocation());
-	if (docId > 0)
-	{
-		// Yes, it is
-		index_document(docInfo, labelName, docId);
-	}
-	else
-	{
-		index_document(docInfo, labelName);
-	}
-
-	return false;
-}
-
-//
 // Edits a query
 //
 void mainWindow::edit_query(QueryProperties &queryProps, bool newQuery)
@@ -2974,85 +2900,6 @@
 }
 
 //
-// Index (or update) a document
-//
-void mainWindow::index_document(const DocumentInfo &docInfo,
-	const string &labelName, unsigned int docId)
-{
-	string location(docInfo.getLocation());
-
-	if (location.empty() == true)
-	{
-		// Nothing to do
-#ifdef DEBUG
-		cout << "mainWindow::index_document: empty queue" << endl;
-#endif
-		return;
-	}
-
-	Url urlObj(location);
-	string indexLocation(m_settings.m_indexLocation);
-
-	// If the document is mail, we need the My Email index
-	if (urlObj.getProtocol() == "mailbox")
-	{
-		indexLocation = m_settings.m_mailIndexLocation;
-	}
-
-	// Is it an update ?
-	if (docId > 0)
-	{
-		// Yes, it is
-		start_thread(new IndexingThread(docInfo, labelName, docId));
-
-		// We may have to update its labels
-		if (labelName.empty() == false)
-		{
-			XapianIndex index(indexLocation);
-			set<string> docLabels;
-
-			// Add this new label
-#ifdef DEBUG
-			cout << "mainWindow::index_document: applying label " << labelName << " to document " << docId << endl;
-#endif
-			docLabels.insert(labelName);
-			index.setDocumentLabels(docId, docLabels, false);
-		}
-	}
-	else
-	{
-		string url(docInfo.getLocation());
-		bool isNewDocument = false;
-
-		// Is the document being indexed ?
-		if (m_state.write_lock_lists(10) == true)
-		{
-			if (m_state.m_beingIndexed.find(url) == m_state.m_beingIndexed.end())
-			{
-				m_state.m_beingIndexed.insert(url);
-				isNewDocument = true;
-			}
-
-			m_state.unlock_lists();
-		}
-
-		if (isNewDocument == true)
-		{
-			// This is a new document
-			start_thread(new IndexingThread(docInfo, labelName));
-		}
-		// Complain about already indexed files only if we aren't going to set a label on them
-		else if (labelName.empty() == true)
-		{
-			ustring status = url;
-			status += " ";
-			status += _("is already indexed or is being indexed");
-			set_status(status);
-		}
-	}
-}
-
-//
 // View documents
 //
 void mainWindow::view_documents(vector<DocumentInfo> &documentsList)
@@ -3251,64 +3098,6 @@
 }
 
 //
-// Checks the queue and runs the oldest action if possible.
-//
-bool mainWindow::check_queue(void)
-{
-	if (m_state.get_threads_count() >= m_maxThreads)
-	{
-#ifdef DEBUG
-		cout << "mainWindow::check_queue: too many threads" << endl;
-#endif
-		return false;
-	}
-
-	DocumentInfo docInfo;
-	string labelName;
-	bool foundItem = false;
-
-	if (m_state.write_lock_lists(12) == true)
-	{
-		if (m_state.m_indexQueue.empty() == false)
-		{
-			// Get the first item
-			std::map<DocumentInfo, string>::iterator queueIter = m_state.m_indexQueue.begin();
-			if (queueIter != m_state.m_indexQueue.end())
-			{
-				docInfo = queueIter->first;
-				labelName = queueIter->second;
-				foundItem = true;
-
-				m_state.m_indexQueue.erase(queueIter);
-			}
-		}
-
-		m_state.unlock_lists();
-	}
-
-	if (foundItem == false)
-	{
-		// Nothing to do
-		return false;
-	}
-
-	// Is it an update ?
-	XapianIndex docsIndex(m_settings.m_indexLocation);
-	unsigned int docId = docsIndex.hasDocument(docInfo.getLocation());
-	if (docId > 0)
-	{
-		// Yes, it is
-		index_document(docInfo, labelName, docId);
-	}
-	else
-	{
-		index_document(docInfo, labelName);
-	}
-
-	return true;
-}
-
-//
 // Sets the status bar text.
 //
 void mainWindow::set_status(const ustring &text, bool canBeSkipped)

Modified: trunk/UI/GTK2/src/mainWindow.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow.hh	2006-07-14 12:08:55 UTC (rev 347)
+++ trunk/UI/GTK2/src/mainWindow.hh	2006-07-14 12:12:57 UTC (rev 348)
@@ -18,7 +18,6 @@
 #define _MAINWINDOW_HH
 
 #include <string>
-#include <map>
 #include <set>
 #include <sigc++/connection.h>
 #include <glibmm/refptr.h>
@@ -73,7 +72,7 @@
 	void on_close_page(Glib::ustring title, NotebookPageBox::PageType type);
 	void on_thread_end(WorkerThread *pThread);
 	void on_editindex(Glib::ustring indexName, Glib::ustring location);
-	void on_message_reception(DocumentInfo docInfo, std::string labelName);
+	void on_message_reception(DocumentInfo docInfo);
 	void on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, std::string indexName);
 
 	// Handlers inherited from the base class
@@ -125,18 +124,14 @@
 		NotebookPageBox::PageType type);
 	int get_page_number(const Glib::ustring &title,
 		NotebookPageBox::PageType type);
-	bool queue_index(const DocumentInfo &docInfo, const std::string &labelName);
 	void edit_query(QueryProperties &queryProps, bool newQuery);
 	void run_search(const QueryProperties &queryProps);
 	void browse_index(const Glib::ustring &indexName,
 		const Glib::ustring &labelName, unsigned int startDoc);
-	void index_document(const DocumentInfo &docInfo, const std::string &labelName,
-		unsigned int docId = 0);
 	void view_documents(std::vector<DocumentInfo> &documentsList);
 	bool append_document(IndexPage *pIndexPage, const Glib::ustring &indexName,
 		const IndexedDocument &docInfo);
 	bool start_thread(WorkerThread *pNewThread, bool inBackground = false);
-	bool check_queue(void);
 
 	// Status methods
 	bool on_activity_timeout(void);
@@ -169,29 +164,19 @@
 	class InternalState : public ThreadsManager
 	{
 		public:
-			InternalState(mainWindow *pWindow);
-			~InternalState();
+			InternalState(unsigned int maxIndexThreads, mainWindow *pWindow);
+			virtual ~InternalState();
 
-			bool read_lock_lists(unsigned int where);
-			bool write_lock_lists(unsigned int where);
-			void unlock_lists(void);
-
 			// Query
 			unsigned int m_liveQueryLength;
 			// Notebook pages
 			int m_currentPage;
-			// In-progress actions
-			std::set<std::string> m_beingIndexed;
+			// Current actions
 			bool m_browsingIndex;
-			// Action queue
-			std::map<DocumentInfo, string> m_indexQueue;
 
-		protected:
-			pthread_rwlock_t m_listsLock;
-
 	} m_state;
 	static unsigned int m_maxDocsCount;
-	static unsigned int m_maxThreads;
+	static unsigned int m_maxIndexThreads;
 
 };
 

Modified: trunk/Utils/DocumentInfo.cpp
===================================================================
--- trunk/Utils/DocumentInfo.cpp	2006-07-14 12:08:55 UTC (rev 347)
+++ trunk/Utils/DocumentInfo.cpp	2006-07-14 12:12:57 UTC (rev 348)
@@ -14,10 +14,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include <algorithm>
 #include "TimeConverter.h"
 #include "DocumentInfo.h"
 
 using std::string;
+using std::copy;
+using std::inserter;
 
 DocumentInfo::DocumentInfo()
 {
@@ -34,13 +37,15 @@
 	m_timestamp = TimeConverter::toTimestamp(time(NULL));
 }
 
-DocumentInfo::DocumentInfo(const DocumentInfo &other)
+DocumentInfo::DocumentInfo(const DocumentInfo &other) :
+	m_title(other.m_title),
+	m_location(other.m_location),
+	m_type(other.m_type),
+	m_language(other.m_language),
+	m_timestamp(other.m_timestamp)
 {
-	m_title = other.m_title;
-	m_location = other.m_location;
-	m_type = other.m_type;
-	m_language = other.m_language;
-	m_timestamp = other.m_timestamp;
+	copy(other.m_labels.begin(), other.m_labels.end(),
+		inserter(m_labels, m_labels.begin()));
 }
 
 DocumentInfo::~DocumentInfo()
@@ -54,6 +59,9 @@
 	m_type = other.m_type;
 	m_language = other.m_language;
 	m_timestamp = other.m_timestamp;
+	m_labels.clear();
+	copy(other.m_labels.begin(), other.m_labels.end(),
+		inserter(m_labels, m_labels.begin()));
 
 	return *this;
 }
@@ -127,3 +135,16 @@
 {
 	return m_timestamp;
 }
+/// Sets the document's labels.
+void DocumentInfo::setLabels(const set<string> &labels)
+{
+	copy(labels.begin(), labels.end(),
+		inserter(m_labels, m_labels.begin()));
+}
+
+/// Returns the document's labels.
+const set<string> &DocumentInfo::getLabels(void) const
+{
+	return m_labels;
+}
+

Modified: trunk/Utils/DocumentInfo.h
===================================================================
--- trunk/Utils/DocumentInfo.h	2006-07-14 12:08:55 UTC (rev 347)
+++ trunk/Utils/DocumentInfo.h	2006-07-14 12:12:57 UTC (rev 348)
@@ -18,6 +18,7 @@
 #define _DOCUMENT_INFO_H
 
 #include <string>
+#include <set>
 
 class DocumentInfo
 {
@@ -62,12 +63,19 @@
 		/// Returns the document's timestamp.
 		virtual std::string getTimestamp(void) const;
 
+		/// Sets the document's labels.
+		virtual void setLabels(const std::set<std::string> &labels);
+
+		/// Returns the document's labels.
+		virtual const std::set<std::string> &getLabels(void) const;
+
 	protected:
 		std::string m_title;
 		std::string m_location;
 		std::string m_type;
 		std::string m_language;
 		std::string m_timestamp;
+		std::set<std::string> m_labels;
 
 };
 



From fabricecolin at mail.berlios.de  Fri Jul 14 15:56:39 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 14 Jul 2006 15:56:39 +0200
Subject: [Pinot-svn] r349 - in trunk: Index Search
Message-ID: <200607141356.k6EDudvv025610@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-14 15:56:39 +0200 (Fri, 14 Jul 2006)
New Revision: 349

Modified:
   trunk/Index/XapianIndex.cpp
   trunk/Search/XapianEngine.cpp
Log:
Show the type of Xapian::Error when caught.


Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2006-07-14 12:12:57 UTC (rev 348)
+++ trunk/Index/XapianIndex.cpp	2006-07-14 13:56:39 UTC (rev 349)
@@ -52,10 +52,6 @@
 	IndexInterface(),
 	m_databaseName(indexName)
 {
-
-	string historyFile = indexName;
-	historyFile += "/history";
-
 	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
 	if ((pDatabase != NULL) &&
 		(pDatabase->isOpen() == true))
@@ -241,9 +237,9 @@
 		{
 			Xapian::Stem stemmer(*langIter);
 		}
-		catch (const Xapian::Error &e)
+		catch (const Xapian::Error &error)
 		{
-			cerr << "XapianIndex::scanDocument: no support for language " << *langIter << endl;
+			cerr << "XapianIndex::scanDocument: " << error.get_type() << ": " << error.get_msg() << endl;
 			continue;
 		}
 
@@ -344,7 +340,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't get document list: " << error.get_msg() << endl;
+		cerr << "Couldn't get document list: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -434,7 +430,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't index document: " << error.get_msg() << endl;
+		cerr << "Couldn't index document: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -490,7 +486,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't get document properties: " << error.get_msg() << endl;
+		cerr << "Couldn't get document properties: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -538,7 +534,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't check document labels: " << error.get_msg() << endl;
+		cerr << "Couldn't check document labels: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -590,7 +586,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't get document's labels: " << error.get_msg() << endl;
+		cerr << "Couldn't get document's labels: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -664,14 +660,13 @@
 			{
 				// Update the document in the database
 				pIndex->replace_document(docId, doc);
-				// FIXME: if the document information has changed, we need to update the history too
 				updated = true;
 			}
 		}
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't update document: " << error.get_msg() << endl;
+		cerr << "Couldn't update document: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -717,7 +712,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't update document properties: " << error.get_msg() << endl;
+		cerr << "Couldn't update document properties: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -782,7 +777,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't update document's labels: " << error.get_msg() << endl;
+		cerr << "Couldn't update document's labels: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -828,7 +823,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't look for document: " << error.get_msg() << endl;
+		cerr << "Couldn't look for document: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -868,7 +863,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't unindex document: " << error.get_msg() << endl;
+		cerr << "Couldn't unindex document: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -911,7 +906,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't unindex documents: " << error.get_msg() << endl;
+		cerr << "Couldn't unindex documents: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -964,7 +959,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't get terms: " << error.get_msg() << endl;
+		cerr << "Couldn't get terms: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -1016,7 +1011,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't delete label: " << error.get_msg() << endl;
+		cerr << "Couldn't delete label: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -1065,7 +1060,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't delete label: " << error.get_msg() << endl;
+		cerr << "Couldn't delete label: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -1102,7 +1097,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't flush database: " << error.get_msg() << endl;
+		cerr << "Couldn't flush database: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
@@ -1146,7 +1141,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't count documents: " << error.get_msg() << endl;
+		cerr << "Couldn't count documents: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 	catch (...)
 	{

Modified: trunk/Search/XapianEngine.cpp
===================================================================
--- trunk/Search/XapianEngine.cpp	2006-07-14 12:12:57 UTC (rev 348)
+++ trunk/Search/XapianEngine.cpp	2006-07-14 13:56:39 UTC (rev 349)
@@ -239,7 +239,7 @@
 		}
 		catch (const Xapian::Error &error)
 		{
-			cerr << "XapianEngine::queryDatabase: couldn't run query: "  << error.get_msg() << endl;
+			cerr << "XapianEngine::queryDatabase: " << error.get_type() << ": " << error.get_msg() << endl;
 		}
 	}
 	pDatabase->unlock();
@@ -261,7 +261,7 @@
 		if (extractWords(queryProps.getAndWords(), stemLanguage, andTerms) == true)
 		{
 #ifdef DEBUG
-			cout << "XapianEngine::stackQuery: OP_AND "  << andTerms.size() << endl;
+			cout << "XapianEngine::stackQuery: OP_AND " << andTerms.size() << endl;
 #endif
 			if (followOperators == true)
 			{
@@ -279,7 +279,7 @@
 		if (extractWords(queryProps.getPhrase(), stemLanguage, phraseTerms) == true)
 		{
 #ifdef DEBUG
-			cout << "XapianEngine::stackQuery: OP_PHRASE "  << phraseTerms.size() << endl;
+			cout << "XapianEngine::stackQuery: OP_PHRASE " << phraseTerms.size() << endl;
 #endif
 			if (followOperators == true)
 			{
@@ -297,7 +297,7 @@
 		if (extractWords(queryProps.getAnyWords(), stemLanguage, orTerms) == true)
 		{
 #ifdef DEBUG
-			cout << "XapianEngine::stackQuery: OP_OR "  << orTerms.size() << endl;
+			cout << "XapianEngine::stackQuery: OP_OR " << orTerms.size() << endl;
 #endif
 			if (followOperators == true)
 			{
@@ -315,7 +315,7 @@
 		if (extractWords(queryProps.getNotWords(), stemLanguage, notTerms) == true)
 		{
 #ifdef DEBUG
-			cout << "XapianEngine::stackQuery: OP_AND_NOT "  << notTerms.size() << endl;
+			cout << "XapianEngine::stackQuery: OP_AND_NOT " << notTerms.size() << endl;
 #endif
 			// We need something to AND_NOT these terms against
 			// Not following the operator would make us return documents
@@ -385,7 +385,7 @@
 		term = "L";
 		term += Languages::toCode(Languages::toEnglish(language));
 #ifdef DEBUG
-		cout << "XapianEngine::stackQuery: filter "  << term << endl;
+		cout << "XapianEngine::stackQuery: filter " << term << endl;
 #endif
 		languageTerms.push_back(term);
 		if (followOperators == true)
@@ -427,7 +427,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "XapianEngine::runQuery: couldn't run query: "  << error.get_msg() << endl;
+		cerr << "XapianEngine::runQuery: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 
 	return false;
@@ -473,12 +473,12 @@
 				Xapian::Query topQuery = queryStack.top();
 				queryStack.pop();
 #ifdef DEBUG
-				cout << "XapianEngine::runQuery: popped query, left "  << queryStack.size() << endl;
+				cout << "XapianEngine::runQuery: popped query, left " << queryStack.size() << endl;
 #endif
 				Xapian::Query query = Xapian::Query(Xapian::Query::OP_AND, queryStack.top(), topQuery);
 				queryStack.pop();
 #ifdef DEBUG
-				cout << "XapianEngine::runQuery: popped query, left "  << queryStack.size() << endl;
+				cout << "XapianEngine::runQuery: popped query, left " << queryStack.size() << endl;
 #endif
 				queryStack.push(query);
 			}
@@ -537,7 +537,7 @@
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "XapianEngine::runQuery: couldn't run query: "  << error.get_msg() << endl;
+		cerr << "XapianEngine::runQuery: " << error.get_type() << ": " << error.get_msg() << endl;
 	}
 
 	return false;



From fabricecolin at mail.berlios.de  Fri Jul 14 17:45:57 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 14 Jul 2006 17:45:57 +0200
Subject: [Pinot-svn] r350 - in trunk: Collect Search
Message-ID: <200607141545.k6EFjvWB001761@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-14 17:45:56 +0200 (Fri, 14 Jul 2006)
New Revision: 350

Modified:
   trunk/Collect/pinot-collect.cpp
   trunk/Search/pinot-search.cpp
Log:
In pinot-search, better call XapianDatabaseFactory::closeAll() before exiting.
Minor cleanup.


Modified: trunk/Collect/pinot-collect.cpp
===================================================================
--- trunk/Collect/pinot-collect.cpp	2006-07-14 13:56:39 UTC (rev 349)
+++ trunk/Collect/pinot-collect.cpp	2006-07-14 15:45:56 UTC (rev 350)
@@ -90,8 +90,8 @@
 	cout << "Parameters: " << thisUrl.getParameters() << endl;
 
 	// Which Downloader ?
-	DownloaderInterface *myDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
-	if (myDownloader == NULL)
+	DownloaderInterface *pDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
+	if (pDownloader == NULL)
 	{
 		cerr << "Couldn't obtain downloader for protocol " << thisUrl.getProtocol() << endl;
 
@@ -101,10 +101,8 @@
 		return EXIT_FAILURE;
 	}
 
-	unsigned int urlContentLen;
-	string contentType;
 	DocumentInfo docInfo("Test", url, "", "");
-	Document *pDoc = myDownloader->retrieveUrl(docInfo);
+	Document *pDoc = pDownloader->retrieveUrl(docInfo);
 	if (pDoc == NULL)
 	{
 		cerr << "Download operation failed !" << endl;
@@ -126,7 +124,7 @@
 				fileName = "index.html";
 			}
 
-			cout << "Saving " << urlContentLen << " bytes to " << fileName << endl;
+			cout << "Saving " << contentLen << " bytes to " << fileName << endl;
 
 			// Save the content to a file
 			ofstream outputFile(fileName.c_str());
@@ -141,7 +139,7 @@
 		delete pDoc;
 	}
 
-	delete myDownloader;
+	delete pDownloader;
 
 	DownloaderInterface::shutdown();
 	MIMEScanner::shutdown();

Modified: trunk/Search/pinot-search.cpp
===================================================================
--- trunk/Search/pinot-search.cpp	2006-07-14 13:56:39 UTC (rev 349)
+++ trunk/Search/pinot-search.cpp	2006-07-14 15:45:56 UTC (rev 350)
@@ -23,6 +23,7 @@
 
 #include "MIMEScanner.h"
 #include "Url.h"
+#include "XapianDatabaseFactory.h"
 #include "XmlTokenizer.h"
 #include "SearchEngineFactory.h"
 #include "DownloaderFactory.h"
@@ -98,8 +99,8 @@
 	// Which SearchEngine ?
 	type = argv[1];
 	option = argv[2];
-	SearchEngineInterface *myEngine = SearchEngineFactory::getSearchEngine(type, option);
-	if (myEngine == NULL)
+	SearchEngineInterface *pEngine = SearchEngineFactory::getSearchEngine(type, option);
+	if (pEngine == NULL)
 	{
 		cerr << "Couldn't obtain search engine instance" << endl;
 
@@ -111,15 +112,15 @@
 
 	// How many results ?
 	unsigned int count = atoi(argv[4]);
-	myEngine->setMaxResultsCount(count);
+	pEngine->setMaxResultsCount(count);
 
 	QueryProperties queryProps("senginetest", argv[3], "", "", "");
-	if (myEngine->runQuery(queryProps) == true)
+	if (pEngine->runQuery(queryProps) == true)
 	{
 		string resultsPage;
 
 		// Try getting a list of links
-		const vector<Result> resultsList = myEngine->getResults();
+		const vector<Result> resultsList = pEngine->getResults();
 		if (resultsList.empty() == false)
 		{
 			unsigned int count = 0;
@@ -155,8 +156,9 @@
 		cerr << "Couldn't run query on search engine " << argv[1] << endl;
 	}
 
-	delete myEngine;
+	delete pEngine;
 
+	XapianDatabaseFactory::closeAll();
 	DownloaderInterface::shutdown();
 	MIMEScanner::shutdown();
 



From fabricecolin at mail.berlios.de  Fri Jul 14 17:57:13 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 14 Jul 2006 17:57:13 +0200
Subject: [Pinot-svn] r351 - trunk/Index
Message-ID: <200607141557.k6EFvDvY002361@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-14 17:57:09 +0200 (Fri, 14 Jul 2006)
New Revision: 351

Modified:
   trunk/Index/indextest.cpp
Log:
Updated this, it should prove useful later.


Modified: trunk/Index/indextest.cpp
===================================================================
--- trunk/Index/indextest.cpp	2006-07-14 15:45:56 UTC (rev 350)
+++ trunk/Index/indextest.cpp	2006-07-14 15:57:09 UTC (rev 351)
@@ -14,109 +14,198 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
  
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
+#include <getopt.h>
+#include <cstdlib>
+#include <cstdio>
+#include <iostream>
 #include <string>
-#include <set>
-#include <iostream>
+#include <fstream>
 
-#include "Document.h"
+#include "MIMEScanner.h"
+#include "Url.h"
+#include "XapianDatabaseFactory.h"
 #include "TokenizerFactory.h"
-#include "XapianDatabaseFactory.h"
+#include "DownloaderFactory.h"
 #include "XapianIndex.h"
+#include "config.h"
 
 using namespace std;
 
+static struct option g_longOptions[] = {
+	{"check", 1, 0, 'c'},
+	{"help", 0, 0, 'h'},
+	{"index", 1, 0, 'i'},
+	{"stats", 0, 0, 's'},
+	{"version", 0, 0, 'v'},
+	{0, 0, 0, 0}
+};
+
 int main(int argc, char **argv)
 {
-	bool success = false;
+	string type, option;
+	int longOptionIndex = 0;
+	string parameter;
+	bool checkDocument = false, indexDocument = false, statIndex = false, success = false;
 
+	// Look at the options
+	int optionChar = getopt_long(argc, argv, "hv", g_longOptions, &longOptionIndex);
+	while (optionChar != -1)
+	{
+		set<string> engines;
+
+		switch (optionChar)
+		{
+			case 'c':
+				if (optarg != NULL)
+				{
+					parameter = optarg;
+				}
+				checkDocument = true;
+				break;
+			case 'h':
+				// Help
+				cout << "pinot-index - Query search engines from the command-line\n\n"
+					<< "Usage: pinot-search [OPTIONS] INDEXTYPE INDEXLOCATION\n\n"
+					<< "Options:\n"
+					<< "  -c, --check		check whether the given URL is in the index\n"
+					<< "  -h, --help		display this help and exit\n"
+					<< "  -i, --index		index the given URL\n"
+					<< "  -s, --stats		print statistics about the index (default option)\n"
+					<< "  -v, --version		output version information and exit\n\n";
+				cout << "\n\nExamples:\n"
+					<< "pinot-index --check http://pinot.berlios.de/ xapian ~/.pinot/index\n\n"
+					<< "pinot-index --stats xapian ~/.pinot/index\n\n"
+					<< "pinot-index --index http://pinot.berlios.de/ xapian ~/.pinot/index\n\n"
+					<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
+				return EXIT_SUCCESS;
+			case 'i':
+				if (optarg != NULL)
+				{
+					parameter = optarg;
+				}
+				indexDocument = true;
+				break;
+			case 's':
+				if (optarg != NULL)
+				{
+					parameter = optarg;
+				}
+				statIndex = true;
+				break;
+			case 'v':
+				cout << "pinot-index - " << PACKAGE_STRING << "\n\n"
+					<< "This is free software.  You may redistribute copies of it under the terms of\n"
+					<< "the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\n"
+					<< "There is NO WARRANTY, to the extent permitted by law." << endl;
+				return EXIT_SUCCESS;
+			default:
+				return EXIT_FAILURE;
+		}
+
+		// Next option
+		optionChar = getopt_long(argc, argv, "hv", g_longOptions, &longOptionIndex);
+	}
+
 	if (argc < 3)
 	{
-		cerr << "Usage: " << argv[0] << " <index type> <database name> CHECK|CREATE|HASURL=<url>|INDEX=<file name>" << endl;
+		cerr << "Not enough parameters" << endl;
 		return EXIT_FAILURE;
 	}
 
-	// Check database ?
-	if (strncasecmp(argv[3], "CHECK", 5) == 0)
+	MIMEScanner::initialize();
+	DownloaderInterface::initialize();
+
+	// FIXME: do stuff
+	XapianIndex index(argv[2]);
+
+	if (checkDocument == true)
 	{
-		XapianIndex index(argv[2]);
-
 		if (index.isGood() == true)
 		{
-			cout << "Index has " << index.getDocumentsCount() << " document(s)" << endl;
-			success = true;
+			unsigned int docId = index.hasDocument(parameter);
+			if (docId > 0)
+			{
+				cout << parameter << ": document ID " << docId << endl;
+				success = true;
+			}
 		}
 	}
-	// Create database ?
-	else if (strncasecmp(argv[3], "CREATE", 6) == 0)
+	if (indexDocument == true)
 	{
-		if (XapianDatabaseFactory::getDatabase(argv[2], false) != NULL)
+		Url thisUrl(parameter);
+
+		// Which Downloader ?
+		DownloaderInterface *pDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
+		if (pDownloader == NULL)
 		{
-			success = true;
+			cerr << "Couldn't obtain downloader for protocol " << thisUrl.getProtocol() << endl;
+
+			XapianDatabaseFactory::closeAll();
+			DownloaderInterface::shutdown();
+			MIMEScanner::shutdown();
+
+			return EXIT_FAILURE;
 		}
-	}
-	// Look for an URL ?
-	else if (strncasecmp(argv[3], "HASURL", 6) == 0)
-	{
-		XapianIndex index(argv[2]);
 
-		if ((index.isGood() == true) &&
-			(index.hasDocument(argv[3] + 7) > 0))
+		DocumentInfo docInfo(parameter, parameter, MIMEScanner::scanUrl(thisUrl), "");
+		Document *pDoc = pDownloader->retrieveUrl(docInfo);
+		if (pDoc == NULL)
 		{
-			success = true;
+			cerr << "Download operation failed !" << endl;
 		}
-	}
-	// Index a file ?
-	else if (strncasecmp(argv[3], "INDEX", 5) == 0)
-	{
-		struct stat fileStat;
-		string fileName(argv[3] + 6);
-
-		if ((stat(fileName.c_str(), &fileStat) == 0) &&
-			(S_ISREG(fileStat.st_mode)))
+		else
 		{
-			char *buffer = new char[fileStat.st_size + 1];
-			int fd = open(fileName.c_str(), O_RDONLY);
-			// Read the file
-			ssize_t readBytes = read(fd, buffer, fileStat.st_size);
-			if (readBytes > 0)
+			// Tokenize this document
+			Tokenizer *pTokens = TokenizerFactory::getTokenizerByType(docInfo.getType(), pDoc);
+			if (pTokens != NULL)
 			{
-				// Assume file is HTML...
-				Document doc(fileName, fileName, "text/html", "");
-				doc.setData(buffer, readBytes);
-				if (doc.isBinary() == false)
+				set<string> labels;
+
+				index.setStemmingMode(IndexInterface::STORE_BOTH);
+
+				// Update an existing document or add to the index ?
+				unsigned int docId = index.hasDocument(parameter);
+				if (docId > 0)
 				{
-					set<string> labels;
-					unsigned int docId = 0;
-
-					Tokenizer *pTokens = TokenizerFactory::getTokenizer(fileName, &doc);
-					if (pTokens != NULL)
+					// Update the document
+					if (index.updateDocument(docId, *pTokens) == true)
 					{
-						// Ignore index type, use a XapianIndex
-						XapianIndex index(argv[2]);
-						index.setStemmingMode(IndexInterface::STORE_BOTH);
-						if (index.indexDocument(*pTokens, labels, docId) == true)
-						{
-							cout << "Added " << fileName << " to index, document" << docId << endl;
-							success = true;
-						}
-
-						delete pTokens;
+						success = true;
 					}
 				}
+				else
+				{
+					// Index the document
+					success = index.indexDocument(*pTokens, labels, docId);
+				}
 
-				delete[] buffer;
+				if (success == true)
+				{
+					// Flush the index
+					index.flush();
+				}
+
+				delete pTokens;
 			}
+
+			delete pDoc;
 		}
+
+		delete pDownloader;
 	}
+	if (statIndex == true)
+	{
+		if (index.isGood() == true)
+		{
+			success = true;
+		}
+	}
 
 	XapianDatabaseFactory::closeAll();
+	DownloaderInterface::shutdown();
+	MIMEScanner::shutdown();
 
+	// Did whatever operation we carried out succeed ?
 	if (success == true)
 	{
 		return EXIT_SUCCESS;



From fabricecolin at mail.berlios.de  Fri Jul 14 18:18:21 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 14 Jul 2006 18:18:21 +0200
Subject: [Pinot-svn] r352 - trunk/Utils
Message-ID: <200607141618.k6EGILW2004264@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-14 18:18:21 +0200 (Fri, 14 Jul 2006)
New Revision: 352

Modified:
   trunk/Utils/XapianDatabase.cpp
   trunk/Utils/XapianDatabase.h
Log:
Try to open the database if it's not already when one of the getter methods
is called.


Modified: trunk/Utils/XapianDatabase.cpp
===================================================================
--- trunk/Utils/XapianDatabase.cpp	2006-07-14 15:57:09 UTC (rev 351)
+++ trunk/Utils/XapianDatabase.cpp	2006-07-14 16:18:21 UTC (rev 352)
@@ -35,9 +35,18 @@
 	m_isOpen(false)
 {
 	pthread_rwlock_init(&m_rwLock, NULL);
-	m_isOpen = openDatabase();
+	openDatabase();
 }
 
+XapianDatabase::XapianDatabase(const XapianDatabase &other) :
+	m_databaseName(other.m_databaseName),
+	m_readOnly(other.m_readOnly),
+	m_pDatabase(other.m_pDatabase),
+	m_isOpen(other.m_isOpen)
+{
+	pthread_rwlock_init(&m_rwLock, NULL);
+}
+
 XapianDatabase::~XapianDatabase()
 {
 	if (m_pDatabase != NULL)
@@ -47,15 +56,38 @@
 	pthread_rwlock_destroy(&m_rwLock);
 }
 
-bool XapianDatabase::openDatabase(void)
+XapianDatabase &XapianDatabase::operator=(const XapianDatabase &other)
 {
+	m_databaseName = other.m_databaseName;
+	m_readOnly = other.m_readOnly;
+	if (m_pDatabase != NULL)
+	{
+		delete m_pDatabase;
+	}
+	m_pDatabase = other.m_pDatabase;
+	m_isOpen = other.m_isOpen;
+
+	return *this;
+}
+
+void XapianDatabase::openDatabase(void)
+{
 	struct stat dbStat;
 
 	if (m_databaseName.empty() == true)
 	{
-		return false;
+		return;
 	}
 
+	// Assume things will fail
+	m_isOpen = false;
+
+	if (m_pDatabase != NULL)
+	{
+		delete m_pDatabase;
+		m_pDatabase = NULL;
+	}
+
 	// Is it a remote database ?
 	string::size_type colonPos = m_databaseName.find(":");
 	if ((m_databaseName[0] != '/') &&
@@ -67,7 +99,7 @@
 		if (m_readOnly == false)
 		{
 			cerr << "XapianDatabase::openDatabase: remote databases are read-only" << endl;
-			return false;
+			return;
 		}
 
 		try
@@ -78,8 +110,9 @@
 #endif
 			Xapian::Database remoteDatabase = Xapian::Remote::open(hostName, port);
 			m_pDatabase = new Xapian::Database(remoteDatabase);
+			m_isOpen = true;
 
-			return true;
+			return;
 		}
 		catch (const Xapian::Error &error)
 		{
@@ -87,7 +120,7 @@
 				<< error.get_msg() << endl;
 		}
 
-		return false;		
+		return;		
 	}
 
 	// It's a local database : the specified path must be a directory
@@ -97,7 +130,7 @@
 		{
 			cerr << "XapianDatabase::openDatabase: database " << m_databaseName
 				<< " doesn't exist" << endl;
-			return false;
+			return;
 		}
 
 		// Database directory doesn't exist, create it (mode 755)
@@ -105,14 +138,14 @@
 		{
 			cerr << "XapianDatabase::openDatabase: couldn't create database directory "
 				<< m_databaseName << endl;
-			return false;
+			return;
 		}
 	}
 	else if (!S_ISDIR(dbStat.st_mode))
 	{
 		cerr << "XapianDatabase::openDatabase: " << m_databaseName
 			<< " is not a directory" << endl;
-		return false;
+		return;
 	}
 
 	// Try opening it now, creating if if necessary
@@ -126,8 +159,9 @@
 		{
 			m_pDatabase = new Xapian::WritableDatabase(m_databaseName, Xapian::DB_CREATE_OR_OPEN);
 		}
+		m_isOpen = true;
 
-		return true;
+		return;
 	}
 	catch (const Xapian::Error &error)
 	{
@@ -135,7 +169,7 @@
 			<< error.get_msg() << endl;
 	}
 
-	return false;
+	return;
 }
 
 /// Returns false if the database couldn't be opened.
@@ -152,6 +186,11 @@
 #endif
 	if (pthread_rwlock_rdlock(&m_rwLock) == 0)
 	{
+		if (m_pDatabase == NULL)
+		{
+			// Try again
+			openDatabase();
+		}
 		return m_pDatabase;
 	}
 
@@ -174,6 +213,11 @@
 #endif
 	if (pthread_rwlock_wrlock(&m_rwLock) == 0)
 	{
+		if (m_pDatabase == NULL)
+		{
+			// Try again
+			openDatabase();
+		}
 		return dynamic_cast<Xapian::WritableDatabase *>(m_pDatabase);
 	}
 

Modified: trunk/Utils/XapianDatabase.h
===================================================================
--- trunk/Utils/XapianDatabase.h	2006-07-14 15:57:09 UTC (rev 351)
+++ trunk/Utils/XapianDatabase.h	2006-07-14 16:18:21 UTC (rev 352)
@@ -51,7 +51,7 @@
 		Xapian::Database *m_pDatabase;
 		bool m_isOpen;
 
-		bool openDatabase(void);
+		void openDatabase(void);
 
 };
 



From fabricecolin at mail.berlios.de  Sat Jul 15 15:34:15 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 15 Jul 2006 15:34:15 +0200
Subject: [Pinot-svn] r353 - in trunk: Index Search UI/GTK2/src Utils
Message-ID: <200607151334.k6FDYFjr021080@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-15 15:34:12 +0200 (Sat, 15 Jul 2006)
New Revision: 353

Modified:
   trunk/Index/XapianIndex.cpp
   trunk/Search/XapianEngine.cpp
   trunk/UI/GTK2/src/indexDialog.cc
   trunk/Utils/XapianDatabase.cpp
Log:
In XapianIndex::listDocuments*(), don't limit the number of document IDs if
maxDocsCount is 0.
In XapianEngine, use OP_FILTER for filters when possible so that weights are
not skewed.
In XapianDatabase and indexDialog, remote indexes have a location with no slash,
rather than one that doesn't start with a slash !


Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2006-07-14 16:18:21 UTC (rev 352)
+++ trunk/Index/XapianIndex.cpp	2006-07-15 13:34:12 UTC (rev 353)
@@ -324,7 +324,8 @@
 #endif
 			// Get a list of documents that have the term
 			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
-				(postingIter != pIndex->postlist_end(term)) && (docIds.size() < maxDocsCount);
+				(postingIter != pIndex->postlist_end(term)) &&
+					((maxDocsCount == 0) || (docIds.size() < maxDocsCount));
 				++postingIter)
 			{
 				Xapian::docid docId = *postingIter;

Modified: trunk/Search/XapianEngine.cpp
===================================================================
--- trunk/Search/XapianEngine.cpp	2006-07-14 16:18:21 UTC (rev 352)
+++ trunk/Search/XapianEngine.cpp	2006-07-15 13:34:12 UTC (rev 353)
@@ -341,7 +341,14 @@
 		hostTerms.push_back(term);
 		if (followOperators == true)
 		{
-			queryOp = Xapian::Query::OP_AND;
+			if (queryStack.empty() == false)
+			{
+				queryOp = Xapian::Query::OP_FILTER;
+			}
+			else
+			{
+				queryOp = Xapian::Query::OP_AND;
+			}
 		}
 		queryStack.push(Xapian::Query(queryOp, hostTerms.begin(), hostTerms.end()));
 	}
@@ -356,7 +363,14 @@
 		fileTerms.push_back(term);
 		if (followOperators == true)
 		{
-			queryOp = Xapian::Query::OP_AND;
+			if (queryStack.empty() == false)
+			{
+				queryOp = Xapian::Query::OP_FILTER;
+			}
+			else
+			{
+				queryOp = Xapian::Query::OP_AND;
+			}
 		}
 		queryStack.push(Xapian::Query(queryOp, fileTerms.begin(), fileTerms.end()));
 	}
@@ -371,7 +385,14 @@
 		labelTerms.push_back(term);
 		if (followOperators == true)
 		{
-			queryOp = Xapian::Query::OP_AND;
+			if (queryStack.empty() == false)
+			{
+				queryOp = Xapian::Query::OP_FILTER;
+			}
+			else
+			{
+				queryOp = Xapian::Query::OP_AND;
+			}
 		}
 		queryStack.push(Xapian::Query(queryOp, labelTerms.begin(), labelTerms.end()));
 	}
@@ -390,7 +411,14 @@
 		languageTerms.push_back(term);
 		if (followOperators == true)
 		{
-			queryOp = Xapian::Query::OP_AND;
+			if (queryStack.empty() == false)
+			{
+				queryOp = Xapian::Query::OP_FILTER;
+			}
+			else
+			{
+				queryOp = Xapian::Query::OP_AND;
+			}
 		}
 		queryStack.push(Xapian::Query(queryOp, languageTerms.begin(), languageTerms.end()));
 	}

Modified: trunk/UI/GTK2/src/indexDialog.cc
===================================================================
--- trunk/UI/GTK2/src/indexDialog.cc	2006-07-14 16:18:21 UTC (rev 352)
+++ trunk/UI/GTK2/src/indexDialog.cc	2006-07-15 13:34:12 UTC (rev 353)
@@ -66,8 +66,9 @@
 	nameEntry->set_text(name);
 
 	// Type and location
+	ustring::size_type slashPos = location.find("/");
 	ustring::size_type colonPos = location.find(":");
-	if ((location[0] != '/') &&
+	if ((slashPos == ustring::npos) &&
 		(colonPos != ustring::npos))
 	{
 		// This is a remote index
@@ -125,18 +126,19 @@
 	ustring location = locationEntry->get_text();
 	if (location.empty() == false)
 	{
-		bool startsWithSlash = false;
+		bool hasSlash = true;
 
-		if (location[0] == '/')
+		ustring::size_type slashPos = location.find("/");
+		if (slashPos == ustring::npos)
 		{
-			startsWithSlash = true;
+			hasSlash = false;
 		}
 
 		// Disable the OK button if the type+location pair doesn't make sense
 		// or if name is empty
 		ustring name = nameEntry->get_text();
 		if ((name.empty() == false) &&
-			(startsWithSlash == isLocal))
+			(hasSlash == isLocal))
 		{
 			enableOkButton = true;
 		}

Modified: trunk/Utils/XapianDatabase.cpp
===================================================================
--- trunk/Utils/XapianDatabase.cpp	2006-07-14 16:18:21 UTC (rev 352)
+++ trunk/Utils/XapianDatabase.cpp	2006-07-15 13:34:12 UTC (rev 353)
@@ -89,8 +89,9 @@
 	}
 
 	// Is it a remote database ?
+	string::size_type slashPos = m_databaseName.find("/");
 	string::size_type colonPos = m_databaseName.find(":");
-	if ((m_databaseName[0] != '/') &&
+	if ((slashPos == string::npos) &&
 		(colonPos != string::npos))
 	{
 		string hostName = m_databaseName.substr(0, colonPos);



From fabricecolin at mail.berlios.de  Sat Jul 15 15:44:23 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 15 Jul 2006 15:44:23 +0200
Subject: [Pinot-svn] r354 - trunk/Index
Message-ID: <200607151344.k6FDiNk2023473@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-15 15:44:22 +0200 (Sat, 15 Jul 2006)
New Revision: 354

Added:
   trunk/Index/pinot-index.1
   trunk/Index/pinot-index.cpp
Removed:
   trunk/Index/indextest.cpp
Log:
Renamed indextest.cpp to pinot-index.cpp. Added man page.


Deleted: trunk/Index/indextest.cpp
===================================================================
--- trunk/Index/indextest.cpp	2006-07-15 13:34:12 UTC (rev 353)
+++ trunk/Index/indextest.cpp	2006-07-15 13:44:22 UTC (rev 354)
@@ -1,215 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
- 
-#include <getopt.h>
-#include <cstdlib>
-#include <cstdio>
-#include <iostream>
-#include <string>
-#include <fstream>
-
-#include "MIMEScanner.h"
-#include "Url.h"
-#include "XapianDatabaseFactory.h"
-#include "TokenizerFactory.h"
-#include "DownloaderFactory.h"
-#include "XapianIndex.h"
-#include "config.h"
-
-using namespace std;
-
-static struct option g_longOptions[] = {
-	{"check", 1, 0, 'c'},
-	{"help", 0, 0, 'h'},
-	{"index", 1, 0, 'i'},
-	{"stats", 0, 0, 's'},
-	{"version", 0, 0, 'v'},
-	{0, 0, 0, 0}
-};
-
-int main(int argc, char **argv)
-{
-	string type, option;
-	int longOptionIndex = 0;
-	string parameter;
-	bool checkDocument = false, indexDocument = false, statIndex = false, success = false;
-
-	// Look at the options
-	int optionChar = getopt_long(argc, argv, "hv", g_longOptions, &longOptionIndex);
-	while (optionChar != -1)
-	{
-		set<string> engines;
-
-		switch (optionChar)
-		{
-			case 'c':
-				if (optarg != NULL)
-				{
-					parameter = optarg;
-				}
-				checkDocument = true;
-				break;
-			case 'h':
-				// Help
-				cout << "pinot-index - Query search engines from the command-line\n\n"
-					<< "Usage: pinot-search [OPTIONS] INDEXTYPE INDEXLOCATION\n\n"
-					<< "Options:\n"
-					<< "  -c, --check		check whether the given URL is in the index\n"
-					<< "  -h, --help		display this help and exit\n"
-					<< "  -i, --index		index the given URL\n"
-					<< "  -s, --stats		print statistics about the index (default option)\n"
-					<< "  -v, --version		output version information and exit\n\n";
-				cout << "\n\nExamples:\n"
-					<< "pinot-index --check http://pinot.berlios.de/ xapian ~/.pinot/index\n\n"
-					<< "pinot-index --stats xapian ~/.pinot/index\n\n"
-					<< "pinot-index --index http://pinot.berlios.de/ xapian ~/.pinot/index\n\n"
-					<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
-				return EXIT_SUCCESS;
-			case 'i':
-				if (optarg != NULL)
-				{
-					parameter = optarg;
-				}
-				indexDocument = true;
-				break;
-			case 's':
-				if (optarg != NULL)
-				{
-					parameter = optarg;
-				}
-				statIndex = true;
-				break;
-			case 'v':
-				cout << "pinot-index - " << PACKAGE_STRING << "\n\n"
-					<< "This is free software.  You may redistribute copies of it under the terms of\n"
-					<< "the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\n"
-					<< "There is NO WARRANTY, to the extent permitted by law." << endl;
-				return EXIT_SUCCESS;
-			default:
-				return EXIT_FAILURE;
-		}
-
-		// Next option
-		optionChar = getopt_long(argc, argv, "hv", g_longOptions, &longOptionIndex);
-	}
-
-	if (argc < 3)
-	{
-		cerr << "Not enough parameters" << endl;
-		return EXIT_FAILURE;
-	}
-
-	MIMEScanner::initialize();
-	DownloaderInterface::initialize();
-
-	// FIXME: do stuff
-	XapianIndex index(argv[2]);
-
-	if (checkDocument == true)
-	{
-		if (index.isGood() == true)
-		{
-			unsigned int docId = index.hasDocument(parameter);
-			if (docId > 0)
-			{
-				cout << parameter << ": document ID " << docId << endl;
-				success = true;
-			}
-		}
-	}
-	if (indexDocument == true)
-	{
-		Url thisUrl(parameter);
-
-		// Which Downloader ?
-		DownloaderInterface *pDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
-		if (pDownloader == NULL)
-		{
-			cerr << "Couldn't obtain downloader for protocol " << thisUrl.getProtocol() << endl;
-
-			XapianDatabaseFactory::closeAll();
-			DownloaderInterface::shutdown();
-			MIMEScanner::shutdown();
-
-			return EXIT_FAILURE;
-		}
-
-		DocumentInfo docInfo(parameter, parameter, MIMEScanner::scanUrl(thisUrl), "");
-		Document *pDoc = pDownloader->retrieveUrl(docInfo);
-		if (pDoc == NULL)
-		{
-			cerr << "Download operation failed !" << endl;
-		}
-		else
-		{
-			// Tokenize this document
-			Tokenizer *pTokens = TokenizerFactory::getTokenizerByType(docInfo.getType(), pDoc);
-			if (pTokens != NULL)
-			{
-				set<string> labels;
-
-				index.setStemmingMode(IndexInterface::STORE_BOTH);
-
-				// Update an existing document or add to the index ?
-				unsigned int docId = index.hasDocument(parameter);
-				if (docId > 0)
-				{
-					// Update the document
-					if (index.updateDocument(docId, *pTokens) == true)
-					{
-						success = true;
-					}
-				}
-				else
-				{
-					// Index the document
-					success = index.indexDocument(*pTokens, labels, docId);
-				}
-
-				if (success == true)
-				{
-					// Flush the index
-					index.flush();
-				}
-
-				delete pTokens;
-			}
-
-			delete pDoc;
-		}
-
-		delete pDownloader;
-	}
-	if (statIndex == true)
-	{
-		if (index.isGood() == true)
-		{
-			success = true;
-		}
-	}
-
-	XapianDatabaseFactory::closeAll();
-	DownloaderInterface::shutdown();
-	MIMEScanner::shutdown();
-
-	// Did whatever operation we carried out succeed ?
-	if (success == true)
-	{
-		return EXIT_SUCCESS;
-	}
-
-	return EXIT_FAILURE;
-}

Added: trunk/Index/pinot-index.1
===================================================================
--- trunk/Index/pinot-index.1	2006-07-15 13:34:12 UTC (rev 353)
+++ trunk/Index/pinot-index.1	2006-07-15 13:44:22 UTC (rev 354)
@@ -0,0 +1,32 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
+.TH PINOT-INDEX "1" "July 2006" "pinot-index - pinot 0.50" "User Commands"
+.SH NAME
+pinot-index \- Index documents from the command-line
+.SH SYNOPSIS
+.B pinot-search
+[\fIOPTIONS\fR] \fIINDEXTYPE INDEXLOCATION\fR
+.SH DESCRIPTION
+pinot\-index \- Index documents from the command\-line
+.SH OPTIONS
+.TP
+\fB\-c\fR, \fB\-\-check\fR
+check whether the given URL is in the index
+.TP
+\fB\-h\fR, \fB\-\-help\fR
+display this help and exit
+.TP
+\fB\-i\fR, \fB\-\-index\fR
+index the given URL
+.TP
+\fB\-v\fR, \fB\-\-version\fR
+output version information and exit
+.SH EXAMPLES
+pinot\-index \fB\-\-check\fR http://pinot.berlios.de/ xapian ~/.pinot/index
+.PP
+pinot\-index \fB\-\-index\fR http://pinot.berlios.de/ xapian ~/.pinot/index
+.SH "REPORTING BUGS"
+Report bugs to fabricecolin at users.berlios.de
+.PP
+This is free software.  You may redistribute copies of it under the terms of
+the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
+There is NO WARRANTY, to the extent permitted by law.

Copied: trunk/Index/pinot-index.cpp (from rev 351, trunk/Index/indextest.cpp)
===================================================================
--- trunk/Index/indextest.cpp	2006-07-14 15:57:09 UTC (rev 351)
+++ trunk/Index/pinot-index.cpp	2006-07-15 13:44:22 UTC (rev 354)
@@ -0,0 +1,202 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#include <getopt.h>
+#include <cstdlib>
+#include <cstdio>
+#include <iostream>
+#include <string>
+#include <fstream>
+
+#include "MIMEScanner.h"
+#include "Url.h"
+#include "XapianDatabaseFactory.h"
+#include "TokenizerFactory.h"
+#include "DownloaderFactory.h"
+#include "XapianIndex.h"
+#include "config.h"
+
+using namespace std;
+
+static struct option g_longOptions[] = {
+	{"check", 1, 0, 'c'},
+	{"help", 0, 0, 'h'},
+	{"index", 1, 0, 'i'},
+	{"version", 0, 0, 'v'},
+	{0, 0, 0, 0}
+};
+
+int main(int argc, char **argv)
+{
+	string type, option;
+	int longOptionIndex = 0;
+	string urlToCheck, urlToIndex;
+	bool checkDocument = false, indexDocument = false, success = false;
+
+	// Look at the options
+	int optionChar = getopt_long(argc, argv, "c:hi:v", g_longOptions, &longOptionIndex);
+	while (optionChar != -1)
+	{
+		set<string> engines;
+
+		switch (optionChar)
+		{
+			case 'c':
+				if (optarg != NULL)
+				{
+					urlToCheck = optarg;
+				}
+				checkDocument = true;
+				break;
+			case 'h':
+				// Help
+				cout << "pinot-index - Index documents from the command-line\n\n"
+					<< "Usage: pinot-search [OPTIONS] INDEXTYPE INDEXLOCATION\n\n"
+					<< "Options:\n"
+					<< "  -c, --check		check whether the given URL is in the index\n"
+					<< "  -h, --help		display this help and exit\n"
+					<< "  -i, --index		index the given URL\n"
+					<< "  -v, --version		output version information and exit\n\n";
+				cout << "\n\nExamples:\n"
+					<< "pinot-index --check http://pinot.berlios.de/ xapian ~/.pinot/index\n\n"
+					<< "pinot-index --index http://pinot.berlios.de/ xapian ~/.pinot/index\n\n"
+					<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
+				return EXIT_SUCCESS;
+			case 'i':
+				if (optarg != NULL)
+				{
+					urlToIndex = optarg;
+				}
+				indexDocument = true;
+				break;
+			case 'v':
+				cout << "pinot-index - " << PACKAGE_STRING << "\n\n"
+					<< "This is free software.  You may redistribute copies of it under the terms of\n"
+					<< "the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\n"
+					<< "There is NO WARRANTY, to the extent permitted by law." << endl;
+				return EXIT_SUCCESS;
+			default:
+				return EXIT_FAILURE;
+		}
+
+		// Next option
+		optionChar = getopt_long(argc, argv, "c:hi:v", g_longOptions, &longOptionIndex);
+	}
+
+	if ((argc < 3) ||
+		(optind >= argc) ||
+		(optind + 2 < argc) ||
+		((indexDocument == false) && (checkDocument == false)))
+	{
+		cerr << "Incorrect parameters" << endl;
+		return EXIT_FAILURE;
+	}
+
+	MIMEScanner::initialize();
+	DownloaderInterface::initialize();
+
+	// FIXME: don't ignore the index type
+
+	XapianIndex index(argv[optind + 1]);
+
+	if (checkDocument == true)
+	{
+		if (index.isGood() == true)
+		{
+			unsigned int docId = index.hasDocument(urlToCheck);
+			if (docId > 0)
+			{
+				cout << urlToCheck << ": document ID " << docId << endl;
+				success = true;
+			}
+		}
+	}
+	if (indexDocument == true)
+	{
+		Url thisUrl(urlToIndex);
+
+		// Which Downloader ?
+		DownloaderInterface *pDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
+		if (pDownloader == NULL)
+		{
+			cerr << "Couldn't obtain downloader for protocol " << thisUrl.getProtocol() << endl;
+
+			XapianDatabaseFactory::closeAll();
+			DownloaderInterface::shutdown();
+			MIMEScanner::shutdown();
+
+			return EXIT_FAILURE;
+		}
+
+		DocumentInfo docInfo(urlToIndex, urlToIndex, MIMEScanner::scanUrl(thisUrl), "");
+		Document *pDoc = pDownloader->retrieveUrl(docInfo);
+		if (pDoc == NULL)
+		{
+			cerr << "Download operation failed !" << endl;
+		}
+		else
+		{
+			// Tokenize this document
+			Tokenizer *pTokens = TokenizerFactory::getTokenizerByType(docInfo.getType(), pDoc);
+			if (pTokens != NULL)
+			{
+				set<string> labels;
+
+				index.setStemmingMode(IndexInterface::STORE_BOTH);
+
+				// Update an existing document or add to the index ?
+				unsigned int docId = index.hasDocument(urlToIndex);
+				if (docId > 0)
+				{
+					// Update the document
+					if (index.updateDocument(docId, *pTokens) == true)
+					{
+						success = true;
+					}
+				}
+				else
+				{
+					// Index the document
+					success = index.indexDocument(*pTokens, labels, docId);
+				}
+
+				if (success == true)
+				{
+					// Flush the index
+					index.flush();
+				}
+
+				delete pTokens;
+			}
+
+			delete pDoc;
+		}
+
+		delete pDownloader;
+	}
+
+	XapianDatabaseFactory::closeAll();
+	DownloaderInterface::shutdown();
+	MIMEScanner::shutdown();
+
+	// Did whatever operation we carried out succeed ?
+	if (success == true)
+	{
+		return EXIT_SUCCESS;
+	}
+
+	return EXIT_FAILURE;
+}



From fabricecolin at mail.berlios.de  Sun Jul 16 12:09:23 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sun, 16 Jul 2006 12:09:23 +0200
Subject: [Pinot-svn] r355 - in trunk: Search UI/GTK2/src Utils
Message-ID: <200607161009.k6GA9Nhv028723@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-16 12:09:20 +0200 (Sun, 16 Jul 2006)
New Revision: 355

Modified:
   trunk/Search/XapianEngine.cpp
   trunk/Search/XapianEngine.h
   trunk/UI/GTK2/src/MboxHandler.cpp
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/Utils/XapianDatabase.cpp
   trunk/Utils/XapianDatabase.h
Log:
Moved buildUrl() to XapianDatabase.


Modified: trunk/Search/XapianEngine.cpp
===================================================================
--- trunk/Search/XapianEngine.cpp	2006-07-15 13:44:22 UTC (rev 354)
+++ trunk/Search/XapianEngine.cpp	2006-07-16 10:09:20 UTC (rev 355)
@@ -177,7 +177,7 @@
 					{
 						// Hmmm this shouldn't be empty...
 						// Use this instead, even though the document isn't cached in the index
-						url = buildUrl(m_databaseName, *mIter);
+						url = XapianDatabase::buildUrl(m_databaseName, *mIter);
 					}
 					else
 					{
@@ -424,20 +424,6 @@
 	}
 }
 
-/// Returns the URL for the given document in the given index.
-string XapianEngine::buildUrl(const string &database, unsigned int docId)
-{
-	// Make up a pseudo URL
-	char docIdStr[64];
-	sprintf(docIdStr, "%u", docId);
-	string url = "xapian://localhost/";
-	url += database;
-	url += "/";
-	url += docIdStr;
-
-	return url;
-}
-
 /// Runs a boolean query; true if success.
 bool XapianEngine::runQuery(const string &keyword)
 {

Modified: trunk/Search/XapianEngine.h
===================================================================
--- trunk/Search/XapianEngine.h	2006-07-15 13:44:22 UTC (rev 354)
+++ trunk/Search/XapianEngine.h	2006-07-16 10:09:20 UTC (rev 355)
@@ -45,9 +45,6 @@
 		/// Returns the results for the previous query.
 		virtual const std::vector<Result> &getResults(void) const;
 
-		/// Returns the URL for the given document in the given index.
-		static std::string buildUrl(const std::string &database, unsigned int docId);
-
 	protected:
 		std::string m_databaseName;
 		std::set<unsigned int> m_relevantDocuments;

Modified: trunk/UI/GTK2/src/MboxHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.cpp	2006-07-15 13:44:22 UTC (rev 354)
+++ trunk/UI/GTK2/src/MboxHandler.cpp	2006-07-16 10:09:20 UTC (rev 355)
@@ -26,10 +26,10 @@
 #include "StringManip.h"
 #include "Timer.h"
 #include "TimeConverter.h"
+#include "XapianDatabase.h"
 #include "TokenizerFactory.h"
 #include "FileCollector.h"
 #include "XapianIndex.h"
-#include "XapianEngine.h"
 #include "PinotUtils.h"
 #include "MboxHandler.h"
 
@@ -192,7 +192,7 @@
 				pIndex->setDocumentLabels(docId, labels);
 
 				IndexedDocument docInfo(pMessage->getTitle(),
-					XapianEngine::buildUrl(PinotSettings::getInstance().m_mailIndexLocation, docId),
+					XapianDatabase::buildUrl(PinotSettings::getInstance().m_mailIndexLocation, docId),
 					pMessage->getLocation(), pMessage->getType(), pMessage->getLanguage());
 				docInfo.setTimestamp(TimeConverter::toTimestamp(messageDate));
 

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-07-15 13:44:22 UTC (rev 354)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-07-16 10:09:20 UTC (rev 355)
@@ -35,6 +35,7 @@
 #include "StringManip.h"
 #include "TimeConverter.h"
 #include "Url.h"
+#include "XapianDatabase.h"
 #include "QueryHistory.h"
 #include "IndexedDocument.h"
 #include "MonitorFactory.h"
@@ -44,7 +45,6 @@
 #include "GoogleAPIEngine.h"
 #endif
 #include "XapianIndex.h"
-#include "XapianEngine.h"
 #include "config.h"
 #include "NLS.h"
 #include "PinotSettings.h"
@@ -610,7 +610,7 @@
 		// Get the document ID
 		unsigned int docId = (*iter);
 		// ...and the document URL
-		string url = XapianEngine::buildUrl(mapIter->second, docId);
+		string url = XapianDatabase::buildUrl(mapIter->second, docId);
 
 		DocumentInfo docInfo;
 		if (index.getDocumentInfo(docId, docInfo) == true)

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2006-07-15 13:44:22 UTC (rev 354)
+++ trunk/UI/GTK2/src/mainWindow.cc	2006-07-16 10:09:20 UTC (rev 355)
@@ -38,13 +38,13 @@
 #include "TimeConverter.h"
 #include "MIMEScanner.h"
 #include "Url.h"
+#include "XapianDatabase.h"
 #include "TokenizerFactory.h"
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "DownloaderFactory.h"
 #include "XapianIndex.h"
 #include "SearchEngineFactory.h"
-#include "XapianEngine.h"
 #include "config.h"
 #include "NLS.h"
 #include "MboxHandler.h"
@@ -1181,7 +1181,7 @@
 				{
 					// Add a row to the index tree
 					IndexedDocument indexedDoc(docInfo.getTitle(),
-						XapianEngine::buildUrl(m_settings.m_indexLocation, docId),
+						XapianDatabase::buildUrl(m_settings.m_indexLocation, docId),
 						docInfo.getLocation(), docInfo.getType(),
 						docInfo.getLanguage());
 					indexedDoc.setTimestamp(docInfo.getTimestamp());

Modified: trunk/Utils/XapianDatabase.cpp
===================================================================
--- trunk/Utils/XapianDatabase.cpp	2006-07-15 13:44:22 UTC (rev 354)
+++ trunk/Utils/XapianDatabase.cpp	2006-07-16 10:09:20 UTC (rev 355)
@@ -233,3 +233,17 @@
 #endif
 	pthread_rwlock_unlock(&m_rwLock);
 }
+
+/// Returns the URL for the given document in the given index.
+string XapianDatabase::buildUrl(const string &database, unsigned int docId)
+{
+	// Make up a pseudo URL
+	char docIdStr[64];
+	sprintf(docIdStr, "%u", docId);
+	string url = "xapian://localhost/";
+	url += database;
+	url += "/";
+	url += docIdStr;
+
+	return url;
+}

Modified: trunk/Utils/XapianDatabase.h
===================================================================
--- trunk/Utils/XapianDatabase.h	2006-07-15 13:44:22 UTC (rev 354)
+++ trunk/Utils/XapianDatabase.h	2006-07-16 10:09:20 UTC (rev 355)
@@ -44,6 +44,9 @@
 		/// Unlocks the database.
 		void unlock(void);
 
+		/// Returns the URL for the given document in the given index.
+		static std::string buildUrl(const std::string &database, unsigned int docId);
+
 	protected:
 		std::string m_databaseName;
 		bool m_readOnly;



From fabricecolin at mail.berlios.de  Sun Jul 16 12:11:28 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sun, 16 Jul 2006 12:11:28 +0200
Subject: [Pinot-svn] r356 - trunk/Utils/xdgmime
Message-ID: <200607161011.k6GABSBK028889@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-16 12:11:27 +0200 (Sun, 16 Jul 2006)
New Revision: 356

Modified:
   trunk/Utils/xdgmime/ChangeLog
   trunk/Utils/xdgmime/xdgmimemagic.c
Log:
Caught up with xdgmime.


Modified: trunk/Utils/xdgmime/ChangeLog
===================================================================
--- trunk/Utils/xdgmime/ChangeLog	2006-07-16 10:09:20 UTC (rev 355)
+++ trunk/Utils/xdgmime/ChangeLog	2006-07-16 10:11:27 UTC (rev 356)
@@ -1,3 +1,9 @@
+2006-07-13  Christian Neumair  <chris at gnome-de.org>
+
+	* src/xdgmimemagic.c: (_xdg_mime_magic_parse_magic_line):
+	Only declare 'i' #if LITTLE_ENDIAN. Partially fixes GNOME #340277.
+	Thanks to James Andrewartha.
+
 2006-03-02  Christian Neumair  <chris at gnome-de.org>
 
 	* src/xdgmimeglob.c: (_xdg_glob_hash_insert_text),

Modified: trunk/Utils/xdgmime/xdgmimemagic.c
===================================================================
--- trunk/Utils/xdgmime/xdgmimemagic.c	2006-07-16 10:09:20 UTC (rev 355)
+++ trunk/Utils/xdgmime/xdgmimemagic.c	2006-07-16 10:11:27 UTC (rev 356)
@@ -474,7 +474,9 @@
       /* We clean up the matchlet, byte swapping if needed */
       if (matchlet->word_size > 1)
 	{
+#if LITTLE_ENDIAN
 	  int i;
+#endif
 	  if (matchlet->value_length % matchlet->word_size != 0)
 	    {
 	      _xdg_mime_magic_matchlet_free (matchlet);



From fabricecolin at mail.berlios.de  Tue Jul 18 15:09:31 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Tue, 18 Jul 2006 15:09:31 +0200
Subject: [Pinot-svn] r357 - trunk/Index
Message-ID: <200607181309.k6ID9Vdf030079@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-18 15:08:51 +0200 (Tue, 18 Jul 2006)
New Revision: 357

Added:
   trunk/Index/WritableXapianIndex.cpp
   trunk/Index/WritableXapianIndex.h
Modified:
   trunk/Index/IndexInterface.h
   trunk/Index/Makefile.am
   trunk/Index/XapianIndex.cpp
   trunk/Index/XapianIndex.h
   trunk/Index/pinot-index.cpp
Log:
Moved everything that requires a writable index to WritableIndexInterface
and WritableXapianIndex.


Modified: trunk/Index/IndexInterface.h
===================================================================
--- trunk/Index/IndexInterface.h	2006-07-16 10:11:27 UTC (rev 356)
+++ trunk/Index/IndexInterface.h	2006-07-18 13:08:51 UTC (rev 357)
@@ -23,27 +23,18 @@
 #include "Tokenizer.h"
 #include "DocumentInfo.h"
 
-/// Interface implemented by indexes.
+/// Interface implemented by read-only indexes.
 class IndexInterface
 {
 	public:
 		virtual ~IndexInterface() {};
 
 		/// Returns false if the index couldn't be opened.
-		bool isGood(void) const { return m_goodIndex; }
+		virtual bool isGood(void) const = 0;
 
-		typedef enum { STORE_UNSTEM = 0, STORE_STEM, STORE_BOTH } StemmingMode;
-
-		/// Sets the stemming mode.
-		virtual void setStemmingMode(StemmingMode mode) { m_stemMode = mode; }
-
 		/// Gets the index location.
 		virtual std::string getLocation(void) const = 0;
 
-		/// Indexes the given data.
-		virtual bool indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
-			unsigned int &docId) = 0;
-
 		/// Returns a document's properties.
 		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const = 0;
 
@@ -53,6 +44,47 @@
 		/// Returns a document's labels.
 		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const = 0;
 
+		/// Checks whether the given URL is in the index.
+		virtual unsigned int hasDocument(const std::string &url) const = 0;
+
+		/// Gets terms with the same root.
+		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions) = 0;
+
+		/// Returns the number of documents.
+		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const = 0;
+
+		/// Lists document IDs.
+		virtual unsigned int listDocuments(std::set<unsigned int> &docIDList,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const = 0;
+
+		/// Lists documents that have a label.
+		virtual bool listDocumentsWithLabel(const std::string &name, std::set<unsigned int> &docIds,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const = 0;
+
+	protected:
+		IndexInterface() { };
+
+	private:
+		IndexInterface(const IndexInterface &other);
+		IndexInterface &operator=(const IndexInterface &other);
+
+};
+
+/// Interface implemented by read-write indexes.
+class WritableIndexInterface : public IndexInterface
+{
+	public:
+		virtual ~WritableIndexInterface() {};
+
+		typedef enum { STORE_UNSTEM = 0, STORE_STEM, STORE_BOTH } StemmingMode;
+
+		/// Sets the stemming mode.
+		virtual void setStemmingMode(StemmingMode mode) { m_stemMode = mode; }
+
+		/// Indexes the given data.
+		virtual bool indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
+			unsigned int &docId) = 0;
+
 		/// Updates the given document.
 		virtual bool updateDocument(unsigned int docId, Tokenizer &tokens) = 0;
 
@@ -63,18 +95,12 @@
 		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
 			bool resetLabels = true) = 0;
 
-		/// Checks whether the given URL is in the index.
-		virtual unsigned int hasDocument(const std::string &url) const = 0;
-
 		/// Unindexes the given document.
 		virtual bool unindexDocument(unsigned int docId) = 0;
 
 		/// Unindexes documents with the given label.
 		virtual bool unindexDocuments(const std::string &labelName) = 0;
 
-		/// Gets terms with the same root.
-		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions) = 0;
-
 		/// Renames a label.
 		virtual bool renameLabel(const std::string &name, const std::string &newName) = 0;
 
@@ -84,26 +110,14 @@
 		/// Flushes recent changes to the disk.
 		virtual bool flush(void) = 0;
 
-		/// Returns the number of documents.
-		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const = 0;
-
-		/// Lists document IDs.
-		virtual unsigned int listDocuments(std::set<unsigned int> &docIDList,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const = 0;
-
-		/// Lists documents that have a label.
-		virtual bool listDocumentsWithLabel(const std::string &name, std::set<unsigned int> &docIds,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const = 0;
-
 	protected:
 		StemmingMode m_stemMode;
-		bool m_goodIndex;
 
-		IndexInterface() { m_stemMode = STORE_UNSTEM; m_goodIndex = false; };
+		WritableIndexInterface() : IndexInterface(), m_stemMode(STORE_UNSTEM) { };
 
 	private:
-		IndexInterface(const IndexInterface &other);
-		IndexInterface &operator=(const IndexInterface &other);
+		WritableIndexInterface(const WritableIndexInterface &other);
+		WritableIndexInterface &operator=(const WritableIndexInterface &other);
 
 };
 

Modified: trunk/Index/Makefile.am
===================================================================
--- trunk/Index/Makefile.am	2006-07-16 10:11:27 UTC (rev 356)
+++ trunk/Index/Makefile.am	2006-07-18 13:08:51 UTC (rev 357)
@@ -3,13 +3,25 @@
 noinst_HEADERS = \
 	IndexInterface.h \
 	LanguageDetector.h \
+	WritableXapianIndex.h \
 	XapianIndex.h
 
 noinst_LTLIBRARIES = libIndex.la
 
+bin_PROGRAMS = pinot-index
+
 libIndex_la_SOURCES = \
 	LanguageDetector.cpp \
+	WritableXapianIndex.cpp \
 	XapianIndex.cpp
 
-AM_CXXFLAGS = -I../Utils -I../Tokenize @INDEX_CFLAGS@ 
+pinot_index_SOURCES = \
+	pinot-index.cpp
 
+pinot_index_LDADD = -L../Utils -L../Tokenize -L../Collect -L../Index \
+	-lIndex -lCollect -lTokenize -lUtils \
+	@GLIBMM_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
+
+AM_CXXFLAGS = -I../Utils -I../Tokenize -I../Collect -I../Index \
+	@HTTP_CFLAGS@ @MIME_CFLAGS@ @XML_CFLAGS@ @DBUS_CFLAGS@ @INDEX_CFLAGS@
+

Added: trunk/Index/WritableXapianIndex.cpp
===================================================================
--- trunk/Index/WritableXapianIndex.cpp	2006-07-16 10:11:27 UTC (rev 356)
+++ trunk/Index/WritableXapianIndex.cpp	2006-07-18 13:08:51 UTC (rev 357)
@@ -0,0 +1,894 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <strings.h>
+#include <time.h>
+#include <ctype.h>
+#include <regex.h>
+#include <iostream>
+#include <fstream>
+#include <algorithm>
+#include <utility>
+
+#include "Languages.h"
+#include "StringManip.h"
+#include "TimeConverter.h"
+#include "Url.h"
+#include "LanguageDetector.h"
+#include "XapianDatabaseFactory.h"
+#include "WritableXapianIndex.h"
+
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+using std::set;
+using std::min;
+
+WritableXapianIndex::WritableXapianIndex(const string &indexName) :
+	WritableIndexInterface(),
+	XapianIndex(indexName)
+{
+	// Open in read/write mode
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if ((pDatabase != NULL) &&
+		(pDatabase->isOpen() == true))
+	{
+		m_goodIndex = true;
+	}
+}
+
+WritableXapianIndex::~WritableXapianIndex()
+{
+}
+
+bool WritableXapianIndex::badField(const string &field)
+{
+	regex_t fieldRegex;
+	regmatch_t pFieldMatches[1];
+	bool isBadField = false;
+
+	// A bad field is one that includes one of our field delimiters
+	if (regcomp(&fieldRegex,
+		"(url|sample|caption|type|timestamp|language)=",
+		REG_EXTENDED|REG_ICASE) == 0)
+	{
+		if (regexec(&fieldRegex, field.c_str(), 1,
+			pFieldMatches, REG_NOTBOL|REG_NOTEOL) == 0)
+		{
+			isBadField = true;
+		}
+	}
+	regfree(&fieldRegex);
+
+	return isBadField;
+}
+
+void WritableXapianIndex::addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,
+	const string &prefix, Xapian::termcount &termPos, StemmingMode mode) const
+{
+	Xapian::Stem *pStemmer = NULL;
+	string term;
+
+	// Do we know what language to use for stemming ?
+	if (m_stemLanguage.empty() == false)
+	{
+		pStemmer = new Xapian::Stem(StringManip::toLowerCase(m_stemLanguage));
+	}
+
+	// Get the terms
+	while (tokens.nextToken(term) == true)
+	{
+		if (term.empty() == true)
+		{
+			continue;
+		}
+		// Does it start with a capital letter ?
+		if (isupper((int)term[0]) != 0)
+		{
+			// R-prefix the raw term
+			doc.add_posting(string("R") + term, termPos);
+		}
+		// Lower case the term
+		term = StringManip::toLowerCase(term);
+
+		// Stem the term ?
+		if ((mode == STORE_UNSTEM) ||
+			(pStemmer == NULL))
+		{
+			doc.add_posting(limitTermLength(prefix + term), termPos++);
+		}
+		else if (mode == STORE_STEM)
+		{
+			string stemmedTerm = pStemmer->stem_word(term);
+
+			doc.add_posting(limitTermLength(prefix + stemmedTerm), termPos++);
+		}
+		else if (mode == STORE_BOTH)
+		{
+			string stemmedTerm = pStemmer->stem_word(term);
+
+			// Add both
+			doc.add_posting(limitTermLength(prefix + term), termPos);
+			// ...at the same position
+			doc.add_posting(limitTermLength(prefix + stemmedTerm), termPos++);
+		}
+	}
+#ifdef DEBUG
+	cout << "WritableXapianIndex::addTermsToDocument: added " << termPos << " terms" << endl;
+#endif
+
+	if (pStemmer != NULL)
+	{
+		delete pStemmer;
+	}
+}
+
+bool WritableXapianIndex::prepareDocument(const DocumentInfo &info, Xapian::Document &doc,
+	Xapian::termcount &termPos) const
+{
+	string title(info.getTitle());
+	string location(info.getLocation());
+	Url urlObj(location);
+
+	// Add a magic term :-)
+	doc.add_term(MAGIC_TERM);
+
+	// Index the title with and without prefix S
+	if (title.empty() == false)
+	{
+		Document titleDoc;
+		titleDoc.setData(title.c_str(), title.length());
+		Tokenizer titleTokens(&titleDoc);
+		addTermsToDocument(titleTokens, doc, "S", termPos, STORE_UNSTEM);
+		titleTokens.rewind();
+		addTermsToDocument(titleTokens, doc, "", termPos, m_stemMode);
+	}
+
+	// Index the full URL with prefix U
+	doc.add_term(limitTermLength(string("U") + location, true));
+	// ...the host name and included domains with prefix H
+	string hostName(StringManip::toLowerCase(urlObj.getHost()));
+	if (hostName.empty() == false)
+	{
+		doc.add_term(limitTermLength(string("H") + hostName, true));
+		string::size_type dotPos = hostName.find('.');
+		while (dotPos != string::npos)
+		{
+			doc.add_term(limitTermLength(string("H") + hostName.substr(dotPos + 1), true));
+
+			// Next
+			dotPos = hostName.find('.', dotPos + 1);
+		}
+	}
+	// ...and the file name with prefix P
+	string fileName(urlObj.getFile());
+	if (fileName.empty() == false)
+	{
+		doc.add_term(limitTermLength(string("P") + StringManip::toLowerCase(fileName), true));
+	}
+	// Finally, add the language code with prefix L
+	doc.add_term(string("L") + Languages::toCode(m_stemLanguage));
+
+	setDocumentData(doc, info, m_stemLanguage);
+
+	return true;
+}
+
+string WritableXapianIndex::scanDocument(const char *pData, unsigned int dataLength,
+	DocumentInfo &info)
+{
+	vector<string> candidates;
+	string language;
+
+	// Try to determine the document's language
+	LanguageDetector lang;
+	lang.guessLanguage(pData, max(dataLength, (unsigned int)2048), candidates);
+
+	// See which of these languages is suitable for stemming
+	for (vector<string>::iterator langIter = candidates.begin(); langIter != candidates.end(); ++langIter)
+	{
+		if (*langIter == "unknown")
+		{
+			continue;
+		}
+
+		try
+		{
+			Xapian::Stem stemmer(*langIter);
+		}
+		catch (const Xapian::Error &error)
+		{
+			cerr << "WritableXapianIndex::scanDocument: " << error.get_type() << ": " << error.get_msg() << endl;
+			continue;
+		}
+
+		language = *langIter;
+		break;
+	}
+#ifdef DEBUG
+	cout << "WritableXapianIndex::scanDocument: language " << language << endl;
+#endif
+
+	// Update the document's properties
+	info.setLanguage(language);
+
+	return language;
+}
+
+void WritableXapianIndex::setDocumentData(Xapian::Document &doc, const DocumentInfo &info,
+	const string &language) const
+{
+	string title(info.getTitle());
+	string timestamp(info.getTimestamp());
+	char timeStr[64];
+
+	// Set the document data omindex-style
+	string record = "url=";
+	record += info.getLocation();
+	// The sample will be generated at query time
+	record += "\nsample=";
+	record += "\ncaption=";
+	if (badField(title) == true)
+	{
+		// Modify the title if necessary
+		string::size_type pos = title.find("=");
+		while (pos != string::npos)
+		{
+			title[pos] = ' ';
+			pos = title.find("=", pos + 1);
+		}
+#ifdef DEBUG
+		cout << "WritableXapianIndex::setDocumentData: modified title" << endl;
+#endif
+	}
+	record += title;
+	record += "\ntype=";
+	record += info.getType();
+	// Append a timestamp
+	record += "\ntimestamp=";
+	record += timestamp;
+	// ...and the language
+	record += "\nlanguage=";
+	record += language;
+#ifdef DEBUG
+	cout << "WritableXapianIndex::setDocumentData: document data is " << record << endl;
+#endif
+	doc.set_data(record);
+
+	// Add this value to allow sorting by date
+	snprintf(timeStr, 64, "%d", TimeConverter::fromTimestamp(timestamp));
+	doc.add_value(0, timeStr);
+}
+
+bool WritableXapianIndex::listDocumentsWithTerm(const string &term, set<unsigned int> &docIds,
+	unsigned int maxDocsCount, unsigned int startDoc) const
+{
+	unsigned int docCount = 0;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return 0;
+	}
+
+	docIds.clear();
+	try
+	{
+		Xapian::Database *pIndex = pDatabase->readLock();
+		if (pIndex != NULL)
+		{
+#ifdef DEBUG
+			cout << "WritableXapianIndex::listDocumentsWithTerm: term " << term << endl;
+#endif
+			// Get a list of documents that have the term
+			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
+				(postingIter != pIndex->postlist_end(term)) &&
+					((maxDocsCount == 0) || (docIds.size() < maxDocsCount));
+				++postingIter)
+			{
+				Xapian::docid docId = *postingIter;
+
+				// We cannot use postingIter->skip_to() because startDoc isn't an ID
+				if (docCount >= startDoc)
+				{
+					docIds.insert(docId);
+				}
+				++docCount;
+			}
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't get document list: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't get document list, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return docIds.size();
+}
+
+//
+// Implementation of IndexInterface
+//
+
+/// Returns false if the index couldn't be opened.
+bool WritableXapianIndex::isGood(void) const
+{
+	return m_goodIndex;
+}
+
+/// Gets the index location.
+string WritableXapianIndex::getLocation(void) const
+{
+	return m_databaseName;
+}
+
+/// Returns a document's properties.
+bool WritableXapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
+{
+	return XapianIndex::getDocumentInfo(docId, docInfo);
+}
+
+/// Determines whether a document has a label.
+bool WritableXapianIndex::hasLabel(unsigned int docId, const string &name) const
+{
+	return XapianIndex::hasLabel(docId, name);
+}
+
+/// Returns a document's labels.
+bool WritableXapianIndex::getDocumentLabels(unsigned int docId, set<string> &labels) const
+{
+	return XapianIndex::getDocumentLabels(docId, labels);
+}
+
+/// Checks whether the given URL is in the index.
+unsigned int WritableXapianIndex::hasDocument(const string &url) const
+{
+	return XapianIndex::hasDocument(url);
+}
+
+/// Gets terms with the same root.
+unsigned int WritableXapianIndex::getCloseTerms(const string &term, set<string> &suggestions)
+{
+	return XapianIndex::getCloseTerms(term, suggestions);
+}
+
+/// Returns the number of documents.
+unsigned int WritableXapianIndex::getDocumentsCount(const string &labelName) const
+{
+	return XapianIndex::getDocumentsCount(labelName);
+}
+
+/// Lists document IDs.
+unsigned int WritableXapianIndex::listDocuments(set<unsigned int> &docIds,
+	unsigned int maxDocsCount, unsigned int startDoc) const
+{
+	return XapianIndex::listDocuments(docIds, maxDocsCount, startDoc);
+}
+
+/// Lists documents that have a label.
+bool WritableXapianIndex::listDocumentsWithLabel(const string &name, set<unsigned int> &docIds,
+	unsigned int maxDocsCount, unsigned int startDoc) const
+{
+	return XapianIndex::listDocumentsWithLabel(name, docIds, maxDocsCount, startDoc);
+}
+//
+// Implementation of WritableIndexInterface
+//
+
+/// Indexes the given data.
+bool WritableXapianIndex::indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
+	unsigned int &docId)
+{
+	unsigned int dataLength = 0;
+	bool indexed = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		// Get the document
+		const Document *pDocument = tokens.getDocument();
+		if (pDocument == NULL)
+		{
+#ifdef DEBUG
+			cout << "WritableXapianIndex::indexDocument: no document" << endl;
+#endif
+			return false;
+		}
+
+		const char *pData = pDocument->getData(dataLength);
+		if (pData == NULL)
+		{
+#ifdef DEBUG
+			cout << "WritableXapianIndex::indexDocument: empty document" << endl;
+#endif
+			return false;
+		}
+		// Cache the document's properties
+		DocumentInfo docInfo(pDocument->getTitle(), pDocument->getLocation(),
+			pDocument->getType(), pDocument->getLanguage());
+		docInfo.setTimestamp(pDocument->getTimestamp());
+		docInfo.setLocation(Url::canonicalizeUrl(docInfo.getLocation()));
+
+		m_stemLanguage = scanDocument(pData, dataLength, docInfo);
+
+		Xapian::Document doc;
+		Xapian::termcount termPos = 0;
+
+#ifdef DEBUG
+		cout << "WritableXapianIndex::indexDocument: adding terms" << endl;
+#endif
+		// Add the tokenizer's terms to the Xapian document
+		addTermsToDocument(tokens, doc, "", termPos, m_stemMode);
+		// Add labels
+		for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
+			++labelIter)
+		{
+			doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
+		}
+		if (prepareDocument(docInfo, doc, termPos) == true)
+		{
+			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+			if (pIndex != NULL)
+			{
+				// Add this document to the Xapian index
+				docId = pIndex->add_document(doc);
+				indexed = true;
+			}
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't index document: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't index document, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return indexed;
+}
+
+/// Updates the given document; true if success.
+bool WritableXapianIndex::updateDocument(unsigned int docId, Tokenizer &tokens)
+{
+	unsigned int dataLength = 0;
+	bool updated = false;
+
+	const Document *pDocument = tokens.getDocument();
+	if (pDocument == NULL)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	const char *pData = pDocument->getData(dataLength);
+	if (pData == NULL)
+	{
+		return false;
+	}
+
+	// Cache the document's properties
+	DocumentInfo docInfo(pDocument->getTitle(), pDocument->getLocation(),
+		pDocument->getType(), pDocument->getLanguage());
+	docInfo.setTimestamp(pDocument->getTimestamp());
+	docInfo.setLocation(Url::canonicalizeUrl(docInfo.getLocation()));
+
+	// Don't scan the document if a language is specified
+	m_stemLanguage = Languages::toEnglish(pDocument->getLanguage());
+	if (m_stemLanguage.empty() == true)
+	{
+		m_stemLanguage = scanDocument(pData, dataLength, docInfo);
+	}
+
+	try
+	{
+		set<string> labels;
+		Xapian::Document doc;
+		Xapian::termcount termPos = 0;
+
+		// Add the tokenizer's terms to the document
+		addTermsToDocument(tokens, doc, "", termPos, m_stemMode);
+		// Get the document's labels
+		if (getDocumentLabels(docId, labels) == true)
+		{
+			// Add labels
+			for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
+				++labelIter)
+			{
+				doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
+			}
+		}
+		if (prepareDocument(docInfo, doc, termPos) == true)
+		{
+			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+			if (pIndex != NULL)
+			{
+				// Update the document in the database
+				pIndex->replace_document(docId, doc);
+				updated = true;
+			}
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't update document: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't update document, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return updated;
+}
+
+/// Updates a document's properties.
+bool WritableXapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo)
+{
+	bool updated = false;
+
+	if (docId == 0)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			Xapian::Document doc = pIndex->get_document(docId);
+
+#ifdef DEBUG
+			cout << "WritableXapianIndex::updateDocumentInfo: language is " << docInfo.getLanguage() << endl;
+#endif
+			// Update the document data with the current language
+			setDocumentData(doc, docInfo, docInfo.getLanguage());
+			pIndex->replace_document(docId, doc);
+			updated = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't update document properties: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't update document properties, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return updated;
+}
+
+/// Sets a document's labels.
+bool WritableXapianIndex::setDocumentLabels(unsigned int docId, const set<string> &labels,
+	bool resetLabels)
+{
+	bool updatedLabels = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			Xapian::Document doc = pIndex->get_document(docId);
+
+			// Reset existing labels ?
+			if (resetLabels == true)
+			{
+				Xapian::TermIterator termIter = pIndex->termlist_begin(docId);
+				if (termIter != pIndex->termlist_end(docId))
+				{
+					for (termIter.skip_to("XLABEL:");
+						termIter != pIndex->termlist_end(docId); ++termIter)
+					{
+						// Is this a label ?
+						if (strncasecmp((*termIter).c_str(), "XLABEL:", min(7, (int)(*termIter).length())) == 0)
+						{
+							doc.remove_term(*termIter);
+						}
+					}
+				}
+			}
+
+			// Set new labels
+			for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
+				++labelIter)
+			{
+				if (labelIter->empty() == false)
+				{
+					doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
+				}
+			}
+
+			pIndex->replace_document(docId, doc);
+			updatedLabels = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't update document's labels: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't update document's labels, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return updatedLabels;
+}
+
+/// Unindexes the given document; true if success.
+bool WritableXapianIndex::unindexDocument(unsigned int docId)
+{
+	bool unindexed = false;
+
+	if (docId == 0)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			// Delete the document from the index
+			pIndex->delete_document(docId);
+			unindexed = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't unindex document: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't unindex document, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return unindexed;
+}
+
+/// Unindexes documents with the given label.
+bool WritableXapianIndex::unindexDocuments(const string &labelName)
+{
+	bool unindexed = false;
+
+	if (labelName.empty() == true)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			string term("XLABEL:");
+
+			// Delete documents from the index
+			term += labelName;
+			pIndex->delete_document(term);
+			unindexed = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't unindex documents: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't unindex documents, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return unindexed;
+}
+
+/// Renames a label.
+bool WritableXapianIndex::renameLabel(const string &name, const string &newName)
+{
+	bool renamedLabel = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			string term("XLABEL:");
+
+			// Get documents that have this label
+			term += name;
+			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
+				postingIter != pIndex->postlist_end(term); ++postingIter)
+			{
+				Xapian::docid docId = *postingIter;
+
+				// Get the document
+				Xapian::Document doc = pIndex->get_document(docId);
+				// Remove the term
+				doc.remove_term(term);
+				// ...add the new one
+				doc.add_term(limitTermLength(string("XLABEL:") + newName));
+				// ...and update the document
+				pIndex->replace_document(docId, doc);
+			}
+
+			renamedLabel = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't delete label: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't delete label, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return renamedLabel;
+}
+
+/// Deletes all references to a label.
+bool WritableXapianIndex::deleteLabel(const string &name)
+{
+	bool deletedLabel = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			string term("XLABEL:");
+
+			// Get documents that have this label
+			term += name;
+			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
+				postingIter != pIndex->postlist_end(term); ++postingIter)
+			{
+				Xapian::docid docId = *postingIter;
+
+				// Get the document
+				Xapian::Document doc = pIndex->get_document(docId);
+				// Remove the term
+				doc.remove_term(term);
+				// ...and update the document
+				pIndex->replace_document(docId, doc);
+			}
+			deletedLabel = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't delete label: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't delete label, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return deletedLabel;
+}
+
+/// Flushes recent changes to the disk.
+bool WritableXapianIndex::flush(void)
+{
+	bool flushed = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+#ifdef DEBUG
+		cout << "WritableXapianIndex::flush: called" << endl;
+#endif
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			pIndex->flush();
+			flushed = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't flush database: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't flush database, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return flushed;
+}
+


Property changes on: trunk/Index/WritableXapianIndex.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Index/WritableXapianIndex.h
===================================================================
--- trunk/Index/WritableXapianIndex.h	2006-07-16 10:11:27 UTC (rev 356)
+++ trunk/Index/WritableXapianIndex.h	2006-07-18 13:08:51 UTC (rev 357)
@@ -0,0 +1,121 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _WRITABLE_XAPIAN_INDEX_H
+#define _WRITABLE_XAPIAN_INDEX_H
+
+#include <string>
+#include <set>
+
+#include <xapian.h>
+
+#include "DocumentInfo.h"
+#include "XapianIndex.h"
+
+class WritableXapianIndex : public WritableIndexInterface, private XapianIndex
+{
+	public:
+		WritableXapianIndex(const std::string &indexName);
+		virtual ~WritableXapianIndex();
+
+		/// Returns false if the index couldn't be opened.
+		virtual bool isGood(void) const;
+
+		/// Gets the index location.
+		virtual std::string getLocation(void) const;
+
+		/// Returns a document's properties.
+		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const;
+
+		/// Determines whether a document has a label.
+		virtual bool hasLabel(unsigned int docId, const std::string &name) const;
+
+		/// Returns a document's labels.
+		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const;
+
+		/// Checks whether the given URL is in the index.
+		virtual unsigned int hasDocument(const std::string &url) const;
+
+		/// Gets terms with the same root.
+		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions);
+
+		/// Returns the number of documents.
+		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const;
+
+		/// Lists document IDs.
+		virtual unsigned int listDocuments(std::set<unsigned int> &docIds,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
+
+		/// Lists documents that have a label.
+		virtual bool listDocumentsWithLabel(const std::string &name, std::set<unsigned int> &docIds,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
+
+		/// Indexes the given data.
+		virtual bool indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
+			unsigned int &docId);
+
+		/// Updates the given document.
+		virtual bool updateDocument(unsigned int docId, Tokenizer &tokens);
+
+		/// Updates a document's properties.
+		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo);
+
+		/// Sets a document's labels.
+		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
+			bool resetLabels = true);
+
+		/// Unindexes the given document.
+		virtual bool unindexDocument(unsigned int docId);
+
+		/// Unindexes documents with the given label.
+		virtual bool unindexDocuments(const std::string &labelName);
+
+		/// Renames a label.
+		virtual bool renameLabel(const std::string &name, const std::string &newName);
+
+		/// Deletes all references to a label.
+		virtual bool deleteLabel(const std::string &name);
+
+		/// Flushes recent changes to the disk.
+		virtual bool flush(void);
+
+	protected:
+		std::string m_stemLanguage;
+
+		static bool badField(const std::string &field);
+
+		void addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,
+			const std::string &prefix, Xapian::termcount &termPos, StemmingMode mode) const;
+
+		bool prepareDocument(const DocumentInfo &info, Xapian::Document &doc,
+			Xapian::termcount &termPos) const;
+
+		std::string scanDocument(const char *pData, unsigned int dataLength,
+			DocumentInfo &info);
+
+		void setDocumentData(Xapian::Document &doc, const DocumentInfo &info,
+			const std::string &language) const;
+
+		bool listDocumentsWithTerm(const std::string &term, std::set<unsigned int> &docIds,
+			unsigned int maxDocsCount, unsigned int startDoc) const;
+
+	private:
+		WritableXapianIndex(const WritableXapianIndex &other);
+		WritableXapianIndex &operator=(const WritableXapianIndex &other);
+
+};
+
+#endif // _WRITABLE_XAPIAN_INDEX_H


Property changes on: trunk/Index/WritableXapianIndex.h
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2006-07-16 10:11:27 UTC (rev 356)
+++ trunk/Index/XapianIndex.cpp	2006-07-18 13:08:51 UTC (rev 357)
@@ -50,9 +50,11 @@
 
 XapianIndex::XapianIndex(const string &indexName) :
 	IndexInterface(),
-	m_databaseName(indexName)
+	m_databaseName(indexName),
+	m_goodIndex(false)
 {
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	// Open in read-only mode
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
 	if ((pDatabase != NULL) &&
 		(pDatabase->isOpen() == true))
 	{
@@ -82,231 +84,12 @@
 	return term;
 }
 
-bool XapianIndex::badField(const string &field)
-{
-	regex_t fieldRegex;
-	regmatch_t pFieldMatches[1];
-	bool isBadField = false;
-
-	// A bad field is one that includes one of our field delimiters
-	if (regcomp(&fieldRegex,
-		"(url|sample|caption|type|timestamp|language)=",
-		REG_EXTENDED|REG_ICASE) == 0)
-	{
-		if (regexec(&fieldRegex, field.c_str(), 1,
-			pFieldMatches, REG_NOTBOL|REG_NOTEOL) == 0)
-		{
-			isBadField = true;
-		}
-	}
-	regfree(&fieldRegex);
-
-	return isBadField;
-}
-
-void XapianIndex::addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,
-	const string &prefix, Xapian::termcount &termPos, StemmingMode mode) const
-{
-	Xapian::Stem *pStemmer = NULL;
-	string term;
-
-	// Do we know what language to use for stemming ?
-	if (m_stemLanguage.empty() == false)
-	{
-		pStemmer = new Xapian::Stem(StringManip::toLowerCase(m_stemLanguage));
-	}
-
-	// Get the terms
-	while (tokens.nextToken(term) == true)
-	{
-		if (term.empty() == true)
-		{
-			continue;
-		}
-		// Does it start with a capital letter ?
-		if (isupper((int)term[0]) != 0)
-		{
-			// R-prefix the raw term
-			doc.add_posting(string("R") + term, termPos);
-		}
-		// Lower case the term
-		term = StringManip::toLowerCase(term);
-
-		// Stem the term ?
-		if ((mode == STORE_UNSTEM) ||
-			(pStemmer == NULL))
-		{
-			doc.add_posting(limitTermLength(prefix + term), termPos++);
-		}
-		else if (mode == STORE_STEM)
-		{
-			string stemmedTerm = pStemmer->stem_word(term);
-
-			doc.add_posting(limitTermLength(prefix + stemmedTerm), termPos++);
-		}
-		else if (mode == STORE_BOTH)
-		{
-			string stemmedTerm = pStemmer->stem_word(term);
-
-			// Add both
-			doc.add_posting(limitTermLength(prefix + term), termPos);
-			// ...at the same position
-			doc.add_posting(limitTermLength(prefix + stemmedTerm), termPos++);
-		}
-	}
-#ifdef DEBUG
-	cout << "XapianIndex::addTermsToDocument: added " << termPos << " terms" << endl;
-#endif
-
-	if (pStemmer != NULL)
-	{
-		delete pStemmer;
-	}
-}
-
-bool XapianIndex::prepareDocument(const DocumentInfo &info, Xapian::Document &doc,
-	Xapian::termcount &termPos) const
-{
-	string title(info.getTitle());
-	string location(info.getLocation());
-	Url urlObj(location);
-
-	// Add a magic term :-)
-	doc.add_term(MAGIC_TERM);
-
-	// Index the title with and without prefix S
-	if (title.empty() == false)
-	{
-		Document titleDoc;
-		titleDoc.setData(title.c_str(), title.length());
-		Tokenizer titleTokens(&titleDoc);
-		addTermsToDocument(titleTokens, doc, "S", termPos, STORE_UNSTEM);
-		titleTokens.rewind();
-		addTermsToDocument(titleTokens, doc, "", termPos, m_stemMode);
-	}
-
-	// Index the full URL with prefix U
-	doc.add_term(limitTermLength(string("U") + location, true));
-	// ...the host name and included domains with prefix H
-	string hostName(StringManip::toLowerCase(urlObj.getHost()));
-	if (hostName.empty() == false)
-	{
-		doc.add_term(limitTermLength(string("H") + hostName, true));
-		string::size_type dotPos = hostName.find('.');
-		while (dotPos != string::npos)
-		{
-			doc.add_term(limitTermLength(string("H") + hostName.substr(dotPos + 1), true));
-
-			// Next
-			dotPos = hostName.find('.', dotPos + 1);
-		}
-	}
-	// ...and the file name with prefix P
-	string fileName(urlObj.getFile());
-	if (fileName.empty() == false)
-	{
-		doc.add_term(limitTermLength(string("P") + StringManip::toLowerCase(fileName), true));
-	}
-	// Finally, add the language code with prefix L
-	doc.add_term(string("L") + Languages::toCode(m_stemLanguage));
-
-	setDocumentData(doc, info, m_stemLanguage);
-
-	return true;
-}
-
-string XapianIndex::scanDocument(const char *pData, unsigned int dataLength,
-	DocumentInfo &info)
-{
-	vector<string> candidates;
-	string language;
-
-	// Try to determine the document's language
-	LanguageDetector lang;
-	lang.guessLanguage(pData, max(dataLength, (unsigned int)2048), candidates);
-
-	// See which of these languages is suitable for stemming
-	for (vector<string>::iterator langIter = candidates.begin(); langIter != candidates.end(); ++langIter)
-	{
-		if (*langIter == "unknown")
-		{
-			continue;
-		}
-
-		try
-		{
-			Xapian::Stem stemmer(*langIter);
-		}
-		catch (const Xapian::Error &error)
-		{
-			cerr << "XapianIndex::scanDocument: " << error.get_type() << ": " << error.get_msg() << endl;
-			continue;
-		}
-
-		language = *langIter;
-		break;
-	}
-#ifdef DEBUG
-	cout << "XapianIndex::scanDocument: language " << language << endl;
-#endif
-
-	// Update the document's properties
-	info.setLanguage(language);
-
-	return language;
-}
-
-void XapianIndex::setDocumentData(Xapian::Document &doc, const DocumentInfo &info,
-	const string &language) const
-{
-	string title(info.getTitle());
-	string timestamp(info.getTimestamp());
-	char timeStr[64];
-
-	// Set the document data omindex-style
-	string record = "url=";
-	record += info.getLocation();
-	// The sample will be generated at query time
-	record += "\nsample=";
-	record += "\ncaption=";
-	if (badField(title) == true)
-	{
-		// Modify the title if necessary
-		string::size_type pos = title.find("=");
-		while (pos != string::npos)
-		{
-			title[pos] = ' ';
-			pos = title.find("=", pos + 1);
-		}
-#ifdef DEBUG
-		cout << "XapianIndex::setDocumentData: modified title" << endl;
-#endif
-	}
-	record += title;
-	record += "\ntype=";
-	record += info.getType();
-	// Append a timestamp
-	record += "\ntimestamp=";
-	record += timestamp;
-	// ...and the language
-	record += "\nlanguage=";
-	record += language;
-#ifdef DEBUG
-	cout << "XapianIndex::setDocumentData: document data is " << record << endl;
-#endif
-	doc.set_data(record);
-
-	// Add this value to allow sorting by date
-	snprintf(timeStr, 64, "%d", TimeConverter::fromTimestamp(timestamp));
-	doc.add_value(0, timeStr);
-}
-
 bool XapianIndex::listDocumentsWithTerm(const string &term, set<unsigned int> &docIds,
 	unsigned int maxDocsCount, unsigned int startDoc) const
 {
 	unsigned int docCount = 0;
 
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
 	if (pDatabase == NULL)
 	{
 		cerr << "Bad index " << m_databaseName << endl;
@@ -356,92 +139,18 @@
 // Implementation of IndexInterface
 //
 
+/// Returns false if the index couldn't be opened.
+bool XapianIndex::isGood(void) const
+{
+	return m_goodIndex;
+}
+
 /// Gets the index location.
 string XapianIndex::getLocation(void) const
 {
 	return m_databaseName;
 }
 
-/// Indexes the given data.
-bool XapianIndex::indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
-	unsigned int &docId)
-{
-	unsigned int dataLength = 0;
-	bool indexed = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		// Get the document
-		const Document *pDocument = tokens.getDocument();
-		if (pDocument == NULL)
-		{
-#ifdef DEBUG
-			cout << "XapianIndex::indexDocument: no document" << endl;
-#endif
-			return false;
-		}
-
-		const char *pData = pDocument->getData(dataLength);
-		if (pData == NULL)
-		{
-#ifdef DEBUG
-			cout << "XapianIndex::indexDocument: empty document" << endl;
-#endif
-			return false;
-		}
-		// Cache the document's properties
-		DocumentInfo docInfo(pDocument->getTitle(), pDocument->getLocation(),
-			pDocument->getType(), pDocument->getLanguage());
-		docInfo.setTimestamp(pDocument->getTimestamp());
-		docInfo.setLocation(Url::canonicalizeUrl(docInfo.getLocation()));
-
-		m_stemLanguage = scanDocument(pData, dataLength, docInfo);
-
-		Xapian::Document doc;
-		Xapian::termcount termPos = 0;
-
-#ifdef DEBUG
-		cout << "XapianIndex::indexDocument: adding terms" << endl;
-#endif
-		// Add the tokenizer's terms to the Xapian document
-		addTermsToDocument(tokens, doc, "", termPos, m_stemMode);
-		// Add labels
-		for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
-			++labelIter)
-		{
-			doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
-		}
-		if (prepareDocument(docInfo, doc, termPos) == true)
-		{
-			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-			if (pIndex != NULL)
-			{
-				// Add this document to the Xapian index
-				docId = pIndex->add_document(doc);
-				indexed = true;
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't index document: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't index document, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return indexed;
-}
-
 /// Returns a document's properties.
 bool XapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
 {
@@ -452,7 +161,7 @@
 		return false;
 	}
 
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
 	if (pDatabase == NULL)
 	{
 		cerr << "Bad index " << m_databaseName << endl;
@@ -503,7 +212,7 @@
 {
 	bool foundLabel = false;
 
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
 	if (pDatabase == NULL)
 	{
 		cerr << "Bad index " << m_databaseName << endl;
@@ -551,7 +260,7 @@
 {
 	bool gotLabels = false;
 
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
 	if (pDatabase == NULL)
 	{
 		cerr << "Bad index " << m_databaseName << endl;
@@ -598,203 +307,12 @@
 	return gotLabels;
 }
 
-/// Updates the given document; true if success.
-bool XapianIndex::updateDocument(unsigned int docId, Tokenizer &tokens)
-{
-	unsigned int dataLength = 0;
-	bool updated = false;
-
-	const Document *pDocument = tokens.getDocument();
-	if (pDocument == NULL)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	const char *pData = pDocument->getData(dataLength);
-	if (pData == NULL)
-	{
-		return false;
-	}
-
-	// Cache the document's properties
-	DocumentInfo docInfo(pDocument->getTitle(), pDocument->getLocation(),
-		pDocument->getType(), pDocument->getLanguage());
-	docInfo.setTimestamp(pDocument->getTimestamp());
-	docInfo.setLocation(Url::canonicalizeUrl(docInfo.getLocation()));
-
-	// Don't scan the document if a language is specified
-	m_stemLanguage = Languages::toEnglish(pDocument->getLanguage());
-	if (m_stemLanguage.empty() == true)
-	{
-		m_stemLanguage = scanDocument(pData, dataLength, docInfo);
-	}
-
-	try
-	{
-		set<string> labels;
-		Xapian::Document doc;
-		Xapian::termcount termPos = 0;
-
-		// Add the tokenizer's terms to the document
-		addTermsToDocument(tokens, doc, "", termPos, m_stemMode);
-		// Get the document's labels
-		if (getDocumentLabels(docId, labels) == true)
-		{
-			// Add labels
-			for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
-				++labelIter)
-			{
-				doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
-			}
-		}
-		if (prepareDocument(docInfo, doc, termPos) == true)
-		{
-			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-			if (pIndex != NULL)
-			{
-				// Update the document in the database
-				pIndex->replace_document(docId, doc);
-				updated = true;
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't update document: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't update document, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return updated;
-}
-
-/// Updates a document's properties.
-bool XapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo)
-{
-	bool updated = false;
-
-	if (docId == 0)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc = pIndex->get_document(docId);
-
-#ifdef DEBUG
-			cout << "XapianIndex::updateDocumentInfo: language is " << docInfo.getLanguage() << endl;
-#endif
-			// Update the document data with the current language
-			setDocumentData(doc, docInfo, docInfo.getLanguage());
-			pIndex->replace_document(docId, doc);
-			updated = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't update document properties: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't update document properties, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return updated;
-}
-
-/// Sets a document's labels.
-bool XapianIndex::setDocumentLabels(unsigned int docId, const set<string> &labels,
-	bool resetLabels)
-{
-	bool updatedLabels = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc = pIndex->get_document(docId);
-
-			// Reset existing labels ?
-			if (resetLabels == true)
-			{
-				Xapian::TermIterator termIter = pIndex->termlist_begin(docId);
-				if (termIter != pIndex->termlist_end(docId))
-				{
-					for (termIter.skip_to("XLABEL:");
-						termIter != pIndex->termlist_end(docId); ++termIter)
-					{
-						// Is this a label ?
-						if (strncasecmp((*termIter).c_str(), "XLABEL:", min(7, (int)(*termIter).length())) == 0)
-						{
-							doc.remove_term(*termIter);
-						}
-					}
-				}
-			}
-
-			// Set new labels
-			for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
-				++labelIter)
-			{
-				if (labelIter->empty() == false)
-				{
-					doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
-				}
-			}
-
-			pIndex->replace_document(docId, doc);
-			updatedLabels = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't update document's labels: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't update document's labels, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return updatedLabels;
-}
-
 /// Checks whether the given URL is in the index.
 unsigned int XapianIndex::hasDocument(const string &url) const
 {
 	unsigned int docId = 0;
 
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
 	if (pDatabase == NULL)
 	{
 		cerr << "Bad index " << m_databaseName << endl;
@@ -835,93 +353,10 @@
 	return docId;
 }
 
-/// Unindexes the given document; true if success.
-bool XapianIndex::unindexDocument(unsigned int docId)
-{
-	bool unindexed = false;
-
-	if (docId == 0)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			// Delete the document from the index
-			pIndex->delete_document(docId);
-			unindexed = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't unindex document: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't unindex document, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return unindexed;
-}
-
-/// Unindexes documents with the given label.
-bool XapianIndex::unindexDocuments(const string &labelName)
-{
-	bool unindexed = false;
-
-	if (labelName.empty() == true)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			string term("XLABEL:");
-
-			// Delete documents from the index
-			term += labelName;
-			pIndex->delete_document(term);
-			unindexed = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't unindex documents: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't unindex documents, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return unindexed;
-}
-
 /// Gets terms with the same root.
 unsigned int XapianIndex::getCloseTerms(const string &term, set<string> &suggestions)
 {
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
 	if (pDatabase == NULL)
 	{
 		cerr << "Bad index " << m_databaseName << endl;
@@ -971,150 +406,12 @@
 	return suggestions.size();
 }
 
-/// Renames a label.
-bool XapianIndex::renameLabel(const string &name, const string &newName)
-{
-	bool renamedLabel = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			string term("XLABEL:");
-
-			// Get documents that have this label
-			term += name;
-			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
-				postingIter != pIndex->postlist_end(term); ++postingIter)
-			{
-				Xapian::docid docId = *postingIter;
-
-				// Get the document
-				Xapian::Document doc = pIndex->get_document(docId);
-				// Remove the term
-				doc.remove_term(term);
-				// ...add the new one
-				doc.add_term(limitTermLength(string("XLABEL:") + newName));
-				// ...and update the document
-				pIndex->replace_document(docId, doc);
-			}
-
-			renamedLabel = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't delete label: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't delete label, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return renamedLabel;
-}
-
-/// Deletes all references to a label.
-bool XapianIndex::deleteLabel(const string &name)
-{
-	bool deletedLabel = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			string term("XLABEL:");
-
-			// Get documents that have this label
-			term += name;
-			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
-				postingIter != pIndex->postlist_end(term); ++postingIter)
-			{
-				Xapian::docid docId = *postingIter;
-
-				// Get the document
-				Xapian::Document doc = pIndex->get_document(docId);
-				// Remove the term
-				doc.remove_term(term);
-				// ...and update the document
-				pIndex->replace_document(docId, doc);
-			}
-			deletedLabel = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't delete label: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't delete label, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return deletedLabel;
-}
-
-/// Flushes recent changes to the disk.
-bool XapianIndex::flush(void)
-{
-	bool flushed = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-#ifdef DEBUG
-		cout << "XapianIndex::flush: called" << endl;
-#endif
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			pIndex->flush();
-			flushed = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't flush database: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't flush database, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return flushed;
-}
-
 /// Returns the number of documents.
 unsigned int XapianIndex::getDocumentsCount(const string &labelName) const
 {
 	unsigned int docCount = 0;
 
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
 	if (pDatabase == NULL)
 	{
 		cerr << "Bad index " << m_databaseName << endl;
@@ -1171,3 +468,4 @@
 	term += name;
 	return listDocumentsWithTerm(term, docIds, maxDocsCount, startDoc);
 }
+

Modified: trunk/Index/XapianIndex.h
===================================================================
--- trunk/Index/XapianIndex.h	2006-07-16 10:11:27 UTC (rev 356)
+++ trunk/Index/XapianIndex.h	2006-07-18 13:08:51 UTC (rev 357)
@@ -31,13 +31,12 @@
 		XapianIndex(const std::string &indexName);
 		virtual ~XapianIndex();
 
+		/// Returns false if the index couldn't be opened.
+		virtual bool isGood(void) const;
+
 		/// Gets the index location.
 		virtual std::string getLocation(void) const;
 
-		/// Indexes the given data.
-		virtual bool indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
-			unsigned int &docId);
-
 		/// Returns a document's properties.
 		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const;
 
@@ -47,37 +46,12 @@
 		/// Returns a document's labels.
 		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const;
 
-		/// Updates the given document.
-		virtual bool updateDocument(unsigned int docId, Tokenizer &tokens);
-
-		/// Updates a document's properties.
-		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo);
-
-		/// Sets a document's labels.
-		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
-			bool resetLabels = true);
-
 		/// Checks whether the given URL is in the index.
 		virtual unsigned int hasDocument(const std::string &url) const;
 
-		/// Unindexes the given document.
-		virtual bool unindexDocument(unsigned int docId);
-
-		/// Unindexes documents with the given label.
-		virtual bool unindexDocuments(const std::string &labelName);
-
 		/// Gets terms with the same root.
 		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions);
 
-		/// Renames a label.
-		virtual bool renameLabel(const std::string &name, const std::string &newName);
-
-		/// Deletes all references to a label.
-		virtual bool deleteLabel(const std::string &name);
-
-		/// Flushes recent changes to the disk.
-		virtual bool flush(void);
-
 		/// Returns the number of documents.
 		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const;
 
@@ -93,24 +67,10 @@
 		static const unsigned int m_maxTermLength;
 		static const std::string MAGIC_TERM;
 		std::string m_databaseName;
-		std::string m_stemLanguage;
+		bool m_goodIndex;
 
 		static std::string limitTermLength(const std::string &term, bool makeUnique = false);
 
-		static bool badField(const std::string &field);
-
-		void addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,
-			const std::string &prefix, Xapian::termcount &termPos, StemmingMode mode) const;
-
-		bool prepareDocument(const DocumentInfo &info, Xapian::Document &doc,
-			Xapian::termcount &termPos) const;
-
-		std::string scanDocument(const char *pData, unsigned int dataLength,
-			DocumentInfo &info);
-
-		void setDocumentData(Xapian::Document &doc, const DocumentInfo &info,
-			const std::string &language) const;
-
 		bool listDocumentsWithTerm(const std::string &term, std::set<unsigned int> &docIds,
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
 

Modified: trunk/Index/pinot-index.cpp
===================================================================
--- trunk/Index/pinot-index.cpp	2006-07-16 10:11:27 UTC (rev 356)
+++ trunk/Index/pinot-index.cpp	2006-07-18 13:08:51 UTC (rev 357)
@@ -26,7 +26,7 @@
 #include "XapianDatabaseFactory.h"
 #include "TokenizerFactory.h"
 #include "DownloaderFactory.h"
-#include "XapianIndex.h"
+#include "WritableXapianIndex.h"
 #include "config.h"
 
 using namespace std;
@@ -70,7 +70,7 @@
 					<< "  -h, --help		display this help and exit\n"
 					<< "  -i, --index		index the given URL\n"
 					<< "  -v, --version		output version information and exit\n\n";
-				cout << "\n\nExamples:\n"
+				cout << "Examples:\n"
 					<< "pinot-index --check http://pinot.berlios.de/ xapian ~/.pinot/index\n\n"
 					<< "pinot-index --index http://pinot.berlios.de/ xapian ~/.pinot/index\n\n"
 					<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
@@ -110,10 +110,10 @@
 
 	// FIXME: don't ignore the index type
 
-	XapianIndex index(argv[optind + 1]);
-
 	if (checkDocument == true)
 	{
+		XapianIndex index(argv[optind + 1]);
+
 		if (index.isGood() == true)
 		{
 			unsigned int docId = index.hasDocument(urlToCheck);
@@ -153,9 +153,10 @@
 			Tokenizer *pTokens = TokenizerFactory::getTokenizerByType(docInfo.getType(), pDoc);
 			if (pTokens != NULL)
 			{
+				WritableXapianIndex index(argv[optind + 1]);
 				set<string> labels;
 
-				index.setStemmingMode(IndexInterface::STORE_BOTH);
+				index.setStemmingMode(WritableIndexInterface::STORE_BOTH);
 
 				// Update an existing document or add to the index ?
 				unsigned int docId = index.hasDocument(urlToIndex);



From fabricecolin at mail.berlios.de  Wed Jul 19 13:27:04 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 19 Jul 2006 13:27:04 +0200
Subject: [Pinot-svn] r358 - trunk/Index
Message-ID: <200607191127.k6JBR4Dd010411@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-19 13:27:03 +0200 (Wed, 19 Jul 2006)
New Revision: 358

Modified:
   trunk/Index/WritableXapianIndex.cpp
Log:
If the document to index has no data, that's fine. We can still index metadata.


Modified: trunk/Index/WritableXapianIndex.cpp
===================================================================
--- trunk/Index/WritableXapianIndex.cpp	2006-07-18 13:08:51 UTC (rev 357)
+++ trunk/Index/WritableXapianIndex.cpp	2006-07-19 11:27:03 UTC (rev 358)
@@ -426,21 +426,17 @@
 			return false;
 		}
 
-		const char *pData = pDocument->getData(dataLength);
-		if (pData == NULL)
-		{
-#ifdef DEBUG
-			cout << "WritableXapianIndex::indexDocument: empty document" << endl;
-#endif
-			return false;
-		}
 		// Cache the document's properties
 		DocumentInfo docInfo(pDocument->getTitle(), pDocument->getLocation(),
 			pDocument->getType(), pDocument->getLanguage());
 		docInfo.setTimestamp(pDocument->getTimestamp());
 		docInfo.setLocation(Url::canonicalizeUrl(docInfo.getLocation()));
 
-		m_stemLanguage = scanDocument(pData, dataLength, docInfo);
+		const char *pData = pDocument->getData(dataLength);
+		if (pData != NULL)
+		{
+			m_stemLanguage = scanDocument(pData, dataLength, docInfo);
+		}
 
 		Xapian::Document doc;
 		Xapian::termcount termPos = 0;



From fabricecolin at mail.berlios.de  Thu Jul 20 15:47:49 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 20 Jul 2006 15:47:49 +0200
Subject: [Pinot-svn] r359 - trunk/Utils
Message-ID: <200607201347.k6KDln2K006627@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-20 15:47:46 +0200 (Thu, 20 Jul 2006)
New Revision: 359

Modified:
   trunk/Utils/MIMEScanner.cpp
Log:
If the type doesn't have a default action, get a list of his parent types and
see if they do.


Modified: trunk/Utils/MIMEScanner.cpp
===================================================================
--- trunk/Utils/MIMEScanner.cpp	2006-07-19 11:27:03 UTC (rev 358)
+++ trunk/Utils/MIMEScanner.cpp	2006-07-20 13:47:46 UTC (rev 359)
@@ -329,6 +329,33 @@
 {
 	map<string, MIMEAction>::const_iterator actionIter = m_defaultActions.find(mimeType);
 
+	if (actionIter == m_defaultActions.end())
+	{
+		// Is there an action for any of this type's parents ?
+		char **pParentTypes = xdg_mime_list_mime_parents(mimeType.c_str());
+		if ((pParentTypes != NULL) &&
+			(pParentTypes[0] != NULL))
+		{
+			for (unsigned int i = 0; pParentTypes[i] != NULL; ++i)
+			{
+				actionIter = m_defaultActions.find(pParentTypes[i]);
+				if (actionIter != m_defaultActions.end())
+				{
+#ifdef DEBUG
+					cout << "MIMEScanner::getDefaultAction: " << mimeType << " has parent type " << pParentTypes[i] << endl;
+#endif
+					break;
+				}
+			}
+
+			free(pParentTypes);
+		}
+#ifdef DEBUG
+		else cout << "MIMEScanner::getDefaultAction: " << mimeType << " has no parent types" << endl;
+#endif
+	}
+
+	// Found anything ?
 	if (actionIter != m_defaultActions.end())
 	{
 		typeAction = actionIter->second;



From fabricecolin at mail.berlios.de  Thu Jul 20 15:53:19 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 20 Jul 2006 15:53:19 +0200
Subject: [Pinot-svn] r360 - trunk/UI/GTK2/src
Message-ID: <200607201353.k6KDrJdK008124@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-20 15:53:17 +0200 (Thu, 20 Jul 2006)
New Revision: 360

Modified:
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
Log:
ThreadManager and IndexingThread expect the index to be specified.
If the type of the document to index is not supported, skip its content and
index only the metadata.


Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-07-20 13:47:46 UTC (rev 359)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-07-20 13:53:17 UTC (rev 360)
@@ -44,7 +44,7 @@
 #ifdef HAS_GOOGLEAPI
 #include "GoogleAPIEngine.h"
 #endif
-#include "XapianIndex.h"
+#include "WritableXapianIndex.h"
 #include "config.h"
 #include "NLS.h"
 #include "PinotSettings.h"
@@ -161,8 +161,10 @@
 	m_dispatcher.emit();
 }
 
-ThreadsManager::ThreadsManager(unsigned int maxIndexThreads) :
+ThreadsManager::ThreadsManager(const string &defaultIndexLocation,
+	unsigned int maxIndexThreads) :
 	SigC::Object(),
+	m_defaultIndexLocation(defaultIndexLocation),
 	m_maxIndexThreads(maxIndexThreads),
 	m_nextId(1),
 	m_backgroundThreadsCount(0)
@@ -288,12 +290,12 @@
 	}
 
 	// Is it an update ?
-	XapianIndex docsIndex(PinotSettings::getInstance().m_indexLocation);
-	unsigned int docId = docsIndex.hasDocument(docInfo.getLocation());
+	XapianIndex index(m_defaultIndexLocation);
+	unsigned int docId = index.hasDocument(docInfo.getLocation());
 	if (docId > 0)
 	{
 		// Yes, it is
-		start_thread(new IndexingThread(docInfo, docId));
+		start_thread(new IndexingThread(docInfo, docId, m_defaultIndexLocation));
 	}
 	else
 	{
@@ -318,7 +320,7 @@
 		}
 
 		// This is a new document
-		start_thread(new IndexingThread(docInfo));
+		start_thread(new IndexingThread(docInfo, docId, m_defaultIndexLocation));
 	}
 
 	return true;
@@ -342,6 +344,8 @@
 	Thread *pThread = pWorkerThread->start();
 	if (pThread == NULL)
 	{
+		delete pWorkerThread;
+
 		return false;
 	}
 
@@ -417,7 +421,7 @@
 
 	// Connect the dispatcher
 	m_threadsEndConnection = WorkerThread::getDispatcher().connect(
-		SigC::slot(*this, &ThreadsManager::on_thread_end));
+		SigC::slot(*this, &ThreadsManager::on_thread_signal));
 #ifdef DEBUG
 	cout << "ThreadsManager::connect: connected" << endl;
 #endif
@@ -432,13 +436,13 @@
 #endif
 }
 
-void ThreadsManager::on_thread_end()
+void ThreadsManager::on_thread_signal()
 {
 	WorkerThread *pThread = get_thread();
 	if (pThread == NULL)
 	{
 #ifdef DEBUG
-		cout << "ThreadsManager::on_thread_end: foreign thread" << endl;
+		cout << "ThreadsManager::on_thread_signal: foreign thread" << endl;
 #endif
 		return;
 	}
@@ -801,16 +805,16 @@
 
 void LabelUpdateThread::doWork(void)
 {
-	XapianIndex docsIndex(PinotSettings::getInstance().m_indexLocation);
+	WritableXapianIndex docsIndex(PinotSettings::getInstance().m_docsIndexLocation);
 	if (docsIndex.isGood() == false)
 	{
 		m_status = _("Index error on");
 		m_status += " ";
-		m_status += PinotSettings::getInstance().m_indexLocation;
+		m_status += PinotSettings::getInstance().m_docsIndexLocation;
 		return;
 	}
 
-	XapianIndex mailIndex(PinotSettings::getInstance().m_mailIndexLocation);
+	WritableXapianIndex mailIndex(PinotSettings::getInstance().m_mailIndexLocation);
 	if (mailIndex.isGood() == false)
 	{
 		m_status = _("Index error on");
@@ -819,6 +823,8 @@
 		return;
 	}
 
+	// FIXME: what about the daemon index ?
+
 	// Delete labels
 	for (set<string>::iterator iter = m_labelsToDelete.begin(); iter != m_labelsToDelete.end(); ++iter)
 	{
@@ -925,13 +931,13 @@
 }
 
 IndexingThread::IndexingThread(const DocumentInfo &docInfo, unsigned int docId,
-	bool allowAllMIMETypes) :
+	const string &indexLocation, bool allowAllMIMETypes) :
 	DownloadingThread(docInfo, false),
 	m_docInfo(docInfo),
 	m_docId(docId),
+	m_indexLocation(indexLocation),
 	m_allowAllMIMETypes(allowAllMIMETypes)
 {
-	m_indexLocation = PinotSettings::getInstance().m_indexLocation;
 	if (m_docId > 0)
 	{
 		// Ignore robots directives on updates
@@ -992,7 +998,7 @@
 void IndexingThread::doWork(void)
 {
 	// First things first, get the index
-	XapianIndex index(m_indexLocation);
+	WritableXapianIndex index(m_indexLocation);
 	if (index.isGood() == false)
 	{
 		m_status = _("Index error on");
@@ -1008,7 +1014,8 @@
 
 	if (m_pDoc != NULL)
 	{
-		string docType = m_pDoc->getType();
+		Tokenizer *pTokens = NULL;
+		string docType(m_pDoc->getType());
 		bool success = false;
 
 		// The type may have been obtained when downloading
@@ -1021,20 +1028,6 @@
 			m_pDoc->setType(m_docInfo.getType());
 		}
 
-		// Skip unsupported types ?
-		if ((m_allowAllMIMETypes == false) &&
-			(TokenizerFactory::isSupportedType(m_docInfo.getType()) == false))
-		{
-			m_status = _("Cannot index document type");
-			m_status += " ";
-			m_status += m_docInfo.getType();
-			m_status += " ";
-			m_status += _("at");
-			m_status += " ";
-			m_status += m_docInfo.getLocation();
-			return;
-		}
-
 		if (m_docInfo.getTitle().empty() == false)
 		{
 			// Use the title we were supplied with
@@ -1049,16 +1042,43 @@
 		cout << "IndexingThread::doWork: title is " << m_pDoc->getTitle() << endl;
 #endif
 
-		// Tokenize this document
-		Tokenizer *pTokens = TokenizerFactory::getTokenizerByType(m_docInfo.getType(), m_pDoc);
-		if (pTokens == NULL)
+		if (TokenizerFactory::isSupportedType(m_docInfo.getType()) == false)
 		{
-			m_status = _("Couldn't tokenize");
-			m_status += " ";
-			m_status += m_docInfo.getLocation();
-			return;
+			// Skip unsupported types ?
+			if (m_allowAllMIMETypes == false)
+			{
+				m_status = _("Cannot index document type");
+				m_status += " ";
+				m_status += m_docInfo.getType();
+				m_status += " ";
+				m_status += _("at");
+				m_status += " ";
+				m_status += m_docInfo.getLocation();
+				return;
+			}
+#ifdef DEBUG
+			cout << "IndexingThread::doWork: can't index document content" << endl;
+#endif
+
+			// Create an empty document so that the file's details are indexed but not its content
+			delete m_pDoc;
+			m_pDoc = new Document(m_docInfo);
+			// A simple text tokenizer will do the job
+			pTokens = new Tokenizer(m_pDoc);
 		}
+		else
+		{
+			pTokens = TokenizerFactory::getTokenizerByType(m_docInfo.getType(), m_pDoc);
+		}
 
+		if (pTokens == NULL)
+                {
+                        m_status = _("Couldn't tokenize");
+                        m_status += " ";
+                        m_status += m_docInfo.getLocation();
+                        return;
+                }
+
 		// Is indexing allowed ?
 		HtmlTokenizer *pHtmlTokens = dynamic_cast<HtmlTokenizer*>(pTokens);
 		if ((m_ignoreRobotsDirectives == false) &&
@@ -1084,7 +1104,7 @@
 		{
 			const set<string> &labels = m_docInfo.getLabels();
 
-			index.setStemmingMode(IndexInterface::STORE_BOTH);
+			index.setStemmingMode(WritableIndexInterface::STORE_BOTH);
 
 			// Update an existing document or add to the index ?
 			if (m_update == true)
@@ -1132,7 +1152,7 @@
 
 UnindexingThread::UnindexingThread(const set<unsigned int> &docIdList) :
 	WorkerThread(),
-	m_indexLocation(PinotSettings::getInstance().m_indexLocation),
+	m_indexLocation(PinotSettings::getInstance().m_docsIndexLocation),
 	m_docsCount(0)
 {
 	copy(docIdList.begin(), docIdList.end(), inserter(m_docIdList, m_docIdList.begin()));
@@ -1146,7 +1166,7 @@
 	copy(labelNames.begin(), labelNames.end(), inserter(m_labelNames, m_labelNames.begin()));
 	if (indexLocation.empty() == true)
 	{
-		m_indexLocation = PinotSettings::getInstance().m_indexLocation;
+		m_indexLocation = PinotSettings::getInstance().m_docsIndexLocation;
 	}
 }
 
@@ -1175,7 +1195,7 @@
 {
 	if (m_done == false)
 	{
-		XapianIndex index(m_indexLocation);
+		WritableXapianIndex index(m_indexLocation);
 
 		if (index.isGood() == false)
 		{
@@ -1295,7 +1315,7 @@
 		}
 
 		// Get the index at that location
-		XapianIndex index(mapIter->second);
+		WritableXapianIndex index(mapIter->second);
 		if (index.isGood() == false)
 		{
 			m_status = _("Index error on");
@@ -1312,6 +1332,7 @@
 		{
 			// Flush the index
 			index.flush();
+
 			// The document properties may have changed
 			index.getDocumentInfo(m_docId, m_docInfo);
 		}

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2006-07-20 13:47:46 UTC (rev 359)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2006-07-20 13:53:17 UTC (rev 360)
@@ -91,7 +91,8 @@
 class ThreadsManager : public SigC::Object
 {
 	public:
-		ThreadsManager(unsigned int maxIndexThreads);
+		ThreadsManager(const std::string &defaultIndexLocation,
+			unsigned int maxIndexThreads);
 		virtual ~ThreadsManager();
 
 		bool start_thread(WorkerThread *pWorkerThread, bool inBackground = false);
@@ -106,7 +107,7 @@
 
 		virtual void disconnect(void);
 
-		void on_thread_end();
+		void on_thread_signal();
 
 		bool read_lock_lists(void);
 
@@ -125,6 +126,7 @@
 		pthread_rwlock_t m_threadsLock;
 		pthread_rwlock_t m_listsLock;
 		std::map<WorkerThread *, Glib::Thread *> m_threads;
+		std::string m_defaultIndexLocation;
 		unsigned int m_maxIndexThreads;
 		unsigned int m_nextId;
 		unsigned int m_backgroundThreadsCount;
@@ -272,8 +274,8 @@
 class IndexingThread : public DownloadingThread
 {
 	public:
-		IndexingThread(const DocumentInfo &docInfo, unsigned int docId = 0,
-			bool allowAllMIMETypes = false);
+		IndexingThread(const DocumentInfo &docInfo, unsigned int docId,
+			const std::string &indexLocation, bool allowAllMIMETypes = true);
 		virtual ~IndexingThread();
 
 		virtual std::string getType(void) const;
@@ -291,8 +293,8 @@
 	protected:
 		DocumentInfo m_docInfo;
 		unsigned int m_docId;
+		std::string m_indexLocation;
 		bool m_allowAllMIMETypes;
-		std::string m_indexLocation;
 		bool m_ignoreRobotsDirectives;
 		bool m_update;
 



From fabricecolin at mail.berlios.de  Thu Jul 20 15:56:44 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 20 Jul 2006 15:56:44 +0200
Subject: [Pinot-svn] r361 - trunk/UI/GTK2/src
Message-ID: <200607201356.k6KDuiJ5009082@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-20 15:56:38 +0200 (Thu, 20 Jul 2006)
New Revision: 361

Modified:
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/PinotSettings.h
Log:
Load locations indexable by the daemon process. Define an index for the daemon
use (temporarily named "My Computer").


Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2006-07-20 13:53:17 UTC (rev 360)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2006-07-20 13:56:38 UTC (rev 361)
@@ -112,10 +112,12 @@
 	}
 
 	// This is where the internal indices live
-	m_indexLocation = directoryName;
-	m_indexLocation += "/index";
+	m_docsIndexLocation = directoryName;
+	m_docsIndexLocation += "/index";
 	m_mailIndexLocation = directoryName;
 	m_mailIndexLocation += "/mail";
+	m_daemonIndexLocation = directoryName;
+	m_daemonIndexLocation += "/daemon";
 
 	// The location of the history database is not configurable
 	m_historyDatabase = directoryName;
@@ -189,6 +191,7 @@
 	m_queries.clear();
 	m_labels.clear();
 	m_mailAccounts.clear();
+	m_indexableLocations.clear();
 	m_cacheProviders.clear();
 }
 
@@ -213,8 +216,9 @@
 	}
 
 	// Internal indices
-	addIndex(_("My Documents"), m_indexLocation);
+	addIndex(_("My Documents"), m_docsIndexLocation);
 	addIndex(_("My Email"), m_mailIndexLocation);
+	addIndex(_("My Computer"), m_daemonIndexLocation);
 
 	// Add default labels on the first run
 	if (m_firstRun == true)
@@ -355,6 +359,10 @@
 				{
 					loadMailAccounts(pElem);
 				}
+				else if (nodeName == "indexable")
+				{
+					loadIndexableLocations(pElem);
+				}
 			}
 		}
 	}
@@ -743,6 +751,41 @@
 	return true;
 }
 
+bool PinotSettings::loadIndexableLocations(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return false;
+	}
+
+	Node::NodeList childNodes = pElem->get_children();
+	if (childNodes.empty() == true)
+	{
+		return false;
+	}
+
+	// Load the indexable location's properties
+	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+	{
+		Node *pNode = (*iter);
+		Element *pElem = dynamic_cast<Element*>(pNode);
+		if (pElem == NULL)
+		{
+			continue;
+		}
+
+		string nodeName = pElem->get_name();
+		string nodeContent = getElementContent(pElem);
+
+		if (nodeName == "location")
+		{
+			m_indexableLocations.insert(nodeContent);
+		}
+	}
+
+	return true;
+}
+
 bool PinotSettings::loadCacheProviders(const Element *pElem)
 {
 	if (pElem == NULL)
@@ -997,6 +1040,16 @@
 		sprintf(numStr, "%ld", mailIter->m_size);
 		addChildElement(pElem, "size", numStr);
 	}
+	// Locations to index 
+	for (set<string>::iterator locationIter = m_indexableLocations.begin(); locationIter != m_indexableLocations.end(); ++locationIter)
+	{
+		pElem = pRootElem->add_child("indexable");
+		if (pElem == NULL)
+		{
+			return false;
+		}
+		addChildElement(pElem, "location", *locationIter);
+	}
 
 	// Save to file
 	doc.write_to_file_formatted(getConfigurationFileName());
@@ -1014,7 +1067,8 @@
 bool PinotSettings::isInternalIndex(const string &indexName) const
 {
 	if ((indexName == _("My Documents")) ||
-		(indexName == _("My Email")))
+		(indexName == _("My Email")) ||
+		(indexName == _("My Computer")))
 	{
 		return true;
 	}
@@ -1069,8 +1123,9 @@
 	// Clear both maps, reinsert the internal index
 	m_indexNames.clear();
 	m_indexIds.clear();
-	addIndex(_("My Documents"), m_indexLocation);
+	addIndex(_("My Documents"), m_docsIndexLocation);
 	addIndex(_("My Email"), m_mailIndexLocation);
+	addIndex(_("My Computer"), m_daemonIndexLocation);
 }
 
 /// Returns an ID that identifies the given index.

Modified: trunk/UI/GTK2/src/PinotSettings.h
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.h	2006-07-20 13:53:17 UTC (rev 360)
+++ trunk/UI/GTK2/src/PinotSettings.h	2006-07-20 13:56:38 UTC (rev 361)
@@ -160,8 +160,9 @@
 		};
 
 		Glib::ustring m_googleAPIKey;
-		Glib::ustring m_indexLocation;
+		Glib::ustring m_docsIndexLocation;
 		Glib::ustring m_mailIndexLocation;
+		Glib::ustring m_daemonIndexLocation;
 		Glib::ustring m_historyDatabase;
 		int m_xPos;
 		int m_yPos;
@@ -173,6 +174,7 @@
 		bool m_suggestQueryTerms;
 		Gdk::Color m_newResultsColour;
 		std::set<MailAccount> m_mailAccounts;
+		std::set<std::string> m_indexableLocations;
 		std::vector<CacheProvider> m_cacheProviders;
 		std::set<Glib::ustring> m_cacheProtocols;
 
@@ -196,6 +198,7 @@
 		bool loadLabels(const xmlpp::Element *pElem);
 		bool loadColour(const xmlpp::Element *pElem);
 		bool loadMailAccounts(const xmlpp::Element *pElem);
+		bool loadIndexableLocations(const xmlpp::Element *pElem);
 		bool loadCacheProviders(const xmlpp::Element *pElem);
 
 	private:



From fabricecolin at mail.berlios.de  Thu Jul 20 16:01:02 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 20 Jul 2006 16:01:02 +0200
Subject: [Pinot-svn] r362 - trunk/UI/GTK2/src
Message-ID: <200607201401.k6KE12rB011341@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-20 16:00:55 +0200 (Thu, 20 Jul 2006)
New Revision: 362

Modified:
   trunk/UI/GTK2/src/propertiesDialog.cc
Log:
Minor fix : default to the first language in the list only if the name was
actually a language name.


Modified: trunk/UI/GTK2/src/propertiesDialog.cc
===================================================================
--- trunk/UI/GTK2/src/propertiesDialog.cc	2006-07-20 13:56:38 UTC (rev 361)
+++ trunk/UI/GTK2/src/propertiesDialog.cc	2006-07-20 14:00:55 UTC (rev 362)
@@ -112,7 +112,8 @@
 	}
 
 	// Did we find the given language ?
-	if (foundLanguage == false)
+	if ((notALanguageName == false) &&
+		(foundLanguage == false))
 	{
 		// Select the first language in the list
 		languageCombobox->set_active(languageStart);



From fabricecolin at mail.berlios.de  Thu Jul 20 16:01:59 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 20 Jul 2006 16:01:59 +0200
Subject: [Pinot-svn] r363 - trunk/UI/GTK2/src
Message-ID: <200607201401.k6KE1xei012908@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-20 16:01:55 +0200 (Thu, 20 Jul 2006)
New Revision: 363

Modified:
   trunk/UI/GTK2/src/MboxHandler.cpp
   trunk/UI/GTK2/src/MboxHandler.h
Log:
Synced with XapianIndex changes.


Modified: trunk/UI/GTK2/src/MboxHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.cpp	2006-07-20 14:00:55 UTC (rev 362)
+++ trunk/UI/GTK2/src/MboxHandler.cpp	2006-07-20 14:01:55 UTC (rev 363)
@@ -29,7 +29,7 @@
 #include "XapianDatabase.h"
 #include "TokenizerFactory.h"
 #include "FileCollector.h"
-#include "XapianIndex.h"
+#include "WritableXapianIndex.h"
 #include "PinotUtils.h"
 #include "MboxHandler.h"
 
@@ -37,8 +37,7 @@
 using namespace SigC;
 
 MboxHandler::MboxHandler() :
-	MonitorHandler(),
-	m_locationsCount(0)
+	MonitorHandler()
 {
 }
 
@@ -105,7 +104,7 @@
 	sourceLabel += fileName;
 
 	// Get the mail index
-	XapianIndex index(PinotSettings::getInstance().m_mailIndexLocation);
+	WritableXapianIndex index(PinotSettings::getInstance().m_mailIndexLocation);
 	if (index.isGood() == false)
 	{
 		cerr << "MboxHandler::indexMessages: couldn't get mail index" << endl;
@@ -133,7 +132,7 @@
 	return indexedFile;
 }
 
-bool MboxHandler::parseMailAccount(MboxParser &boxParser, IndexInterface *pIndex,
+bool MboxHandler::parseMailAccount(MboxParser &boxParser, WritableIndexInterface *pIndex,
 	time_t &lastMessageTime, const string &sourceLabel)
 {
 	set<unsigned int> docIdList;
@@ -165,7 +164,7 @@
 		unsigned int docId = pIndex->hasDocument(pMessage->getLocation());
 		if (docId == 0)
 		{
-			pIndex->setStemmingMode(IndexInterface::STORE_BOTH);
+			pIndex->setStemmingMode(WritableIndexInterface::STORE_BOTH);
 
 			// Get an ad hoc tokenizer for the message
 			Tokenizer *pTokenizer = TokenizerFactory::getTokenizerByType(pMessage->getType(), pMessage);
@@ -243,7 +242,7 @@
 	return indexedFile;
 }
 
-bool MboxHandler::deleteMessages(IndexInterface *pIndex, set<unsigned int> &docIdList)
+bool MboxHandler::deleteMessages(WritableIndexInterface *pIndex, set<unsigned int> &docIdList)
 {
 	bool unindexedMsgs = false;
 
@@ -395,7 +394,7 @@
 	sourceLabel += fileName;
 
 	// Get the mail index
-	XapianIndex index(PinotSettings::getInstance().m_mailIndexLocation);
+	WritableXapianIndex index(PinotSettings::getInstance().m_mailIndexLocation);
 	if (index.isGood() == false)
 	{
 		cerr << "MboxHandler::fileDeleted: couldn't get mail index" << endl;

Modified: trunk/UI/GTK2/src/MboxHandler.h
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.h	2006-07-20 14:00:55 UTC (rev 362)
+++ trunk/UI/GTK2/src/MboxHandler.h	2006-07-20 14:01:55 UTC (rev 363)
@@ -54,7 +54,6 @@
 		virtual bool fileDeleted(const std::string &fileName);
 
 	protected:
-		unsigned int m_locationsCount;
 		std::set<std::string> m_locations;
 
 		bool checkMailAccount(const std::string &fileName, PinotSettings::MailAccount &mailAccount,
@@ -63,10 +62,10 @@
 		bool indexMessages(const std::string &fileName, PinotSettings::MailAccount &mailAccount,
 			off_t mboxOffset);
 
-		bool parseMailAccount(MboxParser &boxParser, IndexInterface *pIndex,
+		bool parseMailAccount(MboxParser &boxParser, WritableIndexInterface *pIndex,
 			time_t &lastMessageTime, const std::string &sourceLabel);
 
-		bool deleteMessages(IndexInterface *pIndex, std::set<unsigned int> &docIdList);
+		bool deleteMessages(WritableIndexInterface *pIndex, std::set<unsigned int> &docIdList);
 
 	private:
 		MboxHandler(const MboxHandler &other);



From fabricecolin at mail.berlios.de  Thu Jul 20 16:03:06 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 20 Jul 2006 16:03:06 +0200
Subject: [Pinot-svn] r364 - trunk/UI/GTK2/src
Message-ID: <200607201403.k6KE369h014164@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-20 16:03:04 +0200 (Thu, 20 Jul 2006)
New Revision: 364

Modified:
   trunk/UI/GTK2/src/importDialog.cc
   trunk/UI/GTK2/src/importDialog.hh
Log:
Make use of the Threadsmanager queue.


Modified: trunk/UI/GTK2/src/importDialog.cc
===================================================================
--- trunk/UI/GTK2/src/importDialog.cc	2006-07-20 14:01:55 UTC (rev 363)
+++ trunk/UI/GTK2/src/importDialog.cc	2006-07-20 14:03:04 UTC (rev 364)
@@ -27,7 +27,7 @@
 #include "MIMEScanner.h"
 #include "NLS.h"
 #include "Url.h"
-#include "XapianIndex.h"
+#include "WritableXapianIndex.h"
 #include "PinotSettings.h"
 #include "PinotUtils.h"
 #include "importDialog.hh"
@@ -39,7 +39,7 @@
 string importDialog::InternalState::m_defaultDirectory = "";
 
 importDialog::InternalState::InternalState(unsigned int maxIndexThreads, importDialog *pWindow) :
-	ThreadsManager(maxIndexThreads),
+	ThreadsManager(PinotSettings::getInstance().m_docsIndexLocation, maxIndexThreads),
 	m_importing(false)
 {
 	m_onThreadEndSignal.connect(SigC::slot(*pWindow, &importDialog::on_thread_end));
@@ -133,21 +133,6 @@
 	}
 }
 
-bool importDialog::start_thread(WorkerThread *pNewThread)
-{
-	if (m_state.start_thread(pNewThread, false) == false)
-	{
-		// Delete the object
-		delete pNewThread;
-		return false;
-	}
-#ifdef DEBUG
-	cout << "importDialog::start_thread: started thread " << pNewThread->getId() << endl;
-#endif
-
-	return true;
-}
-
 void importDialog::signal_scanner(void)
 {
 	// Ask the scanner for another file
@@ -168,17 +153,20 @@
 
 bool importDialog::on_import_url(const string &location)
 {
-	XapianIndex index(PinotSettings::getInstance().m_indexLocation);
-	IndexingThread *pThread = NULL;
+	WritableXapianIndex index(PinotSettings::getInstance().m_docsIndexLocation);
 	Url urlObj(location);
 	set<string> labels;
-	string title = from_utf8(m_title);
-	unsigned int docId = 0;
+	string title(from_utf8(m_title));
 
 	if (index.isGood() == true)
 	{
-		docId = index.hasDocument(location);
-		index.getDocumentLabels(docId, labels);
+		unsigned int docId = index.hasDocument(location);
+
+		// if the document exists, get its labels list
+		if (docId > 0)
+		{
+			index.getDocumentLabels(docId, labels);
+		}
 	}
 	labels.insert(m_labelName);
 
@@ -194,20 +182,8 @@
 	DocumentInfo docInfo(title, location, MIMEScanner::scanUrl(urlObj), "");
 	docInfo.setLabels(labels);
 
-	if (docId > 0)
-	{
-		// This document needs updating
-		index.getDocumentInfo(docId, docInfo);
-		pThread = new IndexingThread(docInfo, docId);
-	}
-	else
-	{
-		pThread = new IndexingThread(docInfo);
-	}
+	m_state.queue_index(docInfo);
 
-	// Launch the new thread
-	start_thread(pThread);
-
 	return false;
 }
 
@@ -270,6 +246,9 @@
 	// Delete the thread
 	delete pThread;
 
+	// We might be able to run a queued action
+	m_state.pop_queue();
+
 	if (m_state.m_importing == false)
 	{
 		double fractionFilled = 1.0;
@@ -424,7 +403,7 @@
 			maxDirLevel, linksCheckbutton->get_active(),
 			&m_state.m_scanMutex, &m_state.m_scanCondVar);
 		m_pScannerThread->getFileFoundSignal().connect(SigC::slot(*this, &importDialog::on_import_url));
-		start_thread(m_pScannerThread);
+		m_state.start_thread(m_pScannerThread);
 	}
 	else
 	{

Modified: trunk/UI/GTK2/src/importDialog.hh
===================================================================
--- trunk/UI/GTK2/src/importDialog.hh	2006-07-20 14:01:55 UTC (rev 363)
+++ trunk/UI/GTK2/src/importDialog.hh	2006-07-20 14:03:04 UTC (rev 364)
@@ -44,7 +44,6 @@
 
 protected:
 	void populate_comboboxes(bool localOnly);
-	bool start_thread(WorkerThread *pNewThread);
 	void signal_scanner(void);
 
 	bool on_activity_timeout(void);



From fabricecolin at mail.berlios.de  Thu Jul 20 16:11:16 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 20 Jul 2006 16:11:16 +0200
Subject: [Pinot-svn] r365 - trunk/UI/GTK2/src
Message-ID: <200607201411.k6KEBGfV020286@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-20 16:11:15 +0200 (Thu, 20 Jul 2006)
New Revision: 365

Modified:
   trunk/UI/GTK2/src/mainWindow.cc
Log:
Synced with XapianIndex changes. Show daemon's index in engines list.
When viewing, if the type doesn't have a MIMEAction and the document's
protocol is http, do as if it was an html document as the browser is very
likely to be able to handle it.


Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2006-07-20 14:03:04 UTC (rev 364)
+++ trunk/UI/GTK2/src/mainWindow.cc	2006-07-20 14:11:15 UTC (rev 365)
@@ -43,7 +43,7 @@
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "DownloaderFactory.h"
-#include "XapianIndex.h"
+#include "WritableXapianIndex.h"
 #include "SearchEngineFactory.h"
 #include "config.h"
 #include "NLS.h"
@@ -66,7 +66,7 @@
 unsigned int mainWindow::m_maxIndexThreads = 2;
 
 mainWindow::InternalState::InternalState(unsigned int maxIndexThreads, mainWindow *pWindow) :
-	ThreadsManager(maxIndexThreads),
+	ThreadsManager(PinotSettings::getInstance().m_docsIndexLocation, maxIndexThreads),
 	m_liveQueryLength(0),
 	m_currentPage(0),
 	m_browsingIndex(false)
@@ -305,9 +305,15 @@
 	SigC::Slot1<void, ustring> indexSlot = SigC::slot(*this, &mainWindow::on_index_changed);
 
 	// Populate the submenu
-	m_pIndexMenu->items().push_back(Menu_Helpers::MenuElem(_("My Documents")));
+	m_pIndexMenu->items().push_back(Menu_Helpers::MenuElem(_("My Computer")));
 	MenuItem *pMenuItem = &m_pIndexMenu->items().back();
 	// Bind the callback's parameter to the index name
+	SigC::Slot0<void> daemonActivateSlot = sigc::bind(indexSlot, _("My Computer"));
+	pMenuItem->signal_activate().connect(daemonActivateSlot);
+
+	m_pIndexMenu->items().push_back(Menu_Helpers::MenuElem(_("My Documents")));
+	pMenuItem = &m_pIndexMenu->items().back();
+	// Bind the callback's parameter to the index name
 	SigC::Slot0<void> documentsActivateSlot = sigc::bind(indexSlot, _("My Documents"));
 	pMenuItem->signal_activate().connect(documentsActivateSlot);
 
@@ -447,7 +453,7 @@
 	if ((hasSelection == true) &&
 		(resultsList.empty() == false))
 	{
-		XapianIndex docsIndex(m_settings.m_indexLocation);
+		XapianIndex docsIndex(m_settings.m_docsIndexLocation);
 		bool firstResult = true, isViewable = true, isCached = false, isIndexed = false, isIndexable = true;
 
 		for (vector<DocumentInfo>::iterator resultIter = resultsList.begin();
@@ -533,7 +539,7 @@
 		{
 			bool isDocumentsIndex = true;
 
-			// Enable these menu items, unless the index is not the documents index
+			// Enable these menu items unless it is not the documents index
 			if (indexName != _("My Documents"))
 			{
 				isDocumentsIndex = false;
@@ -866,7 +872,7 @@
 				snprintf(docsCountStr, 64, "%u", pIndexTree->getRowsCount());
 				status += docsCountStr;
 				status += " ";
-				status += _("off");
+				status += _("of");
 				status += " ";
 				snprintf(docsCountStr, 64, "%u", pIndexPage->getDocumentsCount());
 				status += docsCountStr;
@@ -1181,7 +1187,7 @@
 				{
 					// Add a row to the index tree
 					IndexedDocument indexedDoc(docInfo.getTitle(),
-						XapianDatabase::buildUrl(m_settings.m_indexLocation, docId),
+						XapianDatabase::buildUrl(m_settings.m_docsIndexLocation, docId),
 						docInfo.getLocation(), docInfo.getType(),
 						docInfo.getLanguage());
 					indexedDoc.setTimestamp(docInfo.getTimestamp());
@@ -1741,7 +1747,7 @@
 		}
 	}
 
-        XapianIndex docsIndex(m_settings.m_indexLocation);
+        XapianIndex docsIndex(m_settings.m_docsIndexLocation);
         set<unsigned int> docIdList;
 
         if (docsIndex.isGood() == true)
@@ -1758,7 +1764,7 @@
 
 		// Spawn a new thread
 		start_thread(new QueryingThread("xapian", _("My Documents"),
-			m_settings.m_indexLocation, queryProps, docIdList));
+			m_settings.m_docsIndexLocation, queryProps, docIdList));
         }
 }
 
@@ -1770,7 +1776,7 @@
 	vector<DocumentInfo> resultsList;
 
 	// Make sure this has been configured
-	if (m_settings.m_indexLocation.empty() == true)
+	if (m_settings.m_docsIndexLocation.empty() == true)
 	{
 		set_status(_("Please set a location for the index first"));
 		return;
@@ -1862,7 +1868,7 @@
 	vector<IndexedDocument> documentsList;
 
 	// Make sure this has been configured
-	if (m_settings.m_indexLocation.empty() == true)
+	if (m_settings.m_docsIndexLocation.empty() == true)
 	{
 		set_status(_("Please set a location for the index first"));
 		return;
@@ -1946,7 +1952,7 @@
 		return;
 	}
 
-	XapianIndex index(mapIter->second);
+	WritableXapianIndex index(mapIter->second);
 
 	// Get the current documents selection
 	if ((pIndexTree == NULL) ||
@@ -2304,7 +2310,7 @@
 	m_state.m_liveQueryLength = liveQueryLength;
 
 	// FIXME: relying on other indices may also be useful
-	XapianIndex docsIndex(m_settings.m_indexLocation);
+	XapianIndex docsIndex(m_settings.m_docsIndexLocation);
 	if (docsIndex.isGood() == true)
 	{
 		set<string> suggestedTerms;
@@ -2968,9 +2974,10 @@
 	for (multimap<string, string>::iterator locationIter = locationsByType.begin();
 		locationIter != locationsByType.end(); ++locationIter)
 	{
+		string type(locationIter->first);
 		string url(locationIter->second);
 
-		if (locationIter->first != currentType)
+		if (type != currentType)
 		{
 			if ((action.m_exec.empty() == false) &&
 				(arguments.empty() == false))
@@ -2989,16 +2996,32 @@
 			}
 
 			// Get the action for this MIME type
-			if (MIMEScanner::getDefaultAction(locationIter->first, action) == false)
+			if (MIMEScanner::getDefaultAction(type, action) == false)
 			{
-				ustring statusText = _("No default application defined for type");
-				statusText += " ";
-				statusText += locationIter->first;
-				set_status(statusText);
-				continue;
+				Url urlObj(url);
+				bool foundAction = false;
+
+				if (urlObj.getProtocol() == "http")
+				{
+					// Chances are the web browser will be able to open this
+					type = "text/html";
+					foundAction = MIMEScanner::getDefaultAction(type, action);
+#ifdef DEBUG
+					cout << "mainWindow::view_documents: defaulting to test/html" << endl;
+#endif
+				}
+
+				if (foundAction == false)
+				{
+					ustring statusText = _("No default application defined for type");
+					statusText += " ";
+					statusText += type;
+					set_status(statusText);
+					continue;
+				}
 			}
 		}
-		currentType = locationIter->first;
+		currentType = type;
 
 		arguments.push_back(url);
 



From fabricecolin at mail.berlios.de  Thu Jul 20 16:12:14 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 20 Jul 2006 16:12:14 +0200
Subject: [Pinot-svn] r366 - trunk/UI/GTK2/src
Message-ID: <200607201412.k6KECEvm020481@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-20 16:12:13 +0200 (Thu, 20 Jul 2006)
New Revision: 366

Modified:
   trunk/UI/GTK2/src/pinot.cc
Log:
A few cosmetic changes. Open the deamon's index in read-only mode.


Modified: trunk/UI/GTK2/src/pinot.cc
===================================================================
--- trunk/UI/GTK2/src/pinot.cc	2006-07-20 14:11:15 UTC (rev 365)
+++ trunk/UI/GTK2/src/pinot.cc	2006-07-20 14:12:13 UTC (rev 366)
@@ -42,9 +42,9 @@
 
 using namespace std;
 
-static ofstream outputFile;
-static streambuf *coutBuf = NULL;
-static streambuf *cerrBuf = NULL;
+static ofstream g_outputFile;
+static streambuf *g_coutBuf = NULL;
+static streambuf *g_cerrBuf = NULL;
 static struct option g_longOptions[] = {
 	{"help", 0, 0, 'h'},
 	{"version", 0, 0, 'v'},
@@ -69,15 +69,15 @@
 	TokenizerFactory::unloadTokenizers();
 
 	// Restore the stream buffers
-	if (coutBuf != NULL)
+	if (g_coutBuf != NULL)
 	{
-		cout.rdbuf(coutBuf);
+		cout.rdbuf(g_coutBuf);
 	}
-	if (cerrBuf != NULL)
+	if (g_cerrBuf != NULL)
 	{
-		cerr.rdbuf(cerrBuf);
+		cerr.rdbuf(g_cerrBuf);
 	}
-	outputFile.close();
+	g_outputFile.close();
 
 	DownloaderInterface::shutdown();
 	MIMEScanner::shutdown();
@@ -146,11 +146,11 @@
 	// Redirect cout and cerr to a file
 	string logFileName = confDirectory;
 	logFileName += "/pinot.log";
-	outputFile.open(logFileName.c_str());
-	coutBuf = cout.rdbuf();
-	cerrBuf = cerr.rdbuf();
-	cout.rdbuf(outputFile.rdbuf());
-	cerr.rdbuf(outputFile.rdbuf());
+	g_outputFile.open(logFileName.c_str());
+	g_coutBuf = cout.rdbuf();
+	g_cerrBuf = cerr.rdbuf();
+	cout.rdbuf(g_outputFile.rdbuf());
+	cerr.rdbuf(g_outputFile.rdbuf());
 
 	// Localize language names
 	Languages::setIntlName(0, _("Unknown"));
@@ -184,14 +184,14 @@
 	sigaction(SIGINT, &newAction, NULL);
 	sigaction(SIGQUIT, &newAction, NULL);
 
-	// Ensure Xapian will be able to deal with internal indices
-	XapianDatabase *pDb = XapianDatabaseFactory::getDatabase(settings.m_indexLocation, false);
+	// Open these indexes read-write
+	XapianDatabase *pDb = XapianDatabaseFactory::getDatabase(settings.m_docsIndexLocation, false);
 	if ((pDb == NULL) ||
 		(pDb->isOpen() == false))
 	{
 		errorMsg = _("Couldn't open index");
 		errorMsg += " ";
-		errorMsg += settings.m_indexLocation;
+		errorMsg += settings.m_docsIndexLocation;
 	}
 	pDb = XapianDatabaseFactory::getDatabase(settings.m_mailIndexLocation, false);
 	if ((pDb == NULL) ||
@@ -201,6 +201,15 @@
 		errorMsg += " ";
 		errorMsg += settings.m_mailIndexLocation;
 	}
+	// ...the daemon's index in read-only mode
+	pDb = XapianDatabaseFactory::getDatabase(settings.m_daemonIndexLocation);
+	if ((pDb == NULL) ||
+		(pDb->isOpen() == false))
+	{
+		errorMsg = _("Couldn't open index");
+		errorMsg += " ";
+		errorMsg += settings.m_daemonIndexLocation;
+	}
 
 	// Do the same for the history database
 	if ((settings.m_historyDatabase.empty() == true) ||



From fabricecolin at mail.berlios.de  Fri Jul 21 16:43:47 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 21 Jul 2006 16:43:47 +0200
Subject: [Pinot-svn] r367 - trunk/UI/GTK2/src
Message-ID: <200607211443.k6LEhlSx026748@sheep.berlios.de>

Author: fabricecolin
Date: 2006-07-21 16:43:46 +0200 (Fri, 21 Jul 2006)
New Revision: 367

Modified:
   trunk/UI/GTK2/src/EnginesTree.cpp
   trunk/UI/GTK2/src/ResultsTree.cpp
Log:
Caught up with recent changes.


Modified: trunk/UI/GTK2/src/EnginesTree.cpp
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.cpp	2006-07-20 14:12:13 UTC (rev 366)
+++ trunk/UI/GTK2/src/EnginesTree.cpp	2006-07-21 14:43:46 UTC (rev 367)
@@ -336,14 +336,12 @@
 		ustring indexName = to_utf8(indexIter->first);
 		EnginesModelColumns::EngineType indexType = EnginesModelColumns::INDEX_ENGINE;
 
-		if (indexName == _("My Documents"))
+		if ((indexName == _("My Documents")) ||
+			(indexName == _("My Email")) ||
+			(indexName == _("My Computer")))
 		{
 			indexType = EnginesModelColumns::INTERNAL_INDEX_ENGINE;
 		}
-		else if (indexName == _("My Email"))
-		{
-			indexType = EnginesModelColumns::INTERNAL_INDEX_ENGINE;
-		}
 
 		TreeModel::iterator iter = m_refStore->append(localIter->children());
 		TreeModel::Row row = *iter;

Modified: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2006-07-20 14:12:13 UTC (rev 366)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2006-07-21 14:43:46 UTC (rev 367)
@@ -1131,7 +1131,7 @@
 #endif
 	}
 
-	XapianIndex index(m_settings.m_indexLocation);
+	XapianIndex index(m_settings.m_docsIndexLocation);
 	ViewHistory viewHistory(m_settings.m_historyDatabase);
 	bool isIndexed = false;
 



