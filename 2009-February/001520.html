<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Pinot-svn] r1530 - in trunk: . Core UI/GTK2/src po
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/pinot-svn/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r1530%20-%20in%20trunk%3A%20.%20Core%20UI/GTK2/src%20po&In-Reply-To=%3C200902011105.n11B5cOR025670%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001519.html">
   <LINK REL="Next"  HREF="001521.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Pinot-svn] r1530 - in trunk: . Core UI/GTK2/src po</H1>
    <B>fabricecolin at mail.berlios.de</B> 
    <A HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r1530%20-%20in%20trunk%3A%20.%20Core%20UI/GTK2/src%20po&In-Reply-To=%3C200902011105.n11B5cOR025670%40sheep.berlios.de%3E"
       TITLE="[Pinot-svn] r1530 - in trunk: . Core UI/GTK2/src po">fabricecolin at mail.berlios.de
       </A><BR>
    <I>Sun Feb  1 12:05:38 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001519.html">[Pinot-svn] r1529 - trunk/UI/GTK2/src
</A></li>
        <LI>Next message: <A HREF="001521.html">[Pinot-svn] r1531 - in trunk: Core UI/GTK2/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1520">[ date ]</a>
              <a href="thread.html#1520">[ thread ]</a>
              <a href="subject.html#1520">[ subject ]</a>
              <a href="author.html#1520">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fabricecolin
Date: 2009-02-01 12:04:31 +0100 (Sun, 01 Feb 2009)
New Revision: 1530

Added:
   trunk/Core/
   trunk/Core/DaemonState.cpp
   trunk/Core/DaemonState.h
   trunk/Core/Makefile.am
   trunk/Core/OnDiskHandler.cpp
   trunk/Core/OnDiskHandler.h
   trunk/Core/PinotSettings.cpp
   trunk/Core/PinotSettings.h
   trunk/Core/PinotUtils.cpp
   trunk/Core/PinotUtils.h
   trunk/Core/ServerThreads.cpp
   trunk/Core/ServerThreads.h
   trunk/Core/UniqueApplication.cpp
   trunk/Core/UniqueApplication.h
   trunk/Core/WorkerThreads.cpp
   trunk/Core/WorkerThreads.h
   trunk/Core/de.berlios.Pinot.service.in
   trunk/Core/pinot-dbus-daemon.1
   trunk/Core/pinot-dbus-daemon.cc
   trunk/Core/pinot-dbus-daemon.xml
Removed:
   trunk/UI/GTK2/src/DaemonState.cpp
   trunk/UI/GTK2/src/DaemonState.h
   trunk/UI/GTK2/src/OnDiskHandler.cpp
   trunk/UI/GTK2/src/OnDiskHandler.h
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/PinotSettings.h
   trunk/UI/GTK2/src/PinotUtils.cpp
   trunk/UI/GTK2/src/PinotUtils.h
   trunk/UI/GTK2/src/ServerThreads.cpp
   trunk/UI/GTK2/src/ServerThreads.h
   trunk/UI/GTK2/src/UniqueApplication.cpp
   trunk/UI/GTK2/src/UniqueApplication.h
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
   trunk/UI/GTK2/src/de.berlios.Pinot.service.in
   trunk/UI/GTK2/src/pinot-dbus-daemon.1
   trunk/UI/GTK2/src/pinot-dbus-daemon.cc
   trunk/UI/GTK2/src/pinot-dbus-daemon.xml
Modified:
   trunk/Makefile.am
   trunk/UI/GTK2/src/Makefile.am
   trunk/configure.in
   trunk/po/POTFILES.in
Log:
Moved daemon and non-UI specific code out of UI/GTK2/src to Core.


Copied: trunk/Core/DaemonState.cpp (from rev 1529, trunk/UI/GTK2/src/DaemonState.cpp)


Property changes on: trunk/Core/DaemonState.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/DaemonState.h (from rev 1529, trunk/UI/GTK2/src/DaemonState.h)


Property changes on: trunk/Core/DaemonState.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Added: trunk/Core/Makefile.am
===================================================================
--- trunk/Core/Makefile.am	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/Core/Makefile.am	2009-02-01 11:04:31 UTC (rev 1530)
@@ -0,0 +1,60 @@
+# Process this file with automake to produce Makefile.in
+
+noinst_HEADERS = \
+	DaemonState.h \
+	OnDiskHandler.h \
+	PinotSettings.h \
+	PinotUtils.h \
+	ServerThreads.h \
+	UniqueApplication.h \
+	WorkerThreads.h
+
+noinst_LTLIBRARIES = libCore.la
+
+libCore_la_SOURCES = \
+	DaemonState.cpp \
+	OnDiskHandler.cpp \
+	PinotSettings.cpp \
+	PinotUtils.cpp \
+	ServerThreads.cpp \
+	UniqueApplication.cpp \
+	WorkerThreads.cpp
+
+pinot_dbus_daemon_SOURCES = \
+	pinot-dbus-daemon.cc
+
+if HAVE_DBUS
+bin_PROGRAMS = pinot-dbus-daemon
+endif
+
+AM_CXXFLAGS = \
+	@MISC_CFLAGS@ \
+	-I$(top_srcdir)/Utils \
+	-I$(top_srcdir)/Tokenize \
+	-I$(top_srcdir)/Tokenize/filters \
+	-I$(top_srcdir)/SQL \
+	-I$(top_srcdir)/Monitor \
+	-I$(top_srcdir)/Collect \
+	-I$(top_srcdir)/IndexSearch \
+	@SQL_CFLAGS@ @HTTP_CFLAGS@ @XML_CFLAGS@ @DBUS_CFLAGS@ \
+	@INDEX_CFLAGS@ @GTHREAD_CFLAGS@ @GTKMM_CFLAGS@
+
+if HAVE_DBUS
+AM_CXXFLAGS += -DHAVE_DBUS
+endif
+
+pinot_dbus_daemon_LDFLAGS = \
+	-rdynamic
+
+pinot_dbus_daemon_LDADD = \
+	-L$(top_builddir)/Utils \
+	-L$(top_builddir)/Tokenize \
+	-L$(top_builddir)/SQL \
+	-L$(top_builddir)/Monitor \
+	-L$(top_builddir)/Collect \
+	-L$(top_builddir)/IndexSearch \
+	-lCore -lIndexSearch -lMonitor -lCollect -lSQL \
+	-lTokenize -lUtils -lBasicUtils @LIBS@ \
+	@GLIBMM_LIBS@ @DBUS_LIBS@ @GTHREAD_LIBS@ @XML_LIBS@ \
+	@HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
+

Copied: trunk/Core/OnDiskHandler.cpp (from rev 1529, trunk/UI/GTK2/src/OnDiskHandler.cpp)


Property changes on: trunk/Core/OnDiskHandler.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/OnDiskHandler.h (from rev 1529, trunk/UI/GTK2/src/OnDiskHandler.h)


Property changes on: trunk/Core/OnDiskHandler.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/PinotSettings.cpp (from rev 1529, trunk/UI/GTK2/src/PinotSettings.cpp)


Property changes on: trunk/Core/PinotSettings.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/PinotSettings.h (from rev 1529, trunk/UI/GTK2/src/PinotSettings.h)


Property changes on: trunk/Core/PinotSettings.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/PinotUtils.cpp (from rev 1529, trunk/UI/GTK2/src/PinotUtils.cpp)


Property changes on: trunk/Core/PinotUtils.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/PinotUtils.h (from rev 1529, trunk/UI/GTK2/src/PinotUtils.h)


Property changes on: trunk/Core/PinotUtils.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/ServerThreads.cpp (from rev 1529, trunk/UI/GTK2/src/ServerThreads.cpp)


Property changes on: trunk/Core/ServerThreads.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/ServerThreads.h (from rev 1529, trunk/UI/GTK2/src/ServerThreads.h)


Property changes on: trunk/Core/ServerThreads.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/UniqueApplication.cpp (from rev 1529, trunk/UI/GTK2/src/UniqueApplication.cpp)


Property changes on: trunk/Core/UniqueApplication.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/UniqueApplication.h (from rev 1529, trunk/UI/GTK2/src/UniqueApplication.h)


Property changes on: trunk/Core/UniqueApplication.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/WorkerThreads.cpp (from rev 1529, trunk/UI/GTK2/src/WorkerThreads.cpp)


Property changes on: trunk/Core/WorkerThreads.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/WorkerThreads.h (from rev 1529, trunk/UI/GTK2/src/WorkerThreads.h)


Property changes on: trunk/Core/WorkerThreads.h
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/de.berlios.Pinot.service.in (from rev 1529, trunk/UI/GTK2/src/de.berlios.Pinot.service.in)


Property changes on: trunk/Core/de.berlios.Pinot.service.in
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/pinot-dbus-daemon.1 (from rev 1529, trunk/UI/GTK2/src/pinot-dbus-daemon.1)


Property changes on: trunk/Core/pinot-dbus-daemon.1
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/pinot-dbus-daemon.cc (from rev 1529, trunk/UI/GTK2/src/pinot-dbus-daemon.cc)


Property changes on: trunk/Core/pinot-dbus-daemon.cc
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/Core/pinot-dbus-daemon.xml (from rev 1529, trunk/UI/GTK2/src/pinot-dbus-daemon.xml)


Property changes on: trunk/Core/pinot-dbus-daemon.xml
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/Makefile.am	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,5 +1,5 @@
 
-SUBDIRS = po Utils Tokenize SQL Collect IndexSearch/Google IndexSearch IndexSearch/Xapian IndexSearch/XesamGLib Monitor UI/GTK2/src
+SUBDIRS = po Utils Tokenize SQL Collect IndexSearch/Google IndexSearch IndexSearch/Xapian IndexSearch/XesamGLib Monitor Core UI/GTK2/src
 
 # TODO: Fix that when cleaning up for distcheck! - crazy -
 EXTRA_DIST = AUTHORS ChangeLog ChangeLog-dijon FAQ NEWS README TODO \
@@ -9,8 +9,8 @@
 	IndexSearch/Plugins/*src IndexSearch/Plugins/*.xml \
 	IndexSearch/pinot-index.1 IndexSearch/pinot-label.1 \
 	IndexSearch/pinot-search.1 UI/GTK2/src/pinot.1 \
-	UI/GTK2/src/pinot-dbus-daemon.1 UI/GTK2/src/pinot-dbus-daemon.xml \
-	UI/GTK2/src/de.berlios.Pinot.service \
+	Core/pinot-dbus-daemon.1 Core/pinot-dbus-daemon.xml \
+	Core/de.berlios.Pinot.service \
 	UI/GTK2/xapian-powered.png UI/icons/48x48/pinot.png \
 	UI/icons/32x32/pinot.png UI/icons/24x24/pinot.png \
 	UI/icons/22x22/pinot.png UI/icons/16x16/pinot.png \
@@ -18,14 +18,14 @@
 	scripts/bash/*.sh scripts/python/*.py
 
 man_MANS = IndexSearch/pinot-index.1 IndexSearch/pinot-label.1 \
-	IndexSearch/pinot-search.1 UI/GTK2/src/pinot.1 UI/GTK2/src/pinot-dbus-daemon.1
+	IndexSearch/pinot-search.1 Core/pinot-dbus-daemon.1 UI/GTK2/src/pinot.1
 
 manuals:
 	@help2man --no-info --name &quot;Index documents from the command-line&quot; IndexSearch/pinot-index       &gt;IndexSearch/pinot-index.1
 	@help2man --no-info --name &quot;Label files from the command-line&quot; IndexSearch/pinot-label           &gt;IndexSearch/pinot-label.1
 	@help2man --no-info --name &quot;Query search engines from the command-line&quot; IndexSearch/pinot-search &gt;IndexSearch/pinot-search.1
+	@help2man --no-info --name &quot;D-Bus search and index daemon&quot; Core/pinot-dbus-daemon                &gt;Core/pinot-dbus-daemon.1
 	@help2man --no-info --name &quot;A metasearch tool for the Free Desktop&quot; UI/GTK2/src/pinot            &gt;UI/GTK2/src/pinot.1
-	@help2man --no-info --name &quot;D-Bus search and index daemon&quot; UI/GTK2/src/pinot-dbus-daemon         &gt;UI/GTK2/src/pinot-dbus-daemon.1
 
 install-data-local:
 	@ln -fs $(bindir)/pinot $(DESTDIR)$(bindir)/pinot-prefs
@@ -35,11 +35,11 @@
 	$(INSTALL_DATA) $(srcdir)/textcat_conf.txt $(DESTDIR)$(sysconfdir)/pinot/textcat_conf.txt
 	$(INSTALL_DATA) $(srcdir)/textcat3_conf.txt $(DESTDIR)$(sysconfdir)/pinot/textcat3_conf.txt
 	@mkdir -p $(DESTDIR)$(datadir)/pinot $(DESTDIR)$(datadir)/dbus-1/services
+	$(INSTALL_DATA) $(builddir)/Core/de.berlios.Pinot.service $(DESTDIR)$(datadir)/dbus-1/services/de.berlios.Pinot.service
+	$(INSTALL_DATA) $(srcdir)/Core/pinot-dbus-daemon.xml $(DESTDIR)$(datadir)/pinot/pinot-dbus-daemon.xml
 	$(INSTALL_DATA) $(srcdir)/UI/GTK2/xapian-powered.png $(DESTDIR)$(datadir)/pinot/xapian-powered.png
 	$(INSTALL_DATA) $(srcdir)/UI/GTK2/metase-gtk2.glade $(DESTDIR)$(datadir)/pinot/metase-gtk2.glade
 	$(INSTALL_DATA) $(srcdir)/UI/GTK2/metase-gtk2.gladep $(DESTDIR)$(datadir)/pinot/metase-gtk2.gladep
-	$(INSTALL_DATA) $(srcdir)/UI/GTK2/src/pinot-dbus-daemon.xml $(DESTDIR)$(datadir)/pinot/pinot-dbus-daemon.xml
-	$(INSTALL_DATA) $(builddir)/UI/GTK2/src/de.berlios.Pinot.service $(DESTDIR)$(datadir)/dbus-1/services/de.berlios.Pinot.service
 	@mkdir -p $(DESTDIR)$(datadir)/pinot/engines
 	$(INSTALL_DATA) $(srcdir)/IndexSearch/Plugins/*.src $(DESTDIR)$(datadir)/pinot/engines/
 	$(INSTALL_DATA) $(srcdir)/IndexSearch/Plugins/*.xml $(DESTDIR)$(datadir)/pinot/engines/

Deleted: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,836 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &quot;config.h&quot;
-#include &lt;strings.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;dirent.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;stdint.h&gt;
-#include &lt;stdlib.h&gt;
-#ifdef HAVE_STATFS
-  #ifdef HAVE_SYS_VFS_H
-  #include &lt;sys/vfs.h&gt;
-  #define CHECK_DISK_SPACE 1
-  #else
-    #ifdef HAVE_SYS_STATFS_H
-      #include &lt;sys/statfs.h&gt;
-      #define CHECK_DISK_SPACE 1
-    #else
-      #ifdef HAVE_SYS_MOUNT_H
-        #include &lt;sys/mount.h&gt;
-        #define CHECK_DISK_SPACE 1
-      #endif
-    #endif
-  #endif
-#else
-  #ifdef HAVE_STATVFS
-  #include &lt;sys/statvfs.h&gt;
-  #define CHECK_DISK_SPACE 1
-  #endif
-#endif
-#ifdef __FreeBSD__
-#ifdef HAVE_SYSCTLBYNAME
-#include &lt;sys/sysctl.h&gt;
-#define CHECK_BATTERY_SYSCTL 1
-#endif
-#endif
-#include &lt;iostream&gt;
-#include &lt;glibmm/ustring.h&gt;
-#include &lt;glibmm/stringutils.h&gt;
-#include &lt;glibmm/convert.h&gt;
-#include &lt;glibmm/thread.h&gt;
-#include &lt;glibmm/random.h&gt;
-
-#include &quot;Url.h&quot;
-#include &quot;MonitorFactory.h&quot;
-#include &quot;CrawlHistory.h&quot;
-#ifdef HAVE_DBUS
-#include &quot;DBusIndex.h&quot;
-#endif
-#include &quot;DaemonState.h&quot;
-#include &quot;OnDiskHandler.h&quot;
-#include &quot;PinotSettings.h&quot;
-#include &quot;PinotUtils.h&quot;
-#include &quot;ServerThreads.h&quot;
-
-using namespace std;
-using namespace Glib;
-
-static double getFSFreeSpace(const string &amp;path)
-{
-	double availableBlocks = 0.0;
-	double blockSize = 0.0;
-	int statSuccess = -1;
-#ifdef HAVE_STATFS
-	struct statfs fsStats;
-
-	statSuccess = statfs(PinotSettings::getInstance().m_daemonIndexLocation.c_str(), &amp;fsStats);
-	availableBlocks = (uintmax_t)fsStats.f_bavail;
-	blockSize = fsStats.f_bsize;
-#else
-#ifdef HAVE_STATVFS
-	struct statvfs vfsStats;
-
-	statSuccess = statvfs(path.c_str(), &amp;vfsStats);
-	availableBlocks = (uintmax_t)vfsStats.f_bavail;
-	// f_frsize isn't supported by all implementations
-	blockSize = (vfsStats.f_frsize ? vfsStats.f_frsize : vfsStats.f_bsize);
-#endif
-#endif
-	// Did it fail ?
-	if ((statSuccess == -1) ||
-		(blockSize == 0.0))
-	{
-		return -1.0;
-	}
-
-	double mbRatio = blockSize / (1024 * 1024);
-	double availableMbSize = availableBlocks * mbRatio;
-#ifdef DEBUG
-	cout &lt;&lt; &quot;DaemonState::getFSFreeSpace: &quot; &lt;&lt; availableBlocks &lt;&lt; &quot; blocks of &quot; &lt;&lt; blockSize
-		&lt;&lt; &quot; bytes (&quot; &lt;&lt; mbRatio &lt;&lt; &quot;)&quot; &lt;&lt; endl;
-#endif
-
-	return availableMbSize;
-}
-
-// A function object to stop DirectoryScanner threads with for_each()
-struct StopScannerThreadFunc
-{
-public:
-	void operator()(map&lt;unsigned int, WorkerThread *&gt;::value_type &amp;p)
-	{
-		string type(p.second-&gt;getType());
-
-		if (type == &quot;DirectoryScannerThread&quot;)
-		{
-			p.second-&gt;stop();
-#ifdef DEBUG
-			cout &lt;&lt; &quot;StopScannerThreadFunc: stopped thread &quot; &lt;&lt; p.second-&gt;getId() &lt;&lt; endl;
-#endif
-		}
-	}
-};
-
-#ifdef HAVE_DBUS
-DBusServletInfo::DBusServletInfo(DBusConnection *pConnection, DBusMessage *pRequest) :
-	m_pConnection(pConnection),
-	m_pRequest(pRequest),
-	m_pReply(NULL),
-	m_pArray(NULL),
-	m_simpleQuery(true),
-	m_pThread(NULL),
-	m_replied(false)
-{
-}
-
-DBusServletInfo::~DBusServletInfo()
-{
-	if (m_pReply != NULL)
-	{
-		dbus_message_unref(m_pReply);
-	}
-	if (m_pRequest != NULL)
-	{
-		dbus_message_unref(m_pRequest);
-	}
-	if (m_pConnection != NULL)
-	{
-		dbus_connection_unref(m_pConnection);
-	}
-	if (m_pArray != NULL)
-	{
-		// Free the array
-		g_ptr_array_free(m_pArray, TRUE);
-	}
-}
-
-bool DBusServletInfo::newReply(void)
-{
-        if (m_pRequest == NULL) 
-        {
-                return false;
-        }
-
-        m_pReply = dbus_message_new_method_return(m_pRequest);
-        if (m_pReply != NULL)
-        {
-                return true;
-        }
-
-        return false;
-}
-
-bool DBusServletInfo::newErrorReply(const string &amp;name, const string &amp;message)
-{
-        if (m_pRequest == NULL) 
-        {
-                return false;
-        }
-
-	if (m_pReply != NULL)
-	{
-		dbus_message_unref(m_pReply);
-		m_pReply = NULL;
-	}
-
-	m_pReply = dbus_message_new_error(m_pRequest,
-		name.c_str(), message.c_str());
-        if (m_pReply != NULL)
-        {
-                return true;
-        }
-
-        return false;
-}
-
-bool DBusServletInfo::newReplyWithArray(void)
-{
-	if (newReply() == true)
-	{
-		dbus_message_append_args(m_pReply,
-			DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &amp;m_pArray-&gt;pdata, m_pArray-&gt;len,
-			DBUS_TYPE_INVALID);
-
-		return true;
-	}
-
-	return false;
-}
-
-bool DBusServletInfo::newQueryReply(const vector&lt;DocumentInfo&gt; &amp;resultsList,
-	unsigned int resultsEstimate)
-{
-	DBusMessageIter iter, subIter;
-
-	if (m_simpleQuery == false)
-	{
-		// Create the reply
-		if (newReply() == false)
-		{
-			return false;
-		}
-
-		// ...and attach a container
-		dbus_message_iter_init_append(m_pReply, &amp;iter);
-		dbus_message_iter_append_basic(&amp;iter, DBUS_TYPE_UINT32,
-			&amp;resultsEstimate);
-		dbus_message_iter_open_container(&amp;iter, DBUS_TYPE_ARRAY,
-			 DBUS_TYPE_ARRAY_AS_STRING \
-			 DBUS_STRUCT_BEGIN_CHAR_AS_STRING \
-			 DBUS_TYPE_STRING_AS_STRING \
-			 DBUS_TYPE_STRING_AS_STRING \
-			 DBUS_STRUCT_END_CHAR_AS_STRING, &amp;subIter);
-	}
-	else
-	{
-		// Create an array
-		// FIXME: use a container for this too
-		m_pArray = g_ptr_array_new();
-	}
-
-	for (vector&lt;DocumentInfo&gt;::const_iterator resultIter = resultsList.begin();
-		resultIter != resultsList.end(); ++resultIter)
-	{
-		unsigned int indexId = 0;
-		unsigned int docId = resultIter-&gt;getIsIndexed(indexId);
-
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusServletInfo::newQueryReply: adding result &quot; &lt;&lt; docId &lt;&lt; endl;
-#endif
-		if (m_simpleQuery == false)
-		{
-			// The document ID isn't needed here
-			if (DBusIndex::documentInfoToDBus(&amp;subIter, 0, *resultIter) == false)
-			{
-				newErrorReply(&quot;de.berlios.Pinot.Query&quot;, &quot;Unknown error&quot;);
-				return false;
-			}
-		}
-		else if (docId &gt; 0)
-		{
-			char docIdStr[64];
-
-			// We only need the document ID
-			snprintf(docIdStr, 64, &quot;%u&quot;, docId);
-			g_ptr_array_add(m_pArray, const_cast&lt;char*&gt;(docIdStr));
-		}
-	}
-
-	if (m_simpleQuery == false)
-	{
-		// Close the container
-		dbus_message_iter_close_container(&amp;iter, &amp;subIter);
-		return true;
-	}
-
-	// Attach the array to the reply
-	return newReplyWithArray();
-}
-
-bool DBusServletInfo::reply(void)
-{
-	// Send a reply ?
-	if ((m_pConnection != NULL) &amp;&amp;
-		(m_pReply != NULL) &amp;&amp;
-		(m_replied == false))
-	{
-		m_replied = true;
-
-		dbus_connection_send(m_pConnection, m_pReply, NULL);
-		dbus_connection_flush(m_pConnection);
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusServletInfo::reply: sent reply&quot; &lt;&lt; endl;
-#endif
-
-		return true;
-	}
-
-	return false;
-}
-#endif
-
-DaemonState::DaemonState() :
-	ThreadsManager(PinotSettings::getInstance().m_daemonIndexLocation, 10),
-	m_fullScan(false),
-	m_isReindex(false),
-	m_reload(false),
-	m_pDiskMonitor(MonitorFactory::getMonitor()),
-	m_pDiskHandler(NULL),
-	m_crawlers(0)
-{
-	FD_ZERO(&amp;m_flagsSet);
-
-	// Check disk usage every minute
-	m_timeoutConnection = Glib::signal_timeout().connect(sigc::mem_fun(*this,
-		&amp;DaemonState::on_activity_timeout), 60000);
-	// Check right now before doing anything else
-	DaemonState::on_activity_timeout();
-
-	m_onThreadEndSignal.connect(sigc::mem_fun(*this, &amp;DaemonState::on_thread_end));
-}
-
-DaemonState::~DaemonState()
-{
-	// Don't delete m_pDiskMonitor and m_pDiskHandler, threads may need them
-	// Since DaemonState is destroyed when the program exits, it's a leak we can live with
-}
-
-bool DaemonState::on_activity_timeout(void)
-{
-	if (m_timeoutConnection.blocked() == false)
-	{
-#ifdef CHECK_DISK_SPACE
-		double availableMbSize = getFSFreeSpace(PinotSettings::getInstance().m_daemonIndexLocation);
-		if (availableMbSize &gt;= 0)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DaemonState::on_activity_timeout: &quot; &lt;&lt; availableMbSize &lt;&lt; &quot; Mb free for &quot;
-				&lt;&lt; PinotSettings::getInstance().m_daemonIndexLocation &lt;&lt; endl;
-#endif
-			if (availableMbSize &lt; PinotSettings::getInstance().m_minimumDiskSpace)
-			{
-				// Stop indexing
-				m_stopIndexing = true;
-				// Stop crawling
-				set_flag(LOW_DISK_SPACE);
-				stop_crawling();
-
-				cerr &lt;&lt; &quot;Stopped indexing because of low disk space&quot; &lt;&lt; endl;
-			}
-			else if (m_stopIndexing == true)
-			{
-				// Go ahead
-				m_stopIndexing = false;
-				reset_flag(LOW_DISK_SPACE);
-
-				cerr &lt;&lt; &quot;Resumed indexing following low disk space condition&quot; &lt;&lt; endl;
-			}
-		}
-#endif
-#ifdef CHECK_BATTERY_SYSCTL
-		// Check the battery state too
-		check_battery_state();
-#endif
-	}
-
-	return true;
-}
-
-void DaemonState::check_battery_state(void)
-{
-#ifdef CHECK_BATTERY_SYSCTL
-	int acline = 1;
-	size_t len = sizeof(acline);
-	bool onBattery = false;
-
-	// Are we on battery power ?
-	if (sysctlbyname(&quot;hw.acpi.acline&quot;, &amp;acline, &amp;len, NULL, 0) == 0)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DaemonState::check_battery_state: acline &quot; &lt;&lt; acline &lt;&lt; endl;
-#endif
-		if (acline == 0)
-		{
-			onBattery = true;
-		}
-
-		bool wasOnBattery = is_flag_set(ON_BATTERY);
-		if (onBattery != wasOnBattery)
-		{
-			if (onBattery == true)
-			{
-				// We are now on battery
-				set_flag(ON_BATTERY);
-				stop_crawling();
-
-				cout &lt;&lt; &quot;System is now on battery&quot; &lt;&lt; endl;
-			}
-			else
-			{
-				// Back on-line
-				reset_flag(ON_BATTERY);
-				start_crawling();
-
-				cout &lt;&lt; &quot;System is now on AC&quot; &lt;&lt; endl;
-			}
-		}
-	}
-#endif
-}
-
-bool DaemonState::crawl_location(const PinotSettings::IndexableLocation &amp;location)
-{
-	string locationToCrawl(location.m_name);
-	bool doMonitoring = location.m_monitor;
-	bool isSource = location.m_isSource;
-	DirectoryScannerThread *pScannerThread = NULL;
-
-	// Can we go ahead and crawl ?
-	if ((is_flag_set(LOW_DISK_SPACE) == true) ||
-		(is_flag_set(ON_BATTERY) == true))
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DaemonState::crawl_location: crawling was stopped&quot; &lt;&lt; endl;
-#endif
-		return true;
-	}
-
-	if (locationToCrawl.empty() == true)
-	{
-		return false;
-	}
-
-	if (doMonitoring == false)
-	{
-		// Monitoring is not necessary, but we still have to pass the handler
-		// so that we can act on documents that have been deleted
-		pScannerThread = new DirectoryScannerThread(locationToCrawl, isSource,
-			m_fullScan, m_isReindex, NULL, m_pDiskHandler);
-	}
-	else
-	{
-		pScannerThread = new DirectoryScannerThread(locationToCrawl, isSource,
-			m_fullScan, m_isReindex, m_pDiskMonitor, m_pDiskHandler);
-	}
-	pScannerThread-&gt;getFileFoundSignal().connect(sigc::mem_fun(*this, &amp;DaemonState::on_message_filefound));
-
-	if (start_thread(pScannerThread, true) == true)
-	{
-		++m_crawlers;
-		set_flag(CRAWLING);
-
-		return true;
-	}
-
-	return false;
-}
-
-void DaemonState::start(bool forceFullScan, bool isReindex)
-{
-	// Disable implicit flushing after a change
-	WorkerThread::immediateFlush(false);
-
-	// Do full scans ?
-	if (forceFullScan == true)
-	{
-		m_fullScan = true;
-	}
-	else
-	{
-		Rand randomStuff;
-		guint32 randomArray[5];
-
-		randomStuff.set_seed(randomArray[2]);
-		gint32 randomNum = randomStuff.get_int_range(0, 10);
-		if (randomNum &gt;= 7)
-		{
-			m_fullScan = true;
-		}
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DaemonState::start: picked &quot; &lt;&lt; randomNum &lt;&lt; endl;
-#endif
-	}
-	m_isReindex = isReindex;
-
-	// Fire up the disk monitor thread
-	if (m_pDiskHandler == NULL)
-	{
-		OnDiskHandler *pDiskHandler = new OnDiskHandler();
-		pDiskHandler-&gt;getFileFoundSignal().connect(sigc::mem_fun(*this, &amp;DaemonState::on_message_filefound));
-		m_pDiskHandler = pDiskHandler;
-	}
-	MonitorThread *pDiskMonitorThread = new MonitorThread(m_pDiskMonitor, m_pDiskHandler);
-	start_thread(pDiskMonitorThread, true);
-
-	for (set&lt;PinotSettings::IndexableLocation&gt;::const_iterator locationIter = PinotSettings::getInstance().m_indexableLocations.begin();
-		locationIter != PinotSettings::getInstance().m_indexableLocations.end(); ++locationIter)
-	{
-		m_crawlQueue.push(*locationIter);
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;DaemonState::start: &quot; &lt;&lt; m_crawlQueue.size() &lt;&lt; &quot; locations to crawl&quot; &lt;&lt; endl;
-#endif
-
-	if (m_fullScan == true)
-	{
-		CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-
-		// Update all items status so that we can get rid of files from deleted sources
-		crawlHistory.updateItemsStatus(CrawlHistory::TO_CRAWL, 0, true);
-	}
-
-	// Initiate crawling
-	start_crawling();
-}
-
-void DaemonState::reload(void)
-{
-	// Reload whenever possible
-	m_reload = true;
-}
-
-void DaemonState::start_crawling(void)
-{
-	if (write_lock_lists() == true)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DaemonState::start_crawling: &quot; &lt;&lt; m_crawlQueue.size() &lt;&lt; &quot; locations to crawl, &quot;
-			&lt;&lt; m_crawlers &lt;&lt; &quot; crawlers&quot; &lt;&lt; endl;
-#endif
-		// Get the next location, unless something is still being crawled
-		if (m_crawlers == 0)
-		{
-			reset_flag(CRAWLING);
-
-			if (m_crawlQueue.empty() == false)
-			{
-				PinotSettings::IndexableLocation nextLocation(m_crawlQueue.front());
-
-				crawl_location(nextLocation);
-			}
-			else if (m_fullScan == true)
-			{
-				CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-				set&lt;string&gt; deletedFiles;
-
-				// All files left with status TO_CRAWL belong to deleted sources
-				if ((m_pDiskHandler != NULL) &amp;&amp;
-					(crawlHistory.getItems(CrawlHistory::TO_CRAWL, deletedFiles) &gt; 0))
-				{
-#ifdef DEBUG
-					cout &lt;&lt; &quot;DaemonState::start_crawling: &quot; &lt;&lt; deletedFiles.size() &lt;&lt; &quot; orphaned files&quot; &lt;&lt; endl;
-#endif
-					for(set&lt;string&gt;::const_iterator fileIter = deletedFiles.begin();
-						fileIter != deletedFiles.end(); ++fileIter)
-					{
-						// Inform the MonitorHandler
-						m_pDiskHandler-&gt;fileDeleted(fileIter-&gt;substr(7));
-
-						// Delete this item
-						crawlHistory.deleteItem(*fileIter);
-					}
-				}
-			}
-		}
-
-		unlock_lists();
-	}
-
-}
-
-void DaemonState::stop_crawling(void)
-{
-	if (write_lock_threads() == true)
-	{
-		if (m_threads.empty() == false)
-		{
-			// Stop all DirectoryScanner threads
-			for_each(m_threads.begin(), m_threads.end(), StopScannerThreadFunc());
-		}
-
-		unlock_threads();
-	}
-}
-
-void DaemonState::on_thread_end(WorkerThread *pThread)
-{
-	string indexedUrl;
-
-	if (pThread == NULL)
-	{
-		return;
-	}
-
-	string type(pThread-&gt;getType());
-	bool isStopped = pThread-&gt;isStopped();
-#ifdef DEBUG
-	cout &lt;&lt; &quot;DaemonState::on_thread_end: end of thread &quot; &lt;&lt; type &lt;&lt; &quot; &quot; &lt;&lt; pThread-&gt;getId() &lt;&lt; endl;
-#endif
-
-	// What type of thread was it ?
-	if (type == &quot;DirectoryScannerThread&quot;)
-	{
-		DirectoryScannerThread *pScannerThread = dynamic_cast&lt;DirectoryScannerThread *&gt;(pThread);
-		if (pScannerThread == NULL)
-		{
-			delete pThread;
-			return;
-		}
-		--m_crawlers;
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DaemonState::on_thread_end: done crawling &quot; &lt;&lt; pScannerThread-&gt;getDirectory() &lt;&lt; endl;
-#endif
-
-		// Explicitely flush the index once a directory has been crawled
-		IndexInterface *pIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
-		if (pIndex != NULL)
-		{
-			pIndex-&gt;flush();
-
-			delete pIndex;
-		}
-
-		if (isStopped == false)
-		{
-			// Pop the queue
-			m_crawlQueue.pop();
-		}
-		// Else, the directory wasn't fully crawled so better leave it in the queue
-
-		start_crawling();
-	}
-	else if (type == &quot;IndexingThread&quot;)
-	{
-		IndexingThread *pIndexThread = dynamic_cast&lt;IndexingThread *&gt;(pThread);
-		if (pIndexThread == NULL)
-		{
-			delete pThread;
-			return;
-		}
-
-		// Get the URL we have just indexed
-		indexedUrl = pIndexThread-&gt;getURL();
-
-		// Did it fail ?
-		int errorNum = pThread-&gt;getErrorNum();
-		if ((errorNum &gt; 0) &amp;&amp;
-			(indexedUrl.empty() == false))
-		{
-			CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-
-			// An entry should already exist for this
-			crawlHistory.updateItem(indexedUrl, CrawlHistory::CRAWL_ERROR, time(NULL), errorNum);
-		}
-	}
-	else if (type == &quot;UnindexingThread&quot;)
-	{
-		// FIXME: anything to do ?
-	}
-	else if (type == &quot;MonitorThread&quot;)
-	{
-		// FIXME: do something about this
-	}
-#ifdef HAVE_DBUS
-	else if (type == &quot;DBusServletThread&quot;)
-	{
-		DBusServletThread *pDBusThread = dynamic_cast&lt;DBusServletThread *&gt;(pThread);
-		if (pDBusThread == NULL)
-		{
-			delete pThread;
-			return;
-		}
-
-		// Send the reply ?
-		DBusServletInfo *pInfo = pDBusThread-&gt;getServletInfo();
-		if (pInfo != NULL)
-		{
-			if (pInfo-&gt;m_pThread != NULL)
-			{
-				m_servletsInfo.insert(pInfo);
-
-				start_thread(pInfo-&gt;m_pThread);
-			}
-			else
-			{
-				pInfo-&gt;reply();
-
-				delete pInfo;
-			}
-		}
-
-		if (pDBusThread-&gt;mustQuit() == true)
-		{
-			// Disconnect the timeout signal
-			if (m_timeoutConnection.connected() == true)
-			{
-				m_timeoutConnection.block();
-				m_timeoutConnection.disconnect();
-			}
-			m_signalQuit(0);
-		}
-	}
-#endif
-	else if (type == &quot;QueryingThread&quot;)
-	{
-		QueryingThread *pQueryThread = dynamic_cast&lt;QueryingThread *&gt;(pThread);
-		if (pQueryThread == NULL)
-		{
-			delete pThread;
-			return;
-		}
-
-		bool wasCorrected = false;
-		QueryProperties queryProps(pQueryThread-&gt;getQuery(wasCorrected));
-		const vector&lt;DocumentInfo&gt; &amp;resultsList = pQueryThread-&gt;getDocuments();
-
-#ifdef HAVE_DBUS
-		// Find the servlet info
-		for (set&lt;DBusServletInfo *&gt;::const_iterator servIter = m_servletsInfo.begin();
-			servIter != m_servletsInfo.end(); ++servIter)
-		{
-			DBusServletInfo *pInfo = const_cast&lt;DBusServletInfo *&gt;(*servIter);
-
-			if ((pInfo != NULL) &amp;&amp;
-				(pInfo-&gt;m_pThread-&gt;getId() == pThread-&gt;getId()))
-			{
-#ifdef DEBUG
-				cout &lt;&lt; &quot;DaemonState::on_thread_end: ran query &quot; &lt;&lt; queryProps.getName() &lt;&lt; endl;
-#endif
-				// Prepare and send the reply
-				pInfo-&gt;newQueryReply(resultsList, pQueryThread-&gt;getDocumentsCount());
-				pInfo-&gt;reply();
-
-				m_servletsInfo.erase(servIter);
-				delete pInfo;
-
-				break;
-			}
-		}
-#endif
-	}
-
-	// Delete the thread
-	delete pThread;
-
-	// Are we supposed to reload the configuration ?
-	// Wait until there are no threads running (except background ones)
-	if ((m_reload == true) &amp;&amp;
-		(get_threads_count() == 0))
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DaemonState::on_thread_end: stopping all threads&quot; &lt;&lt; endl;
-#endif
-		// Stop background threads
-		stop_threads();
-		// ...clear the queues
-		clear_queues();
-
-		// Reload
-		PinotSettings &amp;settings = PinotSettings::getInstance();
-		settings.clear();
-		settings.load(PinotSettings::LOAD_ALL);
-		m_reload = false;
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DaemonState::on_thread_end: reloading&quot; &lt;&lt; endl;
-#endif
-
-		// ...and restart everything 
-		start(true, false);
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;DaemonState::on_thread_end: reload status &quot; &lt;&lt; m_reload &lt;&lt; endl;
-#endif
-
-	// Try to run a queued action unless threads were stopped
-	if (isStopped == false)
-	{
-		pop_queue(indexedUrl);
-	}
-}
-
-void DaemonState::on_message_filefound(DocumentInfo docInfo, bool isDirectory)
-{
-	if (isDirectory == false)
-	{
-		queue_index(docInfo);
-	}
-	else
-	{
-		PinotSettings::IndexableLocation newLocation;
-
-		newLocation.m_monitor = true;
-		newLocation.m_name = docInfo.getLocation().substr(7);
-		newLocation.m_isSource = false;
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DaemonState::on_message_filefound: new directory &quot; &lt;&lt; newLocation.m_name &lt;&lt; endl;
-#endif
-
-		// Queue this directory for crawling
-		m_crawlQueue.push(newLocation);
-		start_crawling();
-	}
-}
-
-sigc::signal1&lt;void, int&gt;&amp; DaemonState::getQuitSignal(void)
-{
-	return m_signalQuit;
-}
-
-void DaemonState::set_flag(StatusFlag flag)
-{
-	FD_SET((int)flag, &amp;m_flagsSet);
-}
-
-bool DaemonState::is_flag_set(StatusFlag flag)
-{
-	if (FD_ISSET((int)flag, &amp;m_flagsSet))
-	{
-		return true;
-	}
-
-	return false;
-}
-
-void DaemonState::reset_flag(StatusFlag flag)
-{
-	FD_CLR((int)flag, &amp;m_flagsSet);
-}
-

Deleted: trunk/UI/GTK2/src/DaemonState.h
===================================================================
--- trunk/UI/GTK2/src/DaemonState.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/DaemonState.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,126 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _DAEMONSTATE_HH
-#define _DAEMONSTATE_HH
-
-#include &lt;sys/select.h&gt;
-#include &lt;string&gt;
-#include &lt;queue&gt;
-#include &lt;set&gt;
-#ifdef HAVE_DBUS
-extern &quot;C&quot;
-{
-#if DBUS_VERSION &lt; 1000000
-#define DBUS_API_SUBJECT_TO_CHANGE
-#endif
-#include &lt;dbus/dbus.h&gt;
-#include &lt;dbus/dbus-glib.h&gt;
-#include &lt;dbus/dbus-glib-lowlevel.h&gt;
-}
-#endif
-#include &lt;sigc++/sigc++.h&gt;
-
-#include &quot;MonitorInterface.h&quot;
-#include &quot;MonitorHandler.h&quot;
-#include &quot;PinotSettings.h&quot;
-#include &quot;WorkerThreads.h&quot;
-
-#ifdef HAVE_DBUS
-class DBusServletInfo
-{
-	public:
-		DBusServletInfo(DBusConnection *pConnection, DBusMessage *pRequest);
-		~DBusServletInfo();
-
-		bool newReply(void);
-
-		bool newErrorReply(const std::string &amp;name, const std::string &amp;message);
-
-		bool newReplyWithArray(void);
-
-		bool newQueryReply(const vector&lt;DocumentInfo&gt; &amp;resultsList,
-			unsigned int resultsEstimate);
-
-		bool reply(void);
-
-		DBusConnection *m_pConnection;
-		DBusMessage *m_pRequest;
-		DBusMessage *m_pReply;
-		GPtrArray *m_pArray;
-		bool m_simpleQuery;
-		WorkerThread *m_pThread;
-
-	protected:
-		bool m_replied;
-
-};
-#endif
-
-class DaemonState : public ThreadsManager
-{
-	public:
-		DaemonState();
-		virtual ~DaemonState();
-
-		typedef enum { LOW_DISK_SPACE = 0, ON_BATTERY, CRAWLING, STOPPED, DISCONNECTED } StatusFlag;
-
-		void start(bool forceFullScan, bool isReindex);
-
-		void reload(void);
-
-		void start_crawling(void);
-
-		void stop_crawling(void);
-
-		void on_thread_end(WorkerThread *pThread);
-
-		void on_message_filefound(DocumentInfo docInfo, bool isDirectory);
-
-		sigc::signal1&lt;void, int&gt;&amp; getQuitSignal(void);
-
-		void set_flag(StatusFlag flag);
-
-		bool is_flag_set(StatusFlag flag);
-
-		void reset_flag(StatusFlag flag);
-
-	protected:
-		bool m_fullScan;
-		bool m_isReindex;
-		bool m_reload;
-		fd_set m_flagsSet;
-		MonitorInterface *m_pDiskMonitor;
-		MonitorHandler *m_pDiskHandler;
-		sigc::connection m_timeoutConnection;
-		sigc::signal1&lt;void, int&gt; m_signalQuit;
-		unsigned int m_crawlers;
-		std::queue&lt;PinotSettings::IndexableLocation&gt; m_crawlQueue;
-#ifdef HAVE_DBUS
-		std::set&lt;DBusServletInfo *&gt; m_servletsInfo;
-#endif
-
-		bool on_activity_timeout(void);
-
-		void check_battery_state(void);
-
-		bool crawl_location(const PinotSettings::IndexableLocation &amp;location);
-
-};
-
-#endif // _DAEMONSTATE_HH

Modified: trunk/UI/GTK2/src/Makefile.am
===================================================================
--- trunk/UI/GTK2/src/Makefile.am	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/Makefile.am	2009-02-01 11:04:31 UTC (rev 1530)
@@ -17,18 +17,11 @@
 	queryDialog.hh \
 	statisticsDialog_glade.hh \
 	statisticsDialog.hh \
-	DaemonState.h \
 	EnginesTree.h \
 	IndexPage.h \
 	ModelColumns.h \
 	Notebook.h \
-	OnDiskHandler.h \
-	PinotSettings.h \
-	PinotUtils.h \
-	ResultsTree.h \
-	ServerThreads.h \
-	UniqueApplication.h \
-	WorkerThreads.h
+	ResultsTree.h
 
 pinot_SOURCES = \
 	pinot.cc \
@@ -52,25 +45,9 @@
 	IndexPage.cpp \
 	ModelColumns.cpp \
 	Notebook.cpp \
-	PinotSettings.cpp \
-	PinotUtils.cpp \
-	ResultsTree.cpp \
-	WorkerThreads.cpp
+	ResultsTree.cpp
 
-pinot_dbus_daemon_SOURCES = \
-	pinot-dbus-daemon.cc \
-	DaemonState.cpp \
-	OnDiskHandler.cpp \
-	PinotSettings.cpp \
-	ServerThreads.cpp \
-	UniqueApplication.cpp \
-	WorkerThreads.cpp
-
-if HAVE_DBUS
-bin_PROGRAMS = pinot pinot-dbus-daemon
-else
 bin_PROGRAMS = pinot
-endif
 
 AM_CXXFLAGS = \
 	@MISC_CFLAGS@ \
@@ -81,6 +58,7 @@
 	-I$(top_srcdir)/Monitor \
 	-I$(top_srcdir)/Collect \
 	-I$(top_srcdir)/IndexSearch \
+	-I$(top_srcdir)/Core \
 	@SQL_CFLAGS@ @HTTP_CFLAGS@ @XML_CFLAGS@ @DBUS_CFLAGS@ \
 	@INDEX_CFLAGS@ @GTHREAD_CFLAGS@ @GTKMM_CFLAGS@
 
@@ -98,23 +76,9 @@
 	-L$(top_builddir)/Monitor \
 	-L$(top_builddir)/Collect \
 	-L$(top_builddir)/IndexSearch \
-	-lIndexSearch -lMonitor -lCollect -lSQL \
+	-L$(top_srcdir)/Core \
+	-lCore -lIndexSearch -lMonitor -lCollect -lSQL \
 	-lTokenize -lUtils -lBasicUtils @LIBS@ \
 	@GTKMM_LIBS@ @DBUS_LIBS@ @GTHREAD_LIBS@ @XML_LIBS@ \
 	@HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
 
-pinot_dbus_daemon_LDFLAGS = \
-	-rdynamic
-
-pinot_dbus_daemon_LDADD = \
-	-L$(top_builddir)/Utils \
-	-L$(top_builddir)/Tokenize \
-	-L$(top_builddir)/SQL \
-	-L$(top_builddir)/Monitor \
-	-L$(top_builddir)/Collect \
-	-L$(top_builddir)/IndexSearch \
-	-lIndexSearch -lMonitor -lCollect -lSQL \
-	-lTokenize -lUtils -lBasicUtils @LIBS@ \
-	@GLIBMM_LIBS@ @DBUS_LIBS@ @GTHREAD_LIBS@ @XML_LIBS@ \
-	@HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
-

Deleted: trunk/UI/GTK2/src/OnDiskHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/OnDiskHandler.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,422 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;fcntl.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;time.h&gt;
-#include &lt;set&gt;
-#include &lt;iostream&gt;
-#include &lt;fstream&gt;
-#include &lt;sstream&gt;
-
-#include &quot;config.h&quot;
-#include &quot;NLS.h&quot;
-#include &quot;MIMEScanner.h&quot;
-#include &quot;StringManip.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;FilterWrapper.h&quot;
-#include &quot;PinotSettings.h&quot;
-#include &quot;OnDiskHandler.h&quot;
-
-using namespace std;
-
-OnDiskHandler::OnDiskHandler() :
-	MonitorHandler(),
-	m_history(PinotSettings::getInstance().getHistoryDatabaseName()),
-	m_metaData(PinotSettings::getInstance().getHistoryDatabaseName()),
-	m_pIndex(PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation))
-{
-	pthread_mutex_init(&amp;m_mutex, NULL);
-}
-
-OnDiskHandler::~OnDiskHandler()
-{
-	pthread_mutex_destroy(&amp;m_mutex);
-
-	// Disconnect the signal
-	sigc::signal2&lt;void, DocumentInfo, bool&gt;::slot_list_type slotsList = m_signalFileFound.slots();
-	sigc::signal2&lt;void, DocumentInfo, bool&gt;::slot_list_type::iterator slotIter = slotsList.begin();
-	if (slotIter != slotsList.end())
-	{
-		if (slotIter-&gt;empty() == false)
-		{
-			slotIter-&gt;block();
-			slotIter-&gt;disconnect();
-		}
-	}
-
-	if (m_pIndex != NULL)
-	{
-		delete m_pIndex;
-	}
-}
-
-bool OnDiskHandler::fileMoved(const string &amp;fileName, const string &amp;previousFileName,
-	IndexInterface::NameType type)
-{
-	set&lt;unsigned int&gt; docIdList;
-	bool handledEvent = false;
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;OnDiskHandler::fileMoved: &quot; &lt;&lt; fileName &lt;&lt; endl;
-#endif
-	if (m_pIndex == NULL)
-	{
-		return false;
-	}
-
-	pthread_mutex_lock(&amp;m_mutex);
-	// Get a list of documents in that directory/file
-	if (type == IndexInterface::BY_FILE)
-	{
-		m_pIndex-&gt;listDocuments(string(&quot;<A HREF="file://">file://</A>&quot;) + previousFileName, docIdList, type);
-	}
-	else
-	{
-		m_pIndex-&gt;listDocuments(previousFileName, docIdList, type);
-	}
-	// ...and the directory/file itself
-	unsigned int baseDocId = m_pIndex-&gt;hasDocument(string(&quot;<A HREF="file://">file://</A>&quot;) + previousFileName);
-	if (baseDocId &gt; 0)
-	{
-		docIdList.insert(baseDocId);
-	}
-	if (docIdList.empty() == false)
-	{
-		for (set&lt;unsigned int&gt;::const_iterator iter = docIdList.begin();
-			iter != docIdList.end(); ++iter)
-		{
-			DocumentInfo docInfo;
-
-#ifdef DEBUG
-			cout &lt;&lt; &quot;OnDiskHandler::fileMoved: moving &quot; &lt;&lt; *iter &lt;&lt; endl;
-#endif
-			if (m_pIndex-&gt;getDocumentInfo(*iter, docInfo) == true)
-			{
-				string newLocation(docInfo.getLocation());
-
-				if (baseDocId == *iter)
-				{
-					Url previousUrlObj(previousFileName), urlObj(fileName);
-
-					// Update the title if it was the directory/file name
-					if (docInfo.getTitle() == previousUrlObj.getFile())
-					{
-						docInfo.setTitle(urlObj.getFile());
-					}
-				}
-
-				string::size_type pos = newLocation.find(previousFileName);
-				if (pos != string::npos)
-				{
-					newLocation.replace(pos, previousFileName.length(), fileName);
-
-					// Change the location
-					docInfo.setLocation(newLocation);
-
-					handledEvent = replaceFile(*iter, docInfo);
-#ifdef DEBUG
-					cout &lt;&lt; &quot;OnDiskHandler::fileMoved: moved &quot; &lt;&lt; *iter &lt;&lt; &quot;, &quot; &lt;&lt; docInfo.getLocation() &lt;&lt; endl;
-#endif
-				}
-#ifdef DEBUG
-				else cout &lt;&lt; &quot;OnDiskHandler::fileMoved: skipping &quot; &lt;&lt; newLocation &lt;&lt; endl;
-#endif
-			}
-		}
-	}
-#ifdef DEBUG
-	else cout &lt;&lt; &quot;OnDiskHandler::fileMoved: no documents in &quot; &lt;&lt; previousFileName &lt;&lt; endl;
-#endif
-	pthread_mutex_unlock(&amp;m_mutex);
-
-	return handledEvent;
-}
-
-bool OnDiskHandler::fileDeleted(const string &amp;fileName, IndexInterface::NameType type)
-{
-	set&lt;unsigned int&gt; docIdList;
-	string location(string(&quot;<A HREF="file://">file://</A>&quot;) + fileName);
-	bool unindexedDocs = false, handledEvent = false;
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;OnDiskHandler::fileDeleted: &quot; &lt;&lt; fileName &lt;&lt; endl;
-#endif
-	if (m_pIndex == NULL)
-	{
-		return false;
-	}
-
-	pthread_mutex_lock(&amp;m_mutex);
-	// Unindex all of the directory/file's documents
-	if (type == IndexInterface::BY_FILE)
-	{
-		unindexedDocs = m_pIndex-&gt;unindexDocuments(location, type);
-	}
-	else
-	{
-		unindexedDocs = m_pIndex-&gt;unindexDocuments(fileName, type);
-	}
-	if (unindexedDocs == true)
-	{
-		// ...as well as the actual directory/file
-		m_pIndex-&gt;unindexDocument(location);
-
-		m_history.deleteItems(location);
-		handledEvent = true;
-	}
-	pthread_mutex_unlock(&amp;m_mutex);
-
-	return handledEvent;
-}
-
-bool OnDiskHandler::indexFile(const string &amp;fileName, bool isDirectory, unsigned int &amp;sourceId)
-{
-	string location(string(&quot;<A HREF="file://">file://</A>&quot;) + fileName);
-	Url urlObj(location);
-
-	if (fileName.empty() == true)
-	{
-		return false;
-	}
-
-	// Is it black-listed ?
-	if (PinotSettings::getInstance().isBlackListed(fileName) == true)
-	{
-		return false;
-	}
-
-	DocumentInfo docInfo(&quot;&quot;, location, MIMEScanner::scanUrl(urlObj), &quot;&quot;);
-
-	// What source does it belong to ?
-	for (map&lt;unsigned int, string&gt;::const_iterator sourceIter = m_fileSources.begin();
-		sourceIter != m_fileSources.end(); ++sourceIter)
-	{
-		sourceId = sourceIter-&gt;first;
-
-		if (sourceIter-&gt;second.length() &gt; location.length())
-		{
-			// Skip
-			continue;
-		}
-
-		if (location.substr(0, sourceIter-&gt;second.length()) == sourceIter-&gt;second)
-		{
-			set&lt;string&gt; labels;
-			stringstream labelStream;
-
-			// That's the one
-			labelStream &lt;&lt; &quot;X-SOURCE&quot; &lt;&lt; sourceIter-&gt;first;
-#ifdef DEBUG
-			cout &lt;&lt; &quot;OnDiskHandler::indexFile: source label for &quot; &lt;&lt; location &lt;&lt; &quot; is &quot; &lt;&lt; labelStream.str() &lt;&lt; endl;
-#endif
-			labels.insert(labelStream.str());
-			docInfo.setLabels(labels);
-			break;
-		}
-#ifdef DEBUG
-		else cout &lt;&lt; &quot;OnDiskHandler::indexFile: not &quot; &lt;&lt; sourceIter-&gt;second &lt;&lt; endl;
-#endif
-	}
-
-	m_metaData.getItem(docInfo, DocumentInfo::SERIAL_ALL);
-
-	m_signalFileFound(docInfo, isDirectory);
-
-	return true;
-}
-
-bool OnDiskHandler::replaceFile(unsigned int docId, DocumentInfo &amp;docInfo)
-{
-	if (m_pIndex == NULL)
-	{
-		return false;
-	}
-
-	// Unindex the destination file
-	FilterWrapper wrapFilter(m_pIndex);
-	wrapFilter.unindexDocument(docInfo.getLocation());
-
-	// Update the document info
-	return m_pIndex-&gt;updateDocumentInfo(docId, docInfo);
-}
-
-void OnDiskHandler::initialize(void)
-{
-	set&lt;string&gt; directories;
-
-	// Get the map of indexable locations
-	set&lt;PinotSettings::IndexableLocation&gt; &amp;indexableLocations = PinotSettings::getInstance().m_indexableLocations;
-	for (set&lt;PinotSettings::IndexableLocation&gt;::iterator dirIter = indexableLocations.begin();
-		dirIter != indexableLocations.end(); ++dirIter)
-	{
-		directories.insert(dirIter-&gt;m_name);
-	}
-
-	// Unindex documents that belong to sources that no longer exist
-	if (m_history.getSources(m_fileSources) &gt; 0)
-	{
-		for(map&lt;unsigned int, string&gt;::const_iterator sourceIter = m_fileSources.begin();
-			sourceIter != m_fileSources.end(); ++sourceIter)
-		{
-			unsigned int sourceId = sourceIter-&gt;first;
-
-			if (sourceIter-&gt;second.substr(0, 7) != &quot;<A HREF="file://">file://</A>&quot;)
-			{
-				// Skip
-				continue;
-			}
-
-			// Is this an indexable location ?
-			if (directories.find(sourceIter-&gt;second.substr(7)) == directories.end())
-			{
-				stringstream labelStream;
-
-				labelStream &lt;&lt; &quot;X-SOURCE&quot; &lt;&lt; sourceId;
-
-#ifdef DEBUG
-				cout &lt;&lt; &quot;OnDiskHandler::initialize: &quot; &lt;&lt; sourceIter-&gt;second
-					&lt;&lt; &quot;, source &quot; &lt;&lt; sourceId &lt;&lt; &quot; was removed&quot; &lt;&lt; endl;
-#endif
-				// All documents with this label will be unindexed
-				if ((m_pIndex != NULL) &amp;&amp;
-					(m_pIndex-&gt;unindexDocuments(labelStream.str(), IndexInterface::BY_LABEL) == true))
-				{
-					// Delete the source itself and all its items
-					m_history.deleteSource(sourceId);
-					m_history.deleteItems(sourceId);
-				}
-			}
-#ifdef DEBUG
-			else cout &lt;&lt; &quot;OnDiskHandler::initialize: &quot; &lt;&lt; sourceIter-&gt;second
-				&lt;&lt; &quot; is still configured&quot; &lt;&lt; endl;
-#endif
-		}
-	}
-}
-
-void OnDiskHandler::flushIndex(void)
-{
-	pthread_mutex_lock(&amp;m_mutex);
-	if (m_pIndex != NULL)
-	{
-		m_pIndex-&gt;flush();
-	}
-	pthread_mutex_unlock(&amp;m_mutex);
-}
-
-bool OnDiskHandler::fileExists(const string &amp;fileName)
-{
-	// Nothing to do here
-	return true;
-}
-
-bool OnDiskHandler::fileCreated(const string &amp;fileName)
-{
-	unsigned int sourceId;
-	bool handledEvent = false;
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;OnDiskHandler::fileCreated: &quot; &lt;&lt; fileName &lt;&lt; endl;
-#endif
-	pthread_mutex_lock(&amp;m_mutex);
-	// The file may exist in the index
-	handledEvent = indexFile(fileName, false, sourceId);
-	if (handledEvent == true)
-	{
-	        string location(&quot;<A HREF="file://">file://</A>&quot; + fileName);
-		CrawlHistory::CrawlStatus status = CrawlHistory::UNKNOWN;
-	        time_t itemDate;
-
-		// ...and therefore may exist in the history database
-		if (m_history.hasItem(location, status, itemDate) == true)
-		{
-			m_history.updateItem(location, CrawlHistory::CRAWLED, time(NULL));
-		}
-		else
-		{
-			m_history.insertItem(location, CrawlHistory::CRAWLED, sourceId, time(NULL));
-		}
-	}
-	pthread_mutex_unlock(&amp;m_mutex);
-
-	return handledEvent;
-}
-
-bool OnDiskHandler::directoryCreated(const string &amp;dirName)
-{
-	unsigned int sourceId;
-	bool handledEvent = false;
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;OnDiskHandler::directoryCreated: &quot; &lt;&lt; dirName &lt;&lt; endl;
-#endif
-	pthread_mutex_lock(&amp;m_mutex);
-	handledEvent = indexFile(dirName, true, sourceId);
-	// History will be set by crawling
-	pthread_mutex_unlock(&amp;m_mutex);
-
-	return handledEvent;
-}
-
-bool OnDiskHandler::fileModified(const string &amp;fileName)
-{
-	unsigned int sourceId;
-	bool handledEvent = false;
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;OnDiskHandler::fileModified: &quot; &lt;&lt; fileName &lt;&lt; endl;
-#endif
-	pthread_mutex_lock(&amp;m_mutex);
-	// Update the file, or index if necessary
-	handledEvent = indexFile(fileName, false, sourceId);
-	if (handledEvent == true)
-	{
-		m_history.updateItem(&quot;<A HREF="file://">file://</A>&quot; + fileName, CrawlHistory::CRAWLED, time(NULL));
-	}
-	pthread_mutex_unlock(&amp;m_mutex);
-
-	return handledEvent;
-}
-
-bool OnDiskHandler::fileMoved(const string &amp;fileName, const string &amp;previousFileName)
-{
-	return fileMoved(fileName, previousFileName, IndexInterface::BY_FILE);
-}
-
-bool OnDiskHandler::directoryMoved(const string &amp;dirName,
-	const string &amp;previousDirName)
-{
-	return fileMoved(dirName, previousDirName, IndexInterface::BY_DIRECTORY);
-}
-
-bool OnDiskHandler::fileDeleted(const string &amp;fileName)
-{
-	return fileDeleted(fileName, IndexInterface::BY_FILE);
-}
-
-bool OnDiskHandler::directoryDeleted(const string &amp;dirName)
-{
-	return fileDeleted(dirName, IndexInterface::BY_DIRECTORY);
-}
-
-sigc::signal2&lt;void, DocumentInfo, bool&gt;&amp; OnDiskHandler::getFileFoundSignal(void)
-{
-	return m_signalFileFound;
-}
-

Deleted: trunk/UI/GTK2/src/OnDiskHandler.h
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/OnDiskHandler.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,98 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
- 
-#ifndef _ONDISKHANDLER_HH
-#define _ONDISKHANDLER_HH
-
-#include &lt;time.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;string&gt;
-#include &lt;map&gt;
-#include &lt;sigc++/sigc++.h&gt;
-
-#include &quot;CrawlHistory.h&quot;
-#include &quot;MetaDataBackup.h&quot;
-#include &quot;IndexInterface.h&quot;
-#include &quot;MonitorHandler.h&quot;
-#include &quot;PinotSettings.h&quot;
-
-class OnDiskHandler : public MonitorHandler
-{
-	public:
-		OnDiskHandler();
-		virtual ~OnDiskHandler();
-
-		/// Initializes things before starting monitoring.
-		virtual void initialize(void);
-
-		/// Handles flushing the index.
-		virtual void flushIndex(void);
-
-		/// Handles file existence events.
-		virtual bool fileExists(const std::string &amp;fileName);
-
-		/// Handles file creation events.
-		virtual bool fileCreated(const std::string &amp;fileName);
-
-		/// Handles directory creation events.
-		virtual bool directoryCreated(const std::string &amp;dirName);
-
-		/// Handles file modified events.
-		virtual bool fileModified(const std::string &amp;fileName);
-
-		/// Handles file moved events.
-		virtual bool fileMoved(const std::string &amp;fileName,
-			const std::string &amp;previousFileName);
-
-		/// Handles directory moved events.
-		virtual bool directoryMoved(const std::string &amp;dirName,
-			const std::string &amp;previousDirName);
-
-		/// Handles file deleted events.
-		virtual bool fileDeleted(const std::string &amp;fileName);
-
-		/// Handles directory deleted events.
-		virtual bool directoryDeleted(const std::string &amp;dirName);
-
-		sigc::signal2&lt;void, DocumentInfo, bool&gt;&amp; getFileFoundSignal(void);
-
-	protected:
-		pthread_mutex_t m_mutex;
-		sigc::signal2&lt;void, DocumentInfo, bool&gt; m_signalFileFound;
-		std::map&lt;unsigned int, std::string&gt; m_fileSources;
-		CrawlHistory m_history;
-		MetaDataBackup m_metaData;
-		IndexInterface *m_pIndex;
-
-		bool fileMoved(const std::string &amp;fileName,
-			const std::string &amp;previousFileName,
-			IndexInterface::NameType type);
-
-		bool fileDeleted(const std::string &amp;fileName, IndexInterface::NameType type);
-
-		bool indexFile(const std::string &amp;fileName, bool isDirectory, unsigned int &amp;sourceId);
-
-		bool replaceFile(unsigned int docId, DocumentInfo &amp;docInfo);
-
-	private:
-		OnDiskHandler(const OnDiskHandler &amp;other);
-		OnDiskHandler &amp;operator=(const OnDiskHandler &amp;other);
-
-};
-
-#endif // _ONDISKHANDLER_HH

Deleted: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,2170 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &quot;config.h&quot;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;ctype.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;string.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;dirent.h&gt;
-#ifdef HAVE_PWD_H
-#include &lt;pwd.h&gt;
-#endif
-#ifdef HAVE_FNMATCH_H
-#include &lt;fnmatch.h&gt;
-#endif
-#include &lt;algorithm&gt;
-#include &lt;iostream&gt;
-
-#include &lt;glibmm/convert.h&gt;
-#include &lt;glibmm/date.h&gt;
-#include &lt;libxml++/parsers/domparser.h&gt;
-#include &lt;libxml++/nodes/node.h&gt;
-#include &lt;libxml++/nodes/textnode.h&gt;
-
-#include &quot;NLS.h&quot;
-#include &quot;CommandLine.h&quot;
-#include &quot;Languages.h&quot;
-#include &quot;StringManip.h&quot;
-#include &quot;ModuleFactory.h&quot;
-#include &quot;PluginWebEngine.h&quot;
-#include &quot;PinotSettings.h&quot;
-
-using namespace std;
-using namespace Glib;
-using namespace xmlpp;
-
-static string getElementContent(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return &quot;&quot;;
-	}
-
-#ifdef HAS_LIBXMLPP026
-	const TextNode *pText = pElem-&gt;get_child_content();
-#else
-	const TextNode *pText = pElem-&gt;get_child_text();
-#endif
-	if (pText == NULL)
-	{
-		return &quot;&quot;;
-	}
-
-	return pText-&gt;get_content();
-}
-
-static Element *addChildElement(Element *pElem, const string &amp;nodeName, const string &amp;nodeContent)
-{
-	if (pElem == NULL)
-	{
-		return NULL;
-	}
-
-	Element *pSubElem = pElem-&gt;add_child(nodeName);
-	if (pSubElem != NULL)
-	{
-#ifdef HAS_LIBXMLPP026
-		pSubElem-&gt;set_child_content(nodeContent);
-#else
-		pSubElem-&gt;set_child_text(nodeContent);
-#endif
-	}
-
-	return pSubElem;
-}
-
-PinotSettings PinotSettings::m_instance;
-bool PinotSettings::m_clientMode = false;
-
-PinotSettings::PinotSettings() :
-	m_warnAboutVersion(false),
-	m_defaultBackend(&quot;xapian&quot;),
-	m_minimumDiskSpace(50),
-	m_xPos(0),
-	m_yPos(0),
-	m_width(0),
-	m_height(0),
-	m_panePos(-1),
-	m_showEngines(false),
-	m_expandQueries(false),
-	m_ignoreRobotsDirectives(false),
-	m_suggestQueryTerms(true),
-	m_newResultsColourRed(65535),
-	m_newResultsColourGreen(0),
-	m_newResultsColourBlue(0),
-	m_proxyPort(8080),
-	m_proxyEnabled(false),
-	m_isBlackList(true),
-	m_firstRun(false),
-	m_indexCount(0)
-{
-	string directoryName(getConfigurationDirectory());
-	struct stat fileStat;
-
-	// Find out if there is a .pinot directory
-	if (stat(directoryName.c_str(), &amp;fileStat) != 0)
-	{
-		// No, create it then
-#ifdef WIN32
-		if (mkdir(directoryName.c_str()) == 0)
-#else
-		if (mkdir(directoryName.c_str(), (mode_t)S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IWGRP|S_IXGRP|S_IROTH|S_IXOTH) == 0)
-#endif
-		{
-			cerr &lt;&lt; &quot;Created directory &quot; &lt;&lt; directoryName &lt;&lt; endl;
-			m_firstRun = true;
-		}
-		else
-		{
-			cerr &lt;&lt; &quot;Couldn't create pinot directory at &quot;
-				&lt;&lt; directoryName &lt;&lt; endl;
-		}
-	}
-
-	// This is where the internal indices live
-	m_docsIndexLocation = directoryName;
-	m_docsIndexLocation += &quot;/index&quot;;
-	m_daemonIndexLocation = directoryName;
-	m_daemonIndexLocation += &quot;/daemon&quot;;
-
-	// This is not set in the settings files
-	char *pEnvVar = getenv(&quot;PINOT_MINIMUM_DISK_SPACE&quot;);
-	if ((pEnvVar != NULL) &amp;&amp;
-		(strlen(pEnvVar) &gt; 0))
-	{
-		m_minimumDiskSpace = atof(pEnvVar);
-	}
-}
-
-PinotSettings::~PinotSettings()
-{
-}
-
-PinotSettings &amp;PinotSettings::getInstance(void)
-{
-	return m_instance;
-}
-
-bool PinotSettings::enableClientMode(bool enable)
-{
-	bool isEnabled = m_clientMode;
-
-	m_clientMode = enable;
-
-	return isEnabled;
-}
-
-string PinotSettings::getHomeDirectory(void)
-{
-#ifdef HAVE_PWD_H
-	struct passwd *pPasswd = getpwuid(geteuid());
-
-	if ((pPasswd != NULL) &amp;&amp;
-		(pPasswd-&gt;pw_dir != NULL))
-	{
-		return pPasswd-&gt;pw_dir;
-	}
-	else
-	{
-#endif
-		char *homeDir = getenv(&quot;HOME&quot;);
-		if (homeDir != NULL)
-		{
-			return homeDir;
-		}
-#ifdef HAVE_PWD_H
-	}
-
-	return &quot;~&quot;;
-#else
-
-	return &quot;.&quot;;
-#endif
-}
-
-string PinotSettings::getConfigurationDirectory(void)
-{
-	string directoryName(getHomeDirectory());
-
-	if (directoryName.empty() == true)
-	{
-		return &quot;~/.pinot&quot;;
-	}
-	directoryName += &quot;/.pinot&quot;;
-
-	return directoryName;
-}
-
-string PinotSettings::getFileName(bool prefsOrUI)
-{
-	string configFileName(getConfigurationDirectory());
-
-	if (prefsOrUI == true)
-	{
-		configFileName += &quot;/prefs.xml&quot;;
-	}
-	else
-	{
-		configFileName += &quot;/ui.xml&quot;;
-	}
-
-	return configFileName;
-}
-
-string PinotSettings::getCurrentUserName(void)
-{
-#ifdef HAVE_PWD_H
-	struct passwd *pPasswd = getpwuid(geteuid());
-
-	if ((pPasswd != NULL) &amp;&amp;
-		(pPasswd-&gt;pw_name != NULL))
-	{
-		return pPasswd-&gt;pw_name;
-	}
-#endif
-
-	return &quot;&quot;;
-}
-
-void PinotSettings::checkHistoryDatabase(void)
-{
-	string uiHistoryDatabase(getConfigurationDirectory());
-	string daemonHistoryDatabase(getConfigurationDirectory());
-	struct stat fileStat;
-
-	uiHistoryDatabase += &quot;/history&quot;;
-	daemonHistoryDatabase += &quot;/history-daemon&quot;;
-
-	// Copy the UI's over to the daemon's history if it doesn't exist
-	if ((stat(uiHistoryDatabase.c_str(), &amp;fileStat) == 0) &amp;&amp;
-		((stat(daemonHistoryDatabase.c_str(), &amp;fileStat) != 0) ||
-		(!S_ISREG(fileStat.st_mode))))
-	{
-		string output;
-
-		CommandLine::runSync(string(&quot;\\cp -f &quot;) + uiHistoryDatabase + &quot; &quot; + daemonHistoryDatabase, output);
-#ifdef DEBUG
-		cout &lt;&lt; &quot;PinotSettings::checkHistoryDatabase: &quot; &lt;&lt; output &lt;&lt; endl;
-#endif
-	}
-}
-
-string PinotSettings::getHistoryDatabaseName(bool needToQueryDaemonHistory)
-{
-	string historyDatabase(getConfigurationDirectory());
-
-	if ((m_clientMode == false) ||
-		(needToQueryDaemonHistory == true))
-	{
-		historyDatabase += &quot;/history-daemon&quot;;
-	}
-	else
-	{
-		historyDatabase += &quot;/history&quot;;
-	}
-
-	return historyDatabase;
-}
-
-bool PinotSettings::isFirstRun(void) const
-{
-	return m_firstRun;
-}
-
-void PinotSettings::clear(void)
-{
-	m_version.clear();
-	m_warnAboutVersion = false;
-	m_defaultBackend = &quot;xapian&quot;;
-	m_googleAPIKey.clear();
-	m_xPos = 0;
-	m_yPos = 0;
-	m_width = 0;
-	m_height = 0;
-	m_panePos = -1;
-	m_showEngines = false;
-	m_expandQueries = false;
-	m_ignoreRobotsDirectives = false;
-	m_suggestQueryTerms = true;
-	m_newResultsColourRed = 65535;
-	m_newResultsColourGreen = 0;
-	m_newResultsColourBlue = 0;
-	m_proxyAddress.clear();
-	m_proxyPort = 8080;
-	m_proxyType.clear();
-	m_proxyEnabled = false;
-	m_indexableLocations.clear();
-	m_filePatternsList.clear();
-	m_isBlackList = true;
-	m_editablePluginValues.clear();
-	m_cacheProviders.clear();
-	m_cacheProtocols.clear();
-
-	m_firstRun = false;
-	m_indexes.clear();
-	m_indexCount = 0;
-	m_engines.clear();
-	m_engineIds.clear();
-	m_engineChannels.clear();
-	m_queries.clear();
-	m_labels.clear();
-}
-
-bool PinotSettings::load(LoadWhat what)
-{
-	string fileName;
-	bool loadedUIConfiguration = false;
-
-	if ((what == LOAD_ALL) ||
-		(what == LOAD_GLOBAL))
-	{
-		fileName = string(SYSCONFDIR) + &quot;/pinot/globalconfig.xml&quot;;
-
-		if (loadConfiguration(fileName, true) == false)
-		{
-			return false;
-		}
-
-		if (what == LOAD_GLOBAL)
-		{
-			// Stop here
-			return true;
-		}
-	}
-
-	// Load settings ?
-	if (m_firstRun == false)
-	{
-		// Load 0.90 preferences first
-		if (loadConfiguration(getFileName(true), false) == false)
-		{
-			fileName = getConfigurationDirectory() + &quot;/config.xml&quot;;
-
-			// We may have to migrate away from a pre-0.90 configuration
-			clear();
-			if (loadConfiguration(fileName, false) == true)
-			{
-				// Save settings now to the new format
-				save(SAVE_PREFS);
-				save(SAVE_CONFIG);
-
-				cout &lt;&lt; &quot;Migrated settings to 0.90 format&quot; &lt;&lt; endl;
-			}
-			else
-			{
-				m_firstRun = true;
-			}
-		}
-		else
-		{
-			loadedUIConfiguration = loadConfiguration(getFileName(false), false);
-		}
-	}
-
-	if (what == LOAD_ALL)
-	{
-		// Load search engines
-		loadSearchEngines(string(PREFIX) + &quot;/share/pinot/engines&quot;);
-		loadSearchEngines(getConfigurationDirectory() + &quot;/engines&quot;);
-	}
-
-	map&lt;ModuleProperties, bool&gt; engines;
-	string currentUserChannel(&quot;X-Current-User-Channel&quot;);
-
-	// Some engines are available as back-ends
-	ModuleFactory::getSupportedEngines(engines);
-	for (map&lt;ModuleProperties, bool&gt;::const_iterator engineIter = engines.begin();
-		engineIter != engines.end(); ++engineIter)
-	{
-		if (engineIter-&gt;second == true)
-		{
-			string channelName(engineIter-&gt;first.m_channel);
-
-			m_engineIds[1 &lt;&lt; m_engines.size()] = engineIter-&gt;first.m_name;
-
-			// Is a channel specified ?
-			if (engineIter-&gt;first.m_channel.empty() == true)
-			{
-				ModuleProperties modProps(engineIter-&gt;first);
-
-				channelName = modProps.m_channel = currentUserChannel;
-
-#ifdef DEBUG
-				cout &lt;&lt; &quot;PinotSettings::load: no channel for back-end &quot; &lt;&lt; engineIter-&gt;first.m_name &lt;&lt; endl;
-#endif
-				m_engines.insert(modProps);
-			}
-			else
-			{
-				m_engines.insert(engineIter-&gt;first);
-			}
-
-			if (m_engineChannels.find(channelName) == m_engineChannels.end())
-			{
-				m_engineChannels.insert(pair&lt;string, bool&gt;(channelName, true));
-			}
-		}
-	}
-
-	// Internal indices
-	addIndex(_(&quot;My Web Pages&quot;), m_docsIndexLocation, true);
-	addIndex(_(&quot;My Documents&quot;), m_daemonIndexLocation, true);
-
-	if (loadedUIConfiguration == false)
-	{
-		// Add default labels
-		m_labels.insert(_(&quot;Important&quot;));
-		m_labels.insert(_(&quot;New&quot;));
-		m_labels.insert(_(&quot;Personal&quot;));
-		m_isBlackList = getDefaultPatterns(m_filePatternsList);
-
-		// Create default queries
-#ifdef HAVE_PWD_H
-		struct passwd *pPasswd = getpwuid(geteuid());
-		if (pPasswd != NULL)
-		{
-			string userName;
-
-			if ((pPasswd-&gt;pw_gecos != NULL) &amp;&amp;
-				(strlen(pPasswd-&gt;pw_gecos) &gt; 0))
-			{
-				userName = pPasswd-&gt;pw_gecos;
-			}
-			else if (pPasswd-&gt;pw_name != NULL)
-			{
-				userName = pPasswd-&gt;pw_name;
-			}
-
-			if (userName.empty() == false)
-			{
-				QueryProperties queryProps(_(&quot;Me&quot;), userName);
-
-				queryProps.setSortOrder(QueryProperties::DATE);
-				addQuery(queryProps);
-			}
-		}
-#endif
-
-		QueryProperties queryProps(_(&quot;Latest First&quot;), &quot;dir:/&quot;);
-		queryProps.setSortOrder(QueryProperties::DATE);
-		addQuery(queryProps);
-		addQuery(QueryProperties(_(&quot;Home Stuff&quot;), string(&quot;dir:&quot;) + getHomeDirectory()));
-		addQuery(QueryProperties(_(&quot;With Label New&quot;), &quot;label:New&quot;));
-		addQuery(QueryProperties(_(&quot;Have CJKV&quot;), &quot;tokens:CJKV&quot;));
-		addQuery(QueryProperties(_(&quot;In English&quot;), &quot;lang:en&quot;));
-		addQuery(QueryProperties(_(&quot;10kb And Smaller&quot;), &quot;0..10240b&quot;));
-		addQuery(QueryProperties(&quot;Pinot search&quot;, &quot;pinot search&quot;));
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadSearchEngines(const string &amp;directoryName)
-{
-	if (directoryName.empty() == true)
-	{
-		return true;
-	}
-
-	DIR *pDir = opendir(directoryName.c_str());
-	if (pDir == NULL)
-	{
-		return false;
-	}
-
-	// Iterate through this directory's entries
-	struct dirent *pDirEntry = readdir(pDir);
-	while (pDirEntry != NULL)
-	{
-		char *pEntryName = pDirEntry-&gt;d_name;
-		if (pEntryName != NULL)
-		{
-			struct stat fileStat;
-			string location = directoryName;
-			location += &quot;/&quot;;
-			location += pEntryName;
-
-			// Is that a file ?
-			if ((stat(location.c_str(), &amp;fileStat) == 0) &amp;&amp;
-				(S_ISREG(fileStat.st_mode)))
-			{
-				SearchPluginProperties properties;
-
-				if ((PluginWebEngine::getDetails(location, properties) == true) &amp;&amp;
-					(properties.m_name.empty() == false) &amp;&amp;
-					(properties.m_longName.empty() == false))
-				{
-					m_engineIds[1 &lt;&lt; m_engines.size()] = properties.m_longName;
-					if (properties.m_channel.empty() == true)
-					{
-						properties.m_channel = _(&quot;Unclassified&quot;);
-					}
-					// SearchPluginProperties derives ModuleProperties
-					m_engines.insert(properties);
-					if (m_engineChannels.find(properties.m_channel) == m_engineChannels.end())
-					{
-						m_engineChannels.insert(pair&lt;string, bool&gt;(properties.m_channel, true));
-					}
-
-					// Any editable parameters in this plugin ?
-					for (map&lt;string, string&gt;::const_iterator editableIter = properties.m_editableParameters.begin();
-						editableIter != properties.m_editableParameters.end(); ++editableIter)
-					{
-						// This may have been created when loading settings
-						if (m_editablePluginValues.find(editableIter-&gt;second) == m_editablePluginValues.end())
-						{
-							m_editablePluginValues[editableIter-&gt;second] = &quot;&quot;;
-						}
-					}
-#ifdef DEBUG
-					cout &lt;&lt; &quot;PinotSettings::loadSearchEngines: &quot; &lt;&lt; properties.m_name
-						&lt;&lt; &quot;, &quot; &lt;&lt; properties.m_longName &lt;&lt; &quot;, &quot; &lt;&lt; properties.m_option
-						&lt;&lt; &quot; has &quot; &lt;&lt; properties.m_editableParameters.size() &lt;&lt; &quot; editable values&quot; &lt;&lt; endl;
-#endif
-				}
-			}
-		}
-
-		// Next entry
-		pDirEntry = readdir(pDir);
-	}
-	closedir(pDir);
-
-	return true;
-}
-
-bool PinotSettings::loadConfiguration(const string &amp;fileName, bool isGlobal)
-{
-	struct stat fileStat;
-	bool success = true;
-
-	if ((stat(fileName.c_str(), &amp;fileStat) != 0) ||
-		(!S_ISREG(fileStat.st_mode)))
-	{
-		cerr &lt;&lt; &quot;Couldn't open settings file &quot; &lt;&lt; fileName &lt;&lt; endl;
-		return false;
-	}
-
-	try
-	{
-		// Parse the settings file
-		DomParser parser;
-		parser.set_substitute_entities(true);
-		parser.parse_file(fileName);
-		xmlpp::Document *pDocument = parser.get_document();
-		if (pDocument == NULL)
-		{
-			return false;
-		}
-
-		Element *pRootElem = pDocument-&gt;get_root_node();
-		if (pRootElem == NULL)
-		{
-			return false;
-		}
-
-		// Check the top-level element is what we expect
-		ustring rootNodeName = pRootElem-&gt;get_name();
-		if (rootNodeName != &quot;pinot&quot;)
-		{
-			return false;
-		}
-
-		// Go through the subnodes
-		const Node::NodeList childNodes = pRootElem-&gt;get_children();
-		if (childNodes.empty() == false)
-		{
-			for (Node::NodeList::const_iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-			{
-				Node *pNode = (*iter);
-				// All nodes should be elements
-				Element *pElem = dynamic_cast&lt;Element*&gt;(pNode);
-				if (pElem == NULL)
-				{
-					continue;
-				}
-
-				string nodeName(pElem-&gt;get_name());
-				string nodeContent(getElementContent(pElem));
-				if (isGlobal == true)
-				{
-					if (nodeName == &quot;cache&quot;)
-					{
-						loadCacheProviders(pElem);
-					}
-					else
-					{
-						// Unsupported element
-						continue;
-					}
-				}
-				else if (nodeName == &quot;version&quot;)
-				{
-					m_version = nodeContent;
-				}
-				else if (nodeName == &quot;warnaboutversion&quot;)
-				{
-					if (nodeContent == &quot;YES&quot;)
-					{
-						m_warnAboutVersion = true;
-					}
-					else
-					{
-						m_warnAboutVersion = false;
-					}
-				}
-				else if (nodeName == &quot;backend&quot;)
-				{
-					m_defaultBackend = nodeContent;
-				}
-				else if (nodeName == &quot;googleapikey&quot;)
-				{
-					m_googleAPIKey = nodeContent;
-				}
-				else if (nodeName == &quot;ui&quot;)
-				{
-					loadUi(pElem);
-				}
-				else if (nodeName == &quot;extraindex&quot;)
-				{
-					loadIndexes(pElem);
-				}
-				else if (nodeName == &quot;channel&quot;)
-				{
-					loadEngineChannels(pElem);
-				}
-				else if (nodeName == &quot;storedquery&quot;)
-				{
-					loadQueries(pElem);
-				}
-				else if (nodeName == &quot;label&quot;)
-				{
-					loadLabels(pElem);
-				}
-				else if (nodeName == &quot;robots&quot;)
-				{
-					if (nodeContent == &quot;IGNORE&quot;)
-					{
-						m_ignoreRobotsDirectives = true;
-					}
-					else
-					{
-						m_ignoreRobotsDirectives = false;
-					}
-				}
-				else if (nodeName == &quot;suggestterms&quot;)
-				{
-					if (nodeContent == &quot;YES&quot;)
-					{
-						m_suggestQueryTerms = true;
-					}
-					else
-					{
-						m_suggestQueryTerms = false;
-					}
-				}
-				else if (nodeName == &quot;newresults&quot;)
-				{
-					loadColour(pElem);
-				}
-				else if (nodeName == &quot;proxy&quot;)
-				{
-					loadProxy(pElem);
-				}
-				else if (nodeName == &quot;indexable&quot;)
-				{
-					loadIndexableLocations(pElem);
-				}
-				else if ((nodeName == &quot;blacklist&quot;) ||
-					(nodeName == &quot;patterns&quot;))
-				{
-					loadFilePatterns(pElem);
-				}
-				else if (nodeName == &quot;pluginparameters&quot;)
-				{
-					loadPluginParameters(pElem);
-				}
-			}
-		}
-	}
-	catch (const std::exception&amp; ex)
-	{
-		cerr &lt;&lt; &quot;Couldn't parse settings file: &quot;
-			&lt;&lt; ex.what() &lt;&lt; endl;
-		success = false;
-	}
-
-	return success;
-}
-
-bool PinotSettings::loadUi(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem-&gt;get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast&lt;Element*&gt;(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem-&gt;get_name());
-		string nodeContent(getElementContent(pChildElem));
-		if (nodeName == &quot;xpos&quot;)
-		{
-			m_xPos = atoi(nodeContent.c_str());
-		}
-		else if (nodeName == &quot;ypos&quot;)
-		{
-			m_yPos = atoi(nodeContent.c_str());
-		}
-		else if (nodeName == &quot;width&quot;)
-		{
-			m_width = atoi(nodeContent.c_str());
-		}
-		else if (nodeName == &quot;height&quot;)
-		{
-			m_height = atoi(nodeContent.c_str());
-		}
-		else if (nodeName == &quot;panepos&quot;)
-		{
-			m_panePos = atoi(nodeContent.c_str());
-		}
-		else if (nodeName == &quot;expandqueries&quot;)
-		{
-			if (nodeContent == &quot;YES&quot;)
-			{
-				m_expandQueries = true;
-			}
-			else
-			{
-				m_expandQueries = false;
-			}
-		}
-		else if (nodeName == &quot;showengines&quot;)
-		{
-			if (nodeContent == &quot;YES&quot;)
-			{
-				m_showEngines = true;
-			}
-			else
-			{
-				m_showEngines = false;
-			}
-		}
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadIndexes(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem-&gt;get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	string indexName, indexLocation;
-
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast&lt;Element*&gt;(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem-&gt;get_name());
-		string nodeContent(getElementContent(pChildElem));
-		if (nodeName == &quot;name&quot;)
-		{
-			indexName = nodeContent;
-		}
-		else if (nodeName == &quot;location&quot;)
-		{
-			indexLocation = nodeContent;
-		}
-	}
-
-	if ((indexName.empty() == false) &amp;&amp;
-		(indexLocation.empty() == false))
-	{
-		addIndex(indexName, indexLocation, false);
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadEngineChannels(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem-&gt;get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast&lt;Element*&gt;(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem-&gt;get_name());
-		string nodeContent(getElementContent(pChildElem));
-		if (nodeName == &quot;name&quot;)
-		{
-			std::map&lt;string, bool&gt;::iterator channelIter = m_engineChannels.find(nodeContent);
-
-			if (channelIter != m_engineChannels.end())
-			{
-				channelIter-&gt;second = false;
-			}
-			else
-			{
-				m_engineChannels.insert(pair&lt;string, bool&gt;(nodeContent, false));
-			}
-		}
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadQueries(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem-&gt;get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	QueryProperties queryProps;
-	Date minDate, maxDate;
-	string freeQuery;
-	bool enableMinDate = false, enableMaxDate = false;
-
-	// Load the query's properties
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast&lt;Element*&gt;(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem-&gt;get_name());
-		string nodeContent(getElementContent(pChildElem));
-		if (nodeName == &quot;name&quot;)
-		{
-			queryProps.setName(nodeContent);
-		}
-		else if (nodeName == &quot;sortorder&quot;)
-		{
-			if (nodeContent == &quot;DATE&quot;)
-			{
-				queryProps.setSortOrder(QueryProperties::DATE);
-			}
-			else
-			{
-				queryProps.setSortOrder(QueryProperties::RELEVANCE);
-			}
-		}
-		else if (nodeName == &quot;text&quot;)
-		{
-			freeQuery = nodeContent;
-		}
-		else if ((nodeName == &quot;and&quot;) &amp;&amp;
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += &quot; &quot;;
-			}
-			freeQuery += nodeContent;
-		}
-		else if ((nodeName == &quot;phrase&quot;) &amp;&amp;
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += &quot; &quot;;
-			}
-			freeQuery += &quot;\&quot;&quot;;
-			freeQuery += nodeContent;
-			freeQuery += &quot;\&quot;&quot;;
-		}
-		else if ((nodeName == &quot;any&quot;) &amp;&amp;
-			(nodeContent.empty() == false))
-		{
-			// FIXME: don't be lazy and add those correctly
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += &quot; &quot;;
-			}
-			freeQuery += nodeContent;
-		}
-		else if ((nodeName == &quot;not&quot;) &amp;&amp;
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += &quot; &quot;;
-			}
-			freeQuery += &quot;-(&quot;;
-			freeQuery += nodeContent;
-			freeQuery += &quot;)&quot;;
-		}
-		else if ((nodeName == &quot;language&quot;) &amp;&amp;
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += &quot; &quot;;
-			}
-			freeQuery += &quot;lang:&quot;;
-			freeQuery += nodeContent;
-		}
-		else if ((nodeName == &quot;stemlanguage&quot;) &amp;&amp;
-			(nodeContent.empty() == false))
-		{
-			queryProps.setStemmingLanguage(Languages::toLocale(nodeContent));
-		}
-		else if ((nodeName == &quot;hostfilter&quot;) &amp;&amp;
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += &quot; &quot;;
-			}
-			freeQuery += &quot;site:&quot;;
-			freeQuery += nodeContent;
-		}
-		else if ((nodeName == &quot;filefilter&quot;) &amp;&amp;
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += &quot; &quot;;
-			}
-			freeQuery += &quot;file:&quot;;
-			freeQuery += nodeContent;
-		}
-		else if ((nodeName == &quot;labelfilter&quot;) &amp;&amp;
-			(nodeContent.empty() == false))
-		{
-			if (freeQuery.empty() == false)
-			{
-				freeQuery += &quot; &quot;;
-			}
-			freeQuery += &quot;label:&quot;;
-			freeQuery += nodeContent;
-		}
-		else if (nodeName == &quot;maxresults&quot;)
-		{
-			int count = atoi(nodeContent.c_str());
-			queryProps.setMaximumResultsCount((unsigned int)max(count, 10));
-		}
-		else if (nodeName == &quot;enablemindate&quot;)
-		{
-			if (nodeContent == &quot;YES&quot;)
-			{
-				enableMinDate = true;
-			}
-		}
-		else if (nodeName == &quot;mindate&quot;)
-		{
-			minDate.set_parse(nodeContent);
-		}
-		else if (nodeName == &quot;enablemaxdate&quot;)
-		{
-			if (nodeContent == &quot;YES&quot;)
-			{
-				enableMaxDate = true;
-			}
-		}
-		else if (nodeName == &quot;maxdate&quot;)
-		{
-			maxDate.set_parse(nodeContent);
-		}
-		else if (nodeName == &quot;index&quot;)
-		{
-			if (nodeContent == &quot;NEW&quot;)
-			{
-				queryProps.setIndexResults(QueryProperties::NEW_RESULTS);
-			}
-			else if (nodeContent == &quot;ALL&quot;)
-			{
-				queryProps.setIndexResults(QueryProperties::ALL_RESULTS);
-			}
-			else
-			{
-				queryProps.setIndexResults(QueryProperties::NOTHING);
-			}
-		}
-		else if (nodeName == &quot;label&quot;)
-		{
-			queryProps.setLabelName(nodeContent);
-		}
-		else if (nodeName == &quot;modified&quot;)
-		{
-			if (nodeContent == &quot;YES&quot;)
-			{
-				queryProps.setModified(true);
-			}
-		}
-	}
-
-	// Are pre-0.80 dates specified ?
-	if ((enableMinDate == true) ||
-		(enableMaxDate == true))
-	{
-		// Provide reasonable defaults
-		if (enableMinDate == false)
-		{
-			minDate.set_day(1);
-			minDate.set_month(Date::JANUARY);
-			minDate.set_year(1970);
-		}
-		if (enableMaxDate == false)
-		{
-			maxDate.set_day(31);
-			maxDate.set_month(Date::DECEMBER);
-			maxDate.set_year(2099);
-		}
-
-		ustring minDateStr(minDate.format_string(&quot;%Y%m%d&quot;));
-		ustring maxDateStr(maxDate.format_string(&quot;%Y%m%d&quot;));
-
-#ifdef DEBUG
-		cout &lt;&lt; &quot;PinotSettings::loadQueries: date range &quot; &lt;&lt; minDateStr &lt;&lt; &quot; to &quot; &lt;&lt; maxDateStr &lt;&lt; endl;
-#endif
-		freeQuery += &quot; &quot;;
-		freeQuery += minDateStr;
-		freeQuery += &quot;..&quot;;
-		freeQuery += maxDateStr;
-	}
-
-	// We need at least a name
-	if (queryProps.getName().empty() == false)
-	{
-		if (freeQuery.empty() == false)
-		{
-			queryProps.setFreeQuery(freeQuery);
-		}
-		m_queries[queryProps.getName()] = queryProps;
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadLabels(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem-&gt;get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	// Load the label's properties
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast&lt;Element*&gt;(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem-&gt;get_name());
-		string nodeContent(getElementContent(pChildElem));
-
-		if (nodeName == &quot;name&quot;)
-		{
-			m_labels.insert(nodeContent);
-		}
-		// Labels used to have colours...
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadColour(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem-&gt;get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	// Load the colour RGB components
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast&lt;Element*&gt;(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem-&gt;get_name());
-		string nodeContent(getElementContent(pChildElem));
-		gushort value = (gushort)atoi(nodeContent.c_str());
-
-		if (nodeName == &quot;red&quot;)
-		{
-			m_newResultsColourRed = value;
-		}
-		else if (nodeName == &quot;green&quot;)
-		{
-			m_newResultsColourGreen = value;
-		}
-		else if (nodeName == &quot;blue&quot;)
-		{
-			m_newResultsColourBlue = value;
-		}
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadProxy(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem-&gt;get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast&lt;Element*&gt;(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem-&gt;get_name());
-		string nodeContent(getElementContent(pChildElem));
-
-		if (nodeName == &quot;address&quot;)
-		{
-			m_proxyAddress = nodeContent;
-		}
-		else if (nodeName == &quot;port&quot;)
-		{
-			m_proxyPort = (unsigned int)atoi(nodeContent.c_str());
-		}
-		else if (nodeName == &quot;type&quot;)
-		{
-			m_proxyType = nodeContent;
-		}
-		else if (nodeName == &quot;enable&quot;)
-		{
-			if (nodeContent == &quot;YES&quot;)
-			{
-				m_proxyEnabled = true;
-			}
-			else
-			{
-				m_proxyEnabled = false;
-			}
-		}	
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadIndexableLocations(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem-&gt;get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	IndexableLocation location;
-
-	// Load the indexable location's properties
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast&lt;Element*&gt;(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem-&gt;get_name());
-		string nodeContent(getElementContent(pChildElem));
-
-		if (nodeName == &quot;name&quot;)
-		{
-			location.m_name = nodeContent;
-		}
-		else if (nodeName == &quot;monitor&quot;)
-		{
-			if (nodeContent == &quot;YES&quot;)
-			{
-				location.m_monitor = true;
-			}
-			else
-			{
-				location.m_monitor = false;
-			}
-		}
-	}
-
-	if (location.m_name.empty() == false)
-	{
-		location.m_isSource = true;
-
-		m_indexableLocations.insert(location);
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadFilePatterns(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem-&gt;get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	// Load the file patterns list
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast&lt;Element*&gt;(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem-&gt;get_name());
-		string nodeContent(getElementContent(pChildElem));
-
-		if (nodeName == &quot;pattern&quot;)
-		{
-			m_filePatternsList.insert(nodeContent);
-		}
-		else if (nodeName == &quot;forbid&quot;)
-		{
-			if (nodeContent == &quot;YES&quot;)
-			{
-				m_isBlackList = true;
-			}
-			else
-			{
-				m_isBlackList = false;
-			}
-		}
-	}
-
-	return true;
-}
-
-bool PinotSettings::loadPluginParameters(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem-&gt;get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	string name, value;
-
-	// Load the plugin parameters' values 
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast&lt;Element*&gt;(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem-&gt;get_name());
-		string nodeContent(getElementContent(pChildElem));
-
-		if (nodeName == &quot;name&quot;)
-		{
-			name = nodeContent;
-		}
-		else if (nodeName == &quot;value&quot;)
-		{
-			value = nodeContent;
-		}
-	}
-
-	m_editablePluginValues[name] = value;
-
-	return true;
-}
-
-bool PinotSettings::loadCacheProviders(const Element *pElem)
-{
-	if (pElem == NULL)
-	{
-		return false;
-	}
-
-	Node::NodeList childNodes = pElem-&gt;get_children();
-	if (childNodes.empty() == true)
-	{
-		return false;
-	}
-
-	CacheProvider cacheProvider;
-
-	// Load the cache provider's properties
-	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
-	{
-		Node *pNode = (*iter);
-		Element *pChildElem = dynamic_cast&lt;Element*&gt;(pNode);
-		if (pChildElem == NULL)
-		{
-			continue;
-		}
-
-		string nodeName(pChildElem-&gt;get_name());
-		string nodeContent(getElementContent(pChildElem));
-
-		if (nodeName == &quot;name&quot;)
-		{
-			cacheProvider.m_name = nodeContent;
-		}
-		else if (nodeName == &quot;location&quot;)
-		{
-			cacheProvider.m_location = nodeContent;
-		}
-		else if (nodeName == &quot;protocols&quot;)
-		{
-			nodeContent += &quot;,&quot;;
-
-			ustring::size_type previousPos = 0, commaPos = nodeContent.find(&quot;,&quot;);
-			while (commaPos != ustring::npos)
-			{
-				string protocol(nodeContent.substr(previousPos,
-                                        commaPos - previousPos));
-
-				StringManip::trimSpaces(protocol);
-				cacheProvider.m_protocols.insert(protocol);
-
-				// Next
-				previousPos = commaPos + 1;
-				commaPos = nodeContent.find(&quot;,&quot;, previousPos);
-			}
-		}
-	}
-
-	if ((cacheProvider.m_name.empty() == false) &amp;&amp;
-		(cacheProvider.m_location.empty() == false))
-	{
-		m_cacheProviders.push_back(cacheProvider);
-
-		// Copy the list of protocols supported by this cache provider
-		copy(cacheProvider.m_protocols.begin(), cacheProvider.m_protocols.end(),
-			inserter(m_cacheProtocols, m_cacheProtocols.begin()));
-	}
-
-	return true;
-}
-
-bool PinotSettings::save(SaveWhat what)
-{
-	Element *pRootElem = NULL;
-	Element *pElem = NULL;
-	char numStr[64];
-	bool prefsOrUI = true;
-
-	if (what == SAVE_CONFIG)
-	{
-		prefsOrUI = false;
-	}
-
-	try
-	{
-		xmlpp::Document doc(&quot;1.0&quot;);
-
-		// Create a new node
-		pRootElem = doc.create_root_node(&quot;pinot&quot;);
-		if (pRootElem == NULL)
-		{
-			return false;
-		}
-		// ...with text children nodes
-		addChildElement(pRootElem, &quot;version&quot;, VERSION);
-		if (what == SAVE_CONFIG)
-		{
-			addChildElement(pRootElem, &quot;warnaboutversion&quot;, (m_warnAboutVersion ? &quot;YES&quot; : &quot;NO&quot;));
-			// User interface position and size
-			pElem = pRootElem-&gt;add_child(&quot;ui&quot;);
-			if (pElem == NULL)
-			{
-				return false;
-			}
-			snprintf(numStr, 64, &quot;%d&quot;, m_xPos);
-			addChildElement(pElem, &quot;xpos&quot;, numStr);
-			snprintf(numStr, 64, &quot;%d&quot;, m_yPos);
-			addChildElement(pElem, &quot;ypos&quot;, numStr);
-			snprintf(numStr, 64, &quot;%d&quot;, m_width);
-			addChildElement(pElem, &quot;width&quot;, numStr);
-			snprintf(numStr, 64, &quot;%d&quot;, m_height);
-			addChildElement(pElem, &quot;height&quot;, numStr);
-			snprintf(numStr, 64, &quot;%d&quot;, m_panePos);
-			addChildElement(pElem, &quot;panepos&quot;, numStr);
-			addChildElement(pElem, &quot;expandqueries&quot;, (m_expandQueries ? &quot;YES&quot; : &quot;NO&quot;));
-			addChildElement(pElem, &quot;showengines&quot;, (m_showEngines ? &quot;YES&quot; : &quot;NO&quot;));
-			// User-defined indexes
-			for (set&lt;IndexProperties&gt;::iterator indexIter = m_indexes.begin(); indexIter != m_indexes.end(); ++indexIter)
-			{
-				if (indexIter-&gt;m_internal == true)
-				{
-					continue;
-				}
-
-				pElem = pRootElem-&gt;add_child(&quot;extraindex&quot;);
-				if (pElem == NULL)
-				{
-					return false;
-				}
-				addChildElement(pElem, &quot;name&quot;, indexIter-&gt;m_name);
-				addChildElement(pElem, &quot;location&quot;, indexIter-&gt;m_location);
-			}
-			// Engine channels
-			for (map&lt;string, bool&gt;::iterator channelIter = m_engineChannels.begin();
-				channelIter != m_engineChannels.end(); ++channelIter)
-			{
-				// Only save those whose group was collapsed
-				if (channelIter-&gt;second == false)
-				{
-					pElem = pRootElem-&gt;add_child(&quot;channel&quot;);
-					if (pElem == NULL)
-					{
-						return false;
-					}
-					addChildElement(pElem, &quot;name&quot;, channelIter-&gt;first);
-				}
-			}
-			// User-defined queries
-			for (map&lt;string, QueryProperties&gt;::iterator queryIter = m_queries.begin();
-				queryIter != m_queries.end(); ++queryIter)
-			{
-				pElem = pRootElem-&gt;add_child(&quot;storedquery&quot;);
-				if (pElem == NULL)
-				{
-					return false;
-				}
-
-				addChildElement(pElem, &quot;name&quot;, queryIter-&gt;first);
-				addChildElement(pElem, &quot;sortorder&quot;, (queryIter-&gt;second.getSortOrder() == QueryProperties::DATE ? &quot;DATE&quot; : &quot;RELEVANCE&quot;));
-				addChildElement(pElem, &quot;text&quot;, queryIter-&gt;second.getFreeQuery());
-				addChildElement(pElem, &quot;stemlanguage&quot;, Languages::toEnglish(queryIter-&gt;second.getStemmingLanguage()));
-				snprintf(numStr, 64, &quot;%u&quot;, queryIter-&gt;second.getMaximumResultsCount());
-				addChildElement(pElem, &quot;maxresults&quot;, numStr);
-				QueryProperties::IndexWhat indexResults = queryIter-&gt;second.getIndexResults();
-				if (indexResults == QueryProperties::NEW_RESULTS)
-				{
-					addChildElement(pElem, &quot;index&quot;, &quot;NEW&quot;);
-				}
-				else if (indexResults == QueryProperties::ALL_RESULTS)
-				{
-					addChildElement(pElem, &quot;index&quot;, &quot;ALL&quot;);
-				}
-				else
-				{
-					addChildElement(pElem, &quot;index&quot;, &quot;NONE&quot;);
-				}
-				addChildElement(pElem, &quot;label&quot;, queryIter-&gt;second.getLabelName());
-				addChildElement(pElem, &quot;modified&quot;, (queryIter-&gt;second.getModified() ? &quot;YES&quot; : &quot;NO&quot;));
-			}
-		}
-		if (what == SAVE_PREFS)
-		{
-			addChildElement(pRootElem, &quot;backend&quot;, m_defaultBackend);
-			addChildElement(pRootElem, &quot;googleapikey&quot;, m_googleAPIKey);
-			// Labels
-			for (set&lt;string&gt;::iterator labelIter = m_labels.begin(); labelIter != m_labels.end(); ++labelIter)
-			{
-				pElem = pRootElem-&gt;add_child(&quot;label&quot;);
-				if (pElem == NULL)
-				{
-					return false;
-				}
-				addChildElement(pElem, &quot;name&quot;, *labelIter);
-			}
-			// Ignore robots directives
-			addChildElement(pRootElem, &quot;robots&quot;, (m_ignoreRobotsDirectives ? &quot;IGNORE&quot; : &quot;OBEY&quot;));
-			// Enable terms suggestion
-			addChildElement(pRootElem, &quot;suggestterms&quot;, (m_suggestQueryTerms ? &quot;YES&quot; : &quot;NO&quot;));
-			// New results colour
-			pElem = pRootElem-&gt;add_child(&quot;newresults&quot;);
-			if (pElem == NULL)
-			{
-				return false;
-			}
-			snprintf(numStr, 64, &quot;%u&quot;, m_newResultsColourRed);
-			addChildElement(pElem, &quot;red&quot;, numStr);
-			snprintf(numStr, 64, &quot;%u&quot;, m_newResultsColourGreen);
-			addChildElement(pElem, &quot;green&quot;, numStr);
-			snprintf(numStr, 64, &quot;%u&quot;, m_newResultsColourBlue);
-			addChildElement(pElem, &quot;blue&quot;, numStr);
-			// Proxy
-			pElem = pRootElem-&gt;add_child(&quot;proxy&quot;);
-			if (pElem == NULL)
-			{
-				return false;
-			}
-			addChildElement(pElem, &quot;address&quot;, m_proxyAddress);
-			snprintf(numStr, 64, &quot;%u&quot;, m_proxyPort);
-			addChildElement(pElem, &quot;port&quot;, numStr);
-			addChildElement(pElem, &quot;type&quot;, m_proxyType);
-			addChildElement(pElem, &quot;enable&quot;, (m_proxyEnabled ? &quot;YES&quot; : &quot;NO&quot;));
-			// Locations to index 
-			for (set&lt;IndexableLocation&gt;::iterator locationIter = m_indexableLocations.begin();
-				locationIter != m_indexableLocations.end(); ++locationIter)
-			{
-				pElem = pRootElem-&gt;add_child(&quot;indexable&quot;);
-				if (pElem == NULL)
-				{
-					return false;
-				}
-				addChildElement(pElem, &quot;name&quot;, locationIter-&gt;m_name);
-				addChildElement(pElem, &quot;monitor&quot;, (locationIter-&gt;m_monitor ? &quot;YES&quot; : &quot;NO&quot;));
-			}
-			// File patterns
-			pElem = pRootElem-&gt;add_child(&quot;patterns&quot;);
-			if (pElem == NULL)
-			{
-				return false;
-			}
-			for (set&lt;ustring&gt;::iterator patternIter = m_filePatternsList.begin();
-				patternIter != m_filePatternsList.end() ; ++patternIter)
-			{
-				addChildElement(pElem, &quot;pattern&quot;, *patternIter);
-			}
-			addChildElement(pElem, &quot;forbid&quot;, (m_isBlackList ? &quot;YES&quot; : &quot;NO&quot;));
-			// Values of editable plugin parameters
-			for (map&lt;string, string&gt;::iterator editableIter = m_editablePluginValues.begin();
-				editableIter != m_editablePluginValues.end() ; ++editableIter)
-			{
-				if (editableIter-&gt;second.empty() == true)
-				{
-					continue;
-				}
-
-				pElem = pRootElem-&gt;add_child(&quot;pluginparameters&quot;);
-				if (pElem == NULL)
-				{
-					return false;
-				}
-				addChildElement(pElem, &quot;name&quot;, editableIter-&gt;first);
-				addChildElement(pElem, &quot;value&quot;, editableIter-&gt;second);
-			}
-		}
-#ifdef DEBUG
-		cout &lt;&lt; &quot;PinotSettings::save: saving to &quot; &lt;&lt; getFileName(prefsOrUI) &lt;&lt; endl;
-#endif
-
-		// Save to file
-		doc.write_to_file_formatted(getFileName(prefsOrUI));
-	}
-	catch (const std::exception&amp; ex)
-	{
-		cerr &lt;&lt; &quot;Couldn't save settings file: &quot;
-			&lt;&lt; ex.what() &lt;&lt; endl;
-		return false;
-	}
-
-	return true;
-}
-
-/// Returns the indexes set.
-const set&lt;PinotSettings::IndexProperties&gt; &amp;PinotSettings::getIndexes(void) const
-{
-	return m_indexes;
-}
-
-/// Adds a new index.
-bool PinotSettings::addIndex(const ustring &amp;name, const string &amp;location, bool isInternal)
-{
-	unsigned int indexId(1 &lt;&lt; m_indexCount);
-	m_indexes.insert(IndexProperties(name, location, indexId, isInternal));
-#ifdef DEBUG
-	cout &lt;&lt; &quot;PinotSettings::addIndex: index &quot; &lt;&lt; m_indexCount &lt;&lt; &quot; is &quot; &lt;&lt; name &lt;&lt; &quot; with ID &quot; &lt;&lt; indexId &lt;&lt; endl;
-#endif
-	++m_indexCount;
-
-	return true;
-}
-
-/// Removes an index.
-bool PinotSettings::removeIndex(const IndexProperties &amp;indexProps)
-{
-	// Remove from the names map
-	set&lt;IndexProperties&gt;::iterator namesMapIter = m_indexes.find(indexProps);
-	if (namesMapIter != m_indexes.end())
-	{
-		m_indexes.erase(namesMapIter);
-
-		return true;
-	}
-
-	return false;
-}
-
-/// Clears the indexes map.
-void PinotSettings::clearIndexes(void)
-{
-	// Clear and reinsert the internal indexes
-	m_indexes.clear();
-	m_indexCount = 0;
-	addIndex(_(&quot;My Web Pages&quot;), m_docsIndexLocation, true);
-	addIndex(_(&quot;My Documents&quot;), m_daemonIndexLocation, true);
-}
-
-/// Returns properties of the given index.
-PinotSettings::IndexProperties PinotSettings::getIndexPropertiesByName(const string &amp;name) const
-{
-	unsigned int indexId = 0;
-
-	for (set&lt;IndexProperties&gt;::const_iterator propsIter = m_indexes.begin();
-		propsIter != m_indexes.end(); ++propsIter)
-	{
-		if (propsIter-&gt;m_name == name)
-		{
-			return *propsIter;
-		}
-	}
-
-	return IndexProperties();
-}
-
-/// Returns properties of the given index.
-PinotSettings::IndexProperties PinotSettings::getIndexPropertiesByLocation(const string &amp;location) const
-{
-	for (set&lt;IndexProperties&gt;::const_iterator propsIter = m_indexes.begin();
-		propsIter != m_indexes.end(); ++propsIter)
-	{
-		if (propsIter-&gt;m_location == location)
-		{
-			return *propsIter;
-		}
-	}
-
-	return IndexProperties();
-}
-
-/// Returns the name(s) for the given ID.
-void PinotSettings::getIndexNames(unsigned int id, set&lt;string&gt; &amp;names)
-{
-	names.clear();
-
-	// Make sure indexes are or were defined
-	if (m_indexCount == 0)
-	{
-		return;
-	}
-
-	unsigned indexId = 1 &lt;&lt; (m_indexCount - 1);
-	do
-	{
-		if (id &amp; indexId)
-		{
-			for (set&lt;IndexProperties&gt;::const_iterator propsIter = m_indexes.begin();
-				propsIter != m_indexes.end(); ++propsIter)
-			{
-				if (propsIter-&gt;m_id == indexId)
-				{
-#ifdef DEBUG
-					cout &lt;&lt; &quot;PinotSettings::getIndexNames: index &quot; &lt;&lt; indexId &lt;&lt; &quot; is &quot; &lt;&lt; propsIter-&gt;m_name &lt;&lt; endl;
-#endif
-					// Get the associated name
-					names.insert(propsIter-&gt;m_name);
-				}
-			}
-		}
-		// Shift to the right
-		indexId = indexId &gt;&gt; 1;
-	} while (indexId &gt; 0);
-}
-
-/// Returns an IndexInterface for the given index location.
-IndexInterface *PinotSettings::getIndex(const string &amp;location)
-{
-	if (location == m_docsIndexLocation)
-	{
-		return ModuleFactory::getIndex(m_defaultBackend, m_docsIndexLocation);
-	}
-	else if ((m_clientMode == true) &amp;&amp;
-		(location == m_daemonIndexLocation))
-	{
-		return ModuleFactory::getIndex(&quot;dbus-&quot; + m_defaultBackend, m_daemonIndexLocation);
-	}
-
-	return ModuleFactory::getIndex(m_defaultBackend, location);
-}
-
-/// Returns the search engines set.
-bool PinotSettings::getSearchEngines(set&lt;ModuleProperties&gt; &amp;engines, const string &amp;channelName) const
-{
-	if (channelName.empty() == true)
-	{
-		// Copy the whole list of search engines
-		copy(m_engines.begin(), m_engines.end(), inserter(engines, engines.begin()));
-	}
-	else
-	{
-		if (m_engineChannels.find(channelName) == m_engineChannels.end())
-		{
-			// Unknown channel name
-			return false;
-		}
-
-		// Copy engines that belong to the given channel
-		for (set&lt;ModuleProperties&gt;::iterator engineIter = m_engines.begin(); engineIter != m_engines.end(); ++engineIter)
-		{
-			if (engineIter-&gt;m_channel == channelName)
-			{
-#ifdef DEBUG
-				cout &lt;&lt; &quot;PinotSettings::getSearchEngines: engine &quot; &lt;&lt; engineIter-&gt;m_longName &lt;&lt; &quot; in channel &quot; &lt;&lt; channelName &lt;&lt; endl;
-#endif
-				engines.insert(*engineIter);
-			}
-		}
-	}
-
-	return true;
-}
-
-/// Returns an ID that identifies the given engine name.
-unsigned int PinotSettings::getEngineId(const string &amp;name)
-{
-	unsigned int engineId = 0;
-
-	for (map&lt;unsigned int, string&gt;::iterator mapIter = m_engineIds.begin();
-		mapIter != m_engineIds.end(); ++mapIter)
-	{
-		if (mapIter-&gt;second == name)
-		{
-			engineId = mapIter-&gt;first;
-			break;
-		}
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;PinotSettings::getEngineId: &quot; &lt;&lt; name &lt;&lt; &quot;, ID &quot; &lt;&lt; engineId &lt;&lt; endl;
-#endif
-
-	return engineId;
-}
-
-/// Returns the name for the given ID.
-void PinotSettings::getEngineNames(unsigned int id, set&lt;string&gt; &amp;names)
-{
-	names.clear();
-
-	// Make sure there are search engines defined
-	if (m_engines.empty() == true)
-	{
-		return;
-	}
-
-	unsigned engineId = 1 &lt;&lt; (m_engines.size() - 1);
-	do
-	{
-		if (id &amp; engineId)
-		{
-			map&lt;unsigned int, string&gt;::iterator mapIter = m_engineIds.find(engineId);
-			if (mapIter != m_engineIds.end())
-			{
-				// Get the associated name
-				names.insert(mapIter-&gt;second);
-			}
-		}
-		// Shift to the right
-		engineId = engineId &gt;&gt; 1;
-	} while (engineId &gt; 0);
-}
-
-/// Returns the search engines channels.
-map&lt;string, bool&gt; &amp;PinotSettings::getSearchEnginesChannels(void)
-{
-	return m_engineChannels;
-}
-
-/// Returns the queries map, keyed by name.
-const map&lt;string, QueryProperties&gt; &amp;PinotSettings::getQueries(void) const
-{
-	return m_queries;
-}
-
-/// Adds a new query.
-bool PinotSettings::addQuery(const QueryProperties &amp;properties)
-{
-	string name(properties.getName());
-
-	map&lt;string, QueryProperties&gt;::iterator queryIter = m_queries.find(name);
-	if (queryIter == m_queries.end())
-	{
-		// Okay, no such query exists
-		m_queries[name] = properties;
-
-		return true;
-	}
-
-	return false;
-}
-
-/// Removes a query.
-bool PinotSettings::removeQuery(const string &amp;name)
-{
-	// Remove from the map
-	map&lt;string, QueryProperties&gt;::iterator queryIter = m_queries.find(name);
-	if (queryIter != m_queries.end())
-	{
-		m_queries.erase(queryIter);
-
-		return true;
-	}
-
-	return false;
-}
-
-/// Clears the queries map.
-void PinotSettings::clearQueries(void)
-{
-	m_queries.clear();
-}
-
-/// Gets default patterns.
-bool PinotSettings::getDefaultPatterns(set&lt;ustring&gt; &amp;defaultPatterns)
-{
-	defaultPatterns.clear();
-
-	// Skip common image, video and archive types
-	defaultPatterns.insert(&quot;*~&quot;);
-	defaultPatterns.insert(&quot;*.Z&quot;);
-	defaultPatterns.insert(&quot;*.a&quot;);
-	defaultPatterns.insert(&quot;*.asf&quot;);
-	defaultPatterns.insert(&quot;*.avi&quot;);
-	defaultPatterns.insert(&quot;*.aux&quot;);
-	defaultPatterns.insert(&quot;*CVS&quot;);
-	defaultPatterns.insert(&quot;*.cap&quot;);
-	defaultPatterns.insert(&quot;*.divx&quot;);
-	defaultPatterns.insert(&quot;*.flv&quot;);
-	defaultPatterns.insert(&quot;*.gif&quot;);
-	defaultPatterns.insert(&quot;*.git&quot;);
-	defaultPatterns.insert(&quot;*.gmo&quot;);
-	defaultPatterns.insert(&quot;*.iso&quot;);
-	defaultPatterns.insert(&quot;*.la&quot;);
-	defaultPatterns.insert(&quot;*.lha&quot;);
-	defaultPatterns.insert(&quot;*.lo&quot;);
-	defaultPatterns.insert(&quot;*.loT&quot;);
-	defaultPatterns.insert(&quot;*.m4&quot;);
-	defaultPatterns.insert(&quot;*.mov&quot;);
-	defaultPatterns.insert(&quot;*.msf&quot;);
-	defaultPatterns.insert(&quot;*.mpeg&quot;);
-	defaultPatterns.insert(&quot;*.mpg&quot;);
-	defaultPatterns.insert(&quot;*.mo&quot;);
-	defaultPatterns.insert(&quot;*.o&quot;);
-	defaultPatterns.insert(&quot;*.omf&quot;);
-	defaultPatterns.insert(&quot;*.orig&quot;);
-	defaultPatterns.insert(&quot;*.part&quot;);
-	defaultPatterns.insert(&quot;*.pc&quot;);
-	defaultPatterns.insert(&quot;*.png&quot;);
-	defaultPatterns.insert(&quot;*.po&quot;);
-	defaultPatterns.insert(&quot;*.rar&quot;);
-	defaultPatterns.insert(&quot;*.rej&quot;);
-	defaultPatterns.insert(&quot;*.sh&quot;);
-	defaultPatterns.insert(&quot;*.so&quot;);
-	defaultPatterns.insert(&quot;*.svn&quot;);
-	defaultPatterns.insert(&quot;*.tiff&quot;);
-	defaultPatterns.insert(&quot;*.tmp&quot;);
-	defaultPatterns.insert(&quot;*.torrent&quot;);
-	defaultPatterns.insert(&quot;*.vm*&quot;);
-	defaultPatterns.insert(&quot;*.wmv&quot;);
-	defaultPatterns.insert(&quot;*.xbm&quot;);
-	defaultPatterns.insert(&quot;*.xpm&quot;);
-
-	return true;
-}
-
-/// Determines if a file matches the blacklist.
-bool PinotSettings::isBlackListed(const string &amp;fileName)
-{
-	if (m_filePatternsList.empty() == true)
-	{
-		if (m_isBlackList == true)
-		{
-			// There is no black-list
-			return false;
-		}
-
-		// The file is not in the (empty) whitelist
-		return true;
-	}
-
-#ifdef HAVE_FNMATCH_H
-	// Any pattern matches this file name ?
-	for (set&lt;ustring&gt;::iterator patternIter = m_filePatternsList.begin(); patternIter != m_filePatternsList.end() ; ++patternIter)
-	{
-		if (fnmatch(patternIter-&gt;c_str(), fileName.c_str(), FNM_NOESCAPE) == 0)
-		{
-			// Fail if it's in the blacklist, let the file through otherwise
-			return m_isBlackList;
-		}
-	}
-#endif
-
-	return !m_isBlackList;
-}
-
-PinotSettings::IndexableLocation::IndexableLocation() :
-	m_monitor(false),
-	m_isSource(true)
-{
-}
-
-PinotSettings::IndexableLocation::IndexableLocation(const IndexableLocation &amp;other) :
-	m_monitor(other.m_monitor),
-	m_name(other.m_name),
-	m_isSource(other.m_isSource)
-{
-}
-
-PinotSettings::IndexableLocation::~IndexableLocation()
-{
-}
-
-PinotSettings::IndexableLocation &amp;PinotSettings::IndexableLocation::operator=(const IndexableLocation &amp;other)
-{
-	if (this != &amp;other)
-	{
-		m_monitor = other.m_monitor;
-		m_name = other.m_name;
-		m_isSource = other.m_isSource;
-	}
-
-	return *this;
-}
-
-bool PinotSettings::IndexableLocation::operator&lt;(const IndexableLocation &amp;other) const
-{
-	if (m_name &lt; other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-bool PinotSettings::IndexableLocation::operator==(const IndexableLocation &amp;other) const
-{
-	if (m_name == other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-PinotSettings::CacheProvider::CacheProvider()
-{
-}
-
-PinotSettings::CacheProvider::CacheProvider(const CacheProvider &amp;other) :
-	m_name(other.m_name),
-	m_location(other.m_location)
-{
-	m_protocols.clear();
-	copy(other.m_protocols.begin(), other.m_protocols.end(),
-		inserter(m_protocols, m_protocols.begin()));
-}
-
-PinotSettings::CacheProvider::~CacheProvider()
-{
-}
-
-PinotSettings::CacheProvider &amp;PinotSettings::CacheProvider::operator=(const CacheProvider &amp;other)
-{
-	if (this != &amp;other)
-	{
-		m_name = other.m_name;
-		m_location = other.m_location;
-		m_protocols.clear();
-		copy(other.m_protocols.begin(), other.m_protocols.end(),
-			inserter(m_protocols, m_protocols.begin()));
-	}
-
-	return *this;
-}
-
-bool PinotSettings::CacheProvider::operator&lt;(const CacheProvider &amp;other) const
-{
-	if (m_name &lt; other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-bool PinotSettings::CacheProvider::operator==(const CacheProvider &amp;other) const
-{
-	if (m_name == other.m_name)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-PinotSettings::IndexProperties::IndexProperties() :
-	m_id(0),
-	m_internal(false)
-{
-}
-
-PinotSettings::IndexProperties::IndexProperties(const ustring &amp;name,
-	const string &amp;location, unsigned int id, bool isInternal) :
-	m_name(name),
-	m_location(location),
-	m_id(id),
-	m_internal(isInternal)
-{
-}
-
-PinotSettings::IndexProperties::IndexProperties(const IndexProperties &amp;other) :
-	m_name(other.m_name),
-	m_location(other.m_location),
-	m_id(other.m_id),
-	m_internal(other.m_internal)
-{
-}
-
-PinotSettings::IndexProperties::~IndexProperties()
-{
-}
-
-PinotSettings::IndexProperties&amp; PinotSettings::IndexProperties::operator=(const IndexProperties &amp;other)
-{
-	if (this != &amp;other)
-	{
-		m_name = other.m_name;
-		m_location = other.m_location;
-		m_id = other.m_id;
-		m_internal = other.m_internal;
-	}
-
-	return *this;
-}
-
-bool PinotSettings::IndexProperties::operator&lt;(const IndexProperties &amp;other) const
-{
-	if (m_id &lt; other.m_id)
-	{
-		return true;
-	}
-	else if (m_id == other.m_id)
-	{
-		if (m_name &lt; other.m_name)
-		{
-			return true;
-		}
-	}
-
-	return false;
-}
-
-bool PinotSettings::IndexProperties::operator==(const IndexProperties &amp;other) const
-{
-	if (m_id == other.m_id)
-	{
-		return true;
-	}
-
-	return false;
-}

Deleted: trunk/UI/GTK2/src/PinotSettings.h
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/PinotSettings.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,240 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _PINOTSETTINGS_HH
-#define _PINOTSETTINGS_HH
-
-#include &lt;sys/types.h&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;map&gt;
-#include &lt;set&gt;
-#include &lt;vector&gt;
-#include &lt;glibmm/ustring.h&gt;
-#include &lt;libxml++/nodes/element.h&gt;
-
-#include &quot;IndexInterface.h&quot;
-#include &quot;ModuleProperties.h&quot;
-#include &quot;QueryProperties.h&quot;
-
-class PinotSettings
-{
-	public:
-		~PinotSettings();
-
-		typedef enum { LOAD_ALL = 0, LOAD_GLOBAL, LOAD_LOCAL } LoadWhat;
-
-		typedef enum { SAVE_PREFS = 0, SAVE_CONFIG } SaveWhat;
-
-		class IndexProperties
-		{
-			public:
-				IndexProperties();
-				IndexProperties(const Glib::ustring &amp;name,
-		                        const std::string &amp;location,
-					unsigned int id, bool isInternal);
-				IndexProperties(const IndexProperties &amp;other);
-				virtual ~IndexProperties();
-
-				IndexProperties&amp; operator=(const IndexProperties &amp;other);
-				bool operator&lt;(const IndexProperties &amp;other) const;
-				bool operator==(const IndexProperties &amp;other) const;
-
-				Glib::ustring m_name;
-				std::string m_location;
-				unsigned int m_id;
-				bool m_internal;
-
-		};
-
-		static PinotSettings &amp;getInstance(void);
-
-		static bool enableClientMode(bool enable);
-
-		static std::string getHomeDirectory(void);
-
-		static std::string getConfigurationDirectory(void);
-
-		static std::string getFileName(bool prefsOrUI);
-
-		static std::string getCurrentUserName(void);
-
-		static void checkHistoryDatabase(void);
-
-		static std::string getHistoryDatabaseName(bool needToQueryDaemonHistory = false);
-
-		bool isFirstRun(void) const;
-
-		void clear(void);
-
-		bool load(LoadWhat what);
-
-		bool save(SaveWhat what);
-
-		/// Returns the indexes set.
-		const std::set&lt;IndexProperties&gt; &amp;getIndexes(void) const;
-
-		/// Adds a new index.
-		bool addIndex(const Glib::ustring &amp;name, const std::string &amp;location,
-			bool isInternal = false);
-
-		/// Removes an index.
-		bool removeIndex(const IndexProperties &amp;indexProps);
-
-		/// Clears the indexes map.
-		void clearIndexes(void);
-
-		/// Returns properties of the given index.
-		IndexProperties getIndexPropertiesByName(const std::string &amp;name) const;
-
-		/// Returns properties of the given index.
-		IndexProperties getIndexPropertiesByLocation(const std::string &amp;location) const;
-
-		/// Returns the name(s) for the given ID.
-		void getIndexNames(unsigned int id, std::set&lt;std::string&gt; &amp;names);
-
-		/// Returns an IndexInterface for the given index location.
-		IndexInterface *getIndex(const std::string &amp;location);
-
-		/// Returns the search engines set.
-		bool getSearchEngines(std::set&lt;ModuleProperties&gt; &amp;engines, const std::string &amp;channelName = &quot;&quot;) const;
-
-		/// Returns an ID that identifies the given engine name.
-		unsigned int getEngineId(const std::string &amp;name);
-
-		/// Returns the name(s) for the given ID.
-		void getEngineNames(unsigned int id, std::set&lt;std::string&gt; &amp;names);
-
-		/// Returns the search engines channels.
-		std::map&lt;std::string, bool&gt; &amp;getSearchEnginesChannels(void);
-
-		/// Returns the queries map, keyed by name.
-		const std::map&lt;std::string, QueryProperties&gt; &amp;getQueries(void) const;
-
-		/// Adds a new query.
-		bool addQuery(const QueryProperties &amp;properties);
-
-		/// Removes a query.
-		bool removeQuery(const std::string &amp;name);
-
-		/// Clears the queries map.
-		void clearQueries(void);
-
-		/// Gets default patterns.
-		bool getDefaultPatterns(std::set&lt;Glib::ustring&gt; &amp;defaultPatterns);
-
-		/// Determines if a file matches the blacklist.
-		bool isBlackListed(const std::string &amp;fileName);
-
-		class IndexableLocation 
-		{
-			public:
-				IndexableLocation();
-				IndexableLocation(const IndexableLocation &amp;other);
-				~IndexableLocation();
-
-				IndexableLocation &amp;operator=(const IndexableLocation &amp;other);
-				bool operator&lt;(const IndexableLocation &amp;other) const;
-				bool operator==(const IndexableLocation &amp;other) const;
-
-				bool m_monitor;
-				Glib::ustring m_name;
-				bool m_isSource;
-
-		};
-
-		class CacheProvider
-		{
-			public:
-				CacheProvider();
-				CacheProvider(const CacheProvider &amp;other);
-				~CacheProvider();
-
-				CacheProvider &amp;operator=(const CacheProvider &amp;other);
-				bool operator&lt;(const CacheProvider &amp;other) const;
-				bool operator==(const CacheProvider &amp;other) const;
-
-				Glib::ustring m_name;
-				Glib::ustring m_location;
-				std::set&lt;Glib::ustring&gt; m_protocols;
-		};
-
-		Glib::ustring m_version;
-		bool m_warnAboutVersion;
-		Glib::ustring m_defaultBackend;
-		Glib::ustring m_googleAPIKey;
-		Glib::ustring m_docsIndexLocation;
-		Glib::ustring m_daemonIndexLocation;
-		double m_minimumDiskSpace;
-		int m_xPos;
-		int m_yPos;
-		int m_width;
-		int m_height;
-		int m_panePos;
-		bool m_showEngines;
-		bool m_expandQueries;
-		bool m_ignoreRobotsDirectives;
-		bool m_suggestQueryTerms;
-		unsigned short m_newResultsColourRed;
-		unsigned short m_newResultsColourGreen;
-		unsigned short m_newResultsColourBlue;
-		Glib::ustring m_proxyAddress;
-		unsigned int m_proxyPort;
-		Glib::ustring  m_proxyType;
-		bool m_proxyEnabled;
-		std::set&lt;std::string&gt; m_labels;
-		std::set&lt;IndexableLocation&gt; m_indexableLocations;
-		std::set&lt;Glib::ustring&gt; m_filePatternsList;
-		bool m_isBlackList;
-		std::map&lt;std::string, std::string&gt; m_editablePluginValues;
-		std::vector&lt;CacheProvider&gt; m_cacheProviders;
-		std::set&lt;Glib::ustring&gt; m_cacheProtocols;
-
-	protected:
-		static PinotSettings m_instance;
-		static bool m_clientMode;
-		bool m_firstRun;
-		std::set&lt;IndexProperties&gt; m_indexes;
-		unsigned int m_indexCount;
-		std::set&lt;ModuleProperties&gt; m_engines;
-		std::map&lt;unsigned int, std::string&gt; m_engineIds;
-		std::map&lt;std::string, bool&gt; m_engineChannels;
-		std::map&lt;std::string, QueryProperties&gt; m_queries;
-
-		PinotSettings();
-		bool loadSearchEngines(const std::string &amp;directoryName);
-		bool loadConfiguration(const std::string &amp;fileName, bool isGlobal);
-		bool loadUi(const xmlpp::Element *pElem);
-		bool loadIndexes(const xmlpp::Element *pElem);
-		bool loadEngineChannels(const xmlpp::Element *pElem);
-		bool loadQueries(const xmlpp::Element *pElem);
-		bool loadLabels(const xmlpp::Element *pElem);
-		bool loadColour(const xmlpp::Element *pElem);
-		bool loadProxy(const xmlpp::Element *pElem);
-		bool loadIndexableLocations(const xmlpp::Element *pElem);
-		bool loadFilePatterns(const xmlpp::Element *pElem);
-		bool loadPluginParameters(const xmlpp::Element *pElem);
-		bool loadCacheProviders(const xmlpp::Element *pElem);
-
-	private:
-		PinotSettings(const PinotSettings &amp;other);
-		PinotSettings &amp;operator=(const PinotSettings &amp;other);
-
-};
-
-#endif // _PINOTSETTINGS_HH

Deleted: trunk/UI/GTK2/src/PinotUtils.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/PinotUtils.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,272 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;iostream&gt;
-#include &lt;gtkmm/stock.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;NLS.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;PinotSettings.h&quot;
-#include &quot;PinotUtils.h&quot;
-
-using namespace std;
-using namespace Glib;
-using namespace Gtk;
-
-/// Open a FileChooserDialog.
-bool select_file_name(const ustring &amp;title, ustring &amp;location,
-	bool openOrCreate, bool directoriesOnly)
-{
-	FileChooserDialog fileChooser(title);
-
-	if (title.empty() == true)
-	{
-		return false;
-	}
-
-	prepare_file_chooser(fileChooser, location, openOrCreate, directoriesOnly);
-	fileChooser.show();
-
-	int result = fileChooser.run();
-	if (result == RESPONSE_OK)
-	{
-		// Retrieve the chosen location
-		if (directoriesOnly == false)
-		{
-			location = filename_to_utf8(fileChooser.get_filename());
-		}
-		else
-		{
-			location = filename_to_utf8(fileChooser.get_current_folder());
-		}
-
-		return true;
-	}
-
-	return false;
-}
-
-bool prepare_file_chooser(FileChooserDialog &amp;fileChooser, ustring &amp;location,
-	bool openOrCreate, bool directoriesOnly)
-{
-	FileChooserAction chooserAction = FILE_CHOOSER_ACTION_OPEN;
-	StockID okButtonStockId = Stock::OPEN;
-	bool isDirectory = false;
-
-	if (openOrCreate == false)
-	{
-		okButtonStockId = Stock::SAVE;
-		fileChooser.set_do_overwrite_confirmation(true);
-	}
-
-	// Have we been provided with an initial location ?
-	if (location.empty() == true)
-	{
-		// No, get the location of the home directory then
-		location = PinotSettings::getInstance().getHomeDirectory();
-		isDirectory = true;
-	}
-
-	if (directoriesOnly == false)
-	{
-		if (openOrCreate == true)
-		{
-			chooserAction = FILE_CHOOSER_ACTION_OPEN;
-		}
-		else
-		{
-			chooserAction = FILE_CHOOSER_ACTION_SAVE;
-		}
-	}
-	else
-	{
-		if (openOrCreate == true)
-		{
-			chooserAction = FILE_CHOOSER_ACTION_SELECT_FOLDER;
-		}
-		else
-		{
-			chooserAction = FILE_CHOOSER_ACTION_CREATE_FOLDER;
-		}
-		isDirectory = true;
-	}
-
-	fileChooser.set_action(chooserAction);
-	Url urlObj(location);
-	fileChooser.set_current_folder(filename_from_utf8(urlObj.getLocation()));
-	if (isDirectory == false)
-	{
-		fileChooser.set_current_name(filename_from_utf8(urlObj.getFile()));
-	}
-	fileChooser.set_local_only();
-	fileChooser.set_select_multiple(false);
-	fileChooser.add_button(Stock::CANCEL, RESPONSE_CANCEL);
-	fileChooser.add_button(okButtonStockId, RESPONSE_OK);
-	fileChooser.set_show_hidden(true);
-
-	return true;
-}
-
-/// Get a column height.
-int get_column_height(TreeView *pTree)
-{
-	int height = 0;
-
-	if (pTree == NULL)
-	{
-		return 0;
-	}
-
-	TreeViewColumn *pColumn = pTree-&gt;get_column(1);
-	if (pColumn != NULL)
-	{
-		Gdk::Rectangle cellArea;
-		int xOffset, yOffset, cellWidth, cellHeight;
-
-		pColumn-&gt;cell_get_size(cellArea, xOffset, yOffset, cellWidth, cellHeight);
-		height += cellHeight;
-#ifdef DEBUG
-		cout &lt;&lt; &quot;get_column_height: cell &quot; &lt;&lt; cellHeight &lt;&lt; &quot; &quot; &lt;&lt; yOffset &lt;&lt; endl;
-#endif
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;get_column_height: &quot; &lt;&lt; height &lt;&lt; endl;
-#endif
-
-	return height;
-}
-
-/// Create a text column.
-TreeViewColumn *create_column(const ustring &amp;title, const TreeModelColumnBase&amp; modelColumn,
-	bool isResizable, bool isSortable, const TreeModelColumnBase &amp;sortColumn)
-{
-	TreeViewColumn *pColumn = new TreeViewColumn(title);
-
-	CellRendererText *pTextRenderer = new CellRendererText();
-	pColumn-&gt;pack_start(*manage(pTextRenderer));
-	pColumn-&gt;add_attribute(pTextRenderer-&gt;property_text(), modelColumn);
-	pColumn-&gt;set_resizable(isResizable);
-	if (isSortable == true)
-	{
-		pColumn-&gt;set_sort_column(sortColumn);
-	}
-
-	return pColumn;
-}
-
-/// Create an icon and text column, rendered by renderTextAndIconCell.
-TreeViewColumn *create_column_with_icon(const ustring &amp;title, const TreeModelColumnBase&amp; modelColumn,
-	const TreeViewColumn::SlotCellData &amp;renderTextAndIconCell,
-	bool isResizable, bool isSortable, const TreeModelColumnBase &amp;sortColumn)
-{
-	TreeViewColumn *pColumn = new TreeViewColumn(title);
-
-	// Pack an icon renderer in the column
-	CellRendererPixbuf *pIconRenderer = new CellRendererPixbuf();
-	pColumn-&gt;pack_start(*manage(pIconRenderer), false);
-	pColumn-&gt;set_cell_data_func(*pIconRenderer, renderTextAndIconCell);
-	// ...followed by a text renderer
-	CellRendererText *pTextRenderer = new CellRendererText();
-	pColumn-&gt;pack_start(*manage(pTextRenderer));
-	pColumn-&gt;set_cell_data_func(*pTextRenderer, renderTextAndIconCell);
-
-	pColumn-&gt;add_attribute(pTextRenderer-&gt;property_text(), modelColumn);
-	pColumn-&gt;set_resizable(isResizable);
-	if (isSortable == true)
-	{
-		pColumn-&gt;set_sort_column(sortColumn);
-	}
-
-	return pColumn;
-}
-
-/// Converts to UTF-8.
-ustring to_utf8(const string &amp;text)
-{
-	std::string charset;
-
-	// Get the locale charset
-	get_charset(charset);
-	// Call overload
-	return to_utf8(text, charset);
-}
-
-/// Converts from the given charset to UTF-8.
-ustring to_utf8(const string &amp;text, const string &amp;charset)
-{
-	if ((charset == &quot;UTF-8&quot;) ||
-		(charset == &quot;utf-8&quot;))
-	{
-		// No conversion necessary
-		return text;
-	}
-
-	try
-	{
-		if (charset.empty() == false)
-		{
-			return convert_with_fallback(text, &quot;UTF-8&quot;, charset, &quot; &quot;);
-		}
-		else
-		{
-			return locale_to_utf8(text);
-		}
-	}
-	catch (Error &amp;ce)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;to_utf8: cannot convert from &quot; &lt;&lt; charset &lt;&lt; &quot;: &quot; &lt;&lt; ce.what() &lt;&lt; endl;
-#endif
-		if (charset.empty() == false)
-		{
-			return to_utf8(text);
-		}
-	}
-	catch (...)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;to_utf8: unknown exception&quot; &lt;&lt; endl;
-#endif
-	}
-
-	return &quot;&quot;;
-}
-
-/// Converts from UTF-8.
-string from_utf8(const ustring &amp;text)
-{
-	try
-	{
-		return locale_from_utf8(text);
-	}
-	catch (Error &amp;ce)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;from_utf8: &quot; &lt;&lt; ce.what() &lt;&lt; endl;
-#endif
-	}
-	catch (...)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;from_utf8: unknown exception&quot; &lt;&lt; endl;
-#endif
-	}
-
-	return &quot;&quot;;
-}

Deleted: trunk/UI/GTK2/src/PinotUtils.h
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/PinotUtils.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,62 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
- 
-#ifndef _PINOTUTILS_HH
-#define _PINOTUTILS_HH
-
-#include &lt;string&gt;
-#include &lt;gtkmmconfig.h&gt;
-#include &lt;glibmm/ustring.h&gt;
-#include &lt;gtkmm/window.h&gt;
-#include &lt;gtkmm/filechooserdialog.h&gt;
-#include &lt;gtkmm/treeview.h&gt;
-#include &lt;gtkmm/treemodel.h&gt;
-#include &lt;gtkmm/filechooserdialog.h&gt;
-
-/// Open a FileChooserDialog.
-bool select_file_name(const Glib::ustring &amp;title, Glib::ustring &amp;location,
-	bool openOrCreate, bool directoriesOnly = false);
-
-/// Prepare a FileChooserDialog.
-bool prepare_file_chooser(Gtk::FileChooserDialog &amp;fileChooser, Glib::ustring &amp;location,
-	bool openOrCreate, bool directoriesOnly = false);
-
-/// Get a column height.
-int get_column_height(Gtk::TreeView *pTree);
-
-/// Create a text column.
-Gtk::TreeViewColumn *create_column(const Glib::ustring &amp;title,
-	const Gtk::TreeModelColumnBase&amp; modelColumn,
-	bool isResizable, bool isSortable, const Gtk::TreeModelColumnBase &amp;sortColumn);
-
-/// Create an icon and text column, rendered by renderTextAndIconCell.
-Gtk::TreeViewColumn *create_column_with_icon(const Glib::ustring &amp;title,
-	const Gtk::TreeModelColumnBase&amp; modelColumn,
-	const Gtk::TreeViewColumn::SlotCellData &amp;renderTextAndIconCell,
-	bool isResizable, bool isSortable, const Gtk::TreeModelColumnBase &amp;sortColumn);
-
-/// Converts to UTF-8.
-Glib::ustring to_utf8(const std::string &amp;text);
-
-/// Converts from the given charset to UTF-8.
-Glib::ustring to_utf8(const std::string &amp;text, const std::string &amp;charset);
-
-/// Converts from UTF-8.
-std::string from_utf8(const Glib::ustring &amp;text);
-
-#endif // _PINOTUTILS_HH

Deleted: trunk/UI/GTK2/src/ServerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/ServerThreads.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/ServerThreads.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,1489 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;sys/types.h&gt;
-#include &lt;dirent.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;string.h&gt;
-#include &lt;strings.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;exception&gt;
-#include &lt;iostream&gt;
-#include &lt;fstream&gt;
-#include &lt;sstream&gt;
-#include &lt;glibmm/miscutils.h&gt;
-#include &lt;glibmm/convert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;NLS.h&quot;
-#include &quot;MIMEScanner.h&quot;
-#include &quot;TimeConverter.h&quot;
-#include &quot;Timer.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;CrawlHistory.h&quot;
-#include &quot;MetaDataBackup.h&quot;
-#ifdef HAVE_DBUS
-#include &quot;DBusIndex.h&quot;
-#endif
-#include &quot;ModuleFactory.h&quot;
-#include &quot;DaemonState.h&quot;
-#include &quot;PinotSettings.h&quot;
-#include &quot;ServerThreads.h&quot;
-
-using namespace Glib;
-using namespace std;
-
-static void updateLabels(unsigned int docId, MetaDataBackup &amp;metaData,
-	IndexInterface *pIndex, set&lt;string&gt; &amp;labels, gboolean resetLabels)
-{
-	DocumentInfo docInfo;
-
-	if (pIndex == NULL)
-	{
-		return;
-	}
-
-	// If it's a reset, remove labels from the metadata backup
-	if ((resetLabels == TRUE) &amp;&amp;
-		(pIndex-&gt;getDocumentInfo(docId, docInfo) == true))
-	{
-		metaData.deleteItem(docInfo, DocumentInfo::SERIAL_LABELS);
-	}
-
-	// Get the current labels 
-	if (resetLabels == TRUE)
-	{
-		labels.clear();
-		pIndex-&gt;getDocumentLabels(docId, labels);
-	}
-	docInfo.setLabels(labels);
-	metaData.addItem(docInfo, DocumentInfo::SERIAL_LABELS);
-}
-
-static ustring g_xmlDescription;
-
-static bool loadXMLDescription(void)
-{
-	bool readFile = false;
-
-	if (g_xmlDescription.empty() == false)
-	{
-		return true;
-	}
-
-	ifstream xmlFile;
-	string xmlFileName(PREFIX);
-
-	xmlFileName += &quot;/share/pinot/pinot-dbus-daemon.xml&quot;;
-	xmlFile.open(xmlFileName.c_str());
-	if (xmlFile.good() == true)
-	{
-		xmlFile.seekg(0, ios::end);
-		int length = xmlFile.tellg();
-		xmlFile.seekg(0, ios::beg);
-
-		char *pXmlBuffer = new char[length + 1];
-		xmlFile.read(pXmlBuffer, length);
-		if (xmlFile.fail() == false)
-		{
-			pXmlBuffer[length] = '\0';
-			g_xmlDescription = pXmlBuffer;
-			readFile = true;
-		}
-		delete[] pXmlBuffer;
-	}
-	xmlFile.close();
-
-	if (readFile == false)
-	{
-		cerr &lt;&lt; &quot;File &quot; &lt;&lt; xmlFileName &lt;&lt; &quot; couldn't be read&quot; &lt;&lt; endl;
-	}
-	return readFile;
-}
-
-DirectoryScannerThread::DirectoryScannerThread(const string &amp;dirName, bool isSource,
-	bool fullScan, bool isReindex,
-	MonitorInterface *pMonitor, MonitorHandler *pHandler,
-	unsigned int maxLevel, bool inlineIndexing, bool followSymLinks) :
-	IndexingThread(),
-	m_dirName(dirName),
-	m_fullScan(fullScan),
-	m_isReindex(isReindex),
-	m_pMonitor(pMonitor),
-	m_pHandler(pHandler),
-	m_sourceId(0),
-	m_currentLevel(0),
-	m_maxLevel(maxLevel),
-	m_inlineIndexing(inlineIndexing),
-	m_followSymLinks(followSymLinks)
-{
-	if (m_dirName.empty() == false)
-	{
-		CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-
-		if (isSource == true)
-		{
-			// Does this source exist ?
-			if (crawlHistory.hasSource(&quot;<A HREF="file://">file://</A>&quot; + m_dirName, m_sourceId) == false)
-			{
-				// Create it
-				m_sourceId = crawlHistory.insertSource(&quot;<A HREF="file://">file://</A>&quot; + m_dirName);
-			}
-		}
-		else
-		{
-			map&lt;unsigned int, string&gt; fileSources;
-
-			// What source does this belong to ?
-			for(map&lt;unsigned int, string&gt;::const_iterator sourceIter = fileSources.begin();
-				sourceIter != fileSources.end(); ++sourceIter)
-			{
-				if (sourceIter-&gt;second.length() &lt; m_dirName.length())
-				{
-					// Skip
-					continue;
-				}
-
-				if (sourceIter-&gt;second.substr(0, m_dirName.length()) == m_dirName)
-				{
-					// That's the one
-					m_sourceId = sourceIter-&gt;first;
-					break;
-				}
-			}
-		}
-	}
-}
-
-DirectoryScannerThread::~DirectoryScannerThread()
-{
-}
-
-string DirectoryScannerThread::getType(void) const
-{
-	return &quot;DirectoryScannerThread&quot;;
-}
-
-string DirectoryScannerThread::getDirectory(void) const
-{
-	return m_dirName;
-}
-
-void DirectoryScannerThread::stop(void)
-{
-	// Disconnect the signal
-	sigc::signal2&lt;void, DocumentInfo, bool&gt;::slot_list_type slotsList = m_signalFileFound.slots();
-	sigc::signal2&lt;void, DocumentInfo, bool&gt;::slot_list_type::iterator slotIter = slotsList.begin();
-	if (slotIter != slotsList.end())
-	{
-		if (slotIter-&gt;empty() == false)
-		{
-			slotIter-&gt;block();
-			slotIter-&gt;disconnect();
-		}
-	}
-	WorkerThread::stop();
-}
-
-sigc::signal2&lt;void, DocumentInfo, bool&gt;&amp; DirectoryScannerThread::getFileFoundSignal(void)
-{
-	return m_signalFileFound;
-}
-
-void DirectoryScannerThread::cacheUpdate(const string &amp;location, time_t mTime,
-	CrawlHistory &amp;crawlHistory)
-{
-	m_updateCache[location] = mTime;
-
-	if (m_updateCache.size() &gt; 500)
-	{
-		flushUpdates(crawlHistory);
-	}
-}
-
-void DirectoryScannerThread::flushUpdates(CrawlHistory &amp;crawlHistory)
-{
-#ifdef DEBUG
-	cout &lt;&lt; &quot;DirectoryScannerThread::flushUpdates: flushing updates&quot; &lt;&lt; endl;
-#endif
-
-	// Update these records
-	crawlHistory.updateItems(m_updateCache, CrawlHistory::CRAWLED);
-	m_updateCache.clear();
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;DirectoryScannerThread::flushUpdates: flushed updates&quot; &lt;&lt; endl;
-#endif
-}
-
-void DirectoryScannerThread::foundFile(const DocumentInfo &amp;docInfo)
-{
-	if ((docInfo.getLocation().empty() == true) ||
-		(m_done == true))
-	{
-		return;
-	}
-
-	if (m_inlineIndexing == true)
-	{
-		// Reset base class members
-		m_docInfo = docInfo;
-		m_docId = 0;
-		m_indexLocation = PinotSettings::getInstance().m_daemonIndexLocation;
-		m_update = false;
-
-		IndexingThread::doWork();
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DirectoryScannerThread::foundFile: indexed &quot; &lt;&lt; docInfo.getLocation() &lt;&lt; &quot; to &quot; &lt;&lt; m_docId &lt;&lt; endl;
-#endif
-	}
-	else
-	{
-		// Delegate indexing
-		m_signalFileFound(docInfo, false);
-	}
-}
-
-bool DirectoryScannerThread::isIndexable(const string &amp;entryName) const
-{
-	string entryDir(path_get_dirname(entryName) + &quot;/&quot;);
-
-	// Is this under one of the locations configured for indexing ?
-	for (set&lt;PinotSettings::IndexableLocation&gt;::const_iterator locationIter = PinotSettings::getInstance().m_indexableLocations.begin();
-		locationIter != PinotSettings::getInstance().m_indexableLocations.end(); ++locationIter)
-	{
-		string locationDir(locationIter-&gt;m_name + &quot;/&quot;);
-
-		if ((entryDir.length() &gt;= locationDir.length()) &amp;&amp;
-			(entryDir.substr(0, locationDir.length()) == locationDir))
-		{
-			// Yes, it is
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DirectoryScannerThread::isIndexable: under &quot; &lt;&lt; locationDir &lt;&lt; endl;
-#endif
-			return true;
-		}
-	}
-
-	return false;
-}
-
-bool DirectoryScannerThread::scanEntry(const string &amp;entryName, CrawlHistory &amp;crawlHistory,
-	bool statLinks)
-{
-	string location(&quot;<A HREF="file://">file://</A>&quot; + entryName);
-	DocumentInfo docInfo(&quot;&quot;, location, &quot;&quot;, &quot;&quot;);
-	CrawlHistory::CrawlStatus itemStatus = CrawlHistory::UNKNOWN;
-	time_t itemDate = time(NULL);
-	struct stat fileStat;
-	int entryStatus = 0;
-	bool scanSuccess = true, reportFile = false, itemExists = false;
-
-	if (entryName.empty() == true)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: no name&quot; &lt;&lt; endl;
-#endif
-		return false;
-	}
-
-	// Skip . .. and dotfiles
-	Url urlObj(location);
-	if (urlObj.getFile()[0] == '.')
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: skipped dotfile &quot; &lt;&lt; urlObj.getFile() &lt;&lt; endl;
-#endif
-		return false;
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: checking &quot; &lt;&lt; entryName &lt;&lt; endl;
-#endif
-
-	// Stat links, or the stuff it refers to ?
-	if (statLinks == true)
-	{
-		entryStatus = lstat(entryName.c_str(), &amp;fileStat);
-	}
-	else
-	{
-		entryStatus = stat(entryName.c_str(), &amp;fileStat);
-	}
-
-	if (entryStatus == -1)
-	{
-		entryStatus = errno;
-		scanSuccess = false;
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: stat failed with error &quot; &lt;&lt; entryStatus &lt;&lt; endl;
-#endif
-	}
-	// Special processing applies if it's a symlink
-	else if (S_ISLNK(fileStat.st_mode))
-	{
-		string realEntryName(entryName);
-		string entryNameReferree;
-		bool isInIndexableLocation = false;
-
-		if (m_followSymLinks == false)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: skipped symlink &quot; &lt;&lt; entryName &lt;&lt; endl;
-#endif
-			return false;
-		}
-
-		// Are we already following a symlink to a directory ?
-		if (m_currentLinks.empty() == false)
-		{
-			string linkToDir(m_currentLinks.top() + &quot;/&quot;);
-
-			// Yes, we are
-			if ((entryName.length() &gt; linkToDir.length()) &amp;&amp;
-				(entryName.substr(0, linkToDir.length()) == linkToDir))
-			{
-				// ...and this entry is below it
-				realEntryName.replace(0, linkToDir.length() - 1, m_currentLinkReferrees.top());
-#ifdef DEBUG
-				cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: really at &quot; &lt;&lt; realEntryName &lt;&lt; endl;
-#endif
-				isInIndexableLocation = isIndexable(realEntryName);
-			}
-		}
-
-		char *pBuf = g_file_read_link(realEntryName.c_str(), NULL);
-		if (pBuf != NULL)
-		{
-			string linkLocation(filename_to_utf8(pBuf));
-			if (path_is_absolute(linkLocation) == true)
-			{
-				entryNameReferree = linkLocation;
-			}
-			else
-			{
-				string entryDir(path_get_dirname(realEntryName));
-				string::size_type prevSlashPos = 0, slashPos = linkLocation.find('/');
-
-				while (slashPos != string::npos)
-				{
-					string path(linkLocation.substr(prevSlashPos, slashPos - prevSlashPos));
-
-					if (path == &quot;..&quot;)
-					{
-						string upDir(path_get_dirname(entryDir));
-						entryDir = upDir;
-					}
-					else if (path != &quot;.&quot;)
-					{
-						entryDir += &quot;/&quot;;
-						entryDir += path;
-					}
-#ifdef DEBUG
-					cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: symlink partially resolved to &quot; &lt;&lt; entryDir &lt;&lt; endl;
-#endif
-
-					if (slashPos + 1 &gt;= linkLocation.length())
-					{
-						// Nothing behind
-						prevSlashPos = string::npos;
-						break;
-					}
-
-					// Next
-					prevSlashPos = slashPos + 1;
-					slashPos = linkLocation.find('/', prevSlashPos);
-				}
-
-				// Remainder
-				if (prevSlashPos != string::npos)
-				{
-					string path(linkLocation.substr(prevSlashPos));
-
-					if (path == &quot;..&quot;)
-					{
-						string upDir(path_get_dirname(entryDir));
-						entryDir = upDir;
-					}
-					else if (path != &quot;.&quot;)
-					{
-						entryDir += &quot;/&quot;;
-						entryDir += path;
-					}
-				}
-
-				entryNameReferree = entryDir;
-			}
-
-			if (entryNameReferree[entryNameReferree.length() - 1] == '/')
-			{
-				// Drop the terminating slash
-				entryNameReferree.resize(entryNameReferree.length() - 1);
-			}
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: symlink resolved to &quot; &lt;&lt; entryNameReferree &lt;&lt; endl;
-#endif
-
-			g_free(pBuf);
-		}
-
-		string referreeLocation(&quot;<A HREF="file://">file://</A>&quot; + entryNameReferree);
-		CrawlHistory::CrawlStatus referreeItemStatus = CrawlHistory::UNKNOWN;
-		time_t referreeItemDate;
-
-		// Check whether this will be, or has already been crawled
-		// Referrees in indexable locations will be indexed later on
-		if ((isInIndexableLocation == false) &amp;&amp;
-			(isIndexable(entryNameReferree) == false) &amp;&amp;
-			(crawlHistory.hasItem(referreeLocation, referreeItemStatus, referreeItemDate) == false))
-		{
-			m_currentLinks.push(entryName);
-			m_currentLinkReferrees.push(entryNameReferree);
-
-			// Add a dummy entry for this referree
-			// It will ensure it's not indexed more than once and it shouldn't do any harm
-			crawlHistory.insertItem(referreeLocation, CrawlHistory::CRAWL_LINK, m_sourceId, itemDate);
-
-			// Do it again, this time by stat'ing what the link refers to
-			bool scannedReferree = scanEntry(entryName, crawlHistory, false);
-
-			m_currentLinks.pop();
-			m_currentLinkReferrees.pop();
-
-			return scannedReferree;
-		}
-		else
-		{
-			cout &lt;&lt; &quot;Skipping &quot; &lt;&lt; entryName &lt;&lt; &quot;: it links to &quot; &lt;&lt; entryNameReferree
-				&lt;&lt; &quot; which will be crawled, or has already been crawled&quot; &lt;&lt; endl;
-
-			// This should ensure that only metadata is indexed
-			docInfo.setType(&quot;inode/symlink&quot;);
-			reportFile = true;
-		}
-	}
-
-	// Is this item in the database already ?
-	itemExists = crawlHistory.hasItem(location, itemStatus, itemDate);
-	if (itemExists == false)
-	{
-		// Record it
-		crawlHistory.insertItem(location, CrawlHistory::CRAWLING, m_sourceId, itemDate);
-	}
-	else if (m_fullScan == true)
-	{
-		// Change the status from TO_CRAWL to CRAWLING
-		crawlHistory.updateItem(location, CrawlHistory::CRAWLING, itemDate);
-	}
-
-	// If stat'ing didn't fail, see if it's a file or a directory
-	if ((entryStatus == 0) &amp;&amp;
-		(S_ISREG(fileStat.st_mode)))
-	{
-		// Is this file blacklisted ?
-		// We have to check early so that if necessary the file's status stays at TO_CRAWL
-		// and it is removed from the index at the end of this crawl
-		if (PinotSettings::getInstance().isBlackListed(entryName) == false)
-		{
-			reportFile = true;
-		}
-	}
-	else if ((entryStatus == 0) &amp;&amp;
-		(S_ISDIR(fileStat.st_mode)))
-	{
-		docInfo.setType(&quot;x-directory/normal&quot;);
-
-		// Can we scan this directory ?
-		if (((m_maxLevel == 0) ||
-			(m_currentLevel &lt; m_maxLevel)) &amp;&amp;
-			(PinotSettings::getInstance().isBlackListed(entryName) == false))
-		{
-			++m_currentLevel;
-
-			// Open the directory
-			DIR *pDir = opendir(entryName.c_str());
-			if (pDir != NULL)
-			{
-#ifdef DEBUG
-				cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: entering &quot; &lt;&lt; entryName &lt;&lt; endl;
-#endif
-				if (m_pMonitor != NULL)
-				{
-					// Monitor first so that we don't miss events
-					// If monitoring is not possible, record the first case
-					if ((m_pMonitor-&gt;addLocation(entryName, true) == false) &amp;&amp;
-						(entryStatus != MONITORING_FAILED))
-					{
-						entryStatus = MONITORING_FAILED;
-					}
-				}
-
-				// Iterate through this directory's entries
-				struct dirent *pDirEntry = readdir(pDir);
-				while ((m_done == false) &amp;&amp;
-					(pDirEntry != NULL))
-				{
-					char *pEntryName = pDirEntry-&gt;d_name;
-
-					// Skip . .. and dotfiles
-					if ((pEntryName != NULL) &amp;&amp;
-						(pEntryName[0] != '.'))
-					{
-						string subEntryName(entryName);
-
-						if (entryName[entryName.length() - 1] != '/')
-						{
-							subEntryName += &quot;/&quot;;
-						}
-						subEntryName += pEntryName;
-
-						// Scan this entry
-						scanEntry(subEntryName, crawlHistory);
-					}
-
-					// Next entry
-					pDirEntry = readdir(pDir);
-				}
-#ifdef DEBUG
-				cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: leaving &quot; &lt;&lt; entryName &lt;&lt; endl;
-#endif
-
-				// Close the directory
-				closedir(pDir);
-				--m_currentLevel;
-				reportFile = true;
-			}
-			else
-			{
-				entryStatus = errno;
-				scanSuccess = false;
-#ifdef DEBUG
-				cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: opendir failed with error &quot; &lt;&lt; entryStatus &lt;&lt; endl;
-#endif
-			}
-		}
-	}
-	// Is it some unknown type ?
-	else if ((entryStatus == 0) &amp;&amp;
-		(!S_ISLNK(fileStat.st_mode)))
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: unknown entry type&quot; &lt;&lt; endl;
-#endif
-		entryStatus = ENOENT;
-		scanSuccess = false;
-	}
-
-	// Was it modified after the last crawl ?
-	if ((itemExists == true) &amp;&amp;
-		(itemDate &gt;= fileStat.st_mtime))
-	{
-		// No, it wasn't
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: not reporting &quot; &lt;&lt; location
-			&lt;&lt; &quot;, status &quot; &lt;&lt; itemStatus &lt;&lt; endl;
-#endif
-		reportFile = false;
-	}
-
-	if (m_done == true)
-	{
-		// Don't record or report the file
-		reportFile = false;
-	}
-	// Did an error occur ?
-	else if (entryStatus != 0)
-	{
-		time_t timeNow = time(NULL);
-
-		// Record this error
-		crawlHistory.updateItem(location, CrawlHistory::CRAWL_ERROR, timeNow, entryStatus);
-
-		if (scanSuccess == false)
-		{
-			return scanSuccess;
-		}
-	}
-	// History of new or modified files, especially their timestamp, is always updated
-	// Others' are updated only if we are doing a full scan because
-	// the status has to be reset to CRAWLED, so that they are not unindexed
-	else if ((itemExists == false) ||
-		(reportFile == true) ||
-		(m_fullScan == true))
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DirectoryScannerThread::scanEntry: updating &quot; &lt;&lt; entryName &lt;&lt; endl;
-#endif
-		cacheUpdate(location, fileStat.st_mtime, crawlHistory);
-	}
-
-	// If a major error occured, this won't be true
-	if (reportFile == true)
-	{
-		set&lt;string&gt; labels;
-		stringstream labelStream;
-
-		if (docInfo.getType().empty() == true)
-		{
-			// Scan the file
-			docInfo.setType(MIMEScanner::scanFile(entryName));
-		}
-		docInfo.setTimestamp(TimeConverter::toTimestamp(fileStat.st_mtime));
-		docInfo.setSize(fileStat.st_size);
-
-		// Insert a label that identifies the source
-		labelStream &lt;&lt; &quot;X-SOURCE&quot; &lt;&lt; m_sourceId;
-		labels.insert(labelStream.str());
-		docInfo.setLabels(labels);
-
-		foundFile(docInfo);
-	}
-
-	return scanSuccess;
-}
-
-void DirectoryScannerThread::doWork(void)
-{
-	CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-	MetaDataBackup metaData(PinotSettings::getInstance().getHistoryDatabaseName());
-	Timer scanTimer;
-	set&lt;string&gt; urls;
-	unsigned int currentOffset = 0;
-
-	if (m_dirName.empty() == true)
-	{
-		return;
-	}
-	scanTimer.start();
-
-	// Remove errors and links
-	crawlHistory.deleteItems(m_sourceId, CrawlHistory::CRAWL_ERROR);
-	crawlHistory.deleteItems(m_sourceId, CrawlHistory::CRAWL_LINK);
-	// ...and entries the previous instance didn't have time to crawl
-	crawlHistory.deleteItems(m_sourceId, CrawlHistory::CRAWLING);
-
-	if (m_fullScan == true)
-	{
-		cout &lt;&lt; &quot;Doing a full scan on &quot; &lt;&lt; m_dirName &lt;&lt; endl;
-
-		// Update this source's items status so that we can detect files that have been deleted
-		crawlHistory.updateItemsStatus(CrawlHistory::TO_CRAWL, m_sourceId);
-	}
-
-	if (scanEntry(m_dirName, crawlHistory) == false)
-	{
-		m_errorNum = OPENDIR_FAILED;
-		m_errorParam = m_dirName;
-	}
-	flushUpdates(crawlHistory);
-	cout &lt;&lt; &quot;Scanned &quot; &lt;&lt; m_dirName &lt;&lt; &quot; in &quot; &lt;&lt; scanTimer.stop() &lt;&lt; &quot; ms&quot; &lt;&lt; endl;
-
-	if (m_done == true)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DirectoryScannerThread::doWork: leaving cleanup until next crawl&quot; &lt;&lt; endl;
-#endif
-		return;
-	}
-
-	if (m_fullScan == true)
-	{
-		scanTimer.start();
-
-		// All files left with status TO_CRAWL were not found in this crawl
-		// Chances are they were removed after the last full scan
-		while ((m_pHandler != NULL) &amp;&amp;
-			(crawlHistory.getSourceItems(m_sourceId, CrawlHistory::TO_CRAWL, urls,
-				currentOffset, currentOffset + 100) &gt; 0))
-		{
-			for (set&lt;string&gt;::const_iterator urlIter = urls.begin();
-				urlIter != urls.end(); ++urlIter)
-			{
-				// Inform the MonitorHandler
-				m_pHandler-&gt;fileDeleted(urlIter-&gt;substr(7));
-
-				// Delete this item
-				crawlHistory.deleteItem(*urlIter);
-				metaData.deleteItem(DocumentInfo(&quot;&quot;, *urlIter, &quot;&quot;, &quot;&quot;), DocumentInfo::SERIAL_ALL);
-			}
-
-			// Next
-			if (urls.size() &lt; 100)
-			{
-				break;
-			}
-			currentOffset += 100;
-		}
-		cout &lt;&lt; &quot;Cleaned up &quot; &lt;&lt; currentOffset + urls.size()
-			&lt;&lt; &quot; history entries in &quot; &lt;&lt; scanTimer.stop() &lt;&lt; &quot; ms&quot; &lt;&lt; endl;
-	}
-
-	if (m_isReindex == true)
-	{
-		urls.clear();
-		currentOffset = 0;
-		scanTimer.start();
-
-		IndexInterface *pIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
-		// Restore user-set metadata, if any
-		while ((pIndex != NULL) &amp;&amp;
-			(pIndex-&gt;isGood() == true) &amp;&amp;
-			(metaData.getItems(string(&quot;<A HREF="file://">file://</A>&quot;) + m_dirName, urls,
-				currentOffset, currentOffset + 100) == true))
-		{
-			for (set&lt;string&gt;::const_iterator urlIter = urls.begin();
-				urlIter != urls.end(); ++urlIter)
-			{
-				unsigned int docId = pIndex-&gt;hasDocument(*urlIter);
-				if (docId == 0)
-				{
-					continue;
-				}
-
-				DocumentInfo docInfo(&quot;&quot;, *urlIter, &quot;&quot;, &quot;&quot;);
-				if (metaData.getItem(docInfo, DocumentInfo::SERIAL_ALL) == true)
-				{
-					pIndex-&gt;updateDocumentInfo(docId, docInfo);
-					pIndex-&gt;setDocumentLabels(docId, docInfo.getLabels(), true);
-				}
-			}
-
-			// Next
-			if (urls.size() &lt; 100)
-			{
-				break;
-			}
-			currentOffset += 100;
-		}
-		cout &lt;&lt; &quot;Restored user-set metadata for &quot; &lt;&lt; currentOffset + urls.size()
-			&lt;&lt; &quot; documents in &quot; &lt;&lt; scanTimer.stop() &lt;&lt; &quot; ms&quot; &lt;&lt; endl;
-	}
-}
-
-#ifdef HAVE_DBUS
-DBusServletThread::DBusServletThread(DaemonState *pServer, DBusServletInfo *pInfo) :
-	WorkerThread(),
-	m_pServer(pServer),
-	m_pServletInfo(pInfo),
-	m_mustQuit(false)
-{
-}
-
-DBusServletThread::~DBusServletThread()
-{
-}
-
-string DBusServletThread::getType(void) const
-{
-	return &quot;DBusServletThread&quot;;
-}
-
-DBusServletInfo *DBusServletThread::getServletInfo(void) const
-{
-	return m_pServletInfo;
-}
-
-bool DBusServletThread::mustQuit(void) const
-{
-	return m_mustQuit;
-}
-
-void DBusServletThread::doWork(void)
-{
-	PinotSettings &amp;settings = PinotSettings::getInstance();
-	IndexInterface *pIndex = settings.getIndex(settings.m_daemonIndexLocation);
-	MetaDataBackup metaData(settings.getHistoryDatabaseName());
-	DBusError error;
-	bool processedMessage = true, updateLabelsCache = false, flushIndex = false;
-
-	if ((m_pServer == NULL) ||
-		(m_pServletInfo == NULL) ||
-		(pIndex == NULL))
-	{
-		return;
-	}
-
-	dbus_error_init(&amp;error);
-
-	// Access the settings' labels list directly
-	set&lt;string&gt; &amp;labelsCache = settings.m_labels;
-	if (labelsCache.empty() == true)
-	{
-		pIndex-&gt;getLabels(labelsCache);
-	}
-
-#ifdef DEBUG
-	const char *pSender = dbus_message_get_sender(m_pServletInfo-&gt;m_pRequest);
-	if (pSender != NULL)
-	{
-		cout &lt;&lt; &quot;DBusServletThread::doWork: called by &quot; &lt;&lt; pSender &lt;&lt; endl;
-	}
-	else
-	{
-		cout &lt;&lt; &quot;DBusServletThread::doWork: called by unknown sender&quot; &lt;&lt; endl;
-	}
-#endif
-
-	if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;GetStatistics&quot;) == TRUE)
-	{
-		CrawlHistory crawlHistory(settings.getHistoryDatabaseName());
-		unsigned int crawledFilesCount = crawlHistory.getItemsCount(CrawlHistory::CRAWLED);
-		unsigned int docsCount = pIndex-&gt;getDocumentsCount();
-		gboolean lowDiskSpace = FALSE, onBattery = FALSE, crawling = FALSE;
-
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusServletThread::doWork: received GetStatistics&quot; &lt;&lt; endl;
-#endif
-		// Prepare the reply
-		if (m_pServletInfo-&gt;newReply() == true)
-		{
-			if (m_pServer-&gt;is_flag_set(DaemonState::LOW_DISK_SPACE) == true)
-			{
-				lowDiskSpace = TRUE;
-			}
-			if (m_pServer-&gt;is_flag_set(DaemonState::ON_BATTERY) == true)
-			{
-				onBattery = TRUE;
-			}
-			if (m_pServer-&gt;is_flag_set(DaemonState::CRAWLING) == true)
-			{
-				crawling = TRUE;
-			}
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: replying with &quot; &lt;&lt; crawledFilesCount
-				&lt;&lt; &quot; &quot; &lt;&lt; docsCount &lt;&lt; &quot; &quot; &lt;&lt; lowDiskSpace &lt;&lt; onBattery &lt;&lt; crawling &lt;&lt; endl;
-#endif
-
-			dbus_message_append_args(m_pServletInfo-&gt;m_pReply,
-				DBUS_TYPE_UINT32, &amp;crawledFilesCount,
-				DBUS_TYPE_UINT32, &amp;docsCount,
-				DBUS_TYPE_BOOLEAN, &amp;lowDiskSpace,
-				DBUS_TYPE_BOOLEAN, &amp;onBattery,
-				DBUS_TYPE_BOOLEAN, &amp;crawling,
-				DBUS_TYPE_INVALID);
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;Reload&quot;) == TRUE)
-	{
-		if (dbus_message_get_args(m_pServletInfo-&gt;m_pRequest, &amp;error,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			gboolean reloading = TRUE;
-
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received Reload&quot; &lt;&lt; endl;
-#endif
-			m_pServer-&gt;reload();
-
-			// Prepare the reply
-			if (m_pServletInfo-&gt;newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo-&gt;m_pReply,
-					DBUS_TYPE_BOOLEAN, &amp;reloading,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;Stop&quot;) == TRUE)
-	{
-		if (dbus_message_get_args(m_pServletInfo-&gt;m_pRequest, &amp;error,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			int exitStatus = EXIT_SUCCESS;
-
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received Stop&quot; &lt;&lt; endl;
-#endif
-			m_pServer-&gt;set_flag(DaemonState::STOPPED);
-
-			// Prepare the reply
-			if (m_pServletInfo-&gt;newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo-&gt;m_pReply,
-					DBUS_TYPE_INT32, &amp;exitStatus,
-					DBUS_TYPE_INVALID);
-			}
-
-			m_mustQuit = true;
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;HasDocument&quot;) == TRUE)
-	{
-		char *pUrl = NULL;
-		unsigned int docId = 0;
-
-		if (dbus_message_get_args(m_pServletInfo-&gt;m_pRequest, &amp;error,
-			DBUS_TYPE_STRING, &amp;pUrl,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received HasDocument &quot; &lt;&lt; pUrl &lt;&lt; endl;
-#endif
-			if (pUrl != NULL)
-			{
-				string url(pUrl);
-
-				// Check the index
-				docId = pIndex-&gt;hasDocument(url);
-			}
-
-			// Prepare the reply
-			if (m_pServletInfo-&gt;newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo-&gt;m_pReply,
-					DBUS_TYPE_UINT32, &amp;docId,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;GetLabels&quot;) == TRUE)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusServletThread::doWork: received GetLabels&quot; &lt;&lt; endl;
-#endif
-		// This method doesn't take any argument
-		m_pServletInfo-&gt;m_pArray = g_ptr_array_new();
-
-		for (set&lt;string&gt;::const_iterator labelIter = labelsCache.begin();
-			labelIter != labelsCache.end(); ++labelIter)
-		{
-			string labelName(*labelIter);
-
-			g_ptr_array_add(m_pServletInfo-&gt;m_pArray, const_cast&lt;char*&gt;(labelName.c_str()));
-		}
-
-		// Prepare the reply
-		m_pServletInfo-&gt;newReplyWithArray();
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;AddLabel&quot;) == TRUE)
-	{
-		char *pLabel = NULL;
-
-		if (dbus_message_get_args(m_pServletInfo-&gt;m_pRequest, &amp;error,
-			DBUS_TYPE_STRING, &amp;pLabel,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received AddLabel &quot; &lt;&lt; pLabel &lt;&lt; endl;
-#endif
-			if (pLabel != NULL)
-			{
-				string labelName(pLabel);
-
-				// Add the label
-				flushIndex = pIndex-&gt;addLabel(labelName);
-				// Is this a known label ?
-				if (labelsCache.find(labelName) == labelsCache.end())
-				{
-					// No, it isn't but that's okay
-					labelsCache.insert(labelName);
-					updateLabelsCache = true;
-				}
-			}
-
-			// Prepare the reply
-			if (m_pServletInfo-&gt;newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo-&gt;m_pReply,
-					DBUS_TYPE_STRING, &amp;pLabel,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;RenameLabel&quot;) == TRUE)
-	{
-		char *pOldLabel = NULL;
-		char *pNewLabel = NULL;
-
-		if (dbus_message_get_args(m_pServletInfo-&gt;m_pRequest, &amp;error,
-			DBUS_TYPE_STRING, &amp;pOldLabel,
-			DBUS_TYPE_STRING, &amp;pNewLabel,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			// Nothing to do, this was obsoleted
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received RenameLabel &quot; &lt;&lt; pOldLabel &lt;&lt; &quot;, &quot; &lt;&lt; pNewLabel &lt;&lt; endl;
-#endif
-			
-			// Prepare the reply
-			if (m_pServletInfo-&gt;newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo-&gt;m_pReply,
-					DBUS_TYPE_STRING, &amp;pNewLabel,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;DeleteLabel&quot;) == TRUE)
-	{
-		char *pLabel = NULL;
-
-		if (dbus_message_get_args(m_pServletInfo-&gt;m_pRequest, &amp;error,
-			DBUS_TYPE_STRING, &amp;pLabel,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received DeleteLabel &quot; &lt;&lt; pLabel &lt;&lt; endl;
-#endif
-			if (pLabel != NULL)
-			{
-				// Delete the label
-				flushIndex = pIndex-&gt;deleteLabel(pLabel);
-				// Update the labels list
-				set&lt;string&gt;::const_iterator labelIter = labelsCache.find(pLabel);
-				if (labelIter != labelsCache.end())
-				{
-					labelsCache.erase(labelIter);
-					updateLabelsCache = true;
-				}
-
-				// Update the metadata backup
-				metaData.deleteLabel(pLabel);
-			}
-
-			// Prepare the reply
-			if (m_pServletInfo-&gt;newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo-&gt;m_pReply,
-					DBUS_TYPE_STRING, &amp;pLabel,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;GetDocumentLabels&quot;) == TRUE)
-	{
-		unsigned int docId = 0;
-
-		if (dbus_message_get_args(m_pServletInfo-&gt;m_pRequest, &amp;error,
-			DBUS_TYPE_UINT32, &amp;docId,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			set&lt;string&gt; labels;
-
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received GetDocumentLabels &quot; &lt;&lt; docId &lt;&lt; endl;
-#endif
-			if (pIndex-&gt;getDocumentLabels(docId, labels) == true)
-			{
-				m_pServletInfo-&gt;m_pArray = g_ptr_array_new();
-
-				for (set&lt;string&gt;::const_iterator labelIter = labels.begin();
-					labelIter != labels.end(); ++labelIter)
-				{
-					string labelName(*labelIter);
-
-					g_ptr_array_add(m_pServletInfo-&gt;m_pArray, const_cast&lt;char*&gt;(labelName.c_str()));
-				}
-
-				// Prepare the reply
-				m_pServletInfo-&gt;newReplyWithArray();
-			}
-			else
-			{
-				m_pServletInfo-&gt;newErrorReply(&quot;de.berlios.Pinot.GetDocumentLabels&quot;,
-					&quot; failed&quot;);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;SetDocumentLabels&quot;) == TRUE)
-	{
-		char **ppLabels = NULL;
-		dbus_uint32_t labelsCount = 0;
-		unsigned int docId = 0;
-		gboolean resetLabels = TRUE;
-
-		if (dbus_message_get_args(m_pServletInfo-&gt;m_pRequest, &amp;error,
-			DBUS_TYPE_UINT32, &amp;docId,
-			DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &amp;ppLabels, &amp;labelsCount,
-			DBUS_TYPE_BOOLEAN, &amp;resetLabels,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			set&lt;string&gt; labels;
-
-			for (dbus_uint32_t labelIndex = 0; labelIndex &lt; labelsCount; ++labelIndex)
-			{
-				if (ppLabels[labelIndex] == NULL)
-				{
-					break;
-				}
-
-				string labelName(ppLabels[labelIndex]);
-				labels.insert(labelName);
-				// Is this a known label ?
-				if (labelsCache.find(labelName) == labelsCache.end())
-				{
-					// No, it isn't but that's okay
-					labelsCache.insert(labelName);
-					updateLabelsCache = true;
-				}
-			}
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received SetDocumentLabels on ID &quot; &lt;&lt; docId
-				&lt;&lt; &quot;, &quot; &lt;&lt; labelsCount &lt;&lt; &quot; labels&quot; &lt;&lt; &quot;, &quot; &lt;&lt; resetLabels &lt;&lt; endl;
-#endif
-
-			// Set labels
-			flushIndex = pIndex-&gt;setDocumentLabels(docId, labels, ((resetLabels == TRUE) ? true : false));
-
-			// Update the metadata backup
-			updateLabels(docId, metaData, pIndex, labels, resetLabels);
-
-			// Free container types
-			g_strfreev(ppLabels);
-
-			// Prepare the reply
-			if (m_pServletInfo-&gt;newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo-&gt;m_pReply,
-					DBUS_TYPE_UINT32, &amp;docId,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;SetDocumentsLabels&quot;) == TRUE)
-	{
-		char **ppDocIds = NULL;
-		char **ppLabels = NULL;
-		dbus_uint32_t idsCount = 0;
-		dbus_uint32_t labelsCount = 0;
-		gboolean resetLabels = TRUE;
-
-		if (dbus_message_get_args(m_pServletInfo-&gt;m_pRequest, &amp;error,
-			DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &amp;ppDocIds, &amp;idsCount,
-			DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &amp;ppLabels, &amp;labelsCount,
-			DBUS_TYPE_BOOLEAN, &amp;resetLabels,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			set&lt;unsigned int&gt; docIds;
-			set&lt;string&gt; labels;
-
-			for (dbus_uint32_t idIndex = 0; idIndex &lt; idsCount; ++idIndex)
-			{
-				if (ppDocIds[idIndex] == NULL)
-				{
-					break;
-				}
-
-				docIds.insert((unsigned int)atoi(ppDocIds[idIndex]));
-			}
-			for (dbus_uint32_t labelIndex = 0; labelIndex &lt; labelsCount; ++labelIndex)
-			{
-				if (ppLabels[labelIndex] == NULL)
-				{
-					break;
-				}
-
-				string labelName(ppLabels[labelIndex]);
-				labels.insert(labelName);
-				// Is this a known label ?
-				if (labelsCache.find(labelName) == labelsCache.end())
-				{
-					// No, it isn't but that's okay
-					labelsCache.insert(labelName);
-					updateLabelsCache = true;
-				}
-			}
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received SetDocumentsLabels on &quot; &lt;&lt; docIds.size()
-				&lt;&lt; &quot; IDs, &quot; &lt;&lt; labelsCount &lt;&lt; &quot; labels&quot; &lt;&lt; &quot;, &quot; &lt;&lt; resetLabels &lt;&lt; endl;
-#endif
-			// Set labels
-			if (pIndex-&gt;setDocumentsLabels(docIds, labels, ((resetLabels == TRUE) ? true : false)) == true)
-			{
-				resetLabels = TRUE;
-				flushIndex = true;
-			}
-
-			// Update the metadata backup
-			for (set&lt;unsigned int&gt;::const_iterator docIter = docIds.begin();
-				docIter != docIds.end(); ++docIter)
-			{
-				updateLabels(*docIter, metaData, pIndex, labels, resetLabels);
-			}
-
-			// Free container types
-			g_strfreev(ppDocIds);
-			g_strfreev(ppLabels);
-
-			// Prepare the reply
-			if (m_pServletInfo-&gt;newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo-&gt;m_pReply,
-					DBUS_TYPE_BOOLEAN, &amp;resetLabels,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;GetDocumentInfo&quot;) == TRUE)
-	{
-		unsigned int docId = 0;
-
-		if (dbus_message_get_args(m_pServletInfo-&gt;m_pRequest, &amp;error,
-			DBUS_TYPE_UINT32, &amp;docId,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			DocumentInfo docInfo;
-
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received GetDocumentInfo on &quot; &lt;&lt; docId &lt;&lt; endl;
-#endif
-			if (pIndex-&gt;getDocumentInfo(docId, docInfo) == true)
-			{
-				// Prepare the reply
-				if (m_pServletInfo-&gt;newReply() == true)
-				{
-					DBusMessageIter iter;
-
-					dbus_message_iter_init_append(m_pServletInfo-&gt;m_pReply, &amp;iter);
-					if (DBusIndex::documentInfoToDBus(&amp;iter, 0, docInfo) == false)
-					{
-						dbus_message_unref(m_pServletInfo-&gt;m_pReply);
-						m_pServletInfo-&gt;newErrorReply(&quot;de.berlios.Pinot.GetDocumentInfo&quot;,
-							&quot;Unknown error&quot;);
-					}
-				}
-			}
-			else
-			{
-				m_pServletInfo-&gt;newErrorReply(&quot;de.berlios.Pinot.GetDocumentInfo&quot;,
-					&quot;Unknown document&quot;);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;SetDocumentInfo&quot;) == TRUE)
-	{
-		DBusMessageIter iter;
-		DocumentInfo docInfo;
-		unsigned int docId = 0;
-
-		dbus_message_iter_init(m_pServletInfo-&gt;m_pRequest, &amp;iter);
-		if (DBusIndex::documentInfoFromDBus(&amp;iter, docId, docInfo) == false)
-		{
-			m_pServletInfo-&gt;newErrorReply(&quot;de.berlios.Pinot.SetDocumentInfo&quot;,
-				&quot;Unknown error&quot;);
-		}
-		else
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received SetDocumentInfo on &quot; &lt;&lt; docId &lt;&lt; endl;
-#endif
-
-			// Update the document info
-			flushIndex = pIndex-&gt;updateDocumentInfo(docId, docInfo);
-
-			// Update the metadata backup
-			metaData.addItem(docInfo, DocumentInfo::SERIAL_FIELDS);
-
-			// Prepare the reply
-			if (m_pServletInfo-&gt;newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo-&gt;m_pReply,
-					DBUS_TYPE_UINT32, &amp;docId,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;Query&quot;) == TRUE)
-	{
-		char *pSearchText = NULL;
-		char *pEngineType = NULL;
-		char *pEngineOption = NULL;
-		dbus_uint32_t startDoc = 0, maxHits = 0;
-
-		if (dbus_message_get_args(m_pServletInfo-&gt;m_pRequest, &amp;error,
-			DBUS_TYPE_STRING, &amp;pEngineType,
-			DBUS_TYPE_STRING, &amp;pEngineOption,
-			DBUS_TYPE_STRING, &amp;pSearchText,
-			DBUS_TYPE_UINT32, &amp;startDoc,
-			DBUS_TYPE_UINT32, &amp;maxHits,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			bool replyWithError = true;
-
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received Query &quot; &lt;&lt; pSearchText &lt;&lt; &quot;, &quot; &lt;&lt; startDoc &lt;&lt; &quot;/&quot; &lt;&lt; maxHits &lt;&lt; endl;
-#endif
-			if (pSearchText != NULL)
-			{
-				stringstream queryNameStr;
-
-				// Give the query a unique name
-				queryNameStr &lt;&lt; &quot;DBUS&quot; &lt;&lt; m_id;
-				m_pServletInfo-&gt;m_simpleQuery = false;
-
-				QueryProperties queryProps(queryNameStr.str(), pSearchText);
-				queryProps.setMaximumResultsCount(maxHits);
-
-				string engineType, engineOption;
-
-				// Provide reasonable defaults 
-				if (((pEngineType == NULL) || (strlen(pEngineType) == 0)) &amp;&amp;
-					((pEngineOption == NULL) || (strlen(pEngineOption) == 0)))
-				{
-					engineType = settings.m_defaultBackend;
-					engineOption = settings.m_daemonIndexLocation;
-				}
-				else
-				{
-					engineType = pEngineType;
-					engineOption = pEngineOption;
-				}
-
-				m_pServletInfo-&gt;m_pThread = new EngineQueryThread(engineType,
-					engineType, engineOption, queryProps, startDoc);
-			}
-
-			if (replyWithError == true)
-			{
-				m_pServletInfo-&gt;newErrorReply(&quot;de.berlios.Pinot.SimpleQuery&quot;,
-					&quot;Query failed&quot;);
-			}
-		}
-	}
-	// FIXME: this method will soon be obsoleted
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;SimpleQuery&quot;) == TRUE)
-	{
-		char *pSearchText = NULL;
-		dbus_uint32_t maxHits = 0;
-
-		if (dbus_message_get_args(m_pServletInfo-&gt;m_pRequest, &amp;error,
-			DBUS_TYPE_STRING, &amp;pSearchText,
-			DBUS_TYPE_UINT32, &amp;maxHits,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			bool replyWithError = true;
-
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received SimpleQuery &quot; &lt;&lt; pSearchText &lt;&lt; &quot;, &quot; &lt;&lt; maxHits &lt;&lt; endl;
-#endif
-			if (pSearchText != NULL)
-			{
-				stringstream queryNameStr;
-
-				// Give the query a unique name
-				queryNameStr &lt;&lt; &quot;DBUS&quot; &lt;&lt; m_id;
-				m_pServletInfo-&gt;m_simpleQuery = true;
-
-				QueryProperties queryProps(queryNameStr.str(), pSearchText);
-				queryProps.setMaximumResultsCount(maxHits);
-
-				m_pServletInfo-&gt;m_pThread = new EngineQueryThread(settings.m_defaultBackend,
-					settings.m_defaultBackend, settings.m_daemonIndexLocation,
-					queryProps, 0);
-			}
-
-			if (replyWithError == true)
-			{
-				m_pServletInfo-&gt;newErrorReply(&quot;de.berlios.Pinot.SimpleQuery&quot;,
-					&quot;Query failed&quot;);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;de.berlios.Pinot&quot;, &quot;UpdateDocument&quot;) == TRUE)
-	{
-		unsigned int docId = 0;
-
-		if (dbus_message_get_args(m_pServletInfo-&gt;m_pRequest, &amp;error,
-			DBUS_TYPE_UINT32, &amp;docId,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-			DocumentInfo docInfo;
-
-#ifdef DEBUG
-			cout &lt;&lt; &quot;DBusServletThread::doWork: received UpdateDocument &quot; &lt;&lt; docId &lt;&lt; endl;
-#endif
-			if (pIndex-&gt;getDocumentInfo(docId, docInfo) == true)
-			{
-				// Update document
-				m_pServer-&gt;queue_index(docInfo);
-			}
-
-			// Prepare the reply
-			if (m_pServletInfo-&gt;newReply() == true)
-			{
-				dbus_message_append_args(m_pServletInfo-&gt;m_pReply,
-					DBUS_TYPE_UINT32, &amp;docId,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else if (dbus_message_is_method_call(m_pServletInfo-&gt;m_pRequest, &quot;org.freedesktop.DBus.Introspectable&quot;, &quot;Introspect&quot;) == TRUE)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusServletThread::doWork: received Introspect&quot; &lt;&lt; endl;
-#endif
-		if (loadXMLDescription() == true)
-		{
-			// Prepare the reply
-			if (m_pServletInfo-&gt;newReply() == true)
-			{
-				const char *pXmlData = g_xmlDescription.c_str();
-
-				dbus_message_append_args(m_pServletInfo-&gt;m_pReply,
-					DBUS_TYPE_STRING, &amp;pXmlData,
-					DBUS_TYPE_INVALID);
-			}
-		}
-	}
-	else
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusServletThread::doWork: foreign message for/from &quot; &lt;&lt; dbus_message_get_interface(m_pServletInfo-&gt;m_pRequest)
-			&lt;&lt; &quot; &quot; &lt;&lt; dbus_message_get_member(m_pServletInfo-&gt;m_pRequest) &lt;&lt; endl;
-#endif
-		processedMessage = false;
-	}
-
-	// Did an error occur ?
-	if (error.message != NULL)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusServletThread::doWork: error occured: &quot; &lt;&lt; error.message &lt;&lt; endl;
-#endif
-		// Use the error message as reply
-		m_pServletInfo-&gt;newErrorReply(error.name, error.message);
-	}
-
-	dbus_error_free(&amp;error);
-
-	// Set labels ?
-	if ((updateLabelsCache == true) &amp;&amp;
-		(pIndex-&gt;setLabels(labelsCache, false) == false))
-	{
-		// Updating failed... reset the cache
-		labelsCache.clear();
-		pIndex-&gt;getLabels(labelsCache);
-#ifdef DEBUG
-		cout &lt;&lt; &quot;DBusServletThread::doWork: failed to update labels&quot; &lt;&lt; endl;
-#endif
-	}
-
-	// Flush the index ?
-	if (flushIndex == true)
-	{
-		// Flush now for the sake of the client application
-		pIndex-&gt;flush();
-	}
-
-	delete pIndex;
-}
-#endif
-

Deleted: trunk/UI/GTK2/src/ServerThreads.h
===================================================================
--- trunk/UI/GTK2/src/ServerThreads.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/ServerThreads.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,111 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _SERVERTHREADS_HH
-#define _SERVERTHREADS_HH
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;stack&gt;
-#include &lt;sigc++/sigc++.h&gt;
-#include &lt;glibmm/ustring.h&gt;
-
-#include &quot;DocumentInfo.h&quot;
-#include &quot;CrawlHistory.h&quot;
-#include &quot;MonitorInterface.h&quot;
-#include &quot;MonitorHandler.h&quot;
-#include &quot;QueryProperties.h&quot;
-#include &quot;DaemonState.h&quot;
-#include &quot;WorkerThreads.h&quot;
-
-class DirectoryScannerThread : public IndexingThread
-{
-	public:
-		DirectoryScannerThread(const std::string &amp;dirName, bool isSource,
-			bool fullScan, bool isReindex,
-			MonitorInterface *pMonitor, MonitorHandler *pHandler,
-			unsigned int maxLevel = 0, bool inlineIndexing = false,
-			bool followSymLinks = true);
-		virtual ~DirectoryScannerThread();
-
-		virtual std::string getType(void) const;
-
-		virtual std::string getDirectory(void) const;
-
-		virtual void stop(void);
-
-		sigc::signal2&lt;void, DocumentInfo, bool&gt;&amp; getFileFoundSignal(void);
-
-	protected:
-		std::string m_dirName;
-		bool m_fullScan;
-		bool m_isReindex;
-		MonitorInterface *m_pMonitor;
-		MonitorHandler *m_pHandler;
-		unsigned int m_sourceId;
-		unsigned int m_currentLevel;
-		unsigned int m_maxLevel;
-		bool m_inlineIndexing;
-		bool m_followSymLinks;
-		sigc::signal2&lt;void, DocumentInfo, bool&gt; m_signalFileFound;
-		std::map&lt;std::string, time_t&gt; m_updateCache;
-		std::stack&lt;std::string&gt; m_currentLinks;
-		std::stack&lt;std::string&gt; m_currentLinkReferrees;
-
-		void cacheUpdate(const std::string &amp;location, time_t mTime, CrawlHistory &amp;crawlHistory);
-		void flushUpdates(CrawlHistory &amp;crawlHistory);
-		void foundFile(const DocumentInfo &amp;docInfo);
-		bool isIndexable(const std::string &amp;entryName) const;
-		bool scanEntry(const std::string &amp;entryName, CrawlHistory &amp;crawlHistory,
-			bool statLinks = true);
-		virtual void doWork(void);
-
-	private:
-		DirectoryScannerThread(const DirectoryScannerThread &amp;other);
-		DirectoryScannerThread &amp;operator=(const DirectoryScannerThread &amp;other);
-
-};
-
-#ifdef HAVE_DBUS
-class DBusServletThread : public WorkerThread
-{
-	public:
-		DBusServletThread(DaemonState *pServer, DBusServletInfo *pInfo);
-		virtual ~DBusServletThread();
-
-		virtual std::string getType(void) const;
-
-		DBusServletInfo *getServletInfo(void) const;
-
-		bool mustQuit(void) const;
-
-	protected:
-		DaemonState *m_pServer;
-		DBusServletInfo *m_pServletInfo;
-		bool m_mustQuit;
-
-		virtual void doWork(void);
-
-	private:
-		DBusServletThread(const DBusServletThread &amp;other);
-		DBusServletThread &amp;operator=(const DBusServletThread &amp;other);
-
-};
-#endif
-
-#endif // _SERVERTHREADS_HH

Deleted: trunk/UI/GTK2/src/UniqueApplication.cpp
===================================================================
--- trunk/UI/GTK2/src/UniqueApplication.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/UniqueApplication.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,177 +0,0 @@
-/*
- *  Copyright 2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;sys/types.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;iostream&gt;
-#include &lt;fstream&gt;
-#include &lt;sstream&gt;
-
-#include &quot;UniqueApplication.h&quot;
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-using std::fstream;
-using std::stringstream;
-
-UniqueApplication::UniqueApplication(const string &amp;name)
-{
-#ifdef HAVE_UNIQUE
-	m_pApp = unique_app_new(name.c_str(), NULL);
-#ifdef DEBUG
-	if (m_pApp != NULL)
-	{
-		cout &lt;&lt; &quot;UniqueApplication: registered&quot; &lt;&lt; endl;
-	}
-	else
-	{
-		cout &lt;&lt; &quot;UniqueApplication: failed to register&quot; &lt;&lt; endl;
-	}
-#endif
-#endif
-}
-
-UniqueApplication::~UniqueApplication()
-{
-#ifdef HAVE_UNIQUE
-	if (m_pApp != NULL)
-	{
-		g_object_unref(m_pApp);
-	}
-#endif
-}
-
-bool UniqueApplication::isRunning(void)
-{
-#ifdef HAVE_UNIQUE
-	if ((m_pApp != NULL) &amp;&amp;
-		(unique_app_is_running(m_pApp) == TRUE))
-	{
-		return true;
-	}
-#endif
-
-	return false;
-}
-
-bool UniqueApplication::isRunning(const string &amp;pidFileName, const string &amp;processName)
-{
-	fstream pidFile;
-
-	// Open the PID file
-	pidFile.open(pidFileName.c_str(), std::ios::in);
-	if (pidFile.is_open() == false)
-	{
-		// The application may still be running even though the PID file doesn't exist
-		if (isRunning() == true)
-		{
-			return true;
-		}
-		// Keep going
-	}
-	else
-	{
-		pid_t processID = 0;
-		bool stillRunning = false, processDied = false;
-
-		pidFile &gt;&gt; processID;
-		pidFile.close();
-
-		// Is another process running ?
-		if (processID &gt; 0)
-		{
-#ifdef HAVE_UNIQUE
-			if (m_pApp != NULL)
-			{
-				if (unique_app_is_running(m_pApp) == TRUE)
-				{
-					// It's still running
-					stillRunning = true;
-				}
-				else
-				{
-					// It most likely died
-					processDied = true;
-				}
-			}
-#else
-			fstream cmdLineFile;
-			stringstream cmdLineFileName;
-			bool checkProcess = true;
-
-			// FIXME: check for existence of /proc
-			cmdLineFileName &lt;&lt; &quot;/proc/&quot; &lt;&lt; processID &lt;&lt; &quot;/cmdline&quot;;
-			cmdLineFile.open(cmdLineFileName.str().c_str(), std::ios::in);
-			if (cmdLineFile.is_open() == true)
-			{
-				string cmdLine;
-
-				cmdLineFile &gt;&gt; cmdLine;
-				cmdLineFile.close();
-
-				if (cmdLine.find(processName) == string::npos)
-				{
-					// It's another process
-					checkProcess = false;
-					processDied = true;
-				}
-			}
-
-			if (checkProcess == true)
-			{
-				if (kill(processID, 0) == 0)
-				{
-					// It's still running
-					stillRunning = true;
-				}
-				else if (errno == ESRCH)
-				{
-					// This PID doesn't exist
-					processDied = true;
-				}
-			}
-#endif
-
-			if (stillRunning == true)
-			{
-				cout &lt;&lt; &quot;Process &quot; &lt;&lt; processName &lt;&lt; &quot; (&quot; &lt;&lt; processID &lt;&lt; &quot;) is still running&quot; &lt;&lt; endl;
-				return true;
-			}
-
-			if (processDied == true)
-			{
-				cerr &lt;&lt; &quot;Previous instance &quot; &lt;&lt; processID &lt;&lt; &quot; died prematurely&quot; &lt;&lt; endl;
-			}
-		}
-	}
-
-	// Now save our PID
-	pidFile.open(pidFileName.c_str(), std::ios::out);
-	if (pidFile.is_open() == true)
-	{
-		pidFile &lt;&lt; getpid() &lt;&lt; endl;
-		pidFile.close();
-	}
-
-	return false;
-}
-

Deleted: trunk/UI/GTK2/src/UniqueApplication.h
===================================================================
--- trunk/UI/GTK2/src/UniqueApplication.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/UniqueApplication.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,49 +0,0 @@
-/*
- *  Copyright 2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _UNIQUEAPPLICATION_HH
-#define _UNIQUEAPPLICATION_HH
-
-#include &lt;string&gt;
-
-#ifdef HAVE_UNIQUE
-#include &lt;unique/unique.h&gt;
-#endif
-
-class UniqueApplication
-{
-	public:
-		UniqueApplication(const std::string &amp;name);
-		~UniqueApplication();
-
-		bool isRunning(void);
-
-		bool isRunning(const std::string &amp;pidFileName,
-			const std::string &amp;processName);
-
-	private:
-#ifdef HAVE_UNIQUE
-		UniqueApp *m_pApp;
-#endif
-
-		UniqueApplication(const UniqueApplication &amp;other);
-		UniqueApplication &amp;operator=(const UniqueApplication &amp;other);
-
-};
-
-#endif // _UNIQUEAPPLICATION_HH

Deleted: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,2260 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;string.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;time.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;exception&gt;
-#include &lt;iostream&gt;
-#include &lt;fstream&gt;
-#include &lt;glibmm/miscutils.h&gt;
-#include &lt;glibmm/exception.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;NLS.h&quot;
-#include &quot;Languages.h&quot;
-#include &quot;MIMEScanner.h&quot;
-#include &quot;StringManip.h&quot;
-#include &quot;TimeConverter.h&quot;
-#include &quot;Timer.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;HtmlFilter.h&quot;
-#include &quot;FilterUtils.h&quot;
-#include &quot;ActionQueue.h&quot;
-#include &quot;CrawlHistory.h&quot;
-#include &quot;QueryHistory.h&quot;
-#include &quot;DownloaderFactory.h&quot;
-#include &quot;FilterWrapper.h&quot;
-#include &quot;ModuleFactory.h&quot;
-#include &quot;WebEngine.h&quot;
-#include &quot;PinotSettings.h&quot;
-#include &quot;WorkerThreads.h&quot;
-
-using namespace Glib;
-using namespace std;
-
-// A function object to stop threads with for_each()
-struct StopThreadFunc
-{
-public:
-	void operator()(map&lt;unsigned int, WorkerThread *&gt;::value_type &amp;p)
-	{
-		p.second-&gt;stop();
-#ifdef DEBUG
-		cout &lt;&lt; &quot;StopThreadFunc: stopped thread &quot; &lt;&lt; p.second-&gt;getId() &lt;&lt; endl;
-#endif
-		Thread::yield();
-	}
-};
-
-Dispatcher WorkerThread::m_dispatcher;
-pthread_mutex_t WorkerThread::m_dispatcherMutex = PTHREAD_MUTEX_INITIALIZER;
-bool WorkerThread::m_immediateFlush = true;
-
-string WorkerThread::errorToString(int errorNum)
-{
-	if (errorNum == 0)
-	{
-		return &quot;&quot;;
-	}
-
-	if (errorNum &lt; INDEX_ERROR)
-	{
-		return strerror(errorNum);
-	}
-
-	// Internal error codes
-	switch (errorNum)
-	{
-		case INDEX_ERROR:
-			return _(&quot;Index error&quot;);
-		case INDEXING_FAILED:
-			return _(&quot;Couldn't index document&quot;);
-		case UPDATE_FAILED:
-			return _(&quot;Couldn't update document&quot;);
-		case UNINDEXING_FAILED:
-			return _(&quot;Couldn't unindex document(s)&quot;);
-		case QUERY_FAILED:
-			return _(&quot;Couldn't run query on search engine&quot;);
-		case HISTORY_FAILED:
-			return _(&quot;Couldn't get history for search engine&quot;);
-		case DOWNLOAD_FAILED:
-			return _(&quot;Couldn't retrieve document&quot;);
-		case MONITORING_FAILED:
-			return _(&quot;File monitor error&quot;);
-		case OPENDIR_FAILED:
-			return _(&quot;Couldn't open directory&quot;);
-		case UNKNOWN_INDEX:
-			return _(&quot;Index doesn't exist&quot;);
-		case UNKNOWN_ENGINE:
-			return  _(&quot;Couldn't create search engine&quot;);
-		case UNSUPPORTED_TYPE:
-			return _(&quot;Cannot index document type&quot;);
-		case UNSUPPORTED_PROTOCOL:
-			return _(&quot;No downloader for this protocol&quot;);
-		case ROBOTS_FORBIDDEN:
-			return _(&quot;Robots META tag forbids indexing&quot;);
-		case NO_MONITORING:
-			return _(&quot;No monitoring handler&quot;);
-		default:
-			break;
-	}
-
-	return _(&quot;Unknown error&quot;);
-}
-
-Dispatcher &amp;WorkerThread::getDispatcher(void)
-{
-	return m_dispatcher;
-}
-
-void WorkerThread::immediateFlush(bool doFlush)
-{
-	m_immediateFlush = doFlush;
-}
-
-WorkerThread::WorkerThread() :
-	m_startTime(time(NULL)),
-	m_id(ThreadsManager::get_next_id()),
-	m_background(false),
-	m_stopped(false),
-	m_done(false),
-	m_errorNum(0)
-{
-}
-
-WorkerThread::~WorkerThread()
-{
-}
-
-time_t WorkerThread::getStartTime(void) const
-{
-	return m_startTime;
-}
-
-void WorkerThread::setId(unsigned int id)
-{
-	m_id = id;
-}
-
-unsigned int WorkerThread::getId(void) const
-{
-	return m_id;
-}
-
-void WorkerThread::inBackground(void)
-{
-	m_background = true;
-}
-
-bool WorkerThread::isBackground(void) const
-{
-	return m_background;
-}
-
-bool WorkerThread::operator&lt;(const WorkerThread &amp;other) const
-{
-	return m_id &lt; other.m_id;
-}
-
-Glib::Thread *WorkerThread::start(void)
-{
-#ifdef DEBUG
-	cout &lt;&lt; &quot;WorkerThread::start: &quot; &lt;&lt; getType() &lt;&lt; &quot; &quot; &lt;&lt; m_id &lt;&lt; endl;
-#endif
-	// Create non-joinable threads
-	return Thread::create(sigc::mem_fun(*this, &amp;WorkerThread::threadHandler), false);
-}
-
-void WorkerThread::stop(void)
-{
-	m_stopped = m_done = true;
-}
-
-bool WorkerThread::isStopped(void) const
-{
-	return m_stopped;
-}
-
-bool WorkerThread::isDone(void) const
-{
-	return m_done;
-}
-
-int WorkerThread::getErrorNum(void) const
-{
-	return m_errorNum;
-}
-
-string WorkerThread::getStatus(void) const
-{
-	string status(errorToString(m_errorNum));
-
-	if ((status.empty() == false) &amp;&amp;
-		(m_errorParam.empty() == false))
-	{
-		status += &quot; (&quot;;
-		status += m_errorParam;
-		status += &quot;)&quot;;
-	}
-
-	return status;
-}
-
-void WorkerThread::threadHandler(void)
-{
-#ifdef DEBUG
-	cout &lt;&lt; &quot;WorkerThread::threadHandler: thread &quot; &lt;&lt; m_id &lt;&lt; endl;
-#endif
-	try
-	{
-		doWork();
-	}
-	catch (Glib::Exception &amp;ex)
-	{
-		cerr &lt;&lt; &quot;Glib exception in thread &quot; &lt;&lt; m_id &lt;&lt; &quot;, type &quot; &lt;&lt; getType()
-			&lt;&lt; &quot;:&quot; &lt;&lt; ex.what() &lt;&lt; endl;
-		m_errorNum = UNKNOWN_ERROR;
-	}
-	catch (std::exception &amp;ex)
-	{
-		cerr &lt;&lt; &quot;STL exception in thread &quot; &lt;&lt; m_id &lt;&lt; &quot;, type &quot; &lt;&lt; getType()
-			&lt;&lt; &quot;:&quot; &lt;&lt; ex.what() &lt;&lt; endl;
-		m_errorNum = UNKNOWN_ERROR;
-	}
-	catch (...)
-	{
-		cerr &lt;&lt; &quot;Unknown exception in thread &quot; &lt;&lt; m_id &lt;&lt; &quot;, type &quot; &lt;&lt; getType() &lt;&lt; endl;
-		m_errorNum = UNKNOWN_ERROR;
-	}
-
-	emitSignal();
-}
-
-void WorkerThread::emitSignal(void)
-{
-	m_done = true;
-	if (pthread_mutex_lock(&amp;m_dispatcherMutex) == 0)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;WorkerThread::emitSignal: signaling end of thread &quot; &lt;&lt; m_id &lt;&lt; endl;
-#endif
-		m_dispatcher();
-
-		pthread_mutex_unlock(&amp;m_dispatcherMutex);
-	}
-}
-
-unsigned int ThreadsManager::m_nextThreadId = 1;
-
-ThreadsManager::ThreadsManager(const string &amp;defaultIndexLocation,
-	unsigned int maxIndexThreads, unsigned int maxThreadsTime) :
-	m_defaultIndexLocation(defaultIndexLocation),
-	m_maxIndexThreads(maxIndexThreads),
-	m_backgroundThreadsCount(0),
-	m_foregroundThreadsMaxTime(maxThreadsTime),
-	m_numCPUs(1),
-	m_stopIndexing(false)
-{
-	pthread_rwlock_init(&amp;m_threadsLock, NULL);
-	pthread_rwlock_init(&amp;m_listsLock, NULL);
-
-#ifdef HAVE_SYSCONF
-	m_numCPUs = sysconf(_SC_NPROCESSORS_ONLN);
-#endif
-}
-
-ThreadsManager::~ThreadsManager()
-{
-	stop_threads();
-	// Destroy the read/write locks
-	pthread_rwlock_destroy(&amp;m_listsLock);
-	pthread_rwlock_destroy(&amp;m_threadsLock);
-}
-
-bool ThreadsManager::read_lock_threads(void)
-{
-	if (pthread_rwlock_rdlock(&amp;m_threadsLock) == 0)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-bool ThreadsManager::write_lock_threads(void)
-{
-	if (pthread_rwlock_wrlock(&amp;m_threadsLock) == 0)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-void ThreadsManager::unlock_threads(void)
-{
-	pthread_rwlock_unlock(&amp;m_threadsLock);
-}
-
-bool ThreadsManager::read_lock_lists(void)
-{
-	if (pthread_rwlock_rdlock(&amp;m_listsLock) == 0)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-bool ThreadsManager::write_lock_lists(void)
-{
-	if (pthread_rwlock_wrlock(&amp;m_listsLock) == 0)
-	{
-		return true;
-	}
-
-	return false;
-}
-
-void ThreadsManager::unlock_lists(void)
-{
-	pthread_rwlock_unlock(&amp;m_listsLock);
-}
-
-WorkerThread *ThreadsManager::get_thread(void)
-{
-	time_t timeNow = time(NULL);
-	WorkerThread *pWorkerThread = NULL;
-
-	// Get the first thread that's finished
-	if (write_lock_threads() == true)
-	{
-		for (map&lt;unsigned int, WorkerThread *&gt;::iterator threadIter = m_threads.begin();
-			threadIter != m_threads.end(); ++threadIter)
-		{
-			unsigned int threadId = threadIter-&gt;first;
-
-			if (threadIter-&gt;second-&gt;isDone() == false)
-			{
-#ifdef DEBUG
-				cout &lt;&lt; &quot;ThreadsManager::get_thread: thread &quot;
-					&lt;&lt; threadId &lt;&lt; &quot; is not done&quot; &lt;&lt; endl;
-#endif
-
-				// Foreground threads ought not to run very long
-				if ((threadIter-&gt;second-&gt;isBackground() == false) &amp;&amp;
-					(threadIter-&gt;second-&gt;getStartTime() + m_foregroundThreadsMaxTime &lt; timeNow))
-				{
-					// This thread has been running for too long !
-					threadIter-&gt;second-&gt;stop();
-
-					cerr &lt;&lt; &quot;Stopped long-running thread &quot; &lt;&lt; threadId &lt;&lt; endl;
-				}
-			}
-			else
-			{
-				// This one will do...
-				pWorkerThread = threadIter-&gt;second;
-				// Remove it
-				m_threads.erase(threadIter);
-#ifdef DEBUG
-				cout &lt;&lt; &quot;ThreadsManager::get_thread: thread &quot; &lt;&lt; threadId
-					&lt;&lt; &quot; is done, &quot; &lt;&lt; m_threads.size() &lt;&lt; &quot; left&quot; &lt;&lt; endl;
-#endif
-				break;
-			}
-		}
-
-		unlock_threads();
-	}
-
-	if (pWorkerThread == NULL)
-	{
-		return NULL;
-	}
-
-	if (pWorkerThread-&gt;isBackground() == true)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ThreadsManager::get_thread: thread &quot; &lt;&lt; pWorkerThread-&gt;getId()
-			&lt;&lt; &quot; was running in the background&quot; &lt;&lt; endl;
-#endif
-		--m_backgroundThreadsCount;
-	}
-
-	return pWorkerThread;
-}
-
-ustring ThreadsManager::index_document(const DocumentInfo &amp;docInfo)
-{
-	string location(docInfo.getLocation());
-
-	if (m_stopIndexing == true)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ThreadsManager::index_document: stopped indexing&quot; &lt;&lt; endl;
-#endif
-		return _(&quot;Indexing was stopped&quot;);
-	}
-
-	if (location.empty() == true)
-	{
-		// Nothing to do
-		return &quot;&quot;;
-	}
-
-	// If the document is a mail message, we can't index it again
-	Url urlObj(location);
-	if (urlObj.getProtocol() == &quot;mailbox&quot;)
-	{
-		return _(&quot;Can't index mail here&quot;);
-	}
-
-	// Is the document being indexed/updated ?
-	if (write_lock_lists() == true)
-	{
-		bool beingProcessed = true;
-
-		if (m_beingIndexed.find(location) == m_beingIndexed.end())
-		{
-			m_beingIndexed.insert(location);
-			beingProcessed = false;
-		}
-
-		unlock_lists();
-
-		if (beingProcessed == true)
-		{
-			// FIXME: we may have to set labels on this document
-			ustring status(location);
-			status += &quot; &quot;;
-			status += _(&quot;is already being indexed&quot;);
-			return status;
-		}
-	}
-
-	// Is the document blacklisted ?
-	if (PinotSettings::getInstance().isBlackListed(location) == true)
-	{
-		ustring status(location);
-		status += &quot; &quot;;
-		status += _(&quot;is blacklisted&quot;);
-		return status;
-	}
-
-	start_thread(new IndexingThread(docInfo, m_defaultIndexLocation));
-
-	return &quot;&quot;;
-}
-
-void ThreadsManager::clear_queues(void)
-{
-	if (write_lock_lists() == true)
-	{
-		m_beingIndexed.clear();
-
-		unlock_lists();
-
-		ActionQueue actionQueue(PinotSettings::getInstance().getHistoryDatabaseName(), get_application_name());
-
-		actionQueue.expireItems(time(NULL));
-
-		m_backgroundThreadsCount = 0;
-	}
-}
-
-unsigned int ThreadsManager::get_next_id(void)
-{
-	unsigned int nextThreadId = ++m_nextThreadId;
-
-	return nextThreadId;
-}
-
-bool ThreadsManager::start_thread(WorkerThread *pWorkerThread, bool inBackground)
-{
-	bool createdThread = false;
-
-	if (pWorkerThread == NULL)
-	{
-		return false;
-	}
-
-	if (inBackground == true)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ThreadsManager::start_thread: thread &quot; &lt;&lt; pWorkerThread-&gt;getId()
-			&lt;&lt; &quot; will run in the background&quot; &lt;&lt; endl;
-#endif
-		pWorkerThread-&gt;inBackground();
-		++m_backgroundThreadsCount;
-	}
-#ifdef DEBUG
-	else cout &lt;&lt; &quot;ThreadsManager::start_thread: thread &quot; &lt;&lt; pWorkerThread-&gt;getId()
-			&lt;&lt; &quot; will run in the foreground&quot; &lt;&lt; endl;
-#endif
-
-	// Insert
-	pair&lt;map&lt;unsigned int, WorkerThread *&gt;::iterator, bool&gt; threadPair;
-	if (write_lock_threads() == true)
-	{
-		threadPair = m_threads.insert(pair&lt;unsigned int, WorkerThread *&gt;(pWorkerThread-&gt;getId(), pWorkerThread));
-		if (threadPair.second == false)
-		{
-			delete pWorkerThread;
-			pWorkerThread = NULL;
-		}
-
-		unlock_threads();
-	}
-
-	// Start the thread
-	if (pWorkerThread != NULL)
-	{
-		Thread *pThread = pWorkerThread-&gt;start();
-		if (pThread != NULL)
-		{
-			createdThread = true;
-		}
-		else
-		{
-			// Erase
-			if (write_lock_threads() == true)
-			{
-				m_threads.erase(threadPair.first);
-
-				unlock_threads();
-			}
-			delete pWorkerThread;
-		}
-	}
-
-	return createdThread;
-}
-
-unsigned int ThreadsManager::get_threads_count(void)
-{
-	int count = 0;
-
-	if (read_lock_threads() == true)
-	{
-		count = m_threads.size() - m_backgroundThreadsCount;
-
-		unlock_threads();
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;ThreadsManager::get_threads_count: &quot; &lt;&lt; count &lt;&lt; &quot;/&quot;
-		&lt;&lt; m_backgroundThreadsCount &lt;&lt; &quot; threads left&quot; &lt;&lt; endl;
-#endif
-
-	// A negative count would mean that a background thread
-	// exited without signaling
-	return (unsigned int)max(count , 0);
-}
-
-void ThreadsManager::stop_threads(void)
-{
-	if (m_threads.empty() == false)
-	{
-		if (write_lock_threads() == true)
-		{
-			// Stop threads
-			for_each(m_threads.begin(), m_threads.end(), StopThreadFunc());
-
-			unlock_threads();
-		}
-	}
-}
-
-void ThreadsManager::connect(void)
-{
-	// The previous manager may have been signalled by our threads
-	WorkerThread *pThread = get_thread();
-	while (pThread != NULL)
-	{
-		m_onThreadEndSignal(pThread);
-
-		// Next
-		pThread = get_thread();
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;ThreadsManager::connect: connecting&quot; &lt;&lt; endl;
-#endif
-
-	// Connect the dispatcher
-	m_threadsEndConnection = WorkerThread::getDispatcher().connect(
-		sigc::mem_fun(*this, &amp;ThreadsManager::on_thread_signal));
-#ifdef DEBUG
-	cout &lt;&lt; &quot;ThreadsManager::connect: connected&quot; &lt;&lt; endl;
-#endif
-}
-
-void ThreadsManager::disconnect(void)
-{
-	m_threadsEndConnection.block();
-	m_threadsEndConnection.disconnect();
-#ifdef DEBUG
-	cout &lt;&lt; &quot;ThreadsManager::disconnect: disconnected&quot; &lt;&lt; endl;
-#endif
-}
-
-void ThreadsManager::on_thread_signal()
-{
-	WorkerThread *pThread = get_thread();
-	if (pThread == NULL)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ThreadsManager::on_thread_signal: foreign thread&quot; &lt;&lt; endl;
-#endif
-		return;
-	}
-	m_onThreadEndSignal(pThread);
-}
-
-ustring ThreadsManager::queue_index(const DocumentInfo &amp;docInfo)
-{
-	bool addToQueue = false;
-
-	if (get_threads_count() &gt;= m_maxIndexThreads)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ThreadsManager::queue_index: too many threads&quot; &lt;&lt; endl;
-#endif
-		addToQueue = true;
-	}
-#ifdef HAVE_GETLOADAVG
-	// Get the load averaged over the last minute
-	else
-	{
-		double averageLoad[3];
-
-		if (getloadavg(averageLoad, 3) != -1)
-		{
-			// FIXME: is LOADAVG_1MIN Solaris specific ?
-			if (averageLoad[0] &gt;= (double)m_numCPUs * 4)
-			{
-				// Don't add to the load, queue this
-				addToQueue = true;
-			}
-		}
-	}
-#endif
-
-	if (addToQueue == true)
-	{
-		ActionQueue actionQueue(PinotSettings::getInstance().getHistoryDatabaseName(), get_application_name());
-
-		actionQueue.pushItem(ActionQueue::INDEX, docInfo);
-
-		return &quot;&quot;;
-	}
-
-	return index_document(docInfo);
-}
-
-bool ThreadsManager::pop_queue(const string &amp;urlWasIndexed)
-{
-	bool getItem = true;
-	bool foundItem = false;
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;ThreadsManager::pop_queue: called&quot; &lt;&lt; endl;
-#endif
-	if (get_threads_count() &gt;= m_maxIndexThreads)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ThreadsManager::pop_queue: too many threads&quot; &lt;&lt; endl;
-#endif
-		getItem = false;
-	}
-
-	if (write_lock_lists() == true)
-	{
-		// Update the in-progress list
-		if (urlWasIndexed.empty() == false)
-		{
-			set&lt;string&gt;::iterator urlIter = m_beingIndexed.find(urlWasIndexed);
-			if (urlIter != m_beingIndexed.end())
-			{
-				m_beingIndexed.erase(urlIter);
-			}
-		}
-
-		unlock_lists();
-
-		// Get an item ?
-		if (getItem == true)
-		{
-			ActionQueue actionQueue(PinotSettings::getInstance().getHistoryDatabaseName(), get_application_name());
-			ActionQueue::ActionType type;
-			DocumentInfo docInfo;
-			string previousLocation;
-
-			while (actionQueue.popItem(type, docInfo) == true)
-			{
-				ustring status;
-
-				if (type != ActionQueue::INDEX)
-				{
-					continue;
-				}
-
-				if (docInfo.getLocation() == previousLocation)
-				{
-					// Something dodgy is going on, we got the same item twice !
-					status = previousLocation;
-					status += &quot; &quot;;
-					status += _(&quot;is already being indexed&quot;);
-				}
-				else
-				{
-					status = index_document(docInfo);
-				}
-
-				if (status.empty() == true)
-				{
-					foundItem = true;
-					break;
-				}
-
-				previousLocation = docInfo.getLocation();
-			}
-		}
-	}
-
-	return foundItem;
-}
-
-ListerThread::ListerThread(const PinotSettings::IndexProperties &amp;indexProps,
-	unsigned int startDoc) :
-	WorkerThread(),
-	m_indexProps(indexProps),
-	m_startDoc(startDoc),
-	m_documentsCount(0)
-{
-}
-
-ListerThread::~ListerThread()
-{
-}
-
-string ListerThread::getType(void) const
-{
-	return &quot;ListerThread&quot;;
-}
-
-PinotSettings::IndexProperties ListerThread::getIndexProperties(void) const
-{
-	return m_indexProps;
-}
-
-unsigned int ListerThread::getStartDoc(void) const
-{
-	return m_startDoc;
-}
-
-const vector&lt;DocumentInfo&gt; &amp;ListerThread::getDocuments(void) const
-{
-	return m_documentsList;
-}
-
-unsigned int ListerThread::getDocumentsCount(void) const
-{
-	return m_documentsCount;
-}
-
-IndexBrowserThread::IndexBrowserThread(const PinotSettings::IndexProperties &amp;indexProps,
-	unsigned int maxDocsCount, unsigned int startDoc) :
-	ListerThread(indexProps, startDoc),
-	m_maxDocsCount(maxDocsCount)
-{
-}
-
-IndexBrowserThread::~IndexBrowserThread()
-{
-}
-
-void IndexBrowserThread::doWork(void)
-{
-	set&lt;unsigned int&gt; docIDList;
-	set&lt;string&gt; docLabels;
-	unsigned int numDocs = 0;
-
-	if (m_indexProps.m_location.empty() == true)
-	{
-		m_errorNum = UNKNOWN_INDEX;
-		m_errorParam = m_indexProps.m_name.c_str();
-		return;
-	}
-
-	// Get the index at that location
-	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexProps.m_location);
-	if ((pIndex == NULL) ||
-		(pIndex-&gt;isGood() == false))
-	{
-		m_errorNum = INDEX_ERROR;
-		m_errorParam = m_indexProps.m_location;
-		if (pIndex != NULL)
-		{
-			delete pIndex;
-		}
-		return;
-	}
-
-	m_documentsCount = pIndex-&gt;getDocumentsCount();
-	if (m_documentsCount == 0)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;IndexBrowserThread::doWork: no documents&quot; &lt;&lt; endl;
-#endif
-		return;
-	}
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;IndexBrowserThread::doWork: &quot; &lt;&lt; m_maxDocsCount &lt;&lt; &quot; off &quot; &lt;&lt; m_documentsCount
-		&lt;&lt; &quot; documents to browse, starting at position &quot; &lt;&lt; m_startDoc &lt;&lt; endl;
-#endif
-	pIndex-&gt;listDocuments(docIDList, m_maxDocsCount, m_startDoc);
-
-	m_documentsList.clear();
-	m_documentsList.reserve(m_maxDocsCount);
-
-	for (set&lt;unsigned int&gt;::iterator iter = docIDList.begin(); iter != docIDList.end(); ++iter)
-	{
-		unsigned int docId = (*iter);
-
-		if (m_done == true)
-		{
-			break;
-		}
-
-		DocumentInfo docInfo;
-		if (pIndex-&gt;getDocumentInfo(docId, docInfo) == true)
-		{
-			string type(docInfo.getType());
-
-			if (type.empty() == true)
-			{
-				docInfo.setType(&quot;text/html&quot;);
-			}
-			docInfo.setIsIndexed(m_indexProps.m_id, docId);
-
-			// Insert that document
-			m_documentsList.push_back(docInfo);
-			++numDocs;
-		}
-#ifdef DEBUG
-		else cout &lt;&lt; &quot;IndexBrowserThread::doWork: couldn't retrieve document &quot; &lt;&lt; docId &lt;&lt; endl;
-#endif
-	}
-	delete pIndex;
-}
-
-QueryingThread::QueryingThread(const PinotSettings::IndexProperties &amp;indexProps,
-	const QueryProperties &amp;queryProps, unsigned int startDoc, bool listingIndex) :
-	ListerThread(indexProps, startDoc),
-	m_engineName(PinotSettings::getInstance().m_defaultBackend),
-	m_engineDisplayableName(indexProps.m_name),
-	m_engineOption(indexProps.m_location),
-	m_queryProps(queryProps),
-	m_listingIndex(listingIndex),
-	m_correctedSpelling(false),
-	m_isLive(true)
-{
-#ifdef DEBUG
-	cout &lt;&lt; &quot;QueryingThread: engine &quot; &lt;&lt; m_engineName &lt;&lt; &quot;, &quot; &lt;&lt; m_engineOption
-		&lt;&lt; &quot;, mode &quot; &lt;&lt; m_listingIndex &lt;&lt; endl;
-#endif
-}
-
-QueryingThread::QueryingThread(const string &amp;engineName, const string &amp;engineDisplayableName,
-	const string &amp;engineOption, const QueryProperties &amp;queryProps,
-	unsigned int startDoc) :
-	ListerThread(PinotSettings::IndexProperties(engineDisplayableName, engineOption, 0, false), startDoc),
-	m_engineName(engineName),
-	m_engineDisplayableName(engineDisplayableName),
-	m_engineOption(engineOption),
-	m_queryProps(queryProps),
-	m_listingIndex(false),
-	m_correctedSpelling(false),
-	m_isLive(true)
-{
-#ifdef DEBUG
-	cout &lt;&lt; &quot;QueryingThread: engine &quot; &lt;&lt; m_engineName &lt;&lt; &quot;, &quot; &lt;&lt; m_engineOption
-		&lt;&lt; &quot;, mode 0&quot; &lt;&lt; endl;
-#endif
-}
-
-QueryingThread::~QueryingThread()
-{
-}
-
-string QueryingThread::getType(void) const
-{
-	if (m_listingIndex == true)
-	{
-		return ListerThread::getType();
-	}
-
-	return &quot;QueryingThread&quot;;
-}
-
-bool QueryingThread::isLive(void) const
-{
-	return m_isLive;
-}
-
-string QueryingThread::getEngineName(void) const
-{
-	return m_engineDisplayableName;
-}
-
-QueryProperties QueryingThread::getQuery(bool &amp;wasCorrected) const
-{
-	wasCorrected = m_correctedSpelling;
-	return m_queryProps;
-}
-
-string QueryingThread::getCharset(void) const
-{
-	return m_resultsCharset;
-}
-
-bool QueryingThread::findPlugin(void)
-{
-	string pluginName;
-
-	if ((m_engineName.empty() == true) &amp;&amp;
-		(m_engineOption.empty() == false))
-	{
-		pluginName = m_engineOption;
-	}
-	else if ((m_engineName.empty() == false) &amp;&amp;
-		(m_engineOption.empty() == true))
-	{
-		pluginName = m_engineName;
-	}
-
-	if (pluginName.empty() == false)
-	{
-		set&lt;ModuleProperties&gt; engines;
-		PinotSettings::getInstance().getSearchEngines(engines, &quot;&quot;);
-#ifdef DEBUG
-		cout &lt;&lt; &quot;QueryingThread::findPlugin: looking for a plugin named &quot; &lt;&lt; pluginName &lt;&lt; endl;
-#endif
-
-		// Is there a plugin with such a name ?
-		ModuleProperties modProps(&quot;sherlock&quot;, pluginName, &quot;&quot;, &quot;&quot;);
-		set&lt;ModuleProperties&gt;::const_iterator engineIter = engines.find(modProps);
-		if (engineIter == engines.end())
-		{
-			// Try again
-			modProps.m_name = &quot;opensearch&quot;;
-			engineIter = engines.find(modProps);
-		}
-
-		if (engineIter != engines.end())
-		{
-			// Yes, there is !
-			m_engineName = engineIter-&gt;m_name;
-			m_engineDisplayableName = engineIter-&gt;m_longName;
-			m_engineOption = engineIter-&gt;m_option;
-#ifdef DEBUG
-			cout &lt;&lt; &quot;QueryingThread::findPlugin: found &quot; &lt;&lt; m_engineName &lt;&lt; &quot;, &quot; &lt;&lt; m_engineDisplayableName &lt;&lt; &quot;, &quot; &lt;&lt; m_engineOption &lt;&lt; endl;
-#endif
-
-			return true;
-		}
-	}
-
-	return false;
-}
-
-EngineQueryThread::EngineQueryThread(const PinotSettings::IndexProperties &amp;indexProps,
-	const QueryProperties &amp;queryProps, unsigned int startDoc, bool listingIndex) :
-	QueryingThread(indexProps, queryProps, startDoc, listingIndex)
-{
-}
-
-EngineQueryThread::EngineQueryThread(const PinotSettings::IndexProperties &amp;indexProps,
-	const QueryProperties &amp;queryProps, const set&lt;string&gt; &amp;limitToDocsSet,
-	unsigned int startDoc) :
-	QueryingThread(indexProps, queryProps, startDoc, false)
-{
-	copy(limitToDocsSet.begin(), limitToDocsSet.end(),
-		inserter(m_limitToDocsSet, m_limitToDocsSet.begin()));
-}
-
-EngineQueryThread::EngineQueryThread(const string &amp;engineName, const string &amp;engineDisplayableName,
-	const string &amp;engineOption, const QueryProperties &amp;queryProps, unsigned int startDoc) :
-	QueryingThread(engineName, engineDisplayableName, engineOption, queryProps, startDoc)
-{
-}
-
-EngineQueryThread::~EngineQueryThread()
-{
-}
-
-void EngineQueryThread::processResults(const vector&lt;DocumentInfo&gt; &amp;resultsList)
-{
-	PinotSettings &amp;settings = PinotSettings::getInstance();
-	IndexInterface *pDocsIndex = NULL;
-	IndexInterface *pDaemonIndex = NULL;
-	unsigned int indexId = 0;
-	bool isIndexQuery = false;
-
-	// Are we querying an index ?
-	if (ModuleFactory::isSupported(m_engineName, true) == true)
-	{
-		// Internal index ?
-		if ((m_engineOption == settings.m_docsIndexLocation) ||
-			(m_engineOption == settings.m_daemonIndexLocation))
-		{
-			indexId = settings.getIndexPropertiesByLocation(m_engineOption).m_id;
-			isIndexQuery = true;
-		}
-	}
-
-	// Will we have to query internal indices ?
-	if (isIndexQuery == false)
-	{
-		pDocsIndex = settings.getIndex(settings.m_docsIndexLocation);
-		pDaemonIndex = settings.getIndex(settings.m_daemonIndexLocation);
-	}
-
-	// Copy the results list
-	for (vector&lt;DocumentInfo&gt;::const_iterator resultIter = resultsList.begin();
-		resultIter != resultsList.end(); ++resultIter)
-	{
-		DocumentInfo currentDoc(*resultIter);
-		string title(_(&quot;No title&quot;));
-		string location(currentDoc.getLocation());
-		string language(currentDoc.getLanguage());
-		unsigned int docId = 0;
-
-		// The title may contain formatting
-		if (currentDoc.getTitle().empty() == false)
-		{
-			title = FilterUtils::stripMarkup(currentDoc.getTitle());
-		}
-		currentDoc.setTitle(title);
-#ifdef DEBUG
-		cout &lt;&lt; &quot;EngineQueryThread::processResults: title is &quot; &lt;&lt; title &lt;&lt; endl;
-#endif
-
-		// Use the query's language if the result's is unknown
-		if (language.empty() == true)
-		{
-			language = m_queryProps.getStemmingLanguage();
-		}
-		currentDoc.setLanguage(language);
-
-		if (isIndexQuery == true)
-		{
-			unsigned int tmpId = 0;
-
-			// The index engine should have set this
-			docId = currentDoc.getIsIndexed(tmpId);
-		}
-
-		// Is this in one of the indexes ?
-		if ((pDocsIndex != NULL) &amp;&amp;
-			(pDocsIndex-&gt;isGood() == true))
-		{
-			docId = pDocsIndex-&gt;hasDocument(location);
-			if (docId &gt; 0)
-			{
-				indexId = settings.getIndexPropertiesByName(_(&quot;My Web Pages&quot;)).m_id;
-			}
-		}
-		if ((pDaemonIndex != NULL) &amp;&amp;
-			(pDaemonIndex-&gt;isGood() == true) &amp;&amp;
-			(docId == 0))
-		{
-			docId = pDaemonIndex-&gt;hasDocument(location);
-			if (docId &gt; 0)
-			{
-				indexId = settings.getIndexPropertiesByName(_(&quot;My Documents&quot;)).m_id;
-			}
-		}
-
-		if (docId &gt; 0)
-		{
-			currentDoc.setIsIndexed(indexId, docId);
-#ifdef DEBUG
-			cout &lt;&lt; &quot;EngineQueryThread::processResults: found in index &quot; &lt;&lt; indexId &lt;&lt; endl;
-#endif
-		}
-#ifdef DEBUG
-		else cout &lt;&lt; &quot;EngineQueryThread::processResults: not found in any index&quot; &lt;&lt; endl;
-#endif
-
-		m_documentsList.push_back(currentDoc);
-	}
-
-	if (pDocsIndex != NULL)
-	{
-		delete pDocsIndex;
-	}
-	if (pDaemonIndex != NULL)
-	{
-		delete pDaemonIndex;
-	}
-}
-
-void EngineQueryThread::processResults(const vector&lt;DocumentInfo&gt; &amp;resultsList,
-	unsigned int indexId)
-{
-	unsigned int zeroId = 0;
-
-	// Copy the results list
-	for (vector&lt;DocumentInfo&gt;::const_iterator resultIter = resultsList.begin();
-		resultIter != resultsList.end(); ++resultIter)
-	{
-		DocumentInfo currentDoc(*resultIter);
-
-		// The engine has no notion of index IDs
-		unsigned int docId = currentDoc.getIsIndexed(zeroId);
-		currentDoc.setIsIndexed(indexId, docId);
-
-		m_documentsList.push_back(currentDoc);
-	}
-}
-
-void EngineQueryThread::doWork(void)
-{
-	PinotSettings &amp;settings = PinotSettings::getInstance();
-
-	// Get the SearchEngine
-	SearchEngineInterface *pEngine = ModuleFactory::getSearchEngine(m_engineName, m_engineOption);
-	if (pEngine == NULL)
-	{
-		// Try again
-		if (findPlugin() == true)
-		{
-			pEngine = ModuleFactory::getSearchEngine(m_engineName, m_engineOption);
-		}
-
-		if (pEngine == NULL)
-		{
-			m_errorNum = UNKNOWN_ENGINE;
-			m_errorParam = m_engineDisplayableName;
-			return;
-		}
-	}
-
-	// Set up the proxy
-	WebEngine *pWebEngine = dynamic_cast&lt;WebEngine *&gt;(pEngine);
-	if (pWebEngine != NULL)
-	{
-		DownloaderInterface *pDownloader = pWebEngine-&gt;getDownloader();
-		if ((pDownloader != NULL) &amp;&amp;
-			(settings.m_proxyEnabled == true) &amp;&amp;
-			(settings.m_proxyAddress.empty() == false))
-		{
-			char portStr[64];
-
-			pDownloader-&gt;setSetting(&quot;proxyaddress&quot;, settings.m_proxyAddress);
-			snprintf(portStr, 64, &quot;%u&quot;, settings.m_proxyPort);
-			pDownloader-&gt;setSetting(&quot;proxyport&quot;, portStr);
-			pDownloader-&gt;setSetting(&quot;proxytype&quot;, settings.m_proxyType);
-		}
-
-		pWebEngine-&gt;setEditableValues(settings.m_editablePluginValues);
-	}
-
-	if (m_listingIndex == false)
-	{
-		pEngine-&gt;setLimitSet(m_limitToDocsSet);
-	}
-
-	// Run the query
-	pEngine-&gt;setDefaultOperator(SearchEngineInterface::DEFAULT_OP_AND);
-	if (pEngine-&gt;runQuery(m_queryProps, m_startDoc) == false)
-	{
-		m_errorNum = QUERY_FAILED;
-		m_errorParam = m_engineDisplayableName;
-	}
-	else
-	{
-		const vector&lt;DocumentInfo&gt; &amp;resultsList = pEngine-&gt;getResults();
-
-		m_documentsList.clear();
-		m_documentsList.reserve(resultsList.size());
-		m_documentsCount = pEngine-&gt;getResultsCountEstimate();
-#ifdef DEBUG
-		cout &lt;&lt; &quot;EngineQueryThread::doWork: &quot; &lt;&lt; resultsList.size() &lt;&lt; &quot; off &quot; &lt;&lt; m_documentsCount
-			&lt;&lt; &quot; results to process, starting at position &quot; &lt;&lt; m_startDoc &lt;&lt; endl;
-#endif
-
-		m_resultsCharset = pEngine-&gt;getResultsCharset();
-		if (m_listingIndex == false)
-		{
-			processResults(resultsList);
-		}
-		else
-		{
-			processResults(resultsList,
-				PinotSettings::getInstance().getIndexPropertiesByName(m_engineDisplayableName).m_id);
-		}
-
-		// Don't spellcheck if the query was modified in any way
-		if (m_queryProps.getModified() == false)
-		{
-			string correctedFreeQuery(pEngine-&gt;getSpellingCorrection());
-
-			// Any spelling correction ?
-			if (correctedFreeQuery.empty() == false)
-			{
-				m_correctedSpelling = true;
-				m_queryProps.setFreeQuery(correctedFreeQuery);
-			}
-		}
-	}
-
-	delete pEngine;
-}
-
-EngineHistoryThread::EngineHistoryThread(const string &amp;engineDisplayableName,
-	const QueryProperties &amp;queryProps, unsigned int maxDocsCount) :
-	QueryingThread(&quot;&quot;, engineDisplayableName, &quot;&quot;, queryProps, 0),
-	m_maxDocsCount(maxDocsCount)
-{
-	// Results are converted to UTF-8 prior to insertion in the history database
-	m_resultsCharset = &quot;UTF-8&quot;;
-	m_isLive = false;
-}
-
-EngineHistoryThread::~EngineHistoryThread()
-{
-}
-
-void EngineHistoryThread::doWork(void)
-{
-	QueryHistory queryHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-
-	if (queryHistory.getItems(m_queryProps.getName(), m_engineDisplayableName,
-		m_maxDocsCount, m_documentsList) == false)
-	{
-		m_errorNum = HISTORY_FAILED;
-		m_errorParam = m_engineDisplayableName;
-	}
-	else if (m_documentsList.empty() == false)
-	{
-		// Get the first result's charset
-		queryHistory.getItemExtract(m_queryProps.getName(), m_engineDisplayableName,
-			m_documentsList.front().getLocation());
-	}
-}
-
-ExpandQueryThread::ExpandQueryThread(const QueryProperties &amp;queryProps,
-	const set&lt;string&gt; &amp;expandFromDocsSet) :
-	WorkerThread(),
-	m_queryProps(queryProps)
-{
-	copy(expandFromDocsSet.begin(), expandFromDocsSet.end(),
-		inserter(m_expandFromDocsSet, m_expandFromDocsSet.begin()));
-}
-
-ExpandQueryThread::~ExpandQueryThread()
-{
-}
-
-string ExpandQueryThread::getType(void) const
-{
-	return &quot;ExpandQueryThread&quot;;
-}
-
-QueryProperties ExpandQueryThread::getQuery(void) const
-{
-	return m_queryProps;
-}
-
-const set&lt;string&gt; &amp;ExpandQueryThread::getExpandTerms(void) const
-{
-	return m_expandTerms;
-}
-
-void ExpandQueryThread::doWork(void)
-{
-	// Get the SearchEngine
-	SearchEngineInterface *pEngine = ModuleFactory::getSearchEngine(PinotSettings::getInstance().m_defaultBackend, &quot;MERGED&quot;);
-	if (pEngine == NULL)
-	{
-		m_errorNum = UNKNOWN_ENGINE;
-		m_errorParam = m_queryProps.getName();
-		return;
-	}
-
-	// Expand the query
-	pEngine-&gt;setExpandSet(m_expandFromDocsSet);
-
-	// Run the query
-	pEngine-&gt;setDefaultOperator(SearchEngineInterface::DEFAULT_OP_AND);
-	if (pEngine-&gt;runQuery(m_queryProps) == false)
-	{
-		m_errorNum = QUERY_FAILED;
-	}
-	else
-	{
-		// Copy the expand terms
-		const set&lt;string&gt; &amp;expandTerms = pEngine-&gt;getExpandTerms();
-		copy(expandTerms.begin(), expandTerms.end(),
-			inserter(m_expandTerms, m_expandTerms.begin()));
-	}
-
-	delete pEngine;
-}
-
-LabelUpdateThread::LabelUpdateThread(const set&lt;string&gt; &amp;labelsToAdd,
-	const set&lt;string&gt; &amp;labelsToDelete) :
-	WorkerThread(),
-	m_resetLabels(false)
-{
-	copy(labelsToAdd.begin(), labelsToAdd.end(),
-		inserter(m_labelsToAdd, m_labelsToAdd.begin()));
-	copy(labelsToDelete.begin(), labelsToDelete.end(),
-		inserter(m_labelsToDelete, m_labelsToDelete.begin()));
-}
-
-LabelUpdateThread::LabelUpdateThread(const set&lt;string&gt; &amp;labelsToAdd,
-	const set&lt;unsigned int&gt; &amp;docsIds, const set&lt;unsigned int&gt; &amp;daemonIds,
-	bool resetLabels) :
-	WorkerThread(),
-	m_resetLabels(resetLabels)
-{
-	copy(labelsToAdd.begin(), labelsToAdd.end(),
-		inserter(m_labelsToAdd, m_labelsToAdd.begin()));
-	copy(docsIds.begin(), docsIds.end(),
-		inserter(m_docsIds, m_docsIds.begin()));
-	copy(daemonIds.begin(), daemonIds.end(),
-		inserter(m_daemonIds, m_daemonIds.begin()));
-}
-
-LabelUpdateThread::~LabelUpdateThread()
-{
-}
-
-string LabelUpdateThread::getType(void) const
-{
-	return &quot;LabelUpdateThread&quot;;
-}
-
-bool LabelUpdateThread::modifiedDocsIndex(void) const
-{
-	return !m_docsIds.empty();
-}
-
-bool LabelUpdateThread::modifiedDaemonIndex(void) const
-{
-	return !m_daemonIds.empty();
-}
-
-void LabelUpdateThread::doWork(void)
-{
-	bool actOnDocuments = false;
-
-	IndexInterface *pDocsIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_docsIndexLocation);
-	if (pDocsIndex == NULL)
-	{
-		m_errorNum = INDEX_ERROR;
-		m_errorParam = PinotSettings::getInstance().m_docsIndexLocation;
-		return;
-	}
-
-	IndexInterface *pDaemonIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
-	if (pDaemonIndex == NULL)
-	{
-		m_errorNum = INDEX_ERROR;
-		m_errorParam = PinotSettings::getInstance().m_daemonIndexLocation;
-		delete pDocsIndex;
-		return;
-	}
-
-	// Apply the labels to existing documents
-	if (m_docsIds.empty() == false)
-	{
-		pDocsIndex-&gt;setDocumentsLabels(m_docsIds, m_labelsToAdd, m_resetLabels);
-		actOnDocuments = true;
-	}
-	if (m_daemonIds.empty() == false)
-	{
-		pDaemonIndex-&gt;setDocumentsLabels(m_daemonIds, m_labelsToAdd, m_resetLabels);
-		actOnDocuments = true;
-	}
-
-	if (actOnDocuments == false)
-	{
-		// Add and/or delete labels on the daemon's index only
-		// The documents index is not required to have labels set
-		for (set&lt;string&gt;::iterator iter = m_labelsToAdd.begin(); iter != m_labelsToAdd.end(); ++iter)
-		{
-			pDaemonIndex-&gt;addLabel(*iter);
-		}
-		for (set&lt;string&gt;::iterator iter = m_labelsToDelete.begin(); iter != m_labelsToDelete.end(); ++iter)
-		{
-			pDaemonIndex-&gt;deleteLabel(*iter);
-		}
-	}
-
-	delete pDaemonIndex;
-	delete pDocsIndex;
-}
-
-DownloadingThread::DownloadingThread(const DocumentInfo &amp;docInfo) :
-	WorkerThread(),
-	m_docInfo(docInfo),
-	m_pDoc(NULL),
-	m_pDownloader(NULL)
-{
-}
-
-DownloadingThread::DownloadingThread() :
-	WorkerThread(),
-	m_docInfo(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;),
-	m_pDoc(NULL),
-	m_pDownloader(NULL)
-{
-}
-
-DownloadingThread::~DownloadingThread()
-{
-	if (m_pDoc != NULL)
-	{
-		delete m_pDoc;
-	}
-	if (m_pDownloader != NULL)
-	{
-		delete m_pDownloader;
-	}
-}
-
-string DownloadingThread::getType(void) const
-{
-	return &quot;DownloadingThread&quot;;
-}
-
-string DownloadingThread::getURL(void) const
-{
-	return m_docInfo.getLocation();
-}
-
-const Document *DownloadingThread::getDocument(void) const
-{
-	return m_pDoc;
-}
-
-void DownloadingThread::doWork(void)
-{
-	if (m_pDoc != NULL)
-	{
-		delete m_pDoc;
-		m_pDoc = NULL;
-	}
-	if (m_pDownloader != NULL)
-	{
-		delete m_pDownloader;
-		m_pDownloader = NULL;
-	}
-
-	Url thisUrl(m_docInfo.getLocation());
-
-	// Get a Downloader, the default one will do
-	m_pDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol());
-	if (m_pDownloader == NULL)
-	{
-		m_errorNum = UNSUPPORTED_PROTOCOL;
-		m_errorParam = thisUrl.getProtocol();
-	}
-	else if (m_done == false)
-	{
-		Timer collectTimer;
-		PinotSettings &amp;settings = PinotSettings::getInstance();
-
-		// Set up the proxy
-		if ((settings.m_proxyEnabled == true) &amp;&amp;
-			(settings.m_proxyAddress.empty() == false))
-		{
-			char portStr[64];
-
-			m_pDownloader-&gt;setSetting(&quot;proxyaddress&quot;, settings.m_proxyAddress);
-			snprintf(portStr, 64, &quot;%u&quot;, settings.m_proxyPort);
-			m_pDownloader-&gt;setSetting(&quot;proxyport&quot;, portStr);
-			m_pDownloader-&gt;setSetting(&quot;proxytype&quot;, settings.m_proxyType);
-		}
-
-		collectTimer.start();
-
-		m_pDoc = m_pDownloader-&gt;retrieveUrl(m_docInfo);
-
-		cout &lt;&lt; &quot;Retrieved &quot; &lt;&lt; m_docInfo.getLocation() &lt;&lt; &quot; in &quot; &lt;&lt; collectTimer.stop() &lt;&lt; &quot; ms&quot; &lt;&lt; endl;
-	}
-
-	if (m_pDoc == NULL)
-	{
-		m_errorNum = DOWNLOAD_FAILED;
-		m_errorParam = m_docInfo.getLocation();
-	}
-}
-
-IndexingThread::IndexingThread(const DocumentInfo &amp;docInfo, const string &amp;indexLocation,
-	bool allowAllMIMETypes) :
-	DownloadingThread(docInfo),
-	m_docId(0),
-	m_indexLocation(indexLocation),
-	m_allowAllMIMETypes(allowAllMIMETypes),
-	m_update(false)
-{
-}
-
-IndexingThread::IndexingThread() :
-	DownloadingThread(),
-	m_docId(0),
-	m_indexLocation(&quot;&quot;),
-	m_allowAllMIMETypes(true),
-	m_update(false)
-{
-}
-
-IndexingThread::~IndexingThread()
-{
-}
-
-string IndexingThread::getType(void) const
-{
-	return &quot;IndexingThread&quot;;
-}
-
-const DocumentInfo &amp;IndexingThread::getDocumentInfo(void) const
-{
-	return m_docInfo;
-}
-
-unsigned int IndexingThread::getDocumentID(void) const
-{
-	return m_docId;
-}
-
-bool IndexingThread::isNewDocument(void) const
-{
-	// If the thread is set to perform an update, the document isn't new
-	if (m_update == true)
-	{
-		return false;
-	}
-	return true;
-}
-
-void IndexingThread::doWork(void)
-{
-	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexLocation);
-	Url thisUrl(m_docInfo.getLocation());
-	bool reliableType = false, doDownload = true;
-
-	// First things first, get the index
-	if ((pIndex == NULL) ||
-		(pIndex-&gt;isGood() == false))
-	{
-		m_errorNum = INDEX_ERROR;
-		m_errorParam = m_indexLocation;
-		if (pIndex != NULL)
-		{
-			delete pIndex;
-		}
-		return;
-	}
-
-	// Is it an update ?
-	m_docId = pIndex-&gt;hasDocument(m_docInfo.getLocation());
-	if (m_docId &gt; 0)
-	{
-		// Ignore robots directives on updates
-		m_update = true;
-	}
-
-	if (m_docInfo.getType().empty() == true)
-	{
-		m_docInfo.setType(MIMEScanner::scanUrl(thisUrl));
-	}
-	else if (thisUrl.isLocal() == true)
-	{
-		// There's a good chance the supplied type is accurate
-		// if the document is a local file
-		reliableType = true;
-	}
-
-	if (FilterUtils::isSupportedType(m_docInfo.getType()) == false)
-	{
-		// Skip unsupported types ?
-		if (m_allowAllMIMETypes == false)
-		{
-			m_errorNum = UNSUPPORTED_TYPE;
-			m_errorParam = m_docInfo.getType();
-			delete pIndex;
-
-			return;
-		}
-
-		if (reliableType == true)
-		{
-			doDownload = false;
-#ifdef DEBUG
-			cout &lt;&lt; &quot;IndexingThread::doWork: skipping download of unsupported type &quot; &lt;&lt; m_docInfo.getLocation() &lt;&lt; endl;
-#endif
-		}
-	}
-	else
-	{
-		Dijon::Filter *pFilter = FilterUtils::getFilter(m_docInfo.getType());
-
-		if (pFilter != NULL)
-		{
-			// We may able to feed the document directly to the filter
-			if (((pFilter-&gt;is_data_input_ok(Dijon::Filter::DOCUMENT_FILE_NAME) == true) &amp;&amp;
-				(thisUrl.getProtocol() == &quot;file&quot;)) ||
-				((pFilter-&gt;is_data_input_ok(Dijon::Filter::DOCUMENT_URI) == true) &amp;&amp;
-				(thisUrl.isLocal() == false)))
-			{
-				doDownload = false;
-#ifdef DEBUG
-				cout &lt;&lt; &quot;IndexingThread::doWork: let filter download &quot; &lt;&lt; m_docInfo.getLocation() &lt;&lt; endl;
-#endif
-			}
-
-			delete pFilter;
-		}
-	}
-
-	// We may not have to download the document
-	if (doDownload == true)
-	{
-		DownloadingThread::doWork();
-	}
-	else
-	{
-		m_pDoc = new Document(m_docInfo);
-
-		m_pDoc-&gt;setTimestamp(m_docInfo.getTimestamp());
-		m_pDoc-&gt;setSize(m_docInfo.getSize());
-	}
-
-	if (m_pDoc != NULL)
-	{
-		string docType(m_pDoc-&gt;getType());
-		bool success = false;
-
-		// The type may have been obtained when downloading
-		if (docType.empty() == false)
-		{
-			// Use the document's type
-			m_docInfo.setType(docType);
-		}
-		else
-		{
-			// Use the type we were supplied with
-			m_pDoc-&gt;setType(m_docInfo.getType());
-		}
-
-		if (m_docInfo.getTitle().empty() == false)
-		{
-			// Use the title we were supplied with
-			m_pDoc-&gt;setTitle(m_docInfo.getTitle());
-		}
-		else
-		{
-			// Use the document's
-			m_docInfo.setTitle(m_pDoc-&gt;getTitle());
-		}
-#ifdef DEBUG
-		cout &lt;&lt; &quot;IndexingThread::doWork: title is &quot; &lt;&lt; m_pDoc-&gt;getTitle() &lt;&lt; endl;
-#endif
-
-		// Check again as the downloader may have altered the MIME type
-		if (FilterUtils::isSupportedType(m_docInfo.getType()) == false)
-		{
-			// Skip unsupported types ?
-			if (m_allowAllMIMETypes == false)
-			{
-				m_errorNum = UNSUPPORTED_TYPE;
-				m_errorParam = m_docInfo.getType();
-				delete pIndex;
-
-				return;
-			}
-
-			// Let FilterWrapper handle unspported documents
-		}
-		else if ((PinotSettings::getInstance().m_ignoreRobotsDirectives == false) &amp;&amp;
-			(m_docInfo.getType().length() &gt;= 9) &amp;&amp;
-			(m_docInfo.getType().substr(9) == &quot;text/html&quot;))
-		{
-			Dijon::HtmlFilter htmlFilter(m_docInfo.getType());
-
-			if ((FilterUtils::feedFilter(*m_pDoc, &amp;htmlFilter) == true) &amp;&amp;
-				(htmlFilter.next_document() == true))
-			{
-				const map&lt;string, string&gt; &amp;metaData = htmlFilter.get_meta_data();
-
-				// See if the document has a ROBOTS META tag
-				map&lt;string, string&gt;::const_iterator robotsIter = metaData.find(&quot;robots&quot;);
-				if (robotsIter != metaData.end())
-				{
-					string robotsDirectives(robotsIter-&gt;second);
-	
-					// Is indexing allowed ?
-					string::size_type pos1 = robotsDirectives.find(&quot;none&quot;);
-					string::size_type pos2 = robotsDirectives.find(&quot;noindex&quot;);
-					if ((pos1 != string::npos) ||
-						(pos2 != string::npos))
-					{
-						// No, it isn't
-						m_errorNum = ROBOTS_FORBIDDEN;
-						m_errorParam = m_docInfo.getLocation();
-						delete pIndex;
-
-						return;
-					}
-				}
-			}
-#ifdef DEBUG
-			else cout &lt;&lt; &quot;IndexingThread::doWork: couldn't check document for ROBOTS directive&quot; &lt;&lt; endl;
-#endif
-		}
-
-		if (m_done == false)
-		{
-			FilterWrapper wrapFilter(pIndex);
-
-			// Update an existing document or add to the index ?
-			if (m_update == true)
-			{
-				// Update the document
-				if (wrapFilter.updateDocument(*m_pDoc, m_docId) == true)
-				{
-#ifdef DEBUG
-					cout &lt;&lt; &quot;IndexingThread::doWork: updated &quot; &lt;&lt; m_pDoc-&gt;getLocation()
-						&lt;&lt; &quot; at &quot; &lt;&lt; m_docId &lt;&lt; endl;
-#endif
-					success = true;
-				}
-#ifdef DEBUG
-				else cout &lt;&lt; &quot;IndexingThread::doWork: couldn't update &quot; &lt;&lt; m_pDoc-&gt;getLocation() &lt;&lt; endl;
-#endif
-			}
-			else
-			{
-				unsigned int docId = 0;
-#ifdef DEBUG
-				cout &lt;&lt; &quot;IndexingThread::doWork: &quot; &lt;&lt; m_docInfo.getLabels().size()
-					&lt;&lt; &quot; labels for URL &quot; &lt;&lt; m_pDoc-&gt;getLocation() &lt;&lt; endl;
-#endif
-
-				// Index the document
-				success = wrapFilter.indexDocument(*m_pDoc, m_docInfo.getLabels(), docId);
-				if (success == true)
-				{
-					m_docId = docId;
-#ifdef DEBUG
-					cout &lt;&lt; &quot;IndexingThread::doWork: indexed &quot; &lt;&lt; m_pDoc-&gt;getLocation()
-						&lt;&lt; &quot; to &quot; &lt;&lt; m_docId &lt;&lt; endl;
-#endif
-				}
-#ifdef DEBUG
-				else cout &lt;&lt; &quot;IndexingThread::doWork: couldn't index &quot; &lt;&lt; m_pDoc-&gt;getLocation() &lt;&lt; endl;
-#endif
-			}
-
-			if (success == false)
-			{
-				m_errorNum = INDEXING_FAILED;
-				m_errorParam = m_docInfo.getLocation();
-			}
-			else
-			{
-				// Flush the index ?
-				if (m_immediateFlush == true)
-				{
-					pIndex-&gt;flush();
-				}
-
-				// The document properties may have changed
-				pIndex-&gt;getDocumentInfo(m_docId, m_docInfo);
-				m_docInfo.setIsIndexed(
-					PinotSettings::getInstance().getIndexPropertiesByLocation(m_indexLocation).m_id,
-					m_docId);
-			}
-		}
-	}
-#ifdef DEBUG
-	else cout &lt;&lt; &quot;IndexingThread::doWork: couldn't download &quot; &lt;&lt; m_docInfo.getLocation() &lt;&lt; endl;
-#endif
-
-	delete pIndex;
-}
-
-UnindexingThread::UnindexingThread(const set&lt;unsigned int&gt; &amp;docIdList) :
-	WorkerThread(),
-	m_indexLocation(PinotSettings::getInstance().m_docsIndexLocation),
-	m_docsCount(0)
-{
-	copy(docIdList.begin(), docIdList.end(), inserter(m_docIdList, m_docIdList.begin()));
-}
-
-UnindexingThread::UnindexingThread(const set&lt;string&gt; &amp;labelNames, const string &amp;indexLocation) :
-	WorkerThread(),
-	m_indexLocation(indexLocation),
-	m_docsCount(0)
-{
-	copy(labelNames.begin(), labelNames.end(), inserter(m_labelNames, m_labelNames.begin()));
-	if (indexLocation.empty() == true)
-	{
-		m_indexLocation = PinotSettings::getInstance().m_docsIndexLocation;
-	}
-}
-
-UnindexingThread::~UnindexingThread()
-{
-}
-
-string UnindexingThread::getType(void) const
-{
-	return &quot;UnindexingThread&quot;;
-}
-
-unsigned int UnindexingThread::getDocumentsCount(void) const
-{
-	return m_docsCount;
-}
-
-void UnindexingThread::doWork(void)
-{
-	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexLocation);
-
-	if ((pIndex == NULL) ||
-		(pIndex-&gt;isGood() == false))
-	{
-		m_errorNum = INDEX_ERROR;
-		m_errorParam = m_indexLocation;
-		if (pIndex != NULL)
-		{
-			delete pIndex;
-		}
-		return;
-	}
-
-	// Be pessimistic and assume something will go wrong ;-)
-	m_errorNum = UNINDEXING_FAILED;
-
-	// Are we supposed to remove documents based on labels ?
-	if (m_docIdList.empty() == true)
-	{
-		// Yep, delete documents one label at a time
-		for (set&lt;string&gt;::iterator iter = m_labelNames.begin(); iter != m_labelNames.end(); ++iter)
-		{
-			string labelName = (*iter);
-
-			// By unindexing all documents that match the label,
-			// we effectively delete the label from the index
-			if (pIndex-&gt;unindexDocuments(labelName, IndexInterface::BY_LABEL) == true)
-			{
-#ifdef DEBUG
-				cout &lt;&lt; &quot;UnindexingThread::doWork: removed label &quot; &lt;&lt; labelName &lt;&lt; endl;
-#endif
-				// OK
-				++m_docsCount;
-			}
-#ifdef DEBUG
-			else cout &lt;&lt; &quot;UnindexingThread::doWork: couldn't remove label &quot; &lt;&lt; labelName &lt;&lt; endl;
-#endif
-		}
-
-		// Nothing to report
-		m_errorNum = 0;
-	}
-	else
-	{
-		for (set&lt;unsigned int&gt;::iterator iter = m_docIdList.begin(); iter != m_docIdList.end(); ++iter)
-		{
-			unsigned int docId = (*iter);
-
-			if (pIndex-&gt;unindexDocument(docId) == true)
-			{
-#ifdef DEBUG
-				cout &lt;&lt; &quot;UnindexingThread::doWork: removed &quot; &lt;&lt; docId &lt;&lt; endl;
-#endif
-				// OK
-				++m_docsCount;
-			}
-#ifdef DEBUG
-			else cout &lt;&lt; &quot;UnindexingThread::doWork: couldn't remove &quot; &lt;&lt; docId &lt;&lt; endl;
-#endif
-		}
-#ifdef DEBUG
-		cout &lt;&lt; &quot;UnindexingThread::doWork: removed &quot; &lt;&lt; m_docsCount &lt;&lt; &quot; documents&quot; &lt;&lt; endl;
-#endif
-	}
-
-	if (m_docsCount &gt; 0)
-	{
-		// Flush the index ?
-		if (m_immediateFlush == true)
-		{
-			pIndex-&gt;flush();
-		}
-
-		// Nothing to report
-		m_errorNum = 0;
-	}
-
-	delete pIndex;
-}
-
-UpdateDocumentThread::UpdateDocumentThread(const PinotSettings::IndexProperties &amp;indexProps, unsigned int docId,
-	const DocumentInfo &amp;docInfo, bool updateLabels) :
-	WorkerThread(),
-	m_indexProps(indexProps),
-	m_docId(docId),
-	m_docInfo(docInfo),
-	m_updateLabels(updateLabels)
-{
-}
-
-UpdateDocumentThread::~UpdateDocumentThread()
-{
-}
-
-string UpdateDocumentThread::getType(void) const
-{
-	return &quot;UpdateDocumentThread&quot;;
-}
-
-PinotSettings::IndexProperties UpdateDocumentThread::getIndexProperties(void) const
-{
-	return m_indexProps;
-}
-
-unsigned int UpdateDocumentThread::getDocumentID(void) const
-{
-	return m_docId;
-}
-
-const DocumentInfo &amp;UpdateDocumentThread::getDocumentInfo(void) const
-{
-	return m_docInfo;
-}
-
-void UpdateDocumentThread::doWork(void)
-{
-	if (m_done == false)
-	{
-		if (m_indexProps.m_location.empty() == true)
-		{
-			m_errorNum = UNKNOWN_INDEX;
-			m_errorParam = m_indexProps.m_name.c_str();
-			return;
-		}
-
-		// Get the index at that location
-		IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexProps.m_location);
-		if ((pIndex == NULL) ||
-			(pIndex-&gt;isGood() == false))
-		{
-			m_errorNum = INDEX_ERROR;
-			m_errorParam = m_indexProps.m_location;
-			if (pIndex != NULL)
-			{
-				delete pIndex;
-			}
-			return;
-		}
-
-		// Update the DocumentInfo
-		if (pIndex-&gt;updateDocumentInfo(m_docId, m_docInfo) == false)
-		{
-			m_errorNum = UPDATE_FAILED;
-			m_errorParam = m_docInfo.getLocation();
-			return;
-		}
-		// ...and the labels if necessary
-		if (m_updateLabels == true)
-		{
-			if (pIndex-&gt;setDocumentLabels(m_docId, m_docInfo.getLabels()) == false)
-			{
-				m_errorNum = UPDATE_FAILED;
-				m_errorParam = m_docInfo.getLocation();
-				return;
-			}
-		}
-
-		// Flush the index ?
-		if (m_immediateFlush == true)
-		{
-			pIndex-&gt;flush();
-		}
-
-		delete pIndex;
-	}
-}
-
-MonitorThread::MonitorThread(MonitorInterface *pMonitor, MonitorHandler *pHandler,
-	bool checkHistory) :
-	WorkerThread(),
-	m_ctrlReadPipe(-1),
-	m_ctrlWritePipe(-1),
-	m_pMonitor(pMonitor),
-	m_pHandler(pHandler),
-	m_checkHistory(checkHistory)
-{
-	int pipeFds[2];
-
-#ifdef HAVE_PIPE
-	if (pipe(pipeFds) == 0)
-	{
-		// This pipe will allow to stop select()
-		m_ctrlReadPipe = pipeFds[0];
-		m_ctrlWritePipe = pipeFds[1];
-	}
-#endif
-}
-
-MonitorThread::~MonitorThread()
-{
-	if (m_ctrlReadPipe &gt;= 0)
-	{
-		close(m_ctrlReadPipe);
-	}
-	if (m_ctrlWritePipe &gt;= 0)
-	{
-		close(m_ctrlWritePipe);
-	}
-}
-
-string MonitorThread::getType(void) const
-{
-	return &quot;MonitorThread&quot;;
-}
-
-void MonitorThread::stop(void)
-{
-	WorkerThread::stop();
-	if (m_ctrlWritePipe &gt;= 0)
-	{
-		write(m_ctrlWritePipe, &quot;X&quot;, 1);
-	}
-}
-
-void MonitorThread::processEvents(void)
-{
-	CrawlHistory crawlHistory(PinotSettings::getInstance().getHistoryDatabaseName());
-	queue&lt;MonitorEvent&gt; events;
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;MonitorThread::processEvents: checking for events&quot; &lt;&lt; endl;
-#endif
-	if ((m_pMonitor == NULL) ||
-		(m_pMonitor-&gt;retrievePendingEvents(events) == false))
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;MonitorThread::processEvents: failed to retrieve pending events&quot; &lt;&lt; endl;
-#endif
-		return;
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;MonitorThread::processEvents: retrieved &quot; &lt;&lt; events.size() &lt;&lt; &quot; events&quot; &lt;&lt; endl;
-#endif
-
-	while ((events.empty() == false) &amp;&amp;
-		(m_done == false))
-	{
-		MonitorEvent &amp;event = events.front();
-
-		if ((event.m_location.empty() == true) ||
-			(event.m_type == MonitorEvent::UNKNOWN))
-		{
-			// Next
-			events.pop();
-			continue;
-		}
-#ifdef DEBUG
-		cout &lt;&lt; &quot;MonitorThread::processEvents: event &quot; &lt;&lt; event.m_type &lt;&lt; &quot; on &quot;
-			&lt;&lt; event.m_location &lt;&lt; &quot; &quot; &lt;&lt; event.m_isDirectory &lt;&lt; endl;
-#endif
-
-		// Skip dotfiles and blacklisted files
-		Url urlObj(&quot;<A HREF="file://">file://</A>&quot; + event.m_location);
-		if ((urlObj.getFile()[0] == '.') ||
-			(PinotSettings::getInstance().isBlackListed(event.m_location) == true))
-		{
-			// Next
-			events.pop();
-			continue;
-		}
-
-		// What's the event code ?
-		if (event.m_type == MonitorEvent::EXISTS)
-		{
-			if (event.m_isDirectory == false)
-			{
-				m_pHandler-&gt;fileExists(event.m_location);
-			}
-		}
-		else if (event.m_type == MonitorEvent::CREATED)
-		{
-			if (event.m_isDirectory == false)
-			{
-				m_pHandler-&gt;fileCreated(event.m_location);
-			}
-			else
-			{
-				m_pHandler-&gt;directoryCreated(event.m_location);
-			}
-		}
-		else if (event.m_type == MonitorEvent::WRITE_CLOSED)
-		{
-			if (event.m_isDirectory == false)
-			{
-				CrawlHistory::CrawlStatus status = CrawlHistory::UNKNOWN;
-				struct stat fileStat;
-				time_t itemDate = 0;
-
-				if (m_checkHistory == false)
-				{
-					m_pHandler-&gt;fileModified(event.m_location);
-				}
-				else if (crawlHistory.hasItem(&quot;<A HREF="file://">file://</A>&quot; + event.m_location, status, itemDate) == true)
-				{
-					// Was the file actually modified ?
-					if ((stat(event.m_location.c_str(), &amp;fileStat) == 0) &amp;&amp;
-						(itemDate &lt; fileStat.st_mtime))
-					{
-						m_pHandler-&gt;fileModified(event.m_location);
-					}
-#ifdef DEBUG
-					else cout &lt;&lt; &quot;MonitorThread::processEvents: file wasn't modified&quot; &lt;&lt; endl;
-#endif
-				}
-#ifdef DEBUG
-				else cout &lt;&lt; &quot;MonitorThread::processEvents: file wasn't crawled&quot; &lt;&lt; endl;
-#endif
-			}
-		}
-		else if (event.m_type == MonitorEvent::MOVED)
-		{
-			if (event.m_isDirectory == false)
-			{
-				m_pHandler-&gt;fileMoved(event.m_location, event.m_previousLocation);
-			}
-			else
-			{
-				// We should receive this only if the destination directory is monitored too
-				m_pHandler-&gt;directoryMoved(event.m_location, event.m_previousLocation);
-			}
-		}
-		else if (event.m_type == MonitorEvent::DELETED)
-		{
-			if (event.m_isDirectory == false)
-			{
-				m_pHandler-&gt;fileDeleted(event.m_location);
-			}
-			else
-			{
-				// The monitor should have stopped monitoring this
-				// In practice, events for the files in this directory will already have been received 
-				m_pHandler-&gt;directoryDeleted(event.m_location);
-			}
-		}
-
-		// Next
-		events.pop();
-	}
-}
-
-void MonitorThread::doWork(void)
-{
-	if ((m_pHandler == NULL) ||
-		(m_pMonitor == NULL))
-	{
-		m_errorNum = NO_MONITORING;
-		return;
-	}
-
-	// Initialize the handler
-	m_pHandler-&gt;initialize();
-
-	// Get the list of files to monitor
-	const set&lt;string&gt; &amp;fileNames = m_pHandler-&gt;getFileNames();
-	for (set&lt;string&gt;::const_iterator fileIter = fileNames.begin();
-		fileIter != fileNames.end(); ++fileIter)
-	{
-		m_pMonitor-&gt;addLocation(*fileIter, false);
-	}
-	// Directories, if any, are set elsewhere
-	// In the case of OnDiskHandler, they are set by DirectoryScannerThread
-
-	// There might already be events that need processing
-	processEvents();
-
-	// Wait for something to happen
-	while (m_done == false)
-	{
-		struct timeval selectTimeout;
-		fd_set listenSet;
-
-		selectTimeout.tv_sec = 60;
-		selectTimeout.tv_usec = 0;
-
-		FD_ZERO(&amp;listenSet);
-		if (m_ctrlReadPipe &gt;= 0)
-		{
-			FD_SET(m_ctrlReadPipe, &amp;listenSet);
-		}
-
-		m_pHandler-&gt;flushIndex();
-
-		// The file descriptor may change over time
-		int monitorFd = m_pMonitor-&gt;getFileDescriptor();
-		FD_SET(monitorFd, &amp;listenSet);
-		if (monitorFd &lt; 0)
-		{
-			m_errorNum = MONITORING_FAILED;
-			return;
-		}
-
-		int fdCount = select(max(monitorFd, m_ctrlReadPipe) + 1, &amp;listenSet, NULL, NULL, &amp;selectTimeout);
-		if ((fdCount &lt; 0) &amp;&amp;
-			(errno != EINTR))
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;MonitorThread::doWork: select() failed&quot; &lt;&lt; endl;
-#endif
-			break;
-		}
-		else if (FD_ISSET(monitorFd, &amp;listenSet))
-		{
-			processEvents();
-		}
-	}
-}
-

Deleted: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,513 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _WORKERTHREADS_HH
-#define _WORKERTHREADS_HH
-
-#include &lt;time.h&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;queue&gt;
-#include &lt;set&gt;
-#include &lt;map&gt;
-#include &lt;pthread.h&gt;
-#include &lt;sigc++/sigc++.h&gt;
-#include &lt;glibmm/dispatcher.h&gt;
-#include &lt;glibmm/thread.h&gt;
-#include &lt;glibmm/ustring.h&gt;
-
-#include &quot;Document.h&quot;
-#include &quot;DownloaderInterface.h&quot;
-#include &quot;MonitorInterface.h&quot;
-#include &quot;MonitorHandler.h&quot;
-#include &quot;QueryProperties.h&quot;
-
-class WorkerThread
-{
-	public:
-		WorkerThread();
-		virtual ~WorkerThread();
-
-		typedef enum { UNKNOWN_ERROR = 10000, INDEX_ERROR, INDEXING_FAILED, UPDATE_FAILED, UNINDEXING_FAILED, \
-			QUERY_FAILED, HISTORY_FAILED, DOWNLOAD_FAILED, MONITORING_FAILED, OPENDIR_FAILED, \
-			UNKNOWN_INDEX, UNKNOWN_ENGINE, UNSUPPORTED_TYPE, UNSUPPORTED_PROTOCOL, \
-			ROBOTS_FORBIDDEN, NO_MONITORING } ThreadError;
-
-		static std::string errorToString(int errorNum);
-
-		static Glib::Dispatcher &amp;getDispatcher(void);
-
-		static void immediateFlush(bool doFlush);
-
-		time_t getStartTime(void) const;
-
-		void setId(unsigned int id);
-
-		unsigned int getId(void) const;
-
-		void inBackground(void);
-
-		bool isBackground(void) const;
-
-		bool operator&lt;(const WorkerThread &amp;other) const;
-
-		Glib::Thread *start(void);
-
-		virtual std::string getType(void) const = 0;
-
-		virtual void stop(void);
-
-		bool isStopped(void) const;
-
-		bool isDone(void) const;
-
-		int getErrorNum(void) const;
-
-		std::string getStatus(void) const;
-
-	protected:
-		/// Use a Dispatcher for thread safety
-		static Glib::Dispatcher m_dispatcher;
-		static pthread_mutex_t m_dispatcherMutex;
-		static bool m_immediateFlush;
-		time_t m_startTime;
-		unsigned int m_id;
-		bool m_background;
-		bool m_stopped;
-		bool m_done;
-		int m_errorNum;
-		std::string m_errorParam;
-
-		void threadHandler(void);
-
-		virtual void doWork(void) = 0;
-
-		void emitSignal(void);
-
-	private:
-		WorkerThread(const WorkerThread &amp;other);
-		WorkerThread &amp;operator=(const WorkerThread &amp;other);
-
-};
-
-class ThreadsManager : virtual public sigc::trackable
-{
-	public:
-		ThreadsManager(const std::string &amp;defaultIndexLocation,
-			unsigned int maxIndexThreads,
-			unsigned int maxThreadsTime = 300);
-		virtual ~ThreadsManager();
-
-		static unsigned int get_next_id(void);
-
-		bool start_thread(WorkerThread *pWorkerThread, bool inBackground = false);
-
-		unsigned int get_threads_count(void);
-
-		void stop_threads(void);
-
-		virtual void connect(void);
-
-		virtual void disconnect(void);
-
-		void on_thread_signal();
-
-		bool read_lock_lists(void);
-
-		bool write_lock_lists(void);
-
-		void unlock_lists(void);
-
-		Glib::ustring queue_index(const DocumentInfo &amp;docInfo);
-
-		bool pop_queue(const std::string &amp;urlWasIndexed = &quot;&quot;);
-
-	protected:
-		static unsigned int m_nextThreadId;
-		sigc::connection m_threadsEndConnection;
-		pthread_rwlock_t m_threadsLock;
-		pthread_rwlock_t m_listsLock;
-		std::map&lt;unsigned int, WorkerThread *&gt; m_threads;
-		std::string m_defaultIndexLocation;
-		unsigned int m_maxIndexThreads;
-		unsigned int m_backgroundThreadsCount;
-		unsigned int m_foregroundThreadsMaxTime;
-		long m_numCPUs;
-		sigc::signal1&lt;void, WorkerThread *&gt; m_onThreadEndSignal;
-		std::set&lt;std::string&gt; m_beingIndexed;
-		bool m_stopIndexing;
-
-		bool read_lock_threads(void);
-
-		bool write_lock_threads(void);
-
-		void unlock_threads(void);
-
-		WorkerThread *get_thread(void);
-
-		Glib::ustring index_document(const DocumentInfo &amp;docInfo);
-
-		void clear_queues(void);
-
-	private:
-		ThreadsManager(const ThreadsManager &amp;other);
-		ThreadsManager &amp;operator=(const ThreadsManager &amp;other);
-
-};
-
-class ListerThread : public WorkerThread
-{
-	public:
-		ListerThread(const PinotSettings::IndexProperties &amp;indexProps,
-			unsigned int startDoc);
-		~ListerThread();
-
-		std::string getType(void) const;
-
-		PinotSettings::IndexProperties getIndexProperties(void) const;
-
-		unsigned int getStartDoc(void) const;
-
-		const std::vector&lt;DocumentInfo&gt; &amp;getDocuments(void) const;
-
-		unsigned int getDocumentsCount(void) const;
-
-	protected:
-		PinotSettings::IndexProperties m_indexProps;
-		unsigned int m_startDoc;
-		std::vector&lt;DocumentInfo&gt; m_documentsList;
-		unsigned int m_documentsCount;
-
-	private:
-		ListerThread(const ListerThread &amp;other);
-		ListerThread &amp;operator=(const ListerThread &amp;other);
-
-};
-
-class IndexBrowserThread : public ListerThread
-{
-	public:
-		IndexBrowserThread(const PinotSettings::IndexProperties &amp;indexProps,
-			unsigned int maxDocsCount, unsigned int startDoc = 0);
-		~IndexBrowserThread();
-
-		std::string getLabelName(void) const;
-
-	protected:
-		unsigned int m_maxDocsCount;
-
-		virtual void doWork(void);
-
-	private:
-		IndexBrowserThread(const IndexBrowserThread &amp;other);
-		IndexBrowserThread &amp;operator=(const IndexBrowserThread &amp;other);
-
-};
-
-class QueryingThread : public ListerThread
-{
-	public:
-		QueryingThread(const PinotSettings::IndexProperties &amp;indexProps,
-			const QueryProperties &amp;queryProps, unsigned int startDoc = 0,
-			bool listingIndex = false);
-		QueryingThread(const std::string &amp;engineName, const std::string &amp;engineDisplayableName,
-			const std::string &amp;engineOption, const QueryProperties &amp;queryProps,
-			unsigned int startDoc = 0);
-		virtual ~QueryingThread();
-
-		virtual std::string getType(void) const;
-
-		bool isLive(void) const;
-
-		std::string getEngineName(void) const;
-
-		QueryProperties getQuery(bool &amp;wasCorrected) const;
-
-		std::string getCharset(void) const;
-
-	protected:
-		std::string m_engineName;
-		std::string m_engineDisplayableName;
-		std::string m_engineOption;
-		QueryProperties m_queryProps;
-		std::string m_resultsCharset;
-		bool m_listingIndex;
-		bool m_correctedSpelling;
-		bool m_isLive;
-
-		bool findPlugin(void);
-
-	private:
-		QueryingThread(const QueryingThread &amp;other);
-		QueryingThread &amp;operator=(const QueryingThread &amp;other);
-
-};
-
-class EngineQueryThread : public QueryingThread
-{
-	public:
-		EngineQueryThread(const PinotSettings::IndexProperties &amp;indexProps,
-			const QueryProperties &amp;queryProps, unsigned int startDoc = 0,
-			bool listingIndex = false);
-		EngineQueryThread(const PinotSettings::IndexProperties &amp;indexProps,
-			const QueryProperties &amp;queryProps,
-			const std::set&lt;std::string&gt; &amp;limitToDocsSet, unsigned int startDoc = 0);
-		EngineQueryThread(const std::string &amp;engineName, const std::string &amp;engineDisplayableName,
-			const std::string &amp;engineOption, const QueryProperties &amp;queryProps,
-			unsigned int startDoc = 0);
-		virtual ~EngineQueryThread();
-
-	protected:
-		std::set&lt;std::string&gt; m_limitToDocsSet;
-
-		virtual void processResults(const std::vector&lt;DocumentInfo&gt; &amp;resultsList);
-
-		virtual void processResults(const std::vector&lt;DocumentInfo&gt; &amp;resultsList,
-			unsigned int indexId);
-
-		virtual void doWork(void);
-
-	private:
-		EngineQueryThread(const EngineQueryThread &amp;other);
-		EngineQueryThread &amp;operator=(const EngineQueryThread &amp;other);
-
-};
-
-class EngineHistoryThread : public QueryingThread
-{
-	public:
-		EngineHistoryThread(const std::string &amp;engineDisplayableName,
-			const QueryProperties &amp;queryProps, unsigned int maxDocsCount);
-		virtual ~EngineHistoryThread();
-
-	protected:
-		unsigned int m_maxDocsCount;
-
-		virtual void doWork(void);
-
-	private:
-		EngineHistoryThread(const EngineHistoryThread &amp;other);
-		EngineHistoryThread &amp;operator=(const EngineHistoryThread &amp;other);
-
-};
-
-class ExpandQueryThread : public WorkerThread
-{
-	public:
-		ExpandQueryThread(const QueryProperties &amp;queryProps,
-			const std::set&lt;std::string&gt; &amp;expandFromDocsSet);
-		virtual ~ExpandQueryThread();
-
-		virtual std::string getType(void) const;
-
-		QueryProperties getQuery(void) const;
-
-		const std::set&lt;std::string&gt; &amp;getExpandTerms(void) const;
-
-	protected:
-		QueryProperties m_queryProps;
-		std::set&lt;std::string&gt; m_expandFromDocsSet;
-		std::set&lt;std::string&gt; m_expandTerms;
-
-		virtual void doWork(void);
-
-	private:
-		ExpandQueryThread(const ExpandQueryThread &amp;other);
-		ExpandQueryThread &amp;operator=(const ExpandQueryThread &amp;other);
-
-};
-
-class LabelUpdateThread : public WorkerThread
-{
-	public:
-		LabelUpdateThread(const std::set&lt;std::string&gt; &amp;labelsToAdd,
-			const std::set&lt;std::string&gt; &amp;labelsToDelete);
-		LabelUpdateThread(const std::set&lt;std::string&gt; &amp;labelsToAdd,
-			const std::set&lt;unsigned int&gt; &amp;docsIds,
-			const std::set&lt;unsigned int&gt; &amp;daemonIds,
-			bool resetLabels);
-
-		virtual ~LabelUpdateThread();
-
-		virtual std::string getType(void) const;
-
-		bool modifiedDocsIndex(void) const;
-
-		bool modifiedDaemonIndex(void) const;
-
-	protected:
-		std::set&lt;std::string&gt; m_labelsToAdd;
-		std::set&lt;std::string&gt; m_labelsToDelete;
-		std::set&lt;unsigned int&gt; m_docsIds;
-		std::set&lt;unsigned int&gt; m_daemonIds;
-		bool m_resetLabels;
-
-		virtual void doWork(void);
-
-	private:
-		LabelUpdateThread(const LabelUpdateThread &amp;other);
-		LabelUpdateThread &amp;operator=(const LabelUpdateThread &amp;other);
-
-};
-
-class DownloadingThread : public WorkerThread
-{
-	public:
-		DownloadingThread(const DocumentInfo &amp;docInfo);
-		virtual ~DownloadingThread();
-
-		virtual std::string getType(void) const;
-
-		std::string getURL(void) const;
-
-		const Document *getDocument(void) const;
-
-	protected:
-		DocumentInfo m_docInfo;
-		Document *m_pDoc;
-		DownloaderInterface *m_pDownloader;
-
-		DownloadingThread();
-
-		virtual void doWork(void);
-
-	private:
-		DownloadingThread(const DownloadingThread &amp;other);
-		DownloadingThread &amp;operator=(const DownloadingThread &amp;other);
-
-};
-
-class IndexingThread : public DownloadingThread
-{
-	public:
-		IndexingThread(const DocumentInfo &amp;docInfo, const std::string &amp;indexLocation,
-			bool allowAllMIMETypes = true);
-		virtual ~IndexingThread();
-
-		virtual std::string getType(void) const;
-
-		const DocumentInfo &amp;getDocumentInfo(void) const;
-
-		std::string getLabelName(void) const;
-
-		unsigned int getDocumentID(void) const;
-
-		bool isNewDocument(void) const;
-
-	protected:
-		unsigned int m_docId;
-		std::string m_indexLocation;
-		bool m_allowAllMIMETypes;
-		bool m_update;
-
-		IndexingThread();
-
-		virtual void doWork(void);
-
-	private:
-		IndexingThread(const IndexingThread &amp;other);
-		IndexingThread &amp;operator=(const IndexingThread &amp;other);
-
-};
-
-class UnindexingThread : public WorkerThread
-{
-	public:
-		// Unindex documents from the internal index
-		UnindexingThread(const std::set&lt;unsigned int&gt; &amp;docIdList);
-		// Unindex from the given index documents that have one of the labels
-		UnindexingThread(const std::set&lt;std::string&gt; &amp;labelNames, const std::string &amp;indexLocation);
-		virtual ~UnindexingThread();
-
-		virtual std::string getType(void) const;
-
-		unsigned int getDocumentsCount(void) const;
-
-	protected:
-		std::set&lt;unsigned int&gt; m_docIdList;
-		std::set&lt;std::string&gt; m_labelNames;
-		std::string m_indexLocation;
-		unsigned int m_docsCount;
-
-		virtual void doWork(void);
-
-	private:
-		UnindexingThread(const UnindexingThread &amp;other);
-		UnindexingThread &amp;operator=(const UnindexingThread &amp;other);
-
-};
-
-class UpdateDocumentThread : public WorkerThread
-{
-	public:
-		// Update a document's properties
-		UpdateDocumentThread(const PinotSettings::IndexProperties &amp;indexProps,
-			unsigned int docId, const DocumentInfo &amp;docInfo,
-			bool updateLabels);
-		virtual ~UpdateDocumentThread();
-
-		virtual std::string getType(void) const;
-
-		PinotSettings::IndexProperties getIndexProperties(void) const;
-
-		unsigned int getDocumentID(void) const;
-
-		const DocumentInfo &amp;getDocumentInfo(void) const;
-
-	protected:
-		PinotSettings::IndexProperties m_indexProps;
-		unsigned int m_docId;
-		DocumentInfo m_docInfo;
-		bool m_updateLabels;
-
-		virtual void doWork(void);
-
-	private:
-		UpdateDocumentThread(const UpdateDocumentThread &amp;other);
-		UpdateDocumentThread &amp;operator=(const UpdateDocumentThread &amp;other);
-
-};
-
-class MonitorThread : public WorkerThread
-{
-	public:
-		MonitorThread(MonitorInterface *pMonitor, MonitorHandler *pHandler,
-			bool checkHistory = true);
-		virtual ~MonitorThread();
-
-		virtual std::string getType(void) const;
-
-		virtual void stop(void);
-
-	protected:
-		int m_ctrlReadPipe;
-		int m_ctrlWritePipe;
-		MonitorInterface *m_pMonitor;
-		MonitorHandler *m_pHandler;
-		bool m_checkHistory;
-
-		void processEvents(void);
-		virtual void doWork(void);
-
-	private:
-		MonitorThread(const MonitorThread &amp;other);
-		MonitorThread &amp;operator=(const MonitorThread &amp;other);
-
-};
-
-#endif // _WORKERTHREADS_HH

Deleted: trunk/UI/GTK2/src/de.berlios.Pinot.service.in
===================================================================
--- trunk/UI/GTK2/src/de.berlios.Pinot.service.in	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/de.berlios.Pinot.service.in	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,3 +0,0 @@
-[D-BUS Service]
-Name=de.berlios.Pinot
-Exec=@BINDIR@/pinot-dbus-daemon

Deleted: trunk/UI/GTK2/src/pinot-dbus-daemon.1
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.1	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.1	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,34 +0,0 @@
-.\&quot; DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-DBUS-DAEMON &quot;1&quot; &quot;January 2009&quot; &quot;pinot-dbus-daemon - pinot 0.90&quot; &quot;User Commands&quot;
-.SH NAME
-pinot-dbus-daemon \- D-Bus search and index daemon
-.SH SYNOPSIS
-.B pinot-dbus-daemon
-[\fIOPTIONS\fR]
-.SH DESCRIPTION
-pinot\-dbus\-daemon \- D\-Bus search and index daemon
-.SH OPTIONS
-.TP
-\fB\-f\fR, \fB\-\-fullscan\fR
-force a full scan
-.TP
-\fB\-h\fR, \fB\-\-help\fR
-display this help and exit
-.TP
-\fB\-i\fR, \fB\-\-ignore\-version\fR
-ignore the index version number
-.TP
-\fB\-p\fR, \fB\-\-priority\fR
-set the daemon's priority (default 15)
-.TP
-\fB\-r\fR, \fB\-\-reindex\fR
-force a reindex
-.TP
-\fB\-v\fR, \fB\-\-version\fR
-output version information and exit
-.SH &quot;REPORTING BUGS&quot;
-Report bugs to <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabricecolin at users.berlios.de</A>
-.PP
-This is free software.  You may redistribute copies of it under the terms of
-the GNU General Public License &lt;<A HREF="http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html">http://www.gnu.org/licenses/old\-licenses/gpl\-2.0.html</A>&gt;.
-There is NO WARRANTY, to the extent permitted by law.

Deleted: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,754 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;stdlib.h&gt;
-#include &lt;libintl.h&gt;
-#include &lt;getopt.h&gt;
-#include &lt;sys/time.h&gt;
-#include &lt;sys/resource.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;iostream&gt;
-#include &lt;sstream&gt;
-#include &lt;fstream&gt;
-#include &lt;cstring&gt;
-#include &lt;sigc++/sigc++.h&gt;
-#include &lt;glibmm.h&gt;
-#include &lt;glibmm/thread.h&gt;
-#include &lt;glibmm/ustring.h&gt;
-#include &lt;glibmm/miscutils.h&gt;
-#include &lt;glibmm/convert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;NLS.h&quot;
-#include &quot;FilterFactory.h&quot;
-#include &quot;Languages.h&quot;
-#include &quot;MIMEScanner.h&quot;
-#include &quot;ModuleFactory.h&quot;
-#include &quot;ActionQueue.h&quot;
-#include &quot;CrawlHistory.h&quot;
-#include &quot;MetaDataBackup.h&quot;
-#include &quot;QueryHistory.h&quot;
-#include &quot;ViewHistory.h&quot;
-#include &quot;DownloaderInterface.h&quot;
-#include &quot;DaemonState.h&quot;
-#include &quot;PinotSettings.h&quot;
-#include &quot;ServerThreads.h&quot;
-#include &quot;UniqueApplication.h&quot;
-
-using namespace std;
-
-static ofstream g_outputFile;
-static string g_pidFileName;
-static streambuf *g_coutBuf = NULL;
-static streambuf *g_cerrBuf = NULL;
-static struct option g_longOptions[] = {
-	{&quot;fullscan&quot;, 0, 0, 'f'},
-	{&quot;help&quot;, 0, 0, 'h'},
-	{&quot;ignore-version&quot;, 0, 0, 'i'},
-	{&quot;priority&quot;, 1, 0, 'p'},
-	{&quot;reindex&quot;, 0, 0, 'r'},
-	{&quot;version&quot;, 0, 0, 'v'},
-	{0, 0, 0, 0}
-};
-static const char *g_pinotDBusService = &quot;de.berlios.Pinot&quot;;
-static const char *g_pinotDBusObjectPath = &quot;/de/berlios/Pinot&quot;;
-static void unregisteredHandler(DBusConnection *pConnection, void *pData);
-static DBusHandlerResult messageHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData);
-static DBusObjectPathVTable g_callVTable = {
-	(DBusObjectPathUnregisterFunction)unregisteredHandler,
-        (DBusObjectPathMessageFunction)messageHandler,
-	NULL,
-};
-static Glib::RefPtr&lt;Glib::MainLoop&gt; g_refMainLoop;
-
-static void closeAll(void)
-{
-	cout &lt;&lt; &quot;Exiting...&quot; &lt;&lt; endl;
-
-	// Close everything
-	ModuleFactory::unloadModules();
-	Dijon::FilterFactory::unloadFilters();
-	Dijon::HtmlFilter::shutdown();
-
-	// Restore the stream buffers
-	if (g_coutBuf != NULL)
-	{
-		cout.rdbuf(g_coutBuf);
-	}
-	if (g_cerrBuf != NULL)
-	{
-		cerr.rdbuf(g_cerrBuf);
-	}
-	g_outputFile.close();
-	if (g_pidFileName.empty() == false)
-	{
-		unlink(g_pidFileName.c_str());
-	}
-
-	DownloaderInterface::shutdown();
-	MIMEScanner::shutdown();
-}
-
-static void quitAll(int sigNum)
-{
-	if (g_refMainLoop-&gt;is_running() == true)
-	{
-		cout &lt;&lt; &quot;Quitting...&quot; &lt;&lt; endl;
-
-		g_refMainLoop-&gt;quit();
-	}
-}
-
-static DBusHandlerResult filterHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
-{
-	DaemonState *pServer = (DaemonState *)pData;
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;filterHandler: called&quot; &lt;&lt; endl;
-#endif
-	// Are we about to be disconnected ?
-	if (dbus_message_is_signal(pMessage, DBUS_INTERFACE_LOCAL, &quot;Disconnected&quot;) == TRUE)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;filterHandler: received Disconnected&quot; &lt;&lt; endl;
-#endif
-		if (pServer != NULL)
-		{
-			pServer-&gt;set_flag(DaemonState::DISCONNECTED);
-		}
-		quitAll(0);
-	}
-	else if (dbus_message_is_signal(pMessage, DBUS_INTERFACE_DBUS, &quot;NameOwnerChanged&quot;) == TRUE)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;filterHandler: received NameOwnerChanged&quot; &lt;&lt; endl;
-#endif
-	}
-	// The first two signals are specified by the freedesktop.org Power Management spec v0.1 and v0.2
-	else if ((dbus_message_is_signal(pMessage, &quot;org.freedesktop.PowerManagement&quot;, &quot;BatteryStateChanged&quot;) == TRUE) ||
-		(dbus_message_is_signal(pMessage, &quot;org.freedesktop.PowerManagement&quot;, &quot;OnBatteryChanged&quot;) == TRUE) ||
-		(dbus_message_is_signal(pMessage, &quot;org.gnome.PowerManager&quot;, &quot;OnAcChanged&quot;) == TRUE))
-	{
-		DBusError error;
-		gboolean onBattery = FALSE;
-
-#ifdef DEBUG
-		cout &lt;&lt; &quot;filterHandler: received OnBatteryChanged&quot; &lt;&lt; endl;
-#endif
-		dbus_error_init(&amp;error);
-		if ((dbus_message_get_args(pMessage, &amp;error,
-			DBUS_TYPE_BOOLEAN, &amp;onBattery,
-			DBUS_TYPE_INVALID) == TRUE) &amp;&amp;
-			(pData != NULL))
-		{
-			if (dbus_message_is_signal(pMessage, &quot;org.gnome.PowerManager&quot;, &quot;OnAcChanged&quot;) == TRUE)
-			{
-				// This tells us if we are on AC, not on battery
-				if (onBattery == TRUE)
-				{
-					onBattery = FALSE;
-				}
-				else
-				{
-					onBattery = TRUE;
-				}
-			}
-
-			if (onBattery == TRUE)
-			{
-				// We are now on battery
-				if (pServer != NULL)
-				{
-					pServer-&gt;set_flag(DaemonState::ON_BATTERY);
-					pServer-&gt;stop_crawling();
-				}
-
-				cout &lt;&lt; &quot;System is now on battery&quot; &lt;&lt; endl;
-			}
-			else
-			{
-				// Back on-line
-				if (pServer != NULL)
-				{
-					pServer-&gt;reset_flag(DaemonState::ON_BATTERY);
-					pServer-&gt;start_crawling();
-				}
-
-				cout &lt;&lt; &quot;System is now on AC&quot; &lt;&lt; endl;
-			}
-		}
-		dbus_error_free(&amp;error);
-	}
-
-	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-}
-
-static void unregisteredHandler(DBusConnection *pConnection, void *pData)
-{
-#ifdef DEBUG
-	cout &lt;&lt; &quot;unregisteredHandler: called&quot; &lt;&lt; endl;
-#endif
-}
-
-static DBusHandlerResult messageHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
-{
-	DaemonState *pServer = (DaemonState *)pData;
-
-	if ((pConnection != NULL) &amp;&amp;
-		(pMessage != NULL))
-	{
-		dbus_connection_ref(pConnection);
-		dbus_message_ref(pMessage);
-
-		if (pServer != NULL)
-		{
-			DBusServletInfo *pInfo = new DBusServletInfo(pConnection, pMessage);
-
-			pServer-&gt;start_thread(new DBusServletThread(pServer, pInfo));
-		}
-	}
-
-	return DBUS_HANDLER_RESULT_HANDLED;
-}
-
-static bool getBatteryState(DBusGConnection *pBus, const string &amp;name, const string &amp;path,
-	const string &amp;method, gboolean &amp;result)
-{
-	bool callSuccess = true;
-
-	if ((pBus == NULL) ||
-		(name.empty() == true) ||
-		(path.empty() == true) ||
-		(method.empty() == true))
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = dbus_g_proxy_new_for_name(pBus, name.c_str(),
-		path.c_str(), name.c_str());
-	if (pBusProxy == NULL)
-	{
-		return false;
-	}
-
-	GError *pError = NULL;
-	if (dbus_g_proxy_call(pBusProxy, method.c_str(), &amp;pError,
-		G_TYPE_INVALID,
-		G_TYPE_BOOLEAN, &amp;result,
-		G_TYPE_INVALID) == FALSE)
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;Couldn't get battery state: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			g_error_free(pError);
-		}
-
-		callSuccess = false;
-	}
-
-	g_object_unref(pBusProxy);
-
-	return callSuccess;
-}
-
-int main(int argc, char **argv)
-{
-	int longOptionIndex = 0, priority = 15;
-	bool resetHistory = false;
-	bool resetLabels = false;
-	bool fullScan = false;
-	bool reindex = false;
-	bool ignoreVersion = false;
-
-	// Look at the options
-	int optionChar = getopt_long(argc, argv, &quot;fhip:rv&quot;, g_longOptions, &amp;longOptionIndex);
-	while (optionChar != -1)
-	{
-		switch (optionChar)
-		{
-			case 'f':
-				fullScan = true;
-				break;
-			case 'h':
-				// Help
-				cout &lt;&lt; &quot;pinot-dbus-daemon - D-Bus search and index daemon\n\n&quot;
-					&lt;&lt; &quot;Usage: pinot-dbus-daemon [OPTIONS]\n\n&quot;
-					&lt;&lt; &quot;Options:\n&quot;
-					&lt;&lt; &quot;  -f, --fullscan	force a full scan\n&quot;
-					&lt;&lt; &quot;  -h, --help		display this help and exit\n&quot;
-					&lt;&lt; &quot;  -i, --ignore-version	ignore the index version number\n&quot;
-					&lt;&lt; &quot;  -p, --priority	set the daemon's priority (default 15)\n&quot;
-					&lt;&lt; &quot;  -r, --reindex		force a reindex\n&quot;
-					&lt;&lt; &quot;  -v, --version		output version information and exit\n&quot;
-					&lt;&lt; &quot;\nReport bugs to &quot; &lt;&lt; PACKAGE_BUGREPORT &lt;&lt; endl;
-				return EXIT_SUCCESS;
-			case 'i':
-				ignoreVersion = true;
-				break;
-			case 'p':
-				if (optarg != NULL)
-				{
-					int newPriority = atoi(optarg);
-					if ((newPriority &gt;= -20) &amp;&amp;
-						(newPriority &lt; 20))
-					{
-						priority = newPriority;
-					}
-				}
-				break;
-			case 'r':
-				reindex = true;
-				break;
-			case 'v':
-				cout &lt;&lt; &quot;pinot-dbus-daemon - &quot; &lt;&lt; PACKAGE_STRING &lt;&lt; &quot;\n\n&quot; 
-					&lt;&lt; &quot;This is free software.  You may redistribute copies of it under the terms of\n&quot;
-					&lt;&lt; &quot;the GNU General Public License &lt;<A HREF="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">http://www.gnu.org/licenses/old-licenses/gpl-2.0.html</A>&gt;.\n&quot;
-					&lt;&lt; &quot;There is NO WARRANTY, to the extent permitted by law.&quot; &lt;&lt; endl;
-				return EXIT_SUCCESS;
-			default:
-				return EXIT_FAILURE;
-		}
-
-		// Next option
-		optionChar = getopt_long(argc, argv, &quot;fhip:rv&quot;, g_longOptions, &amp;longOptionIndex);
-	}
-
-#if defined(ENABLE_NLS)
-	bindtextdomain(GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
-	bind_textdomain_codeset(GETTEXT_PACKAGE, &quot;UTF-8&quot;);
-	textdomain(GETTEXT_PACKAGE);
-#endif //ENABLE_NLS
-
-	// Initialize threads support before doing anything else
-	if (Glib::thread_supported() == false)
-	{
-		Glib::thread_init();
-	}
-	// Initialize the GType and the D-Bus thread system
-	g_type_init();
-#if DBUS_NUM_VERSION &gt; 1000000
-	dbus_threads_init_default();
-#endif
-	dbus_g_thread_init();
-
-	g_refMainLoop = Glib::MainLoop::create();
-	Glib::set_application_name(&quot;Pinot DBus Daemon&quot;);
-
-	// This should make Xapian use Flint rather than Quartz
-	Glib::setenv(&quot;XAPIAN_PREFER_FLINT&quot;, &quot;1&quot;);
-
-	// Make the locale follow the environment variables
-	setlocale(LC_ALL, &quot;&quot;);
-	char *pLocale = setlocale(LC_ALL, NULL);
-	if (pLocale != NULL)
-	{
-		string locale(pLocale);
-
-		if (locale != &quot;C&quot;)
-		{
-			bool appendUTF8 = false;
-
-			string::size_type pos = locale.find_last_of(&quot;.&quot;);
-			if ((pos != string::npos) &amp;&amp;
-				((strcasecmp(locale.substr(pos).c_str(), &quot;.utf8&quot;) != 0) &amp;&amp;
-				(strcasecmp(locale.substr(pos).c_str(), &quot;.utf-8&quot;) != 0)))
-			{
-				locale.resize(pos);
-				appendUTF8 = true;
-			}
-
-			if (appendUTF8 == true)
-			{
-				locale += &quot;.UTF-8&quot;;
-
-				pLocale = setlocale(LC_ALL, locale.c_str());
-				if (pLocale != NULL)
-				{
-#ifdef DEBUG
-					cout &lt;&lt; &quot;Changed locale to &quot; &lt;&lt; pLocale &lt;&lt; endl;
-#endif
-				}
-			}
-		}
-	}
-
-	// Make sure only one instance runs
-	UniqueApplication uniqueApp(&quot;de.berlios.PinotDBusDaemon&quot;);
-	string confDirectory = PinotSettings::getConfigurationDirectory();
-	g_pidFileName = confDirectory + &quot;/pinot-dbus-daemon.pid&quot;;
-	if (chdir(confDirectory.c_str()) == 0)
-	{
-		if (uniqueApp.isRunning(g_pidFileName, &quot;pinot-dbus-daemon&quot;) == true)
-		{
-			return EXIT_SUCCESS;
-		}
-
-		// Redirect cout and cerr to a file
-		string fileName(confDirectory);
-		fileName += &quot;/pinot-dbus-daemon.log&quot;;
-		g_outputFile.open(fileName.c_str());
-		g_coutBuf = cout.rdbuf();
-		g_cerrBuf = cerr.rdbuf();
-		cout.rdbuf(g_outputFile.rdbuf());
-		cerr.rdbuf(g_outputFile.rdbuf());
-	}
-	else
-	{
-		// We can't rely on the PID file
-		if (uniqueApp.isRunning() == true)
-		{
-			return EXIT_SUCCESS;
-		}
-	}
-
-	// This will create the necessary directories on the first run
-	PinotSettings &amp;settings = PinotSettings::getInstance();
-	// This is the daemon so disable client-side code 
-	settings.enableClientMode(false);
-
-	// Initialize utility classes
-	if (MIMEScanner::initialize(PinotSettings::getHomeDirectory() + &quot;/.local&quot;,
-		string(SHARED_MIME_INFO_PREFIX)) == false)
-	{
-		cerr &lt;&lt; &quot;Couldn't load MIME settings&quot; &lt;&lt; endl;
-	}
-	DownloaderInterface::initialize();
-	// Load tokenizer libraries, if any
-	Dijon::HtmlFilter::initialize();
-	Dijon::FilterFactory::loadFilters(string(LIBDIR) + &quot;/pinot/filters&quot;);
-	Dijon::FilterFactory::loadFilters(confDirectory + &quot;/filters&quot;);
-	// Load backends, if any
-	ModuleFactory::loadModules(string(LIBDIR) + &quot;/pinot/backends&quot;);
-	ModuleFactory::loadModules(confDirectory + &quot;/backends&quot;);
-
-	// Localize language names
-	Languages::setIntlName(0, _(&quot;Unknown&quot;));
-	Languages::setIntlName(1, _(&quot;Danish&quot;));
-	Languages::setIntlName(2, _(&quot;Dutch&quot;));
-	Languages::setIntlName(3, _(&quot;English&quot;));
-	Languages::setIntlName(4, _(&quot;Finnish&quot;));
-	Languages::setIntlName(5, _(&quot;French&quot;));
-	Languages::setIntlName(6, _(&quot;German&quot;));
-	Languages::setIntlName(7, _(&quot;Hungarian&quot;));
-	Languages::setIntlName(8, _(&quot;Italian&quot;));
-	Languages::setIntlName(9, _(&quot;Norwegian&quot;));
-	Languages::setIntlName(10, _(&quot;Portuguese&quot;));
-	Languages::setIntlName(11, _(&quot;Romanian&quot;));
-	Languages::setIntlName(12, _(&quot;Russian&quot;));
-	Languages::setIntlName(13, _(&quot;Spanish&quot;));
-	Languages::setIntlName(14, _(&quot;Swedish&quot;));
-	Languages::setIntlName(15, _(&quot;Turkish&quot;));
-
-	// Load the settings
-	settings.load(PinotSettings::LOAD_ALL);
-
-	// Catch interrupts
-#ifdef HAVE_SIGACTION
-	struct sigaction newAction;
-	sigemptyset(&amp;newAction.sa_mask);
-	newAction.sa_flags = 0;
-	newAction.sa_handler = quitAll;
-	sigaction(SIGINT, &amp;newAction, NULL);
-	sigaction(SIGQUIT, &amp;newAction, NULL);
-	sigaction(SIGTERM, &amp;newAction, NULL);
-#else
-	signal(SIGINT, quitAll);
-#ifdef SIGQUIT
-	signal(SIGQUIT, quitAll);
-#endif
-	signal(SIGTERM, quitAll);
-#endif
-
-	// Open the daemon index in read-write mode 
-	bool wasObsoleteFormat = false;
-	if (ModuleFactory::openOrCreateIndex(settings.m_defaultBackend, settings.m_daemonIndexLocation, wasObsoleteFormat, false) == false)
-	{
-		cerr &lt;&lt; &quot;Couldn't open index &quot; &lt;&lt; settings.m_daemonIndexLocation &lt;&lt; endl;
-		return EXIT_FAILURE;
-	}
-	if (wasObsoleteFormat == true)
-	{
-		resetHistory = resetLabels = true;
-	}
-
-	// Do the same for the history database
-	PinotSettings::checkHistoryDatabase();
-	string historyDatabase(settings.getHistoryDatabaseName());
-	if ((historyDatabase.empty() == true) ||
-		(ActionQueue::create(historyDatabase) == false) ||
-		(CrawlHistory::create(historyDatabase) == false) ||
-		(MetaDataBackup::create(historyDatabase) == false) ||
-		(QueryHistory::create(historyDatabase) == false) ||
-		(ViewHistory::create(historyDatabase) == false))
-	{
-		cerr &lt;&lt; &quot;Couldn't create history database &quot; &lt;&lt; historyDatabase &lt;&lt; endl;
-		return EXIT_FAILURE;
-	}
-	else
-	{
-		ActionQueue actionQueue(historyDatabase, Glib::get_application_name());
-		QueryHistory queryHistory(historyDatabase);
-		ViewHistory viewHistory(historyDatabase);
-		time_t timeNow = time(NULL);
-		unsigned int actionsCount = actionQueue.getItemsCount(ActionQueue::INDEX);
-
-		// Don't expire actions left from last time
-		actionsCount += actionQueue.getItemsCount(ActionQueue::UNINDEX);
-		cout &lt;&lt; actionsCount &lt;&lt; &quot; actions left&quot; &lt;&lt; endl;
-
-		// Expire the rest
-		queryHistory.expireItems(timeNow);
-		viewHistory.expireItems(timeNow);
-	}
-
-	atexit(closeAll);
-
-	// Change the daemon's priority
-	if (setpriority(PRIO_PROCESS, 0, priority) == -1)
-	{
-		cerr &lt;&lt; &quot;Couldn't set scheduling priority to &quot; &lt;&lt; priority &lt;&lt; endl;
-	}
-#ifdef DEBUG
-	else cout &lt;&lt; &quot;Set priority to &quot; &lt;&lt; priority &lt;&lt; endl;
-#endif
-
-	GError *pError = NULL;
-	DBusGConnection *pBus = dbus_g_bus_get(DBUS_BUS_SESSION, &amp;pError);
-	if (pBus == NULL)
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;Couldn't open bus connection: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			if (pError-&gt;message != NULL)
-			{
-				cerr &lt;&lt; &quot;Error is &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			}
-			g_error_free(pError);
-		}
-
-		return EXIT_FAILURE;
-	}
-
-	DBusConnection *pConnection = dbus_g_connection_get_connection(pBus);
-	if (pConnection == NULL)
-	{
-		cerr &lt;&lt; &quot;Couldn't get connection&quot; &lt;&lt; endl;
-		return EXIT_FAILURE;
-	}
-
-	DBusError error;
-	DaemonState server;
-	IndexInterface *pIndex = NULL;
-
-	dbus_error_init(&amp;error);
-	dbus_connection_set_exit_on_disconnect(pConnection, FALSE);
-	dbus_connection_setup_with_g_main(pConnection, NULL);
-
-	if (dbus_connection_register_object_path(pConnection, g_pinotDBusObjectPath,
-		&amp;g_callVTable, &amp;server) == TRUE)
-	{
-		// Request to be identified by this name
-		// FIXME: flags are currently broken ?
-		dbus_bus_request_name(pConnection, g_pinotDBusService, 0, &amp;error);
-		if (dbus_error_is_set(&amp;error) == FALSE)
-		{
-			// See power management signals
-			dbus_bus_add_match(pConnection,
-				&quot;type='signal',interface='org.freedesktop.PowerManagement'&quot;, &amp;error);
-			dbus_bus_add_match(pConnection,
-				&quot;type='signal',interface='org.gnome.PowerManager'&quot;, &amp;error);
-
-			dbus_connection_add_filter(pConnection,
-				(DBusHandleMessageFunction)filterHandler, &amp;server, NULL);
-		}
-		else
-		{
-			cerr &lt;&lt; &quot;Couldn't obtain name &quot; &lt;&lt; g_pinotDBusService &lt;&lt; endl;
-			if (error.message != NULL)
-			{
-				cerr &lt;&lt; &quot;Error is &quot; &lt;&lt; error.message &lt;&lt; endl;
-			}
-		}
-
-		try
-		{
-			set&lt;string&gt; labels;
-			bool gotLabels = false;
-			bool onBattery = false;
-
-			pIndex = settings.getIndex(settings.m_daemonIndexLocation);
-			if (pIndex != NULL)
-			{
-				string indexVersion(pIndex-&gt;getMetadata(&quot;version&quot;));
-
-				gotLabels = pIndex-&gt;getLabels(labels);
-
-				// What version is the index at ?
-				if (indexVersion.empty() == true)
-				{
-					indexVersion = &quot;0.0&quot;;
-				}
-				if (ignoreVersion == true)
-				{
-					// Better reset labels, they may have been lost too
-					resetLabels = true;
-				}
-				else if (indexVersion &lt; PINOT_INDEX_MIN_VERSION)
-				{
-					cout &lt;&lt; &quot;Upgrading index from version &quot; &lt;&lt; indexVersion &lt;&lt; &quot; to &quot; &lt;&lt; VERSION &lt;&lt; endl;
-
-					reindex = true;
-				}
-				if (reindex == true)
-				{
-					// Reset the index so that all documents are reindexed
-					pIndex-&gt;reset();
-
-					cout &lt;&lt; &quot;Reset index&quot; &lt;&lt; endl;
-
-					resetHistory = resetLabels = true;
-				}
-
-				pIndex-&gt;setMetadata(&quot;version&quot;, VERSION);
-				pIndex-&gt;setMetadata(&quot;dbus-status&quot;, &quot;Running&quot;);
-			}
-
-			if (resetHistory == true)
-			{
-				CrawlHistory history(historyDatabase);
-				map&lt;unsigned int, string&gt; sources;
-
-				// Reset the history
-				history.getSources(sources);
-				for (std::map&lt;unsigned int, string&gt;::iterator sourceIter = sources.begin();
-					sourceIter != sources.end(); ++sourceIter)
-				{
-					history.deleteItems(sourceIter-&gt;first);
-					history.deleteSource(sourceIter-&gt;first);
-				}
-
-				cout &lt;&lt; &quot;Reset crawler history&quot; &lt;&lt; endl;
-			}
-
-			if ((resetLabels == true) &amp;&amp;
-				(pIndex != NULL))
-			{
-				// Re-apply the labels list
-				if (gotLabels == false)
-				{
-					// If this is an upgrade from a version &lt; 0.80, the labels list
-					// needs to be pulled from the configuration file
-					pIndex-&gt;setLabels(settings.m_labels, true);
-
-					cout &lt;&lt; &quot;Set labels as per the configuration file&quot; &lt;&lt; endl;
-				}
-				else
-				{
-					pIndex-&gt;setLabels(labels, true);
-				}
-			}
-
-			// Connect to the quit signal
-			server.getQuitSignal().connect(sigc::ptr_fun(&amp;quitAll));
-
-			// Connect to threads' finished signal
-			server.connect();
-
-			// Try and get the battery state
-			gboolean result = FALSE;
-			if ((getBatteryState(pBus, &quot;org.freedesktop.PowerManagement&quot;,
-				&quot;/org/freedesktop/PowerManagement&quot;, &quot;GetOnBattery&quot;, result) == true) ||
-				(getBatteryState(pBus, &quot;org.freedesktop.PowerManagement&quot;,
-				&quot;/org/freedesktop/PowerManagement&quot;, &quot;GetBatteryState&quot;, result) == true))
-			{
-				if (result == TRUE)
-				{
-					onBattery = true;
-				}
-			}
-			else if (getBatteryState(pBus, &quot;org.gnome.PowerManager&quot;,
-				&quot;/org/gnome/PowerManager&quot;, &quot;GetOnAc&quot;, result) == true)
-			{
-				if (result == FALSE)
-				{
-					onBattery = true;
-				}
-			}
-			if (onBattery == true)
-			{
-				// We are on battery
-				server.set_flag(DaemonState::ON_BATTERY);
-				server.stop_crawling();
-
-				cout &lt;&lt; &quot;System is on battery&quot; &lt;&lt; endl;
-			}
-
-			server.start(fullScan, reindex);
-
-			// Run the main loop
-			g_refMainLoop-&gt;run();
-
-		}
-		catch (const Glib::Exception &amp;e)
-		{
-			cerr &lt;&lt; e.what() &lt;&lt; endl;
-			return EXIT_FAILURE;
-		}
-		catch (const char *pMsg)
-		{
-			cerr &lt;&lt; pMsg &lt;&lt; endl;
-			return EXIT_FAILURE;
-		}
-		catch (...)
-		{
-			cerr &lt;&lt; &quot;Unknown exception&quot; &lt;&lt; endl;
-			return EXIT_FAILURE;
-		}
-	}
-	else
-	{
-		cerr &lt;&lt; &quot;Couldn't register object path&quot; &lt;&lt; endl;
-	}
-	dbus_error_free(&amp;error);
-
-	if (pIndex != NULL)
-	{
-		if (server.is_flag_set(DaemonState::DISCONNECTED) == true)
-		{
-			pIndex-&gt;setMetadata(&quot;dbus-status&quot;, &quot;Disconnected&quot;);
-		}
-		else if (server.is_flag_set(DaemonState::STOPPED) == true)
-		{
-			pIndex-&gt;setMetadata(&quot;dbus-status&quot;, &quot;Stopped&quot;);
-		}
-		else
-		{
-			pIndex-&gt;setMetadata(&quot;dbus-status&quot;, &quot;&quot;);
-		}
-		delete pIndex;
-	}
-
-	// Stop everything
-	server.disconnect();
-	server.stop_threads();
-
-	return EXIT_SUCCESS;
-}

Deleted: trunk/UI/GTK2/src/pinot-dbus-daemon.xml
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,181 +0,0 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
-&lt;node&gt;
-  &lt;interface name=&quot;org.freedesktop.DBus.Introspectable&quot;&gt;
-    &lt;method name=&quot;Introspect&quot;&gt;
-      &lt;arg type=&quot;s&quot; name=&quot;data&quot; direction=&quot;out&quot;/&gt;
-    &lt;/method&gt;
-  &lt;/interface&gt;
-  &lt;!--
-	WARNING: This interface WILL change before 1.0 is released !
-	--&gt;
-  &lt;interface name=&quot;de.berlios.Pinot&quot;&gt;
-    &lt;!--
-	Retrieves statistics.
-	 crawledCount: the number of documents crawled
-	 docsCount: the number of documents in the index
-	--&gt;
-    &lt;method name=&quot;GetStatistics&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.GetStatistics&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;crawledCount&quot; direction=&quot;out&quot;/&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;docsCount&quot; direction=&quot;out&quot;/&gt;
-      &lt;arg type=&quot;b&quot; name=&quot;lowDiskSpace&quot; direction=&quot;out&quot; /&gt;
-      &lt;arg type=&quot;b&quot; name=&quot;onBattery&quot; direction=&quot;out&quot; /&gt;
-      &lt;arg type=&quot;b&quot; name=&quot;crawling&quot; direction=&quot;out&quot; /&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Instructs the daemon program to reload the configuration file.
-	 reloading: TRUE if the configuration is being reloaded
-	--&gt;
-    &lt;method name=&quot;Reload&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.Reload&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;b&quot; name=&quot;reloading&quot; direction=&quot;out&quot; /&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Stops the daemon program.
-	 exitStatus: the daemon's exit status
-	--&gt;
-    &lt;method name=&quot;Stop&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.Stop&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;i&quot; name=&quot;exitStatus&quot; direction=&quot;out&quot; /&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Checks if a URL is indexed.
-	 docId: the document's ID
-	--&gt;
-    &lt;method name=&quot;HasDocument&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.HasDocument&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;s&quot; name=&quot;url&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;docId&quot; direction=&quot;out&quot;/&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Gets the list of known labels.
-	 labels: array of labels
-	--&gt;
-    &lt;method name=&quot;GetLabels&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.GetLabels&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;as&quot; name=&quot;labels&quot; direction=&quot;out&quot;/&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Adds a label.
-	 label: the name of the new label
-        This method shouldn't be used by applications other than Pinot.
-	--&gt;
-    &lt;method name=&quot;AddLabel&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.AddLabel&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;s&quot; name=&quot;label&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;s&quot; name=&quot;label&quot; direction=&quot;out&quot;/&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Deletes a label.
-	 label: the name of the label to delete
-        This method shouldn't be used by applications other than Pinot.
-	--&gt;
-    &lt;method name=&quot;DeleteLabel&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.DeleteLabel&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;s&quot; name=&quot;label&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;s&quot; name=&quot;label&quot; direction=&quot;out&quot;/&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Retrieves a document's labels.
-	 docId: the document's ID
-	 labels: array of labels applied to the document
-	--&gt;
-    &lt;method name=&quot;GetDocumentLabels&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.GetDocumentLabels&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;docId&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;as&quot; name=&quot;labels&quot; direction=&quot;out&quot;/&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Sets a document's labels.
-	 docId: the document's ID
-	 labels: array of labels to apply to the document
-	 resetLabels: TRUE if existing labels should be unset
-	--&gt;
-    &lt;method name=&quot;SetDocumentLabels&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.SetDocumentLabels&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;docId&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;as&quot; name=&quot;labels&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;b&quot; name=&quot;resetLabels&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;docId&quot; direction=&quot;out&quot;/&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Sets labels on a group of documents.
-	 docIds: array of document IDs
-	 labels: array of labels to apply to the documents
-	 resetLabels: TRUE if existing labels should be unset
-	--&gt;
-    &lt;method name=&quot;SetDocumentsLabels&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.SetDocumentsLabels&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;as&quot; name=&quot;docIds&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;as&quot; name=&quot;labels&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;b&quot; name=&quot;resetLabels&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;b&quot; name=&quot;status&quot; direction=&quot;out&quot;/&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Retrieves information about a document.
-	 docId: the document's ID
-	 fields : array of (s name, s value) structures with name one of
-	 &quot;caption&quot;, &quot;url&quot;, &quot;type&quot;, &quot;language&quot;, &quot;modtime&quot;, &quot;size&quot;, &quot;extract&quot;
-	--&gt;
-    &lt;method name=&quot;GetDocumentInfo&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.GetDocumentInfo&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;docId&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;a(ss)&quot; name=&quot;fields&quot; direction=&quot;out&quot;/&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Sets information about a document.
-	 docId: the document's ID
-	 fields : array of (s name, s value) structures with name one of
-	 &quot;caption&quot;, &quot;url&quot;, &quot;type&quot;, &quot;language&quot;, &quot;modtime&quot;, &quot;size&quot;, &quot;extract&quot;
-	--&gt;
-    &lt;method name=&quot;SetDocumentInfo&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.SetDocumentInfo&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;docId&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;a(ss)&quot; name=&quot;fields&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;docId&quot; direction=&quot;out&quot;/&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Queries the index.
-	 engineType : engine type (defaults to &quot;xapian&quot;). See pinot-search(1) for a list of supported types
-	 engineName : engine name (defaults to &quot;~/.pinot/daemon&quot;). See pinot-search(1) for examples
-	 searchText : search text, as would be entered in Pinot's live query field
-	 startDoc: the first result to return, starting from 0
-	 maxHits: the maximum number of hits desired
-	 estimatedHits: an estimate of the total number of hits
-	 hitsList: hit properties
-	--&gt;
-    &lt;method name=&quot;Query&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.Query&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;s&quot; name=&quot;engineType&quot; direction=&quot;in&quot; /&gt;
-      &lt;arg type=&quot;s&quot; name=&quot;engineName&quot; direction=&quot;in&quot; /&gt;
-      &lt;arg type=&quot;s&quot; name=&quot;searchText&quot; direction=&quot;in&quot; /&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;startDoc&quot; direction=&quot;in&quot; /&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;maxHits&quot; direction=&quot;in&quot; /&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;estimatedHits&quot; direction=&quot;out&quot; /&gt;
-      &lt;arg type=&quot;aa(ss)&quot; name=&quot;hitsList&quot; direction=&quot;out&quot; /&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Queries the index.
-	 searchText : search text, as would be entered in Pinot's live query field
-	 maxHits: the maximum number of hits desired
-	 docIds: array of document IDs
-	 docIdsCount: the number of document IDs in the array
-        WARNING: this method is obsolete
-	--&gt;
-    &lt;method name=&quot;SimpleQuery&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.SimpleQuery&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;s&quot; name=&quot;searchText&quot; direction=&quot;in&quot; /&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;maxHits&quot; direction=&quot;in&quot; /&gt;
-      &lt;arg type=&quot;as&quot; name=&quot;docIds&quot; direction=&quot;out&quot; /&gt;
-    &lt;/method&gt;
-    &lt;!--
-	Updates a document.
-	 docId: the document's ID
-	--&gt;
-    &lt;method name=&quot;UpdateDocument&quot;&gt;
-      &lt;annotation name=&quot;de.berlios.Pinot.UpdateDocument&quot; value=&quot;pinotDBus&quot;/&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;docId&quot; direction=&quot;in&quot;/&gt;
-      &lt;arg type=&quot;u&quot; name=&quot;docId&quot; direction=&quot;out&quot;/&gt;
-    &lt;/method&gt;
-  &lt;/interface&gt;
-&lt;/node&gt;

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/configure.in	2009-02-01 11:04:31 UTC (rev 1530)
@@ -439,8 +439,8 @@
 AC_CHECK_FUNCS(getloadavg)
 AC_CHECK_FUNCS(pipe)
 
-AC_OUTPUT( pinot.spec UI/GTK2/src/de.berlios.Pinot.service Makefile \
+AC_OUTPUT( pinot.spec Core/de.berlios.Pinot.service Makefile \
 	Utils/Makefile Tokenize/Makefile SQL/Makefile po/Makefile.in Collect/Makefile \
 	IndexSearch/Google/Makefile IndexSearch/Xapian/Makefile IndexSearch/XesamGLib/Makefile \
-	IndexSearch/Makefile Monitor/Makefile UI/GTK2/src/Makefile )
+	IndexSearch/Makefile Monitor/Makefile Core/Makefile UI/GTK2/src/Makefile )
 

Modified: trunk/po/POTFILES.in
===================================================================
--- trunk/po/POTFILES.in	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/po/POTFILES.in	2009-02-01 11:04:31 UTC (rev 1530)
@@ -1,5 +1,12 @@
 # List of source files containing translatable strings.
-UI/GTK2/src/DaemonState.cpp
+Core/DaemonState.cpp
+Core/OnDiskHandler.cpp
+Core/pinot-dbus-daemon.cc
+Core/PinotSettings.cpp
+Core/PinotUtils.cpp
+Core/ServerThreads.cpp
+Core/UniqueApplication.cpp
+Core/WorkerThreads.cpp
 UI/GTK2/src/EnginesTree.cpp
 UI/GTK2/src/indexDialog.cc
 UI/GTK2/src/indexDialog_glade.cc
@@ -14,11 +21,7 @@
 UI/GTK2/src/mainWindow_glade.cc
 UI/GTK2/src/ModelColumns.cpp
 UI/GTK2/src/Notebook.cpp
-UI/GTK2/src/OnDiskHandler.cpp
 UI/GTK2/src/pinot.cc
-UI/GTK2/src/pinot-dbus-daemon.cc
-UI/GTK2/src/PinotSettings.cpp
-UI/GTK2/src/PinotUtils.cpp
 UI/GTK2/src/prefsWindow.cc
 UI/GTK2/src/prefsWindow_glade.cc
 UI/GTK2/src/propertiesDialog.cc
@@ -28,4 +31,3 @@
 UI/GTK2/src/ResultsTree.cpp
 UI/GTK2/src/statisticsDialog.cc
 UI/GTK2/src/statisticsDialog_glade.cc
-UI/GTK2/src/WorkerThreads.cpp


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001519.html">[Pinot-svn] r1529 - trunk/UI/GTK2/src
</A></li>
	<LI>Next message: <A HREF="001521.html">[Pinot-svn] r1531 - in trunk: Core UI/GTK2/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1520">[ date ]</a>
              <a href="thread.html#1520">[ thread ]</a>
              <a href="subject.html#1520">[ subject ]</a>
              <a href="author.html#1520">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/pinot-svn">More information about the Pinot-svn
mailing list</a><br>
</body></html>
