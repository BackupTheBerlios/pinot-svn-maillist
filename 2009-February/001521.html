<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Pinot-svn] r1531 - in trunk: Core UI/GTK2/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/pinot-svn/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r1531%20-%20in%20trunk%3A%20Core%20UI/GTK2/src&In-Reply-To=%3C200902011148.n11BmXmK014882%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001520.html">
   <LINK REL="Next"  HREF="001522.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Pinot-svn] r1531 - in trunk: Core UI/GTK2/src</H1>
    <B>fabricecolin at mail.berlios.de</B> 
    <A HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r1531%20-%20in%20trunk%3A%20Core%20UI/GTK2/src&In-Reply-To=%3C200902011148.n11BmXmK014882%40sheep.berlios.de%3E"
       TITLE="[Pinot-svn] r1531 - in trunk: Core UI/GTK2/src">fabricecolin at mail.berlios.de
       </A><BR>
    <I>Sun Feb  1 12:48:33 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001520.html">[Pinot-svn] r1530 - in trunk: . Core UI/GTK2/src po
</A></li>
        <LI>Next message: <A HREF="001522.html">[Pinot-svn] r1532 - trunk/po
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1521">[ date ]</a>
              <a href="thread.html#1521">[ thread ]</a>
              <a href="subject.html#1521">[ subject ]</a>
              <a href="author.html#1521">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fabricecolin
Date: 2009-02-01 12:47:02 +0100 (Sun, 01 Feb 2009)
New Revision: 1531

Added:
   trunk/Core/pinot-dbus-daemon.cpp
   trunk/UI/GTK2/src/EnginesTree.cc
   trunk/UI/GTK2/src/EnginesTree.hh
   trunk/UI/GTK2/src/IndexPage.cc
   trunk/UI/GTK2/src/IndexPage.hh
   trunk/UI/GTK2/src/ModelColumns.cc
   trunk/UI/GTK2/src/ModelColumns.hh
   trunk/UI/GTK2/src/Notebook.cc
   trunk/UI/GTK2/src/Notebook.hh
   trunk/UI/GTK2/src/ResultsTree.cc
   trunk/UI/GTK2/src/ResultsTree.hh
Removed:
   trunk/Core/pinot-dbus-daemon.cc
   trunk/UI/GTK2/src/EnginesTree.cpp
   trunk/UI/GTK2/src/EnginesTree.h
   trunk/UI/GTK2/src/IndexPage.cpp
   trunk/UI/GTK2/src/IndexPage.h
   trunk/UI/GTK2/src/ModelColumns.cpp
   trunk/UI/GTK2/src/ModelColumns.h
   trunk/UI/GTK2/src/Notebook.cpp
   trunk/UI/GTK2/src/Notebook.h
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/ResultsTree.h
Modified:
   trunk/Core/Makefile.am
   trunk/UI/GTK2/src/Makefile.am
   trunk/UI/GTK2/src/importDialog.hh
   trunk/UI/GTK2/src/indexDialog.hh
   trunk/UI/GTK2/src/mainWindow.hh
   trunk/UI/GTK2/src/prefsWindow.hh
   trunk/UI/GTK2/src/propertiesDialog.hh
   trunk/UI/GTK2/src/queryDialog.hh
   trunk/UI/GTK2/src/statisticsDialog.hh
Log:
Use the same naming conventions as glademm where appropriate.


Modified: trunk/Core/Makefile.am
===================================================================
--- trunk/Core/Makefile.am	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/Core/Makefile.am	2009-02-01 11:47:02 UTC (rev 1531)
@@ -20,9 +20,6 @@
 	UniqueApplication.cpp \
 	WorkerThreads.cpp
 
-pinot_dbus_daemon_SOURCES = \
-	pinot-dbus-daemon.cc
-
 if HAVE_DBUS
 bin_PROGRAMS = pinot-dbus-daemon
 endif
@@ -58,3 +55,7 @@
 	@GLIBMM_LIBS@ @DBUS_LIBS@ @GTHREAD_LIBS@ @XML_LIBS@ \
 	@HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
 
+pinot_dbus_daemon_SOURCES = pinot-dbus-daemon.cpp
+
+pinot_index_DEPENDENCIES = libCore.la
+

Deleted: trunk/Core/pinot-dbus-daemon.cc
===================================================================
--- trunk/Core/pinot-dbus-daemon.cc	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/Core/pinot-dbus-daemon.cc	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,754 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;stdlib.h&gt;
-#include &lt;libintl.h&gt;
-#include &lt;getopt.h&gt;
-#include &lt;sys/time.h&gt;
-#include &lt;sys/resource.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;iostream&gt;
-#include &lt;sstream&gt;
-#include &lt;fstream&gt;
-#include &lt;cstring&gt;
-#include &lt;sigc++/sigc++.h&gt;
-#include &lt;glibmm.h&gt;
-#include &lt;glibmm/thread.h&gt;
-#include &lt;glibmm/ustring.h&gt;
-#include &lt;glibmm/miscutils.h&gt;
-#include &lt;glibmm/convert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;NLS.h&quot;
-#include &quot;FilterFactory.h&quot;
-#include &quot;Languages.h&quot;
-#include &quot;MIMEScanner.h&quot;
-#include &quot;ModuleFactory.h&quot;
-#include &quot;ActionQueue.h&quot;
-#include &quot;CrawlHistory.h&quot;
-#include &quot;MetaDataBackup.h&quot;
-#include &quot;QueryHistory.h&quot;
-#include &quot;ViewHistory.h&quot;
-#include &quot;DownloaderInterface.h&quot;
-#include &quot;DaemonState.h&quot;
-#include &quot;PinotSettings.h&quot;
-#include &quot;ServerThreads.h&quot;
-#include &quot;UniqueApplication.h&quot;
-
-using namespace std;
-
-static ofstream g_outputFile;
-static string g_pidFileName;
-static streambuf *g_coutBuf = NULL;
-static streambuf *g_cerrBuf = NULL;
-static struct option g_longOptions[] = {
-	{&quot;fullscan&quot;, 0, 0, 'f'},
-	{&quot;help&quot;, 0, 0, 'h'},
-	{&quot;ignore-version&quot;, 0, 0, 'i'},
-	{&quot;priority&quot;, 1, 0, 'p'},
-	{&quot;reindex&quot;, 0, 0, 'r'},
-	{&quot;version&quot;, 0, 0, 'v'},
-	{0, 0, 0, 0}
-};
-static const char *g_pinotDBusService = &quot;de.berlios.Pinot&quot;;
-static const char *g_pinotDBusObjectPath = &quot;/de/berlios/Pinot&quot;;
-static void unregisteredHandler(DBusConnection *pConnection, void *pData);
-static DBusHandlerResult messageHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData);
-static DBusObjectPathVTable g_callVTable = {
-	(DBusObjectPathUnregisterFunction)unregisteredHandler,
-        (DBusObjectPathMessageFunction)messageHandler,
-	NULL,
-};
-static Glib::RefPtr&lt;Glib::MainLoop&gt; g_refMainLoop;
-
-static void closeAll(void)
-{
-	cout &lt;&lt; &quot;Exiting...&quot; &lt;&lt; endl;
-
-	// Close everything
-	ModuleFactory::unloadModules();
-	Dijon::FilterFactory::unloadFilters();
-	Dijon::HtmlFilter::shutdown();
-
-	// Restore the stream buffers
-	if (g_coutBuf != NULL)
-	{
-		cout.rdbuf(g_coutBuf);
-	}
-	if (g_cerrBuf != NULL)
-	{
-		cerr.rdbuf(g_cerrBuf);
-	}
-	g_outputFile.close();
-	if (g_pidFileName.empty() == false)
-	{
-		unlink(g_pidFileName.c_str());
-	}
-
-	DownloaderInterface::shutdown();
-	MIMEScanner::shutdown();
-}
-
-static void quitAll(int sigNum)
-{
-	if (g_refMainLoop-&gt;is_running() == true)
-	{
-		cout &lt;&lt; &quot;Quitting...&quot; &lt;&lt; endl;
-
-		g_refMainLoop-&gt;quit();
-	}
-}
-
-static DBusHandlerResult filterHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
-{
-	DaemonState *pServer = (DaemonState *)pData;
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;filterHandler: called&quot; &lt;&lt; endl;
-#endif
-	// Are we about to be disconnected ?
-	if (dbus_message_is_signal(pMessage, DBUS_INTERFACE_LOCAL, &quot;Disconnected&quot;) == TRUE)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;filterHandler: received Disconnected&quot; &lt;&lt; endl;
-#endif
-		if (pServer != NULL)
-		{
-			pServer-&gt;set_flag(DaemonState::DISCONNECTED);
-		}
-		quitAll(0);
-	}
-	else if (dbus_message_is_signal(pMessage, DBUS_INTERFACE_DBUS, &quot;NameOwnerChanged&quot;) == TRUE)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;filterHandler: received NameOwnerChanged&quot; &lt;&lt; endl;
-#endif
-	}
-	// The first two signals are specified by the freedesktop.org Power Management spec v0.1 and v0.2
-	else if ((dbus_message_is_signal(pMessage, &quot;org.freedesktop.PowerManagement&quot;, &quot;BatteryStateChanged&quot;) == TRUE) ||
-		(dbus_message_is_signal(pMessage, &quot;org.freedesktop.PowerManagement&quot;, &quot;OnBatteryChanged&quot;) == TRUE) ||
-		(dbus_message_is_signal(pMessage, &quot;org.gnome.PowerManager&quot;, &quot;OnAcChanged&quot;) == TRUE))
-	{
-		DBusError error;
-		gboolean onBattery = FALSE;
-
-#ifdef DEBUG
-		cout &lt;&lt; &quot;filterHandler: received OnBatteryChanged&quot; &lt;&lt; endl;
-#endif
-		dbus_error_init(&amp;error);
-		if ((dbus_message_get_args(pMessage, &amp;error,
-			DBUS_TYPE_BOOLEAN, &amp;onBattery,
-			DBUS_TYPE_INVALID) == TRUE) &amp;&amp;
-			(pData != NULL))
-		{
-			if (dbus_message_is_signal(pMessage, &quot;org.gnome.PowerManager&quot;, &quot;OnAcChanged&quot;) == TRUE)
-			{
-				// This tells us if we are on AC, not on battery
-				if (onBattery == TRUE)
-				{
-					onBattery = FALSE;
-				}
-				else
-				{
-					onBattery = TRUE;
-				}
-			}
-
-			if (onBattery == TRUE)
-			{
-				// We are now on battery
-				if (pServer != NULL)
-				{
-					pServer-&gt;set_flag(DaemonState::ON_BATTERY);
-					pServer-&gt;stop_crawling();
-				}
-
-				cout &lt;&lt; &quot;System is now on battery&quot; &lt;&lt; endl;
-			}
-			else
-			{
-				// Back on-line
-				if (pServer != NULL)
-				{
-					pServer-&gt;reset_flag(DaemonState::ON_BATTERY);
-					pServer-&gt;start_crawling();
-				}
-
-				cout &lt;&lt; &quot;System is now on AC&quot; &lt;&lt; endl;
-			}
-		}
-		dbus_error_free(&amp;error);
-	}
-
-	return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-}
-
-static void unregisteredHandler(DBusConnection *pConnection, void *pData)
-{
-#ifdef DEBUG
-	cout &lt;&lt; &quot;unregisteredHandler: called&quot; &lt;&lt; endl;
-#endif
-}
-
-static DBusHandlerResult messageHandler(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
-{
-	DaemonState *pServer = (DaemonState *)pData;
-
-	if ((pConnection != NULL) &amp;&amp;
-		(pMessage != NULL))
-	{
-		dbus_connection_ref(pConnection);
-		dbus_message_ref(pMessage);
-
-		if (pServer != NULL)
-		{
-			DBusServletInfo *pInfo = new DBusServletInfo(pConnection, pMessage);
-
-			pServer-&gt;start_thread(new DBusServletThread(pServer, pInfo));
-		}
-	}
-
-	return DBUS_HANDLER_RESULT_HANDLED;
-}
-
-static bool getBatteryState(DBusGConnection *pBus, const string &amp;name, const string &amp;path,
-	const string &amp;method, gboolean &amp;result)
-{
-	bool callSuccess = true;
-
-	if ((pBus == NULL) ||
-		(name.empty() == true) ||
-		(path.empty() == true) ||
-		(method.empty() == true))
-	{
-		return false;
-	}
-
-	DBusGProxy *pBusProxy = dbus_g_proxy_new_for_name(pBus, name.c_str(),
-		path.c_str(), name.c_str());
-	if (pBusProxy == NULL)
-	{
-		return false;
-	}
-
-	GError *pError = NULL;
-	if (dbus_g_proxy_call(pBusProxy, method.c_str(), &amp;pError,
-		G_TYPE_INVALID,
-		G_TYPE_BOOLEAN, &amp;result,
-		G_TYPE_INVALID) == FALSE)
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;Couldn't get battery state: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			g_error_free(pError);
-		}
-
-		callSuccess = false;
-	}
-
-	g_object_unref(pBusProxy);
-
-	return callSuccess;
-}
-
-int main(int argc, char **argv)
-{
-	int longOptionIndex = 0, priority = 15;
-	bool resetHistory = false;
-	bool resetLabels = false;
-	bool fullScan = false;
-	bool reindex = false;
-	bool ignoreVersion = false;
-
-	// Look at the options
-	int optionChar = getopt_long(argc, argv, &quot;fhip:rv&quot;, g_longOptions, &amp;longOptionIndex);
-	while (optionChar != -1)
-	{
-		switch (optionChar)
-		{
-			case 'f':
-				fullScan = true;
-				break;
-			case 'h':
-				// Help
-				cout &lt;&lt; &quot;pinot-dbus-daemon - D-Bus search and index daemon\n\n&quot;
-					&lt;&lt; &quot;Usage: pinot-dbus-daemon [OPTIONS]\n\n&quot;
-					&lt;&lt; &quot;Options:\n&quot;
-					&lt;&lt; &quot;  -f, --fullscan	force a full scan\n&quot;
-					&lt;&lt; &quot;  -h, --help		display this help and exit\n&quot;
-					&lt;&lt; &quot;  -i, --ignore-version	ignore the index version number\n&quot;
-					&lt;&lt; &quot;  -p, --priority	set the daemon's priority (default 15)\n&quot;
-					&lt;&lt; &quot;  -r, --reindex		force a reindex\n&quot;
-					&lt;&lt; &quot;  -v, --version		output version information and exit\n&quot;
-					&lt;&lt; &quot;\nReport bugs to &quot; &lt;&lt; PACKAGE_BUGREPORT &lt;&lt; endl;
-				return EXIT_SUCCESS;
-			case 'i':
-				ignoreVersion = true;
-				break;
-			case 'p':
-				if (optarg != NULL)
-				{
-					int newPriority = atoi(optarg);
-					if ((newPriority &gt;= -20) &amp;&amp;
-						(newPriority &lt; 20))
-					{
-						priority = newPriority;
-					}
-				}
-				break;
-			case 'r':
-				reindex = true;
-				break;
-			case 'v':
-				cout &lt;&lt; &quot;pinot-dbus-daemon - &quot; &lt;&lt; PACKAGE_STRING &lt;&lt; &quot;\n\n&quot; 
-					&lt;&lt; &quot;This is free software.  You may redistribute copies of it under the terms of\n&quot;
-					&lt;&lt; &quot;the GNU General Public License &lt;<A HREF="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html">http://www.gnu.org/licenses/old-licenses/gpl-2.0.html</A>&gt;.\n&quot;
-					&lt;&lt; &quot;There is NO WARRANTY, to the extent permitted by law.&quot; &lt;&lt; endl;
-				return EXIT_SUCCESS;
-			default:
-				return EXIT_FAILURE;
-		}
-
-		// Next option
-		optionChar = getopt_long(argc, argv, &quot;fhip:rv&quot;, g_longOptions, &amp;longOptionIndex);
-	}
-
-#if defined(ENABLE_NLS)
-	bindtextdomain(GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
-	bind_textdomain_codeset(GETTEXT_PACKAGE, &quot;UTF-8&quot;);
-	textdomain(GETTEXT_PACKAGE);
-#endif //ENABLE_NLS
-
-	// Initialize threads support before doing anything else
-	if (Glib::thread_supported() == false)
-	{
-		Glib::thread_init();
-	}
-	// Initialize the GType and the D-Bus thread system
-	g_type_init();
-#if DBUS_NUM_VERSION &gt; 1000000
-	dbus_threads_init_default();
-#endif
-	dbus_g_thread_init();
-
-	g_refMainLoop = Glib::MainLoop::create();
-	Glib::set_application_name(&quot;Pinot DBus Daemon&quot;);
-
-	// This should make Xapian use Flint rather than Quartz
-	Glib::setenv(&quot;XAPIAN_PREFER_FLINT&quot;, &quot;1&quot;);
-
-	// Make the locale follow the environment variables
-	setlocale(LC_ALL, &quot;&quot;);
-	char *pLocale = setlocale(LC_ALL, NULL);
-	if (pLocale != NULL)
-	{
-		string locale(pLocale);
-
-		if (locale != &quot;C&quot;)
-		{
-			bool appendUTF8 = false;
-
-			string::size_type pos = locale.find_last_of(&quot;.&quot;);
-			if ((pos != string::npos) &amp;&amp;
-				((strcasecmp(locale.substr(pos).c_str(), &quot;.utf8&quot;) != 0) &amp;&amp;
-				(strcasecmp(locale.substr(pos).c_str(), &quot;.utf-8&quot;) != 0)))
-			{
-				locale.resize(pos);
-				appendUTF8 = true;
-			}
-
-			if (appendUTF8 == true)
-			{
-				locale += &quot;.UTF-8&quot;;
-
-				pLocale = setlocale(LC_ALL, locale.c_str());
-				if (pLocale != NULL)
-				{
-#ifdef DEBUG
-					cout &lt;&lt; &quot;Changed locale to &quot; &lt;&lt; pLocale &lt;&lt; endl;
-#endif
-				}
-			}
-		}
-	}
-
-	// Make sure only one instance runs
-	UniqueApplication uniqueApp(&quot;de.berlios.PinotDBusDaemon&quot;);
-	string confDirectory = PinotSettings::getConfigurationDirectory();
-	g_pidFileName = confDirectory + &quot;/pinot-dbus-daemon.pid&quot;;
-	if (chdir(confDirectory.c_str()) == 0)
-	{
-		if (uniqueApp.isRunning(g_pidFileName, &quot;pinot-dbus-daemon&quot;) == true)
-		{
-			return EXIT_SUCCESS;
-		}
-
-		// Redirect cout and cerr to a file
-		string fileName(confDirectory);
-		fileName += &quot;/pinot-dbus-daemon.log&quot;;
-		g_outputFile.open(fileName.c_str());
-		g_coutBuf = cout.rdbuf();
-		g_cerrBuf = cerr.rdbuf();
-		cout.rdbuf(g_outputFile.rdbuf());
-		cerr.rdbuf(g_outputFile.rdbuf());
-	}
-	else
-	{
-		// We can't rely on the PID file
-		if (uniqueApp.isRunning() == true)
-		{
-			return EXIT_SUCCESS;
-		}
-	}
-
-	// This will create the necessary directories on the first run
-	PinotSettings &amp;settings = PinotSettings::getInstance();
-	// This is the daemon so disable client-side code 
-	settings.enableClientMode(false);
-
-	// Initialize utility classes
-	if (MIMEScanner::initialize(PinotSettings::getHomeDirectory() + &quot;/.local&quot;,
-		string(SHARED_MIME_INFO_PREFIX)) == false)
-	{
-		cerr &lt;&lt; &quot;Couldn't load MIME settings&quot; &lt;&lt; endl;
-	}
-	DownloaderInterface::initialize();
-	// Load tokenizer libraries, if any
-	Dijon::HtmlFilter::initialize();
-	Dijon::FilterFactory::loadFilters(string(LIBDIR) + &quot;/pinot/filters&quot;);
-	Dijon::FilterFactory::loadFilters(confDirectory + &quot;/filters&quot;);
-	// Load backends, if any
-	ModuleFactory::loadModules(string(LIBDIR) + &quot;/pinot/backends&quot;);
-	ModuleFactory::loadModules(confDirectory + &quot;/backends&quot;);
-
-	// Localize language names
-	Languages::setIntlName(0, _(&quot;Unknown&quot;));
-	Languages::setIntlName(1, _(&quot;Danish&quot;));
-	Languages::setIntlName(2, _(&quot;Dutch&quot;));
-	Languages::setIntlName(3, _(&quot;English&quot;));
-	Languages::setIntlName(4, _(&quot;Finnish&quot;));
-	Languages::setIntlName(5, _(&quot;French&quot;));
-	Languages::setIntlName(6, _(&quot;German&quot;));
-	Languages::setIntlName(7, _(&quot;Hungarian&quot;));
-	Languages::setIntlName(8, _(&quot;Italian&quot;));
-	Languages::setIntlName(9, _(&quot;Norwegian&quot;));
-	Languages::setIntlName(10, _(&quot;Portuguese&quot;));
-	Languages::setIntlName(11, _(&quot;Romanian&quot;));
-	Languages::setIntlName(12, _(&quot;Russian&quot;));
-	Languages::setIntlName(13, _(&quot;Spanish&quot;));
-	Languages::setIntlName(14, _(&quot;Swedish&quot;));
-	Languages::setIntlName(15, _(&quot;Turkish&quot;));
-
-	// Load the settings
-	settings.load(PinotSettings::LOAD_ALL);
-
-	// Catch interrupts
-#ifdef HAVE_SIGACTION
-	struct sigaction newAction;
-	sigemptyset(&amp;newAction.sa_mask);
-	newAction.sa_flags = 0;
-	newAction.sa_handler = quitAll;
-	sigaction(SIGINT, &amp;newAction, NULL);
-	sigaction(SIGQUIT, &amp;newAction, NULL);
-	sigaction(SIGTERM, &amp;newAction, NULL);
-#else
-	signal(SIGINT, quitAll);
-#ifdef SIGQUIT
-	signal(SIGQUIT, quitAll);
-#endif
-	signal(SIGTERM, quitAll);
-#endif
-
-	// Open the daemon index in read-write mode 
-	bool wasObsoleteFormat = false;
-	if (ModuleFactory::openOrCreateIndex(settings.m_defaultBackend, settings.m_daemonIndexLocation, wasObsoleteFormat, false) == false)
-	{
-		cerr &lt;&lt; &quot;Couldn't open index &quot; &lt;&lt; settings.m_daemonIndexLocation &lt;&lt; endl;
-		return EXIT_FAILURE;
-	}
-	if (wasObsoleteFormat == true)
-	{
-		resetHistory = resetLabels = true;
-	}
-
-	// Do the same for the history database
-	PinotSettings::checkHistoryDatabase();
-	string historyDatabase(settings.getHistoryDatabaseName());
-	if ((historyDatabase.empty() == true) ||
-		(ActionQueue::create(historyDatabase) == false) ||
-		(CrawlHistory::create(historyDatabase) == false) ||
-		(MetaDataBackup::create(historyDatabase) == false) ||
-		(QueryHistory::create(historyDatabase) == false) ||
-		(ViewHistory::create(historyDatabase) == false))
-	{
-		cerr &lt;&lt; &quot;Couldn't create history database &quot; &lt;&lt; historyDatabase &lt;&lt; endl;
-		return EXIT_FAILURE;
-	}
-	else
-	{
-		ActionQueue actionQueue(historyDatabase, Glib::get_application_name());
-		QueryHistory queryHistory(historyDatabase);
-		ViewHistory viewHistory(historyDatabase);
-		time_t timeNow = time(NULL);
-		unsigned int actionsCount = actionQueue.getItemsCount(ActionQueue::INDEX);
-
-		// Don't expire actions left from last time
-		actionsCount += actionQueue.getItemsCount(ActionQueue::UNINDEX);
-		cout &lt;&lt; actionsCount &lt;&lt; &quot; actions left&quot; &lt;&lt; endl;
-
-		// Expire the rest
-		queryHistory.expireItems(timeNow);
-		viewHistory.expireItems(timeNow);
-	}
-
-	atexit(closeAll);
-
-	// Change the daemon's priority
-	if (setpriority(PRIO_PROCESS, 0, priority) == -1)
-	{
-		cerr &lt;&lt; &quot;Couldn't set scheduling priority to &quot; &lt;&lt; priority &lt;&lt; endl;
-	}
-#ifdef DEBUG
-	else cout &lt;&lt; &quot;Set priority to &quot; &lt;&lt; priority &lt;&lt; endl;
-#endif
-
-	GError *pError = NULL;
-	DBusGConnection *pBus = dbus_g_bus_get(DBUS_BUS_SESSION, &amp;pError);
-	if (pBus == NULL)
-	{
-		if (pError != NULL)
-		{
-			cerr &lt;&lt; &quot;Couldn't open bus connection: &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			if (pError-&gt;message != NULL)
-			{
-				cerr &lt;&lt; &quot;Error is &quot; &lt;&lt; pError-&gt;message &lt;&lt; endl;
-			}
-			g_error_free(pError);
-		}
-
-		return EXIT_FAILURE;
-	}
-
-	DBusConnection *pConnection = dbus_g_connection_get_connection(pBus);
-	if (pConnection == NULL)
-	{
-		cerr &lt;&lt; &quot;Couldn't get connection&quot; &lt;&lt; endl;
-		return EXIT_FAILURE;
-	}
-
-	DBusError error;
-	DaemonState server;
-	IndexInterface *pIndex = NULL;
-
-	dbus_error_init(&amp;error);
-	dbus_connection_set_exit_on_disconnect(pConnection, FALSE);
-	dbus_connection_setup_with_g_main(pConnection, NULL);
-
-	if (dbus_connection_register_object_path(pConnection, g_pinotDBusObjectPath,
-		&amp;g_callVTable, &amp;server) == TRUE)
-	{
-		// Request to be identified by this name
-		// FIXME: flags are currently broken ?
-		dbus_bus_request_name(pConnection, g_pinotDBusService, 0, &amp;error);
-		if (dbus_error_is_set(&amp;error) == FALSE)
-		{
-			// See power management signals
-			dbus_bus_add_match(pConnection,
-				&quot;type='signal',interface='org.freedesktop.PowerManagement'&quot;, &amp;error);
-			dbus_bus_add_match(pConnection,
-				&quot;type='signal',interface='org.gnome.PowerManager'&quot;, &amp;error);
-
-			dbus_connection_add_filter(pConnection,
-				(DBusHandleMessageFunction)filterHandler, &amp;server, NULL);
-		}
-		else
-		{
-			cerr &lt;&lt; &quot;Couldn't obtain name &quot; &lt;&lt; g_pinotDBusService &lt;&lt; endl;
-			if (error.message != NULL)
-			{
-				cerr &lt;&lt; &quot;Error is &quot; &lt;&lt; error.message &lt;&lt; endl;
-			}
-		}
-
-		try
-		{
-			set&lt;string&gt; labels;
-			bool gotLabels = false;
-			bool onBattery = false;
-
-			pIndex = settings.getIndex(settings.m_daemonIndexLocation);
-			if (pIndex != NULL)
-			{
-				string indexVersion(pIndex-&gt;getMetadata(&quot;version&quot;));
-
-				gotLabels = pIndex-&gt;getLabels(labels);
-
-				// What version is the index at ?
-				if (indexVersion.empty() == true)
-				{
-					indexVersion = &quot;0.0&quot;;
-				}
-				if (ignoreVersion == true)
-				{
-					// Better reset labels, they may have been lost too
-					resetLabels = true;
-				}
-				else if (indexVersion &lt; PINOT_INDEX_MIN_VERSION)
-				{
-					cout &lt;&lt; &quot;Upgrading index from version &quot; &lt;&lt; indexVersion &lt;&lt; &quot; to &quot; &lt;&lt; VERSION &lt;&lt; endl;
-
-					reindex = true;
-				}
-				if (reindex == true)
-				{
-					// Reset the index so that all documents are reindexed
-					pIndex-&gt;reset();
-
-					cout &lt;&lt; &quot;Reset index&quot; &lt;&lt; endl;
-
-					resetHistory = resetLabels = true;
-				}
-
-				pIndex-&gt;setMetadata(&quot;version&quot;, VERSION);
-				pIndex-&gt;setMetadata(&quot;dbus-status&quot;, &quot;Running&quot;);
-			}
-
-			if (resetHistory == true)
-			{
-				CrawlHistory history(historyDatabase);
-				map&lt;unsigned int, string&gt; sources;
-
-				// Reset the history
-				history.getSources(sources);
-				for (std::map&lt;unsigned int, string&gt;::iterator sourceIter = sources.begin();
-					sourceIter != sources.end(); ++sourceIter)
-				{
-					history.deleteItems(sourceIter-&gt;first);
-					history.deleteSource(sourceIter-&gt;first);
-				}
-
-				cout &lt;&lt; &quot;Reset crawler history&quot; &lt;&lt; endl;
-			}
-
-			if ((resetLabels == true) &amp;&amp;
-				(pIndex != NULL))
-			{
-				// Re-apply the labels list
-				if (gotLabels == false)
-				{
-					// If this is an upgrade from a version &lt; 0.80, the labels list
-					// needs to be pulled from the configuration file
-					pIndex-&gt;setLabels(settings.m_labels, true);
-
-					cout &lt;&lt; &quot;Set labels as per the configuration file&quot; &lt;&lt; endl;
-				}
-				else
-				{
-					pIndex-&gt;setLabels(labels, true);
-				}
-			}
-
-			// Connect to the quit signal
-			server.getQuitSignal().connect(sigc::ptr_fun(&amp;quitAll));
-
-			// Connect to threads' finished signal
-			server.connect();
-
-			// Try and get the battery state
-			gboolean result = FALSE;
-			if ((getBatteryState(pBus, &quot;org.freedesktop.PowerManagement&quot;,
-				&quot;/org/freedesktop/PowerManagement&quot;, &quot;GetOnBattery&quot;, result) == true) ||
-				(getBatteryState(pBus, &quot;org.freedesktop.PowerManagement&quot;,
-				&quot;/org/freedesktop/PowerManagement&quot;, &quot;GetBatteryState&quot;, result) == true))
-			{
-				if (result == TRUE)
-				{
-					onBattery = true;
-				}
-			}
-			else if (getBatteryState(pBus, &quot;org.gnome.PowerManager&quot;,
-				&quot;/org/gnome/PowerManager&quot;, &quot;GetOnAc&quot;, result) == true)
-			{
-				if (result == FALSE)
-				{
-					onBattery = true;
-				}
-			}
-			if (onBattery == true)
-			{
-				// We are on battery
-				server.set_flag(DaemonState::ON_BATTERY);
-				server.stop_crawling();
-
-				cout &lt;&lt; &quot;System is on battery&quot; &lt;&lt; endl;
-			}
-
-			server.start(fullScan, reindex);
-
-			// Run the main loop
-			g_refMainLoop-&gt;run();
-
-		}
-		catch (const Glib::Exception &amp;e)
-		{
-			cerr &lt;&lt; e.what() &lt;&lt; endl;
-			return EXIT_FAILURE;
-		}
-		catch (const char *pMsg)
-		{
-			cerr &lt;&lt; pMsg &lt;&lt; endl;
-			return EXIT_FAILURE;
-		}
-		catch (...)
-		{
-			cerr &lt;&lt; &quot;Unknown exception&quot; &lt;&lt; endl;
-			return EXIT_FAILURE;
-		}
-	}
-	else
-	{
-		cerr &lt;&lt; &quot;Couldn't register object path&quot; &lt;&lt; endl;
-	}
-	dbus_error_free(&amp;error);
-
-	if (pIndex != NULL)
-	{
-		if (server.is_flag_set(DaemonState::DISCONNECTED) == true)
-		{
-			pIndex-&gt;setMetadata(&quot;dbus-status&quot;, &quot;Disconnected&quot;);
-		}
-		else if (server.is_flag_set(DaemonState::STOPPED) == true)
-		{
-			pIndex-&gt;setMetadata(&quot;dbus-status&quot;, &quot;Stopped&quot;);
-		}
-		else
-		{
-			pIndex-&gt;setMetadata(&quot;dbus-status&quot;, &quot;&quot;);
-		}
-		delete pIndex;
-	}
-
-	// Stop everything
-	server.disconnect();
-	server.stop_threads();
-
-	return EXIT_SUCCESS;
-}

Copied: trunk/Core/pinot-dbus-daemon.cpp (from rev 1530, trunk/Core/pinot-dbus-daemon.cc)

Copied: trunk/UI/GTK2/src/EnginesTree.cc (from rev 1529, trunk/UI/GTK2/src/EnginesTree.cpp)
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/EnginesTree.cc	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,407 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+#include &lt;gtkmm/alignment.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/buttonbox.h&gt;
+#include &lt;gtkmm/image.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/stock.h&gt;
+#include &lt;gtkmm/textbuffer.h&gt;
+
+#include &quot;Url.h&quot;
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;ModuleFactory.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;EnginesTree.hh&quot;
+
+using namespace std;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+EnginesTree::EnginesTree(VBox *enginesVbox, PinotSettings &amp;settings) :
+	TreeView(),
+	m_settings(settings)
+{
+	ScrolledWindow *enginesScrolledwindow = manage(new ScrolledWindow());
+
+	// This is the actual engines tree
+	set_events(Gdk::BUTTON_PRESS_MASK);
+	set_flags(CAN_FOCUS);
+	set_headers_clickable(true);
+	set_headers_visible(true);
+	set_reorderable(false);
+	set_enable_search(false);
+	get_selection()-&gt;set_mode(SELECTION_MULTIPLE);
+	enginesScrolledwindow-&gt;set_flags(CAN_FOCUS);
+	enginesScrolledwindow-&gt;set_shadow_type(SHADOW_NONE);
+	enginesScrolledwindow-&gt;set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
+	enginesScrolledwindow-&gt;property_window_placement().set_value(CORNER_TOP_LEFT);
+	enginesScrolledwindow-&gt;add(*this);
+
+	// Position the scrolled window
+	enginesVbox-&gt;pack_start(*enginesScrolledwindow, Gtk::PACK_EXPAND_WIDGET, 0);
+
+	// Associate the columns model to the engines tree
+	m_refStore = TreeStore::create(m_enginesColumns);
+	set_model(m_refStore);
+
+	TreeViewColumn *pColumn = new TreeViewColumn(_(&quot;Search Engines&quot;));
+	// Pack an icon renderer for engines icons
+	CellRendererPixbuf *pIconRenderer = new CellRendererPixbuf();
+	pColumn-&gt;pack_start(*manage(pIconRenderer), false);
+	pColumn-&gt;set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &amp;EnginesTree::renderEngineIcon));
+	pColumn-&gt;pack_end(m_enginesColumns.m_name, false);
+	pColumn-&gt;set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
+	append_column(*manage(pColumn));
+
+	// Handle button presses
+	signal_button_press_event().connect_notify(sigc::mem_fun(*this, &amp;EnginesTree::onButtonPressEvent));
+	// Control which rows can be selected
+	get_selection()-&gt;set_select_function(sigc::mem_fun(*this, &amp;EnginesTree::onSelectionSelect));
+	// Listen for style changes
+	signal_style_changed().connect_notify(sigc::mem_fun(*this, &amp;EnginesTree::onStyleChanged));
+
+	// Render the icons
+	m_engineFolderIconPixbuf = render_icon(Stock::DIRECTORY, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+
+	// Populate
+	populate();
+
+	// Show all
+	show();
+	enginesScrolledwindow-&gt;show();
+}
+
+EnginesTree::~EnginesTree()
+{
+}
+
+void EnginesTree::save(void)
+{
+	std::map&lt;string, bool&gt; &amp;channels = m_settings.getSearchEnginesChannels();
+
+	TreeModel::Children children = m_refStore-&gt;children();
+	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
+	{
+		TreeModel::Row row = *iter;
+
+		if (row[m_enginesColumns.m_type] == EnginesModelColumns::ENGINE_FOLDER)
+		{
+			ustring channelName(row[m_enginesColumns.m_name]);
+			TreeModel::Path channelPath = m_refStore-&gt;get_path(iter);
+
+			std::map&lt;string, bool&gt;::iterator channelIter = channels.find(from_utf8(channelName));
+			if (channelIter != channels.end())
+			{
+#ifdef DEBUG
+				cout &lt;&lt; &quot;EnginesTree::save: &quot; &lt;&lt; channelName &lt;&lt; &quot; is &quot; &lt;&lt; row_expanded(channelPath) &lt;&lt; endl;
+#endif
+				channelIter-&gt;second = row_expanded(channelPath);
+			}
+		}
+	}
+}
+
+void EnginesTree::renderEngineIcon(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &amp;iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (renderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *pIconRenderer = dynamic_cast&lt;CellRendererPixbuf*&gt;(renderer);
+	if (pIconRenderer != NULL)
+	{
+		// Is this an engine folder ?
+		if (row[m_enginesColumns.m_type] == EnginesModelColumns::ENGINE_FOLDER)
+		{
+			pIconRenderer-&gt;property_pixbuf() = m_engineFolderIconPixbuf;
+		}
+		else
+		{
+			pIconRenderer-&gt;property_pixbuf().reset_value();
+		}
+	}
+}
+
+//
+// Handles button presses.
+//
+void EnginesTree::onButtonPressEvent(GdkEventButton *ev)
+{
+	list&lt;TreeModel::Path&gt; selectedEngines = get_selection()-&gt;get_selected_rows();
+	// If there are more than one row selected, don't bother
+	if (selectedEngines.size() != 1)
+	{
+		return;
+	}
+
+	list&lt;TreeModel::Path&gt;::iterator enginePath = selectedEngines.begin();
+	if (enginePath == selectedEngines.end())
+	{
+		return;
+	}
+
+	TreeModel::iterator engineIter = m_refStore-&gt;get_iter(*enginePath);
+	TreeModel::Row engineRow = *engineIter;
+
+	// Check for double clicks
+	if (ev-&gt;type == GDK_2BUTTON_PRESS)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;EnginesTree::onButtonPressEvent: double click on button &quot; &lt;&lt; ev-&gt;button &lt;&lt; endl;
+#endif
+		// Make sure the engine is an external index
+		EnginesModelColumns::EngineType engineType = engineRow[m_enginesColumns.m_type];
+		if (engineType == EnginesModelColumns::INDEX_ENGINE)
+		{
+			ustring name = engineRow[m_enginesColumns.m_name];
+			ustring location = engineRow[m_enginesColumns.m_option];
+
+			m_signalDoubleClick(name, location);
+		}
+		else
+		{
+			// Is the row already expanded ?
+			if (row_expanded(*enginePath) == false)
+			{
+				// Expand it
+				expand_row(*enginePath, true);
+			}
+			else
+			{
+				// Collapse it
+				collapse_row(*enginePath);
+			}
+		}
+	}
+}
+
+//
+// Handles attempts to select rows.
+//
+bool EnginesTree::onSelectionSelect(const RefPtr&lt;TreeModel&gt;&amp; model,
+		const TreeModel::Path&amp; node_path, bool path_currently_selected)
+{
+	// All nodes can be selected
+	return true;
+}
+
+//
+// Handles GTK style changes.
+//
+void EnginesTree::onStyleChanged(const RefPtr&lt;Style&gt; &amp;previous_style)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;EnginesTree::onStyleChanged: called&quot; &lt;&lt; endl;
+#endif
+	// FIXME: find better icons :-)
+	m_engineFolderIconPixbuf = render_icon(Stock::DIRECTORY, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+}
+
+//
+// Gets a list of selected items.
+//
+list&lt;TreeModel::Path&gt; EnginesTree::getSelection(void)
+{
+	return get_selection()-&gt;get_selected_rows();
+}
+
+/// Gets an iterator.
+TreeModel::iterator EnginesTree::getIter(TreeModel::Path enginePath)
+{
+	return m_refStore-&gt;get_iter(enginePath);
+}
+
+/// Gets the column record.
+EnginesModelColumns &amp;EnginesTree::getColumnRecord(void)
+{
+	return m_enginesColumns;
+}
+
+//
+// Populate the tree.
+//
+void EnginesTree::populate(bool indexesOnly)
+{
+	set&lt;ModuleProperties&gt; engines;
+	ustring currentUserChannel(_(&quot;Current User&quot;));
+	TreeModel::Row row;
+	TreeModel::iterator folderIter, localIter;
+	bool createCurrentUserChannel = true;
+
+	// Reset the whole tree
+	get_selection()-&gt;unselect_all();
+	m_refStore-&gt;clear();
+
+	// Populate the tree with search engines
+	std::map&lt;string, bool&gt; &amp;channels = m_settings.getSearchEnginesChannels();
+	for (std::map&lt;string, bool&gt;::const_iterator channelIter = channels.begin();
+		channelIter != channels.end(); ++channelIter)
+	{
+		string channelName(channelIter-&gt;first);
+		bool isExpanded(channelIter-&gt;second);
+
+		// Enumerate search engines for this channel
+		engines.clear();
+		m_settings.getSearchEngines(engines, channelName);
+
+		if (engines.empty() == true)
+		{
+			continue;
+		}
+
+		folderIter = m_refStore-&gt;append();
+		row = *folderIter;
+
+		// Is this the current user channel ?
+		if (channelName == &quot;X-Current-User-Channel&quot;)
+		{
+			row[m_enginesColumns.m_name] = currentUserChannel;
+		}
+		else
+		{
+			row[m_enginesColumns.m_name] = to_utf8(channelName);
+		}
+		row[m_enginesColumns.m_engineName] = &quot;internal-folder&quot;;
+		row[m_enginesColumns.m_option] = &quot;&quot;;
+		row[m_enginesColumns.m_type] = EnginesModelColumns::ENGINE_FOLDER;
+
+		if (channelName == &quot;X-Current-User-Channel&quot;)
+		{
+			localIter = folderIter;
+			createCurrentUserChannel = false;
+		}
+		else if (createCurrentUserChannel == false)
+		{
+			// The current user channel stays at the bottom
+			m_refStore-&gt;iter_swap(folderIter, localIter);
+		}
+
+		std::set&lt;ModuleProperties&gt;::const_iterator engineIter = engines.begin();
+		for (; engineIter != engines.end(); ++engineIter)
+		{
+			ustring engineType(to_utf8(engineIter-&gt;m_name));
+			ustring engineName(to_utf8(engineIter-&gt;m_longName));
+
+			if (ModuleFactory::isSupported(engineType, true) == true)
+			{
+				// Skip this, it's only usable through a local engine
+				continue;
+			}
+
+			TreeModel::iterator iter = m_refStore-&gt;append(folderIter-&gt;children());
+			row = *iter;
+
+			row[m_enginesColumns.m_name] = engineName;
+			row[m_enginesColumns.m_engineName] = engineType;
+			row[m_enginesColumns.m_option] = engineIter-&gt;m_option;
+			row[m_enginesColumns.m_type] = EnginesModelColumns::WEB_ENGINE;
+#ifdef DEBUG
+			cout &lt;&lt; &quot;EnginesTree::populate: engine &quot; &lt;&lt; engineName &lt;&lt; &quot;/&quot; &lt;&lt; engineType &lt;&lt; &quot; at &quot; &lt;&lt; engineIter-&gt;m_option &lt;&lt; endl;
+#endif
+		}
+
+		TreeModel::Path folderPath = m_refStore-&gt;get_path(folderIter);
+		if (isExpanded == true)
+		{
+			// Expand this
+			expand_row(folderPath, true);
+		}
+		else
+		{
+			// Collapse this
+			collapse_row(folderPath);
+		}
+	}
+
+	if (createCurrentUserChannel == true)
+	{
+		localIter = m_refStore-&gt;append();
+		row = *localIter;
+		row[m_enginesColumns.m_name] = currentUserChannel;
+		row[m_enginesColumns.m_engineName] = &quot;internal-folder&quot;;
+		row[m_enginesColumns.m_option] = &quot;&quot;;
+		row[m_enginesColumns.m_type] = EnginesModelColumns::ENGINE_FOLDER;
+	}
+
+	// Local engines
+	for (set&lt;PinotSettings::IndexProperties&gt;::const_iterator indexIter = m_settings.getIndexes().begin();
+		indexIter != m_settings.getIndexes().end(); ++indexIter)
+	{
+		EnginesModelColumns::EngineType indexType = EnginesModelColumns::INDEX_ENGINE;
+
+		if (indexIter-&gt;m_internal == true)
+		{
+			indexType = EnginesModelColumns::INTERNAL_INDEX_ENGINE;
+		}
+
+		TreeModel::iterator iter = m_refStore-&gt;append(localIter-&gt;children());
+		TreeModel::Row childRow = *iter;
+		childRow[m_enginesColumns.m_name] = indexIter-&gt;m_name;
+		childRow[m_enginesColumns.m_engineName] = m_settings.m_defaultBackend;
+		childRow[m_enginesColumns.m_option] = indexIter-&gt;m_location;
+		childRow[m_enginesColumns.m_type] = indexType;
+	}
+
+	// Expand this
+	expand_row(m_refStore-&gt;get_path(localIter), true);
+
+	get_selection()-&gt;select(localIter);
+}
+
+//
+// Clear the tree.
+//
+void EnginesTree::clear(void)
+{
+	// Unselect engines
+	get_selection()-&gt;unselect_all();
+
+	// Remove existing rows in the tree
+	TreeModel::Children children = m_refStore-&gt;children();
+	if (children.empty() == false)
+	{
+		TreeModel::Children::iterator iter = children.begin();
+		while (iter != children.end())
+		{
+			// Erase this row
+			m_refStore-&gt;erase(*iter);
+
+			// Get the new first row
+			children = m_refStore-&gt;children();
+			iter = children.begin();
+		}
+		m_refStore-&gt;clear();
+	}
+}
+
+//
+// Returns the double-click signal.
+//
+sigc::signal2&lt;void, string, string&gt;&amp; EnginesTree::getDoubleClickSignal(void)
+{
+	return m_signalDoubleClick;
+}


Property changes on: trunk/UI/GTK2/src/EnginesTree.cc
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: trunk/UI/GTK2/src/EnginesTree.cpp
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.cpp	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/EnginesTree.cpp	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,407 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;iostream&gt;
-#include &lt;gtkmm/alignment.h&gt;
-#include &lt;gtkmm/box.h&gt;
-#include &lt;gtkmm/buttonbox.h&gt;
-#include &lt;gtkmm/image.h&gt;
-#include &lt;gtkmm/label.h&gt;
-#include &lt;gtkmm/stock.h&gt;
-#include &lt;gtkmm/textbuffer.h&gt;
-
-#include &quot;Url.h&quot;
-#include &quot;config.h&quot;
-#include &quot;NLS.h&quot;
-#include &quot;ModuleFactory.h&quot;
-#include &quot;PinotSettings.h&quot;
-#include &quot;PinotUtils.h&quot;
-#include &quot;EnginesTree.h&quot;
-
-using namespace std;
-using namespace Glib;
-using namespace Gdk;
-using namespace Gtk;
-
-EnginesTree::EnginesTree(VBox *enginesVbox, PinotSettings &amp;settings) :
-	TreeView(),
-	m_settings(settings)
-{
-	ScrolledWindow *enginesScrolledwindow = manage(new ScrolledWindow());
-
-	// This is the actual engines tree
-	set_events(Gdk::BUTTON_PRESS_MASK);
-	set_flags(CAN_FOCUS);
-	set_headers_clickable(true);
-	set_headers_visible(true);
-	set_reorderable(false);
-	set_enable_search(false);
-	get_selection()-&gt;set_mode(SELECTION_MULTIPLE);
-	enginesScrolledwindow-&gt;set_flags(CAN_FOCUS);
-	enginesScrolledwindow-&gt;set_shadow_type(SHADOW_NONE);
-	enginesScrolledwindow-&gt;set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
-	enginesScrolledwindow-&gt;property_window_placement().set_value(CORNER_TOP_LEFT);
-	enginesScrolledwindow-&gt;add(*this);
-
-	// Position the scrolled window
-	enginesVbox-&gt;pack_start(*enginesScrolledwindow, Gtk::PACK_EXPAND_WIDGET, 0);
-
-	// Associate the columns model to the engines tree
-	m_refStore = TreeStore::create(m_enginesColumns);
-	set_model(m_refStore);
-
-	TreeViewColumn *pColumn = new TreeViewColumn(_(&quot;Search Engines&quot;));
-	// Pack an icon renderer for engines icons
-	CellRendererPixbuf *pIconRenderer = new CellRendererPixbuf();
-	pColumn-&gt;pack_start(*manage(pIconRenderer), false);
-	pColumn-&gt;set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &amp;EnginesTree::renderEngineIcon));
-	pColumn-&gt;pack_end(m_enginesColumns.m_name, false);
-	pColumn-&gt;set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
-	append_column(*manage(pColumn));
-
-	// Handle button presses
-	signal_button_press_event().connect_notify(sigc::mem_fun(*this, &amp;EnginesTree::onButtonPressEvent));
-	// Control which rows can be selected
-	get_selection()-&gt;set_select_function(sigc::mem_fun(*this, &amp;EnginesTree::onSelectionSelect));
-	// Listen for style changes
-	signal_style_changed().connect_notify(sigc::mem_fun(*this, &amp;EnginesTree::onStyleChanged));
-
-	// Render the icons
-	m_engineFolderIconPixbuf = render_icon(Stock::DIRECTORY, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
-
-	// Populate
-	populate();
-
-	// Show all
-	show();
-	enginesScrolledwindow-&gt;show();
-}
-
-EnginesTree::~EnginesTree()
-{
-}
-
-void EnginesTree::save(void)
-{
-	std::map&lt;string, bool&gt; &amp;channels = m_settings.getSearchEnginesChannels();
-
-	TreeModel::Children children = m_refStore-&gt;children();
-	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
-	{
-		TreeModel::Row row = *iter;
-
-		if (row[m_enginesColumns.m_type] == EnginesModelColumns::ENGINE_FOLDER)
-		{
-			ustring channelName(row[m_enginesColumns.m_name]);
-			TreeModel::Path channelPath = m_refStore-&gt;get_path(iter);
-
-			std::map&lt;string, bool&gt;::iterator channelIter = channels.find(from_utf8(channelName));
-			if (channelIter != channels.end())
-			{
-#ifdef DEBUG
-				cout &lt;&lt; &quot;EnginesTree::save: &quot; &lt;&lt; channelName &lt;&lt; &quot; is &quot; &lt;&lt; row_expanded(channelPath) &lt;&lt; endl;
-#endif
-				channelIter-&gt;second = row_expanded(channelPath);
-			}
-		}
-	}
-}
-
-void EnginesTree::renderEngineIcon(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &amp;iter)
-{
-	TreeModel::Row row = *iter;
-
-	if (renderer == NULL)
-	{
-		return;
-	}
-
-	CellRendererPixbuf *pIconRenderer = dynamic_cast&lt;CellRendererPixbuf*&gt;(renderer);
-	if (pIconRenderer != NULL)
-	{
-		// Is this an engine folder ?
-		if (row[m_enginesColumns.m_type] == EnginesModelColumns::ENGINE_FOLDER)
-		{
-			pIconRenderer-&gt;property_pixbuf() = m_engineFolderIconPixbuf;
-		}
-		else
-		{
-			pIconRenderer-&gt;property_pixbuf().reset_value();
-		}
-	}
-}
-
-//
-// Handles button presses.
-//
-void EnginesTree::onButtonPressEvent(GdkEventButton *ev)
-{
-	list&lt;TreeModel::Path&gt; selectedEngines = get_selection()-&gt;get_selected_rows();
-	// If there are more than one row selected, don't bother
-	if (selectedEngines.size() != 1)
-	{
-		return;
-	}
-
-	list&lt;TreeModel::Path&gt;::iterator enginePath = selectedEngines.begin();
-	if (enginePath == selectedEngines.end())
-	{
-		return;
-	}
-
-	TreeModel::iterator engineIter = m_refStore-&gt;get_iter(*enginePath);
-	TreeModel::Row engineRow = *engineIter;
-
-	// Check for double clicks
-	if (ev-&gt;type == GDK_2BUTTON_PRESS)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;EnginesTree::onButtonPressEvent: double click on button &quot; &lt;&lt; ev-&gt;button &lt;&lt; endl;
-#endif
-		// Make sure the engine is an external index
-		EnginesModelColumns::EngineType engineType = engineRow[m_enginesColumns.m_type];
-		if (engineType == EnginesModelColumns::INDEX_ENGINE)
-		{
-			ustring name = engineRow[m_enginesColumns.m_name];
-			ustring location = engineRow[m_enginesColumns.m_option];
-
-			m_signalDoubleClick(name, location);
-		}
-		else
-		{
-			// Is the row already expanded ?
-			if (row_expanded(*enginePath) == false)
-			{
-				// Expand it
-				expand_row(*enginePath, true);
-			}
-			else
-			{
-				// Collapse it
-				collapse_row(*enginePath);
-			}
-		}
-	}
-}
-
-//
-// Handles attempts to select rows.
-//
-bool EnginesTree::onSelectionSelect(const RefPtr&lt;TreeModel&gt;&amp; model,
-		const TreeModel::Path&amp; node_path, bool path_currently_selected)
-{
-	// All nodes can be selected
-	return true;
-}
-
-//
-// Handles GTK style changes.
-//
-void EnginesTree::onStyleChanged(const RefPtr&lt;Style&gt; &amp;previous_style)
-{
-#ifdef DEBUG
-	cout &lt;&lt; &quot;EnginesTree::onStyleChanged: called&quot; &lt;&lt; endl;
-#endif
-	// FIXME: find better icons :-)
-	m_engineFolderIconPixbuf = render_icon(Stock::DIRECTORY, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
-}
-
-//
-// Gets a list of selected items.
-//
-list&lt;TreeModel::Path&gt; EnginesTree::getSelection(void)
-{
-	return get_selection()-&gt;get_selected_rows();
-}
-
-/// Gets an iterator.
-TreeModel::iterator EnginesTree::getIter(TreeModel::Path enginePath)
-{
-	return m_refStore-&gt;get_iter(enginePath);
-}
-
-/// Gets the column record.
-EnginesModelColumns &amp;EnginesTree::getColumnRecord(void)
-{
-	return m_enginesColumns;
-}
-
-//
-// Populate the tree.
-//
-void EnginesTree::populate(bool indexesOnly)
-{
-	set&lt;ModuleProperties&gt; engines;
-	ustring currentUserChannel(_(&quot;Current User&quot;));
-	TreeModel::Row row;
-	TreeModel::iterator folderIter, localIter;
-	bool createCurrentUserChannel = true;
-
-	// Reset the whole tree
-	get_selection()-&gt;unselect_all();
-	m_refStore-&gt;clear();
-
-	// Populate the tree with search engines
-	std::map&lt;string, bool&gt; &amp;channels = m_settings.getSearchEnginesChannels();
-	for (std::map&lt;string, bool&gt;::const_iterator channelIter = channels.begin();
-		channelIter != channels.end(); ++channelIter)
-	{
-		string channelName(channelIter-&gt;first);
-		bool isExpanded(channelIter-&gt;second);
-
-		// Enumerate search engines for this channel
-		engines.clear();
-		m_settings.getSearchEngines(engines, channelName);
-
-		if (engines.empty() == true)
-		{
-			continue;
-		}
-
-		folderIter = m_refStore-&gt;append();
-		row = *folderIter;
-
-		// Is this the current user channel ?
-		if (channelName == &quot;X-Current-User-Channel&quot;)
-		{
-			row[m_enginesColumns.m_name] = currentUserChannel;
-		}
-		else
-		{
-			row[m_enginesColumns.m_name] = to_utf8(channelName);
-		}
-		row[m_enginesColumns.m_engineName] = &quot;internal-folder&quot;;
-		row[m_enginesColumns.m_option] = &quot;&quot;;
-		row[m_enginesColumns.m_type] = EnginesModelColumns::ENGINE_FOLDER;
-
-		if (channelName == &quot;X-Current-User-Channel&quot;)
-		{
-			localIter = folderIter;
-			createCurrentUserChannel = false;
-		}
-		else if (createCurrentUserChannel == false)
-		{
-			// The current user channel stays at the bottom
-			m_refStore-&gt;iter_swap(folderIter, localIter);
-		}
-
-		std::set&lt;ModuleProperties&gt;::const_iterator engineIter = engines.begin();
-		for (; engineIter != engines.end(); ++engineIter)
-		{
-			ustring engineType(to_utf8(engineIter-&gt;m_name));
-			ustring engineName(to_utf8(engineIter-&gt;m_longName));
-
-			if (ModuleFactory::isSupported(engineType, true) == true)
-			{
-				// Skip this, it's only usable through a local engine
-				continue;
-			}
-
-			TreeModel::iterator iter = m_refStore-&gt;append(folderIter-&gt;children());
-			row = *iter;
-
-			row[m_enginesColumns.m_name] = engineName;
-			row[m_enginesColumns.m_engineName] = engineType;
-			row[m_enginesColumns.m_option] = engineIter-&gt;m_option;
-			row[m_enginesColumns.m_type] = EnginesModelColumns::WEB_ENGINE;
-#ifdef DEBUG
-			cout &lt;&lt; &quot;EnginesTree::populate: engine &quot; &lt;&lt; engineName &lt;&lt; &quot;/&quot; &lt;&lt; engineType &lt;&lt; &quot; at &quot; &lt;&lt; engineIter-&gt;m_option &lt;&lt; endl;
-#endif
-		}
-
-		TreeModel::Path folderPath = m_refStore-&gt;get_path(folderIter);
-		if (isExpanded == true)
-		{
-			// Expand this
-			expand_row(folderPath, true);
-		}
-		else
-		{
-			// Collapse this
-			collapse_row(folderPath);
-		}
-	}
-
-	if (createCurrentUserChannel == true)
-	{
-		localIter = m_refStore-&gt;append();
-		row = *localIter;
-		row[m_enginesColumns.m_name] = currentUserChannel;
-		row[m_enginesColumns.m_engineName] = &quot;internal-folder&quot;;
-		row[m_enginesColumns.m_option] = &quot;&quot;;
-		row[m_enginesColumns.m_type] = EnginesModelColumns::ENGINE_FOLDER;
-	}
-
-	// Local engines
-	for (set&lt;PinotSettings::IndexProperties&gt;::const_iterator indexIter = m_settings.getIndexes().begin();
-		indexIter != m_settings.getIndexes().end(); ++indexIter)
-	{
-		EnginesModelColumns::EngineType indexType = EnginesModelColumns::INDEX_ENGINE;
-
-		if (indexIter-&gt;m_internal == true)
-		{
-			indexType = EnginesModelColumns::INTERNAL_INDEX_ENGINE;
-		}
-
-		TreeModel::iterator iter = m_refStore-&gt;append(localIter-&gt;children());
-		TreeModel::Row childRow = *iter;
-		childRow[m_enginesColumns.m_name] = indexIter-&gt;m_name;
-		childRow[m_enginesColumns.m_engineName] = m_settings.m_defaultBackend;
-		childRow[m_enginesColumns.m_option] = indexIter-&gt;m_location;
-		childRow[m_enginesColumns.m_type] = indexType;
-	}
-
-	// Expand this
-	expand_row(m_refStore-&gt;get_path(localIter), true);
-
-	get_selection()-&gt;select(localIter);
-}
-
-//
-// Clear the tree.
-//
-void EnginesTree::clear(void)
-{
-	// Unselect engines
-	get_selection()-&gt;unselect_all();
-
-	// Remove existing rows in the tree
-	TreeModel::Children children = m_refStore-&gt;children();
-	if (children.empty() == false)
-	{
-		TreeModel::Children::iterator iter = children.begin();
-		while (iter != children.end())
-		{
-			// Erase this row
-			m_refStore-&gt;erase(*iter);
-
-			// Get the new first row
-			children = m_refStore-&gt;children();
-			iter = children.begin();
-		}
-		m_refStore-&gt;clear();
-	}
-}
-
-//
-// Returns the double-click signal.
-//
-sigc::signal2&lt;void, string, string&gt;&amp; EnginesTree::getDoubleClickSignal(void)
-{
-	return m_signalDoubleClick;
-}

Deleted: trunk/UI/GTK2/src/EnginesTree.h
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.h	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/EnginesTree.h	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,95 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _ENGINESTREE_HH
-#define _ENGINESTREE_HH
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;set&gt;
-#include &lt;map&gt;
-#include &lt;sigc++/sigc++.h&gt;
-#include &lt;glibmm/refptr.h&gt;
-#include &lt;glibmm/ustring.h&gt;
-#include &lt;gdkmm/pixbuf.h&gt;
-#include &lt;gtkmm/box.h&gt;
-#include &lt;gtkmm/button.h&gt;
-#include &lt;gtkmm/menu.h&gt;
-#include &lt;gtkmm/scrolledwindow.h&gt;
-#include &lt;gtkmm/textview.h&gt;
-#include &lt;gtkmm/treestore.h&gt;
-#include &lt;gtkmm/treeview.h&gt;
-#include &lt;gtkmm/treeselection.h&gt;
-
-#include &quot;QueryProperties.h&quot;
-#include &quot;ModelColumns.h&quot;
-#include &quot;PinotSettings.h&quot;
-
-class EnginesTree : public Gtk::TreeView
-{
-	public:
-		EnginesTree(Gtk::VBox *enginesVbox, PinotSettings &amp;settings);
-		virtual ~EnginesTree();
-
-		/// Gets a list of selected items.
-		std::list&lt;Gtk::TreeModel::Path&gt; getSelection(void);
-
-		/// Gets an iterator.
-		Gtk::TreeModel::iterator getIter(Gtk::TreeModel::Path enginePath);
-
-		/// Gets the column record.
-		EnginesModelColumns &amp;getColumnRecord(void);
-
-		/// Populate the tree.
-		void populate(bool indexesOnly = false);
-
-		/// Clear the tree.
-		void clear(void);
-
-		/// Save the tree's state.
-		void save(void);
-
-		/// Returns the double-click signal.
-		sigc::signal2&lt;void, std::string, std::string&gt;&amp; getDoubleClickSignal(void);
-
-	protected:
-		Glib::RefPtr&lt;Gtk::TreeStore&gt; m_refStore;
-		PinotSettings &amp;m_settings;
-		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_engineFolderIconPixbuf;
-		EnginesModelColumns m_enginesColumns;
-		sigc::signal2&lt;void, std::string, std::string&gt; m_signalDoubleClick;
-
-		void renderEngineIcon(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &amp;iter);
-
-		/// Handles button presses.
-		void onButtonPressEvent(GdkEventButton *ev);
-
-		/// Handles attempts to select rows.
-		bool onSelectionSelect(const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,
-			const Gtk::TreeModel::Path&amp; node_path, bool path_currently_selected);
-
-		/// Handles GTK style changes.
-		void onStyleChanged(const Glib::RefPtr&lt;Gtk::Style&gt; &amp;previous_style);
-
-	private:
-		EnginesTree(const EnginesTree &amp;other);
-		EnginesTree &amp;operator=(const EnginesTree &amp;other);
-
-};
-
-#endif // _ENGINESTREE_HH

Copied: trunk/UI/GTK2/src/EnginesTree.hh (from rev 1529, trunk/UI/GTK2/src/EnginesTree.h)
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/EnginesTree.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,95 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _ENGINESTREE_HH
+#define _ENGINESTREE_HH
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;set&gt;
+#include &lt;map&gt;
+#include &lt;sigc++/sigc++.h&gt;
+#include &lt;glibmm/refptr.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gdkmm/pixbuf.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/menu.h&gt;
+#include &lt;gtkmm/scrolledwindow.h&gt;
+#include &lt;gtkmm/textview.h&gt;
+#include &lt;gtkmm/treestore.h&gt;
+#include &lt;gtkmm/treeview.h&gt;
+#include &lt;gtkmm/treeselection.h&gt;
+
+#include &quot;QueryProperties.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;ModelColumns.hh&quot;
+
+class EnginesTree : public Gtk::TreeView
+{
+	public:
+		EnginesTree(Gtk::VBox *enginesVbox, PinotSettings &amp;settings);
+		virtual ~EnginesTree();
+
+		/// Gets a list of selected items.
+		std::list&lt;Gtk::TreeModel::Path&gt; getSelection(void);
+
+		/// Gets an iterator.
+		Gtk::TreeModel::iterator getIter(Gtk::TreeModel::Path enginePath);
+
+		/// Gets the column record.
+		EnginesModelColumns &amp;getColumnRecord(void);
+
+		/// Populate the tree.
+		void populate(bool indexesOnly = false);
+
+		/// Clear the tree.
+		void clear(void);
+
+		/// Save the tree's state.
+		void save(void);
+
+		/// Returns the double-click signal.
+		sigc::signal2&lt;void, std::string, std::string&gt;&amp; getDoubleClickSignal(void);
+
+	protected:
+		Glib::RefPtr&lt;Gtk::TreeStore&gt; m_refStore;
+		PinotSettings &amp;m_settings;
+		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_engineFolderIconPixbuf;
+		EnginesModelColumns m_enginesColumns;
+		sigc::signal2&lt;void, std::string, std::string&gt; m_signalDoubleClick;
+
+		void renderEngineIcon(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &amp;iter);
+
+		/// Handles button presses.
+		void onButtonPressEvent(GdkEventButton *ev);
+
+		/// Handles attempts to select rows.
+		bool onSelectionSelect(const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,
+			const Gtk::TreeModel::Path&amp; node_path, bool path_currently_selected);
+
+		/// Handles GTK style changes.
+		void onStyleChanged(const Glib::RefPtr&lt;Gtk::Style&gt; &amp;previous_style);
+
+	private:
+		EnginesTree(const EnginesTree &amp;other);
+		EnginesTree &amp;operator=(const EnginesTree &amp;other);
+
+};
+
+#endif // _ENGINESTREE_HH


Property changes on: trunk/UI/GTK2/src/EnginesTree.hh
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/UI/GTK2/src/IndexPage.cc (from rev 1529, trunk/UI/GTK2/src/IndexPage.cpp)
===================================================================
--- trunk/UI/GTK2/src/IndexPage.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/IndexPage.cc	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,286 @@
+/*
+ *  Copyright 2005,2006 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+#include &lt;gtkmm/alignment.h&gt;
+#include &lt;gtkmm/buttonbox.h&gt;
+#include &lt;gtkmm/stock.h&gt;
+#include &lt;gtkmm/textbuffer.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;IndexPage.hh&quot;
+
+using namespace std;
+using namespace Glib;
+using namespace Gtk;
+
+IndexPage::IndexPage(const ustring &amp;indexName, ResultsTree *pTree,
+	PinotSettings &amp;settings) :
+	NotebookPageBox(indexName, NotebookPageBox::INDEX_PAGE, settings),
+	m_pQueryCombobox(NULL),
+	m_pBackButton(NULL),
+	m_pForwardButton(NULL),
+	m_docsCount(0),
+	m_firstDoc(0)
+{
+	m_pTree = pTree;
+	m_pQueryCombobox = manage(new ComboBoxText());
+
+	Image *image521 = manage(new Image(StockID(&quot;gtk-media-rewind&quot;), IconSize(4)));
+	Label *label52 = manage(new Label(_(&quot;Show Previous&quot;)));
+	HBox *hbox45 = manage(new HBox(false, 2));
+	Alignment *alignment31 = manage(new Alignment(0.5, 0.5, 0, 0));
+	m_pBackButton = manage(new Button());
+
+	Image *image522 = manage(new Image(StockID(&quot;gtk-media-forward&quot;), IconSize(4)));
+	Label *label53 = manage(new Label(_(&quot;Show Next&quot;)));
+	HBox *hbox46 = manage(new HBox(false, 2));
+	Alignment *alignment32 = manage(new Alignment(0.5, 0.5, 0, 0));
+	m_pForwardButton = manage(new Button());
+
+	HButtonBox *indexHbuttonbox = manage(new HButtonBox(BUTTONBOX_START, 0));
+	HBox *indexButtonsHbox = manage(new HBox(false, 0));
+
+	// Buttons
+	image521-&gt;set_alignment(0.5,0.5);
+	image521-&gt;set_padding(0,0);
+	label52-&gt;set_alignment(0.5,0.5);
+	label52-&gt;set_padding(0,0);
+	label52-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+	label52-&gt;set_line_wrap(false);
+	label52-&gt;set_use_markup(false);
+	label52-&gt;set_selectable(false);
+	hbox45-&gt;pack_start(*image521, Gtk::PACK_SHRINK, 0);
+	hbox45-&gt;pack_start(*label52, Gtk::PACK_SHRINK, 0);
+	alignment31-&gt;add(*hbox45);
+	m_pBackButton-&gt;set_flags(Gtk::CAN_FOCUS);
+	m_pBackButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+	m_pBackButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+	m_pBackButton-&gt;add(*alignment31);
+	image522-&gt;set_alignment(0.5,0.5);
+	image522-&gt;set_padding(0,0);
+	label53-&gt;set_alignment(0.5,0.5);
+	label53-&gt;set_padding(0,0);
+	label53-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+	label53-&gt;set_line_wrap(false);
+	label53-&gt;set_use_markup(false);
+	label53-&gt;set_selectable(false);
+	hbox46-&gt;pack_start(*image522, Gtk::PACK_SHRINK, 0);
+	hbox46-&gt;pack_start(*label53, Gtk::PACK_SHRINK, 0);
+	alignment32-&gt;add(*hbox46);
+	m_pForwardButton-&gt;set_flags(Gtk::CAN_FOCUS);
+	m_pForwardButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+	m_pForwardButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+	m_pForwardButton-&gt;add(*alignment32);
+
+	// Position everything
+	indexHbuttonbox-&gt;pack_start(*m_pBackButton);
+	indexHbuttonbox-&gt;pack_start(*m_pForwardButton);
+	indexButtonsHbox-&gt;pack_start(*m_pQueryCombobox, Gtk::PACK_SHRINK, 4);
+	indexButtonsHbox-&gt;pack_start(*indexHbuttonbox, Gtk::PACK_EXPAND_WIDGET, 4);
+	pack_start(*indexButtonsHbox, Gtk::PACK_SHRINK, 4);
+	if (pTree != NULL)
+	{
+		pack_start(*pTree-&gt;getResultsScrolledWindow());
+	}
+
+	// Populate
+	populateQueryCombobox(&quot;&quot;);
+
+	// Connect the signals
+	m_pBackButton-&gt;signal_clicked().connect(
+		sigc::mem_fun(*this, &amp;IndexPage::onBackClicked));
+	m_pForwardButton-&gt;signal_clicked().connect(
+		sigc::mem_fun(*this, &amp;IndexPage::onForwardClicked));
+
+	// Disable the buttons until something is being shown
+	m_pBackButton-&gt;set_sensitive(false);
+	m_pForwardButton-&gt;set_sensitive(false);
+
+	// Show all
+	m_pQueryCombobox-&gt;show();
+	image521-&gt;show();
+	label52-&gt;show();
+	hbox45-&gt;show();
+	alignment31-&gt;show();
+	m_pBackButton-&gt;show();
+	image522-&gt;show();
+	label53-&gt;show();
+	hbox46-&gt;show();
+	alignment32-&gt;show();
+	m_pForwardButton-&gt;show();
+	indexHbuttonbox-&gt;show();
+	indexButtonsHbox-&gt;show();
+	show();
+}
+
+IndexPage::~IndexPage()
+{
+}
+
+void IndexPage::onQueryChanged(void)
+{
+	m_queryName = m_pQueryCombobox-&gt;get_active_text();
+	if (m_pQueryCombobox-&gt;get_active_row_number() == 0)
+	{
+		m_queryName.clear();
+	}
+	m_signalQueryChanged(m_title, m_queryName);
+}
+
+void IndexPage::onBackClicked(void)
+{
+	m_signalBackClicked(m_title);
+}
+
+void IndexPage::onForwardClicked(void)
+{
+	m_signalForwardClicked(m_title);
+}
+
+//
+// Returns the name of the current query.
+//
+ustring IndexPage::getQueryName(void) const
+{
+	return m_queryName;
+}
+
+//
+// Populates the queries list.
+//
+void IndexPage::populateQueryCombobox(const string &amp;queryName)
+{
+	// Disconnect the changed signal
+	if (m_queryChangedConnection.connected() == true)
+	{
+		m_queryChangedConnection.disconnect();
+	}
+
+	m_pQueryCombobox-&gt;clear_items();
+
+	m_pQueryCombobox-&gt;append_text(_(&quot;All&quot;));
+
+	const std::map&lt;string, QueryProperties&gt; &amp;queries = m_settings.getQueries();
+	for (std::map&lt;string, QueryProperties&gt;::const_iterator queryIter = queries.begin();
+		queryIter != queries.end(); ++queryIter)
+	{
+		m_pQueryCombobox-&gt;append_text(to_utf8(queryIter-&gt;first));
+	}
+
+	// Reconnect the signal
+	m_queryChangedConnection = m_pQueryCombobox-&gt;signal_changed().connect(
+		sigc::mem_fun(*this, &amp;IndexPage::onQueryChanged));
+
+	if (queryName.empty() == false)
+	{
+		m_pQueryCombobox-&gt;set_active_text(queryName);
+		m_queryName = queryName;
+	}
+	else
+	{
+		m_pQueryCombobox-&gt;set_active(0);
+		m_queryName.clear();
+	}
+}
+
+//
+// Updates the state of the index buttons.
+//
+void IndexPage::updateButtonsState(unsigned int maxDocsCount)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;IndexPage::updateButtonsState: counts &quot; &lt;&lt; m_firstDoc
+		&lt;&lt; &quot; &quot; &lt;&lt; m_docsCount &lt;&lt; endl;
+#endif
+	if (m_firstDoc &gt;= maxDocsCount)
+	{
+		m_pBackButton-&gt;set_sensitive(true);
+	}
+	else
+	{
+		m_pBackButton-&gt;set_sensitive(false);
+	}
+	if (m_docsCount &gt; m_firstDoc + maxDocsCount)
+	{
+		m_pForwardButton-&gt;set_sensitive(true);
+	}
+	else
+	{
+		m_pForwardButton-&gt;set_sensitive(false);
+	}
+}
+
+//
+// Gets the number of documents.
+//
+unsigned int IndexPage::getDocumentsCount(void) const
+{
+	return m_docsCount;
+}
+
+//
+// Sets the number of documents.
+//
+void IndexPage::setDocumentsCount(unsigned int docsCount)
+{
+	m_docsCount = docsCount;
+}
+
+//
+// Gets the first document.
+//
+unsigned int IndexPage::getFirstDocument(void) const
+{
+	return m_firstDoc;
+}
+
+//
+// Sets the first document.
+//
+void IndexPage::setFirstDocument(unsigned int startDoc)
+{
+	m_firstDoc = startDoc;
+}
+
+//
+// Returns the changed query signal.
+//
+sigc::signal2&lt;void, ustring, ustring&gt;&amp; IndexPage::getQueryChangedSignal(void)
+{
+	return m_signalQueryChanged;
+}
+
+//
+// Returns the back button clicked signal.
+//
+sigc::signal1&lt;void, ustring&gt;&amp; IndexPage::getBackClickedSignal(void)
+{
+	return m_signalBackClicked;
+}
+
+//
+// Returns the forward button clicked signal.
+//
+sigc::signal1&lt;void, ustring&gt;&amp; IndexPage::getForwardClickedSignal(void)
+{
+	return m_signalForwardClicked;
+}


Property changes on: trunk/UI/GTK2/src/IndexPage.cc
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: trunk/UI/GTK2/src/IndexPage.cpp
===================================================================
--- trunk/UI/GTK2/src/IndexPage.cpp	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/IndexPage.cpp	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,286 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;iostream&gt;
-#include &lt;gtkmm/alignment.h&gt;
-#include &lt;gtkmm/buttonbox.h&gt;
-#include &lt;gtkmm/stock.h&gt;
-#include &lt;gtkmm/textbuffer.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;NLS.h&quot;
-#include &quot;PinotSettings.h&quot;
-#include &quot;PinotUtils.h&quot;
-#include &quot;IndexPage.h&quot;
-
-using namespace std;
-using namespace Glib;
-using namespace Gtk;
-
-IndexPage::IndexPage(const ustring &amp;indexName, ResultsTree *pTree,
-	PinotSettings &amp;settings) :
-	NotebookPageBox(indexName, NotebookPageBox::INDEX_PAGE, settings),
-	m_pQueryCombobox(NULL),
-	m_pBackButton(NULL),
-	m_pForwardButton(NULL),
-	m_docsCount(0),
-	m_firstDoc(0)
-{
-	m_pTree = pTree;
-	m_pQueryCombobox = manage(new ComboBoxText());
-
-	Image *image521 = manage(new Image(StockID(&quot;gtk-media-rewind&quot;), IconSize(4)));
-	Label *label52 = manage(new Label(_(&quot;Show Previous&quot;)));
-	HBox *hbox45 = manage(new HBox(false, 2));
-	Alignment *alignment31 = manage(new Alignment(0.5, 0.5, 0, 0));
-	m_pBackButton = manage(new Button());
-
-	Image *image522 = manage(new Image(StockID(&quot;gtk-media-forward&quot;), IconSize(4)));
-	Label *label53 = manage(new Label(_(&quot;Show Next&quot;)));
-	HBox *hbox46 = manage(new HBox(false, 2));
-	Alignment *alignment32 = manage(new Alignment(0.5, 0.5, 0, 0));
-	m_pForwardButton = manage(new Button());
-
-	HButtonBox *indexHbuttonbox = manage(new HButtonBox(BUTTONBOX_START, 0));
-	HBox *indexButtonsHbox = manage(new HBox(false, 0));
-
-	// Buttons
-	image521-&gt;set_alignment(0.5,0.5);
-	image521-&gt;set_padding(0,0);
-	label52-&gt;set_alignment(0.5,0.5);
-	label52-&gt;set_padding(0,0);
-	label52-&gt;set_justify(Gtk::JUSTIFY_LEFT);
-	label52-&gt;set_line_wrap(false);
-	label52-&gt;set_use_markup(false);
-	label52-&gt;set_selectable(false);
-	hbox45-&gt;pack_start(*image521, Gtk::PACK_SHRINK, 0);
-	hbox45-&gt;pack_start(*label52, Gtk::PACK_SHRINK, 0);
-	alignment31-&gt;add(*hbox45);
-	m_pBackButton-&gt;set_flags(Gtk::CAN_FOCUS);
-	m_pBackButton-&gt;set_flags(Gtk::CAN_DEFAULT);
-	m_pBackButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
-	m_pBackButton-&gt;add(*alignment31);
-	image522-&gt;set_alignment(0.5,0.5);
-	image522-&gt;set_padding(0,0);
-	label53-&gt;set_alignment(0.5,0.5);
-	label53-&gt;set_padding(0,0);
-	label53-&gt;set_justify(Gtk::JUSTIFY_LEFT);
-	label53-&gt;set_line_wrap(false);
-	label53-&gt;set_use_markup(false);
-	label53-&gt;set_selectable(false);
-	hbox46-&gt;pack_start(*image522, Gtk::PACK_SHRINK, 0);
-	hbox46-&gt;pack_start(*label53, Gtk::PACK_SHRINK, 0);
-	alignment32-&gt;add(*hbox46);
-	m_pForwardButton-&gt;set_flags(Gtk::CAN_FOCUS);
-	m_pForwardButton-&gt;set_flags(Gtk::CAN_DEFAULT);
-	m_pForwardButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
-	m_pForwardButton-&gt;add(*alignment32);
-
-	// Position everything
-	indexHbuttonbox-&gt;pack_start(*m_pBackButton);
-	indexHbuttonbox-&gt;pack_start(*m_pForwardButton);
-	indexButtonsHbox-&gt;pack_start(*m_pQueryCombobox, Gtk::PACK_SHRINK, 4);
-	indexButtonsHbox-&gt;pack_start(*indexHbuttonbox, Gtk::PACK_EXPAND_WIDGET, 4);
-	pack_start(*indexButtonsHbox, Gtk::PACK_SHRINK, 4);
-	if (pTree != NULL)
-	{
-		pack_start(*pTree-&gt;getResultsScrolledWindow());
-	}
-
-	// Populate
-	populateQueryCombobox(&quot;&quot;);
-
-	// Connect the signals
-	m_pBackButton-&gt;signal_clicked().connect(
-		sigc::mem_fun(*this, &amp;IndexPage::onBackClicked));
-	m_pForwardButton-&gt;signal_clicked().connect(
-		sigc::mem_fun(*this, &amp;IndexPage::onForwardClicked));
-
-	// Disable the buttons until something is being shown
-	m_pBackButton-&gt;set_sensitive(false);
-	m_pForwardButton-&gt;set_sensitive(false);
-
-	// Show all
-	m_pQueryCombobox-&gt;show();
-	image521-&gt;show();
-	label52-&gt;show();
-	hbox45-&gt;show();
-	alignment31-&gt;show();
-	m_pBackButton-&gt;show();
-	image522-&gt;show();
-	label53-&gt;show();
-	hbox46-&gt;show();
-	alignment32-&gt;show();
-	m_pForwardButton-&gt;show();
-	indexHbuttonbox-&gt;show();
-	indexButtonsHbox-&gt;show();
-	show();
-}
-
-IndexPage::~IndexPage()
-{
-}
-
-void IndexPage::onQueryChanged(void)
-{
-	m_queryName = m_pQueryCombobox-&gt;get_active_text();
-	if (m_pQueryCombobox-&gt;get_active_row_number() == 0)
-	{
-		m_queryName.clear();
-	}
-	m_signalQueryChanged(m_title, m_queryName);
-}
-
-void IndexPage::onBackClicked(void)
-{
-	m_signalBackClicked(m_title);
-}
-
-void IndexPage::onForwardClicked(void)
-{
-	m_signalForwardClicked(m_title);
-}
-
-//
-// Returns the name of the current query.
-//
-ustring IndexPage::getQueryName(void) const
-{
-	return m_queryName;
-}
-
-//
-// Populates the queries list.
-//
-void IndexPage::populateQueryCombobox(const string &amp;queryName)
-{
-	// Disconnect the changed signal
-	if (m_queryChangedConnection.connected() == true)
-	{
-		m_queryChangedConnection.disconnect();
-	}
-
-	m_pQueryCombobox-&gt;clear_items();
-
-	m_pQueryCombobox-&gt;append_text(_(&quot;All&quot;));
-
-	const std::map&lt;string, QueryProperties&gt; &amp;queries = m_settings.getQueries();
-	for (std::map&lt;string, QueryProperties&gt;::const_iterator queryIter = queries.begin();
-		queryIter != queries.end(); ++queryIter)
-	{
-		m_pQueryCombobox-&gt;append_text(to_utf8(queryIter-&gt;first));
-	}
-
-	// Reconnect the signal
-	m_queryChangedConnection = m_pQueryCombobox-&gt;signal_changed().connect(
-		sigc::mem_fun(*this, &amp;IndexPage::onQueryChanged));
-
-	if (queryName.empty() == false)
-	{
-		m_pQueryCombobox-&gt;set_active_text(queryName);
-		m_queryName = queryName;
-	}
-	else
-	{
-		m_pQueryCombobox-&gt;set_active(0);
-		m_queryName.clear();
-	}
-}
-
-//
-// Updates the state of the index buttons.
-//
-void IndexPage::updateButtonsState(unsigned int maxDocsCount)
-{
-#ifdef DEBUG
-	cout &lt;&lt; &quot;IndexPage::updateButtonsState: counts &quot; &lt;&lt; m_firstDoc
-		&lt;&lt; &quot; &quot; &lt;&lt; m_docsCount &lt;&lt; endl;
-#endif
-	if (m_firstDoc &gt;= maxDocsCount)
-	{
-		m_pBackButton-&gt;set_sensitive(true);
-	}
-	else
-	{
-		m_pBackButton-&gt;set_sensitive(false);
-	}
-	if (m_docsCount &gt; m_firstDoc + maxDocsCount)
-	{
-		m_pForwardButton-&gt;set_sensitive(true);
-	}
-	else
-	{
-		m_pForwardButton-&gt;set_sensitive(false);
-	}
-}
-
-//
-// Gets the number of documents.
-//
-unsigned int IndexPage::getDocumentsCount(void) const
-{
-	return m_docsCount;
-}
-
-//
-// Sets the number of documents.
-//
-void IndexPage::setDocumentsCount(unsigned int docsCount)
-{
-	m_docsCount = docsCount;
-}
-
-//
-// Gets the first document.
-//
-unsigned int IndexPage::getFirstDocument(void) const
-{
-	return m_firstDoc;
-}
-
-//
-// Sets the first document.
-//
-void IndexPage::setFirstDocument(unsigned int startDoc)
-{
-	m_firstDoc = startDoc;
-}
-
-//
-// Returns the changed query signal.
-//
-sigc::signal2&lt;void, ustring, ustring&gt;&amp; IndexPage::getQueryChangedSignal(void)
-{
-	return m_signalQueryChanged;
-}
-
-//
-// Returns the back button clicked signal.
-//
-sigc::signal1&lt;void, ustring&gt;&amp; IndexPage::getBackClickedSignal(void)
-{
-	return m_signalBackClicked;
-}
-
-//
-// Returns the forward button clicked signal.
-//
-sigc::signal1&lt;void, ustring&gt;&amp; IndexPage::getForwardClickedSignal(void)
-{
-	return m_signalForwardClicked;
-}

Deleted: trunk/UI/GTK2/src/IndexPage.h
===================================================================
--- trunk/UI/GTK2/src/IndexPage.h	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/IndexPage.h	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,103 +0,0 @@
-/*
- *  Copyright 2005,2006 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _INDEXPAGE_HH
-#define _INDEXPAGE_HH
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;sigc++/sigc++.h&gt;
-#include &lt;glibmm/refptr.h&gt;
-#include &lt;glibmm/ustring.h&gt;
-#include &lt;gtkmm/menu.h&gt;
-#include &lt;gdkmm/pixbuf.h&gt;
-#include &lt;gtkmm/comboboxtext.h&gt;
-#include &lt;gtkmm/button.h&gt;
-#include &lt;gtkmm/scrolledwindow.h&gt;
-#include &lt;gtkmm/textview.h&gt;
-#include &lt;gtkmm/treeview.h&gt;
-#include &lt;gtkmm/treeselection.h&gt;
-
-#include &quot;QueryProperties.h&quot;
-#include &quot;ResultsTree.h&quot;
-#include &quot;Notebook.h&quot;
-#include &quot;PinotSettings.h&quot;
-
-class IndexPage : public NotebookPageBox
-{
-	public:
-		IndexPage(const Glib::ustring &amp;indexName, ResultsTree *pTree,
-			PinotSettings &amp;settings);
-		virtual ~IndexPage();
-
-		/// Returns the name of the current query.
-		Glib::ustring getQueryName(void) const;
-
-		/// Populates the queries list.
-		void populateQueryCombobox(const std::string &amp;queryName);
-
-		/// Updates the state of the index buttons.
-		void updateButtonsState(unsigned int maxDocsCount);
-
-		/// Gets the number of documents.
-		unsigned int getDocumentsCount(void) const;
-
-		/// Sets the number of documents.
-		void setDocumentsCount(unsigned int docsCount);
-
-		/// Gets the first document.
-		unsigned int getFirstDocument(void) const;
-
-		/// Sets the first document.
-		void setFirstDocument(unsigned int startDoc);
-
-		/// Returns the changed query signal.
-		sigc::signal2&lt;void, Glib::ustring, Glib::ustring&gt;&amp; getQueryChangedSignal(void);
-
-		/// Returns the back button clicked signal.
-		sigc::signal1&lt;void, Glib::ustring&gt;&amp; getBackClickedSignal(void);
-
-		/// Returns the forward button clicked signal.
-		sigc::signal1&lt;void, Glib::ustring&gt;&amp; getForwardClickedSignal(void);
-
-	protected:
-		Glib::ustring m_indexName;
-		Glib::ustring m_queryName;
-		Gtk::ComboBoxText *m_pQueryCombobox;
-		Gtk::Button *m_pBackButton;
-		Gtk::Button *m_pForwardButton;
-		unsigned int m_docsCount;
-		unsigned int m_firstDoc;
-		sigc::signal2&lt;void, Glib::ustring, Glib::ustring&gt; m_signalQueryChanged;
-		sigc::signal1&lt;void, Glib::ustring&gt; m_signalBackClicked;
-		sigc::signal1&lt;void, Glib::ustring&gt; m_signalForwardClicked;
-		sigc::connection m_queryChangedConnection;
-
-		void onQueryChanged(void);
-
-		void onBackClicked(void);
-
-		void onForwardClicked(void);
-
-	private:
-		IndexPage(const IndexPage &amp;other);
-		IndexPage &amp;operator=(const IndexPage &amp;other);
-
-};
-
-#endif // _INDEXPAGE_HH

Copied: trunk/UI/GTK2/src/IndexPage.hh (from rev 1529, trunk/UI/GTK2/src/IndexPage.h)
===================================================================
--- trunk/UI/GTK2/src/IndexPage.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/IndexPage.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,103 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _INDEXPAGE_HH
+#define _INDEXPAGE_HH
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;sigc++/sigc++.h&gt;
+#include &lt;glibmm/refptr.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gtkmm/menu.h&gt;
+#include &lt;gdkmm/pixbuf.h&gt;
+#include &lt;gtkmm/comboboxtext.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/scrolledwindow.h&gt;
+#include &lt;gtkmm/textview.h&gt;
+#include &lt;gtkmm/treeview.h&gt;
+#include &lt;gtkmm/treeselection.h&gt;
+
+#include &quot;QueryProperties.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;ResultsTree.hh&quot;
+#include &quot;Notebook.hh&quot;
+
+class IndexPage : public NotebookPageBox
+{
+	public:
+		IndexPage(const Glib::ustring &amp;indexName, ResultsTree *pTree,
+			PinotSettings &amp;settings);
+		virtual ~IndexPage();
+
+		/// Returns the name of the current query.
+		Glib::ustring getQueryName(void) const;
+
+		/// Populates the queries list.
+		void populateQueryCombobox(const std::string &amp;queryName);
+
+		/// Updates the state of the index buttons.
+		void updateButtonsState(unsigned int maxDocsCount);
+
+		/// Gets the number of documents.
+		unsigned int getDocumentsCount(void) const;
+
+		/// Sets the number of documents.
+		void setDocumentsCount(unsigned int docsCount);
+
+		/// Gets the first document.
+		unsigned int getFirstDocument(void) const;
+
+		/// Sets the first document.
+		void setFirstDocument(unsigned int startDoc);
+
+		/// Returns the changed query signal.
+		sigc::signal2&lt;void, Glib::ustring, Glib::ustring&gt;&amp; getQueryChangedSignal(void);
+
+		/// Returns the back button clicked signal.
+		sigc::signal1&lt;void, Glib::ustring&gt;&amp; getBackClickedSignal(void);
+
+		/// Returns the forward button clicked signal.
+		sigc::signal1&lt;void, Glib::ustring&gt;&amp; getForwardClickedSignal(void);
+
+	protected:
+		Glib::ustring m_indexName;
+		Glib::ustring m_queryName;
+		Gtk::ComboBoxText *m_pQueryCombobox;
+		Gtk::Button *m_pBackButton;
+		Gtk::Button *m_pForwardButton;
+		unsigned int m_docsCount;
+		unsigned int m_firstDoc;
+		sigc::signal2&lt;void, Glib::ustring, Glib::ustring&gt; m_signalQueryChanged;
+		sigc::signal1&lt;void, Glib::ustring&gt; m_signalBackClicked;
+		sigc::signal1&lt;void, Glib::ustring&gt; m_signalForwardClicked;
+		sigc::connection m_queryChangedConnection;
+
+		void onQueryChanged(void);
+
+		void onBackClicked(void);
+
+		void onForwardClicked(void);
+
+	private:
+		IndexPage(const IndexPage &amp;other);
+		IndexPage &amp;operator=(const IndexPage &amp;other);
+
+};
+
+#endif // _INDEXPAGE_HH


Property changes on: trunk/UI/GTK2/src/IndexPage.hh
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: trunk/UI/GTK2/src/Makefile.am
===================================================================
--- trunk/UI/GTK2/src/Makefile.am	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/Makefile.am	2009-02-01 11:47:02 UTC (rev 1531)
@@ -17,11 +17,11 @@
 	queryDialog.hh \
 	statisticsDialog_glade.hh \
 	statisticsDialog.hh \
-	EnginesTree.h \
-	IndexPage.h \
-	ModelColumns.h \
-	Notebook.h \
-	ResultsTree.h
+	EnginesTree.hh \
+	IndexPage.hh \
+	ModelColumns.hh \
+	Notebook.hh \
+	ResultsTree.hh
 
 pinot_SOURCES = \
 	pinot.cc \
@@ -41,11 +41,11 @@
 	queryDialog.cc \
 	statisticsDialog_glade.cc \
 	statisticsDialog.cc \
-	EnginesTree.cpp \
-	IndexPage.cpp \
-	ModelColumns.cpp \
-	Notebook.cpp \
-	ResultsTree.cpp
+	EnginesTree.cc \
+	IndexPage.cc \
+	ModelColumns.cc \
+	Notebook.cc \
+	ResultsTree.cc
 
 bin_PROGRAMS = pinot
 

Copied: trunk/UI/GTK2/src/ModelColumns.cc (from rev 1529, trunk/UI/GTK2/src/ModelColumns.cpp)
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/ModelColumns.cc	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,117 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;ModelColumns.hh&quot;
+
+ComboModelColumns::ComboModelColumns()
+{
+	add(m_name);
+}
+
+ComboModelColumns::~ComboModelColumns()
+{
+}
+
+EnginesModelColumns::EnginesModelColumns()
+{
+	add(m_name);
+	add(m_engineName);
+	add(m_option);
+	add(m_type);
+}
+
+EnginesModelColumns::~EnginesModelColumns()
+{
+}
+
+QueryModelColumns::QueryModelColumns()
+{
+	add(m_name);
+	add(m_lastRun);
+	add(m_lastRunTime);
+	add(m_summary);
+	add(m_properties);
+}
+
+QueryModelColumns::~QueryModelColumns()
+{
+}
+
+ResultsModelColumns::ResultsModelColumns()
+{
+	add(m_text);
+	add(m_url);
+	add(m_indexed);
+	add(m_viewed);
+	add(m_rankDiff);
+	add(m_score);
+	add(m_scoreText);
+	add(m_engines);
+	add(m_indexes);
+	add(m_docId);
+	add(m_resultType);
+	add(m_timestamp);
+	add(m_timestampTime);
+	add(m_serial);
+}
+
+ResultsModelColumns::~ResultsModelColumns()
+{
+}
+
+OtherIndexModelColumns::OtherIndexModelColumns()
+{
+	add(m_name);
+	add(m_location);
+}
+
+OtherIndexModelColumns::~OtherIndexModelColumns()
+{
+}
+
+LabelModelColumns::LabelModelColumns()
+{
+	add(m_enabled);
+	add(m_name);
+}
+
+LabelModelColumns::~LabelModelColumns()
+{
+}
+
+TimestampedModelColumns::TimestampedModelColumns()
+{
+	add(m_location);
+	add(m_mTime);
+}
+
+TimestampedModelColumns::~TimestampedModelColumns()
+{
+}
+
+IndexableModelColumns::IndexableModelColumns()
+{
+	add(m_monitor);
+	add(m_location);
+}
+
+IndexableModelColumns::~IndexableModelColumns()
+{
+}


Property changes on: trunk/UI/GTK2/src/ModelColumns.cc
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: trunk/UI/GTK2/src/ModelColumns.cpp
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.cpp	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/ModelColumns.cpp	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,117 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &quot;config.h&quot;
-#include &quot;NLS.h&quot;
-#include &quot;ModelColumns.h&quot;
-
-ComboModelColumns::ComboModelColumns()
-{
-	add(m_name);
-}
-
-ComboModelColumns::~ComboModelColumns()
-{
-}
-
-EnginesModelColumns::EnginesModelColumns()
-{
-	add(m_name);
-	add(m_engineName);
-	add(m_option);
-	add(m_type);
-}
-
-EnginesModelColumns::~EnginesModelColumns()
-{
-}
-
-QueryModelColumns::QueryModelColumns()
-{
-	add(m_name);
-	add(m_lastRun);
-	add(m_lastRunTime);
-	add(m_summary);
-	add(m_properties);
-}
-
-QueryModelColumns::~QueryModelColumns()
-{
-}
-
-ResultsModelColumns::ResultsModelColumns()
-{
-	add(m_text);
-	add(m_url);
-	add(m_indexed);
-	add(m_viewed);
-	add(m_rankDiff);
-	add(m_score);
-	add(m_scoreText);
-	add(m_engines);
-	add(m_indexes);
-	add(m_docId);
-	add(m_resultType);
-	add(m_timestamp);
-	add(m_timestampTime);
-	add(m_serial);
-}
-
-ResultsModelColumns::~ResultsModelColumns()
-{
-}
-
-OtherIndexModelColumns::OtherIndexModelColumns()
-{
-	add(m_name);
-	add(m_location);
-}
-
-OtherIndexModelColumns::~OtherIndexModelColumns()
-{
-}
-
-LabelModelColumns::LabelModelColumns()
-{
-	add(m_enabled);
-	add(m_name);
-}
-
-LabelModelColumns::~LabelModelColumns()
-{
-}
-
-TimestampedModelColumns::TimestampedModelColumns()
-{
-	add(m_location);
-	add(m_mTime);
-}
-
-TimestampedModelColumns::~TimestampedModelColumns()
-{
-}
-
-IndexableModelColumns::IndexableModelColumns()
-{
-	add(m_monitor);
-	add(m_location);
-}
-
-IndexableModelColumns::~IndexableModelColumns()
-{
-}

Deleted: trunk/UI/GTK2/src/ModelColumns.h
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.h	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/ModelColumns.h	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,149 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _MODELCOLUMNS_HH
-#define _MODELCOLUMNS_HH
-
-#include &lt;time.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;glibmm/refptr.h&gt;
-#include &lt;glibmm/ustring.h&gt;
-#include &lt;gdkmm/event.h&gt;
-#include &lt;gtkmm/treemodel.h&gt;
-#include &lt;gtkmm/treemodelcolumn.h&gt;
-#include &lt;gtkmm/optionmenu.h&gt;
-
-#include &quot;QueryProperties.h&quot;
-
-/// Model column for text combo boxes.
-class ComboModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-	public:
-		ComboModelColumns();
-		virtual ~ComboModelColumns();
-
-		Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_name;
-
-};
-
-/// Main window, model column for the search engines tree.
-class EnginesModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-	public:
-		EnginesModelColumns();
-		virtual ~EnginesModelColumns();
-
-		Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_name;
-		Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_engineName;
-		Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_option;
-		typedef enum { ENGINE_SEPARATOR = 0, ENGINE_FOLDER,
-			WEB_ENGINE, INTERNAL_INDEX_ENGINE, INDEX_ENGINE } EngineType;
-		Gtk::TreeModelColumn&lt;EngineType&gt; m_type;
-
-};
-
-/// Main window, model column for the queries tree.
-class QueryModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-public:
-	QueryModelColumns();
-	virtual ~QueryModelColumns();
-
-	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_name;
-	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_lastRun;
-	Gtk::TreeModelColumn&lt;time_t&gt; m_lastRunTime;
-	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_summary;
-	Gtk::TreeModelColumn&lt;QueryProperties&gt; m_properties;
-
-};
-
-/// Main window, model column for the search results tree.
-class ResultsModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-public:
-	ResultsModelColumns();
-	virtual ~ResultsModelColumns();
-
-	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_text;
-	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_url;
-	Gtk::TreeModelColumn&lt;bool&gt; m_indexed;
-	Gtk::TreeModelColumn&lt;bool&gt; m_viewed;
-	Gtk::TreeModelColumn&lt;int&gt; m_rankDiff;
-	Gtk::TreeModelColumn&lt;int&gt; m_score;
-	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_scoreText;
-	Gtk::TreeModelColumn&lt;unsigned int&gt; m_engines;
-	Gtk::TreeModelColumn&lt;unsigned int&gt; m_indexes;
-	Gtk::TreeModelColumn&lt;unsigned int&gt; m_docId;
-	typedef enum { ROW_ENGINE = 0, ROW_HOST, ROW_RESULT, ROW_OTHER } RowType;
-	Gtk::TreeModelColumn&lt;RowType&gt; m_resultType;
-	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_timestamp;
-	Gtk::TreeModelColumn&lt;time_t&gt; m_timestampTime;
-	Gtk::TreeModelColumn&lt;std::string&gt; m_serial;
-
-};
-
-/// Preferences window, model column for the Xapian indexes tree.
-class OtherIndexModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-public:
-	OtherIndexModelColumns();
-	virtual ~OtherIndexModelColumns();
-
-	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_name;
-	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_location;
-
-};
-
-/// Preferences window, model column for the labels tree.
-/// Export/import window, model column for the labels tree.
-class LabelModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-public:
-	LabelModelColumns();
-	virtual ~LabelModelColumns();
-
-	Gtk::TreeModelColumn&lt;bool&gt; m_enabled;
-	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_name;
-
-};
-
-/// Preferences window, model column for the mail accounts tree.
-class TimestampedModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-public:
-	TimestampedModelColumns();
-	virtual ~TimestampedModelColumns();
-
-	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_location;
-	Gtk::TreeModelColumn&lt;time_t&gt; m_mTime;
-
-};
-
-/// Preferences window, model column for the directories tree.
-class IndexableModelColumns : public Gtk::TreeModel::ColumnRecord
-{
-public:
-	IndexableModelColumns();
-	virtual ~IndexableModelColumns();
-
-	Gtk::TreeModelColumn&lt;bool&gt; m_monitor;
-	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_location;
-
-};
-
-#endif // _MODELCOLUMNS_HH

Copied: trunk/UI/GTK2/src/ModelColumns.hh (from rev 1529, trunk/UI/GTK2/src/ModelColumns.h)


Property changes on: trunk/UI/GTK2/src/ModelColumns.hh
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/UI/GTK2/src/Notebook.cc (from rev 1529, trunk/UI/GTK2/src/Notebook.cpp)
===================================================================
--- trunk/UI/GTK2/src/Notebook.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/Notebook.cc	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,267 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+#include &lt;gtkmm/rc.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;Notebook.hh&quot;
+
+using namespace std;
+using namespace Glib;
+using namespace Gtk;
+
+NotebookPageBox::NotebookPageBox(const ustring &amp;title, NotebookPageBox::PageType type,
+	PinotSettings &amp;settings) :
+	VBox(),
+	m_title(title),
+	m_type(type),
+	m_settings(settings),
+	m_pTree(NULL)
+{
+}
+
+NotebookPageBox::~NotebookPageBox()
+{
+}
+
+//
+// Returns the page title.
+//
+ustring NotebookPageBox::getTitle(void) const
+{
+	return m_title;
+}
+
+//
+// Returns the page type.
+//
+NotebookPageBox::PageType NotebookPageBox::getType(void) const
+{
+	return m_type;
+}
+
+//
+// Returns the page's tree.
+//
+ResultsTree *NotebookPageBox::getTree(void) const
+{
+	return m_pTree;
+}
+
+ResultsPage::ResultsPage(const ustring &amp;queryName, ResultsTree *pTree,
+	int parentHeight, PinotSettings &amp;settings) :
+	NotebookPageBox(queryName, NotebookPageBox::RESULTS_PAGE, settings),
+	m_pLabel(NULL),
+	m_pCombobox(NULL),
+	m_pYesButton(NULL),
+	m_pCloseImage(NULL),
+	m_pCloseButton(NULL),
+	m_pHBox(NULL),
+	m_pVBox(NULL),
+	m_pVPaned(NULL)
+{
+	if (pTree != NULL)
+	{
+		m_pTree = pTree;
+		m_pLabel = manage(new Label(_(&quot;Did you mean ?&quot;)));
+		m_pCombobox = manage(new ComboBoxText());
+		m_pYesButton = manage(new Button(StockID(&quot;gtk-yes&quot;)));
+		m_pCloseImage = manage(new Image(StockID(&quot;gtk-close&quot;), IconSize(ICON_SIZE_MENU)));
+		m_pCloseButton = manage(new Button());
+
+		m_pCloseImage-&gt;set_alignment(0, 0);
+		m_pCloseImage-&gt;set_padding(0, 0);
+		m_pCloseButton-&gt;set_relief(RELIEF_NONE);
+		m_pCloseButton-&gt;set_border_width(0);
+		m_pCloseButton-&gt;set_name(&quot;pinot-tab-close-button&quot;);
+		m_pCloseButton-&gt;set_tooltip_text(_(&quot;Close&quot;));
+		m_pCloseButton-&gt;set_alignment(0, 0);
+		m_pCloseButton-&gt;add(*m_pCloseImage);
+		m_pHBox = manage(new HBox(false, 0));
+		m_pHBox-&gt;pack_start(*m_pLabel, Gtk::PACK_SHRINK, 4);
+		m_pHBox-&gt;pack_start(*m_pCombobox, Gtk::PACK_EXPAND_WIDGET, 4);
+		m_pHBox-&gt;pack_start(*m_pYesButton, Gtk::PACK_SHRINK, 4);
+		m_pHBox-&gt;pack_start(*m_pCloseButton, Gtk::PACK_SHRINK, 4);
+
+		m_pVBox = manage(new VBox(false, 0));
+		m_pVBox-&gt;pack_start(*m_pHBox, Gtk::PACK_SHRINK);
+		m_pVBox-&gt;pack_start(*pTree-&gt;getResultsScrolledWindow());
+
+		m_pVPaned = manage(new VPaned());
+		m_pVPaned-&gt;set_flags(Gtk::CAN_FOCUS);
+		m_pVPaned-&gt;set_position(105);
+		m_pVPaned-&gt;pack1(*m_pVBox, Gtk::EXPAND|Gtk::SHRINK);
+		m_pVPaned-&gt;pack2(*pTree-&gt;getExtractScrolledWindow(), Gtk::SHRINK);
+		pack_start(*m_pVPaned, Gtk::PACK_EXPAND_WIDGET);
+
+		// Give the extract 2/10th of the height
+		m_pVPaned-&gt;set_position((parentHeight * 8) / 10);
+
+		// Hide suggestions by default
+		onCloseButtonClicked();
+		m_pVBox-&gt;show();
+		m_pVPaned-&gt;show();
+
+		m_pYesButton-&gt;signal_clicked().connect(
+			sigc::mem_fun(*this, &amp;ResultsPage::onYesButtonClicked), false);
+		m_pCloseButton-&gt;signal_clicked().connect(
+			sigc::mem_fun(*this, &amp;ResultsPage::onCloseButtonClicked), false);
+	}
+
+	show();
+}
+
+ResultsPage::~ResultsPage()
+{
+}
+
+void ResultsPage::onYesButtonClicked()
+{
+	if (m_pCombobox == NULL)
+	{
+		return;
+	}
+
+	m_signalSuggest(m_title, m_pCombobox-&gt;get_active_text());
+}
+
+void ResultsPage::onCloseButtonClicked()
+{
+	// Just hide these
+	m_pLabel-&gt;hide();
+	m_pCombobox-&gt;hide();
+	m_pYesButton-&gt;hide();
+	m_pCloseImage-&gt;hide();
+	m_pCloseButton-&gt;hide();
+	m_pHBox-&gt;hide();
+}
+
+// Returns the suggest signal.
+sigc::signal2&lt;void, ustring, ustring&gt;&amp; ResultsPage::getSuggestSignal(void)
+{
+	return m_signalSuggest;
+}
+
+//
+// Append a suggestion.
+//
+void ResultsPage::appendSuggestion(const ustring &amp;text)
+{
+	if ((text.empty() == false) &amp;&amp;
+		(m_suggestions.find(text) == m_suggestions.end()))
+	{
+		ustring activeText(m_pCombobox-&gt;get_active_text());
+
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsPage::appendSuggestion: suggesting &quot; &lt;&lt; text &lt;&lt; endl;
+#endif
+		m_suggestions.insert(text);
+		m_pCombobox-&gt;prepend_text(text);
+		if (activeText.empty() == true)
+		{
+			m_pCombobox-&gt;set_active(0);
+		}
+		else
+		{
+			m_pCombobox-&gt;set_active_text(activeText);
+		}
+	}
+
+	m_pLabel-&gt;show();
+	m_pCombobox-&gt;show();
+	m_pYesButton-&gt;show();
+	m_pCloseImage-&gt;show();
+	m_pCloseButton-&gt;show();
+	m_pHBox-&gt;show();
+}
+
+bool NotebookTabBox::m_initialized = false;
+
+NotebookTabBox::NotebookTabBox(const Glib::ustring &amp;title, NotebookPageBox::PageType type) :
+	HBox(),
+	m_title(title),
+	m_pageType(type),
+	m_pTabLabel(NULL),
+	m_pTabImage(NULL),
+	m_pTabButton(NULL)
+{
+	if (m_initialized == false)
+	{
+		m_initialized = true;
+
+		// This was lifted from gnome-terminal's terminal-window.c
+		RC::parse_string(&quot;style \&quot;pinot-tab-close-button-style\&quot;\n&quot;
+			&quot;{\n&quot;
+			&quot;GtkWidget::focus-padding = 0\n&quot;
+			&quot;GtkWidget::focus-line-width = 0\n&quot;
+			&quot;xthickness = 0\n&quot;
+			&quot;ythickness = 0\n&quot;
+			&quot;}\n&quot;
+			&quot;widget \&quot;*.pinot-tab-close-button\&quot; style \&quot;pinot-tab-close-button-style\&quot;&quot;);
+	}
+
+	m_pTabLabel = manage(new Label(title));
+	m_pTabImage = manage(new Image(StockID(&quot;gtk-close&quot;), IconSize(ICON_SIZE_MENU)));
+	m_pTabButton = manage(new Button());
+
+	m_pTabLabel-&gt;set_alignment(0, 0.5);
+	m_pTabLabel-&gt;set_padding(0, 0);
+	m_pTabLabel-&gt;set_justify(JUSTIFY_LEFT);
+	m_pTabLabel-&gt;set_line_wrap(false);
+	m_pTabLabel-&gt;set_use_markup(false);
+	m_pTabLabel-&gt;set_selectable(false);
+	m_pTabImage-&gt;set_alignment(0, 0);
+	m_pTabImage-&gt;set_padding(0, 0);
+	m_pTabButton-&gt;set_relief(RELIEF_NONE);
+	m_pTabButton-&gt;set_border_width(0);
+	m_pTabButton-&gt;set_name(&quot;pinot-tab-close-button&quot;);
+	m_pTabButton-&gt;set_tooltip_text(_(&quot;Close&quot;));
+	m_pTabButton-&gt;set_alignment(0, 0);
+	m_pTabButton-&gt;add(*m_pTabImage);
+	pack_start(*m_pTabLabel);
+	pack_start(*m_pTabButton, PACK_SHRINK);
+	set_spacing(0);
+	set_homogeneous(false);
+	m_pTabLabel-&gt;show();
+	m_pTabImage-&gt;show();
+	m_pTabButton-&gt;show();
+	show();
+
+	m_pTabButton-&gt;signal_clicked().connect(
+		sigc::mem_fun(*this, &amp;NotebookTabBox::onButtonClicked));
+}
+
+NotebookTabBox::~NotebookTabBox()
+{
+}
+
+void NotebookTabBox::onButtonClicked(void)
+{
+	m_signalClose(m_title, m_pageType);
+}
+
+//
+// Returns the close signal.
+//
+sigc::signal2&lt;void, ustring, NotebookPageBox::PageType&gt;&amp; NotebookTabBox::getCloseSignal(void)
+{
+	return m_signalClose;
+}


Property changes on: trunk/UI/GTK2/src/Notebook.cc
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: trunk/UI/GTK2/src/Notebook.cpp
===================================================================
--- trunk/UI/GTK2/src/Notebook.cpp	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/Notebook.cpp	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,267 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;iostream&gt;
-#include &lt;gtkmm/rc.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;NLS.h&quot;
-#include &quot;Notebook.h&quot;
-#include &quot;PinotUtils.h&quot;
-
-using namespace std;
-using namespace Glib;
-using namespace Gtk;
-
-NotebookPageBox::NotebookPageBox(const ustring &amp;title, NotebookPageBox::PageType type,
-	PinotSettings &amp;settings) :
-	VBox(),
-	m_title(title),
-	m_type(type),
-	m_settings(settings),
-	m_pTree(NULL)
-{
-}
-
-NotebookPageBox::~NotebookPageBox()
-{
-}
-
-//
-// Returns the page title.
-//
-ustring NotebookPageBox::getTitle(void) const
-{
-	return m_title;
-}
-
-//
-// Returns the page type.
-//
-NotebookPageBox::PageType NotebookPageBox::getType(void) const
-{
-	return m_type;
-}
-
-//
-// Returns the page's tree.
-//
-ResultsTree *NotebookPageBox::getTree(void) const
-{
-	return m_pTree;
-}
-
-ResultsPage::ResultsPage(const ustring &amp;queryName, ResultsTree *pTree,
-	int parentHeight, PinotSettings &amp;settings) :
-	NotebookPageBox(queryName, NotebookPageBox::RESULTS_PAGE, settings),
-	m_pLabel(NULL),
-	m_pCombobox(NULL),
-	m_pYesButton(NULL),
-	m_pCloseImage(NULL),
-	m_pCloseButton(NULL),
-	m_pHBox(NULL),
-	m_pVBox(NULL),
-	m_pVPaned(NULL)
-{
-	if (pTree != NULL)
-	{
-		m_pTree = pTree;
-		m_pLabel = manage(new Label(_(&quot;Did you mean ?&quot;)));
-		m_pCombobox = manage(new ComboBoxText());
-		m_pYesButton = manage(new Button(StockID(&quot;gtk-yes&quot;)));
-		m_pCloseImage = manage(new Image(StockID(&quot;gtk-close&quot;), IconSize(ICON_SIZE_MENU)));
-		m_pCloseButton = manage(new Button());
-
-		m_pCloseImage-&gt;set_alignment(0, 0);
-		m_pCloseImage-&gt;set_padding(0, 0);
-		m_pCloseButton-&gt;set_relief(RELIEF_NONE);
-		m_pCloseButton-&gt;set_border_width(0);
-		m_pCloseButton-&gt;set_name(&quot;pinot-tab-close-button&quot;);
-		m_pCloseButton-&gt;set_tooltip_text(_(&quot;Close&quot;));
-		m_pCloseButton-&gt;set_alignment(0, 0);
-		m_pCloseButton-&gt;add(*m_pCloseImage);
-		m_pHBox = manage(new HBox(false, 0));
-		m_pHBox-&gt;pack_start(*m_pLabel, Gtk::PACK_SHRINK, 4);
-		m_pHBox-&gt;pack_start(*m_pCombobox, Gtk::PACK_EXPAND_WIDGET, 4);
-		m_pHBox-&gt;pack_start(*m_pYesButton, Gtk::PACK_SHRINK, 4);
-		m_pHBox-&gt;pack_start(*m_pCloseButton, Gtk::PACK_SHRINK, 4);
-
-		m_pVBox = manage(new VBox(false, 0));
-		m_pVBox-&gt;pack_start(*m_pHBox, Gtk::PACK_SHRINK);
-		m_pVBox-&gt;pack_start(*pTree-&gt;getResultsScrolledWindow());
-
-		m_pVPaned = manage(new VPaned());
-		m_pVPaned-&gt;set_flags(Gtk::CAN_FOCUS);
-		m_pVPaned-&gt;set_position(105);
-		m_pVPaned-&gt;pack1(*m_pVBox, Gtk::EXPAND|Gtk::SHRINK);
-		m_pVPaned-&gt;pack2(*pTree-&gt;getExtractScrolledWindow(), Gtk::SHRINK);
-		pack_start(*m_pVPaned, Gtk::PACK_EXPAND_WIDGET);
-
-		// Give the extract 2/10th of the height
-		m_pVPaned-&gt;set_position((parentHeight * 8) / 10);
-
-		// Hide suggestions by default
-		onCloseButtonClicked();
-		m_pVBox-&gt;show();
-		m_pVPaned-&gt;show();
-
-		m_pYesButton-&gt;signal_clicked().connect(
-			sigc::mem_fun(*this, &amp;ResultsPage::onYesButtonClicked), false);
-		m_pCloseButton-&gt;signal_clicked().connect(
-			sigc::mem_fun(*this, &amp;ResultsPage::onCloseButtonClicked), false);
-	}
-
-	show();
-}
-
-ResultsPage::~ResultsPage()
-{
-}
-
-void ResultsPage::onYesButtonClicked()
-{
-	if (m_pCombobox == NULL)
-	{
-		return;
-	}
-
-	m_signalSuggest(m_title, m_pCombobox-&gt;get_active_text());
-}
-
-void ResultsPage::onCloseButtonClicked()
-{
-	// Just hide these
-	m_pLabel-&gt;hide();
-	m_pCombobox-&gt;hide();
-	m_pYesButton-&gt;hide();
-	m_pCloseImage-&gt;hide();
-	m_pCloseButton-&gt;hide();
-	m_pHBox-&gt;hide();
-}
-
-// Returns the suggest signal.
-sigc::signal2&lt;void, ustring, ustring&gt;&amp; ResultsPage::getSuggestSignal(void)
-{
-	return m_signalSuggest;
-}
-
-//
-// Append a suggestion.
-//
-void ResultsPage::appendSuggestion(const ustring &amp;text)
-{
-	if ((text.empty() == false) &amp;&amp;
-		(m_suggestions.find(text) == m_suggestions.end()))
-	{
-		ustring activeText(m_pCombobox-&gt;get_active_text());
-
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ResultsPage::appendSuggestion: suggesting &quot; &lt;&lt; text &lt;&lt; endl;
-#endif
-		m_suggestions.insert(text);
-		m_pCombobox-&gt;prepend_text(text);
-		if (activeText.empty() == true)
-		{
-			m_pCombobox-&gt;set_active(0);
-		}
-		else
-		{
-			m_pCombobox-&gt;set_active_text(activeText);
-		}
-	}
-
-	m_pLabel-&gt;show();
-	m_pCombobox-&gt;show();
-	m_pYesButton-&gt;show();
-	m_pCloseImage-&gt;show();
-	m_pCloseButton-&gt;show();
-	m_pHBox-&gt;show();
-}
-
-bool NotebookTabBox::m_initialized = false;
-
-NotebookTabBox::NotebookTabBox(const Glib::ustring &amp;title, NotebookPageBox::PageType type) :
-	HBox(),
-	m_title(title),
-	m_pageType(type),
-	m_pTabLabel(NULL),
-	m_pTabImage(NULL),
-	m_pTabButton(NULL)
-{
-	if (m_initialized == false)
-	{
-		m_initialized = true;
-
-		// This was lifted from gnome-terminal's terminal-window.c
-		RC::parse_string(&quot;style \&quot;pinot-tab-close-button-style\&quot;\n&quot;
-			&quot;{\n&quot;
-			&quot;GtkWidget::focus-padding = 0\n&quot;
-			&quot;GtkWidget::focus-line-width = 0\n&quot;
-			&quot;xthickness = 0\n&quot;
-			&quot;ythickness = 0\n&quot;
-			&quot;}\n&quot;
-			&quot;widget \&quot;*.pinot-tab-close-button\&quot; style \&quot;pinot-tab-close-button-style\&quot;&quot;);
-	}
-
-	m_pTabLabel = manage(new Label(title));
-	m_pTabImage = manage(new Image(StockID(&quot;gtk-close&quot;), IconSize(ICON_SIZE_MENU)));
-	m_pTabButton = manage(new Button());
-
-	m_pTabLabel-&gt;set_alignment(0, 0.5);
-	m_pTabLabel-&gt;set_padding(0, 0);
-	m_pTabLabel-&gt;set_justify(JUSTIFY_LEFT);
-	m_pTabLabel-&gt;set_line_wrap(false);
-	m_pTabLabel-&gt;set_use_markup(false);
-	m_pTabLabel-&gt;set_selectable(false);
-	m_pTabImage-&gt;set_alignment(0, 0);
-	m_pTabImage-&gt;set_padding(0, 0);
-	m_pTabButton-&gt;set_relief(RELIEF_NONE);
-	m_pTabButton-&gt;set_border_width(0);
-	m_pTabButton-&gt;set_name(&quot;pinot-tab-close-button&quot;);
-	m_pTabButton-&gt;set_tooltip_text(_(&quot;Close&quot;));
-	m_pTabButton-&gt;set_alignment(0, 0);
-	m_pTabButton-&gt;add(*m_pTabImage);
-	pack_start(*m_pTabLabel);
-	pack_start(*m_pTabButton, PACK_SHRINK);
-	set_spacing(0);
-	set_homogeneous(false);
-	m_pTabLabel-&gt;show();
-	m_pTabImage-&gt;show();
-	m_pTabButton-&gt;show();
-	show();
-
-	m_pTabButton-&gt;signal_clicked().connect(
-		sigc::mem_fun(*this, &amp;NotebookTabBox::onButtonClicked));
-}
-
-NotebookTabBox::~NotebookTabBox()
-{
-}
-
-void NotebookTabBox::onButtonClicked(void)
-{
-	m_signalClose(m_title, m_pageType);
-}
-
-//
-// Returns the close signal.
-//
-sigc::signal2&lt;void, ustring, NotebookPageBox::PageType&gt;&amp; NotebookTabBox::getCloseSignal(void)
-{
-	return m_signalClose;
-}

Deleted: trunk/UI/GTK2/src/Notebook.h
===================================================================
--- trunk/UI/GTK2/src/Notebook.h	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/Notebook.h	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,114 +0,0 @@
-/*
- *  Copyright 2005-2008 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _NOTEBOOK_HH
-#define _NOTEBOOK_HH
-
-#include &lt;set&gt;
-#include &lt;sigc++/sigc++.h&gt;
-#include &lt;glibmm/ustring.h&gt;
-#include &lt;gtkmm/box.h&gt;
-#include &lt;gtkmm/button.h&gt;
-#include &lt;gtkmm/comboboxtext.h&gt;
-#include &lt;gtkmm/image.h&gt;
-#include &lt;gtkmm/label.h&gt;
-#include &lt;gtkmm/paned.h&gt;
-#include &lt;gtkmm/textview.h&gt;
-
-#include &quot;PinotSettings.h&quot;
-#include &quot;ResultsTree.h&quot;
-
-class NotebookPageBox : public Gtk::VBox
-{
-	public:
-		typedef enum { RESULTS_PAGE = 0, INDEX_PAGE } PageType;
-
-		NotebookPageBox(const Glib::ustring &amp;title, PageType type,
-			PinotSettings &amp;settings);
-		virtual ~NotebookPageBox();
-
-		/// Returns the page title.
-		Glib::ustring getTitle(void) const;
-
-		/// Returns the page type.
-		PageType getType(void) const;
-
-		/// Returns the page's tree.
-		virtual ResultsTree *getTree(void) const;
-
-	protected:
-		Glib::ustring m_title;
-		PageType m_type;
-		PinotSettings &amp;m_settings;
-		ResultsTree *m_pTree;
-
-};
-
-class ResultsPage : public NotebookPageBox
-{
-	public:
-		ResultsPage(const Glib::ustring &amp;queryName, ResultsTree *pTree,
-			int parentHeight, PinotSettings &amp;settings);
-		virtual ~ResultsPage();
-
-		/// Returns the suggest signal.
-		sigc::signal2&lt;void, Glib::ustring, Glib::ustring&gt;&amp; getSuggestSignal(void);
-
-		/// Append a suggestion.
-		void appendSuggestion(const Glib::ustring &amp;text);
-
-	protected:
-		Gtk::Label *m_pLabel;
-		Gtk::ComboBoxText *m_pCombobox;
-		Gtk::Button *m_pYesButton;
-		Gtk::Image *m_pCloseImage;
-		Gtk::Button *m_pCloseButton;
-		Gtk::HBox *m_pHBox;
-		Gtk::VBox *m_pVBox;
-		Gtk::VPaned *m_pVPaned;
-		sigc::signal2&lt;void, Glib::ustring, Glib::ustring&gt; m_signalSuggest;
-		std::set&lt;Glib::ustring&gt; m_suggestions;
-		void onYesButtonClicked();
-
-		void onCloseButtonClicked();
-
-};
-
-class NotebookTabBox : public Gtk::HBox
-{
-	public:
-		NotebookTabBox(const Glib::ustring &amp;title, NotebookPageBox::PageType type);
-		virtual ~NotebookTabBox();
-
-		/// Returns the close signal.
-		sigc::signal2&lt;void, Glib::ustring, NotebookPageBox::PageType&gt;&amp; getCloseSignal(void);
-
-	protected:
-		static bool m_initialized;
-		Glib::ustring m_title;
-		NotebookPageBox::PageType m_pageType;
-		Gtk::Label *m_pTabLabel;
-		Gtk::Image *m_pTabImage;
-		Gtk::Button *m_pTabButton;
-		sigc::signal2&lt;void, Glib::ustring, NotebookPageBox::PageType&gt; m_signalClose;
-
-		void onButtonClicked(void);
-
-};
-
-#endif // _NOTEBOOK_HH

Copied: trunk/UI/GTK2/src/Notebook.hh (from rev 1529, trunk/UI/GTK2/src/Notebook.h)
===================================================================
--- trunk/UI/GTK2/src/Notebook.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/Notebook.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,114 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _NOTEBOOK_HH
+#define _NOTEBOOK_HH
+
+#include &lt;set&gt;
+#include &lt;sigc++/sigc++.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/comboboxtext.h&gt;
+#include &lt;gtkmm/image.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/paned.h&gt;
+#include &lt;gtkmm/textview.h&gt;
+
+#include &quot;PinotSettings.h&quot;
+#include &quot;ResultsTree.hh&quot;
+
+class NotebookPageBox : public Gtk::VBox
+{
+	public:
+		typedef enum { RESULTS_PAGE = 0, INDEX_PAGE } PageType;
+
+		NotebookPageBox(const Glib::ustring &amp;title, PageType type,
+			PinotSettings &amp;settings);
+		virtual ~NotebookPageBox();
+
+		/// Returns the page title.
+		Glib::ustring getTitle(void) const;
+
+		/// Returns the page type.
+		PageType getType(void) const;
+
+		/// Returns the page's tree.
+		virtual ResultsTree *getTree(void) const;
+
+	protected:
+		Glib::ustring m_title;
+		PageType m_type;
+		PinotSettings &amp;m_settings;
+		ResultsTree *m_pTree;
+
+};
+
+class ResultsPage : public NotebookPageBox
+{
+	public:
+		ResultsPage(const Glib::ustring &amp;queryName, ResultsTree *pTree,
+			int parentHeight, PinotSettings &amp;settings);
+		virtual ~ResultsPage();
+
+		/// Returns the suggest signal.
+		sigc::signal2&lt;void, Glib::ustring, Glib::ustring&gt;&amp; getSuggestSignal(void);
+
+		/// Append a suggestion.
+		void appendSuggestion(const Glib::ustring &amp;text);
+
+	protected:
+		Gtk::Label *m_pLabel;
+		Gtk::ComboBoxText *m_pCombobox;
+		Gtk::Button *m_pYesButton;
+		Gtk::Image *m_pCloseImage;
+		Gtk::Button *m_pCloseButton;
+		Gtk::HBox *m_pHBox;
+		Gtk::VBox *m_pVBox;
+		Gtk::VPaned *m_pVPaned;
+		sigc::signal2&lt;void, Glib::ustring, Glib::ustring&gt; m_signalSuggest;
+		std::set&lt;Glib::ustring&gt; m_suggestions;
+		void onYesButtonClicked();
+
+		void onCloseButtonClicked();
+
+};
+
+class NotebookTabBox : public Gtk::HBox
+{
+	public:
+		NotebookTabBox(const Glib::ustring &amp;title, NotebookPageBox::PageType type);
+		virtual ~NotebookTabBox();
+
+		/// Returns the close signal.
+		sigc::signal2&lt;void, Glib::ustring, NotebookPageBox::PageType&gt;&amp; getCloseSignal(void);
+
+	protected:
+		static bool m_initialized;
+		Glib::ustring m_title;
+		NotebookPageBox::PageType m_pageType;
+		Gtk::Label *m_pTabLabel;
+		Gtk::Image *m_pTabImage;
+		Gtk::Button *m_pTabButton;
+		sigc::signal2&lt;void, Glib::ustring, NotebookPageBox::PageType&gt; m_signalClose;
+
+		void onButtonClicked(void);
+
+};
+
+#endif // _NOTEBOOK_HH


Property changes on: trunk/UI/GTK2/src/Notebook.hh
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: trunk/UI/GTK2/src/ResultsTree.cc (from rev 1529, trunk/UI/GTK2/src/ResultsTree.cpp)
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/ResultsTree.cc	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,1656 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;ctype.h&gt;
+#include &lt;iostream&gt;
+#include &lt;gdkmm/color.h&gt;
+#include &lt;gtkmm/alignment.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/buttonbox.h&gt;
+#include &lt;gtkmm/image.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/stock.h&gt;
+#include &lt;gtkmm/cellrendererprogress.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;StringManip.h&quot;
+#include &quot;TimeConverter.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;QueryHistory.h&quot;
+#include &quot;ViewHistory.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;ResultsTree.hh&quot;
+
+using namespace std;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+ResultsTree::ResultsTree(const ustring &amp;queryName, Menu *pPopupMenu,
+	GroupByMode groupMode, PinotSettings &amp;settings) :
+	TreeView(),
+	m_treeName(queryName),
+	m_pPopupMenu(pPopupMenu),
+	m_pResultsScrolledwindow(NULL),
+	m_settings(settings),
+	m_pExtractScrolledwindow(NULL),
+	m_extractTextView(NULL),
+	m_showExtract(true),
+	m_groupMode(groupMode)
+{
+	TreeViewColumn *pColumn = NULL;
+
+	m_pResultsScrolledwindow = manage(new ScrolledWindow());
+	m_pExtractScrolledwindow = manage(new ScrolledWindow());
+	m_extractTextView = manage(new TextView());
+
+	// This is the actual results tree
+	set_events(Gdk::BUTTON_PRESS_MASK);
+	set_flags(CAN_FOCUS);
+	set_headers_clickable(true);
+	set_headers_visible(true);
+	set_rules_hint(true);
+	set_reorderable(false);
+	set_enable_search(true);
+	get_selection()-&gt;set_mode(SELECTION_MULTIPLE);
+	m_pResultsScrolledwindow-&gt;set_flags(CAN_FOCUS);
+	m_pResultsScrolledwindow-&gt;set_border_width(4);
+	m_pResultsScrolledwindow-&gt;set_shadow_type(SHADOW_NONE);
+	m_pResultsScrolledwindow-&gt;set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
+	m_pResultsScrolledwindow-&gt;property_window_placement().set_value(CORNER_TOP_LEFT);
+	m_pResultsScrolledwindow-&gt;add(*this);
+
+	// That's for the extract view
+	m_extractTextView-&gt;set_flags(CAN_FOCUS);
+	m_extractTextView-&gt;set_editable(false);
+	m_extractTextView-&gt;set_cursor_visible(false);
+	m_extractTextView-&gt;set_pixels_above_lines(0);
+	m_extractTextView-&gt;set_pixels_below_lines(0);
+	m_extractTextView-&gt;set_pixels_inside_wrap(0);
+	m_extractTextView-&gt;set_left_margin(0);
+	m_extractTextView-&gt;set_right_margin(0);
+	m_extractTextView-&gt;set_indent(0);
+	m_extractTextView-&gt;set_wrap_mode(WRAP_WORD);
+	m_extractTextView-&gt;set_justification(JUSTIFY_LEFT);
+	RefPtr&lt;TextTag&gt; refBoldTag = TextBuffer::Tag::create(&quot;bold&quot;);
+	refBoldTag-&gt;property_weight() = 900;
+	RefPtr&lt;TextBuffer&gt; refBuffer = m_extractTextView-&gt;get_buffer();
+	if (refBuffer)
+	{
+		refBuffer-&gt;get_tag_table()-&gt;add(refBoldTag); 
+	}
+	m_pExtractScrolledwindow-&gt;set_flags(CAN_FOCUS);
+	m_pExtractScrolledwindow-&gt;set_border_width(4);
+	m_pExtractScrolledwindow-&gt;set_shadow_type(SHADOW_NONE);
+	m_pExtractScrolledwindow-&gt;set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
+	m_pExtractScrolledwindow-&gt;property_window_placement().set_value(CORNER_TOP_LEFT);
+	m_pExtractScrolledwindow-&gt;add(*m_extractTextView);
+
+	// Associate the columns model to the results tree
+	m_refStore = TreeStore::create(m_resultsColumns);
+	set_model(m_refStore);
+
+	if (m_groupMode != FLAT)
+	{
+		// The first column is for the status icons
+		pColumn = new TreeViewColumn(&quot;&quot;);
+		// Pack an icon renderer for the viewed status
+		CellRendererPixbuf *pIconRenderer = new CellRendererPixbuf();
+		pColumn-&gt;pack_start(*manage(pIconRenderer), false);
+		pColumn-&gt;set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &amp;ResultsTree::renderViewStatus));
+		// Pack a second icon renderer for the indexed status
+		pIconRenderer = new CellRendererPixbuf();
+		pColumn-&gt;pack_start(*manage(pIconRenderer), false);
+		pColumn-&gt;set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &amp;ResultsTree::renderIndexStatus));
+		// And a third one for the ranking
+		pIconRenderer = new CellRendererPixbuf();
+		pColumn-&gt;pack_start(*manage(pIconRenderer), false);
+		pColumn-&gt;set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &amp;ResultsTree::renderRanking));
+		pColumn-&gt;set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
+		append_column(*manage(pColumn));
+
+		// This is the score column
+		pColumn = new TreeViewColumn(_(&quot;Score&quot;));
+		CellRendererProgress *pProgressRenderer = new CellRendererProgress();
+		pColumn-&gt;pack_start(*manage(pProgressRenderer));
+		pColumn-&gt;add_attribute(pProgressRenderer-&gt;property_text(), m_resultsColumns.m_scoreText);
+		pColumn-&gt;add_attribute(pProgressRenderer-&gt;property_value(), m_resultsColumns.m_score);
+		pColumn-&gt;set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
+		pColumn-&gt;set_sort_column(m_resultsColumns.m_score);
+		append_column(*manage(pColumn));
+	}
+
+	// This is the title column
+	pColumn = new TreeViewColumn(_(&quot;Title&quot;));
+	CellRendererText *pTextRenderer = new CellRendererText();
+	pColumn-&gt;pack_start(*manage(pTextRenderer));
+	pColumn-&gt;set_cell_data_func(*pTextRenderer, sigc::mem_fun(*this, &amp;ResultsTree::renderTitleColumn));
+	pColumn-&gt;add_attribute(pTextRenderer-&gt;property_text(), m_resultsColumns.m_text);
+	pColumn-&gt;set_resizable(true);
+	pColumn-&gt;set_sort_column(m_resultsColumns.m_text);
+	append_column(*manage(pColumn));
+
+	// URL
+	pColumn = create_column(_(&quot;URL&quot;), m_resultsColumns.m_url, false, true, m_resultsColumns.m_url);
+	if (pColumn != NULL)
+	{
+		pColumn-&gt;set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
+		append_column(*manage(pColumn));
+	}
+
+	// The last column is for the timestamp
+	pColumn = create_column(_(&quot;Date&quot;), m_resultsColumns.m_timestamp, false, true, m_resultsColumns.m_timestampTime);
+	if (pColumn != NULL)
+	{
+		pColumn-&gt;set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
+		append_column(*manage(pColumn));
+	}
+	
+	// Connect the signals
+	signal_button_press_event().connect_notify(
+		sigc::mem_fun(*this, &amp;ResultsTree::onButtonPressEvent));
+	get_selection()-&gt;signal_changed().connect(
+		sigc::mem_fun(*this, &amp;ResultsTree::onSelectionChanged));
+
+	// Enable interactive search
+	set_search_column(m_resultsColumns.m_text.index());
+	// Control which rows can be selected
+	get_selection()-&gt;set_select_function(sigc::mem_fun(*this, &amp;ResultsTree::onSelectionSelect));
+	// Listen for style changes
+	signal_style_changed().connect_notify(sigc::mem_fun(*this, &amp;ResultsTree::onStyleChanged));
+
+	// Render the icons
+	m_indexedIconPixbuf = render_icon(Stock::INDEX, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_viewededIconPixbuf = render_icon(Stock::YES, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_upIconPixbuf = render_icon(Stock::GO_UP, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_downIconPixbuf = render_icon(Stock::GO_DOWN, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+
+	// Show all
+	show();
+	m_pResultsScrolledwindow-&gt;show();
+	m_extractTextView-&gt;show();
+	m_pExtractScrolledwindow-&gt;show();
+}
+
+ResultsTree::~ResultsTree()
+{
+}
+
+void ResultsTree::renderViewStatus(CellRenderer *pRenderer, const TreeModel::iterator &amp;iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (pRenderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *pIconRenderer = dynamic_cast&lt;CellRendererPixbuf*&gt;(pRenderer);
+	if (pIconRenderer != NULL)
+	{
+		// Has this result been already viewed ?
+		if ((row[m_resultsColumns.m_viewed] == true) &amp;&amp;
+			(m_viewededIconPixbuf))
+		{
+			pIconRenderer-&gt;property_pixbuf() = m_viewededIconPixbuf;
+		}
+		else
+		{
+			pIconRenderer-&gt;property_pixbuf().reset_value();
+		}
+	}
+}
+
+void ResultsTree::renderIndexStatus(CellRenderer *pRenderer, const TreeModel::iterator &amp;iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (pRenderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *pIconRenderer = dynamic_cast&lt;CellRendererPixbuf*&gt;(pRenderer);
+	if (pIconRenderer != NULL)
+	{
+		// Is this result indexed ?
+		if ((row[m_resultsColumns.m_indexed] == true) &amp;&amp;
+			(m_indexedIconPixbuf))
+		{
+			pIconRenderer-&gt;property_pixbuf() = m_indexedIconPixbuf;
+		}
+		else
+		{
+			pIconRenderer-&gt;property_pixbuf().reset_value();
+		}
+	}
+}
+
+void ResultsTree::renderRanking(CellRenderer *pRenderer, const TreeModel::iterator &amp;iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (pRenderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *pIconRenderer = dynamic_cast&lt;CellRendererPixbuf*&gt;(pRenderer);
+	if (pIconRenderer != NULL)
+	{
+		int rankDiff = row[m_resultsColumns.m_rankDiff];
+
+		// Has this result's score changed ?
+		if ((rankDiff &gt; 0) &amp;&amp;
+			(rankDiff != 666))
+		{
+			pIconRenderer-&gt;property_pixbuf() = m_upIconPixbuf;
+		}
+		else if (rankDiff &lt; 0)
+		{
+			pIconRenderer-&gt;property_pixbuf() = m_downIconPixbuf;
+		}
+		else
+		{
+			pIconRenderer-&gt;property_pixbuf().reset_value();
+		}
+	}
+}
+
+void ResultsTree::renderTitleColumn(CellRenderer *pRenderer, const TreeModel::iterator &amp;iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (pRenderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererText *pTextRenderer = dynamic_cast&lt;CellRendererText*&gt;(pRenderer);
+	if (pTextRenderer != NULL)
+	{
+		// Is this result new ?
+		if (row[m_resultsColumns.m_rankDiff] == 666)
+		{
+			Color newColour;
+
+			newColour.set_red(m_settings.m_newResultsColourRed);
+			newColour.set_green(m_settings.m_newResultsColourGreen);
+			newColour.set_blue(m_settings.m_newResultsColourBlue);
+
+			// Change the row's background
+			pTextRenderer-&gt;property_background_gdk() = newColour;
+		}
+		else
+		{
+			pTextRenderer-&gt;property_background_gdk().reset_value();
+		}
+
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		if ((type == ResultsModelColumns::ROW_ENGINE) ||
+			(type == ResultsModelColumns::ROW_HOST))
+		{
+			ustring markup(&quot;&lt;b&gt;&quot;);
+			markup += row[m_resultsColumns.m_text];
+			markup += &quot;&lt;/b&gt;&quot;;
+			pTextRenderer-&gt;property_markup() = markup;
+		}
+	}
+}
+
+void ResultsTree::onButtonPressEvent(GdkEventButton *ev)
+{
+	// Check for popup click
+	if ((ev-&gt;type == GDK_BUTTON_PRESS) &amp;&amp;
+		(ev-&gt;button == 3) )
+	{
+		if (m_pPopupMenu != NULL)
+		{
+			m_pPopupMenu-&gt;popup(ev-&gt;button, ev-&gt;time);
+		}
+	}
+	// Check for double clicks
+	else if (ev-&gt;type == GDK_2BUTTON_PRESS)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::onButtonPressEvent: double click on button &quot; &lt;&lt; ev-&gt;button &lt;&lt; endl;
+#endif
+		m_signalDoubleClick();
+	}
+}
+
+void ResultsTree::onSelectionChanged(void)
+{
+	m_signalSelectionChanged(m_treeName);
+}
+
+bool ResultsTree::onSelectionSelect(const RefPtr&lt;TreeModel&gt;&amp; model,
+	const TreeModel::Path&amp; node_path, bool path_currently_selected)
+{
+	const TreeModel::iterator iter = model-&gt;get_iter(node_path);
+	const TreeModel::Row row = *iter;
+
+	// In flat mode, don't bother about the extract
+	if ((path_currently_selected == false) &amp;&amp;
+		(m_groupMode != FLAT))
+	{
+		// Is this an actual result ?
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		if (type != ResultsModelColumns::ROW_RESULT)
+		{
+			return true;
+		}
+
+		RefPtr&lt;TextBuffer&gt; refBuffer = m_extractTextView-&gt;get_buffer();
+		if (refBuffer)
+		{
+			ustring extract(findResultsExtract(row));
+			ustring::size_type textPos = 0, boldPos = extract.find(&quot;&lt;b&gt;&quot;);
+
+			// Clear the extract
+			refBuffer-&gt;set_text(&quot;&quot;);
+
+#ifdef DEBUG
+			cout &lt;&lt; &quot;ResultsTree::onSelectionSelect: extract for &quot; &lt;&lt; row[m_resultsColumns.m_url] &lt;&lt; endl;
+#endif
+			if (boldPos == ustring::npos)
+			{
+				refBuffer-&gt;set_text(extract);
+			}
+			else
+			{
+				TextBuffer::iterator bufferPos = refBuffer-&gt;begin();
+
+				while (boldPos != ustring::npos)
+				{
+					bufferPos = refBuffer-&gt;insert(bufferPos, extract.substr(textPos, boldPos - textPos));
+
+					textPos = boldPos + 3;
+					boldPos = extract.find(&quot;&lt;/b&gt;&quot;, textPos);
+					if (boldPos == ustring::npos)
+					{
+						continue;
+					}
+					bufferPos = refBuffer-&gt;insert_with_tag(bufferPos, extract.substr(textPos, boldPos - textPos), &quot;bold&quot;);
+
+					// Next
+					textPos = boldPos + 4;
+					boldPos = extract.find(&quot;&lt;b&gt;&quot;, textPos);
+				}
+
+				if (textPos + 1 &lt; extract.length())
+				{
+					bufferPos = refBuffer-&gt;insert(bufferPos, extract.substr(textPos, boldPos - textPos));
+				}
+			}
+		}
+	}
+
+	return true;
+}
+
+void ResultsTree::onStyleChanged(const RefPtr&lt;Style&gt; &amp;previous_style)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;ResultsTree::onStyleChanged: called&quot; &lt;&lt; endl;
+#endif
+	// FIXME: find better icons :-)
+	m_indexedIconPixbuf = render_icon(Stock::INDEX, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_viewededIconPixbuf = render_icon(Stock::YES, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_upIconPixbuf = render_icon(Stock::GO_UP, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_downIconPixbuf = render_icon(Stock::GO_DOWN, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+}
+
+//
+// Returns the results scrolled window.
+//
+ScrolledWindow *ResultsTree::getResultsScrolledWindow(void) const
+{
+	return m_pResultsScrolledwindow;
+}
+
+//
+// Returns the extract scrolled window.
+//
+ScrolledWindow *ResultsTree::getExtractScrolledWindow(void) const
+{
+	return m_pExtractScrolledwindow;
+}
+
+//
+// Returns the extract tree.
+//
+bool ResultsTree::focusOnExtract(void) const
+{
+	return m_extractTextView-&gt;is_focus();
+}
+
+//
+// Returns the extract.
+//
+ustring ResultsTree::getExtract(void) const
+{
+	ustring text;
+
+	RefPtr&lt;TextBuffer&gt; refBuffer = m_extractTextView-&gt;get_buffer();
+	if (refBuffer)
+	{
+		text = refBuffer-&gt;get_text();
+	}
+
+	return text;
+}
+
+//
+// Adds a set of results.
+// Returns true if something was added to the tree.
+//
+bool ResultsTree::addResults(const string &amp;engineName, const vector&lt;DocumentInfo&gt; &amp;resultsList,
+	const string &amp;charset, bool updateHistory)
+{
+	std::map&lt;string, TreeModel::iterator&gt; updatedGroups;
+	ResultsModelColumns::RowType rootType;
+	unsigned int count = 0;
+
+	// What's the grouping criteria ?
+	if (m_groupMode == BY_ENGINE)
+	{
+		// By search engine
+		rootType = ResultsModelColumns::ROW_ENGINE;
+	}
+	else if (m_groupMode == BY_HOST)
+	{
+		// By host
+		rootType = ResultsModelColumns::ROW_HOST;
+	}
+
+	unsigned int indexId = 0;
+	unsigned int engineId = 0;
+
+	// Find out what the search engine ID is
+	if (engineName.empty() == false)
+	{
+		engineId = m_settings.getEngineId(engineName);
+		if (engineId == 0)
+		{
+			// Chances are this engine is an index
+			PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(engineName);
+			if (indexProps.m_location.empty() == false)
+			{
+				// Yes, it is
+				indexId = indexProps.m_id;
+				engineId = m_settings.getEngineId(m_settings.m_defaultBackend);
+#ifdef DEBUG
+				cout &lt;&lt; &quot;ResultsTree::addResults: engine is index &quot; &lt;&lt; engineName &lt;&lt; &quot; &quot; &lt;&lt; indexId &lt;&lt; &quot; &quot; &lt;&lt; engineId &lt;&lt; endl;
+#endif
+			}
+#ifdef DEBUG
+			else cout &lt;&lt; &quot;ResultsTree::addResults: &quot; &lt;&lt; engineName &lt;&lt; &quot; is not an index&quot; &lt;&lt;  endl;
+#endif
+		}
+#ifdef DEBUG
+		else cout &lt;&lt; &quot;ResultsTree::addResults: ID for engine &quot; &lt;&lt; engineName &lt;&lt; &quot; is &quot; &lt;&lt; engineId &lt;&lt;  endl;
+#endif
+	}
+
+	QueryHistory queryHistory(m_settings.getHistoryDatabaseName());
+	ViewHistory viewHistory(m_settings.getHistoryDatabaseName());
+	set&lt;time_t&gt; latestRuns;
+	time_t secondLastRunTime = 0;
+	bool isNewQuery = false;
+
+	// Is this a new query ?
+	if ((queryHistory.getLatestRuns(m_treeName, engineName, 2, latestRuns) == false) ||
+		(latestRuns.empty() == true))
+	{
+		isNewQuery = true;
+	}
+	else
+	{
+		set&lt;time_t&gt;::const_iterator runIter = latestRuns.begin();
+
+		// We only need to keep the last two runs
+		if (runIter != latestRuns.end())
+		{
+			++runIter;
+			if (runIter != latestRuns.end())
+			{
+				secondLastRunTime = (*runIter);
+			}
+		}
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;ResultsTree::addResults: &quot; &lt;&lt; resultsList.size() &lt;&lt; &quot; results with charset &quot; &lt;&lt; charset
+		&lt;&lt; &quot;, second last run &quot; &lt;&lt; secondLastRunTime &lt;&lt; endl;
+#endif
+
+	// Look at the results list
+	for (vector&lt;DocumentInfo&gt;::const_iterator resultIter = resultsList.begin();
+		resultIter != resultsList.end(); ++resultIter)
+	{
+		ustring title(to_utf8(resultIter-&gt;getTitle(), charset));
+		ustring location(to_utf8(resultIter-&gt;getLocation(), charset));
+		ustring timestamp(to_utf8(resultIter-&gt;getTimestamp()));
+		ustring extract(to_utf8(resultIter-&gt;getExtract(), charset));
+		string groupName;
+		TreeModel::iterator groupIter;
+		float currentScore = resultIter-&gt;getScore();
+		int rankDiff = 0;
+
+		if (m_groupMode != FLAT)
+		{
+			// What group should the result go to ?
+			if (rootType == ResultsModelColumns::ROW_HOST)
+			{
+				Url urlObj(location);
+				groupName = urlObj.getHost();
+			}
+			else
+			{
+				groupName = engineName;
+			}
+			// Add the group or get its position if it's already in
+			appendGroup(groupName, rootType, groupIter);
+
+			// Has the result's ranking changed ?
+			float oldestScore = 0;
+			float previousScore = queryHistory.hasItem(m_treeName, engineName,
+				location, oldestScore);
+#ifdef DEBUG
+			cout &lt;&lt; &quot;ResultsTree::addResults: &quot; &lt;&lt; location &lt;&lt; &quot; has scores &quot;
+				&lt;&lt; previousScore &lt;&lt; &quot;, &quot; &lt;&lt; oldestScore &lt;&lt; endl;
+#endif
+			if (previousScore &gt; 0)
+			{
+				// Yes, it has
+				rankDiff = (int)(currentScore - previousScore);
+			}
+			else
+			{
+				// New results are displayed as such only if the query has already been run on the engine
+				if (isNewQuery == false)
+				{
+					// This is a magic value :-)
+					rankDiff = 666;
+				}
+			}
+
+			if (updateHistory == true)
+			{
+				queryHistory.insertItem(m_treeName, engineName, location,
+					title, extract, currentScore);
+			}
+		}
+
+		++count;
+
+		// We already got indexId from PinotSettings
+		unsigned int docIndexId = 0;
+		unsigned int docId = resultIter-&gt;getIsIndexed(docIndexId);
+		bool isIndexed = false;
+
+		if (docId &gt; 0)
+		{
+			isIndexed = true;
+		}
+
+		// Has it been already viewed ?
+		bool wasViewed = viewHistory.hasItem(location);
+
+		// OK, add a row for this result within the group
+		TreeModel::iterator titleIter;
+		if (appendResult(title, location, (int)currentScore, rankDiff, isIndexed, wasViewed,
+			docId, timestamp, resultIter-&gt;serialize(),
+			engineId, indexId, titleIter, groupIter, true) == true)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;ResultsTree::addResults: added row for result &quot; &lt;&lt; count
+				&lt;&lt; &quot;, &quot; &lt;&lt; currentScore &lt;&lt; &quot;, &quot; &lt;&lt; isIndexed &lt;&lt; &quot; &quot; &lt;&lt; docId
+				&lt;&lt; &quot; &quot; &lt;&lt; indexId &lt;&lt; endl;
+#endif
+
+			if (groupIter)
+			{
+				// Update this map, so that we know which groups need updating
+				updatedGroups[groupName] = groupIter;
+			}
+		}
+	}
+
+	// Remove older items ?
+	if ((isNewQuery == false) &amp;&amp;
+		(updateHistory == true))
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::addResults: removing items for &quot; &lt;&lt; m_treeName
+			&lt;&lt; &quot;, &quot; &lt;&lt; engineName &lt;&lt; &quot; older than &quot; &lt;&lt; secondLastRunTime &lt;&lt; endl;
+#endif
+		queryHistory.deleteItems(m_treeName, engineName, secondLastRunTime);
+	}
+
+	if (count &gt; 0)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::addResults: &quot; &lt;&lt; updatedGroups.size() &lt;&lt; &quot; groups to update&quot; &lt;&lt; endl;
+#endif
+		// Update the groups to which we have added results
+		for (std::map&lt;string, TreeModel::iterator&gt;::iterator mapIter = updatedGroups.begin();
+			mapIter != updatedGroups.end(); mapIter++)
+		{
+			TreeModel::iterator groupIter = mapIter-&gt;second;
+			updateGroup(groupIter);
+		}
+
+		return true;
+	}
+	else if (m_groupMode == BY_ENGINE)
+	{
+		// If this didn't return any result, add an empty group
+		TreeModel::iterator groupIter;
+		appendGroup(engineName, rootType, groupIter);
+		updateGroup(groupIter);
+
+		return true;
+	}
+
+	return false;
+}
+
+//
+// Sets how results are grouped.
+//
+void ResultsTree::setGroupMode(GroupByMode groupMode)
+{
+	ResultsModelColumns::RowType currentType, newType;
+
+	if (m_groupMode == FLAT)
+	{
+		// No change possible
+		return;
+	}
+
+	if (m_groupMode == groupMode)
+	{
+		// No change
+		return;
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;ResultsTree::setGroupMode: set to &quot; &lt;&lt; groupMode &lt;&lt; endl;
+#endif
+	m_groupMode = groupMode;
+
+	// Do we need to update the tree ?
+	TreeModel::Children children = m_refStore-&gt;children();
+	if (children.empty() == true)
+	{
+		return;
+	}
+
+	// What's the new grouping criteria ?
+	if (m_groupMode == BY_ENGINE)
+	{
+		// By search engine
+		currentType = ResultsModelColumns::ROW_HOST;
+		newType = ResultsModelColumns::ROW_ENGINE;
+	}
+	else
+	{
+		// By host
+		currentType = ResultsModelColumns::ROW_ENGINE;
+		newType = ResultsModelColumns::ROW_HOST;
+	}
+
+	// Clear the map
+	m_resultsGroups.clear();
+
+	// Unselect results
+	get_selection()-&gt;unselect_all();
+
+	TreeModel::Children::iterator iter = children.begin();
+	while (iter != children.end())
+	{
+		TreeModel::Row row = *iter;
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::setGroupMode: looking at &quot; &lt;&lt; row[m_resultsColumns.m_url] &lt;&lt; endl;
+#endif
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		// Skip new type and other rows
+		if ((type == newType) ||
+			(type == ResultsModelColumns::ROW_OTHER))
+		{
+			iter++;
+			continue;
+		}
+
+		TreeModel::Children groupChildren = iter-&gt;children();
+		TreeModel::Children::iterator childIter = groupChildren.begin();
+		// Type ROW_RESULT
+		while (childIter != groupChildren.end())
+		{
+			TreeModel::Row childRow = *childIter;
+			TreeModel::iterator groupIter, newIter;
+			bool success = false;
+
+			type = childRow[m_resultsColumns.m_resultType];
+			if (type == ResultsModelColumns::ROW_OTHER)
+			{
+				TreeModel::Children::iterator nextChildIter = childIter;
+				++nextChildIter;
+
+				// Erase this row
+				m_refStore-&gt;erase(childIter);
+				childIter = nextChildIter;
+				continue;
+			}
+
+			// We will need the URL and engines columns in all cases
+			string url(from_utf8(childRow[m_resultsColumns.m_url]));
+			unsigned int engineIds = childRow[m_resultsColumns.m_engines];
+			unsigned int indexIds = childRow[m_resultsColumns.m_indexes];
+
+			// Get the name of the group this should go into
+			if (m_groupMode == BY_HOST)
+			{
+				Url urlObj(url);
+#ifdef DEBUG
+				cout &lt;&lt; &quot;ResultsTree::setGroupMode: row &quot; &lt;&lt; url &lt;&lt; endl;
+#endif
+				// Add group
+				if (appendGroup(urlObj.getHost(), newType, groupIter) == true)
+				{
+					// Add result
+					success = appendResult(childRow[m_resultsColumns.m_text],
+						childRow[m_resultsColumns.m_url],
+						childRow[m_resultsColumns.m_score],
+						childRow[m_resultsColumns.m_rankDiff],
+						childRow[m_resultsColumns.m_indexed],
+						childRow[m_resultsColumns.m_viewed],
+						childRow[m_resultsColumns.m_docId],
+						childRow[m_resultsColumns.m_timestamp],
+						childRow[m_resultsColumns.m_serial],
+						engineIds, indexIds,
+						newIter, groupIter, true);
+				}
+			}
+			else
+			{
+				// Look at the engines column and see which engines this result is for
+				set&lt;string&gt; engineNames;
+				m_settings.getEngineNames(engineIds, engineNames);
+				if (engineNames.empty() == false)
+				{
+#ifdef DEBUG
+					cout &lt;&lt; &quot;ResultsTree::setGroupMode: row is for &quot; &lt;&lt; engineNames.size() &lt;&lt; &quot; engine(s)&quot; &lt;&lt; endl;
+#endif
+					// Are there indexes in the list ?
+					set&lt;string&gt;::iterator backendIter = engineNames.find(m_settings.m_defaultBackend);
+					if ((backendIter != engineNames.end()) &amp;&amp;
+						(indexIds &gt; 0))
+					{
+						// Erase this
+						engineNames.erase(backendIter);
+#ifdef DEBUG
+						cout &lt;&lt; &quot;ResultsTree::setGroupMode: row is for index(es) &quot; &lt;&lt; indexIds &lt;&lt; endl;
+#endif
+
+						// Add entries for each index name so that we can loop once on engine names
+						set&lt;string&gt; indexNames;
+						m_settings.getIndexNames(indexIds, indexNames);
+						for (set&lt;string&gt;::iterator indexIter = indexNames.begin();
+							indexIter != indexNames.end(); ++indexIter)
+						{
+							string indexName(*indexIter);
+							engineNames.insert(indexName);
+#ifdef DEBUG
+							cout &lt;&lt; &quot;ResultsTree::setGroupMode: row is for index &quot; &lt;&lt; indexName &lt;&lt; endl;
+#endif
+						}
+					}
+
+					for (set&lt;string&gt;::iterator engineIter = engineNames.begin();
+						engineIter != engineNames.end(); ++engineIter)
+					{
+						string engineName(*engineIter);
+						unsigned int indexId = 0;
+						unsigned int engineId = m_settings.getEngineId(engineName);
+
+						if (engineId == 0)
+						{
+							// This is actually an index, not an engine...
+							PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(engineName);
+							if (indexProps.m_location.empty() == false)
+							{
+								engineId = m_settings.getEngineId(m_settings.m_defaultBackend);
+							}
+#ifdef DEBUG
+							cout &lt;&lt; &quot;ResultsTree::setGroupMode: index &quot; &lt;&lt; indexId &lt;&lt; endl;
+#endif
+						}
+#ifdef DEBUG
+						else cout &lt;&lt; &quot;ResultsTree::setGroupMode: no index&quot; &lt;&lt; endl;
+#endif
+
+						// Add group
+						if (appendGroup(engineName, newType, groupIter) == true)
+						{
+							// Add result
+							appendResult(childRow[m_resultsColumns.m_text],
+								childRow[m_resultsColumns.m_url],
+								childRow[m_resultsColumns.m_score],
+								childRow[m_resultsColumns.m_rankDiff],
+								childRow[m_resultsColumns.m_indexed],
+								childRow[m_resultsColumns.m_viewed],
+								childRow[m_resultsColumns.m_docId],
+								childRow[m_resultsColumns.m_timestamp],
+								childRow[m_resultsColumns.m_serial],
+								engineId, indexId,
+								newIter, groupIter, true);
+#ifdef DEBUG
+							cout &lt;&lt; &quot;ResultsTree::setGroupMode: row for &quot; &lt;&lt; engineName &lt;&lt; endl;
+#endif
+						}
+					}
+
+					// FIXME: make sure at least one row was added
+					success = true;
+				}
+			}
+
+			if (success == true)
+			{
+				// Delete it
+				m_refStore-&gt;erase(*childIter);
+				childIter = groupChildren.begin();
+			}
+			else
+			{
+				// Don't delete anything then, just go to the next child
+				childIter++;
+			}
+		}
+
+		// Erase this row
+		m_refStore-&gt;erase(*iter);
+
+		// Get the new first row, that way we don't have to worry about iterators validity
+		iter = children.begin();
+	}
+
+	for (std::map&lt;string, TreeModel::iterator&gt;::iterator mapIter = m_resultsGroups.begin();
+		mapIter != m_resultsGroups.end(); mapIter++)
+	{
+		TreeModel::iterator groupIter = mapIter-&gt;second;
+		updateGroup(groupIter);
+	}
+
+	onSelectionChanged();
+}
+
+//
+// Gets the first selected item's URL.
+//
+ustring ResultsTree::getFirstSelectionURL(void)
+{
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return &quot;&quot;;
+	}
+
+	list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
+	TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
+	TreeModel::Row row = *iter;
+
+	return row[m_resultsColumns.m_url];
+}
+
+//
+// Gets a list of selected items.
+//
+bool ResultsTree::getSelection(vector&lt;DocumentInfo&gt; &amp;resultsList, bool skipIndexed)
+{
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return false;
+	}
+
+	// Go through selected items
+	for (list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
+		itemPath != selectedItems.end(); ++itemPath)
+	{
+		TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		if (type != ResultsModelColumns::ROW_RESULT)
+		{
+			continue;
+		}
+
+		bool isIndexed = row[m_resultsColumns.m_indexed];
+		if ((skipIndexed == false) ||
+			(isIndexed == false))
+		{
+			DocumentInfo current;
+			string serial(row[m_resultsColumns.m_serial]);
+
+			current.deserialize(serial);
+
+			if (isIndexed == true)
+			{
+				set&lt;string&gt; indexNames;
+				unsigned int indexIds = row[m_resultsColumns.m_indexes];
+
+				m_settings.getIndexNames(indexIds, indexNames);
+				// Any internal index in there ?
+				for (set&lt;string&gt;::iterator indexIter = indexNames.begin(); indexIter != indexNames.end(); ++indexIter)
+				{
+					PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(*indexIter);
+					if (indexProps.m_internal == true)
+					{
+#ifdef DEBUG
+						cout &lt;&lt; &quot;ResultsTree::getSelection: result in internal index &quot; &lt;&lt; *indexIter &lt;&lt; endl;
+#endif
+						current.setIsIndexed(indexProps.m_id, row[m_resultsColumns.m_docId]);
+						break;
+					}
+				}
+			}
+
+			resultsList.push_back(current);
+		}
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;ResultsTree::getSelection: &quot; &lt;&lt; resultsList.size() &lt;&lt; &quot; results selected&quot; &lt;&lt; endl;
+#endif
+
+	return true;
+}
+
+//
+// Sets the selected items' state.
+//
+void ResultsTree::setSelectionState(bool viewed)
+{
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return;
+	}
+
+	// Go through selected items
+	for (list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
+		itemPath != selectedItems.end(); ++itemPath)
+	{
+		TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+  
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		if (type != ResultsModelColumns::ROW_RESULT)
+		{
+			continue;
+		}
+
+		if (viewed == true)
+		{
+			row[m_resultsColumns.m_viewed] = true;
+		}
+	}
+}
+
+//
+// Updates a result's properties.
+//
+bool ResultsTree::updateResult(const DocumentInfo &amp;result)
+{
+	unsigned int indexId = 0;
+	unsigned int docId = result.getIsIndexed(indexId);
+
+	if (docId == 0)
+	{
+		return false;
+	}
+
+	// Go through the list
+	TreeModel::Children children = m_refStore-&gt;children();
+	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
+	{
+		TreeModel::Row row = *iter;
+
+		if (docId == row[m_resultsColumns.m_docId])
+		{
+			// FIXME: title, location should be converted based on the result's charset !
+			updateRow(row, result.getTitle(), result.getLocation(),
+				row[m_resultsColumns.m_score], row[m_resultsColumns.m_engines],
+				row[m_resultsColumns.m_indexes], docId,
+				to_utf8(result.getTimestamp()), result.serialize(),
+				ResultsModelColumns::ROW_RESULT,
+				row[m_resultsColumns.m_indexed], row[m_resultsColumns.m_viewed],
+				row[m_resultsColumns.m_rankDiff]);
+
+			return true;
+		}
+	}
+
+	return false;
+}
+
+//
+// Deletes the current selection.
+//
+bool ResultsTree::deleteSelection(void)
+{
+	bool empty = false;
+
+	// Go through selected items
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
+	while (itemPath != selectedItems.end())
+	{
+		TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+		TreeModel::iterator parentIter;
+		bool updateParent = false;
+
+		// This could be a group that's in the map and should be removed first
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		if (type != ResultsModelColumns::ROW_RESULT)
+		{
+			string groupName(from_utf8(row[m_resultsColumns.m_text]));
+			std::map&lt;string, TreeModel::iterator&gt;::iterator mapIter = m_resultsGroups.find(groupName);
+			if (mapIter != m_resultsGroups.end())
+			{
+				m_resultsGroups.erase(mapIter);
+#ifdef DEBUG
+				cout &lt;&lt; &quot;ResultsTree::deleteSelection: erased group &quot; &lt;&lt; groupName &lt;&lt; endl;
+#endif
+			}
+		}
+		else if (m_groupMode != FLAT)
+		{
+			// This item is a result
+			parentIter = row.parent();
+			updateParent = true;
+		}
+
+		// Unselect and erase
+		get_selection()-&gt;unselect(iter);
+		m_refStore-&gt;erase(row);
+
+		// Update group ?
+		if (updateParent == true)
+		{
+			// Update the group this result belongs to
+			updateGroup(parentIter);
+		}
+
+		selectedItems = get_selection()-&gt;get_selected_rows();
+		itemPath = selectedItems.begin();
+	}
+
+	TreeModel::Children children = m_refStore-&gt;children();
+	empty = children.empty();
+
+	refresh();
+
+	return empty;
+}
+
+//
+// Deletes results.
+//
+bool ResultsTree::deleteResults(const string &amp;engineName)
+{
+	unsigned int indexId = 0;
+	unsigned int engineId = m_settings.getEngineId(engineName);
+	unsigned int count = 0;
+
+	if (engineId == 0)
+	{
+		// Chances are this engine is an index
+		PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(engineName);
+		if (indexProps.m_location.empty() == false)
+		{
+			// Yes, it is
+			indexId = indexProps.m_id;
+			engineId = m_settings.getEngineId(m_settings.m_defaultBackend);
+		}
+	}
+
+	TreeModel::Children groups = m_refStore-&gt;children();
+	for (TreeModel::Children::iterator parentIter = groups.begin();
+		parentIter != groups.end(); ++parentIter)
+	{
+		TreeModel::Row row = *parentIter;
+
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+		if ((type != ResultsModelColumns::ROW_ENGINE) &amp;&amp;
+			(type != ResultsModelColumns::ROW_HOST))
+		{
+			continue;
+		}
+
+		TreeModel::Children children = parentIter-&gt;children();
+		TreeModel::Children::iterator iter = children.begin();
+		while (iter != children.end())
+		{
+			row = *iter;
+
+			type = row[m_resultsColumns.m_resultType];
+			if (((type == ResultsModelColumns::ROW_RESULT) &amp;&amp;
+				(row[m_resultsColumns.m_engines] == engineId) &amp;&amp;
+				(row[m_resultsColumns.m_indexes] == indexId)) ||
+				(type == ResultsModelColumns::ROW_OTHER))
+			{
+				TreeModel::Children::iterator nextIter = iter;
+				++nextIter;
+				++count;
+
+				// Erase this row
+				m_refStore-&gt;erase(*iter);
+				iter = nextIter;
+				continue;
+			}
+
+			// Next
+			++iter;
+		}
+	}
+
+	if (count &gt; 0)
+	{
+		onSelectionChanged();
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::deleteResults: erased &quot; &lt;&lt; count &lt;&lt; &quot; rows&quot; &lt;&lt; endl;
+#endif
+		return true;
+	}
+
+	return false;
+}
+
+//
+// Returns the number of rows.
+//
+unsigned int ResultsTree::getRowsCount(void)
+{
+	return m_refStore-&gt;children().size();
+}
+
+//
+// Refreshes the tree.
+//
+void ResultsTree::refresh(void)
+{
+	// FIXME: not sure why, but this helps with refreshing the tree
+	columns_autosize();
+}
+
+//
+// Clears the tree.
+//
+void ResultsTree::clear(void)
+{
+	// Unselect results
+	get_selection()-&gt;unselect_all();
+
+	// Remove existing rows in the tree
+	TreeModel::Children children = m_refStore-&gt;children();
+	if (children.empty() == false)
+	{
+		// Clear the groups map
+		m_resultsGroups.clear();
+
+		TreeModel::Children::iterator iter = children.begin();
+		while (iter != children.end())
+		{
+			// Erase this row
+			m_refStore-&gt;erase(*iter);
+
+			// Get the new first row
+			children = m_refStore-&gt;children();
+			iter = children.begin();
+		}
+		m_refStore-&gt;clear();
+
+		// Clear the extract
+		RefPtr&lt;TextBuffer&gt; refBuffer = m_extractTextView-&gt;get_buffer();
+		if (refBuffer)
+		{
+			refBuffer-&gt;set_text(&quot;&quot;);
+		}
+
+		onSelectionChanged();
+	}
+}
+
+//
+// Shows or hides the extract field.
+//
+void ResultsTree::showExtract(bool showExtract)
+{
+	m_showExtract = showExtract;
+	if (m_showExtract == true)
+	{
+		// Show the extract
+		m_pExtractScrolledwindow-&gt;show();
+	}
+	else
+	{
+		// Hide
+		m_pExtractScrolledwindow-&gt;hide();
+	}
+}
+
+//
+// Exports results to a file.
+//
+void ResultsTree::exportResults(const string &amp;fileName,
+	const string &amp;queryName, bool csvFormat)
+{
+	QueryProperties queryProps(queryName, &quot;&quot;);
+	ResultsExporter *pExporter = NULL;
+	unsigned int maxResultsCount = 0;
+
+	if (fileName.empty() == true)
+	{
+		return;
+	}
+
+	if (csvFormat == true)
+	{
+		pExporter = new CSVExporter(fileName,
+			queryProps);
+	}
+	else
+	{
+		pExporter = new OpenSearchExporter(fileName,
+			queryProps);
+	}
+
+	// How many results are there altogether ?
+	TreeModel::Children children = m_refStore-&gt;children();
+	if (m_groupMode == FLAT)
+	{
+		maxResultsCount = children.size();
+	}
+	else for (TreeModel::Children::iterator iter = children.begin();
+		iter != children.end(); ++iter)
+	{
+		TreeModel::Row row = *iter;
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+
+		if ((type != ResultsModelColumns::ROW_ENGINE) &amp;&amp;
+			(type != ResultsModelColumns::ROW_HOST))
+		{
+			continue;
+		}
+
+		TreeModel::Children groupChildren = iter-&gt;children();
+		maxResultsCount += groupChildren.size();
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;ResultsTree::exportResults: &quot; &lt;&lt; maxResultsCount &lt;&lt; &quot; results to export&quot; &lt;&lt; endl;
+#endif
+
+	// Start
+	pExporter-&gt;exportStart(&quot;&quot;, maxResultsCount);
+
+	if (m_groupMode == FLAT)
+	{
+		exportResults(children, queryName, pExporter);
+	}
+	else for (TreeModel::Children::iterator iter = children.begin();
+		iter != children.end(); ++iter)
+	{
+		TreeModel::Row row = *iter;
+		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
+
+		if ((type != ResultsModelColumns::ROW_ENGINE) &amp;&amp;
+			(type != ResultsModelColumns::ROW_HOST))
+		{
+			continue;
+		}
+
+		TreeModel::Children groupChildren = iter-&gt;children();
+		exportResults(groupChildren, queryName, pExporter);
+	}
+
+	// End
+	pExporter-&gt;exportEnd();
+
+	delete pExporter;
+}
+
+//
+// Exports results to a file.
+//
+void ResultsTree::exportResults(TreeModel::Children &amp;groupChildren,
+	const string &amp;queryName, ResultsExporter *pExporter)
+{
+	QueryHistory queryHistory(m_settings.getHistoryDatabaseName());
+
+	for (TreeModel::Children::iterator childIter = groupChildren.begin();
+		childIter != groupChildren.end(); ++childIter)
+	{
+		TreeModel::Row childRow = *childIter;
+		ResultsModelColumns::RowType type = childRow[m_resultsColumns.m_resultType];
+
+		if (type == ResultsModelColumns::ROW_OTHER)
+		{
+			continue;
+		}
+
+		set&lt;string&gt; engineNames, indexNames;
+		DocumentInfo result;
+		string engineName, serial(childRow[m_resultsColumns.m_serial]);
+		unsigned int engineIds = childRow[m_resultsColumns.m_engines];
+		unsigned int indexIds = childRow[m_resultsColumns.m_indexes];
+
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::exportResults: engines &quot; &lt;&lt; engineIds &lt;&lt; &quot;, indexes &quot; &lt;&lt; indexIds &lt;&lt; endl;
+#endif
+		result.deserialize(serial);
+		m_settings.getEngineNames(engineIds, engineNames);
+		if (engineNames.empty() == false)
+		{
+			// Get the first engine this result was obtained from
+			engineName = *engineNames.begin();
+			if (engineName == m_settings.m_defaultBackend)
+			{
+				m_settings.getIndexNames(indexIds, indexNames);
+				if (indexNames.empty() == false)
+				{
+					// Use the name of the first index as engine name
+					engineName = (*indexNames.begin());
+				}
+			}
+		}
+		if (m_groupMode != FLAT)
+		{
+			result.setExtract(queryHistory.getItemExtract(from_utf8(queryName),
+				engineName, result.getLocation()));
+		}
+		else
+		{
+			engineName = m_treeName;
+		}
+		result.setTimestamp(from_utf8(childRow[m_resultsColumns.m_timestamp]));
+
+		// Export this
+		if (pExporter != NULL)
+		{
+			pExporter-&gt;exportResult(engineName, result);
+		}
+	}
+}
+
+//
+// Returns the changed selection signal.
+//
+sigc::signal1&lt;void, ustring&gt;&amp; ResultsTree::getSelectionChangedSignal(void)
+{
+	return m_signalSelectionChanged;
+}
+
+//
+// Returns the double-click signal.
+//
+sigc::signal0&lt;void&gt;&amp; ResultsTree::getDoubleClickSignal(void)
+{
+	return m_signalDoubleClick;
+}
+
+//
+// Adds a new row in the results tree.
+//
+bool ResultsTree::appendResult(const ustring &amp;text, const ustring &amp;url,
+	int score, int rankDiff, bool isIndexed, bool wasViewed,
+	unsigned int docId, const ustring &amp;timestamp,
+	const string &amp;serial, unsigned int engineId,
+	unsigned int indexId, TreeModel::iterator &amp;newRowIter,
+	const TreeModel::iterator &amp;parentIter, bool noDuplicates)
+{
+	if (!parentIter)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::appendResult: no parent&quot; &lt;&lt; endl;
+#endif
+		newRowIter = m_refStore-&gt;append();
+	}
+	else
+	{
+		const TreeModel::Row parentRow = *parentIter;
+
+		// Merge duplicates within groups ?
+		if (noDuplicates == true)
+		{
+			// Look for a row with the same URL and query. For instance, in group
+			// by host mode, if a page is returned by several search engines, it
+			// should appear only once
+			TreeModel::Children children = parentRow.children();
+			if (children.empty() == false)
+			{
+				for (TreeModel::Children::iterator childIter = children.begin();
+					childIter != children.end(); ++childIter)
+				{
+					TreeModel::Row row = *childIter;
+					if (row[m_resultsColumns.m_url] == url)
+					{
+						// Update the engines column...
+						row[m_resultsColumns.m_engines] = row[m_resultsColumns.m_engines] | engineId;
+						// ...and the indexes column too
+						row[m_resultsColumns.m_indexes] = row[m_resultsColumns.m_indexes] | engineId;
+
+						newRowIter = childIter;
+						return true;
+					}
+				}
+			}
+		}
+
+		newRowIter = m_refStore-&gt;append(parentRow.children());
+	}
+
+	TreeModel::Row childRow = *newRowIter;
+	updateRow(childRow, text, url, score, engineId, indexId,
+		docId, timestamp, serial, ResultsModelColumns::ROW_RESULT, isIndexed,
+		wasViewed, rankDiff);
+
+	return true;
+}
+
+//
+// Adds a results group
+//
+bool ResultsTree::appendGroup(const string &amp;groupName, ResultsModelColumns::RowType groupType,
+	TreeModel::iterator &amp;groupIter)
+{
+	bool success = false;
+
+	// Is this group already in ?
+	std::map&lt;string, TreeModel::iterator&gt;::iterator mapIter = m_resultsGroups.find(groupName);
+	if (mapIter == m_resultsGroups.end())
+	{
+		// No, it isn't: insert a new group in the tree
+		groupIter = m_refStore-&gt;append();
+		TreeModel::Row groupRow = *groupIter;
+		updateRow(groupRow, groupName,
+			&quot;&quot;, 0, 0, 0, 0, &quot;&quot;, &quot;&quot;, groupType,
+			false, false, 0);
+
+		// Update the map
+		m_resultsGroups[groupName] = groupIter;
+		success = true;
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::appendGroup: updated map with &quot; &lt;&lt; groupName &lt;&lt; endl;
+#endif
+	}
+	else
+	{
+		// Yes, it is
+		groupIter = mapIter-&gt;second;
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::appendGroup: found &quot; &lt;&lt; groupName &lt;&lt; &quot; in map&quot; &lt;&lt; endl;
+#endif
+		success = true;
+	}
+
+	return success;
+}
+
+//
+// Updates a results group.
+//
+void ResultsTree::updateGroup(TreeModel::iterator &amp;groupIter)
+{
+	TreeModel::Row groupRow = (*groupIter);
+	int averageScore = 0;
+
+	// Check the iterator doesn't point to a result
+	ResultsModelColumns::RowType type = groupRow[m_resultsColumns.m_resultType];
+	if (type == ResultsModelColumns::ROW_RESULT)
+	{
+		return;
+	}
+
+	// Modify the &quot;score&quot; column to indicate the number of results in that group
+	TreeModel::Children groupChildren = groupIter-&gt;children();
+	if (groupChildren.empty() == false)
+	{
+		for (TreeModel::Children::iterator childIter = groupChildren.begin();
+			childIter != groupChildren.end(); ++childIter)
+		{
+			TreeModel::Row row = *childIter;
+
+			averageScore += row[m_resultsColumns.m_score];
+		}
+
+		averageScore = (int)(averageScore / groupChildren.size());
+	}
+	else
+	{
+		TreeModel::Row groupRow = *groupIter;
+		TreeModel::iterator childIter = m_refStore-&gt;append(groupRow.children());
+		TreeModel::Row childRow = *childIter;
+
+		updateRow(childRow, _(&quot;No results&quot;), &quot;&quot;, 0, 0, 0, 0,
+			&quot;&quot;, &quot;&quot;, ResultsModelColumns::ROW_OTHER, false, false, 0);
+	}
+	groupRow[m_resultsColumns.m_score] = averageScore;
+
+	// Expand this group
+	TreeModel::Path groupPath = m_refStore-&gt;get_path(groupIter);
+	expand_row(groupPath, true);
+}
+
+//
+// Updates a row.
+//
+void ResultsTree::updateRow(TreeModel::Row &amp;row, const ustring &amp;text,
+	const ustring &amp;url, int score, 	unsigned int engineId, unsigned int indexId,
+	unsigned int docId, const ustring &amp;timestamp, const string &amp;serial,
+	ResultsModelColumns::RowType resultType, bool indexed, bool viewed, int rankDiff)
+{
+	try
+	{
+		row[m_resultsColumns.m_text] = text;
+		row[m_resultsColumns.m_url] = url;
+		row[m_resultsColumns.m_score] = score;
+		row[m_resultsColumns.m_scoreText] = &quot;&quot;;
+		row[m_resultsColumns.m_engines] = engineId;
+		row[m_resultsColumns.m_indexes] = indexId;
+		row[m_resultsColumns.m_docId] = docId;
+		row[m_resultsColumns.m_resultType] = resultType;
+		row[m_resultsColumns.m_timestamp] = timestamp;
+		row[m_resultsColumns.m_timestampTime] = TimeConverter::fromTimestamp(from_utf8(timestamp));
+		row[m_resultsColumns.m_serial] = serial;
+
+		row[m_resultsColumns.m_indexed] = indexed;
+		row[m_resultsColumns.m_viewed] = viewed;
+		row[m_resultsColumns.m_rankDiff] = rankDiff;
+	}
+	catch (Error &amp;error)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::updateRow: &quot; &lt;&lt; error.what() &lt;&lt; endl;
+#endif
+	}
+	catch (...)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::updateRow: caught unknown exception&quot; &lt;&lt; endl;
+#endif
+	}
+}
+
+//
+// Retrieves the extract to show for the given row.
+//
+ustring ResultsTree::findResultsExtract(const Gtk::TreeModel::Row &amp;row)
+{
+	QueryHistory queryHistory(m_settings.getHistoryDatabaseName());
+	set&lt;string&gt; engineNames, indexNames;
+	string url(from_utf8(row[m_resultsColumns.m_url]));
+	string extract;
+	unsigned int engineIds = row[m_resultsColumns.m_engines];
+	unsigned int indexIds = row[m_resultsColumns.m_indexes];
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;ResultsTree::findResultsExtract: &quot; &lt;&lt; url &lt;&lt; &quot; has engines &quot; &lt;&lt; engineIds &lt;&lt; &quot;, indexes &quot; &lt;&lt; indexIds &lt;&lt; endl;
+#endif
+	m_settings.getEngineNames(engineIds, engineNames);
+	for (set&lt;string&gt;::const_iterator engineIter = engineNames.begin();
+		engineIter != engineNames.end(); ++engineIter)
+	{
+		string engineName(*engineIter);
+
+		indexNames.clear();
+		if (engineName == m_settings.m_defaultBackend)
+		{
+			m_settings.getIndexNames(indexIds, indexNames);
+		}
+		else
+		{
+			// That's not an index but pretend it is
+			indexNames.insert(engineName);
+		}
+
+		for (set&lt;string&gt;::const_iterator indexIter = indexNames.begin();
+			indexIter != indexNames.end(); ++indexIter)
+		{
+			// Use the name of this index as engine name
+			engineName = (*indexNames.begin());
+
+#ifdef DEBUG
+			cout &lt;&lt; &quot;ResultsTree::findResultsExtract: engine or index &quot; &lt;&lt; engineName &lt;&lt; endl;
+#endif
+			extract = queryHistory.getItemExtract(from_utf8(m_treeName), engineName, url);
+			if (extract.empty() == false)
+			{
+				// Stop here
+				return extract;
+			}
+		}
+	}
+
+	return &quot;&quot;;
+}


Property changes on: trunk/UI/GTK2/src/ResultsTree.cc
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,1656 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include &lt;ctype.h&gt;
-#include &lt;iostream&gt;
-#include &lt;gdkmm/color.h&gt;
-#include &lt;gtkmm/alignment.h&gt;
-#include &lt;gtkmm/box.h&gt;
-#include &lt;gtkmm/buttonbox.h&gt;
-#include &lt;gtkmm/image.h&gt;
-#include &lt;gtkmm/label.h&gt;
-#include &lt;gtkmm/stock.h&gt;
-#include &lt;gtkmm/cellrendererprogress.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;NLS.h&quot;
-#include &quot;StringManip.h&quot;
-#include &quot;TimeConverter.h&quot;
-#include &quot;Url.h&quot;
-#include &quot;QueryHistory.h&quot;
-#include &quot;ViewHistory.h&quot;
-#include &quot;PinotSettings.h&quot;
-#include &quot;PinotUtils.h&quot;
-#include &quot;ResultsTree.h&quot;
-
-using namespace std;
-using namespace Glib;
-using namespace Gdk;
-using namespace Gtk;
-
-ResultsTree::ResultsTree(const ustring &amp;queryName, Menu *pPopupMenu,
-	GroupByMode groupMode, PinotSettings &amp;settings) :
-	TreeView(),
-	m_treeName(queryName),
-	m_pPopupMenu(pPopupMenu),
-	m_pResultsScrolledwindow(NULL),
-	m_settings(settings),
-	m_pExtractScrolledwindow(NULL),
-	m_extractTextView(NULL),
-	m_showExtract(true),
-	m_groupMode(groupMode)
-{
-	TreeViewColumn *pColumn = NULL;
-
-	m_pResultsScrolledwindow = manage(new ScrolledWindow());
-	m_pExtractScrolledwindow = manage(new ScrolledWindow());
-	m_extractTextView = manage(new TextView());
-
-	// This is the actual results tree
-	set_events(Gdk::BUTTON_PRESS_MASK);
-	set_flags(CAN_FOCUS);
-	set_headers_clickable(true);
-	set_headers_visible(true);
-	set_rules_hint(true);
-	set_reorderable(false);
-	set_enable_search(true);
-	get_selection()-&gt;set_mode(SELECTION_MULTIPLE);
-	m_pResultsScrolledwindow-&gt;set_flags(CAN_FOCUS);
-	m_pResultsScrolledwindow-&gt;set_border_width(4);
-	m_pResultsScrolledwindow-&gt;set_shadow_type(SHADOW_NONE);
-	m_pResultsScrolledwindow-&gt;set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
-	m_pResultsScrolledwindow-&gt;property_window_placement().set_value(CORNER_TOP_LEFT);
-	m_pResultsScrolledwindow-&gt;add(*this);
-
-	// That's for the extract view
-	m_extractTextView-&gt;set_flags(CAN_FOCUS);
-	m_extractTextView-&gt;set_editable(false);
-	m_extractTextView-&gt;set_cursor_visible(false);
-	m_extractTextView-&gt;set_pixels_above_lines(0);
-	m_extractTextView-&gt;set_pixels_below_lines(0);
-	m_extractTextView-&gt;set_pixels_inside_wrap(0);
-	m_extractTextView-&gt;set_left_margin(0);
-	m_extractTextView-&gt;set_right_margin(0);
-	m_extractTextView-&gt;set_indent(0);
-	m_extractTextView-&gt;set_wrap_mode(WRAP_WORD);
-	m_extractTextView-&gt;set_justification(JUSTIFY_LEFT);
-	RefPtr&lt;TextTag&gt; refBoldTag = TextBuffer::Tag::create(&quot;bold&quot;);
-	refBoldTag-&gt;property_weight() = 900;
-	RefPtr&lt;TextBuffer&gt; refBuffer = m_extractTextView-&gt;get_buffer();
-	if (refBuffer)
-	{
-		refBuffer-&gt;get_tag_table()-&gt;add(refBoldTag); 
-	}
-	m_pExtractScrolledwindow-&gt;set_flags(CAN_FOCUS);
-	m_pExtractScrolledwindow-&gt;set_border_width(4);
-	m_pExtractScrolledwindow-&gt;set_shadow_type(SHADOW_NONE);
-	m_pExtractScrolledwindow-&gt;set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
-	m_pExtractScrolledwindow-&gt;property_window_placement().set_value(CORNER_TOP_LEFT);
-	m_pExtractScrolledwindow-&gt;add(*m_extractTextView);
-
-	// Associate the columns model to the results tree
-	m_refStore = TreeStore::create(m_resultsColumns);
-	set_model(m_refStore);
-
-	if (m_groupMode != FLAT)
-	{
-		// The first column is for the status icons
-		pColumn = new TreeViewColumn(&quot;&quot;);
-		// Pack an icon renderer for the viewed status
-		CellRendererPixbuf *pIconRenderer = new CellRendererPixbuf();
-		pColumn-&gt;pack_start(*manage(pIconRenderer), false);
-		pColumn-&gt;set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &amp;ResultsTree::renderViewStatus));
-		// Pack a second icon renderer for the indexed status
-		pIconRenderer = new CellRendererPixbuf();
-		pColumn-&gt;pack_start(*manage(pIconRenderer), false);
-		pColumn-&gt;set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &amp;ResultsTree::renderIndexStatus));
-		// And a third one for the ranking
-		pIconRenderer = new CellRendererPixbuf();
-		pColumn-&gt;pack_start(*manage(pIconRenderer), false);
-		pColumn-&gt;set_cell_data_func(*pIconRenderer, sigc::mem_fun(*this, &amp;ResultsTree::renderRanking));
-		pColumn-&gt;set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
-		append_column(*manage(pColumn));
-
-		// This is the score column
-		pColumn = new TreeViewColumn(_(&quot;Score&quot;));
-		CellRendererProgress *pProgressRenderer = new CellRendererProgress();
-		pColumn-&gt;pack_start(*manage(pProgressRenderer));
-		pColumn-&gt;add_attribute(pProgressRenderer-&gt;property_text(), m_resultsColumns.m_scoreText);
-		pColumn-&gt;add_attribute(pProgressRenderer-&gt;property_value(), m_resultsColumns.m_score);
-		pColumn-&gt;set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
-		pColumn-&gt;set_sort_column(m_resultsColumns.m_score);
-		append_column(*manage(pColumn));
-	}
-
-	// This is the title column
-	pColumn = new TreeViewColumn(_(&quot;Title&quot;));
-	CellRendererText *pTextRenderer = new CellRendererText();
-	pColumn-&gt;pack_start(*manage(pTextRenderer));
-	pColumn-&gt;set_cell_data_func(*pTextRenderer, sigc::mem_fun(*this, &amp;ResultsTree::renderTitleColumn));
-	pColumn-&gt;add_attribute(pTextRenderer-&gt;property_text(), m_resultsColumns.m_text);
-	pColumn-&gt;set_resizable(true);
-	pColumn-&gt;set_sort_column(m_resultsColumns.m_text);
-	append_column(*manage(pColumn));
-
-	// URL
-	pColumn = create_column(_(&quot;URL&quot;), m_resultsColumns.m_url, false, true, m_resultsColumns.m_url);
-	if (pColumn != NULL)
-	{
-		pColumn-&gt;set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
-		append_column(*manage(pColumn));
-	}
-
-	// The last column is for the timestamp
-	pColumn = create_column(_(&quot;Date&quot;), m_resultsColumns.m_timestamp, false, true, m_resultsColumns.m_timestampTime);
-	if (pColumn != NULL)
-	{
-		pColumn-&gt;set_sizing(TREE_VIEW_COLUMN_AUTOSIZE);
-		append_column(*manage(pColumn));
-	}
-	
-	// Connect the signals
-	signal_button_press_event().connect_notify(
-		sigc::mem_fun(*this, &amp;ResultsTree::onButtonPressEvent));
-	get_selection()-&gt;signal_changed().connect(
-		sigc::mem_fun(*this, &amp;ResultsTree::onSelectionChanged));
-
-	// Enable interactive search
-	set_search_column(m_resultsColumns.m_text.index());
-	// Control which rows can be selected
-	get_selection()-&gt;set_select_function(sigc::mem_fun(*this, &amp;ResultsTree::onSelectionSelect));
-	// Listen for style changes
-	signal_style_changed().connect_notify(sigc::mem_fun(*this, &amp;ResultsTree::onStyleChanged));
-
-	// Render the icons
-	m_indexedIconPixbuf = render_icon(Stock::INDEX, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
-	m_viewededIconPixbuf = render_icon(Stock::YES, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
-	m_upIconPixbuf = render_icon(Stock::GO_UP, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
-	m_downIconPixbuf = render_icon(Stock::GO_DOWN, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
-
-	// Show all
-	show();
-	m_pResultsScrolledwindow-&gt;show();
-	m_extractTextView-&gt;show();
-	m_pExtractScrolledwindow-&gt;show();
-}
-
-ResultsTree::~ResultsTree()
-{
-}
-
-void ResultsTree::renderViewStatus(CellRenderer *pRenderer, const TreeModel::iterator &amp;iter)
-{
-	TreeModel::Row row = *iter;
-
-	if (pRenderer == NULL)
-	{
-		return;
-	}
-
-	CellRendererPixbuf *pIconRenderer = dynamic_cast&lt;CellRendererPixbuf*&gt;(pRenderer);
-	if (pIconRenderer != NULL)
-	{
-		// Has this result been already viewed ?
-		if ((row[m_resultsColumns.m_viewed] == true) &amp;&amp;
-			(m_viewededIconPixbuf))
-		{
-			pIconRenderer-&gt;property_pixbuf() = m_viewededIconPixbuf;
-		}
-		else
-		{
-			pIconRenderer-&gt;property_pixbuf().reset_value();
-		}
-	}
-}
-
-void ResultsTree::renderIndexStatus(CellRenderer *pRenderer, const TreeModel::iterator &amp;iter)
-{
-	TreeModel::Row row = *iter;
-
-	if (pRenderer == NULL)
-	{
-		return;
-	}
-
-	CellRendererPixbuf *pIconRenderer = dynamic_cast&lt;CellRendererPixbuf*&gt;(pRenderer);
-	if (pIconRenderer != NULL)
-	{
-		// Is this result indexed ?
-		if ((row[m_resultsColumns.m_indexed] == true) &amp;&amp;
-			(m_indexedIconPixbuf))
-		{
-			pIconRenderer-&gt;property_pixbuf() = m_indexedIconPixbuf;
-		}
-		else
-		{
-			pIconRenderer-&gt;property_pixbuf().reset_value();
-		}
-	}
-}
-
-void ResultsTree::renderRanking(CellRenderer *pRenderer, const TreeModel::iterator &amp;iter)
-{
-	TreeModel::Row row = *iter;
-
-	if (pRenderer == NULL)
-	{
-		return;
-	}
-
-	CellRendererPixbuf *pIconRenderer = dynamic_cast&lt;CellRendererPixbuf*&gt;(pRenderer);
-	if (pIconRenderer != NULL)
-	{
-		int rankDiff = row[m_resultsColumns.m_rankDiff];
-
-		// Has this result's score changed ?
-		if ((rankDiff &gt; 0) &amp;&amp;
-			(rankDiff != 666))
-		{
-			pIconRenderer-&gt;property_pixbuf() = m_upIconPixbuf;
-		}
-		else if (rankDiff &lt; 0)
-		{
-			pIconRenderer-&gt;property_pixbuf() = m_downIconPixbuf;
-		}
-		else
-		{
-			pIconRenderer-&gt;property_pixbuf().reset_value();
-		}
-	}
-}
-
-void ResultsTree::renderTitleColumn(CellRenderer *pRenderer, const TreeModel::iterator &amp;iter)
-{
-	TreeModel::Row row = *iter;
-
-	if (pRenderer == NULL)
-	{
-		return;
-	}
-
-	CellRendererText *pTextRenderer = dynamic_cast&lt;CellRendererText*&gt;(pRenderer);
-	if (pTextRenderer != NULL)
-	{
-		// Is this result new ?
-		if (row[m_resultsColumns.m_rankDiff] == 666)
-		{
-			Color newColour;
-
-			newColour.set_red(m_settings.m_newResultsColourRed);
-			newColour.set_green(m_settings.m_newResultsColourGreen);
-			newColour.set_blue(m_settings.m_newResultsColourBlue);
-
-			// Change the row's background
-			pTextRenderer-&gt;property_background_gdk() = newColour;
-		}
-		else
-		{
-			pTextRenderer-&gt;property_background_gdk().reset_value();
-		}
-
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		if ((type == ResultsModelColumns::ROW_ENGINE) ||
-			(type == ResultsModelColumns::ROW_HOST))
-		{
-			ustring markup(&quot;&lt;b&gt;&quot;);
-			markup += row[m_resultsColumns.m_text];
-			markup += &quot;&lt;/b&gt;&quot;;
-			pTextRenderer-&gt;property_markup() = markup;
-		}
-	}
-}
-
-void ResultsTree::onButtonPressEvent(GdkEventButton *ev)
-{
-	// Check for popup click
-	if ((ev-&gt;type == GDK_BUTTON_PRESS) &amp;&amp;
-		(ev-&gt;button == 3) )
-	{
-		if (m_pPopupMenu != NULL)
-		{
-			m_pPopupMenu-&gt;popup(ev-&gt;button, ev-&gt;time);
-		}
-	}
-	// Check for double clicks
-	else if (ev-&gt;type == GDK_2BUTTON_PRESS)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ResultsTree::onButtonPressEvent: double click on button &quot; &lt;&lt; ev-&gt;button &lt;&lt; endl;
-#endif
-		m_signalDoubleClick();
-	}
-}
-
-void ResultsTree::onSelectionChanged(void)
-{
-	m_signalSelectionChanged(m_treeName);
-}
-
-bool ResultsTree::onSelectionSelect(const RefPtr&lt;TreeModel&gt;&amp; model,
-	const TreeModel::Path&amp; node_path, bool path_currently_selected)
-{
-	const TreeModel::iterator iter = model-&gt;get_iter(node_path);
-	const TreeModel::Row row = *iter;
-
-	// In flat mode, don't bother about the extract
-	if ((path_currently_selected == false) &amp;&amp;
-		(m_groupMode != FLAT))
-	{
-		// Is this an actual result ?
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		if (type != ResultsModelColumns::ROW_RESULT)
-		{
-			return true;
-		}
-
-		RefPtr&lt;TextBuffer&gt; refBuffer = m_extractTextView-&gt;get_buffer();
-		if (refBuffer)
-		{
-			ustring extract(findResultsExtract(row));
-			ustring::size_type textPos = 0, boldPos = extract.find(&quot;&lt;b&gt;&quot;);
-
-			// Clear the extract
-			refBuffer-&gt;set_text(&quot;&quot;);
-
-#ifdef DEBUG
-			cout &lt;&lt; &quot;ResultsTree::onSelectionSelect: extract for &quot; &lt;&lt; row[m_resultsColumns.m_url] &lt;&lt; endl;
-#endif
-			if (boldPos == ustring::npos)
-			{
-				refBuffer-&gt;set_text(extract);
-			}
-			else
-			{
-				TextBuffer::iterator bufferPos = refBuffer-&gt;begin();
-
-				while (boldPos != ustring::npos)
-				{
-					bufferPos = refBuffer-&gt;insert(bufferPos, extract.substr(textPos, boldPos - textPos));
-
-					textPos = boldPos + 3;
-					boldPos = extract.find(&quot;&lt;/b&gt;&quot;, textPos);
-					if (boldPos == ustring::npos)
-					{
-						continue;
-					}
-					bufferPos = refBuffer-&gt;insert_with_tag(bufferPos, extract.substr(textPos, boldPos - textPos), &quot;bold&quot;);
-
-					// Next
-					textPos = boldPos + 4;
-					boldPos = extract.find(&quot;&lt;b&gt;&quot;, textPos);
-				}
-
-				if (textPos + 1 &lt; extract.length())
-				{
-					bufferPos = refBuffer-&gt;insert(bufferPos, extract.substr(textPos, boldPos - textPos));
-				}
-			}
-		}
-	}
-
-	return true;
-}
-
-void ResultsTree::onStyleChanged(const RefPtr&lt;Style&gt; &amp;previous_style)
-{
-#ifdef DEBUG
-	cout &lt;&lt; &quot;ResultsTree::onStyleChanged: called&quot; &lt;&lt; endl;
-#endif
-	// FIXME: find better icons :-)
-	m_indexedIconPixbuf = render_icon(Stock::INDEX, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
-	m_viewededIconPixbuf = render_icon(Stock::YES, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
-	m_upIconPixbuf = render_icon(Stock::GO_UP, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
-	m_downIconPixbuf = render_icon(Stock::GO_DOWN, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
-}
-
-//
-// Returns the results scrolled window.
-//
-ScrolledWindow *ResultsTree::getResultsScrolledWindow(void) const
-{
-	return m_pResultsScrolledwindow;
-}
-
-//
-// Returns the extract scrolled window.
-//
-ScrolledWindow *ResultsTree::getExtractScrolledWindow(void) const
-{
-	return m_pExtractScrolledwindow;
-}
-
-//
-// Returns the extract tree.
-//
-bool ResultsTree::focusOnExtract(void) const
-{
-	return m_extractTextView-&gt;is_focus();
-}
-
-//
-// Returns the extract.
-//
-ustring ResultsTree::getExtract(void) const
-{
-	ustring text;
-
-	RefPtr&lt;TextBuffer&gt; refBuffer = m_extractTextView-&gt;get_buffer();
-	if (refBuffer)
-	{
-		text = refBuffer-&gt;get_text();
-	}
-
-	return text;
-}
-
-//
-// Adds a set of results.
-// Returns true if something was added to the tree.
-//
-bool ResultsTree::addResults(const string &amp;engineName, const vector&lt;DocumentInfo&gt; &amp;resultsList,
-	const string &amp;charset, bool updateHistory)
-{
-	std::map&lt;string, TreeModel::iterator&gt; updatedGroups;
-	ResultsModelColumns::RowType rootType;
-	unsigned int count = 0;
-
-	// What's the grouping criteria ?
-	if (m_groupMode == BY_ENGINE)
-	{
-		// By search engine
-		rootType = ResultsModelColumns::ROW_ENGINE;
-	}
-	else if (m_groupMode == BY_HOST)
-	{
-		// By host
-		rootType = ResultsModelColumns::ROW_HOST;
-	}
-
-	unsigned int indexId = 0;
-	unsigned int engineId = 0;
-
-	// Find out what the search engine ID is
-	if (engineName.empty() == false)
-	{
-		engineId = m_settings.getEngineId(engineName);
-		if (engineId == 0)
-		{
-			// Chances are this engine is an index
-			PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(engineName);
-			if (indexProps.m_location.empty() == false)
-			{
-				// Yes, it is
-				indexId = indexProps.m_id;
-				engineId = m_settings.getEngineId(m_settings.m_defaultBackend);
-#ifdef DEBUG
-				cout &lt;&lt; &quot;ResultsTree::addResults: engine is index &quot; &lt;&lt; engineName &lt;&lt; &quot; &quot; &lt;&lt; indexId &lt;&lt; &quot; &quot; &lt;&lt; engineId &lt;&lt; endl;
-#endif
-			}
-#ifdef DEBUG
-			else cout &lt;&lt; &quot;ResultsTree::addResults: &quot; &lt;&lt; engineName &lt;&lt; &quot; is not an index&quot; &lt;&lt;  endl;
-#endif
-		}
-#ifdef DEBUG
-		else cout &lt;&lt; &quot;ResultsTree::addResults: ID for engine &quot; &lt;&lt; engineName &lt;&lt; &quot; is &quot; &lt;&lt; engineId &lt;&lt;  endl;
-#endif
-	}
-
-	QueryHistory queryHistory(m_settings.getHistoryDatabaseName());
-	ViewHistory viewHistory(m_settings.getHistoryDatabaseName());
-	set&lt;time_t&gt; latestRuns;
-	time_t secondLastRunTime = 0;
-	bool isNewQuery = false;
-
-	// Is this a new query ?
-	if ((queryHistory.getLatestRuns(m_treeName, engineName, 2, latestRuns) == false) ||
-		(latestRuns.empty() == true))
-	{
-		isNewQuery = true;
-	}
-	else
-	{
-		set&lt;time_t&gt;::const_iterator runIter = latestRuns.begin();
-
-		// We only need to keep the last two runs
-		if (runIter != latestRuns.end())
-		{
-			++runIter;
-			if (runIter != latestRuns.end())
-			{
-				secondLastRunTime = (*runIter);
-			}
-		}
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;ResultsTree::addResults: &quot; &lt;&lt; resultsList.size() &lt;&lt; &quot; results with charset &quot; &lt;&lt; charset
-		&lt;&lt; &quot;, second last run &quot; &lt;&lt; secondLastRunTime &lt;&lt; endl;
-#endif
-
-	// Look at the results list
-	for (vector&lt;DocumentInfo&gt;::const_iterator resultIter = resultsList.begin();
-		resultIter != resultsList.end(); ++resultIter)
-	{
-		ustring title(to_utf8(resultIter-&gt;getTitle(), charset));
-		ustring location(to_utf8(resultIter-&gt;getLocation(), charset));
-		ustring timestamp(to_utf8(resultIter-&gt;getTimestamp()));
-		ustring extract(to_utf8(resultIter-&gt;getExtract(), charset));
-		string groupName;
-		TreeModel::iterator groupIter;
-		float currentScore = resultIter-&gt;getScore();
-		int rankDiff = 0;
-
-		if (m_groupMode != FLAT)
-		{
-			// What group should the result go to ?
-			if (rootType == ResultsModelColumns::ROW_HOST)
-			{
-				Url urlObj(location);
-				groupName = urlObj.getHost();
-			}
-			else
-			{
-				groupName = engineName;
-			}
-			// Add the group or get its position if it's already in
-			appendGroup(groupName, rootType, groupIter);
-
-			// Has the result's ranking changed ?
-			float oldestScore = 0;
-			float previousScore = queryHistory.hasItem(m_treeName, engineName,
-				location, oldestScore);
-#ifdef DEBUG
-			cout &lt;&lt; &quot;ResultsTree::addResults: &quot; &lt;&lt; location &lt;&lt; &quot; has scores &quot;
-				&lt;&lt; previousScore &lt;&lt; &quot;, &quot; &lt;&lt; oldestScore &lt;&lt; endl;
-#endif
-			if (previousScore &gt; 0)
-			{
-				// Yes, it has
-				rankDiff = (int)(currentScore - previousScore);
-			}
-			else
-			{
-				// New results are displayed as such only if the query has already been run on the engine
-				if (isNewQuery == false)
-				{
-					// This is a magic value :-)
-					rankDiff = 666;
-				}
-			}
-
-			if (updateHistory == true)
-			{
-				queryHistory.insertItem(m_treeName, engineName, location,
-					title, extract, currentScore);
-			}
-		}
-
-		++count;
-
-		// We already got indexId from PinotSettings
-		unsigned int docIndexId = 0;
-		unsigned int docId = resultIter-&gt;getIsIndexed(docIndexId);
-		bool isIndexed = false;
-
-		if (docId &gt; 0)
-		{
-			isIndexed = true;
-		}
-
-		// Has it been already viewed ?
-		bool wasViewed = viewHistory.hasItem(location);
-
-		// OK, add a row for this result within the group
-		TreeModel::iterator titleIter;
-		if (appendResult(title, location, (int)currentScore, rankDiff, isIndexed, wasViewed,
-			docId, timestamp, resultIter-&gt;serialize(),
-			engineId, indexId, titleIter, groupIter, true) == true)
-		{
-#ifdef DEBUG
-			cout &lt;&lt; &quot;ResultsTree::addResults: added row for result &quot; &lt;&lt; count
-				&lt;&lt; &quot;, &quot; &lt;&lt; currentScore &lt;&lt; &quot;, &quot; &lt;&lt; isIndexed &lt;&lt; &quot; &quot; &lt;&lt; docId
-				&lt;&lt; &quot; &quot; &lt;&lt; indexId &lt;&lt; endl;
-#endif
-
-			if (groupIter)
-			{
-				// Update this map, so that we know which groups need updating
-				updatedGroups[groupName] = groupIter;
-			}
-		}
-	}
-
-	// Remove older items ?
-	if ((isNewQuery == false) &amp;&amp;
-		(updateHistory == true))
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ResultsTree::addResults: removing items for &quot; &lt;&lt; m_treeName
-			&lt;&lt; &quot;, &quot; &lt;&lt; engineName &lt;&lt; &quot; older than &quot; &lt;&lt; secondLastRunTime &lt;&lt; endl;
-#endif
-		queryHistory.deleteItems(m_treeName, engineName, secondLastRunTime);
-	}
-
-	if (count &gt; 0)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ResultsTree::addResults: &quot; &lt;&lt; updatedGroups.size() &lt;&lt; &quot; groups to update&quot; &lt;&lt; endl;
-#endif
-		// Update the groups to which we have added results
-		for (std::map&lt;string, TreeModel::iterator&gt;::iterator mapIter = updatedGroups.begin();
-			mapIter != updatedGroups.end(); mapIter++)
-		{
-			TreeModel::iterator groupIter = mapIter-&gt;second;
-			updateGroup(groupIter);
-		}
-
-		return true;
-	}
-	else if (m_groupMode == BY_ENGINE)
-	{
-		// If this didn't return any result, add an empty group
-		TreeModel::iterator groupIter;
-		appendGroup(engineName, rootType, groupIter);
-		updateGroup(groupIter);
-
-		return true;
-	}
-
-	return false;
-}
-
-//
-// Sets how results are grouped.
-//
-void ResultsTree::setGroupMode(GroupByMode groupMode)
-{
-	ResultsModelColumns::RowType currentType, newType;
-
-	if (m_groupMode == FLAT)
-	{
-		// No change possible
-		return;
-	}
-
-	if (m_groupMode == groupMode)
-	{
-		// No change
-		return;
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;ResultsTree::setGroupMode: set to &quot; &lt;&lt; groupMode &lt;&lt; endl;
-#endif
-	m_groupMode = groupMode;
-
-	// Do we need to update the tree ?
-	TreeModel::Children children = m_refStore-&gt;children();
-	if (children.empty() == true)
-	{
-		return;
-	}
-
-	// What's the new grouping criteria ?
-	if (m_groupMode == BY_ENGINE)
-	{
-		// By search engine
-		currentType = ResultsModelColumns::ROW_HOST;
-		newType = ResultsModelColumns::ROW_ENGINE;
-	}
-	else
-	{
-		// By host
-		currentType = ResultsModelColumns::ROW_ENGINE;
-		newType = ResultsModelColumns::ROW_HOST;
-	}
-
-	// Clear the map
-	m_resultsGroups.clear();
-
-	// Unselect results
-	get_selection()-&gt;unselect_all();
-
-	TreeModel::Children::iterator iter = children.begin();
-	while (iter != children.end())
-	{
-		TreeModel::Row row = *iter;
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ResultsTree::setGroupMode: looking at &quot; &lt;&lt; row[m_resultsColumns.m_url] &lt;&lt; endl;
-#endif
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		// Skip new type and other rows
-		if ((type == newType) ||
-			(type == ResultsModelColumns::ROW_OTHER))
-		{
-			iter++;
-			continue;
-		}
-
-		TreeModel::Children groupChildren = iter-&gt;children();
-		TreeModel::Children::iterator childIter = groupChildren.begin();
-		// Type ROW_RESULT
-		while (childIter != groupChildren.end())
-		{
-			TreeModel::Row childRow = *childIter;
-			TreeModel::iterator groupIter, newIter;
-			bool success = false;
-
-			type = childRow[m_resultsColumns.m_resultType];
-			if (type == ResultsModelColumns::ROW_OTHER)
-			{
-				TreeModel::Children::iterator nextChildIter = childIter;
-				++nextChildIter;
-
-				// Erase this row
-				m_refStore-&gt;erase(childIter);
-				childIter = nextChildIter;
-				continue;
-			}
-
-			// We will need the URL and engines columns in all cases
-			string url(from_utf8(childRow[m_resultsColumns.m_url]));
-			unsigned int engineIds = childRow[m_resultsColumns.m_engines];
-			unsigned int indexIds = childRow[m_resultsColumns.m_indexes];
-
-			// Get the name of the group this should go into
-			if (m_groupMode == BY_HOST)
-			{
-				Url urlObj(url);
-#ifdef DEBUG
-				cout &lt;&lt; &quot;ResultsTree::setGroupMode: row &quot; &lt;&lt; url &lt;&lt; endl;
-#endif
-				// Add group
-				if (appendGroup(urlObj.getHost(), newType, groupIter) == true)
-				{
-					// Add result
-					success = appendResult(childRow[m_resultsColumns.m_text],
-						childRow[m_resultsColumns.m_url],
-						childRow[m_resultsColumns.m_score],
-						childRow[m_resultsColumns.m_rankDiff],
-						childRow[m_resultsColumns.m_indexed],
-						childRow[m_resultsColumns.m_viewed],
-						childRow[m_resultsColumns.m_docId],
-						childRow[m_resultsColumns.m_timestamp],
-						childRow[m_resultsColumns.m_serial],
-						engineIds, indexIds,
-						newIter, groupIter, true);
-				}
-			}
-			else
-			{
-				// Look at the engines column and see which engines this result is for
-				set&lt;string&gt; engineNames;
-				m_settings.getEngineNames(engineIds, engineNames);
-				if (engineNames.empty() == false)
-				{
-#ifdef DEBUG
-					cout &lt;&lt; &quot;ResultsTree::setGroupMode: row is for &quot; &lt;&lt; engineNames.size() &lt;&lt; &quot; engine(s)&quot; &lt;&lt; endl;
-#endif
-					// Are there indexes in the list ?
-					set&lt;string&gt;::iterator backendIter = engineNames.find(m_settings.m_defaultBackend);
-					if ((backendIter != engineNames.end()) &amp;&amp;
-						(indexIds &gt; 0))
-					{
-						// Erase this
-						engineNames.erase(backendIter);
-#ifdef DEBUG
-						cout &lt;&lt; &quot;ResultsTree::setGroupMode: row is for index(es) &quot; &lt;&lt; indexIds &lt;&lt; endl;
-#endif
-
-						// Add entries for each index name so that we can loop once on engine names
-						set&lt;string&gt; indexNames;
-						m_settings.getIndexNames(indexIds, indexNames);
-						for (set&lt;string&gt;::iterator indexIter = indexNames.begin();
-							indexIter != indexNames.end(); ++indexIter)
-						{
-							string indexName(*indexIter);
-							engineNames.insert(indexName);
-#ifdef DEBUG
-							cout &lt;&lt; &quot;ResultsTree::setGroupMode: row is for index &quot; &lt;&lt; indexName &lt;&lt; endl;
-#endif
-						}
-					}
-
-					for (set&lt;string&gt;::iterator engineIter = engineNames.begin();
-						engineIter != engineNames.end(); ++engineIter)
-					{
-						string engineName(*engineIter);
-						unsigned int indexId = 0;
-						unsigned int engineId = m_settings.getEngineId(engineName);
-
-						if (engineId == 0)
-						{
-							// This is actually an index, not an engine...
-							PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(engineName);
-							if (indexProps.m_location.empty() == false)
-							{
-								engineId = m_settings.getEngineId(m_settings.m_defaultBackend);
-							}
-#ifdef DEBUG
-							cout &lt;&lt; &quot;ResultsTree::setGroupMode: index &quot; &lt;&lt; indexId &lt;&lt; endl;
-#endif
-						}
-#ifdef DEBUG
-						else cout &lt;&lt; &quot;ResultsTree::setGroupMode: no index&quot; &lt;&lt; endl;
-#endif
-
-						// Add group
-						if (appendGroup(engineName, newType, groupIter) == true)
-						{
-							// Add result
-							appendResult(childRow[m_resultsColumns.m_text],
-								childRow[m_resultsColumns.m_url],
-								childRow[m_resultsColumns.m_score],
-								childRow[m_resultsColumns.m_rankDiff],
-								childRow[m_resultsColumns.m_indexed],
-								childRow[m_resultsColumns.m_viewed],
-								childRow[m_resultsColumns.m_docId],
-								childRow[m_resultsColumns.m_timestamp],
-								childRow[m_resultsColumns.m_serial],
-								engineId, indexId,
-								newIter, groupIter, true);
-#ifdef DEBUG
-							cout &lt;&lt; &quot;ResultsTree::setGroupMode: row for &quot; &lt;&lt; engineName &lt;&lt; endl;
-#endif
-						}
-					}
-
-					// FIXME: make sure at least one row was added
-					success = true;
-				}
-			}
-
-			if (success == true)
-			{
-				// Delete it
-				m_refStore-&gt;erase(*childIter);
-				childIter = groupChildren.begin();
-			}
-			else
-			{
-				// Don't delete anything then, just go to the next child
-				childIter++;
-			}
-		}
-
-		// Erase this row
-		m_refStore-&gt;erase(*iter);
-
-		// Get the new first row, that way we don't have to worry about iterators validity
-		iter = children.begin();
-	}
-
-	for (std::map&lt;string, TreeModel::iterator&gt;::iterator mapIter = m_resultsGroups.begin();
-		mapIter != m_resultsGroups.end(); mapIter++)
-	{
-		TreeModel::iterator groupIter = mapIter-&gt;second;
-		updateGroup(groupIter);
-	}
-
-	onSelectionChanged();
-}
-
-//
-// Gets the first selected item's URL.
-//
-ustring ResultsTree::getFirstSelectionURL(void)
-{
-	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
-	if (selectedItems.empty() == true)
-	{
-		return &quot;&quot;;
-	}
-
-	list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
-	TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
-	TreeModel::Row row = *iter;
-
-	return row[m_resultsColumns.m_url];
-}
-
-//
-// Gets a list of selected items.
-//
-bool ResultsTree::getSelection(vector&lt;DocumentInfo&gt; &amp;resultsList, bool skipIndexed)
-{
-	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
-	if (selectedItems.empty() == true)
-	{
-		return false;
-	}
-
-	// Go through selected items
-	for (list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
-		itemPath != selectedItems.end(); ++itemPath)
-	{
-		TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
-		TreeModel::Row row = *iter;
-
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		if (type != ResultsModelColumns::ROW_RESULT)
-		{
-			continue;
-		}
-
-		bool isIndexed = row[m_resultsColumns.m_indexed];
-		if ((skipIndexed == false) ||
-			(isIndexed == false))
-		{
-			DocumentInfo current;
-			string serial(row[m_resultsColumns.m_serial]);
-
-			current.deserialize(serial);
-
-			if (isIndexed == true)
-			{
-				set&lt;string&gt; indexNames;
-				unsigned int indexIds = row[m_resultsColumns.m_indexes];
-
-				m_settings.getIndexNames(indexIds, indexNames);
-				// Any internal index in there ?
-				for (set&lt;string&gt;::iterator indexIter = indexNames.begin(); indexIter != indexNames.end(); ++indexIter)
-				{
-					PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(*indexIter);
-					if (indexProps.m_internal == true)
-					{
-#ifdef DEBUG
-						cout &lt;&lt; &quot;ResultsTree::getSelection: result in internal index &quot; &lt;&lt; *indexIter &lt;&lt; endl;
-#endif
-						current.setIsIndexed(indexProps.m_id, row[m_resultsColumns.m_docId]);
-						break;
-					}
-				}
-			}
-
-			resultsList.push_back(current);
-		}
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;ResultsTree::getSelection: &quot; &lt;&lt; resultsList.size() &lt;&lt; &quot; results selected&quot; &lt;&lt; endl;
-#endif
-
-	return true;
-}
-
-//
-// Sets the selected items' state.
-//
-void ResultsTree::setSelectionState(bool viewed)
-{
-	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
-	if (selectedItems.empty() == true)
-	{
-		return;
-	}
-
-	// Go through selected items
-	for (list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
-		itemPath != selectedItems.end(); ++itemPath)
-	{
-		TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
-		TreeModel::Row row = *iter;
-  
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		if (type != ResultsModelColumns::ROW_RESULT)
-		{
-			continue;
-		}
-
-		if (viewed == true)
-		{
-			row[m_resultsColumns.m_viewed] = true;
-		}
-	}
-}
-
-//
-// Updates a result's properties.
-//
-bool ResultsTree::updateResult(const DocumentInfo &amp;result)
-{
-	unsigned int indexId = 0;
-	unsigned int docId = result.getIsIndexed(indexId);
-
-	if (docId == 0)
-	{
-		return false;
-	}
-
-	// Go through the list
-	TreeModel::Children children = m_refStore-&gt;children();
-	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
-	{
-		TreeModel::Row row = *iter;
-
-		if (docId == row[m_resultsColumns.m_docId])
-		{
-			// FIXME: title, location should be converted based on the result's charset !
-			updateRow(row, result.getTitle(), result.getLocation(),
-				row[m_resultsColumns.m_score], row[m_resultsColumns.m_engines],
-				row[m_resultsColumns.m_indexes], docId,
-				to_utf8(result.getTimestamp()), result.serialize(),
-				ResultsModelColumns::ROW_RESULT,
-				row[m_resultsColumns.m_indexed], row[m_resultsColumns.m_viewed],
-				row[m_resultsColumns.m_rankDiff]);
-
-			return true;
-		}
-	}
-
-	return false;
-}
-
-//
-// Deletes the current selection.
-//
-bool ResultsTree::deleteSelection(void)
-{
-	bool empty = false;
-
-	// Go through selected items
-	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
-	list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
-	while (itemPath != selectedItems.end())
-	{
-		TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
-		TreeModel::Row row = *iter;
-		TreeModel::iterator parentIter;
-		bool updateParent = false;
-
-		// This could be a group that's in the map and should be removed first
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		if (type != ResultsModelColumns::ROW_RESULT)
-		{
-			string groupName(from_utf8(row[m_resultsColumns.m_text]));
-			std::map&lt;string, TreeModel::iterator&gt;::iterator mapIter = m_resultsGroups.find(groupName);
-			if (mapIter != m_resultsGroups.end())
-			{
-				m_resultsGroups.erase(mapIter);
-#ifdef DEBUG
-				cout &lt;&lt; &quot;ResultsTree::deleteSelection: erased group &quot; &lt;&lt; groupName &lt;&lt; endl;
-#endif
-			}
-		}
-		else if (m_groupMode != FLAT)
-		{
-			// This item is a result
-			parentIter = row.parent();
-			updateParent = true;
-		}
-
-		// Unselect and erase
-		get_selection()-&gt;unselect(iter);
-		m_refStore-&gt;erase(row);
-
-		// Update group ?
-		if (updateParent == true)
-		{
-			// Update the group this result belongs to
-			updateGroup(parentIter);
-		}
-
-		selectedItems = get_selection()-&gt;get_selected_rows();
-		itemPath = selectedItems.begin();
-	}
-
-	TreeModel::Children children = m_refStore-&gt;children();
-	empty = children.empty();
-
-	refresh();
-
-	return empty;
-}
-
-//
-// Deletes results.
-//
-bool ResultsTree::deleteResults(const string &amp;engineName)
-{
-	unsigned int indexId = 0;
-	unsigned int engineId = m_settings.getEngineId(engineName);
-	unsigned int count = 0;
-
-	if (engineId == 0)
-	{
-		// Chances are this engine is an index
-		PinotSettings::IndexProperties indexProps = m_settings.getIndexPropertiesByName(engineName);
-		if (indexProps.m_location.empty() == false)
-		{
-			// Yes, it is
-			indexId = indexProps.m_id;
-			engineId = m_settings.getEngineId(m_settings.m_defaultBackend);
-		}
-	}
-
-	TreeModel::Children groups = m_refStore-&gt;children();
-	for (TreeModel::Children::iterator parentIter = groups.begin();
-		parentIter != groups.end(); ++parentIter)
-	{
-		TreeModel::Row row = *parentIter;
-
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-		if ((type != ResultsModelColumns::ROW_ENGINE) &amp;&amp;
-			(type != ResultsModelColumns::ROW_HOST))
-		{
-			continue;
-		}
-
-		TreeModel::Children children = parentIter-&gt;children();
-		TreeModel::Children::iterator iter = children.begin();
-		while (iter != children.end())
-		{
-			row = *iter;
-
-			type = row[m_resultsColumns.m_resultType];
-			if (((type == ResultsModelColumns::ROW_RESULT) &amp;&amp;
-				(row[m_resultsColumns.m_engines] == engineId) &amp;&amp;
-				(row[m_resultsColumns.m_indexes] == indexId)) ||
-				(type == ResultsModelColumns::ROW_OTHER))
-			{
-				TreeModel::Children::iterator nextIter = iter;
-				++nextIter;
-				++count;
-
-				// Erase this row
-				m_refStore-&gt;erase(*iter);
-				iter = nextIter;
-				continue;
-			}
-
-			// Next
-			++iter;
-		}
-	}
-
-	if (count &gt; 0)
-	{
-		onSelectionChanged();
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ResultsTree::deleteResults: erased &quot; &lt;&lt; count &lt;&lt; &quot; rows&quot; &lt;&lt; endl;
-#endif
-		return true;
-	}
-
-	return false;
-}
-
-//
-// Returns the number of rows.
-//
-unsigned int ResultsTree::getRowsCount(void)
-{
-	return m_refStore-&gt;children().size();
-}
-
-//
-// Refreshes the tree.
-//
-void ResultsTree::refresh(void)
-{
-	// FIXME: not sure why, but this helps with refreshing the tree
-	columns_autosize();
-}
-
-//
-// Clears the tree.
-//
-void ResultsTree::clear(void)
-{
-	// Unselect results
-	get_selection()-&gt;unselect_all();
-
-	// Remove existing rows in the tree
-	TreeModel::Children children = m_refStore-&gt;children();
-	if (children.empty() == false)
-	{
-		// Clear the groups map
-		m_resultsGroups.clear();
-
-		TreeModel::Children::iterator iter = children.begin();
-		while (iter != children.end())
-		{
-			// Erase this row
-			m_refStore-&gt;erase(*iter);
-
-			// Get the new first row
-			children = m_refStore-&gt;children();
-			iter = children.begin();
-		}
-		m_refStore-&gt;clear();
-
-		// Clear the extract
-		RefPtr&lt;TextBuffer&gt; refBuffer = m_extractTextView-&gt;get_buffer();
-		if (refBuffer)
-		{
-			refBuffer-&gt;set_text(&quot;&quot;);
-		}
-
-		onSelectionChanged();
-	}
-}
-
-//
-// Shows or hides the extract field.
-//
-void ResultsTree::showExtract(bool showExtract)
-{
-	m_showExtract = showExtract;
-	if (m_showExtract == true)
-	{
-		// Show the extract
-		m_pExtractScrolledwindow-&gt;show();
-	}
-	else
-	{
-		// Hide
-		m_pExtractScrolledwindow-&gt;hide();
-	}
-}
-
-//
-// Exports results to a file.
-//
-void ResultsTree::exportResults(const string &amp;fileName,
-	const string &amp;queryName, bool csvFormat)
-{
-	QueryProperties queryProps(queryName, &quot;&quot;);
-	ResultsExporter *pExporter = NULL;
-	unsigned int maxResultsCount = 0;
-
-	if (fileName.empty() == true)
-	{
-		return;
-	}
-
-	if (csvFormat == true)
-	{
-		pExporter = new CSVExporter(fileName,
-			queryProps);
-	}
-	else
-	{
-		pExporter = new OpenSearchExporter(fileName,
-			queryProps);
-	}
-
-	// How many results are there altogether ?
-	TreeModel::Children children = m_refStore-&gt;children();
-	if (m_groupMode == FLAT)
-	{
-		maxResultsCount = children.size();
-	}
-	else for (TreeModel::Children::iterator iter = children.begin();
-		iter != children.end(); ++iter)
-	{
-		TreeModel::Row row = *iter;
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-
-		if ((type != ResultsModelColumns::ROW_ENGINE) &amp;&amp;
-			(type != ResultsModelColumns::ROW_HOST))
-		{
-			continue;
-		}
-
-		TreeModel::Children groupChildren = iter-&gt;children();
-		maxResultsCount += groupChildren.size();
-	}
-#ifdef DEBUG
-	cout &lt;&lt; &quot;ResultsTree::exportResults: &quot; &lt;&lt; maxResultsCount &lt;&lt; &quot; results to export&quot; &lt;&lt; endl;
-#endif
-
-	// Start
-	pExporter-&gt;exportStart(&quot;&quot;, maxResultsCount);
-
-	if (m_groupMode == FLAT)
-	{
-		exportResults(children, queryName, pExporter);
-	}
-	else for (TreeModel::Children::iterator iter = children.begin();
-		iter != children.end(); ++iter)
-	{
-		TreeModel::Row row = *iter;
-		ResultsModelColumns::RowType type = row[m_resultsColumns.m_resultType];
-
-		if ((type != ResultsModelColumns::ROW_ENGINE) &amp;&amp;
-			(type != ResultsModelColumns::ROW_HOST))
-		{
-			continue;
-		}
-
-		TreeModel::Children groupChildren = iter-&gt;children();
-		exportResults(groupChildren, queryName, pExporter);
-	}
-
-	// End
-	pExporter-&gt;exportEnd();
-
-	delete pExporter;
-}
-
-//
-// Exports results to a file.
-//
-void ResultsTree::exportResults(TreeModel::Children &amp;groupChildren,
-	const string &amp;queryName, ResultsExporter *pExporter)
-{
-	QueryHistory queryHistory(m_settings.getHistoryDatabaseName());
-
-	for (TreeModel::Children::iterator childIter = groupChildren.begin();
-		childIter != groupChildren.end(); ++childIter)
-	{
-		TreeModel::Row childRow = *childIter;
-		ResultsModelColumns::RowType type = childRow[m_resultsColumns.m_resultType];
-
-		if (type == ResultsModelColumns::ROW_OTHER)
-		{
-			continue;
-		}
-
-		set&lt;string&gt; engineNames, indexNames;
-		DocumentInfo result;
-		string engineName, serial(childRow[m_resultsColumns.m_serial]);
-		unsigned int engineIds = childRow[m_resultsColumns.m_engines];
-		unsigned int indexIds = childRow[m_resultsColumns.m_indexes];
-
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ResultsTree::exportResults: engines &quot; &lt;&lt; engineIds &lt;&lt; &quot;, indexes &quot; &lt;&lt; indexIds &lt;&lt; endl;
-#endif
-		result.deserialize(serial);
-		m_settings.getEngineNames(engineIds, engineNames);
-		if (engineNames.empty() == false)
-		{
-			// Get the first engine this result was obtained from
-			engineName = *engineNames.begin();
-			if (engineName == m_settings.m_defaultBackend)
-			{
-				m_settings.getIndexNames(indexIds, indexNames);
-				if (indexNames.empty() == false)
-				{
-					// Use the name of the first index as engine name
-					engineName = (*indexNames.begin());
-				}
-			}
-		}
-		if (m_groupMode != FLAT)
-		{
-			result.setExtract(queryHistory.getItemExtract(from_utf8(queryName),
-				engineName, result.getLocation()));
-		}
-		else
-		{
-			engineName = m_treeName;
-		}
-		result.setTimestamp(from_utf8(childRow[m_resultsColumns.m_timestamp]));
-
-		// Export this
-		if (pExporter != NULL)
-		{
-			pExporter-&gt;exportResult(engineName, result);
-		}
-	}
-}
-
-//
-// Returns the changed selection signal.
-//
-sigc::signal1&lt;void, ustring&gt;&amp; ResultsTree::getSelectionChangedSignal(void)
-{
-	return m_signalSelectionChanged;
-}
-
-//
-// Returns the double-click signal.
-//
-sigc::signal0&lt;void&gt;&amp; ResultsTree::getDoubleClickSignal(void)
-{
-	return m_signalDoubleClick;
-}
-
-//
-// Adds a new row in the results tree.
-//
-bool ResultsTree::appendResult(const ustring &amp;text, const ustring &amp;url,
-	int score, int rankDiff, bool isIndexed, bool wasViewed,
-	unsigned int docId, const ustring &amp;timestamp,
-	const string &amp;serial, unsigned int engineId,
-	unsigned int indexId, TreeModel::iterator &amp;newRowIter,
-	const TreeModel::iterator &amp;parentIter, bool noDuplicates)
-{
-	if (!parentIter)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ResultsTree::appendResult: no parent&quot; &lt;&lt; endl;
-#endif
-		newRowIter = m_refStore-&gt;append();
-	}
-	else
-	{
-		const TreeModel::Row parentRow = *parentIter;
-
-		// Merge duplicates within groups ?
-		if (noDuplicates == true)
-		{
-			// Look for a row with the same URL and query. For instance, in group
-			// by host mode, if a page is returned by several search engines, it
-			// should appear only once
-			TreeModel::Children children = parentRow.children();
-			if (children.empty() == false)
-			{
-				for (TreeModel::Children::iterator childIter = children.begin();
-					childIter != children.end(); ++childIter)
-				{
-					TreeModel::Row row = *childIter;
-					if (row[m_resultsColumns.m_url] == url)
-					{
-						// Update the engines column...
-						row[m_resultsColumns.m_engines] = row[m_resultsColumns.m_engines] | engineId;
-						// ...and the indexes column too
-						row[m_resultsColumns.m_indexes] = row[m_resultsColumns.m_indexes] | engineId;
-
-						newRowIter = childIter;
-						return true;
-					}
-				}
-			}
-		}
-
-		newRowIter = m_refStore-&gt;append(parentRow.children());
-	}
-
-	TreeModel::Row childRow = *newRowIter;
-	updateRow(childRow, text, url, score, engineId, indexId,
-		docId, timestamp, serial, ResultsModelColumns::ROW_RESULT, isIndexed,
-		wasViewed, rankDiff);
-
-	return true;
-}
-
-//
-// Adds a results group
-//
-bool ResultsTree::appendGroup(const string &amp;groupName, ResultsModelColumns::RowType groupType,
-	TreeModel::iterator &amp;groupIter)
-{
-	bool success = false;
-
-	// Is this group already in ?
-	std::map&lt;string, TreeModel::iterator&gt;::iterator mapIter = m_resultsGroups.find(groupName);
-	if (mapIter == m_resultsGroups.end())
-	{
-		// No, it isn't: insert a new group in the tree
-		groupIter = m_refStore-&gt;append();
-		TreeModel::Row groupRow = *groupIter;
-		updateRow(groupRow, groupName,
-			&quot;&quot;, 0, 0, 0, 0, &quot;&quot;, &quot;&quot;, groupType,
-			false, false, 0);
-
-		// Update the map
-		m_resultsGroups[groupName] = groupIter;
-		success = true;
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ResultsTree::appendGroup: updated map with &quot; &lt;&lt; groupName &lt;&lt; endl;
-#endif
-	}
-	else
-	{
-		// Yes, it is
-		groupIter = mapIter-&gt;second;
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ResultsTree::appendGroup: found &quot; &lt;&lt; groupName &lt;&lt; &quot; in map&quot; &lt;&lt; endl;
-#endif
-		success = true;
-	}
-
-	return success;
-}
-
-//
-// Updates a results group.
-//
-void ResultsTree::updateGroup(TreeModel::iterator &amp;groupIter)
-{
-	TreeModel::Row groupRow = (*groupIter);
-	int averageScore = 0;
-
-	// Check the iterator doesn't point to a result
-	ResultsModelColumns::RowType type = groupRow[m_resultsColumns.m_resultType];
-	if (type == ResultsModelColumns::ROW_RESULT)
-	{
-		return;
-	}
-
-	// Modify the &quot;score&quot; column to indicate the number of results in that group
-	TreeModel::Children groupChildren = groupIter-&gt;children();
-	if (groupChildren.empty() == false)
-	{
-		for (TreeModel::Children::iterator childIter = groupChildren.begin();
-			childIter != groupChildren.end(); ++childIter)
-		{
-			TreeModel::Row row = *childIter;
-
-			averageScore += row[m_resultsColumns.m_score];
-		}
-
-		averageScore = (int)(averageScore / groupChildren.size());
-	}
-	else
-	{
-		TreeModel::Row groupRow = *groupIter;
-		TreeModel::iterator childIter = m_refStore-&gt;append(groupRow.children());
-		TreeModel::Row childRow = *childIter;
-
-		updateRow(childRow, _(&quot;No results&quot;), &quot;&quot;, 0, 0, 0, 0,
-			&quot;&quot;, &quot;&quot;, ResultsModelColumns::ROW_OTHER, false, false, 0);
-	}
-	groupRow[m_resultsColumns.m_score] = averageScore;
-
-	// Expand this group
-	TreeModel::Path groupPath = m_refStore-&gt;get_path(groupIter);
-	expand_row(groupPath, true);
-}
-
-//
-// Updates a row.
-//
-void ResultsTree::updateRow(TreeModel::Row &amp;row, const ustring &amp;text,
-	const ustring &amp;url, int score, 	unsigned int engineId, unsigned int indexId,
-	unsigned int docId, const ustring &amp;timestamp, const string &amp;serial,
-	ResultsModelColumns::RowType resultType, bool indexed, bool viewed, int rankDiff)
-{
-	try
-	{
-		row[m_resultsColumns.m_text] = text;
-		row[m_resultsColumns.m_url] = url;
-		row[m_resultsColumns.m_score] = score;
-		row[m_resultsColumns.m_scoreText] = &quot;&quot;;
-		row[m_resultsColumns.m_engines] = engineId;
-		row[m_resultsColumns.m_indexes] = indexId;
-		row[m_resultsColumns.m_docId] = docId;
-		row[m_resultsColumns.m_resultType] = resultType;
-		row[m_resultsColumns.m_timestamp] = timestamp;
-		row[m_resultsColumns.m_timestampTime] = TimeConverter::fromTimestamp(from_utf8(timestamp));
-		row[m_resultsColumns.m_serial] = serial;
-
-		row[m_resultsColumns.m_indexed] = indexed;
-		row[m_resultsColumns.m_viewed] = viewed;
-		row[m_resultsColumns.m_rankDiff] = rankDiff;
-	}
-	catch (Error &amp;error)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ResultsTree::updateRow: &quot; &lt;&lt; error.what() &lt;&lt; endl;
-#endif
-	}
-	catch (...)
-	{
-#ifdef DEBUG
-		cout &lt;&lt; &quot;ResultsTree::updateRow: caught unknown exception&quot; &lt;&lt; endl;
-#endif
-	}
-}
-
-//
-// Retrieves the extract to show for the given row.
-//
-ustring ResultsTree::findResultsExtract(const Gtk::TreeModel::Row &amp;row)
-{
-	QueryHistory queryHistory(m_settings.getHistoryDatabaseName());
-	set&lt;string&gt; engineNames, indexNames;
-	string url(from_utf8(row[m_resultsColumns.m_url]));
-	string extract;
-	unsigned int engineIds = row[m_resultsColumns.m_engines];
-	unsigned int indexIds = row[m_resultsColumns.m_indexes];
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;ResultsTree::findResultsExtract: &quot; &lt;&lt; url &lt;&lt; &quot; has engines &quot; &lt;&lt; engineIds &lt;&lt; &quot;, indexes &quot; &lt;&lt; indexIds &lt;&lt; endl;
-#endif
-	m_settings.getEngineNames(engineIds, engineNames);
-	for (set&lt;string&gt;::const_iterator engineIter = engineNames.begin();
-		engineIter != engineNames.end(); ++engineIter)
-	{
-		string engineName(*engineIter);
-
-		indexNames.clear();
-		if (engineName == m_settings.m_defaultBackend)
-		{
-			m_settings.getIndexNames(indexIds, indexNames);
-		}
-		else
-		{
-			// That's not an index but pretend it is
-			indexNames.insert(engineName);
-		}
-
-		for (set&lt;string&gt;::const_iterator indexIter = indexNames.begin();
-			indexIter != indexNames.end(); ++indexIter)
-		{
-			// Use the name of this index as engine name
-			engineName = (*indexNames.begin());
-
-#ifdef DEBUG
-			cout &lt;&lt; &quot;ResultsTree::findResultsExtract: engine or index &quot; &lt;&lt; engineName &lt;&lt; endl;
-#endif
-			extract = queryHistory.getItemExtract(from_utf8(m_treeName), engineName, url);
-			if (extract.empty() == false)
-			{
-				// Stop here
-				return extract;
-			}
-		}
-	}
-
-	return &quot;&quot;;
-}

Deleted: trunk/UI/GTK2/src/ResultsTree.h
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.h	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/ResultsTree.h	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,189 +0,0 @@
-/*
- *  Copyright 2005-2009 Fabrice Colin
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _RESULTSTREE_HH
-#define _RESULTSTREE_HH
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;set&gt;
-#include &lt;map&gt;
-#include &lt;sigc++/sigc++.h&gt;
-#include &lt;glibmm/refptr.h&gt;
-#include &lt;glibmm/ustring.h&gt;
-#include &lt;gdkmm/pixbuf.h&gt;
-#include &lt;gtkmm/button.h&gt;
-#include &lt;gtkmm/menu.h&gt;
-#include &lt;gtkmm/scrolledwindow.h&gt;
-#include &lt;gtkmm/treestore.h&gt;
-#include &lt;gtkmm/textview.h&gt;
-#include &lt;gtkmm/treeview.h&gt;
-#include &lt;gtkmm/treeselection.h&gt;
-
-#include &quot;ResultsExporter.h&quot;
-#include &quot;ModelColumns.h&quot;
-#include &quot;PinotSettings.h&quot;
-
-class ResultsTree : public Gtk::TreeView
-{
-	public:
-		typedef enum { BY_ENGINE = 0, BY_HOST, FLAT } GroupByMode;
-
-		ResultsTree(const Glib::ustring &amp;name, Gtk::Menu *pPopupMenu,
-			GroupByMode groupMode, PinotSettings &amp;settings);
-		virtual ~ResultsTree();
-
-		/// Returns the results scrolled window.
-		Gtk::ScrolledWindow *getResultsScrolledWindow(void) const;
-
-		/// Returns the extract scrolled window.
-		Gtk::ScrolledWindow *getExtractScrolledWindow(void) const;
-
-		/// Returns whether the extract text view has the focus.
-		bool focusOnExtract(void) const;
-
-		/// Returns the extract.
-		Glib::ustring getExtract(void) const;
-
-		/**
-		  * Adds a set of results.
-		  * Returns true if something was added to the tree.
-		  */
-		bool addResults(const std::string &amp;engineName, const std::vector&lt;DocumentInfo&gt; &amp;resultsList,
-			const std::string &amp;charset, bool updateHistory);
-
-		/// Sets how results are grouped.
-		void setGroupMode(GroupByMode groupMode);
-
-		/// Gets the first selected item's URL.
-		Glib::ustring getFirstSelectionURL(void);
-
-		/// Gets a list of selected items.
-		bool getSelection(std::vector&lt;DocumentInfo&gt; &amp;resultsList, bool skipIndexed = false);
-
-		/// Sets the selected items' state.
-		void setSelectionState(bool viewed);
-
-		/// Updates a result's properties.
-		bool updateResult(const DocumentInfo &amp;result);
-
-		/**
-		  * Deletes the current selection.
-		  * Returns true if the tree is then empty.
-		  */
-		bool deleteSelection(void);
-
-		/// Deletes results.
-		bool deleteResults(const std::string &amp;engineName);
-
-		/// Returns the number of rows.
-		unsigned int getRowsCount(void);
-
-		/// Refreshes the tree.
-		void refresh(void);
-
-		/// Clears the tree.
-		void clear(void);
-
-		/// Shows or hides the extract field.
-		void showExtract(bool showExtract = true);
-
-		/// Exports results to a file.
-		void exportResults(const std::string &amp;fileName,
-			const string &amp;queryName, bool csvFormat);
-
-		/// Returns the changed selection signal.
-		sigc::signal1&lt;void, Glib::ustring&gt;&amp; getSelectionChangedSignal(void);
-
-		/// Returns the double-click signal.
-		sigc::signal0&lt;void&gt;&amp; getDoubleClickSignal(void);
-
-	protected:
-		Glib::ustring m_treeName;
-		Gtk::Menu *m_pPopupMenu;
-		Gtk::ScrolledWindow *m_pResultsScrolledwindow;
-		Glib::RefPtr&lt;Gtk::TreeStore&gt; m_refStore;
-		sigc::signal1&lt;void, Glib::ustring&gt; m_signalSelectionChanged;
-		sigc::signal0&lt;void&gt; m_signalDoubleClick;
-		PinotSettings &amp;m_settings;
-		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_indexedIconPixbuf;
-		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_viewededIconPixbuf;
-		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_upIconPixbuf;
-		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_downIconPixbuf;
-		std::map&lt;std::string, Gtk::TreeModel::iterator&gt; m_resultsGroups;
-		ResultsModelColumns m_resultsColumns;
-		Gtk::ScrolledWindow *m_pExtractScrolledwindow;
-		Gtk::TextView *m_extractTextView;
-		ComboModelColumns m_extractColumns;
-		bool m_showExtract;
-		GroupByMode m_groupMode;
-
-		void renderViewStatus(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &amp;iter);
-
-		void renderIndexStatus(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &amp;iter);
-
-		void renderRanking(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &amp;iter);
-
-		void renderTitleColumn(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &amp;iter);
-
-		void onButtonPressEvent(GdkEventButton *ev);
-
-		void onSelectionChanged(void);
-
-		bool onSelectionSelect(const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,
-			const Gtk::TreeModel::Path&amp; node_path, bool path_currently_selected);
-
-		/// Handles GTK style changes.
-		void onStyleChanged(const Glib::RefPtr&lt;Gtk::Style&gt; &amp;previous_style);
-
-		/// Adds a results group.
-		bool appendGroup(const std::string &amp;groupName, ResultsModelColumns::RowType groupType,
-			Gtk::TreeModel::iterator &amp;groupIter);
-
-		/// Adds a new row in the results tree.
-		bool appendResult(const Glib::ustring &amp;text, const Glib::ustring &amp;url,
-			int score, int rankDiff, bool isIndexed, bool wasViewed,
-			unsigned int docId, const Glib::ustring &amp;timestamp, const std::string &amp;serial,
-			unsigned int engineId, unsigned int indexId,
-			Gtk::TreeModel::iterator &amp;newRowIter,
-			const Gtk::TreeModel::iterator &amp;parentIter,
-			bool noDuplicates = false);
-
-		/// Updates a results group.
-		void updateGroup(Gtk::TreeModel::iterator &amp;groupIter);
-
-		/// Updates a row.
-		void updateRow(Gtk::TreeModel::Row &amp;row, const Glib::ustring &amp;text,
-			const Glib::ustring &amp;url, int score, unsigned int engineId, unsigned int indexId,
-			unsigned int docId, const Glib::ustring &amp;timestamp, const std::string &amp;serial,
-			ResultsModelColumns::RowType resultType, bool indexed, bool viewed, int rankDiff);
-
-		/// Retrieves the extract to show for the given row.
-		Glib::ustring findResultsExtract(const Gtk::TreeModel::Row &amp;row);
-
-		/// Exports results to a file.
-		void exportResults(Gtk::TreeModel::Children &amp;groupChildren,
-			const string &amp;queryName, ResultsExporter *pExporter);
-
-	private:
-		ResultsTree(const ResultsTree &amp;other);
-		ResultsTree &amp;operator=(const ResultsTree &amp;other);
-
-};
-
-#endif // _RESULTSTREE_HH

Copied: trunk/UI/GTK2/src/ResultsTree.hh (from rev 1529, trunk/UI/GTK2/src/ResultsTree.h)
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.h	2009-02-01 09:53:30 UTC (rev 1529)
+++ trunk/UI/GTK2/src/ResultsTree.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -0,0 +1,189 @@
+/*
+ *  Copyright 2005-2009 Fabrice Colin
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _RESULTSTREE_HH
+#define _RESULTSTREE_HH
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;set&gt;
+#include &lt;map&gt;
+#include &lt;sigc++/sigc++.h&gt;
+#include &lt;glibmm/refptr.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gdkmm/pixbuf.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/menu.h&gt;
+#include &lt;gtkmm/scrolledwindow.h&gt;
+#include &lt;gtkmm/treestore.h&gt;
+#include &lt;gtkmm/textview.h&gt;
+#include &lt;gtkmm/treeview.h&gt;
+#include &lt;gtkmm/treeselection.h&gt;
+
+#include &quot;ResultsExporter.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;ModelColumns.hh&quot;
+
+class ResultsTree : public Gtk::TreeView
+{
+	public:
+		typedef enum { BY_ENGINE = 0, BY_HOST, FLAT } GroupByMode;
+
+		ResultsTree(const Glib::ustring &amp;name, Gtk::Menu *pPopupMenu,
+			GroupByMode groupMode, PinotSettings &amp;settings);
+		virtual ~ResultsTree();
+
+		/// Returns the results scrolled window.
+		Gtk::ScrolledWindow *getResultsScrolledWindow(void) const;
+
+		/// Returns the extract scrolled window.
+		Gtk::ScrolledWindow *getExtractScrolledWindow(void) const;
+
+		/// Returns whether the extract text view has the focus.
+		bool focusOnExtract(void) const;
+
+		/// Returns the extract.
+		Glib::ustring getExtract(void) const;
+
+		/**
+		  * Adds a set of results.
+		  * Returns true if something was added to the tree.
+		  */
+		bool addResults(const std::string &amp;engineName, const std::vector&lt;DocumentInfo&gt; &amp;resultsList,
+			const std::string &amp;charset, bool updateHistory);
+
+		/// Sets how results are grouped.
+		void setGroupMode(GroupByMode groupMode);
+
+		/// Gets the first selected item's URL.
+		Glib::ustring getFirstSelectionURL(void);
+
+		/// Gets a list of selected items.
+		bool getSelection(std::vector&lt;DocumentInfo&gt; &amp;resultsList, bool skipIndexed = false);
+
+		/// Sets the selected items' state.
+		void setSelectionState(bool viewed);
+
+		/// Updates a result's properties.
+		bool updateResult(const DocumentInfo &amp;result);
+
+		/**
+		  * Deletes the current selection.
+		  * Returns true if the tree is then empty.
+		  */
+		bool deleteSelection(void);
+
+		/// Deletes results.
+		bool deleteResults(const std::string &amp;engineName);
+
+		/// Returns the number of rows.
+		unsigned int getRowsCount(void);
+
+		/// Refreshes the tree.
+		void refresh(void);
+
+		/// Clears the tree.
+		void clear(void);
+
+		/// Shows or hides the extract field.
+		void showExtract(bool showExtract = true);
+
+		/// Exports results to a file.
+		void exportResults(const std::string &amp;fileName,
+			const string &amp;queryName, bool csvFormat);
+
+		/// Returns the changed selection signal.
+		sigc::signal1&lt;void, Glib::ustring&gt;&amp; getSelectionChangedSignal(void);
+
+		/// Returns the double-click signal.
+		sigc::signal0&lt;void&gt;&amp; getDoubleClickSignal(void);
+
+	protected:
+		Glib::ustring m_treeName;
+		Gtk::Menu *m_pPopupMenu;
+		Gtk::ScrolledWindow *m_pResultsScrolledwindow;
+		Glib::RefPtr&lt;Gtk::TreeStore&gt; m_refStore;
+		sigc::signal1&lt;void, Glib::ustring&gt; m_signalSelectionChanged;
+		sigc::signal0&lt;void&gt; m_signalDoubleClick;
+		PinotSettings &amp;m_settings;
+		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_indexedIconPixbuf;
+		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_viewededIconPixbuf;
+		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_upIconPixbuf;
+		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_downIconPixbuf;
+		std::map&lt;std::string, Gtk::TreeModel::iterator&gt; m_resultsGroups;
+		ResultsModelColumns m_resultsColumns;
+		Gtk::ScrolledWindow *m_pExtractScrolledwindow;
+		Gtk::TextView *m_extractTextView;
+		ComboModelColumns m_extractColumns;
+		bool m_showExtract;
+		GroupByMode m_groupMode;
+
+		void renderViewStatus(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &amp;iter);
+
+		void renderIndexStatus(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &amp;iter);
+
+		void renderRanking(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &amp;iter);
+
+		void renderTitleColumn(Gtk::CellRenderer *pRenderer, const Gtk::TreeModel::iterator &amp;iter);
+
+		void onButtonPressEvent(GdkEventButton *ev);
+
+		void onSelectionChanged(void);
+
+		bool onSelectionSelect(const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,
+			const Gtk::TreeModel::Path&amp; node_path, bool path_currently_selected);
+
+		/// Handles GTK style changes.
+		void onStyleChanged(const Glib::RefPtr&lt;Gtk::Style&gt; &amp;previous_style);
+
+		/// Adds a results group.
+		bool appendGroup(const std::string &amp;groupName, ResultsModelColumns::RowType groupType,
+			Gtk::TreeModel::iterator &amp;groupIter);
+
+		/// Adds a new row in the results tree.
+		bool appendResult(const Glib::ustring &amp;text, const Glib::ustring &amp;url,
+			int score, int rankDiff, bool isIndexed, bool wasViewed,
+			unsigned int docId, const Glib::ustring &amp;timestamp, const std::string &amp;serial,
+			unsigned int engineId, unsigned int indexId,
+			Gtk::TreeModel::iterator &amp;newRowIter,
+			const Gtk::TreeModel::iterator &amp;parentIter,
+			bool noDuplicates = false);
+
+		/// Updates a results group.
+		void updateGroup(Gtk::TreeModel::iterator &amp;groupIter);
+
+		/// Updates a row.
+		void updateRow(Gtk::TreeModel::Row &amp;row, const Glib::ustring &amp;text,
+			const Glib::ustring &amp;url, int score, unsigned int engineId, unsigned int indexId,
+			unsigned int docId, const Glib::ustring &amp;timestamp, const std::string &amp;serial,
+			ResultsModelColumns::RowType resultType, bool indexed, bool viewed, int rankDiff);
+
+		/// Retrieves the extract to show for the given row.
+		Glib::ustring findResultsExtract(const Gtk::TreeModel::Row &amp;row);
+
+		/// Exports results to a file.
+		void exportResults(Gtk::TreeModel::Children &amp;groupChildren,
+			const string &amp;queryName, ResultsExporter *pExporter);
+
+	private:
+		ResultsTree(const ResultsTree &amp;other);
+		ResultsTree &amp;operator=(const ResultsTree &amp;other);
+
+};
+
+#endif // _RESULTSTREE_HH


Property changes on: trunk/UI/GTK2/src/ResultsTree.hh
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: trunk/UI/GTK2/src/importDialog.hh
===================================================================
--- trunk/UI/GTK2/src/importDialog.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/importDialog.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005,2006 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -27,7 +27,7 @@
 #include &lt;glibmm/ustring.h&gt;
 
 #include &quot;DocumentInfo.h&quot;
-#include &quot;ModelColumns.h&quot;
+#include &quot;ModelColumns.hh&quot;
 #include &quot;importDialog_glade.hh&quot;
 
 class importDialog : public importDialog_glade

Modified: trunk/UI/GTK2/src/indexDialog.hh
===================================================================
--- trunk/UI/GTK2/src/indexDialog.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/indexDialog.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005,2006 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -21,7 +21,7 @@
 
 #include &lt;glibmm/ustring.h&gt;
 
-#include &quot;ModelColumns.h&quot;
+#include &quot;ModelColumns.hh&quot;
 #include &quot;indexDialog_glade.hh&quot;
 
 class indexDialog : public indexDialog_glade

Modified: trunk/UI/GTK2/src/mainWindow.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/mainWindow.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005-2008 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -39,13 +39,13 @@
 #include &quot;QueryProperties.h&quot;
 #include &quot;MonitorInterface.h&quot;
 #include &quot;MonitorHandler.h&quot;
-#include &quot;EnginesTree.h&quot;
-#include &quot;IndexPage.h&quot;
-#include &quot;ModelColumns.h&quot;
-#include &quot;Notebook.h&quot;
 #include &quot;PinotSettings.h&quot;
-#include &quot;ResultsTree.h&quot;
 #include &quot;WorkerThreads.h&quot;
+#include &quot;EnginesTree.hh&quot;
+#include &quot;IndexPage.hh&quot;
+#include &quot;ModelColumns.hh&quot;
+#include &quot;Notebook.hh&quot;
+#include &quot;ResultsTree.hh&quot;
 #include &quot;mainWindow_glade.hh&quot;
 
 class mainWindow : public mainWindow_glade

Modified: trunk/UI/GTK2/src/prefsWindow.hh
===================================================================
--- trunk/UI/GTK2/src/prefsWindow.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/prefsWindow.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -27,9 +27,9 @@
 #include &lt;glibmm/ustring.h&gt;
 #include &lt;gtkmm/liststore.h&gt;
 
-#include &quot;ModelColumns.h&quot;
 #include &quot;PinotSettings.h&quot;
 #include &quot;WorkerThreads.h&quot;
+#include &quot;ModelColumns.hh&quot;
 #include &quot;prefsWindow_glade.hh&quot;
 
 class prefsWindow : public prefsWindow_glade

Modified: trunk/UI/GTK2/src/propertiesDialog.hh
===================================================================
--- trunk/UI/GTK2/src/propertiesDialog.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/propertiesDialog.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005,2006 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -26,7 +26,7 @@
 #include &lt;gtkmm/liststore.h&gt;
 
 #include &quot;DocumentInfo.h&quot;
-#include &quot;ModelColumns.h&quot;
+#include &quot;ModelColumns.hh&quot;
 #include &quot;propertiesDialog_glade.hh&quot;
 
 class propertiesDialog : public propertiesDialog_glade

Modified: trunk/UI/GTK2/src/queryDialog.hh
===================================================================
--- trunk/UI/GTK2/src/queryDialog.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/queryDialog.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2005,2006 Fabrice Colin
+ *  Copyright 2005-2009 Fabrice Colin
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by

Modified: trunk/UI/GTK2/src/statisticsDialog.hh
===================================================================
--- trunk/UI/GTK2/src/statisticsDialog.hh	2009-02-01 11:04:31 UTC (rev 1530)
+++ trunk/UI/GTK2/src/statisticsDialog.hh	2009-02-01 11:47:02 UTC (rev 1531)
@@ -25,8 +25,8 @@
 #include &lt;glibmm/refptr.h&gt;
 #include &lt;gtkmm/treestore.h&gt;
 
-#include &quot;ModelColumns.h&quot;
 #include &quot;WorkerThreads.h&quot;
+#include &quot;ModelColumns.hh&quot;
 #include &quot;statisticsDialog_glade.hh&quot;
 
 class statisticsDialog : public statisticsDialog_glade


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001520.html">[Pinot-svn] r1530 - in trunk: . Core UI/GTK2/src po
</A></li>
	<LI>Next message: <A HREF="001522.html">[Pinot-svn] r1532 - trunk/po
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1521">[ date ]</a>
              <a href="thread.html#1521">[ thread ]</a>
              <a href="subject.html#1521">[ subject ]</a>
              <a href="author.html#1521">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/pinot-svn">More information about the Pinot-svn
mailing list</a><br>
</body></html>
