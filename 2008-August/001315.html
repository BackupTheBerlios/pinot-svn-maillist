<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Pinot-svn] r1321 - trunk/IndexSearch/Google
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/pinot-svn/2008-August/index.html" >
   <LINK REL="made" HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r1321%20-%20trunk/IndexSearch/Google&In-Reply-To=%3C200808041422.m74EMM8x002146%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001314.html">
   <LINK REL="Next"  HREF="001316.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Pinot-svn] r1321 - trunk/IndexSearch/Google</H1>
    <B>fabricecolin at mail.berlios.de</B> 
    <A HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r1321%20-%20trunk/IndexSearch/Google&In-Reply-To=%3C200808041422.m74EMM8x002146%40sheep.berlios.de%3E"
       TITLE="[Pinot-svn] r1321 - trunk/IndexSearch/Google">fabricecolin at mail.berlios.de
       </A><BR>
    <I>Mon Aug  4 16:22:22 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001314.html">[Pinot-svn] r1320 - in trunk: . Collect IndexSearch	IndexSearch/Xapian IndexSearch/XesamGLib Monitor SQL Tokenize	UI/GTK2/src Utils
</A></li>
        <LI>Next message: <A HREF="001316.html">[Pinot-svn] r1322 - trunk/IndexSearch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1315">[ date ]</a>
              <a href="thread.html#1315">[ thread ]</a>
              <a href="subject.html#1315">[ subject ]</a>
              <a href="author.html#1315">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fabricecolin
Date: 2008-08-04 16:22:08 +0200 (Mon, 04 Aug 2008)
New Revision: 1321

Modified:
   trunk/IndexSearch/Google/GAPIC.cpp
   trunk/IndexSearch/Google/GAPIClient.cpp
   trunk/IndexSearch/Google/GAPIClientLib.cpp
   trunk/IndexSearch/Google/GAPIGoogleSearchBindingProxy.h
   trunk/IndexSearch/Google/GAPIH.h
   trunk/IndexSearch/Google/GAPIStub.h
   trunk/IndexSearch/Google/GoogleAPIEngine.cpp
   trunk/IndexSearch/Google/GoogleSearch.h
   trunk/IndexSearch/Google/Makefile.am
Log:
Regenerated code with gsoap 2.7.10.
Compile GAPIC and GAPIClient, and ignore GAPIClientLib as it defines a macro
that makes all the soap_ functions static. All this is built into a dynamic
backend.


Modified: trunk/IndexSearch/Google/GAPIC.cpp
===================================================================
--- trunk/IndexSearch/Google/GAPIC.cpp	2008-08-04 14:15:56 UTC (rev 1320)
+++ trunk/IndexSearch/Google/GAPIC.cpp	2008-08-04 14:22:08 UTC (rev 1321)
@@ -1,13 +1,13 @@
 /* GAPIC.cpp
-   Generated by gSOAP 2.7.9e from GoogleSearch.h
-   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   Generated by gSOAP 2.7.10 from GoogleSearch.h
+   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
    This part of the software is released under one of the following licenses:
    GPL, the gSOAP public license, or Genivia's license for commercial use.
 */
 
 #include &quot;GAPIH.h&quot;
 
-SOAP_SOURCE_STAMP(&quot;@(#) GAPIC.cpp ver 2.7.9e 2007-07-29 10:34:02 GMT&quot;)
+SOAP_SOURCE_STAMP(&quot;@(#) GAPIC.cpp ver 2.7.10 2008-08-04 14:27:08 GMT&quot;)
 
 
 #ifndef WITH_NOGLOBAL
@@ -22,7 +22,8 @@
 {
 	if (soap-&gt;header)
 	{	soap-&gt;part = SOAP_IN_HEADER;
-		soap_out_SOAP_ENV__Header(soap, &quot;SOAP-ENV:Header&quot;, 0, soap-&gt;header, NULL);
+		if (soap_out_SOAP_ENV__Header(soap, &quot;SOAP-ENV:Header&quot;, 0, soap-&gt;header, NULL))
+			return soap-&gt;error;
 		soap-&gt;part = SOAP_END_HEADER;
 	}
 	return SOAP_OK;
@@ -36,6 +37,14 @@
 	return soap-&gt;header == NULL;
 }
 
+SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
+{
+	if (!soap-&gt;header)
+	{	soap-&gt;header = soap_new_SOAP_ENV__Header(soap, -1);
+		soap_default_SOAP_ENV__Header(soap, soap-&gt;header);
+	}
+}
+
 SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
 {
 	if (!soap-&gt;fault)
@@ -209,30 +218,6 @@
 	{	const char *t = soap-&gt;type;
 		if (!*t)
 			t = soap-&gt;tag;
-		if (!soap_match_tag(soap, t, &quot;xsd:byte&quot;))
-		{	*type = SOAP_TYPE_byte;
-			return soap_in_byte(soap, NULL, NULL, NULL);
-		}
-		if (!soap_match_tag(soap, t, &quot;xsd:int&quot;))
-		{	*type = SOAP_TYPE_int;
-			return soap_in_int(soap, NULL, NULL, NULL);
-		}
-		if (!soap_match_tag(soap, t, &quot;xsd:double&quot;))
-		{	*type = SOAP_TYPE_double;
-			return soap_in_double(soap, NULL, NULL, NULL);
-		}
-		if (!soap_match_tag(soap, t, &quot;xsd:unsignedByte&quot;))
-		{	*type = SOAP_TYPE_unsignedByte;
-			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
-		}
-		if (!soap_match_tag(soap, t, &quot;xsd:unsignedInt&quot;))
-		{	*type = SOAP_TYPE_unsignedInt;
-			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
-		}
-		if (!soap_match_tag(soap, t, &quot;xsd:boolean&quot;))
-		{	*type = SOAP_TYPE_bool;
-			return soap_in_bool(soap, NULL, NULL, NULL);
-		}
 		if (!soap_match_tag(soap, t, &quot;xsd:string&quot;))
 		{	*type = SOAP_TYPE_std__string;
 			return soap_in_std__string(soap, NULL, NULL, NULL);
@@ -261,6 +246,30 @@
 		{	*type = SOAP_TYPE_xsd__base64Binary;
 			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
 		}
+		if (!soap_match_tag(soap, t, &quot;xsd:byte&quot;))
+		{	*type = SOAP_TYPE_byte;
+			return soap_in_byte(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;xsd:int&quot;))
+		{	*type = SOAP_TYPE_int;
+			return soap_in_int(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;xsd:double&quot;))
+		{	*type = SOAP_TYPE_double;
+			return soap_in_double(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;xsd:unsignedByte&quot;))
+		{	*type = SOAP_TYPE_unsignedByte;
+			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;xsd:unsignedInt&quot;))
+		{	*type = SOAP_TYPE_unsignedInt;
+			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;xsd:boolean&quot;))
+		{	*type = SOAP_TYPE_bool;
+			return soap_in_bool(soap, NULL, NULL, NULL);
+		}
 		if (!soap_match_tag(soap, t, &quot;gapi1:doGoogleSearch&quot;))
 		{	*type = SOAP_TYPE_gapi1__doGoogleSearch;
 			return soap_in_gapi1__doGoogleSearch(soap, NULL, NULL, NULL);
@@ -313,6 +322,7 @@
 {
 	if (!soap_peek_element(soap))
 	{	int t;
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Unexpected element '%s' in input (level=%u, %d)\n&quot;, soap-&gt;tag, soap-&gt;level, soap-&gt;body));
 		if (soap-&gt;mustUnderstand &amp;&amp; !soap-&gt;other)
 			return soap-&gt;error = SOAP_MUSTUNDERSTAND;
 		if (((soap-&gt;mode &amp; SOAP_XML_STRICT) &amp;&amp; soap-&gt;part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap-&gt;tag, &quot;SOAP-ENV:&quot;))
@@ -321,7 +331,6 @@
 		}
 		if (!*soap-&gt;id || !soap_getelement(soap, &amp;t))
 		{	soap-&gt;peeked = 0;
-			DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Unknown element '%s' (level=%u, %d)\n&quot;, soap-&gt;tag, soap-&gt;level, soap-&gt;body));
 			if (soap-&gt;fignore)
 				soap-&gt;error = soap-&gt;fignore(soap, soap-&gt;tag);
 			else
@@ -418,9 +427,9 @@
 	case SOAP_TYPE_PointerTounsignedByte:
 		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, &quot;xsd:unsignedByte&quot;);
 	case SOAP_TYPE__QName:
-		return soap_out_string(soap, &quot;xsd:QName&quot;, id, (char**)&amp;ptr, NULL);
+		return soap_out_string(soap, &quot;xsd:QName&quot;, id, (char*const*)&amp;ptr, NULL);
 	case SOAP_TYPE_string:
-		return soap_out_string(soap, tag, id, (char**)&amp;ptr, &quot;xsd:string&quot;);
+		return soap_out_string(soap, tag, id, (char*const*)&amp;ptr, &quot;xsd:string&quot;);
 	}
 	return SOAP_OK;
 }
@@ -504,10 +513,10 @@
 		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
 		break;
 	case SOAP_TYPE__QName:
-		soap_serialize_string(soap, (char**)&amp;ptr);
+		soap_serialize_string(soap, (char*const*)&amp;ptr);
 		break;
 	case SOAP_TYPE_string:
-		soap_serialize_string(soap, (char**)&amp;ptr);
+		soap_serialize_string(soap, (char*const*)&amp;ptr);
 		break;
 	}
 }
@@ -728,7 +737,8 @@
 SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_byte(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -762,7 +772,8 @@
 SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_int(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -796,7 +807,8 @@
 SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_double(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -830,7 +842,8 @@
 SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -864,7 +877,8 @@
 SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -901,15 +915,16 @@
 }
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
-{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
-	soap_send(soap, soap_bool2s(soap, *a));
+{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
+		return soap-&gt;error;
 	return soap_element_end_out(soap, tag);
 }
 
 SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_bool(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -981,13 +996,14 @@
 SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_std__string(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
 SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
 {
-	if (soap_element_begin_in(soap, tag, 1, type))
+	if (soap_element_begin_in(soap, tag, 1, NULL))
 		return NULL;
 	if (!s)
 		s = soap_new_std__string(soap, -1);
@@ -1078,12 +1094,14 @@
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__DirectoryCategory(struct soap *soap, const char *tag, int id, const gapi1__DirectoryCategory *a, const char *type)
 {
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__DirectoryCategory), type);
-	soap_out_std__string(soap, &quot;fullViewableName&quot;, -1, &amp;(a-&gt;gapi1__DirectoryCategory::fullViewableName), &quot;&quot;);
-	soap_out_std__string(soap, &quot;specialEncoding&quot;, -1, &amp;(a-&gt;gapi1__DirectoryCategory::specialEncoding), &quot;&quot;);
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__DirectoryCategory), type))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;fullViewableName&quot;, -1, &amp;(a-&gt;gapi1__DirectoryCategory::fullViewableName), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;specialEncoding&quot;, -1, &amp;(a-&gt;gapi1__DirectoryCategory::specialEncoding), &quot;&quot;))
+		return soap-&gt;error;
 	/* transient soap skipped */
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	return soap_element_end_out(soap, tag);
 }
 
 void *gapi1__DirectoryCategory::soap_get(struct soap *soap, const char *tag, const char *type)
@@ -1094,7 +1112,8 @@
 SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_get_gapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_gapi1__DirectoryCategory(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -1230,7 +1249,8 @@
 	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&amp;a-&gt;__ptr, 1, type, SOAP_TYPE_gapi1DirectoryCategoryArray);
 	if (id &lt; 0)
 		return soap-&gt;error;
-	soap_array_begin_out(soap, tag, id, t, NULL);
+	if (soap_array_begin_out(soap, tag, id, t, NULL))
+		return soap-&gt;error;
 	for (i = 0; i &lt; n; i++)
 	{
 		soap-&gt;position = 1;
@@ -1238,8 +1258,7 @@
 		soap_out_PointerTogapi1__DirectoryCategory(soap, &quot;item&quot;, -1, &amp;a-&gt;__ptr[i], &quot;&quot;);
 	}
 	soap-&gt;position = 0;
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	return soap_element_end_out(soap, tag);
 }
 
 void *gapi1DirectoryCategoryArray::soap_get(struct soap *soap, const char *tag, const char *type)
@@ -1250,7 +1269,8 @@
 SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_get_gapi1DirectoryCategoryArray(struct soap *soap, gapi1DirectoryCategoryArray *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_gapi1DirectoryCategoryArray(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -1400,7 +1420,8 @@
 	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&amp;a-&gt;__ptr, 1, type, SOAP_TYPE_gapi1ResultElementArray);
 	if (id &lt; 0)
 		return soap-&gt;error;
-	soap_array_begin_out(soap, tag, id, t, NULL);
+	if (soap_array_begin_out(soap, tag, id, t, NULL))
+		return soap-&gt;error;
 	for (i = 0; i &lt; n; i++)
 	{
 		soap-&gt;position = 1;
@@ -1408,8 +1429,7 @@
 		soap_out_PointerTogapi1__ResultElement(soap, &quot;item&quot;, -1, &amp;a-&gt;__ptr[i], &quot;&quot;);
 	}
 	soap-&gt;position = 0;
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	return soap_element_end_out(soap, tag);
 }
 
 void *gapi1ResultElementArray::soap_get(struct soap *soap, const char *tag, const char *type)
@@ -1420,7 +1440,8 @@
 SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_get_gapi1ResultElementArray(struct soap *soap, gapi1ResultElementArray *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_gapi1ResultElementArray(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -1579,19 +1600,28 @@
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__ResultElement(struct soap *soap, const char *tag, int id, const gapi1__ResultElement *a, const char *type)
 {
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__ResultElement), type);
-	soap_out_std__string(soap, &quot;summary&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::summary), &quot;&quot;);
-	soap_out_std__string(soap, &quot;URL&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::URL), &quot;&quot;);
-	soap_out_std__string(soap, &quot;snippet&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::snippet), &quot;&quot;);
-	soap_out_std__string(soap, &quot;title&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::title), &quot;&quot;);
-	soap_out_std__string(soap, &quot;cachedSize&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::cachedSize), &quot;&quot;);
-	soap_out_bool(soap, &quot;relatedInformationPresent&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::relatedInformationPresent), &quot;&quot;);
-	soap_out_std__string(soap, &quot;hostName&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::hostName), &quot;&quot;);
-	soap_out_PointerTogapi1__DirectoryCategory(soap, &quot;directoryCategory&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::directoryCategory), &quot;&quot;);
-	soap_out_std__string(soap, &quot;directoryTitle&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::directoryTitle), &quot;&quot;);
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__ResultElement), type))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;summary&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::summary), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;URL&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::URL), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;snippet&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::snippet), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;title&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::title), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;cachedSize&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::cachedSize), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_bool(soap, &quot;relatedInformationPresent&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::relatedInformationPresent), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;hostName&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::hostName), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_PointerTogapi1__DirectoryCategory(soap, &quot;directoryCategory&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::directoryCategory), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;directoryTitle&quot;, -1, &amp;(a-&gt;gapi1__ResultElement::directoryTitle), &quot;&quot;))
+		return soap-&gt;error;
 	/* transient soap skipped */
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	return soap_element_end_out(soap, tag);
 }
 
 void *gapi1__ResultElement::soap_get(struct soap *soap, const char *tag, const char *type)
@@ -1602,7 +1632,8 @@
 SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_get_gapi1__ResultElement(struct soap *soap, gapi1__ResultElement *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_gapi1__ResultElement(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -1781,21 +1812,32 @@
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__GoogleSearchResult(struct soap *soap, const char *tag, int id, const gapi1__GoogleSearchResult *a, const char *type)
 {
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__GoogleSearchResult), type);
-	soap_out_bool(soap, &quot;documentFiltering&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::documentFiltering), &quot;&quot;);
-	soap_out_std__string(soap, &quot;searchComments&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::searchComments), &quot;&quot;);
-	soap_out_int(soap, &quot;estimatedTotalResultsCount&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::estimatedTotalResultsCount), &quot;&quot;);
-	soap_out_bool(soap, &quot;estimateIsExact&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::estimateIsExact), &quot;&quot;);
-	soap_out_PointerTogapi1ResultElementArray(soap, &quot;resultElements&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::resultElements), &quot;&quot;);
-	soap_out_std__string(soap, &quot;searchQuery&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::searchQuery), &quot;&quot;);
-	soap_out_int(soap, &quot;startIndex&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::startIndex), &quot;&quot;);
-	soap_out_int(soap, &quot;endIndex&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::endIndex), &quot;&quot;);
-	soap_out_std__string(soap, &quot;searchTips&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::searchTips), &quot;&quot;);
-	soap_out_PointerTogapi1DirectoryCategoryArray(soap, &quot;directoryCategories&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::directoryCategories), &quot;&quot;);
-	soap_out_double(soap, &quot;searchTime&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::searchTime), &quot;&quot;);
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__GoogleSearchResult), type))
+		return soap-&gt;error;
+	if (soap_out_bool(soap, &quot;documentFiltering&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::documentFiltering), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;searchComments&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::searchComments), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_int(soap, &quot;estimatedTotalResultsCount&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::estimatedTotalResultsCount), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_bool(soap, &quot;estimateIsExact&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::estimateIsExact), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_PointerTogapi1ResultElementArray(soap, &quot;resultElements&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::resultElements), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;searchQuery&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::searchQuery), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_int(soap, &quot;startIndex&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::startIndex), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_int(soap, &quot;endIndex&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::endIndex), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;searchTips&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::searchTips), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_PointerTogapi1DirectoryCategoryArray(soap, &quot;directoryCategories&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::directoryCategories), &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_double(soap, &quot;searchTime&quot;, -1, &amp;(a-&gt;gapi1__GoogleSearchResult::searchTime), &quot;&quot;))
+		return soap-&gt;error;
 	/* transient soap skipped */
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	return soap_element_end_out(soap, tag);
 }
 
 void *gapi1__GoogleSearchResult::soap_get(struct soap *soap, const char *tag, const char *type)
@@ -1806,7 +1848,8 @@
 SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_get_gapi1__GoogleSearchResult(struct soap *soap, gapi1__GoogleSearchResult *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_gapi1__GoogleSearchResult(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -1990,10 +2033,11 @@
 #endif
 	if (id &lt; 0)
 		return soap-&gt;error;
-	soap_element_begin_out(soap, tag, id, type);
-	soap_putbase64(soap, a-&gt;__ptr, a-&gt;__size);
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	if (soap_element_begin_out(soap, tag, id, type))
+		return soap-&gt;error;
+	if (soap_putbase64(soap, a-&gt;__ptr, a-&gt;__size))
+		return soap-&gt;error;
+	return soap_element_end_out(soap, tag);
 }
 
 void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
@@ -2004,7 +2048,8 @@
 SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -2132,24 +2177,34 @@
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
 {
 	const char *soap_tmp_faultcode = soap_QName2s(soap, a-&gt;faultcode);
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
-	soap_out__QName(soap, &quot;faultcode&quot;, -1, (char*const*)&amp;soap_tmp_faultcode, &quot;&quot;);
-	soap_out_string(soap, &quot;faultstring&quot;, -1, &amp;a-&gt;faultstring, &quot;&quot;);
-	soap_out_string(soap, &quot;faultactor&quot;, -1, &amp;a-&gt;faultactor, &quot;&quot;);
-	soap_out_PointerToSOAP_ENV__Detail(soap, &quot;detail&quot;, -1, &amp;a-&gt;detail, &quot;&quot;);
-	soap_out_PointerToSOAP_ENV__Code(soap, &quot;SOAP-ENV:Code&quot;, -1, &amp;a-&gt;SOAP_ENV__Code, &quot;&quot;);
-	soap_out_PointerToSOAP_ENV__Reason(soap, &quot;SOAP-ENV:Reason&quot;, -1, &amp;a-&gt;SOAP_ENV__Reason, &quot;&quot;);
-	soap_out_string(soap, &quot;SOAP-ENV:Node&quot;, -1, &amp;a-&gt;SOAP_ENV__Node, &quot;&quot;);
-	soap_out_string(soap, &quot;SOAP-ENV:Role&quot;, -1, &amp;a-&gt;SOAP_ENV__Role, &quot;&quot;);
-	soap_out_PointerToSOAP_ENV__Detail(soap, &quot;SOAP-ENV:Detail&quot;, -1, &amp;a-&gt;SOAP_ENV__Detail, &quot;&quot;);
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
+		return soap-&gt;error;
+	if (soap_out__QName(soap, &quot;faultcode&quot;, -1, (char*const*)&amp;soap_tmp_faultcode, &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_string(soap, &quot;faultstring&quot;, -1, &amp;a-&gt;faultstring, &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_string(soap, &quot;faultactor&quot;, -1, &amp;a-&gt;faultactor, &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_PointerToSOAP_ENV__Detail(soap, &quot;detail&quot;, -1, &amp;a-&gt;detail, &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_PointerToSOAP_ENV__Code(soap, &quot;SOAP-ENV:Code&quot;, -1, &amp;a-&gt;SOAP_ENV__Code, &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_PointerToSOAP_ENV__Reason(soap, &quot;SOAP-ENV:Reason&quot;, -1, &amp;a-&gt;SOAP_ENV__Reason, &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_string(soap, &quot;SOAP-ENV:Node&quot;, -1, &amp;a-&gt;SOAP_ENV__Node, &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_string(soap, &quot;SOAP-ENV:Role&quot;, -1, &amp;a-&gt;SOAP_ENV__Role, &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_PointerToSOAP_ENV__Detail(soap, &quot;SOAP-ENV:Detail&quot;, -1, &amp;a-&gt;SOAP_ENV__Detail, &quot;&quot;))
+		return soap-&gt;error;
+	return soap_element_end_out(soap, tag);
 }
 
 SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -2292,16 +2347,18 @@
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
 {
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
-	soap_out_string(soap, &quot;SOAP-ENV:Text&quot;, -1, &amp;a-&gt;SOAP_ENV__Text, &quot;&quot;);
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
+		return soap-&gt;error;
+	if (soap_out_string(soap, &quot;SOAP-ENV:Text&quot;, -1, &amp;a-&gt;SOAP_ENV__Text, &quot;&quot;))
+		return soap-&gt;error;
+	return soap_element_end_out(soap, tag);
 }
 
 SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -2406,17 +2463,19 @@
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
 {
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
-	soap_putelement(soap, a-&gt;fault, &quot;fault&quot;, -1, a-&gt;__type);
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
+		return soap-&gt;error;
+	if (soap_putelement(soap, a-&gt;fault, &quot;fault&quot;, -1, a-&gt;__type))
+		return soap-&gt;error;
 	soap_outliteral(soap, &quot;-any&quot;, &amp;a-&gt;__any, NULL);
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	return soap_element_end_out(soap, tag);
 }
 
 SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -2527,17 +2586,20 @@
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
 {
 	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a-&gt;SOAP_ENV__Value);
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
-	soap_out__QName(soap, &quot;SOAP-ENV:Value&quot;, -1, (char*const*)&amp;soap_tmp_SOAP_ENV__Value, &quot;&quot;);
-	soap_out_PointerToSOAP_ENV__Code(soap, &quot;SOAP-ENV:Subcode&quot;, -1, &amp;a-&gt;SOAP_ENV__Subcode, &quot;&quot;);
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
+		return soap-&gt;error;
+	if (soap_out__QName(soap, &quot;SOAP-ENV:Value&quot;, -1, (char*const*)&amp;soap_tmp_SOAP_ENV__Value, &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_PointerToSOAP_ENV__Code(soap, &quot;SOAP-ENV:Subcode&quot;, -1, &amp;a-&gt;SOAP_ENV__Subcode, &quot;&quot;))
+		return soap-&gt;error;
+	return soap_element_end_out(soap, tag);
 }
 
 SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -2626,13 +2688,11 @@
 SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
 {
 	(void)soap; (void)a; /* appease -Wall -Werror */
-	/* transient dummy skipped */
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
 {
 	(void)soap; (void)a; /* appease -Wall -Werror */
-	/* transient dummy skipped */
 }
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
@@ -2645,21 +2705,21 @@
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
 {
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
-	/* transient dummy skipped */
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
+		return soap-&gt;error;
+	return soap_element_end_out(soap, tag);
 }
 
 SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
 SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
-{;
+{
 	if (soap_element_begin_in(soap, tag, 0, type))
 		return NULL;
 	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
@@ -2670,7 +2730,6 @@
 	{
 		for (;;)
 		{	soap-&gt;error = SOAP_TAG_MISMATCH;
-		/* transient dummy skipped */
 			if (soap-&gt;error == SOAP_TAG_MISMATCH)
 				soap-&gt;error = soap_ignore_element(soap);
 			if (soap-&gt;error == SOAP_NO_TAG)
@@ -2764,25 +2823,36 @@
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGoogleSearch(struct soap *soap, const char *tag, int id, const struct gapi1__doGoogleSearch *a, const char *type)
 {
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGoogleSearch), type);
-	soap_out_std__string(soap, &quot;key&quot;, -1, &amp;a-&gt;key, &quot;xsd:string&quot;);
-	soap_out_std__string(soap, &quot;q&quot;, -1, &amp;a-&gt;q, &quot;xsd:string&quot;);
-	soap_out_int(soap, &quot;start&quot;, -1, &amp;a-&gt;start, &quot;xsd:int&quot;);
-	soap_out_int(soap, &quot;maxResults&quot;, -1, &amp;a-&gt;maxResults, &quot;xsd:int&quot;);
-	soap_out_bool(soap, &quot;filter&quot;, -1, &amp;a-&gt;filter, &quot;xsd:boolean&quot;);
-	soap_out_std__string(soap, &quot;restrict&quot;, -1, &amp;a-&gt;restrict_, &quot;xsd:string&quot;);
-	soap_out_bool(soap, &quot;safeSearch&quot;, -1, &amp;a-&gt;safeSearch, &quot;xsd:boolean&quot;);
-	soap_out_std__string(soap, &quot;lr&quot;, -1, &amp;a-&gt;lr, &quot;xsd:string&quot;);
-	soap_out_std__string(soap, &quot;ie&quot;, -1, &amp;a-&gt;ie, &quot;xsd:string&quot;);
-	soap_out_std__string(soap, &quot;oe&quot;, -1, &amp;a-&gt;oe, &quot;xsd:string&quot;);
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGoogleSearch), type))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;key&quot;, -1, &amp;a-&gt;key, &quot;xsd:string&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;q&quot;, -1, &amp;a-&gt;q, &quot;xsd:string&quot;))
+		return soap-&gt;error;
+	if (soap_out_int(soap, &quot;start&quot;, -1, &amp;a-&gt;start, &quot;xsd:int&quot;))
+		return soap-&gt;error;
+	if (soap_out_int(soap, &quot;maxResults&quot;, -1, &amp;a-&gt;maxResults, &quot;xsd:int&quot;))
+		return soap-&gt;error;
+	if (soap_out_bool(soap, &quot;filter&quot;, -1, &amp;a-&gt;filter, &quot;xsd:boolean&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;restrict&quot;, -1, &amp;a-&gt;restrict_, &quot;xsd:string&quot;))
+		return soap-&gt;error;
+	if (soap_out_bool(soap, &quot;safeSearch&quot;, -1, &amp;a-&gt;safeSearch, &quot;xsd:boolean&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;lr&quot;, -1, &amp;a-&gt;lr, &quot;xsd:string&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;ie&quot;, -1, &amp;a-&gt;ie, &quot;xsd:string&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;oe&quot;, -1, &amp;a-&gt;oe, &quot;xsd:string&quot;))
+		return soap-&gt;error;
+	return soap_element_end_out(soap, tag);
 }
 
 SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_get_gapi1__doGoogleSearch(struct soap *soap, struct gapi1__doGoogleSearch *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_gapi1__doGoogleSearch(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -2930,18 +3000,18 @@
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGoogleSearchResponse(struct soap *soap, const char *tag, int id, const struct gapi1__doGoogleSearchResponse *a, const char *type)
 {
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGoogleSearchResponse), type);
-	if (a-&gt;return_)
-		soap_element_result(soap, &quot;return&quot;);
-	soap_out_PointerTogapi1__GoogleSearchResult(soap, &quot;return&quot;, -1, &amp;a-&gt;return_, &quot;&quot;);
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGoogleSearchResponse), type))
+		return soap-&gt;error;
+	if (soap_out_PointerTogapi1__GoogleSearchResult(soap, &quot;return&quot;, -1, &amp;a-&gt;return_, &quot;&quot;))
+		return soap-&gt;error;
+	return soap_element_end_out(soap, tag);
 }
 
 SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_get_gapi1__doGoogleSearchResponse(struct soap *soap, struct gapi1__doGoogleSearchResponse *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_gapi1__doGoogleSearchResponse(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -2963,7 +3033,6 @@
 				{	soap_flag_return_--;
 					continue;
 				}
-			soap_check_result(soap, &quot;return&quot;);
 			if (soap-&gt;error == SOAP_TAG_MISMATCH)
 				soap-&gt;error = soap_ignore_element(soap);
 			if (soap-&gt;error == SOAP_NO_TAG)
@@ -3043,17 +3112,20 @@
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doSpellingSuggestion(struct soap *soap, const char *tag, int id, const struct gapi1__doSpellingSuggestion *a, const char *type)
 {
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doSpellingSuggestion), type);
-	soap_out_std__string(soap, &quot;key&quot;, -1, &amp;a-&gt;key, &quot;xsd:string&quot;);
-	soap_out_std__string(soap, &quot;phrase&quot;, -1, &amp;a-&gt;phrase, &quot;xsd:string&quot;);
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doSpellingSuggestion), type))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;key&quot;, -1, &amp;a-&gt;key, &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;phrase&quot;, -1, &amp;a-&gt;phrase, &quot;&quot;))
+		return soap-&gt;error;
+	return soap_element_end_out(soap, tag);
 }
 
 SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_get_gapi1__doSpellingSuggestion(struct soap *soap, struct gapi1__doSpellingSuggestion *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_gapi1__doSpellingSuggestion(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -3161,17 +3233,18 @@
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doSpellingSuggestionResponse(struct soap *soap, const char *tag, int id, const struct gapi1__doSpellingSuggestionResponse *a, const char *type)
 {
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doSpellingSuggestionResponse), type);
-	soap_element_result(soap, &quot;return&quot;);
-	soap_out_std__string(soap, &quot;return&quot;, -1, &amp;a-&gt;return_, &quot;&quot;);
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doSpellingSuggestionResponse), type))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;return&quot;, -1, &amp;a-&gt;return_, &quot;&quot;))
+		return soap-&gt;error;
+	return soap_element_end_out(soap, tag);
 }
 
 SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_get_gapi1__doSpellingSuggestionResponse(struct soap *soap, struct gapi1__doSpellingSuggestionResponse *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_gapi1__doSpellingSuggestionResponse(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -3193,7 +3266,6 @@
 				{	soap_flag_return_--;
 					continue;
 				}
-			soap_check_result(soap, &quot;return&quot;);
 			if (soap-&gt;error == SOAP_TAG_MISMATCH)
 				soap-&gt;error = soap_ignore_element(soap);
 			if (soap-&gt;error == SOAP_NO_TAG)
@@ -3277,17 +3349,20 @@
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGetCachedPage(struct soap *soap, const char *tag, int id, const struct gapi1__doGetCachedPage *a, const char *type)
 {
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGetCachedPage), type);
-	soap_out_std__string(soap, &quot;key&quot;, -1, &amp;a-&gt;key, &quot;xsd:string&quot;);
-	soap_out_std__string(soap, &quot;url&quot;, -1, &amp;a-&gt;url, &quot;xsd:string&quot;);
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGetCachedPage), type))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;key&quot;, -1, &amp;a-&gt;key, &quot;&quot;))
+		return soap-&gt;error;
+	if (soap_out_std__string(soap, &quot;url&quot;, -1, &amp;a-&gt;url, &quot;&quot;))
+		return soap-&gt;error;
+	return soap_element_end_out(soap, tag);
 }
 
 SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_get_gapi1__doGetCachedPage(struct soap *soap, struct gapi1__doGetCachedPage *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_gapi1__doGetCachedPage(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -3395,17 +3470,18 @@
 
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGetCachedPageResponse(struct soap *soap, const char *tag, int id, const struct gapi1__doGetCachedPageResponse *a, const char *type)
 {
-	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGetCachedPageResponse), type);
-	soap_element_result(soap, &quot;return&quot;);
-	a-&gt;return_.soap_out(soap, &quot;return&quot;, -1, &quot;&quot;);
-	soap_element_end_out(soap, tag);
-	return SOAP_OK;
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGetCachedPageResponse), type))
+		return soap-&gt;error;
+	if (a-&gt;return_.soap_out(soap, &quot;return&quot;, -1, &quot;&quot;))
+		return soap-&gt;error;
+	return soap_element_end_out(soap, tag);
 }
 
 SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_get_gapi1__doGetCachedPageResponse(struct soap *soap, struct gapi1__doGetCachedPageResponse *p, const char *tag, const char *type)
 {
 	if ((p = soap_in_gapi1__doGetCachedPageResponse(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -3427,7 +3503,6 @@
 				{	soap_flag_return_--;
 					continue;
 				}
-			soap_check_result(soap, &quot;return&quot;);
 			if (soap-&gt;error == SOAP_TAG_MISMATCH)
 				soap-&gt;error = soap_ignore_element(soap);
 			if (soap-&gt;error == SOAP_NO_TAG)
@@ -3514,7 +3589,8 @@
 SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
 {
 	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -3568,7 +3644,8 @@
 SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
 {
 	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -3622,7 +3699,8 @@
 SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
 {
 	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -3674,7 +3752,8 @@
 SOAP_FMAC3 gapi1__GoogleSearchResult ** SOAP_FMAC4 soap_get_PointerTogapi1__GoogleSearchResult(struct soap *soap, gapi1__GoogleSearchResult **p, const char *tag, const char *type)
 {
 	if ((p = soap_in_PointerTogapi1__GoogleSearchResult(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -3695,7 +3774,8 @@
 			return NULL;
 	}
 	else
-	{	a = (gapi1__GoogleSearchResult **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1__GoogleSearchResult, sizeof(gapi1__GoogleSearchResult), 0);
+	{	gapi1__GoogleSearchResult ** p = (gapi1__GoogleSearchResult **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1__GoogleSearchResult, sizeof(gapi1__GoogleSearchResult), 0);
+		a = p;
 		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
 			return NULL;
 	}
@@ -3727,7 +3807,8 @@
 SOAP_FMAC3 gapi1__DirectoryCategory *** SOAP_FMAC4 soap_get_PointerToPointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory ***p, const char *tag, const char *type)
 {
 	if ((p = soap_in_PointerToPointerTogapi1__DirectoryCategory(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -3777,7 +3858,8 @@
 SOAP_FMAC3 gapi1__ResultElement *** SOAP_FMAC4 soap_get_PointerToPointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement ***p, const char *tag, const char *type)
 {
 	if ((p = soap_in_PointerToPointerTogapi1__ResultElement(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -3827,7 +3909,8 @@
 SOAP_FMAC3 gapi1__ResultElement ** SOAP_FMAC4 soap_get_PointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement **p, const char *tag, const char *type)
 {
 	if ((p = soap_in_PointerTogapi1__ResultElement(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -3848,7 +3931,8 @@
 			return NULL;
 	}
 	else
-	{	a = (gapi1__ResultElement **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1__ResultElement, sizeof(gapi1__ResultElement), 0);
+	{	gapi1__ResultElement ** p = (gapi1__ResultElement **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1__ResultElement, sizeof(gapi1__ResultElement), 0);
+		a = p;
 		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
 			return NULL;
 	}
@@ -3880,7 +3964,8 @@
 SOAP_FMAC3 gapi1__DirectoryCategory ** SOAP_FMAC4 soap_get_PointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory **p, const char *tag, const char *type)
 {
 	if ((p = soap_in_PointerTogapi1__DirectoryCategory(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -3901,7 +3986,8 @@
 			return NULL;
 	}
 	else
-	{	a = (gapi1__DirectoryCategory **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1__DirectoryCategory, sizeof(gapi1__DirectoryCategory), 0);
+	{	gapi1__DirectoryCategory ** p = (gapi1__DirectoryCategory **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1__DirectoryCategory, sizeof(gapi1__DirectoryCategory), 0);
+		a = p;
 		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
 			return NULL;
 	}
@@ -3933,7 +4019,8 @@
 SOAP_FMAC3 gapi1DirectoryCategoryArray ** SOAP_FMAC4 soap_get_PointerTogapi1DirectoryCategoryArray(struct soap *soap, gapi1DirectoryCategoryArray **p, const char *tag, const char *type)
 {
 	if ((p = soap_in_PointerTogapi1DirectoryCategoryArray(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -3954,7 +4041,8 @@
 			return NULL;
 	}
 	else
-	{	a = (gapi1DirectoryCategoryArray **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1DirectoryCategoryArray, sizeof(gapi1DirectoryCategoryArray), 0);
+	{	gapi1DirectoryCategoryArray ** p = (gapi1DirectoryCategoryArray **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1DirectoryCategoryArray, sizeof(gapi1DirectoryCategoryArray), 0);
+		a = p;
 		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
 			return NULL;
 	}
@@ -3986,7 +4074,8 @@
 SOAP_FMAC3 gapi1ResultElementArray ** SOAP_FMAC4 soap_get_PointerTogapi1ResultElementArray(struct soap *soap, gapi1ResultElementArray **p, const char *tag, const char *type)
 {
 	if ((p = soap_in_PointerTogapi1ResultElementArray(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -4007,7 +4096,8 @@
 			return NULL;
 	}
 	else
-	{	a = (gapi1ResultElementArray **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1ResultElementArray, sizeof(gapi1ResultElementArray), 0);
+	{	gapi1ResultElementArray ** p = (gapi1ResultElementArray **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1ResultElementArray, sizeof(gapi1ResultElementArray), 0);
+		a = p;
 		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
 			return NULL;
 	}
@@ -4038,7 +4128,8 @@
 SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
 {
 	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -4087,7 +4178,8 @@
 SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
 {
 	if ((p = soap_in__QName(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 
@@ -4126,7 +4218,8 @@
 SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
 {
 	if ((p = soap_in_string(soap, tag, p, type)))
-		soap_getindependent(soap);
+		if (soap_getindependent(soap))
+			return NULL;
 	return p;
 }
 

Modified: trunk/IndexSearch/Google/GAPIClient.cpp
===================================================================
--- trunk/IndexSearch/Google/GAPIClient.cpp	2008-08-04 14:15:56 UTC (rev 1320)
+++ trunk/IndexSearch/Google/GAPIClient.cpp	2008-08-04 14:22:08 UTC (rev 1321)
@@ -1,12 +1,12 @@
 /* GAPIClient.cpp
-   Generated by gSOAP 2.7.9e from GoogleSearch.h
-   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   Generated by gSOAP 2.7.10 from GoogleSearch.h
+   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
    This part of the software is released under one of the following licenses:
    GPL, the gSOAP public license, or Genivia's license for commercial use.
 */
 #include &quot;GAPIH.h&quot;
 
-SOAP_SOURCE_STAMP(&quot;@(#) GAPIClient.cpp ver 2.7.9e 2007-07-29 10:34:02 GMT&quot;)
+SOAP_SOURCE_STAMP(&quot;@(#) GAPIClient.cpp ver 2.7.10 2008-08-04 14:27:08 GMT&quot;)
 
 
 SOAP_FMAC5 int SOAP_FMAC6 soap_call_gapi1__doGetCachedPage(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string key, std::string url, xsd__base64Binary &amp;return_)

Modified: trunk/IndexSearch/Google/GAPIClientLib.cpp
===================================================================
--- trunk/IndexSearch/Google/GAPIClientLib.cpp	2008-08-04 14:15:56 UTC (rev 1320)
+++ trunk/IndexSearch/Google/GAPIClientLib.cpp	2008-08-04 14:22:08 UTC (rev 1321)
@@ -1,6 +1,6 @@
 /* GAPIClientLib.cpp
-   Generated by gSOAP 2.7.9e from GoogleSearch.h
-   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   Generated by gSOAP 2.7.10 from GoogleSearch.h
+   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
    This part of the software is released under one of the following licenses:
    GPL, the gSOAP public license, or Genivia's license for commercial use.
 */

Modified: trunk/IndexSearch/Google/GAPIGoogleSearchBindingProxy.h
===================================================================
--- trunk/IndexSearch/Google/GAPIGoogleSearchBindingProxy.h	2008-08-04 14:15:56 UTC (rev 1320)
+++ trunk/IndexSearch/Google/GAPIGoogleSearchBindingProxy.h	2008-08-04 14:22:08 UTC (rev 1321)
@@ -1,22 +1,29 @@
 /* GAPIGoogleSearchBindingProxy.h
-   Generated by gSOAP 2.7.9e from GoogleSearch.h
-   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   Generated by gSOAP 2.7.10 from GoogleSearch.h
+   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
    This part of the software is released under one of the following licenses:
    GPL, the gSOAP public license, or Genivia's license for commercial use.
 */
 
-#ifndef GAPIGoogleSearchBinding_H
-#define GAPIGoogleSearchBinding_H
+#ifndef GAPIGoogleSearchBindingProxy_H
+#define GAPIGoogleSearchBindingProxy_H
 #include &quot;GAPIH.h&quot;
 extern SOAP_NMAC struct Namespace GAPI_namespaces[];
 class GoogleSearchBinding
 {   public:
+	/// Runtime engine context allocated in constructor
 	struct soap *soap;
+	/// Endpoint URL of service 'GoogleSearchBinding' (change as needed)
 	const char *endpoint;
+	/// Constructor allocates soap engine context, sets default endpoint URL, and sets namespace mapping table
 	GoogleSearchBinding() { soap = soap_new(); if (soap) soap-&gt;namespaces = GAPI_namespaces; endpoint = &quot;<A HREF="http://api.google.com/search/beta2">http://api.google.com/search/beta2</A>&quot;; };
+	/// Destructor frees deserialized data and soap engine context
 	virtual ~GoogleSearchBinding() { if (soap) { soap_destroy(soap); soap_end(soap); soap_free(soap); } };
+	/// Invoke 'doGetCachedPage' of service 'GoogleSearchBinding' and return error code (or SOAP_OK)
 	virtual int gapi1__doGetCachedPage(std::string key, std::string url, xsd__base64Binary &amp;return_) { return soap ? soap_call_gapi1__doGetCachedPage(soap, endpoint, NULL, key, url, return_) : SOAP_EOM; };
+	/// Invoke 'doSpellingSuggestion' of service 'GoogleSearchBinding' and return error code (or SOAP_OK)
 	virtual int gapi1__doSpellingSuggestion(std::string key, std::string phrase, std::string &amp;return_) { return soap ? soap_call_gapi1__doSpellingSuggestion(soap, endpoint, NULL, key, phrase, return_) : SOAP_EOM; };
+	/// Invoke 'doGoogleSearch' of service 'GoogleSearchBinding' and return error code (or SOAP_OK)
 	virtual int gapi1__doGoogleSearch(std::string key, std::string q, int start, int maxResults, bool filter, std::string restrict_, bool safeSearch, std::string lr, std::string ie, std::string oe, struct gapi1__doGoogleSearchResponse &amp;_param_1) { return soap ? soap_call_gapi1__doGoogleSearch(soap, endpoint, NULL, key, q, start, maxResults, filter, restrict_, safeSearch, lr, ie, oe, _param_1) : SOAP_EOM; };
 };
 #endif

Modified: trunk/IndexSearch/Google/GAPIH.h
===================================================================
--- trunk/IndexSearch/Google/GAPIH.h	2008-08-04 14:15:56 UTC (rev 1320)
+++ trunk/IndexSearch/Google/GAPIH.h	2008-08-04 14:22:08 UTC (rev 1321)
@@ -1,6 +1,6 @@
 /* GAPIH.h
-   Generated by gSOAP 2.7.9e from GoogleSearch.h
-   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   Generated by gSOAP 2.7.10 from GoogleSearch.h
+   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
    This part of the software is released under one of the following licenses:
    GPL, the gSOAP public license, or Genivia's license for commercial use.
 */
@@ -34,7 +34,7 @@
 SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap*, int, int, void*, size_t, const void*, size_t);
 
 #ifndef SOAP_TYPE_byte
-#define SOAP_TYPE_byte (2)
+#define SOAP_TYPE_byte (3)
 #endif
 SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap*, char *);
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap*, const char *, const char*, const char*);
@@ -61,7 +61,7 @@
 SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap*, const char*, double *, const char*);
 
 #ifndef SOAP_TYPE_unsignedByte
-#define SOAP_TYPE_unsignedByte (9)
+#define SOAP_TYPE_unsignedByte (10)
 #endif
 SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap*, unsigned char *);
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap*, const unsigned char *, const char*, const char*);
@@ -70,7 +70,7 @@
 SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap*, const char*, unsigned char *, const char*);
 
 #ifndef SOAP_TYPE_unsignedInt
-#define SOAP_TYPE_unsignedInt (8)
+#define SOAP_TYPE_unsignedInt (9)
 #endif
 SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap*, unsigned int *);
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap*, const unsigned int *, const char*, const char*);
@@ -164,7 +164,7 @@
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__GoogleSearchResult(struct soap*, int, int, void*, size_t, const void*, size_t);
 
 #ifndef SOAP_TYPE_xsd__base64Binary
-#define SOAP_TYPE_xsd__base64Binary (7)
+#define SOAP_TYPE_xsd__base64Binary (8)
 #endif
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap*, const char*, int, const xsd__base64Binary *, const char*);
 SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap*, xsd__base64Binary *, const char*, const char*);
@@ -213,7 +213,7 @@
 #ifndef WITH_NOGLOBAL
 
 #ifndef SOAP_TYPE_SOAP_ENV__Detail
-#define SOAP_TYPE_SOAP_ENV__Detail (45)
+#define SOAP_TYPE_SOAP_ENV__Detail (43)
 #endif
 SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *);
 SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *);
@@ -231,7 +231,7 @@
 #ifndef WITH_NOGLOBAL
 
 #ifndef SOAP_TYPE_SOAP_ENV__Code
-#define SOAP_TYPE_SOAP_ENV__Code (43)
+#define SOAP_TYPE_SOAP_ENV__Code (41)
 #endif
 SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *);
 SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *);
@@ -249,7 +249,7 @@
 #ifndef WITH_NOGLOBAL
 
 #ifndef SOAP_TYPE_SOAP_ENV__Header
-#define SOAP_TYPE_SOAP_ENV__Header (42)
+#define SOAP_TYPE_SOAP_ENV__Header (40)
 #endif
 SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *);
 SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *);
@@ -377,7 +377,7 @@
 #ifndef WITH_NOGLOBAL
 
 #ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
-#define SOAP_TYPE_PointerToSOAP_ENV__Code (44)
+#define SOAP_TYPE_PointerToSOAP_ENV__Code (42)
 #endif
 SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*);
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*, const char*, const char*);
@@ -451,7 +451,7 @@
 SOAP_FMAC3 gapi1ResultElementArray ** SOAP_FMAC4 soap_in_PointerTogapi1ResultElementArray(struct soap*, const char*, gapi1ResultElementArray **, const char*);
 
 #ifndef SOAP_TYPE_PointerTounsignedByte
-#define SOAP_TYPE_PointerTounsignedByte (10)
+#define SOAP_TYPE_PointerTounsignedByte (11)
 #endif
 SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap*, unsigned char *const*);
 SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap*, unsigned char *const*, const char*, const char*);
@@ -470,7 +470,7 @@
 SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap*, const char*, char **, const char*);
 
 #ifndef SOAP_TYPE_string
-#define SOAP_TYPE_string (3)
+#define SOAP_TYPE_string (4)
 #endif
 SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap*, char **);
 SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap*, char *const*);

Modified: trunk/IndexSearch/Google/GAPIStub.h
===================================================================
--- trunk/IndexSearch/Google/GAPIStub.h	2008-08-04 14:15:56 UTC (rev 1320)
+++ trunk/IndexSearch/Google/GAPIStub.h	2008-08-04 14:22:08 UTC (rev 1321)
@@ -1,6 +1,6 @@
 /* GAPIStub.h
-   Generated by gSOAP 2.7.9e from GoogleSearch.h
-   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   Generated by gSOAP 2.7.10 from GoogleSearch.h
+   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
    This part of the software is released under one of the following licenses:
    GPL, the gSOAP public license, or Genivia's license for commercial use.
 */
@@ -8,7 +8,9 @@
 #ifndef GAPIStub_H
 #define GAPIStub_H
 #include &lt;vector&gt;
+#ifndef WITH_NONAMESPACES
 #define WITH_NONAMESPACES
+#endif
 #include &quot;stdsoap2.h&quot;
 
 /******************************************************************************\
@@ -25,10 +27,12 @@
 \******************************************************************************/
 
 
+#if 0 /* volatile type: do not redeclare here */
 
+#endif
 
 #ifndef SOAP_TYPE_xsd__base64Binary
-#define SOAP_TYPE_xsd__base64Binary (7)
+#define SOAP_TYPE_xsd__base64Binary (8)
 /* Base64 schema type: */
 class SOAP_CMAC xsd__base64Binary
 {
@@ -40,19 +44,19 @@
 	char *options;	/* optional element of type xsd:string */
 	struct soap *soap;	/* transient */
 public:
-	virtual int soap_type() const { return 7; } /* = unique id SOAP_TYPE_xsd__base64Binary */
+	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_xsd__base64Binary */
 	virtual void soap_default(struct soap*);
 	virtual void soap_serialize(struct soap*) const;
 	virtual int soap_put(struct soap*, const char*, const char*) const;
 	virtual int soap_out(struct soap*, const char*, int, const char*) const;
 	virtual void *soap_get(struct soap*, const char*, const char*);
 	virtual void *soap_in(struct soap*, const char*, const char*);
-	         xsd__base64Binary() : __ptr(NULL), id(NULL), type(NULL), options(NULL), soap(NULL) { }
+	         xsd__base64Binary() : __ptr(NULL), __size(0), id(NULL), type(NULL), options(NULL), soap(NULL) { }
 	virtual ~xsd__base64Binary() { }
 };
 #endif
 
-#if 0 /* volatile type: do not redeclare */
+#if 0 /* volatile type: do not redeclare here */
 
 #endif
 
@@ -82,7 +86,7 @@
 	virtual int soap_out(struct soap*, const char*, int, const char*) const;
 	virtual void *soap_get(struct soap*, const char*, const char*);
 	virtual void *soap_in(struct soap*, const char*, const char*);
-	         gapi1__GoogleSearchResult() : resultElements(NULL), directoryCategories(NULL), soap(NULL) { }
+	         gapi1__GoogleSearchResult() : documentFiltering((bool)0), estimatedTotalResultsCount(0), estimateIsExact((bool)0), resultElements(NULL), startIndex(0), endIndex(0), directoryCategories(NULL), searchTime(0), soap(NULL) { }
 	virtual ~gapi1__GoogleSearchResult() { }
 };
 #endif
@@ -111,7 +115,7 @@
 	virtual int soap_out(struct soap*, const char*, int, const char*) const;
 	virtual void *soap_get(struct soap*, const char*, const char*);
 	virtual void *soap_in(struct soap*, const char*, const char*);
-	         gapi1__ResultElement() : directoryCategory(NULL), soap(NULL) { }
+	         gapi1__ResultElement() : relatedInformationPresent((bool)0), directoryCategory(NULL), soap(NULL) { }
 	virtual ~gapi1__ResultElement() { }
 };
 #endif
@@ -155,7 +159,7 @@
 	virtual int soap_out(struct soap*, const char*, int, const char*) const;
 	virtual void *soap_get(struct soap*, const char*, const char*);
 	virtual void *soap_in(struct soap*, const char*, const char*);
-	         gapi1ResultElementArray() : __ptr(NULL), soap(NULL) { }
+	         gapi1ResultElementArray() : __ptr(NULL), __size(0), soap(NULL) { }
 	virtual ~gapi1ResultElementArray() { }
 };
 #endif
@@ -177,7 +181,7 @@
 	virtual int soap_out(struct soap*, const char*, int, const char*) const;
 	virtual void *soap_get(struct soap*, const char*, const char*);
 	virtual void *soap_in(struct soap*, const char*, const char*);
-	         gapi1DirectoryCategoryArray() : __ptr(NULL), soap(NULL) { }
+	         gapi1DirectoryCategoryArray() : __ptr(NULL), __size(0), soap(NULL) { }
 	virtual ~gapi1DirectoryCategoryArray() { }
 };
 #endif
@@ -188,7 +192,7 @@
 struct gapi1__doGetCachedPageResponse
 {
 public:
-	xsd__base64Binary return_;	/* RPC return element */	/* required element of type xsd:base64Binary */
+	xsd__base64Binary return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:base64Binary */
 };
 #endif
 
@@ -209,7 +213,7 @@
 struct gapi1__doSpellingSuggestionResponse
 {
 public:
-	std::string return_;	/* RPC return element */	/* required element of type xsd:string */
+	std::string return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
 };
 #endif
 
@@ -230,7 +234,7 @@
 struct gapi1__doGoogleSearchResponse
 {
 public:
-	gapi1__GoogleSearchResult *return_;	/* RPC return element */	/* optional element of type gapi1:GoogleSearchResult */
+	gapi1__GoogleSearchResult *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type gapi1:GoogleSearchResult */
 };
 #endif
 
@@ -254,17 +258,19 @@
 #endif
 
 #ifndef SOAP_TYPE_SOAP_ENV__Header
-#define SOAP_TYPE_SOAP_ENV__Header (42)
+#define SOAP_TYPE_SOAP_ENV__Header (40)
 /* SOAP Header: */
 struct SOAP_ENV__Header
 {
-public:
-	void *dummy;	/* transient */
+#ifdef WITH_NOEMPTYSTRUCT
+private:
+	char dummy;	/* dummy member to enable compilation */
+#endif
 };
 #endif
 
 #ifndef SOAP_TYPE_SOAP_ENV__Code
-#define SOAP_TYPE_SOAP_ENV__Code (43)
+#define SOAP_TYPE_SOAP_ENV__Code (41)
 /* SOAP Fault Code: */
 struct SOAP_ENV__Code
 {
@@ -275,7 +281,7 @@
 #endif
 
 #ifndef SOAP_TYPE_SOAP_ENV__Detail
-#define SOAP_TYPE_SOAP_ENV__Detail (45)
+#define SOAP_TYPE_SOAP_ENV__Detail (43)
 /* SOAP-ENV:Detail */
 struct SOAP_ENV__Detail
 {
@@ -327,17 +333,17 @@
  *                                                                            *
 \******************************************************************************/
 
-#ifndef SOAP_TYPE__XML
-#define SOAP_TYPE__XML (4)
-typedef char *_XML;
-#endif
-
 #ifndef SOAP_TYPE__QName
 #define SOAP_TYPE__QName (5)
 typedef char *_QName;
 #endif
 
+#ifndef SOAP_TYPE__XML
+#define SOAP_TYPE__XML (6)
+typedef char *_XML;
+#endif
 
+
 /******************************************************************************\
  *                                                                            *
  * Typedef Synonyms                                                           *

Modified: trunk/IndexSearch/Google/GoogleAPIEngine.cpp
===================================================================
--- trunk/IndexSearch/Google/GoogleAPIEngine.cpp	2008-08-04 14:15:56 UTC (rev 1320)
+++ trunk/IndexSearch/Google/GoogleAPIEngine.cpp	2008-08-04 14:22:08 UTC (rev 1321)
@@ -29,6 +29,8 @@
 using std::cerr;
 using std::endl;
 
+struct Namespace *namespaces;
+
 GoogleAPIEngine::GoogleAPIEngine(const string &amp;key) :
 	WebEngine(),
 	m_key(key)

Modified: trunk/IndexSearch/Google/GoogleSearch.h
===================================================================
--- trunk/IndexSearch/Google/GoogleSearch.h	2008-08-04 14:15:56 UTC (rev 1320)
+++ trunk/IndexSearch/Google/GoogleSearch.h	2008-08-04 14:22:08 UTC (rev 1321)
@@ -1,7 +1,7 @@
 /* GoogleSearch.h
-   Generated by wsdl2h 1.2.9e from googleapi/GoogleSearch.wsdl and typemap.dat
-   2007-07-29 10:33:46 GMT
-   Copyright (C) 2001-2006 Robert van Engelen, Genivia Inc. All Rights Reserved.
+   Generated by wsdl2h 1.2.10 from googleapi/GoogleSearch.wsdl and typemap.dat
+   2008-08-03 16:08:14 GMT
+   Copyright (C) 2001-2008 Robert van Engelen, Genivia Inc. All Rights Reserved.
    This part of the software is released under one of the following licenses:
    GPL or Genivia's license for commercial use.
 */
@@ -12,7 +12,7 @@
  - Use soapcpp2 option -I to specify paths for #import
    To build with STL, 'stlvector.h' is imported from 'import' dir in package.
  - Use wsdl2h options -c and -s to generate pure C code or C++ code without STL.
- - Use 'typemap.dat' to control schema namespace bindings and type mappings.
+ - Use 'WS/typemap.dat' to control namespace bindings and type mappings.
    It is strongly recommended to customize the names of the namespace prefixes
    generated by wsdl2h. To do so, modify the prefix bindings in the Namespaces
    section below and add the modified lines to 'typemap.dat' to rerun wsdl2h.
@@ -73,7 +73,7 @@
 class xsd__base64Binary
 {	unsigned char *__ptr;
 	int __size;
-	char *id, *type, *options; /* NOTE: for DIME and MTOM XOP attachments only */
+	char *id, *type, *options; // NOTE: for DIME and MTOM XOP attachments only
 	struct soap *soap;
 };
 
@@ -274,6 +274,8 @@
 C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
   class GoogleSearchBinding;
 
+Note: use soapcpp2 option '-i' to generate improved proxy and service classes;
+
 */
 
 //gsoap gapi1 service method-style:	doGetCachedPage rpc
@@ -330,6 +332,8 @@
 C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
   class GoogleSearchBinding;
 
+Note: use soapcpp2 option '-i' to generate improved proxy and service classes;
+
 */
 
 //gsoap gapi1 service method-style:	doSpellingSuggestion rpc
@@ -407,6 +411,8 @@
 C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
   class GoogleSearchBinding;
 
+Note: use soapcpp2 option '-i' to generate improved proxy and service classes;
+
 */
 
 //gsoap gapi1 service method-style:	doGoogleSearch rpc

Modified: trunk/IndexSearch/Google/Makefile.am
===================================================================
--- trunk/IndexSearch/Google/Makefile.am	2008-08-04 14:15:56 UTC (rev 1320)
+++ trunk/IndexSearch/Google/Makefile.am	2008-08-04 14:22:08 UTC (rev 1321)
@@ -6,30 +6,35 @@
 	GAPIH.h \
 	GAPIStub.h \
 	GoogleAPIEngine.h \
-	GoogleSearch.h
+	GoogleSearch.h \
+	GAPIClientLib.cpp
 
 if HAVE_SOAP
-noinst_LTLIBRARIES = libSearchGoogle.la
+lib_LTLIBRARIES = libgoogleapibackend.la
 
-libSearchGoogle_la_SOURCES = \
+libgoogleapibackend_la_SOURCES = \
 	GAPIC.cpp \
 	GAPIClient.cpp \
-	GAPIClientLib.cpp \
-	GoogleAPIEngine.cpp
+	GoogleAPIEngine.cpp \
+	ModuleExports.cpp
 
+libgoogleapibackend_la_LDFLAGS = -module -shared -nostartfiles
+
+libgoogleapibackend_la_LIBADD = \
+	@SOAP_LIBS@ @MISC_LIBS@
+
 GoogleSearch.h :
 	wsdl2h -n gapi -o GoogleSearch.h googleapi/GoogleSearch.wsdl
 
 GAPIClientLib.cpp : GoogleSearch.h
 	soapcpp2 -n -pGAPI -I/usr/include/gsoap/import -I/usr/share/gsoap/import GoogleSearch.h
 
-libSearchGoogle_la_CXXFLAGS = \
+libgoogleapibackend_la_CXXFLAGS = \
 	-I$(top_srcdir)/Utils \
 	-I$(top_srcdir)/Tokenize \
 	-I$(top_srcdir)/Tokenize/filters \
 	-I$(top_srcdir)/Collect \
 	-I$(top_srcdir)/IndexSearch \
-	@HTTP_CFLAGS@ @XML_CFLAGS@ @SOAP_CFLAGS@ \
-	@INDEX_CFLAGS@
+	@HTTP_CFLAGS@ @XML_CFLAGS@ @SOAP_CFLAGS@
 endif
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001314.html">[Pinot-svn] r1320 - in trunk: . Collect IndexSearch	IndexSearch/Xapian IndexSearch/XesamGLib Monitor SQL Tokenize	UI/GTK2/src Utils
</A></li>
	<LI>Next message: <A HREF="001316.html">[Pinot-svn] r1322 - trunk/IndexSearch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1315">[ date ]</a>
              <a href="thread.html#1315">[ thread ]</a>
              <a href="subject.html#1315">[ subject ]</a>
              <a href="author.html#1315">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/pinot-svn">More information about the Pinot-svn
mailing list</a><br>
</body></html>
