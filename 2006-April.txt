From fabricecolin at berlios.de  Tue Apr  4 13:23:40 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 4 Apr 2006 13:23:40 +0200
Subject: [Pinot-svn] r178 - trunk/Search
Message-ID: <200604041123.k34BNeVO015815@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-04 13:23:31 +0200 (Tue, 04 Apr 2006)
New Revision: 178

Removed:
   trunk/Search/ObjectsSearch/
Log:
ObjectsSearch API is long obsolete.




From fabricecolin at berlios.de  Tue Apr  4 14:25:43 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 4 Apr 2006 14:25:43 +0200
Subject: [Pinot-svn] r179 - in trunk: . Search Search/Google
Message-ID: <200604041225.k34CPhLo005319@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-04 14:25:39 +0200 (Tue, 04 Apr 2006)
New Revision: 179

Added:
   trunk/Search/Google/Makefile.am
   trunk/Search/SOAPEnv.h
Modified:
   trunk/Makefile.am
   trunk/Search/Google/GoogleAPIEngine.cpp
   trunk/Search/Google/GoogleSearch.h
   trunk/Search/Makefile.am
   trunk/Search/SearchEngineFactory.cpp
   trunk/configure.in
Log:
Attempt at resurrecting support for the Google SOAP API. Option --with-soap=yes
can be passed at configure time. This will use gsoap's utilities to generate
stubs based on Search/Google/googleapi/GoogleSearch.wsdl.


Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2006-04-04 11:23:31 UTC (rev 178)
+++ trunk/Makefile.am	2006-04-04 12:25:39 UTC (rev 179)
@@ -1,7 +1,7 @@
 # generated 2005/12/14 20:48:47 SGT by fabrice at amra.dyndns.org.(none)
 # using glademm V2.6.0
 
-SUBDIRS = po Utils Tokenize SQL Collect Search \
+SUBDIRS = po Utils Tokenize SQL Collect @SOAP_SUBDIRS@ Search \
 	Index UI/RenderHTML UI/GTK2/src
 
 EXTRA_DIST = ChangeLog NEWS README TODO mkinstalldirs pinot.spec \

Modified: trunk/Search/Google/GoogleAPIEngine.cpp
===================================================================
--- trunk/Search/Google/GoogleAPIEngine.cpp	2006-04-04 11:23:31 UTC (rev 178)
+++ trunk/Search/Google/GoogleAPIEngine.cpp	2006-04-04 12:25:39 UTC (rev 179)
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include <iostream>
+
 #include "Url.h"
 #include "MIMEScanner.h"
 
@@ -21,7 +23,8 @@
 #include "GAPIGoogleSearchBindingProxy.h"
 #include "GAPI.nsmap"
 
-using namespace GAPI;
+using std::cout;
+using std::endl;
 
 GoogleAPIEngine::GoogleAPIEngine() :
 	SearchEngineInterface()
@@ -39,14 +42,13 @@
 Document *GoogleAPIEngine::retrieveCachedUrl(const string &url)
 {
 	GoogleSearchBinding soapProxy;
-	struct gapi1__doGetCachedPageResponse cacheOut;
+	xsd__base64Binary base64Page;
 
-	if (soapProxy.gapi1__doGetCachedPage(m_key, url, cacheOut))
+	if (soapProxy.gapi1__doGetCachedPage(m_key, url, base64Page))
 	{
 		return NULL;
 	}
 
-	xsd__base64Binary base64Page = cacheOut.return_;
 	if ((base64Page.__ptr != NULL) &&
 		(base64Page. __size > 0))
 	{
@@ -65,14 +67,14 @@
 string GoogleAPIEngine::checkSpelling(const string &text)
 {
 	GoogleSearchBinding soapProxy;
-	struct gapi1__doSpellingSuggestionResponse spellOut;
+	string spellOut;
 
 	if (soapProxy.gapi1__doSpellingSuggestion(m_key, text, spellOut))
 	{
 		return "";
 	}
 
-	return spellOut.return_;
+	return spellOut;
 }
 
 //
@@ -90,6 +92,9 @@
 
 	if (m_key.empty() == true)
 	{
+#ifdef DEBUG
+		cout << "GoogleAPIEngine::runQuery: no key" << endl;
+#endif
 		return false;
 	}
 
@@ -109,9 +114,14 @@
 	struct gapi1__doGoogleSearchResponse queryOut;
 
 	// No filter, no safe search
-	if (soapProxy.gapi1__doGoogleSearch(m_key, andTerms, 0, (m_maxResultsCount > 10 ? 10 : m_maxResultsCount),
-		((phrase.empty() == false) ? true : false), phrase, false, "", "latin1", "latin1", queryOut))
+	// std::string key, std::string q, int start, int maxResults, bool filter, std::string restrict_, bool safeSearch, std::string lr, std::string ie, std::string oe, struct gapi1__doGoogleSearchResponse &_param_1
+	int soapStatus = soapProxy.gapi1__doGoogleSearch(m_key, andTerms, 0, (int)(m_maxResultsCount > 10 ? 10 : m_maxResultsCount),
+		((phrase.empty() == false) ? true : false), phrase, false, "", "utf-8", "utf-8", queryOut);
+	if (soapStatus != SOAP_OK)
 	{
+#ifdef DEBUG
+		cout << "GoogleAPIEngine::runQuery: search failed with status " << soapStatus << endl;
+#endif
 		return false;
 	}
 

Modified: trunk/Search/Google/GoogleSearch.h
===================================================================
--- trunk/Search/Google/GoogleSearch.h	2006-04-04 11:23:31 UTC (rev 178)
+++ trunk/Search/Google/GoogleSearch.h	2006-04-04 12:25:39 UTC (rev 179)
@@ -1,141 +1,260 @@
-namespace GAPI
-{
-/*  Web Services Definitions urn:GoogleSearch */
+/* GoogleSearch.h
+   Generated by wsdl2h 1.2.6e from googleapi/GoogleSearch.wsdl and typemap.dat
+   2006-04-02 07:30:36 GMT
+   Copyright (C) 2001-2005 Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL or Genivia's license for commercial use.
+*/
 
-/*  Modify this file to customize the generated data type declarations */
+/* NOTE:
 
-/*
+ - Compile this file with soapcpp2 to complete the code generation process.
+ - Use soapcpp2 option -I to specify paths for #import
+   To build with STL, 'stlvector.h' is imported from 'import' dir in package.
+ - Use wsdl2h options -c and -s to generate pure C code or C++ code without STL.
+ - Use 'typemap.dat' to control schema namespace bindings and type mappings.
+   It is strongly recommended to customize the names of the namespace prefixes
+   generated by wsdl2h. To do so, modify the prefix bindings in the Namespaces
+   section below and add the modified lines to 'typemap.dat' to rerun wsdl2h.
+ - Use Doxygen (www.doxygen.org) to browse this file.
+ - Use wsdl2h option -l to view the software license terms.
 
-**  The gSOAP WSDL parser for C and C++ 1.1.2
-**  Copyright (C) 2001-2004 Robert van Engelen, Genivia, Inc.
-**  All Rights Reserved. This product is provided "as is", without any warranty.
+*/
 
+/******************************************************************************\
+ *                                                                            *
+ * urn:GoogleSearch                                                           *
+ *                                                                            *
+\******************************************************************************/
 
---------------------------------------------------------------------------------
-gSOAP XML Web services tools
-Copyright (C) 2001-2004, Robert van Engelen, Genivia, Inc. All Rights Reserved.
+//gsoapopt w
 
-GPL license.
+/******************************************************************************\
+ *                                                                            *
+ * Import                                                                     *
+ *                                                                            *
+\******************************************************************************/
 
-This program is free software; you can redistribute it and/or modify it under
-the terms of the GNU General Public License as published by the Free Software
-Foundation; either version 2 of the License, or (at your option) any later
-version.
+#import "stlvector.h"
 
-This program is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-PARTICULAR PURPOSE. See the GNU General Public License for more details.
+/******************************************************************************\
+ *                                                                            *
+ * Schema Namespaces                                                          *
+ *                                                                            *
+\******************************************************************************/
 
-You should have received a copy of the GNU General Public License along with
-this program; if not, write to the Free Software Foundation, Inc., 59 Temple
-Place, Suite 330, Boston, MA 02111-1307 USA
 
-Author contact information:
-engelen at genivia.com / engelen at acm.org
---------------------------------------------------------------------------------
-*/
+/* NOTE:
 
-//gsoapopt w
-#import "stl.h"
-// built-in type "xs:base64Binary":
-class xsd__base64Binary { unsigned char *__ptr; int __size; };
+It is strongly recommended to customize the names of the namespace prefixes
+generated by wsdl2h. To do so, modify the prefix bindings below and add the
+modified lines to typemap.dat to rerun wsdl2h:
 
-/*
-To customize the names of the namespace prefixes generated by wsdl2h, modify
-the prefix names below and add the modified lines to typemap.dat to run wsdl2h:
+gapi1 = "urn:GoogleSearch"
 
-gapi1 = urn:GoogleSearch
 */
 
 //gsoap gapi1 schema namespace:	urn:GoogleSearch
+//gsoap gapi1 schema form:	unqualified
 
-// forward declarations
+/******************************************************************************\
+ *                                                                            *
+ * Schema Types                                                               *
+ *                                                                            *
+\******************************************************************************/
+
+
+/// Built-in type "xs:base64Binary".
+class xsd__base64Binary
+{	unsigned char *__ptr;
+	int __size;
+	char *id, *type, *options; /* NOTE: for DIME and MTOM XOP attachments only */
+	struct soap *soap;
+};
+
+/// Built-in attribute "SOAP-ENC:arrayType".
+typedef std::string _SOAP_ENC__arrayType;
+
+
+//  Forward declaration of class gapi1__GoogleSearchResult.
 class gapi1__GoogleSearchResult;
+
+//  Forward declaration of class gapi1__ResultElement.
 class gapi1__ResultElement;
-class ResultElementArray;
-class DirectoryCategoryArray;
+
+//  Forward declaration of class gapi1ResultElementArray.
+class gapi1ResultElementArray;
+
+//  Forward declaration of class gapi1DirectoryCategoryArray.
+class gapi1DirectoryCategoryArray;
+
+//  Forward declaration of class gapi1__DirectoryCategory.
 class gapi1__DirectoryCategory;
 
-
+/// "urn:GoogleSearch":GoogleSearchResult is a complexType.
 class gapi1__GoogleSearchResult
 { public:
-    bool                                 documentFiltering             ;
-    std::string                          searchComments                ;
-    int                                  estimatedTotalResultsCount    ;
-    bool                                 estimateIsExact               ;
-    ResultElementArray*                  resultElements                ;
-    std::string                          searchQuery                   ;
-    int                                  startIndex                    ;
-    int                                  endIndex                      ;
-    std::string                          searchTips                    ;
-    DirectoryCategoryArray*              directoryCategories           ;
-    double                               searchTime                    ;
+/// Element documentFiltering of type xs:boolean.
+    bool                                 documentFiltering              1;	///< Required element.
+/// Element searchComments of type xs:string.
+    std::string                          searchComments                 1;	///< Required element.
+/// Element estimatedTotalResultsCount of type xs:int.
+    int                                  estimatedTotalResultsCount     1;	///< Required element.
+/// Element estimateIsExact of type xs:boolean.
+    bool                                 estimateIsExact                1;	///< Required element.
+/// Element resultElements of type "urn:GoogleSearch":ResultElementArray.
+    gapi1ResultElementArray*             resultElements                 1;	///< Required element.
+/// Element searchQuery of type xs:string.
+    std::string                          searchQuery                    1;	///< Required element.
+/// Element startIndex of type xs:int.
+    int                                  startIndex                     1;	///< Required element.
+/// Element endIndex of type xs:int.
+    int                                  endIndex                       1;	///< Required element.
+/// Element searchTips of type xs:string.
+    std::string                          searchTips                     1;	///< Required element.
+/// Element directoryCategories of type "urn:GoogleSearch":DirectoryCategoryArray.
+    gapi1DirectoryCategoryArray*         directoryCategories            1;	///< Required element.
+/// Element searchTime of type xs:double.
+    double                               searchTime                     1;	///< Required element.
+/// A handle to the soap struct that manages this instance (automatically set)
     struct soap                         *soap                          ;
 };
 
+/// "urn:GoogleSearch":ResultElement is a complexType.
 class gapi1__ResultElement
 { public:
-    std::string                          summary                       ;
-    std::string                          URL                           ;
-    std::string                          snippet                       ;
-    std::string                          title                         ;
-    std::string                          cachedSize                    ;
-    bool                                 relatedInformationPresent     ;
-    std::string                          hostName                      ;
-    gapi1__DirectoryCategory*            directoryCategory             ;
-    std::string                          directoryTitle                ;
+/// Element summary of type xs:string.
+    std::string                          summary                        1;	///< Required element.
+/// Element URL of type xs:string.
+    std::string                          URL                            1;	///< Required element.
+/// Element snippet of type xs:string.
+    std::string                          snippet                        1;	///< Required element.
+/// Element title of type xs:string.
+    std::string                          title                          1;	///< Required element.
+/// Element cachedSize of type xs:string.
+    std::string                          cachedSize                     1;	///< Required element.
+/// Element relatedInformationPresent of type xs:boolean.
+    bool                                 relatedInformationPresent      1;	///< Required element.
+/// Element hostName of type xs:string.
+    std::string                          hostName                       1;	///< Required element.
+/// Element directoryCategory of type "urn:GoogleSearch":DirectoryCategory.
+    gapi1__DirectoryCategory*            directoryCategory              1;	///< Required element.
+/// Element directoryTitle of type xs:string.
+    std::string                          directoryTitle                 1;	///< Required element.
+/// A handle to the soap struct that manages this instance (automatically set)
     struct soap                         *soap                          ;
 };
 
+/// "urn:GoogleSearch":DirectoryCategory is a complexType.
 class gapi1__DirectoryCategory
 { public:
-    std::string                          fullViewableName              ;
-    std::string                          specialEncoding               ;
+/// Element fullViewableName of type xs:string.
+    std::string                          fullViewableName               1;	///< Required element.
+/// Element specialEncoding of type xs:string.
+    std::string                          specialEncoding                1;	///< Required element.
+/// A handle to the soap struct that manages this instance (automatically set)
     struct soap                         *soap                          ;
 };
 
-// SOAP encoded array ResultElementArray
-class ResultElementArray
+/// "urn:GoogleSearch":ResultElementArray is a complexType with complexContent restriction of SOAP-ENC:Array.
+/// SOAP encoded array of "urn:GoogleSearch":ResultElement
+class gapi1ResultElementArray
 { public:
+/// Pointer to array of gapi1__ResultElement*.
     gapi1__ResultElement*               *__ptr                         ;
+/// Size of the dynamic array.
     int                                  __size                        ;
+/// Offset for partially transmitted arrays (uncomment only when required).
+//  int                                  __offset                      ;
+/// A handle to the soap struct that manages this instance (automatically set)
     struct soap                         *soap                          ;
 };
 
-// SOAP encoded array DirectoryCategoryArray
-class DirectoryCategoryArray
+/// "urn:GoogleSearch":DirectoryCategoryArray is a complexType with complexContent restriction of SOAP-ENC:Array.
+/// SOAP encoded array of "urn:GoogleSearch":DirectoryCategory
+class gapi1DirectoryCategoryArray
 { public:
+/// Pointer to array of gapi1__DirectoryCategory*.
     gapi1__DirectoryCategory*           *__ptr                         ;
+/// Size of the dynamic array.
     int                                  __size                        ;
+/// Offset for partially transmitted arrays (uncomment only when required).
+//  int                                  __offset                      ;
+/// A handle to the soap struct that manages this instance (automatically set)
     struct soap                         *soap                          ;
 };
 
-/* Service GoogleSearchBinding operations:
+/******************************************************************************\
+ *                                                                            *
+ * Services                                                                   *
+ *                                                                            *
+\******************************************************************************/
 
-  gapi1__doGetCachedPage
-  gapi1__doSpellingSuggestion
-  gapi1__doGoogleSearch
 
-*/
-
 //gsoap gapi1 service name:	GoogleSearchBinding 
 //gsoap gapi1 service type:	GoogleSearchPort 
 //gsoap gapi1 service port:	http://api.google.com/search/beta2 
 //gsoap gapi1 service namespace:	urn:GoogleSearch 
+//gsoap gapi1 service transport:	http://schemas.xmlsoap.org/soap/http 
 
-/* Service GoogleSearchBinding operation gapi1__doGetCachedPage
+/** @mainpage GoogleSearch Definitions
 
-  C stub function (defined in soapClient.c[pp]):
+ at section GoogleSearch_bindings Bindings
+  - @ref GoogleSearchBinding
+
+*/
+
+/**
+
+ at page GoogleSearchBinding Binding "GoogleSearchBinding"
+
+ at section GoogleSearchBinding_operations Operations of Binding  "GoogleSearchBinding"
+  - @ref gapi1__doGetCachedPage
+  - @ref gapi1__doSpellingSuggestion
+  - @ref gapi1__doGoogleSearch
+
+ at section GoogleSearchBinding_ports Endpoints of Binding  "GoogleSearchBinding"
+  - http://api.google.com/search/beta2
+
+*/
+
+/******************************************************************************\
+ *                                                                            *
+ * GoogleSearchBinding                                                        *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * gapi1__doGetCachedPage                                                     *
+ *                                                                            *
+\******************************************************************************/
+
+
+/// Operation "gapi1__doGetCachedPage" of service binding "GoogleSearchBinding"
+
+/**
+
+Operation details:
+
+  - SOAP RPC encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"
+  - SOAP action="urn:GoogleSearchAction"
+
+C stub function (defined in soapClient.c[pp] after running soapcpp2):
+ at code
   int soap_call_gapi1__doGetCachedPage(struct soap *soap,
-    NULL, (char *endpoint = NULL selects default endpoint for this operation)
-    NULL, (char *action = NULL selects default action for this operation)
+    NULL, // char *endpoint = NULL selects default endpoint for this operation
+    NULL, // char *action = NULL selects default action for this operation
+    // request parameters:
     std::string                         key,
     std::string                         url,
-  struct gapi1__doGetCachedPageResponse {
-    xsd__base64Binary                   return_;
-  } & );
+    // response parameters:
+    xsd__base64Binary                  &return_
+  );
+ at endcode
 
-  C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
+C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
   class GoogleSearchBinding;
 
 */
@@ -144,25 +263,41 @@
 //gsoap gapi1 service method-encoding:	doGetCachedPage http://schemas.xmlsoap.org/soap/encoding/
 //gsoap gapi1 service method-action:	doGetCachedPage urn:GoogleSearchAction
 int gapi1__doGetCachedPage(
-    std::string                         key,
-    std::string                         url,
-  struct gapi1__doGetCachedPageResponse {
-    xsd__base64Binary                   return_;
-  } & );
+    std::string                         key,	///< Request parameter
+    std::string                         url,	///< Request parameter
+    xsd__base64Binary                  &return_	///< Response parameter
+);
 
-/* Service GoogleSearchBinding operation gapi1__doSpellingSuggestion
+/******************************************************************************\
+ *                                                                            *
+ * gapi1__doSpellingSuggestion                                                *
+ *                                                                            *
+\******************************************************************************/
 
-  C stub function (defined in soapClient.c[pp]):
+
+/// Operation "gapi1__doSpellingSuggestion" of service binding "GoogleSearchBinding"
+
+/**
+
+Operation details:
+
+  - SOAP RPC encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"
+  - SOAP action="urn:GoogleSearchAction"
+
+C stub function (defined in soapClient.c[pp] after running soapcpp2):
+ at code
   int soap_call_gapi1__doSpellingSuggestion(struct soap *soap,
-    NULL, (char *endpoint = NULL selects default endpoint for this operation)
-    NULL, (char *action = NULL selects default action for this operation)
+    NULL, // char *endpoint = NULL selects default endpoint for this operation
+    NULL, // char *action = NULL selects default action for this operation
+    // request parameters:
     std::string                         key,
     std::string                         phrase,
-  struct gapi1__doSpellingSuggestionResponse {
-    std::string                         return_;
-  } & );
+    // response parameters:
+    std::string                        &return_
+  );
+ at endcode
 
-  C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
+C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
   class GoogleSearchBinding;
 
 */
@@ -171,18 +306,38 @@
 //gsoap gapi1 service method-encoding:	doSpellingSuggestion http://schemas.xmlsoap.org/soap/encoding/
 //gsoap gapi1 service method-action:	doSpellingSuggestion urn:GoogleSearchAction
 int gapi1__doSpellingSuggestion(
-    std::string                         key,
-    std::string                         phrase,
-  struct gapi1__doSpellingSuggestionResponse {
-    std::string                         return_;
-  } & );
+    std::string                         key,	///< Request parameter
+    std::string                         phrase,	///< Request parameter
+    std::string                        &return_	///< Response parameter
+);
 
-/* Service GoogleSearchBinding operation gapi1__doGoogleSearch
+/******************************************************************************\
+ *                                                                            *
+ * gapi1__doGoogleSearch                                                      *
+ *                                                                            *
+\******************************************************************************/
 
-  C stub function (defined in soapClient.c[pp]):
+/// Operation response struct "gapi1__doGoogleSearchResponse" of service binding "GoogleSearchBinding" operation "gapi1__doGoogleSearch"
+struct gapi1__doGoogleSearchResponse
+{
+    gapi1__GoogleSearchResult*          return_;
+};
+
+/// Operation "gapi1__doGoogleSearch" of service binding "GoogleSearchBinding"
+
+/**
+
+Operation details:
+
+  - SOAP RPC encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"
+  - SOAP action="urn:GoogleSearchAction"
+
+C stub function (defined in soapClient.c[pp] after running soapcpp2):
+ at code
   int soap_call_gapi1__doGoogleSearch(struct soap *soap,
-    NULL, (char *endpoint = NULL selects default endpoint for this operation)
-    NULL, (char *action = NULL selects default action for this operation)
+    NULL, // char *endpoint = NULL selects default endpoint for this operation
+    NULL, // char *action = NULL selects default action for this operation
+    // request parameters:
     std::string                         key,
     std::string                         q,
     int                                 start,
@@ -193,11 +348,12 @@
     std::string                         lr,
     std::string                         ie,
     std::string                         oe,
-  struct gapi1__doGoogleSearchResponse {
-    gapi1__GoogleSearchResult*          return_;
-  } & );
+    // response parameters:
+    struct gapi1__doGoogleSearchResponse&
+  );
+ at endcode
 
-  C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
+C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
   class GoogleSearchBinding;
 
 */
@@ -206,19 +362,17 @@
 //gsoap gapi1 service method-encoding:	doGoogleSearch http://schemas.xmlsoap.org/soap/encoding/
 //gsoap gapi1 service method-action:	doGoogleSearch urn:GoogleSearchAction
 int gapi1__doGoogleSearch(
-    std::string                         key,
-    std::string                         q,
-    int                                 start,
-    int                                 maxResults,
-    bool                                filter,
-    std::string                         restrict_,
-    bool                                safeSearch,
-    std::string                         lr,
-    std::string                         ie,
-    std::string                         oe,
-  struct gapi1__doGoogleSearchResponse {
-    gapi1__GoogleSearchResult*          return_;
-  } & );
+    std::string                         key,	///< Request parameter
+    std::string                         q,	///< Request parameter
+    int                                 start,	///< Request parameter
+    int                                 maxResults,	///< Request parameter
+    bool                                filter,	///< Request parameter
+    std::string                         restrict_,	///< Request parameter
+    bool                                safeSearch,	///< Request parameter
+    std::string                         lr,	///< Request parameter
+    std::string                         ie,	///< Request parameter
+    std::string                         oe,	///< Request parameter
+    struct gapi1__doGoogleSearchResponse&	///< Response struct parameter
+);
 
-/*  End of Web Services Definitions urn:GoogleSearch */
-}
+/* End of GoogleSearch.h */

Added: trunk/Search/Google/Makefile.am
===================================================================
--- trunk/Search/Google/Makefile.am	2006-04-04 11:23:31 UTC (rev 178)
+++ trunk/Search/Google/Makefile.am	2006-04-04 12:25:39 UTC (rev 179)
@@ -0,0 +1,25 @@
+# Process this file with automake to produce Makefile.in
+
+noinst_HEADERS = \
+	GAPIGoogleSearchBindingObject.h \
+	GAPIGoogleSearchBindingProxy.h \
+	GAPIH.h \
+	GAPIStub.h \
+	GoogleAPIEngine.h \
+	GoogleSearch.h
+
+noinst_LTLIBRARIES = libSearchGoogle.la
+
+libSearchGoogle_la_SOURCES = \
+	GAPIClientLib.cpp \
+	GoogleAPIEngine.cpp
+
+GoogleSearch.h : googleapi/GoogleSearch.wsdl
+	wsdl2c -n gapi -o GoogleSearch.h googleapi/GoogleSearch.wsdl
+
+GAPIClientLib.cpp : GoogleSearch.h
+	soapcpp2 -n -pGAPI -I /usr/include/gsoap/import GoogleSearch.h
+
+AM_CXXFLAGS = -I../../Utils -I../../Tokenize -I../../Collect -I.. \
+	@HTTP_CFLAGS@ @XML_CFLAGS@ @SOAP_CFLAGS@ @INDEX_CFLAGS@ @MIME_CFLAGS@
+

Modified: trunk/Search/Makefile.am
===================================================================
--- trunk/Search/Makefile.am	2006-04-04 11:23:31 UTC (rev 178)
+++ trunk/Search/Makefile.am	2006-04-04 12:25:39 UTC (rev 179)
@@ -11,10 +11,13 @@
 	PluginParsers.h \
 	PluginWebEngine.h \
 	SearchEngineInterface.h \
-	SherlockParser.h
+	SherlockParser.h \
+	SOAPEnv.h
 
-noinst_LTLIBRARIES = libSearch.la
+EXTRA_LTLIBRARIES = libSearch.la libSearchSOAP.la
 
+noinst_LTLIBRARIES = @SEARCH_LTLIBRARIES@
+
 bin_PROGRAMS = pinot_search
 
 libSearch_la_SOURCES = \
@@ -29,13 +32,20 @@
 	SearchEngineInterface.cpp \
 	SherlockParser.cpp
 
+libSearchSOAP_la_SOURCES = \
+	SOAPEnvC.cpp \
+	SOAPEnvNS.cpp
+
 pinot_search_SOURCES = \
 	senginetest.cpp
 
-pinot_search_LDADD = -L../Utils -L../Tokenize -L../Collect \
-	-lSearch -lCollect -lTokenize -lUtils \
-	@INDEX_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
+pinot_search_LDADD = -L../Utils -L../Tokenize -L../Collect -LGoogle \
+	@SEARCH_LIBS@ -lCollect -lTokenize -lUtils \
+	@INDEX_LIBS@ @SOAP_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
 
-AM_CXXFLAGS = -I../Utils -I../Tokenize -I../Collect \
-	@HTTP_CFLAGS@ @XML_CFLAGS@ @INDEX_CFLAGS@ @MIME_CFLAGS@
+SOAPEnvC.cpp : SOAPEnv.h
+	soapcpp2 -pSOAPEnv SOAPEnv.h
 
+AM_CXXFLAGS = -I../Utils -I../Tokenize -I../Collect -IGoogle \
+	@HTTP_CFLAGS@ @XML_CFLAGS@ @INDEX_CFLAGS@ @SOAP_CFLAGS@ @MIME_CFLAGS@
+

Added: trunk/Search/SOAPEnv.h
===================================================================

Modified: trunk/Search/SearchEngineFactory.cpp
===================================================================
--- trunk/Search/SearchEngineFactory.cpp	2006-04-04 11:23:31 UTC (rev 178)
+++ trunk/Search/SearchEngineFactory.cpp	2006-04-04 12:25:39 UTC (rev 179)
@@ -17,9 +17,6 @@
 #ifdef HAS_GOOGLEAPI
 #include "GoogleAPIEngine.h"
 #endif
-#ifdef HAS_OSAPI
-#include "ObjectsSearchAPIEngine.h"
-#endif
 #include "PluginWebEngine.h"
 #include "XapianEngine.h"
 #include "SearchEngineFactory.h"
@@ -54,12 +51,6 @@
 		myEngine->setKey(option);
 	}
 #endif
-#ifdef HAS_OSAPI
-	else if (type == "objectssearchapi")
-	{
-		myEngine = new ObjectsSearchAPIEngine();
-	}
-#endif
 
 	return myEngine;
 }
@@ -75,9 +66,6 @@
 #ifdef HAS_GOOGLEAPI
 	engines.insert("googleapi");
 #endif
-#ifdef HAS_OSAPI
-	engines.insert("objectssearchapi");
-#endif
 }
 
 /// Indicates whether a search engine is supported or not.
@@ -87,9 +75,6 @@
 #ifdef HAS_GOOGLEAPI
 		(type == "googleapi") ||
 #endif
-#ifdef HAS_OSAPI
-		(type == "objectssearchapi") ||
-#endif
 		(type == "sherlock") ||
 		(type == "xapian"))
 	{

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2006-04-04 11:23:31 UTC (rev 178)
+++ trunk/configure.in	2006-04-04 12:25:39 UTC (rev 179)
@@ -50,22 +50,46 @@
 
 AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
 
-dnl Xapian
-AC_PATH_PROG(XAPIAN_CONFIG, xapian-config, no)
-if test "$XAPIAN_CONFIG" = "no" ; then
-   AC_MSG_ERROR([Can't find xapian-config in $PATH.])
-   exit 1
+dnl SOAP API support
+AC_MSG_CHECKING(whether to enable SOAP support)
+AC_ARG_WITH(soap, AS_HELP_STRING(--with-soap@<:@=yes|no@:>@,
+   whether to enable SOAP support (default: no)))
+soapsupport=$with_soap
+if test "x$soapsupport" = "x"; then
+   soapsupport="no"
 fi
-XAPIAN_CFLAGS=`$XAPIAN_CONFIG --cxxflags`
-XAPIAN_LIBS=`$XAPIAN_CONFIG --libs`
+AC_MSG_RESULT($soapsupport)
 
+case "$soapsupport" in
+yes)
+PKG_CHECK_MODULES(SOAP, gsoap)
+SOAP_CFLAGS="-DHAS_GOOGLEAPI $SOAP_CFLAGS"
+SOAP_LIBS="$SOAP_LIBS -lSearchSOAP"
+SOAP_SUBDIRS="Search/Google"
+SEARCH_LTLIBRARIES="libSearch.la libSearchSOAP.la"
+SEARCH_LIBS="-lSearch -lSearchGoogle"
+;;
+no)
+SOAP_CFLAGS=""
+SOAP_LIBS=""
+SOAP_SUBDIRS=""
+SEARCH_LTLIBRARIES="libSearch.la"
+SEARCH_LIBS="-lSearch"
+;;
+esac
+AC_SUBST(SOAP_CFLAGS)
+AC_SUBST(SOAP_LIBS)
+AC_SUBST(SOAP_SUBDIRS)
+AC_SUBST(SEARCH_LTLIBRARIES)
+AC_SUBST(SEARCH_LIBS)
+
 dnl Neon or Curl ?
 AC_MSG_CHECKING(which HTTP library to use)
 AC_ARG_WITH(http, AS_HELP_STRING(--with-http@<:@=neon|curl@:>@,
-	which HTTP library to use (default: curl)))
+   which HTTP library to use (default: curl)))
 httplibrary=$with_http
 if test "x$httplibrary" = "x"; then
-	httplibrary="curl"
+   httplibrary="curl"
 fi
 AC_MSG_RESULT($httplibrary)
 
@@ -90,6 +114,18 @@
 esac
 AC_SUBST(HTTP_DOWNLOADER)
 
+dnl Textcat
+AC_CHECK_HEADERS(textcat.h)
+
+dnl Xapian
+AC_PATH_PROG(XAPIAN_CONFIG, xapian-config, no)
+if test "$XAPIAN_CONFIG" = "no" ; then
+   AC_MSG_ERROR([Can't find xapian-config in $PATH.])
+   exit 1
+fi
+XAPIAN_CFLAGS=`$XAPIAN_CONFIG --cxxflags`
+XAPIAN_LIBS=`$XAPIAN_CONFIG --libs`
+
 dnl Mozilla NSS and NSPR
 AC_PATH_PROG(NSS_CONFIG, nss-config, no)
 if test "$NSS_CONFIG" = "no" ; then
@@ -116,7 +152,6 @@
 PKG_CHECK_MODULES(XML, libxml++-2.6 >= 2.12 )
 AC_SUBST(XML_CFLAGS)
 AC_SUBST(XML_LIBS)
-dnl FIXME: check for libtextcat
 INDEX_CFLAGS="$XAPIAN_CFLAGS"
 INDEX_LIBS="$XAPIAN_LIBS -ltextcat"
 AC_SUBST(INDEX_CFLAGS)
@@ -140,6 +175,6 @@
 AC_CHECK_FUNCS(mmap)
 
 AC_OUTPUT( pinot.spec Makefile Utils/Makefile Tokenize/Makefile SQL/Makefile \
-	po/Makefile.in Collect/Makefile Search/Makefile \
+	po/Makefile.in Collect/Makefile Search/Makefile Search/Google/Makefile \
 	Index/Makefile UI/RenderHTML/Makefile UI/GTK2/src/Makefile )
 



From fabricecolin at berlios.de  Tue Apr  4 14:27:38 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 4 Apr 2006 14:27:38 +0200
Subject: [Pinot-svn] r180 - trunk/Search
Message-ID: <200604041227.k34CRcxa006578@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-04 14:27:36 +0200 (Tue, 04 Apr 2006)
New Revision: 180

Modified:
   trunk/Search/SearchEngineInterface.cpp
Log:
Complete relative URLs with the search engine's host name.


Modified: trunk/Search/SearchEngineInterface.cpp
===================================================================
--- trunk/Search/SearchEngineInterface.cpp	2006-04-04 12:25:39 UTC (rev 179)
+++ trunk/Search/SearchEngineInterface.cpp	2006-04-04 12:27:36 UTC (rev 180)
@@ -83,9 +83,36 @@
 bool SearchEngineInterface::processResult(const string &queryUrl, string &resultUrl)
 {
 	Url queryUrlObj(queryUrl);
-	Url resultUrlObj(resultUrl);
 	string queryHost(Url::reduceHost(queryUrlObj.getHost(), 2));
 
+	if (resultUrl.empty() == true)
+	{
+		return false;
+	}
+
+	if ((resultUrl[0] == '/') ||
+		((resultUrl.length() > 1) &&
+		(resultUrl[0] == '.') &&
+		(resultUrl[1] == '/')))
+	{
+		string fullResultUrl(queryUrlObj.getProtocol());
+
+		fullResultUrl += "://";
+		fullResultUrl += queryUrlObj.getHost();
+		if (resultUrl[0] == '.')
+		{
+			fullResultUrl += resultUrl.substr(1);
+		}
+		else
+		{
+			fullResultUrl += resultUrl;
+		}
+
+		resultUrl = fullResultUrl;
+	}
+
+	Url resultUrlObj(resultUrl);
+
 	if ((m_hostFilter.empty() == false) &&
 		(resultUrlObj.getHost() != m_hostFilter))
 	{



From fabricecolin at berlios.de  Tue Apr  4 14:29:28 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 4 Apr 2006 14:29:28 +0200
Subject: [Pinot-svn] r181 - trunk/Search
Message-ID: <200604041229.k34CTS4C007041@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-04 14:29:15 +0200 (Tue, 04 Apr 2006)
New Revision: 181

Modified:
   trunk/Search/SherlockParser.cpp
Log:
If the result's extract is all spaces, strip tags and replace.


Modified: trunk/Search/SherlockParser.cpp
===================================================================
--- trunk/Search/SherlockParser.cpp	2006-04-04 12:27:36 UTC (rev 180)
+++ trunk/Search/SherlockParser.cpp	2006-04-04 12:29:15 UTC (rev 181)
@@ -355,6 +355,7 @@
 			{
 				string extractWithMarkup1, extractWithMarkup2;
 				string extractCandidate1, extractCandidate2;
+				bool isBlank = true;
 
 				if (startOfSecondLink > 0)
 				{
@@ -393,6 +394,19 @@
 				cout << "SherlockResponseParser::parse: extract is \""
 					<< extract << "\"" << endl;
 #endif
+				for (string::size_type pos = 0; pos < extract.length(); ++pos)
+				{
+					if (isspace(extract[pos]) == 0)
+					{
+						isBlank = false;
+						break;
+					}
+				}
+
+				if (isBlank == true)
+				{
+					extract = HtmlTokenizer::stripTags(resultItem);
+				}
 			}
 		}
 		else



From fabricecolin at berlios.de  Tue Apr  4 15:14:53 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 4 Apr 2006 15:14:53 +0200
Subject: [Pinot-svn] r182 - trunk/UI/GTK2/src
Message-ID: <200604041314.k34DEr4r027335@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-04 15:14:50 +0200 (Tue, 04 Apr 2006)
New Revision: 182

Modified:
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
Log:
IndexingThread can skip MIME type check.
Minor fixes to get rid of compilation warnings.


Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-04-04 12:29:15 UTC (rev 181)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-04-04 13:14:50 UTC (rev 182)
@@ -245,8 +245,6 @@
 
 bool ThreadsManager::start_thread(WorkerThread *pWorkerThread, bool inBackground)
 {
-	bool insertedThread = false;
-
 	if (pWorkerThread == NULL)
 	{
 		return false;
@@ -467,10 +465,10 @@
 QueryingThread::QueryingThread(const string &engineName, const string &engineDisplayableName,
 	const string &engineOption, const QueryProperties &queryProps) :
 	WorkerThread(),
-	m_queryProps(queryProps),
 	m_engineName(engineName),
 	m_engineDisplayableName(engineDisplayableName),
-	m_engineOption(engineOption)
+	m_engineOption(engineOption),
+	m_queryProps(queryProps)
 {
 }
 
@@ -722,11 +720,12 @@
 }
 
 IndexingThread::IndexingThread(const DocumentInfo &docInfo, const string &labelName,
-	unsigned int docId) :
+	unsigned int docId, bool allowAllMIMETypes) :
 	DownloadingThread(docInfo.getLocation(), false),
 	m_docInfo(docInfo),
 	m_labelName(labelName),
-	m_docId(docId)
+	m_docId(docId),
+	m_allowAllMIMETypes(allowAllMIMETypes)
 {
 	m_indexLocation = PinotSettings::getInstance().m_indexLocation;
 	if (m_docId > 0)
@@ -816,9 +815,7 @@
 	}
 	else
 	{
-		unsigned int urlContentLen;
 		string docType = m_pDoc->getType();
-		const char *urlContent = m_pDoc->getData(urlContentLen);
 		bool success = false;
 
 		// The type may have been obtained when downloading
@@ -831,8 +828,9 @@
 			m_pDoc->setType(m_docInfo.getType());
 		}
 
-		// Skip unsupported types
-		if (TokenizerFactory::isSupportedType(m_docInfo.getType()) == false)
+		// Skip unsupported types ?
+		if ((m_allowAllMIMETypes == false) &&
+			(TokenizerFactory::isSupportedType(m_docInfo.getType()) == false))
 		{
 			m_status = _("Cannot index document type");
 			m_status += " ";
@@ -1194,7 +1192,6 @@
 	FAMConnection famConn;
 	FAMRequest famReq;
 	map<unsigned long, string> fsLocations;
-	struct stat fileStat;
 	bool setLocationsToMonitor = true;
 	bool firstTime = true;
 	bool closeMonitor = false, resumeMonitor = false;

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2006-04-04 12:29:15 UTC (rev 181)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2006-04-04 13:14:50 UTC (rev 182)
@@ -246,7 +246,7 @@
 {
 	public:
 		IndexingThread(const DocumentInfo &docInfo, const std::string &labelName,
-			unsigned int docId = 0);
+			unsigned int docId = 0, bool allowAllMIMETypes = false);
 		virtual ~IndexingThread();
 
 		virtual std::string getType(void) const;
@@ -265,6 +265,7 @@
 		DocumentInfo m_docInfo;
 		std::string m_labelName;
 		unsigned int m_docId;
+		bool m_allowAllMIMETypes;
 		std::string m_indexLocation;
 		bool m_ignoreRobotsDirectives;
 		bool m_update;



From fabricecolin at berlios.de  Tue Apr  4 15:17:31 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 4 Apr 2006 15:17:31 +0200
Subject: [Pinot-svn] r183 - in trunk: UI/GTK2/src Utils
Message-ID: <200604041317.k34DHVkB028232@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-04 15:17:28 +0200 (Tue, 04 Apr 2006)
New Revision: 183

Modified:
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/PinotSettings.h
   trunk/Utils/MboxParser.cpp
Log:
Minor fixes to get rid of compilation warnings.


Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2006-04-04 13:14:50 UTC (rev 182)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2006-04-04 13:17:28 UTC (rev 183)
@@ -652,6 +652,8 @@
 			m_newResultsColour.set_blue(value);
 		}
 	}
+
+	return true;
 }
 
 bool PinotSettings::loadMailAccounts(const Element *pElem)
@@ -883,11 +885,11 @@
 		}
 		addChildElement(pElem, "name", mailIter->m_name);
 		addChildElement(pElem, "type", mailIter->m_type);
-		sprintf(numStr, "%u", mailIter->m_modTime);
+		sprintf(numStr, "%d", mailIter->m_modTime);
 		addChildElement(pElem, "mtime", numStr);
-		sprintf(numStr, "%u", mailIter->m_lastMessageTime);
+		sprintf(numStr, "%d", mailIter->m_lastMessageTime);
 		addChildElement(pElem, "mindate", numStr);
-		sprintf(numStr, "%u", mailIter->m_size);
+		sprintf(numStr, "%d", mailIter->m_size);
 		addChildElement(pElem, "size", numStr);
 	}
 
@@ -1142,13 +1144,13 @@
 }
 
 /// Adds a new label.
-bool PinotSettings::addLabel(const string &name)
+void PinotSettings::addLabel(const string &name)
 {
 	m_labels.insert(name);
 }
 
 /// Removes a label.
-bool PinotSettings::removeLabel(const string &name)
+void PinotSettings::removeLabel(const string &name)
 {
 	set<string>::iterator labelIter = m_labels.find(name);
 	if (labelIter != m_labels.end())

Modified: trunk/UI/GTK2/src/PinotSettings.h
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.h	2006-04-04 13:14:50 UTC (rev 182)
+++ trunk/UI/GTK2/src/PinotSettings.h	2006-04-04 13:17:28 UTC (rev 183)
@@ -112,10 +112,10 @@
 		const std::set<std::string> &getLabels(void) const;
 
 		/// Adds a new label.
-		bool addLabel(const std::string &name);
+		void addLabel(const std::string &name);
 
 		/// Removes a label.
-		bool removeLabel(const std::string &name);
+		void removeLabel(const std::string &name);
 
 		/// Clears the labels list.
 		void clearLabels(void);

Modified: trunk/Utils/MboxParser.cpp
===================================================================
--- trunk/Utils/MboxParser.cpp	2006-04-04 13:14:50 UTC (rev 182)
+++ trunk/Utils/MboxParser.cpp	2006-04-04 13:17:28 UTC (rev 183)
@@ -156,8 +156,6 @@
 	// Is this a multipart ?
 	if (GMIME_IS_MULTIPART(part))
 	{
-		ssize_t allPartsLen = 0;
-
 		m_partsCount = g_mime_multipart_get_number(GMIME_MULTIPART(part));
 #ifdef DEBUG
 		cout << "MboxParser::extractPart: message has " << m_partsCount << " parts" << endl;
@@ -336,7 +334,7 @@
 				location = "mailbox://";
 				location += m_fileName;
 				location += "?o=";
-				snprintf(posStr, 64, "%u", m_messageStart);
+				snprintf(posStr, 64, "%d", m_messageStart);
 				location += posStr;
 				location += "&p=";
 				snprintf(posStr, 64, "%d", max(m_partNum, 0));



From fabricecolin at berlios.de  Tue Apr  4 15:18:59 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 4 Apr 2006 15:18:59 +0200
Subject: [Pinot-svn] r184 - in trunk: Search UI/GTK2/src
Message-ID: <200604041318.k34DIx3p028564@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-04 15:18:35 +0200 (Tue, 04 Apr 2006)
New Revision: 184

Modified:
   trunk/Search/senginetest.cpp
   trunk/UI/GTK2/src/prefsDialog.cc
Log:
More minor fixes...


Modified: trunk/Search/senginetest.cpp
===================================================================
--- trunk/Search/senginetest.cpp	2006-04-04 13:17:28 UTC (rev 183)
+++ trunk/Search/senginetest.cpp	2006-04-04 13:18:35 UTC (rev 184)
@@ -65,8 +65,7 @@
 	myEngine->setMaxResultsCount(count);
 
 	QueryProperties queryProps("senginetest", argv[3], "", "", "");
-	bool bOK = myEngine->runQuery(queryProps);
-	if (bOK == true)
+	if (myEngine->runQuery(queryProps) == true)
 	{
 		string resultsPage;
 

Modified: trunk/UI/GTK2/src/prefsDialog.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.cc	2006-04-04 13:17:28 UTC (rev 183)
+++ trunk/UI/GTK2/src/prefsDialog.cc	2006-04-04 13:18:35 UTC (rev 184)
@@ -38,7 +38,8 @@
 unsigned int prefsDialog::m_maxDirLevel = 1;
 
 prefsDialog::prefsDialog() :
-	m_settings(PinotSettings::getInstance()), prefsDialog_glade()
+	prefsDialog_glade(),
+	m_settings(PinotSettings::getInstance())
 {
 	// Associate the columns model to the view combo
 	m_refViewTree = ListStore::create(m_viewColumns);



From fabricecolin at berlios.de  Tue Apr  4 15:38:20 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 4 Apr 2006 15:38:20 +0200
Subject: [Pinot-svn] r185 - in trunk: . Tokenize
Message-ID: <200604041338.k34DcKxO005735@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-04 15:38:06 +0200 (Tue, 04 Apr 2006)
New Revision: 185

Added:
   trunk/Tokenize/TagLibTokenizer.cpp
   trunk/Tokenize/TagLibTokenizer.h
Modified:
   trunk/Tokenize/Makefile.am
   trunk/Tokenize/TokenizerFactory.cpp
   trunk/configure.in
   trunk/pinot.spec.in
Log:
New tokenizer for MP3, Vorbis and FLAC audio that extracts track information
with taglib.


Modified: trunk/Tokenize/Makefile.am
===================================================================
--- trunk/Tokenize/Makefile.am	2006-04-04 13:18:35 UTC (rev 184)
+++ trunk/Tokenize/Makefile.am	2006-04-04 13:38:06 UTC (rev 185)
@@ -11,12 +11,14 @@
 	HtmlTokenizer.h \
 	PdfTokenizer.h \
 	RtfTokenizer.h \
+	TagLibTokenizer.h \
 	Tokenizer.h \
 	TokenizerFactory.h \
 	UnknownTypeTokenizer.h \
 	WordTokenizer.h
 
-lib_LTLIBRARIES = libpdftokenizer.la librtftokenizer.la libwordtokenizer.la
+lib_LTLIBRARIES = libpdftokenizer.la librtftokenizer.la libwordtokenizer.la \
+	libtaglibtokenizer.la
 
 noinst_LTLIBRARIES = libTokenize.la
 
@@ -25,7 +27,7 @@
 	HtmlTokenizer.cpp \
 	Tokenizer.cpp
 
-libpdftokenizer_la_LDFLAGS = 
+libpdftokenizer_la_LDFLAGS = -module
 
 libpdftokenizer_la_LIBADD = ${UTILS_OBJS} 
 
@@ -34,7 +36,7 @@
 	HtmlTokenizer.cpp \
 	Tokenizer.cpp
 
-librtftokenizer_la_LDFLAGS = 
+librtftokenizer_la_LDFLAGS = -module
 
 librtftokenizer_la_LIBADD = ${UTILS_OBJS}
 
@@ -42,15 +44,23 @@
 	WordTokenizer.cpp \
 	Tokenizer.cpp
 
-libwordtokenizer_la_LDFLAGS = 
+libwordtokenizer_la_LDFLAGS = -module
 
 libwordtokenizer_la_LIBADD = ${UTILS_OBJS}
 
+libtaglibtokenizer_la_SOURCES = \
+	TagLibTokenizer.cpp \
+	Tokenizer.cpp
+
+libtaglibtokenizer_la_LDFLAGS = -module @TAGLIB_LIBS@
+
+libtaglibtokenizer_la_LIBADD = ${UTILS_OBJS}
+
 libTokenize_la_SOURCES = \
 	HtmlTokenizer.cpp \
 	Tokenizer.cpp \
 	TokenizerFactory.cpp \
 	UnknownTypeTokenizer.cpp
 
-AM_CXXFLAGS = -fPIC -I../Utils
+AM_CXXFLAGS = -fPIC -I../Utils @TAGLIB_CFLAGS@
 

Added: trunk/Tokenize/TagLibTokenizer.cpp
===================================================================
--- trunk/Tokenize/TagLibTokenizer.cpp	2006-04-04 13:18:35 UTC (rev 184)
+++ trunk/Tokenize/TagLibTokenizer.cpp	2006-04-04 13:38:06 UTC (rev 185)
@@ -0,0 +1,144 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <string.h>
+#include <iostream>
+
+#include <fileref.h>
+#include <tfile.h>
+#include <tag.h>
+
+#include "Url.h"
+#include "TagLibTokenizer.h"
+
+/**
+  * This returns the MIME type supported by the library's tokenizer.
+  * The character string is allocated with new[].
+  */
+char *getTokenizerType(unsigned int typeNum)
+{
+	if (typeNum == 0)
+	{
+		char *pType = new char[11];
+		strncpy(pType, "audio/mpeg", 10);
+		pType[10] = '\0';
+		return pType;
+	}
+	else if (typeNum == 1)
+	{
+		char *pType = new char[12];
+		strncpy(pType, "audio/x-mp3", 11);
+		pType[11] = '\0';
+		return pType;
+	}
+	else if (typeNum == 2)
+	{
+		char *pType = new char[16];
+		strncpy(pType, "application/ogg", 15);
+		pType[15] = '\0';
+		return pType;
+	}
+	else if (typeNum == 3)
+	{
+		char *pType = new char[17];
+		strncpy(pType, "audio/x-flac+ogg", 16);
+		pType[16] = '\0';
+		return pType;
+	}
+	else if (typeNum == 4)
+	{
+		char *pType = new char[13];
+		strncpy(pType, "audio/x-flac", 12);
+		pType[12] = '\0';
+		return pType;
+	}
+
+	return NULL;
+}
+
+/// This returns a pointer to a Tokenizer, allocated with new.
+Tokenizer *getTokenizer(const Document *pDocument)
+{
+	return new TagLibTokenizer(pDocument);
+}
+
+TagLibTokenizer::TagLibTokenizer(const Document *pDocument) :
+	Tokenizer(NULL)
+{
+	if (pDocument != NULL)
+	{
+		Document *pPseudoDocument = NULL;
+		Url urlObj(pDocument->getLocation());
+		string pseudoContent;
+
+		if ((urlObj.isLocal() == true) &&
+			(urlObj.getFile().empty() == false))
+		{
+			string location(urlObj.getLocation());
+			string trackTitle;
+
+			location += "/";
+			location += urlObj.getFile();
+
+			TagLib::FileRef fileRef(location.c_str(), false);
+
+			if ((fileRef.isNull() == false) &&
+				(fileRef.file()->isOpen() == true))
+			{
+				TagLib::Tag *pTag = fileRef.tag();
+				if ((pTag != NULL) &&
+					(pTag->isEmpty() == false))
+				{
+					char yearStr[64];
+
+					trackTitle = pTag->title().to8Bit(); 
+					trackTitle += " ";
+					trackTitle += pTag->artist().to8Bit();
+
+					pseudoContent = trackTitle;
+					pseudoContent += " ";
+					pseudoContent += pTag->album().to8Bit();
+					pseudoContent += " ";
+					pseudoContent += pTag->comment().to8Bit();
+					pseudoContent += " ";
+					pseudoContent += pTag->genre().to8Bit();
+					snprintf(yearStr, 64, " %u", pTag->year());
+					pseudoContent += yearStr;
+				}
+			}
+			else
+			{
+				trackTitle = pseudoContent = pDocument->getTitle();
+			}
+
+			pPseudoDocument = new Document(trackTitle, pDocument->getLocation(),
+				pDocument->getType(), pDocument->getLanguage());
+			pPseudoDocument->setData(pseudoContent.c_str(), pseudoContent.length());
+
+			// Give the result to the parent class
+			setDocument(pPseudoDocument);
+		}
+	}
+}
+
+TagLibTokenizer::~TagLibTokenizer()
+{
+	if (m_pDocument != NULL)
+	{
+		// This should have been set by setDocument()
+		delete m_pDocument;
+	}
+}

Added: trunk/Tokenize/TagLibTokenizer.h
===================================================================
--- trunk/Tokenize/TagLibTokenizer.h	2006-04-04 13:18:35 UTC (rev 184)
+++ trunk/Tokenize/TagLibTokenizer.h	2006-04-04 13:38:06 UTC (rev 185)
@@ -0,0 +1,43 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _WORD_TOKENIZER_H
+#define _WORD_TOKENIZER_H
+
+#include "Document.h"
+#include "Tokenizer.h"
+
+/**
+  * This returns the MIME type supported by the library's tokenizer.
+  * The character string is allocated with new[].
+  */
+char *getTokenizerType(unsigned int typeNum);
+/// This returns a pointer to a Tokenizer, allocated with new.
+Tokenizer *getTokenizer(const Document *pDocument);
+
+class TagLibTokenizer : public Tokenizer
+{
+	public:
+		TagLibTokenizer(const Document *pDocument);
+		virtual ~TagLibTokenizer();
+
+	private:
+		TagLibTokenizer(const TagLibTokenizer &other);
+		TagLibTokenizer& operator=(const TagLibTokenizer& other);
+
+};
+
+#endif // _WORD_TOKENIZER_H

Modified: trunk/Tokenize/TokenizerFactory.cpp
===================================================================
--- trunk/Tokenize/TokenizerFactory.cpp	2006-04-04 13:18:35 UTC (rev 184)
+++ trunk/Tokenize/TokenizerFactory.cpp	2006-04-04 13:38:06 UTC (rev 185)
@@ -271,6 +271,9 @@
 			return new Tokenizer(pDocument);
 		}
 
+#ifdef DEBUG
+		cout << "TokenizerFactory::getTokenizerByType: unknown file type" << endl;
+#endif
 		return new UnknownTypeTokenizer(pDocument);
 	}
 

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2006-04-04 13:18:35 UTC (rev 184)
+++ trunk/configure.in	2006-04-04 13:38:06 UTC (rev 185)
@@ -139,6 +139,9 @@
 dnl Other libraries
 MISC_LIBS="-lmagic -lcrypt"
 AC_SUBST(MISC_LIBS)
+PKG_CHECK_MODULES(TAGLIB, taglib >= 1.4 )
+AC_SUBST(TAGLIB_CFLAGS)
+AC_SUBST(TAGLIB_LIBS)
 PKG_CHECK_MODULES(SQL, sqlite3 >= 3.1 )
 AC_SUBST(SQL_CFLAGS)
 AC_SUBST(SQL_LIBS)

Modified: trunk/pinot.spec.in
===================================================================
--- trunk/pinot.spec.in	2006-04-04 13:18:35 UTC (rev 184)
+++ trunk/pinot.spec.in	2006-04-04 13:38:06 UTC (rev 185)
@@ -12,7 +12,7 @@
 URL: http://pinot.berlios.de/
 BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
 Requires: xapian-core-libs >= 0.9.4, curl >= 7.13, gtkmm24 >= 2.6, libxml++ >= 2.12, mozilla >= %{mozilla_ver}, sqlite >= 3.1.2, libtextcat >= 2.2, fam >= 2.6.10, gmime >= 2.1, file
-BuildRequires: xapian-core-devel >= 0.9.4, curl-devel >= 7.13, gtkmm24-devel >= 2.6, libxml++-devel >= 2.12, mozilla-devel >= %{mozilla_ver}, sqlite-devel >= 3.1.2, libtextcat-devel >= 2.2, fam-devel >= 2.6.10, gmime-devel >= 2.1, file, boost-devel >= 1.32, gettext-devel, desktop-file-utils
+BuildRequires: xapian-core-devel >= 0.9.4, curl-devel >= 7.13, gtkmm24-devel >= 2.6, libxml++-devel >= 2.12, mozilla-devel >= %{mozilla_ver}, sqlite-devel >= 3.1.2, libtextcat-devel >= 2.2, fam-devel >= 2.6.10, gmime-devel >= 2.1, taglib-devel >= 1.4, boost-devel >= 1.32, gettext-devel, desktop-file-utils
 
 %description
 Pinot is a metasearch tool for the Free Desktop. It enables one to query
@@ -29,6 +29,15 @@
 %description text-docs 
 The included tokenizers add support for PDF, MS Word and RTF documents.
 
+%package audio-docs 
+Summary: Tokenizers for Pinot that handle various audio document formats
+Group: Applications/Internet
+Requires: %{name} = %{version}
+Requires: taglib >= 1.4
+
+%description audio-docs 
+The included tokenizer adds support for OGG and MP3 files.
+
 %package omega 
 Summary: Xapian Omega plugin for Pinot
 Group: Applications/Internet
@@ -115,6 +124,10 @@
 %{_datadir}/pinot/tokenizers/librtftokenizer.so
 %{_datadir}/pinot/tokenizers/libwordtokenizer.so
 
+%files audio-docs 
+%defattr(-, root, root, -)
+%{_datadir}/pinot/tokenizers/libtaglibtokenizer.so
+
 %files omega
 %defattr(-, root, root, -)
 %config(noreplace) %{_datadir}/pinot/engines/OmegaDescription.xml



From fabricecolin at berlios.de  Tue Apr  4 16:04:13 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 4 Apr 2006 16:04:13 +0200
Subject: [Pinot-svn] r186 - trunk
Message-ID: <200604041404.k34E4DnS022799@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-04 16:04:09 +0200 (Tue, 04 Apr 2006)
New Revision: 186

Modified:
   trunk/configure.in
Log:
Generation of Search/Google/Makefile is conditional.


Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2006-04-04 13:38:06 UTC (rev 185)
+++ trunk/configure.in	2006-04-04 14:04:09 UTC (rev 186)
@@ -177,7 +177,10 @@
 AC_CHECK_FUNCS(lstat)
 AC_CHECK_FUNCS(mmap)
 
-AC_OUTPUT( pinot.spec Makefile Utils/Makefile Tokenize/Makefile SQL/Makefile \
-	po/Makefile.in Collect/Makefile Search/Makefile Search/Google/Makefile \
-	Index/Makefile UI/RenderHTML/Makefile UI/GTK2/src/Makefile )
+AC_OUTPUT( pinot.spec Makefile Utils/Makefile Tokenize/Makefile )
+AC_OUTPUT( SQL/Makefile po/Makefile.in Collect/Makefile )
+if test "$SOAP_SUBDIRS" != "" ; then
+  AC_OUTPUT( Search/Google/Makefile )
+fi
+AC_OUTPUT( Search/Makefile Index/Makefile UI/RenderHTML/Makefile UI/GTK2/src/Makefile )
 



From fabricecolin at berlios.de  Tue Apr  4 17:16:44 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 4 Apr 2006 17:16:44 +0200
Subject: [Pinot-svn] r187 - trunk/UI/GTK2/src
Message-ID: <200604041516.k34FGir3023563@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-04 17:16:44 +0200 (Tue, 04 Apr 2006)
New Revision: 187

Modified:
   trunk/UI/GTK2/src/Makefile.am
Log:
Flags and libraries for SOAP support.


Modified: trunk/UI/GTK2/src/Makefile.am
===================================================================
--- trunk/UI/GTK2/src/Makefile.am	2006-04-04 14:04:09 UTC (rev 186)
+++ trunk/UI/GTK2/src/Makefile.am	2006-04-04 15:16:44 UTC (rev 187)
@@ -53,12 +53,12 @@
 
 bin_PROGRAMS = pinot
 
-AM_CXXFLAGS = -I../../../Utils -I../../../Tokenize -I../../../SQL \
-	-I../../../Collect -I../../../Search -I../../../Index -I../../RenderHTML \
-	@SQL_CFLAGS@ @HTTP_CFLAGS@ @MIME_CFLAGS@ @XML_CFLAGS@ @INDEX_CFLAGS@ @UI_CFLAGS@
+AM_CXXFLAGS = -I../../../Utils -I../../../Tokenize -I../../../SQL -I../../../Collect \
+	-I../../../Search -I../../../Search/Google -I../../../Index -I../../RenderHTML \
+	@SQL_CFLAGS@ @HTTP_CFLAGS@ @MIME_CFLAGS@ @XML_CFLAGS@ @SOAP_CFLAGS@ @INDEX_CFLAGS@ @UI_CFLAGS@
 
-pinot_LDADD = -L../../../Utils -L../../../Tokenize -L../../../SQL \
-        -L../../../Collect -L../../../Search -L../../../Index -L../../RenderHTML \
-	-lHTML -lIndex -lSearch -lCollect -lSQL -lTokenize -lUtils \
-	@LIBS@ @UI_LIBS@ @INDEX_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
+pinot_LDADD = -L../../../Utils -L../../../Tokenize -L../../../SQL -L../../../Collect \
+	-L../../../Search -L../../../Search/Google -L../../../Index -L../../RenderHTML \
+	-lHTML -lIndex @SEARCH_LIBS@ -lCollect -lSQL -lTokenize -lUtils \
+	@LIBS@ @UI_LIBS@ @INDEX_LIBS@ @SOAP_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
 



From fabricecolin at berlios.de  Wed Apr  5 15:08:05 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 5 Apr 2006 15:08:05 +0200
Subject: [Pinot-svn] r189 - trunk/Search/Google
Message-ID: <200604051308.k35D85oJ020613@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-05 15:08:03 +0200 (Wed, 05 Apr 2006)
New Revision: 189

Modified:
   trunk/Search/Google/GAPIC.cpp
Log:
Added missing types to calls to soap_out_std__string().


Modified: trunk/Search/Google/GAPIC.cpp
===================================================================
--- trunk/Search/Google/GAPIC.cpp	2006-04-05 13:06:48 UTC (rev 188)
+++ trunk/Search/Google/GAPIC.cpp	2006-04-05 13:08:03 UTC (rev 189)
@@ -7,7 +7,7 @@
 
 #include "GAPIH.h"
 
-SOAP_SOURCE_STAMP("@(#) GAPIC.cpp ver 2.7.6e 2006-04-05 04:17:23 GMT")
+SOAP_SOURCE_STAMP("@(#) GAPIC.cpp ver 2.7.6e 2006-04-02 07:31:50 GMT")
 
 
 #ifndef WITH_NOGLOBAL
@@ -2811,16 +2811,16 @@
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGoogleSearch(struct soap *soap, const char *tag, int id, const struct gapi1__doGoogleSearch *a, const char *type)
 {
 	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGoogleSearch), type);
-	soap_out_std__string(soap, "key", -1, &a->key, "");
-	soap_out_std__string(soap, "q", -1, &a->q, "");
-	soap_out_int(soap, "start", -1, &a->start, "");
-	soap_out_int(soap, "maxResults", -1, &a->maxResults, "");
-	soap_out_bool(soap, "filter", -1, &a->filter, "");
-	soap_out_std__string(soap, "restrict", -1, &a->restrict_, "");
-	soap_out_bool(soap, "safeSearch", -1, &a->safeSearch, "");
-	soap_out_std__string(soap, "lr", -1, &a->lr, "");
-	soap_out_std__string(soap, "ie", -1, &a->ie, "");
-	soap_out_std__string(soap, "oe", -1, &a->oe, "");
+	soap_out_std__string(soap, "key", -1, &a->key, "xsd:string");
+	soap_out_std__string(soap, "q", -1, &a->q, "xsd:string");
+	soap_out_int(soap, "start", -1, &a->start, "xsd:int");
+	soap_out_int(soap, "maxResults", -1, &a->maxResults, "xsd:int");
+	soap_out_bool(soap, "filter", -1, &a->filter, "xsd:boolean");
+	soap_out_std__string(soap, "restrict", -1, &a->restrict_, "xsd:string");
+	soap_out_bool(soap, "safeSearch", -1, &a->safeSearch, "xsd:boolean");
+	soap_out_std__string(soap, "lr", -1, &a->lr, "xsd:string");
+	soap_out_std__string(soap, "ie", -1, &a->ie, "xsd:string");
+	soap_out_std__string(soap, "oe", -1, &a->oe, "xsd:string");
 	soap_element_end_out(soap, tag);
 	return SOAP_OK;
 }
@@ -3091,8 +3091,8 @@
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doSpellingSuggestion(struct soap *soap, const char *tag, int id, const struct gapi1__doSpellingSuggestion *a, const char *type)
 {
 	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doSpellingSuggestion), type);
-	soap_out_std__string(soap, "key", -1, &a->key, "");
-	soap_out_std__string(soap, "phrase", -1, &a->phrase, "");
+	soap_out_std__string(soap, "key", -1, &a->key, "xsd:string");
+	soap_out_std__string(soap, "phrase", -1, &a->phrase, "xsd:string");
 	soap_element_end_out(soap, tag);
 	return SOAP_OK;
 }
@@ -3326,8 +3326,8 @@
 SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGetCachedPage(struct soap *soap, const char *tag, int id, const struct gapi1__doGetCachedPage *a, const char *type)
 {
 	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGetCachedPage), type);
-	soap_out_std__string(soap, "key", -1, &a->key, "");
-	soap_out_std__string(soap, "url", -1, &a->url, "");
+	soap_out_std__string(soap, "key", -1, &a->key, "xsd:string");
+	soap_out_std__string(soap, "url", -1, &a->url, "xsd:string");
 	soap_element_end_out(soap, tag);
 	return SOAP_OK;
 }



From fabricecolin at berlios.de  Wed Apr  5 15:07:02 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 5 Apr 2006 15:07:02 +0200
Subject: [Pinot-svn] r188 - trunk/Search/Google
Message-ID: <200604051307.k35D71oV020392@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-05 15:06:48 +0200 (Wed, 05 Apr 2006)
New Revision: 188

Added:
   trunk/Search/Google/GAPI.nsmap
   trunk/Search/Google/GAPIC.cpp
   trunk/Search/Google/GAPIClient.cpp
   trunk/Search/Google/GAPIClientLib.cpp
   trunk/Search/Google/GAPIGoogleSearchBindingProxy.h
   trunk/Search/Google/GAPIH.h
   trunk/Search/Google/GAPIStub.h
Log:
Checking in gSOAP-generated (v2.7.6e) client stubs. They shouldn't have to be
regenerated too often and one of them needs to be fixed (see next commit :-).


Added: trunk/Search/Google/GAPI.nsmap
===================================================================
--- trunk/Search/Google/GAPI.nsmap	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPI.nsmap	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,11 @@
+
+#include "GAPIH.h"
+SOAP_NMAC struct Namespace GAPI_namespaces[] =
+{
+	{"SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL},
+	{"SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL},
+	{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
+	{"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
+	{"gapi1", "urn:GoogleSearch", NULL, NULL},
+	{NULL, NULL, NULL, NULL}
+};

Added: trunk/Search/Google/GAPIC.cpp
===================================================================
--- trunk/Search/Google/GAPIC.cpp	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPIC.cpp	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,4187 @@
+/* GAPIC.cpp
+   Generated by gSOAP 2.7.6e from GoogleSearch.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+
+#include "GAPIH.h"
+
+SOAP_SOURCE_STAMP("@(#) GAPIC.cpp ver 2.7.6e 2006-04-05 04:17:23 GMT")
+
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
+{
+	if (soap->header)
+		soap_serialize_SOAP_ENV__Header(soap, soap->header);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
+{
+	if (soap->header)
+	{	soap->part = SOAP_IN_HEADER;
+		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
+		soap->part = SOAP_END_HEADER;
+	}
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
+{
+	soap->part = SOAP_IN_HEADER;
+	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
+	soap->part = SOAP_END_HEADER;
+	return soap->header == NULL;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
+{
+	if (!soap->fault)
+	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
+		soap_default_SOAP_ENV__Fault(soap, soap->fault);
+	}
+	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
+	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
+		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
+	}
+	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
+	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
+		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
+	}
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
+{
+	if (soap->fault)
+		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
+{
+	if (soap->fault)
+		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
+{
+	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
+}
+
+SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
+{
+	soap_fault(soap);
+	if (soap->version == 2)
+		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
+	return (const char**)&soap->fault->faultcode;
+}
+
+SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
+{
+	soap_fault(soap);
+	if (soap->version == 2)
+	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
+		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
+			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
+		}
+		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
+	}
+	return (const char**)&soap->fault->faultcode;
+}
+
+SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
+{
+	soap_fault(soap);
+	if (soap->version == 2)
+		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
+	return (const char**)&soap->fault->faultstring;
+}
+
+SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
+{
+	soap_fault(soap);
+	if (soap->version == 1)
+	{	if (!soap->fault->detail)
+		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
+			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
+		}
+		return (const char**)&soap->fault->detail->__any;
+	}
+	if (!soap->fault->SOAP_ENV__Detail)
+	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
+		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
+	}
+	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
+}
+
+#endif
+
+#ifndef WITH_NOIDREF
+SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
+{
+	int t;
+	for (;;)
+		if (!soap_getelement(soap, &t))
+			if (soap->error || soap_ignore_element(soap))
+				break;
+	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
+		soap->error = SOAP_OK;
+	return soap->error;
+}
+#endif
+
+#ifndef WITH_NOIDREF
+SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
+{
+	if (soap_peek_element(soap))
+		return NULL;
+	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
+		*type = soap_lookup_type(soap, soap->href);
+	switch (*type)
+	{
+	case SOAP_TYPE_byte:
+		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
+	case SOAP_TYPE_int:
+		return soap_in_int(soap, NULL, NULL, "xsd:int");
+	case SOAP_TYPE_double:
+		return soap_in_double(soap, NULL, NULL, "xsd:double");
+	case SOAP_TYPE_unsignedByte:
+		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
+	case SOAP_TYPE_unsignedInt:
+		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
+	case SOAP_TYPE_bool:
+		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
+	case SOAP_TYPE_gapi1__DirectoryCategory:
+		return soap_in_gapi1__DirectoryCategory(soap, NULL, NULL, "gapi1:DirectoryCategory");
+	case SOAP_TYPE_gapi1DirectoryCategoryArray:
+		return soap_in_gapi1DirectoryCategoryArray(soap, NULL, NULL, "gapi1:DirectoryCategory");
+	case SOAP_TYPE_gapi1ResultElementArray:
+		return soap_in_gapi1ResultElementArray(soap, NULL, NULL, "gapi1:ResultElement");
+	case SOAP_TYPE_gapi1__ResultElement:
+		return soap_in_gapi1__ResultElement(soap, NULL, NULL, "gapi1:ResultElement");
+	case SOAP_TYPE_gapi1__GoogleSearchResult:
+		return soap_in_gapi1__GoogleSearchResult(soap, NULL, NULL, "gapi1:GoogleSearchResult");
+	case SOAP_TYPE__SOAP_ENC__arrayType:
+		return soap_in__SOAP_ENC__arrayType(soap, NULL, NULL, "SOAP-ENC:arrayType");
+	case SOAP_TYPE_std__string:
+		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
+	case SOAP_TYPE_xsd__base64Binary:
+		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
+	case SOAP_TYPE_gapi1__doGoogleSearch:
+		return soap_in_gapi1__doGoogleSearch(soap, NULL, NULL, "gapi1:doGoogleSearch");
+	case SOAP_TYPE_gapi1__doGoogleSearchResponse:
+		return soap_in_gapi1__doGoogleSearchResponse(soap, NULL, NULL, "gapi1:doGoogleSearchResponse");
+	case SOAP_TYPE_gapi1__doSpellingSuggestion:
+		return soap_in_gapi1__doSpellingSuggestion(soap, NULL, NULL, "gapi1:doSpellingSuggestion");
+	case SOAP_TYPE_gapi1__doSpellingSuggestionResponse:
+		return soap_in_gapi1__doSpellingSuggestionResponse(soap, NULL, NULL, "gapi1:doSpellingSuggestionResponse");
+	case SOAP_TYPE_gapi1__doGetCachedPage:
+		return soap_in_gapi1__doGetCachedPage(soap, NULL, NULL, "gapi1:doGetCachedPage");
+	case SOAP_TYPE_gapi1__doGetCachedPageResponse:
+		return soap_in_gapi1__doGetCachedPageResponse(soap, NULL, NULL, "gapi1:doGetCachedPageResponse");
+	case SOAP_TYPE_PointerTogapi1__GoogleSearchResult:
+		return soap_in_PointerTogapi1__GoogleSearchResult(soap, NULL, NULL, "gapi1:GoogleSearchResult");
+	case SOAP_TYPE_PointerToPointerTogapi1__DirectoryCategory:
+		return soap_in_PointerToPointerTogapi1__DirectoryCategory(soap, NULL, NULL, "gapi1:DirectoryCategory");
+	case SOAP_TYPE_PointerToPointerTogapi1__ResultElement:
+		return soap_in_PointerToPointerTogapi1__ResultElement(soap, NULL, NULL, "gapi1:ResultElement");
+	case SOAP_TYPE_PointerTogapi1__ResultElement:
+		return soap_in_PointerTogapi1__ResultElement(soap, NULL, NULL, "gapi1:ResultElement");
+	case SOAP_TYPE_PointerTogapi1__DirectoryCategory:
+		return soap_in_PointerTogapi1__DirectoryCategory(soap, NULL, NULL, "gapi1:DirectoryCategory");
+	case SOAP_TYPE_PointerTogapi1DirectoryCategoryArray:
+		return soap_in_PointerTogapi1DirectoryCategoryArray(soap, NULL, NULL, "gapi1:DirectoryCategory");
+	case SOAP_TYPE_PointerTogapi1ResultElementArray:
+		return soap_in_PointerTogapi1ResultElementArray(soap, NULL, NULL, "gapi1:ResultElement");
+	case SOAP_TYPE_PointerTounsignedByte:
+		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
+	case SOAP_TYPE__QName:
+	{	char **s;
+		s = soap_in__QName(soap, NULL, NULL, "QName");
+		return s ? *s : NULL;
+	}
+	case SOAP_TYPE_string:
+	{	char **s;
+		s = soap_in_string(soap, NULL, NULL, "xsd:string");
+		return s ? *s : NULL;
+	}
+	default:
+	{	const char *t = soap->type;
+		if (!*t)
+			t = soap->tag;
+		if (!soap_match_tag(soap, t, "xsd:byte"))
+		{	*type = SOAP_TYPE_byte;
+			return soap_in_byte(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "xsd:int"))
+		{	*type = SOAP_TYPE_int;
+			return soap_in_int(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "xsd:double"))
+		{	*type = SOAP_TYPE_double;
+			return soap_in_double(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
+		{	*type = SOAP_TYPE_unsignedByte;
+			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
+		{	*type = SOAP_TYPE_unsignedInt;
+			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "xsd:boolean"))
+		{	*type = SOAP_TYPE_bool;
+			return soap_in_bool(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "gapi1:DirectoryCategory"))
+		{	*type = SOAP_TYPE_gapi1__DirectoryCategory;
+			return soap_in_gapi1__DirectoryCategory(soap, NULL, NULL, NULL);
+		}
+		if (*soap->arrayType && !soap_match_array(soap, "gapi1:DirectoryCategory"))
+		{	*type = SOAP_TYPE_gapi1DirectoryCategoryArray;
+			return soap_in_gapi1DirectoryCategoryArray(soap, NULL, NULL, NULL);
+		}
+		if (*soap->arrayType && !soap_match_array(soap, "gapi1:ResultElement"))
+		{	*type = SOAP_TYPE_gapi1ResultElementArray;
+			return soap_in_gapi1ResultElementArray(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "gapi1:ResultElement"))
+		{	*type = SOAP_TYPE_gapi1__ResultElement;
+			return soap_in_gapi1__ResultElement(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "gapi1:GoogleSearchResult"))
+		{	*type = SOAP_TYPE_gapi1__GoogleSearchResult;
+			return soap_in_gapi1__GoogleSearchResult(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "SOAP-ENC:arrayType"))
+		{	*type = SOAP_TYPE__SOAP_ENC__arrayType;
+			return soap_in__SOAP_ENC__arrayType(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "xsd:string"))
+		{	*type = SOAP_TYPE_std__string;
+			return soap_in_std__string(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
+		{	*type = SOAP_TYPE_xsd__base64Binary;
+			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "gapi1:doGoogleSearch"))
+		{	*type = SOAP_TYPE_gapi1__doGoogleSearch;
+			return soap_in_gapi1__doGoogleSearch(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "gapi1:doGoogleSearchResponse"))
+		{	*type = SOAP_TYPE_gapi1__doGoogleSearchResponse;
+			return soap_in_gapi1__doGoogleSearchResponse(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "gapi1:doSpellingSuggestion"))
+		{	*type = SOAP_TYPE_gapi1__doSpellingSuggestion;
+			return soap_in_gapi1__doSpellingSuggestion(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "gapi1:doSpellingSuggestionResponse"))
+		{	*type = SOAP_TYPE_gapi1__doSpellingSuggestionResponse;
+			return soap_in_gapi1__doSpellingSuggestionResponse(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "gapi1:doGetCachedPage"))
+		{	*type = SOAP_TYPE_gapi1__doGetCachedPage;
+			return soap_in_gapi1__doGetCachedPage(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "gapi1:doGetCachedPageResponse"))
+		{	*type = SOAP_TYPE_gapi1__doGetCachedPageResponse;
+			return soap_in_gapi1__doGetCachedPageResponse(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, "QName"))
+		{	char **s;
+			*type = SOAP_TYPE__QName;
+			s = soap_in__QName(soap, NULL, NULL, NULL);
+			return s ? *s : NULL;
+		}
+		if (!soap_match_tag(soap, t, "xsd:string"))
+		{	char **s;
+			*type = SOAP_TYPE_string;
+			s = soap_in_string(soap, NULL, NULL, NULL);
+			return s ? *s : NULL;
+		}
+	}
+	}
+	soap->error = SOAP_TAG_MISMATCH;
+	return NULL;
+}
+#endif
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
+{
+	if (!soap_peek_element(soap))
+	{	int t;
+		if (soap->mustUnderstand && !soap->other)
+			return soap->error = SOAP_MUSTUNDERSTAND;
+		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
+			return soap->error = SOAP_TAG_MISMATCH;
+		if (!*soap->id || !soap_getelement(soap, &t))
+		{	soap->peeked = 0;
+			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
+			if (soap->fignore)
+				soap->error = soap->fignore(soap, soap->tag);
+			else
+				soap->error = SOAP_OK;
+			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
+			if (!soap->error && soap->body)
+			{	soap->level++;
+				while (!soap_ignore_element(soap))
+					;
+				if (soap->error == SOAP_NO_TAG)
+					soap->error = soap_element_end_in(soap, NULL);
+			}
+		}
+	}
+	return soap->error;
+}
+
+#ifndef WITH_NOIDREF
+SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
+{
+	int i;
+	struct soap_plist *pp;
+	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
+		for (i = 0; i < SOAP_PTRHASH; i++)
+			for (pp = soap->pht[i]; pp; pp = pp->next)
+				if (pp->mark1 == 2 || pp->mark2 == 2)
+					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
+						return soap->error;
+	return SOAP_OK;
+}
+#endif
+
+#ifndef WITH_NOIDREF
+SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
+{
+	switch (type)
+	{
+	case SOAP_TYPE_byte:
+		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
+	case SOAP_TYPE_int:
+		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
+	case SOAP_TYPE_double:
+		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
+	case SOAP_TYPE_unsignedByte:
+		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
+	case SOAP_TYPE_unsignedInt:
+		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
+	case SOAP_TYPE_bool:
+		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
+	case SOAP_TYPE_gapi1__DirectoryCategory:
+		return ((gapi1__DirectoryCategory *)ptr)->soap_out(soap, tag, id, "gapi1:DirectoryCategory");
+	case SOAP_TYPE_gapi1DirectoryCategoryArray:
+		return ((gapi1DirectoryCategoryArray *)ptr)->soap_out(soap, tag, id, "gapi1:DirectoryCategory");
+	case SOAP_TYPE_gapi1ResultElementArray:
+		return ((gapi1ResultElementArray *)ptr)->soap_out(soap, tag, id, "gapi1:ResultElement");
+	case SOAP_TYPE_gapi1__ResultElement:
+		return ((gapi1__ResultElement *)ptr)->soap_out(soap, tag, id, "gapi1:ResultElement");
+	case SOAP_TYPE_gapi1__GoogleSearchResult:
+		return ((gapi1__GoogleSearchResult *)ptr)->soap_out(soap, tag, id, "gapi1:GoogleSearchResult");
+	case SOAP_TYPE__SOAP_ENC__arrayType:
+		return soap_out__SOAP_ENC__arrayType(soap, "SOAP-ENC:arrayType", id, (const std::string *)ptr, NULL);
+	case SOAP_TYPE_std__string:
+		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
+	case SOAP_TYPE_xsd__base64Binary:
+		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
+	case SOAP_TYPE_gapi1__doGoogleSearch:
+		return soap_out_gapi1__doGoogleSearch(soap, tag, id, (const struct gapi1__doGoogleSearch *)ptr, "gapi1:doGoogleSearch");
+	case SOAP_TYPE_gapi1__doGoogleSearchResponse:
+		return soap_out_gapi1__doGoogleSearchResponse(soap, tag, id, (const struct gapi1__doGoogleSearchResponse *)ptr, "gapi1:doGoogleSearchResponse");
+	case SOAP_TYPE_gapi1__doSpellingSuggestion:
+		return soap_out_gapi1__doSpellingSuggestion(soap, tag, id, (const struct gapi1__doSpellingSuggestion *)ptr, "gapi1:doSpellingSuggestion");
+	case SOAP_TYPE_gapi1__doSpellingSuggestionResponse:
+		return soap_out_gapi1__doSpellingSuggestionResponse(soap, tag, id, (const struct gapi1__doSpellingSuggestionResponse *)ptr, "gapi1:doSpellingSuggestionResponse");
+	case SOAP_TYPE_gapi1__doGetCachedPage:
+		return soap_out_gapi1__doGetCachedPage(soap, tag, id, (const struct gapi1__doGetCachedPage *)ptr, "gapi1:doGetCachedPage");
+	case SOAP_TYPE_gapi1__doGetCachedPageResponse:
+		return soap_out_gapi1__doGetCachedPageResponse(soap, tag, id, (const struct gapi1__doGetCachedPageResponse *)ptr, "gapi1:doGetCachedPageResponse");
+	case SOAP_TYPE_PointerTogapi1__GoogleSearchResult:
+		return soap_out_PointerTogapi1__GoogleSearchResult(soap, tag, id, (gapi1__GoogleSearchResult *const*)ptr, "gapi1:GoogleSearchResult");
+	case SOAP_TYPE_PointerToPointerTogapi1__DirectoryCategory:
+		return soap_out_PointerToPointerTogapi1__DirectoryCategory(soap, tag, id, (gapi1__DirectoryCategory **const*)ptr, "gapi1:DirectoryCategory");
+	case SOAP_TYPE_PointerToPointerTogapi1__ResultElement:
+		return soap_out_PointerToPointerTogapi1__ResultElement(soap, tag, id, (gapi1__ResultElement **const*)ptr, "gapi1:ResultElement");
+	case SOAP_TYPE_PointerTogapi1__ResultElement:
+		return soap_out_PointerTogapi1__ResultElement(soap, tag, id, (gapi1__ResultElement *const*)ptr, "gapi1:ResultElement");
+	case SOAP_TYPE_PointerTogapi1__DirectoryCategory:
+		return soap_out_PointerTogapi1__DirectoryCategory(soap, tag, id, (gapi1__DirectoryCategory *const*)ptr, "gapi1:DirectoryCategory");
+	case SOAP_TYPE_PointerTogapi1DirectoryCategoryArray:
+		return soap_out_PointerTogapi1DirectoryCategoryArray(soap, tag, id, (gapi1DirectoryCategoryArray *const*)ptr, "gapi1:DirectoryCategory");
+	case SOAP_TYPE_PointerTogapi1ResultElementArray:
+		return soap_out_PointerTogapi1ResultElementArray(soap, tag, id, (gapi1ResultElementArray *const*)ptr, "gapi1:ResultElement");
+	case SOAP_TYPE_PointerTounsignedByte:
+		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
+	case SOAP_TYPE__QName:
+		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
+	case SOAP_TYPE_string:
+		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
+	}
+	return SOAP_OK;
+}
+#endif
+
+#ifndef WITH_NOIDREF
+SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
+{
+	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
+	switch (type)
+	{
+	case SOAP_TYPE_gapi1__DirectoryCategory:
+		((gapi1__DirectoryCategory *)ptr)->soap_serialize(soap);
+		break;
+	case SOAP_TYPE_gapi1DirectoryCategoryArray:
+		((gapi1DirectoryCategoryArray *)ptr)->soap_serialize(soap);
+		break;
+	case SOAP_TYPE_gapi1ResultElementArray:
+		((gapi1ResultElementArray *)ptr)->soap_serialize(soap);
+		break;
+	case SOAP_TYPE_gapi1__ResultElement:
+		((gapi1__ResultElement *)ptr)->soap_serialize(soap);
+		break;
+	case SOAP_TYPE_gapi1__GoogleSearchResult:
+		((gapi1__GoogleSearchResult *)ptr)->soap_serialize(soap);
+		break;
+	case SOAP_TYPE__SOAP_ENC__arrayType:
+		soap_serialize__SOAP_ENC__arrayType(soap, (const std::string *)ptr);
+		break;
+	case SOAP_TYPE_std__string:
+		soap_serialize_std__string(soap, (const std::string *)ptr);
+		break;
+	case SOAP_TYPE_xsd__base64Binary:
+		((xsd__base64Binary *)ptr)->soap_serialize(soap);
+		break;
+	case SOAP_TYPE_gapi1__doGoogleSearch:
+		soap_serialize_gapi1__doGoogleSearch(soap, (const struct gapi1__doGoogleSearch *)ptr);
+		break;
+	case SOAP_TYPE_gapi1__doGoogleSearchResponse:
+		soap_serialize_gapi1__doGoogleSearchResponse(soap, (const struct gapi1__doGoogleSearchResponse *)ptr);
+		break;
+	case SOAP_TYPE_gapi1__doSpellingSuggestion:
+		soap_serialize_gapi1__doSpellingSuggestion(soap, (const struct gapi1__doSpellingSuggestion *)ptr);
+		break;
+	case SOAP_TYPE_gapi1__doSpellingSuggestionResponse:
+		soap_serialize_gapi1__doSpellingSuggestionResponse(soap, (const struct gapi1__doSpellingSuggestionResponse *)ptr);
+		break;
+	case SOAP_TYPE_gapi1__doGetCachedPage:
+		soap_serialize_gapi1__doGetCachedPage(soap, (const struct gapi1__doGetCachedPage *)ptr);
+		break;
+	case SOAP_TYPE_gapi1__doGetCachedPageResponse:
+		soap_serialize_gapi1__doGetCachedPageResponse(soap, (const struct gapi1__doGetCachedPageResponse *)ptr);
+		break;
+	case SOAP_TYPE_PointerTogapi1__GoogleSearchResult:
+		soap_serialize_PointerTogapi1__GoogleSearchResult(soap, (gapi1__GoogleSearchResult *const*)ptr);
+		break;
+	case SOAP_TYPE_PointerToPointerTogapi1__DirectoryCategory:
+		soap_serialize_PointerToPointerTogapi1__DirectoryCategory(soap, (gapi1__DirectoryCategory **const*)ptr);
+		break;
+	case SOAP_TYPE_PointerToPointerTogapi1__ResultElement:
+		soap_serialize_PointerToPointerTogapi1__ResultElement(soap, (gapi1__ResultElement **const*)ptr);
+		break;
+	case SOAP_TYPE_PointerTogapi1__ResultElement:
+		soap_serialize_PointerTogapi1__ResultElement(soap, (gapi1__ResultElement *const*)ptr);
+		break;
+	case SOAP_TYPE_PointerTogapi1__DirectoryCategory:
+		soap_serialize_PointerTogapi1__DirectoryCategory(soap, (gapi1__DirectoryCategory *const*)ptr);
+		break;
+	case SOAP_TYPE_PointerTogapi1DirectoryCategoryArray:
+		soap_serialize_PointerTogapi1DirectoryCategoryArray(soap, (gapi1DirectoryCategoryArray *const*)ptr);
+		break;
+	case SOAP_TYPE_PointerTogapi1ResultElementArray:
+		soap_serialize_PointerTogapi1ResultElementArray(soap, (gapi1ResultElementArray *const*)ptr);
+		break;
+	case SOAP_TYPE_PointerTounsignedByte:
+		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
+		break;
+	case SOAP_TYPE__QName:
+		soap_serialize_string(soap, (char**)&ptr);
+		break;
+	case SOAP_TYPE_string:
+		soap_serialize_string(soap, (char**)&ptr);
+		break;
+	}
+}
+#endif
+
+SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
+{
+	switch (t)
+	{
+	case SOAP_TYPE_xsd__base64Binary:
+		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_std__string:
+		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__GoogleSearchResult:
+		return (void*)soap_instantiate_gapi1__GoogleSearchResult(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__ResultElement:
+		return (void*)soap_instantiate_gapi1__ResultElement(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__DirectoryCategory:
+		return (void*)soap_instantiate_gapi1__DirectoryCategory(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1ResultElementArray:
+		return (void*)soap_instantiate_gapi1ResultElementArray(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1DirectoryCategoryArray:
+		return (void*)soap_instantiate_gapi1DirectoryCategoryArray(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__doGetCachedPageResponse:
+		return (void*)soap_instantiate_gapi1__doGetCachedPageResponse(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__doGetCachedPage:
+		return (void*)soap_instantiate_gapi1__doGetCachedPage(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__doSpellingSuggestionResponse:
+		return (void*)soap_instantiate_gapi1__doSpellingSuggestionResponse(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__doSpellingSuggestion:
+		return (void*)soap_instantiate_gapi1__doSpellingSuggestion(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__doGoogleSearchResponse:
+		return (void*)soap_instantiate_gapi1__doGoogleSearchResponse(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__doGoogleSearch:
+		return (void*)soap_instantiate_gapi1__doGoogleSearch(soap, -1, type, arrayType, n);
+	case SOAP_TYPE__SOAP_ENC__arrayType:
+		return (void*)soap_instantiate__SOAP_ENC__arrayType(soap, -1, type, arrayType, n);
+	}
+	return NULL;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
+{	switch (p->type)
+	{
+	case SOAP_TYPE_xsd__base64Binary:
+		if (p->size < 0)
+			delete (xsd__base64Binary*)p->ptr;
+		else
+			delete[] (xsd__base64Binary*)p->ptr;
+		break;
+	case SOAP_TYPE_std__string:
+		if (p->size < 0)
+			delete (std::string*)p->ptr;
+		else
+			delete[] (std::string*)p->ptr;
+		break;
+	case SOAP_TYPE_gapi1__GoogleSearchResult:
+		if (p->size < 0)
+			delete (gapi1__GoogleSearchResult*)p->ptr;
+		else
+			delete[] (gapi1__GoogleSearchResult*)p->ptr;
+		break;
+	case SOAP_TYPE_gapi1__ResultElement:
+		if (p->size < 0)
+			delete (gapi1__ResultElement*)p->ptr;
+		else
+			delete[] (gapi1__ResultElement*)p->ptr;
+		break;
+	case SOAP_TYPE_gapi1__DirectoryCategory:
+		if (p->size < 0)
+			delete (gapi1__DirectoryCategory*)p->ptr;
+		else
+			delete[] (gapi1__DirectoryCategory*)p->ptr;
+		break;
+	case SOAP_TYPE_gapi1ResultElementArray:
+		if (p->size < 0)
+			delete (gapi1ResultElementArray*)p->ptr;
+		else
+			delete[] (gapi1ResultElementArray*)p->ptr;
+		break;
+	case SOAP_TYPE_gapi1DirectoryCategoryArray:
+		if (p->size < 0)
+			delete (gapi1DirectoryCategoryArray*)p->ptr;
+		else
+			delete[] (gapi1DirectoryCategoryArray*)p->ptr;
+		break;
+	case SOAP_TYPE_gapi1__doGetCachedPageResponse:
+		if (p->size < 0)
+			delete (struct gapi1__doGetCachedPageResponse*)p->ptr;
+		else
+			delete[] (struct gapi1__doGetCachedPageResponse*)p->ptr;
+		break;
+	case SOAP_TYPE_gapi1__doGetCachedPage:
+		if (p->size < 0)
+			delete (struct gapi1__doGetCachedPage*)p->ptr;
+		else
+			delete[] (struct gapi1__doGetCachedPage*)p->ptr;
+		break;
+	case SOAP_TYPE_gapi1__doSpellingSuggestionResponse:
+		if (p->size < 0)
+			delete (struct gapi1__doSpellingSuggestionResponse*)p->ptr;
+		else
+			delete[] (struct gapi1__doSpellingSuggestionResponse*)p->ptr;
+		break;
+	case SOAP_TYPE_gapi1__doSpellingSuggestion:
+		if (p->size < 0)
+			delete (struct gapi1__doSpellingSuggestion*)p->ptr;
+		else
+			delete[] (struct gapi1__doSpellingSuggestion*)p->ptr;
+		break;
+	case SOAP_TYPE_gapi1__doGoogleSearchResponse:
+		if (p->size < 0)
+			delete (struct gapi1__doGoogleSearchResponse*)p->ptr;
+		else
+			delete[] (struct gapi1__doGoogleSearchResponse*)p->ptr;
+		break;
+	case SOAP_TYPE_gapi1__doGoogleSearch:
+		if (p->size < 0)
+			delete (struct gapi1__doGoogleSearch*)p->ptr;
+		else
+			delete[] (struct gapi1__doGoogleSearch*)p->ptr;
+		break;
+	case SOAP_TYPE_SOAP_ENV__Header:
+		if (p->size < 0)
+			delete (struct SOAP_ENV__Header*)p->ptr;
+		else
+			delete[] (struct SOAP_ENV__Header*)p->ptr;
+		break;
+	case SOAP_TYPE_SOAP_ENV__Code:
+		if (p->size < 0)
+			delete (struct SOAP_ENV__Code*)p->ptr;
+		else
+			delete[] (struct SOAP_ENV__Code*)p->ptr;
+		break;
+	case SOAP_TYPE_SOAP_ENV__Detail:
+		if (p->size < 0)
+			delete (struct SOAP_ENV__Detail*)p->ptr;
+		else
+			delete[] (struct SOAP_ENV__Detail*)p->ptr;
+		break;
+	case SOAP_TYPE_SOAP_ENV__Reason:
+		if (p->size < 0)
+			delete (struct SOAP_ENV__Reason*)p->ptr;
+		else
+			delete[] (struct SOAP_ENV__Reason*)p->ptr;
+		break;
+	case SOAP_TYPE_SOAP_ENV__Fault:
+		if (p->size < 0)
+			delete (struct SOAP_ENV__Fault*)p->ptr;
+		else
+			delete[] (struct SOAP_ENV__Fault*)p->ptr;
+		break;
+	case SOAP_TYPE__SOAP_ENC__arrayType:
+		if (p->size < 0)
+			delete (std::string*)p->ptr;
+		else
+			delete[] (std::string*)p->ptr;
+		break;
+	}
+}
+
+SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
+{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
+}
+
+SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
+{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{	switch (tt)
+	{
+	default:
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
+	}
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_byte
+	*a = SOAP_DEFAULT_byte;
+#else
+	*a = (char)0;
+#endif
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
+	if (soap_out_byte(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
+{
+	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
+}
+
+SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_byte(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
+{
+	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_int
+	*a = SOAP_DEFAULT_int;
+#else
+	*a = (int)0;
+#endif
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
+	if (soap_out_int(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
+{
+	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
+}
+
+SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_int(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
+{
+	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_double
+	*a = SOAP_DEFAULT_double;
+#else
+	*a = (double)0;
+#endif
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
+	if (soap_out_double(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
+{
+	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
+}
+
+SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_double(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
+{
+	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_unsignedByte
+	*a = SOAP_DEFAULT_unsignedByte;
+#else
+	*a = (unsigned char)0;
+#endif
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
+	if (soap_out_unsignedByte(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
+{
+	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
+}
+
+SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
+{
+	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_unsignedInt
+	*a = SOAP_DEFAULT_unsignedInt;
+#else
+	*a = (unsigned int)0;
+#endif
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
+	if (soap_out_unsignedInt(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
+{
+	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
+}
+
+SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
+{
+	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_bool
+	*a = SOAP_DEFAULT_bool;
+#else
+	*a = (bool)0;
+#endif
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
+	if (soap_out_bool(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+static const struct soap_code_map soap_codes_bool[] =
+{	{ (long)false, "false" },
+	{ (long)true, "true" },
+	{ 0, NULL }
+};
+
+SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
+{	const char *s = soap_str_code(soap_codes_bool, (long)n);
+	if (s)
+		return s;
+	return soap_long2s(soap, (long)n);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
+{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
+	soap_send(soap, soap_bool2s(soap, *a));
+	return soap_element_end_out(soap, tag);
+}
+
+SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_bool(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
+{
+	const struct soap_code_map *map;
+	if (!s)
+		return SOAP_OK;
+	map = soap_code(soap_codes_bool, s);
+	if (map)
+		*a = (bool)(map->code != 0);
+	else
+	{	long n;
+		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
+			return soap->error = SOAP_TYPE;
+		*a = (bool)(n != 0);
+	}
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	if (soap->body && !*soap->href)
+	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+void gapi1__DirectoryCategory::soap_serialize(struct soap *soap) const
+{
+	(void)soap; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &((gapi1__DirectoryCategory*)this)->fullViewableName);
+	soap_serialize_std__string(soap, &((gapi1__DirectoryCategory*)this)->specialEncoding);
+	/* transient soap skipped */
+}
+
+void gapi1__DirectoryCategory::soap_default(struct soap *soap)
+{
+	this->soap = soap;
+	soap_default_std__string(soap, &((gapi1__DirectoryCategory*)this)->fullViewableName);
+	soap_default_std__string(soap, &((gapi1__DirectoryCategory*)this)->specialEncoding);
+	/* transient soap skipped */
+}
+
+int gapi1__DirectoryCategory::soap_put(struct soap *soap, const char *tag, const  char *type) const
+{
+	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gapi1__DirectoryCategory);
+	if (this->soap_out(soap, tag, id, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+int gapi1__DirectoryCategory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
+{
+	return soap_out_gapi1__DirectoryCategory(soap, tag, id, this, type);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__DirectoryCategory(struct soap *soap, const char *tag, int id, const gapi1__DirectoryCategory *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__DirectoryCategory), type);
+	soap_out_std__string(soap, "fullViewableName", -1, &(((gapi1__DirectoryCategory*)a)->fullViewableName), "");
+	soap_out_std__string(soap, "specialEncoding", -1, &(((gapi1__DirectoryCategory*)a)->specialEncoding), "");
+	/* transient soap skipped */
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+void *gapi1__DirectoryCategory::soap_get(struct soap *soap, const char *tag, const char *type)
+{
+	return soap_get_gapi1__DirectoryCategory(soap, this, tag, type);
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_get_gapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__DirectoryCategory(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+void *gapi1__DirectoryCategory::soap_in(struct soap *soap, const char *tag, const char *type)
+{	return soap_in_gapi1__DirectoryCategory(soap, tag, this, type);
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_in_gapi1__DirectoryCategory(struct soap *soap, const char *tag, gapi1__DirectoryCategory *a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	a = (gapi1__DirectoryCategory *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gapi1__DirectoryCategory, sizeof(gapi1__DirectoryCategory), soap->type, soap->arrayType);
+	if (!a)
+		return NULL;
+	if (soap->alloced)
+	{	a->soap_default(soap);
+		if (soap->clist->type != SOAP_TYPE_gapi1__DirectoryCategory)
+		{	soap_revert(soap);
+			*soap->id = '\0';
+			return (gapi1__DirectoryCategory *)a->soap_in(soap, tag, type);
+		}
+	}
+	short soap_flag_fullViewableName1 = 1, soap_flag_specialEncoding1 = 1;
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+			if (soap_flag_fullViewableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "fullViewableName", &(((gapi1__DirectoryCategory*)a)->fullViewableName), "xsd:string"))
+				{	soap_flag_fullViewableName1--;
+					continue;
+				}
+			if (soap_flag_specialEncoding1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "specialEncoding", &(((gapi1__DirectoryCategory*)a)->specialEncoding), "xsd:string"))
+				{	soap_flag_specialEncoding1--;
+					continue;
+				}
+			/* transient soap skipped */
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fullViewableName1 > 0 || soap_flag_specialEncoding1 > 0))
+		{	soap->error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__DirectoryCategory *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_gapi1__DirectoryCategory, 0, sizeof(gapi1__DirectoryCategory), 0, soap_copy_gapi1__DirectoryCategory);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 gapi1__DirectoryCategory * SOAP_FMAC6 soap_new_gapi1__DirectoryCategory(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__DirectoryCategory(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_instantiate_gapi1__DirectoryCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__DirectoryCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__DirectoryCategory, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new gapi1__DirectoryCategory;
+		if (size)
+			*size = sizeof(gapi1__DirectoryCategory);
+		((gapi1__DirectoryCategory*)cp->ptr)->soap = soap;
+	}
+	else
+	{	cp->ptr = (void*)new gapi1__DirectoryCategory[n];
+		if (size)
+			*size = n * sizeof(gapi1__DirectoryCategory);
+		for (int i = 0; i < n; i++)
+			((gapi1__DirectoryCategory*)cp->ptr)[i].soap = soap;
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (gapi1__DirectoryCategory*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__DirectoryCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gapi1__DirectoryCategory %p -> %p\n", q, p));
+	*(gapi1__DirectoryCategory*)p = *(gapi1__DirectoryCategory*)q;
+}
+
+void gapi1DirectoryCategoryArray::soap_serialize(struct soap *soap) const
+{
+	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_gapi1DirectoryCategoryArray))
+		for (int i = 0; i < this->__size; i++)
+		{
+			soap_serialize_PointerTogapi1__DirectoryCategory(soap, this->__ptr + i);
+		}
+}
+
+void gapi1DirectoryCategoryArray::soap_default(struct soap *soap)
+{
+	this->soap = soap;
+	this->__size = 0;
+	this->__ptr = NULL;
+}
+
+int gapi1DirectoryCategoryArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
+{
+	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_gapi1DirectoryCategoryArray);
+	if (this->soap_out(soap, tag, id, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+int gapi1DirectoryCategoryArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
+{	return soap_out_gapi1DirectoryCategoryArray(soap, tag, id, this, type);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1DirectoryCategoryArray(struct soap *soap, const char *tag, int id, const gapi1DirectoryCategoryArray *a, const char *type)
+{
+	int i, n = a->__size;
+	char *t = soap_putsize(soap, "gapi1:DirectoryCategory", a->__size);
+	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_gapi1DirectoryCategoryArray);
+	if (id < 0)
+		return soap->error;
+	soap_array_begin_out(soap, tag, id, t, NULL);
+	for (i = 0; i < n; i++)
+	{
+		soap->position = 1;
+		soap->positions[0] = i;
+		soap_out_PointerTogapi1__DirectoryCategory(soap, "item", -1, &a->__ptr[i], "");
+	}
+	soap->position = 0;
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+void *gapi1DirectoryCategoryArray::soap_get(struct soap *soap, const char *tag, const char *type)
+{
+	return soap_get_gapi1DirectoryCategoryArray(soap, this, tag, type);
+}
+
+SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_get_gapi1DirectoryCategoryArray(struct soap *soap, gapi1DirectoryCategoryArray *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1DirectoryCategoryArray(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+void *gapi1DirectoryCategoryArray::soap_in(struct soap *soap, const char *tag, const char *type)
+{	return soap_in_gapi1DirectoryCategoryArray(soap, tag, this, type);
+}
+
+SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_in_gapi1DirectoryCategoryArray(struct soap *soap, const char *tag, gapi1DirectoryCategoryArray *a, const char *type)
+{	int i, j;
+	gapi1__DirectoryCategory **p;
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (soap_match_array(soap, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (gapi1DirectoryCategoryArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gapi1DirectoryCategoryArray, sizeof(gapi1DirectoryCategoryArray), soap->type, soap->arrayType);
+	if (!a)
+		return NULL;
+	if (soap->alloced)
+		a->soap_default(soap);
+	if (soap->body && !*soap->href)
+	{
+		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
+		if (a->__size >= 0)
+		{	a->__ptr = (gapi1__DirectoryCategory **)soap_malloc(soap, sizeof(gapi1__DirectoryCategory *) * a->__size);
+			for (i = 0; i < a->__size; i++)
+				a->__ptr[i] = NULL;
+			for (i = 0; i < a->__size; i++)
+			{	soap_peek_element(soap);
+				if (soap->position)
+				{	i = soap->positions[0]-j;
+					if (i < 0 || i >= a->__size)
+					{	soap->error = SOAP_IOB;
+						return NULL;
+					}
+				}
+				if (!soap_in_PointerTogapi1__DirectoryCategory(soap, NULL, a->__ptr + i, "gapi1:DirectoryCategory"))
+				{	if (soap->error != SOAP_NO_TAG)
+						return NULL;
+					soap->error = SOAP_OK;
+					break;
+				}
+			}
+		}
+		else
+		{	soap_new_block(soap);
+			for (a->__size = 0; ; a->__size++)
+			{	p = (gapi1__DirectoryCategory **)soap_push_block(soap, sizeof(gapi1__DirectoryCategory *));
+				if (!p)
+					return NULL;
+				*p = NULL;
+				if (!soap_in_PointerTogapi1__DirectoryCategory(soap, NULL, p, "gapi1:DirectoryCategory"))
+				{	if (soap->error != SOAP_NO_TAG)
+						return NULL;
+					soap->error = SOAP_OK;
+					break;
+				}
+			}
+			soap_pop_block(soap);
+			a->__ptr = (gapi1__DirectoryCategory **)soap_malloc(soap, soap->blist->size);
+			soap_save_block(soap, (char*)a->__ptr, 1);
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (gapi1DirectoryCategoryArray *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_gapi1DirectoryCategoryArray, 0, sizeof(gapi1DirectoryCategoryArray), 0, soap_copy_gapi1DirectoryCategoryArray);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 gapi1DirectoryCategoryArray * SOAP_FMAC6 soap_new_gapi1DirectoryCategoryArray(struct soap *soap, int n)
+{	return soap_instantiate_gapi1DirectoryCategoryArray(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1DirectoryCategoryArray(struct soap *soap, gapi1DirectoryCategoryArray *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_instantiate_gapi1DirectoryCategoryArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1DirectoryCategoryArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1DirectoryCategoryArray, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new gapi1DirectoryCategoryArray;
+		if (size)
+			*size = sizeof(gapi1DirectoryCategoryArray);
+		((gapi1DirectoryCategoryArray*)cp->ptr)->soap = soap;
+	}
+	else
+	{	cp->ptr = (void*)new gapi1DirectoryCategoryArray[n];
+		if (size)
+			*size = n * sizeof(gapi1DirectoryCategoryArray);
+		for (int i = 0; i < n; i++)
+			((gapi1DirectoryCategoryArray*)cp->ptr)[i].soap = soap;
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (gapi1DirectoryCategoryArray*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1DirectoryCategoryArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gapi1DirectoryCategoryArray %p -> %p\n", q, p));
+	*(gapi1DirectoryCategoryArray*)p = *(gapi1DirectoryCategoryArray*)q;
+}
+
+void gapi1ResultElementArray::soap_serialize(struct soap *soap) const
+{
+	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_gapi1ResultElementArray))
+		for (int i = 0; i < this->__size; i++)
+		{
+			soap_serialize_PointerTogapi1__ResultElement(soap, this->__ptr + i);
+		}
+}
+
+void gapi1ResultElementArray::soap_default(struct soap *soap)
+{
+	this->soap = soap;
+	this->__size = 0;
+	this->__ptr = NULL;
+}
+
+int gapi1ResultElementArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
+{
+	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_gapi1ResultElementArray);
+	if (this->soap_out(soap, tag, id, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+int gapi1ResultElementArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
+{	return soap_out_gapi1ResultElementArray(soap, tag, id, this, type);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1ResultElementArray(struct soap *soap, const char *tag, int id, const gapi1ResultElementArray *a, const char *type)
+{
+	int i, n = a->__size;
+	char *t = soap_putsize(soap, "gapi1:ResultElement", a->__size);
+	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_gapi1ResultElementArray);
+	if (id < 0)
+		return soap->error;
+	soap_array_begin_out(soap, tag, id, t, NULL);
+	for (i = 0; i < n; i++)
+	{
+		soap->position = 1;
+		soap->positions[0] = i;
+		soap_out_PointerTogapi1__ResultElement(soap, "item", -1, &a->__ptr[i], "");
+	}
+	soap->position = 0;
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+void *gapi1ResultElementArray::soap_get(struct soap *soap, const char *tag, const char *type)
+{
+	return soap_get_gapi1ResultElementArray(soap, this, tag, type);
+}
+
+SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_get_gapi1ResultElementArray(struct soap *soap, gapi1ResultElementArray *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1ResultElementArray(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+void *gapi1ResultElementArray::soap_in(struct soap *soap, const char *tag, const char *type)
+{	return soap_in_gapi1ResultElementArray(soap, tag, this, type);
+}
+
+SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_in_gapi1ResultElementArray(struct soap *soap, const char *tag, gapi1ResultElementArray *a, const char *type)
+{	int i, j;
+	gapi1__ResultElement **p;
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (soap_match_array(soap, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (gapi1ResultElementArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gapi1ResultElementArray, sizeof(gapi1ResultElementArray), soap->type, soap->arrayType);
+	if (!a)
+		return NULL;
+	if (soap->alloced)
+		a->soap_default(soap);
+	if (soap->body && !*soap->href)
+	{
+		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
+		if (a->__size >= 0)
+		{	a->__ptr = (gapi1__ResultElement **)soap_malloc(soap, sizeof(gapi1__ResultElement *) * a->__size);
+			for (i = 0; i < a->__size; i++)
+				a->__ptr[i] = NULL;
+			for (i = 0; i < a->__size; i++)
+			{	soap_peek_element(soap);
+				if (soap->position)
+				{	i = soap->positions[0]-j;
+					if (i < 0 || i >= a->__size)
+					{	soap->error = SOAP_IOB;
+						return NULL;
+					}
+				}
+				if (!soap_in_PointerTogapi1__ResultElement(soap, NULL, a->__ptr + i, "gapi1:ResultElement"))
+				{	if (soap->error != SOAP_NO_TAG)
+						return NULL;
+					soap->error = SOAP_OK;
+					break;
+				}
+			}
+		}
+		else
+		{	soap_new_block(soap);
+			for (a->__size = 0; ; a->__size++)
+			{	p = (gapi1__ResultElement **)soap_push_block(soap, sizeof(gapi1__ResultElement *));
+				if (!p)
+					return NULL;
+				*p = NULL;
+				if (!soap_in_PointerTogapi1__ResultElement(soap, NULL, p, "gapi1:ResultElement"))
+				{	if (soap->error != SOAP_NO_TAG)
+						return NULL;
+					soap->error = SOAP_OK;
+					break;
+				}
+			}
+			soap_pop_block(soap);
+			a->__ptr = (gapi1__ResultElement **)soap_malloc(soap, soap->blist->size);
+			soap_save_block(soap, (char*)a->__ptr, 1);
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (gapi1ResultElementArray *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_gapi1ResultElementArray, 0, sizeof(gapi1ResultElementArray), 0, soap_copy_gapi1ResultElementArray);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 gapi1ResultElementArray * SOAP_FMAC6 soap_new_gapi1ResultElementArray(struct soap *soap, int n)
+{	return soap_instantiate_gapi1ResultElementArray(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1ResultElementArray(struct soap *soap, gapi1ResultElementArray *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_instantiate_gapi1ResultElementArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1ResultElementArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1ResultElementArray, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new gapi1ResultElementArray;
+		if (size)
+			*size = sizeof(gapi1ResultElementArray);
+		((gapi1ResultElementArray*)cp->ptr)->soap = soap;
+	}
+	else
+	{	cp->ptr = (void*)new gapi1ResultElementArray[n];
+		if (size)
+			*size = n * sizeof(gapi1ResultElementArray);
+		for (int i = 0; i < n; i++)
+			((gapi1ResultElementArray*)cp->ptr)[i].soap = soap;
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (gapi1ResultElementArray*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1ResultElementArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gapi1ResultElementArray %p -> %p\n", q, p));
+	*(gapi1ResultElementArray*)p = *(gapi1ResultElementArray*)q;
+}
+
+void gapi1__ResultElement::soap_serialize(struct soap *soap) const
+{
+	(void)soap; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &((gapi1__ResultElement*)this)->summary);
+	soap_serialize_std__string(soap, &((gapi1__ResultElement*)this)->URL);
+	soap_serialize_std__string(soap, &((gapi1__ResultElement*)this)->snippet);
+	soap_serialize_std__string(soap, &((gapi1__ResultElement*)this)->title);
+	soap_serialize_std__string(soap, &((gapi1__ResultElement*)this)->cachedSize);
+	soap_serialize_std__string(soap, &((gapi1__ResultElement*)this)->hostName);
+	soap_serialize_PointerTogapi1__DirectoryCategory(soap, &((gapi1__ResultElement*)this)->directoryCategory);
+	soap_serialize_std__string(soap, &((gapi1__ResultElement*)this)->directoryTitle);
+	/* transient soap skipped */
+}
+
+void gapi1__ResultElement::soap_default(struct soap *soap)
+{
+	this->soap = soap;
+	soap_default_std__string(soap, &((gapi1__ResultElement*)this)->summary);
+	soap_default_std__string(soap, &((gapi1__ResultElement*)this)->URL);
+	soap_default_std__string(soap, &((gapi1__ResultElement*)this)->snippet);
+	soap_default_std__string(soap, &((gapi1__ResultElement*)this)->title);
+	soap_default_std__string(soap, &((gapi1__ResultElement*)this)->cachedSize);
+	soap_default_bool(soap, &((gapi1__ResultElement*)this)->relatedInformationPresent);
+	soap_default_std__string(soap, &((gapi1__ResultElement*)this)->hostName);
+	((gapi1__ResultElement*)this)->directoryCategory = NULL;
+	soap_default_std__string(soap, &((gapi1__ResultElement*)this)->directoryTitle);
+	/* transient soap skipped */
+}
+
+int gapi1__ResultElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
+{
+	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gapi1__ResultElement);
+	if (this->soap_out(soap, tag, id, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+int gapi1__ResultElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
+{
+	return soap_out_gapi1__ResultElement(soap, tag, id, this, type);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__ResultElement(struct soap *soap, const char *tag, int id, const gapi1__ResultElement *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__ResultElement), type);
+	soap_out_std__string(soap, "summary", -1, &(((gapi1__ResultElement*)a)->summary), "");
+	soap_out_std__string(soap, "URL", -1, &(((gapi1__ResultElement*)a)->URL), "");
+	soap_out_std__string(soap, "snippet", -1, &(((gapi1__ResultElement*)a)->snippet), "");
+	soap_out_std__string(soap, "title", -1, &(((gapi1__ResultElement*)a)->title), "");
+	soap_out_std__string(soap, "cachedSize", -1, &(((gapi1__ResultElement*)a)->cachedSize), "");
+	soap_out_bool(soap, "relatedInformationPresent", -1, &(((gapi1__ResultElement*)a)->relatedInformationPresent), "");
+	soap_out_std__string(soap, "hostName", -1, &(((gapi1__ResultElement*)a)->hostName), "");
+	soap_out_PointerTogapi1__DirectoryCategory(soap, "directoryCategory", -1, &(((gapi1__ResultElement*)a)->directoryCategory), "");
+	soap_out_std__string(soap, "directoryTitle", -1, &(((gapi1__ResultElement*)a)->directoryTitle), "");
+	/* transient soap skipped */
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+void *gapi1__ResultElement::soap_get(struct soap *soap, const char *tag, const char *type)
+{
+	return soap_get_gapi1__ResultElement(soap, this, tag, type);
+}
+
+SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_get_gapi1__ResultElement(struct soap *soap, gapi1__ResultElement *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__ResultElement(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+void *gapi1__ResultElement::soap_in(struct soap *soap, const char *tag, const char *type)
+{	return soap_in_gapi1__ResultElement(soap, tag, this, type);
+}
+
+SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_in_gapi1__ResultElement(struct soap *soap, const char *tag, gapi1__ResultElement *a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	a = (gapi1__ResultElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gapi1__ResultElement, sizeof(gapi1__ResultElement), soap->type, soap->arrayType);
+	if (!a)
+		return NULL;
+	if (soap->alloced)
+	{	a->soap_default(soap);
+		if (soap->clist->type != SOAP_TYPE_gapi1__ResultElement)
+		{	soap_revert(soap);
+			*soap->id = '\0';
+			return (gapi1__ResultElement *)a->soap_in(soap, tag, type);
+		}
+	}
+	short soap_flag_summary1 = 1, soap_flag_URL1 = 1, soap_flag_snippet1 = 1, soap_flag_title1 = 1, soap_flag_cachedSize1 = 1, soap_flag_relatedInformationPresent1 = 1, soap_flag_hostName1 = 1, soap_flag_directoryCategory1 = 1, soap_flag_directoryTitle1 = 1;
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+			if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "summary", &(((gapi1__ResultElement*)a)->summary), "xsd:string"))
+				{	soap_flag_summary1--;
+					continue;
+				}
+			if (soap_flag_URL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "URL", &(((gapi1__ResultElement*)a)->URL), "xsd:string"))
+				{	soap_flag_URL1--;
+					continue;
+				}
+			if (soap_flag_snippet1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "snippet", &(((gapi1__ResultElement*)a)->snippet), "xsd:string"))
+				{	soap_flag_snippet1--;
+					continue;
+				}
+			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "title", &(((gapi1__ResultElement*)a)->title), "xsd:string"))
+				{	soap_flag_title1--;
+					continue;
+				}
+			if (soap_flag_cachedSize1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "cachedSize", &(((gapi1__ResultElement*)a)->cachedSize), "xsd:string"))
+				{	soap_flag_cachedSize1--;
+					continue;
+				}
+			if (soap_flag_relatedInformationPresent1 && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_bool(soap, "relatedInformationPresent", &(((gapi1__ResultElement*)a)->relatedInformationPresent), "xsd:boolean"))
+				{	soap_flag_relatedInformationPresent1--;
+					continue;
+				}
+			if (soap_flag_hostName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "hostName", &(((gapi1__ResultElement*)a)->hostName), "xsd:string"))
+				{	soap_flag_hostName1--;
+					continue;
+				}
+			if (soap_flag_directoryCategory1 && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerTogapi1__DirectoryCategory(soap, "directoryCategory", &(((gapi1__ResultElement*)a)->directoryCategory), "gapi1:DirectoryCategory"))
+				{	soap_flag_directoryCategory1--;
+					continue;
+				}
+			if (soap_flag_directoryTitle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "directoryTitle", &(((gapi1__ResultElement*)a)->directoryTitle), "xsd:string"))
+				{	soap_flag_directoryTitle1--;
+					continue;
+				}
+			/* transient soap skipped */
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_summary1 > 0 || soap_flag_URL1 > 0 || soap_flag_snippet1 > 0 || soap_flag_title1 > 0 || soap_flag_cachedSize1 > 0 || soap_flag_relatedInformationPresent1 > 0 || soap_flag_hostName1 > 0 || soap_flag_directoryCategory1 > 0 || soap_flag_directoryTitle1 > 0))
+		{	soap->error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__ResultElement *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_gapi1__ResultElement, 0, sizeof(gapi1__ResultElement), 0, soap_copy_gapi1__ResultElement);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 gapi1__ResultElement * SOAP_FMAC6 soap_new_gapi1__ResultElement(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__ResultElement(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__ResultElement(struct soap *soap, gapi1__ResultElement *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_instantiate_gapi1__ResultElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__ResultElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__ResultElement, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new gapi1__ResultElement;
+		if (size)
+			*size = sizeof(gapi1__ResultElement);
+		((gapi1__ResultElement*)cp->ptr)->soap = soap;
+	}
+	else
+	{	cp->ptr = (void*)new gapi1__ResultElement[n];
+		if (size)
+			*size = n * sizeof(gapi1__ResultElement);
+		for (int i = 0; i < n; i++)
+			((gapi1__ResultElement*)cp->ptr)[i].soap = soap;
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (gapi1__ResultElement*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__ResultElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gapi1__ResultElement %p -> %p\n", q, p));
+	*(gapi1__ResultElement*)p = *(gapi1__ResultElement*)q;
+}
+
+void gapi1__GoogleSearchResult::soap_serialize(struct soap *soap) const
+{
+	(void)soap; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &((gapi1__GoogleSearchResult*)this)->searchComments);
+	soap_serialize_PointerTogapi1ResultElementArray(soap, &((gapi1__GoogleSearchResult*)this)->resultElements);
+	soap_serialize_std__string(soap, &((gapi1__GoogleSearchResult*)this)->searchQuery);
+	soap_serialize_std__string(soap, &((gapi1__GoogleSearchResult*)this)->searchTips);
+	soap_serialize_PointerTogapi1DirectoryCategoryArray(soap, &((gapi1__GoogleSearchResult*)this)->directoryCategories);
+	/* transient soap skipped */
+}
+
+void gapi1__GoogleSearchResult::soap_default(struct soap *soap)
+{
+	this->soap = soap;
+	soap_default_bool(soap, &((gapi1__GoogleSearchResult*)this)->documentFiltering);
+	soap_default_std__string(soap, &((gapi1__GoogleSearchResult*)this)->searchComments);
+	soap_default_int(soap, &((gapi1__GoogleSearchResult*)this)->estimatedTotalResultsCount);
+	soap_default_bool(soap, &((gapi1__GoogleSearchResult*)this)->estimateIsExact);
+	((gapi1__GoogleSearchResult*)this)->resultElements = NULL;
+	soap_default_std__string(soap, &((gapi1__GoogleSearchResult*)this)->searchQuery);
+	soap_default_int(soap, &((gapi1__GoogleSearchResult*)this)->startIndex);
+	soap_default_int(soap, &((gapi1__GoogleSearchResult*)this)->endIndex);
+	soap_default_std__string(soap, &((gapi1__GoogleSearchResult*)this)->searchTips);
+	((gapi1__GoogleSearchResult*)this)->directoryCategories = NULL;
+	soap_default_double(soap, &((gapi1__GoogleSearchResult*)this)->searchTime);
+	/* transient soap skipped */
+}
+
+int gapi1__GoogleSearchResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
+{
+	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gapi1__GoogleSearchResult);
+	if (this->soap_out(soap, tag, id, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+int gapi1__GoogleSearchResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
+{
+	return soap_out_gapi1__GoogleSearchResult(soap, tag, id, this, type);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__GoogleSearchResult(struct soap *soap, const char *tag, int id, const gapi1__GoogleSearchResult *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__GoogleSearchResult), type);
+	soap_out_bool(soap, "documentFiltering", -1, &(((gapi1__GoogleSearchResult*)a)->documentFiltering), "");
+	soap_out_std__string(soap, "searchComments", -1, &(((gapi1__GoogleSearchResult*)a)->searchComments), "");
+	soap_out_int(soap, "estimatedTotalResultsCount", -1, &(((gapi1__GoogleSearchResult*)a)->estimatedTotalResultsCount), "");
+	soap_out_bool(soap, "estimateIsExact", -1, &(((gapi1__GoogleSearchResult*)a)->estimateIsExact), "");
+	soap_out_PointerTogapi1ResultElementArray(soap, "resultElements", -1, &(((gapi1__GoogleSearchResult*)a)->resultElements), "");
+	soap_out_std__string(soap, "searchQuery", -1, &(((gapi1__GoogleSearchResult*)a)->searchQuery), "");
+	soap_out_int(soap, "startIndex", -1, &(((gapi1__GoogleSearchResult*)a)->startIndex), "");
+	soap_out_int(soap, "endIndex", -1, &(((gapi1__GoogleSearchResult*)a)->endIndex), "");
+	soap_out_std__string(soap, "searchTips", -1, &(((gapi1__GoogleSearchResult*)a)->searchTips), "");
+	soap_out_PointerTogapi1DirectoryCategoryArray(soap, "directoryCategories", -1, &(((gapi1__GoogleSearchResult*)a)->directoryCategories), "");
+	soap_out_double(soap, "searchTime", -1, &(((gapi1__GoogleSearchResult*)a)->searchTime), "");
+	/* transient soap skipped */
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+void *gapi1__GoogleSearchResult::soap_get(struct soap *soap, const char *tag, const char *type)
+{
+	return soap_get_gapi1__GoogleSearchResult(soap, this, tag, type);
+}
+
+SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_get_gapi1__GoogleSearchResult(struct soap *soap, gapi1__GoogleSearchResult *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__GoogleSearchResult(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+void *gapi1__GoogleSearchResult::soap_in(struct soap *soap, const char *tag, const char *type)
+{	return soap_in_gapi1__GoogleSearchResult(soap, tag, this, type);
+}
+
+SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_in_gapi1__GoogleSearchResult(struct soap *soap, const char *tag, gapi1__GoogleSearchResult *a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	a = (gapi1__GoogleSearchResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gapi1__GoogleSearchResult, sizeof(gapi1__GoogleSearchResult), soap->type, soap->arrayType);
+	if (!a)
+		return NULL;
+	if (soap->alloced)
+	{	a->soap_default(soap);
+		if (soap->clist->type != SOAP_TYPE_gapi1__GoogleSearchResult)
+		{	soap_revert(soap);
+			*soap->id = '\0';
+			return (gapi1__GoogleSearchResult *)a->soap_in(soap, tag, type);
+		}
+	}
+	short soap_flag_documentFiltering1 = 1, soap_flag_searchComments1 = 1, soap_flag_estimatedTotalResultsCount1 = 1, soap_flag_estimateIsExact1 = 1, soap_flag_resultElements1 = 1, soap_flag_searchQuery1 = 1, soap_flag_startIndex1 = 1, soap_flag_endIndex1 = 1, soap_flag_searchTips1 = 1, soap_flag_directoryCategories1 = 1, soap_flag_searchTime1 = 1;
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+			if (soap_flag_documentFiltering1 && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_bool(soap, "documentFiltering", &(((gapi1__GoogleSearchResult*)a)->documentFiltering), "xsd:boolean"))
+				{	soap_flag_documentFiltering1--;
+					continue;
+				}
+			if (soap_flag_searchComments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "searchComments", &(((gapi1__GoogleSearchResult*)a)->searchComments), "xsd:string"))
+				{	soap_flag_searchComments1--;
+					continue;
+				}
+			if (soap_flag_estimatedTotalResultsCount1 && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_int(soap, "estimatedTotalResultsCount", &(((gapi1__GoogleSearchResult*)a)->estimatedTotalResultsCount), "xsd:int"))
+				{	soap_flag_estimatedTotalResultsCount1--;
+					continue;
+				}
+			if (soap_flag_estimateIsExact1 && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_bool(soap, "estimateIsExact", &(((gapi1__GoogleSearchResult*)a)->estimateIsExact), "xsd:boolean"))
+				{	soap_flag_estimateIsExact1--;
+					continue;
+				}
+			if (soap_flag_resultElements1 && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerTogapi1ResultElementArray(soap, "resultElements", &(((gapi1__GoogleSearchResult*)a)->resultElements), "gapi1:ResultElement"))
+				{	soap_flag_resultElements1--;
+					continue;
+				}
+			if (soap_flag_searchQuery1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "searchQuery", &(((gapi1__GoogleSearchResult*)a)->searchQuery), "xsd:string"))
+				{	soap_flag_searchQuery1--;
+					continue;
+				}
+			if (soap_flag_startIndex1 && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_int(soap, "startIndex", &(((gapi1__GoogleSearchResult*)a)->startIndex), "xsd:int"))
+				{	soap_flag_startIndex1--;
+					continue;
+				}
+			if (soap_flag_endIndex1 && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_int(soap, "endIndex", &(((gapi1__GoogleSearchResult*)a)->endIndex), "xsd:int"))
+				{	soap_flag_endIndex1--;
+					continue;
+				}
+			if (soap_flag_searchTips1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "searchTips", &(((gapi1__GoogleSearchResult*)a)->searchTips), "xsd:string"))
+				{	soap_flag_searchTips1--;
+					continue;
+				}
+			if (soap_flag_directoryCategories1 && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerTogapi1DirectoryCategoryArray(soap, "directoryCategories", &(((gapi1__GoogleSearchResult*)a)->directoryCategories), "gapi1:DirectoryCategory"))
+				{	soap_flag_directoryCategories1--;
+					continue;
+				}
+			if (soap_flag_searchTime1 && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_double(soap, "searchTime", &(((gapi1__GoogleSearchResult*)a)->searchTime), "xsd:double"))
+				{	soap_flag_searchTime1--;
+					continue;
+				}
+			/* transient soap skipped */
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_documentFiltering1 > 0 || soap_flag_searchComments1 > 0 || soap_flag_estimatedTotalResultsCount1 > 0 || soap_flag_estimateIsExact1 > 0 || soap_flag_resultElements1 > 0 || soap_flag_searchQuery1 > 0 || soap_flag_startIndex1 > 0 || soap_flag_endIndex1 > 0 || soap_flag_searchTips1 > 0 || soap_flag_directoryCategories1 > 0 || soap_flag_searchTime1 > 0))
+		{	soap->error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__GoogleSearchResult *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_gapi1__GoogleSearchResult, 0, sizeof(gapi1__GoogleSearchResult), 0, soap_copy_gapi1__GoogleSearchResult);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 gapi1__GoogleSearchResult * SOAP_FMAC6 soap_new_gapi1__GoogleSearchResult(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__GoogleSearchResult(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__GoogleSearchResult(struct soap *soap, gapi1__GoogleSearchResult *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_instantiate_gapi1__GoogleSearchResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__GoogleSearchResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__GoogleSearchResult, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new gapi1__GoogleSearchResult;
+		if (size)
+			*size = sizeof(gapi1__GoogleSearchResult);
+		((gapi1__GoogleSearchResult*)cp->ptr)->soap = soap;
+	}
+	else
+	{	cp->ptr = (void*)new gapi1__GoogleSearchResult[n];
+		if (size)
+			*size = n * sizeof(gapi1__GoogleSearchResult);
+		for (int i = 0; i < n; i++)
+			((gapi1__GoogleSearchResult*)cp->ptr)[i].soap = soap;
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (gapi1__GoogleSearchResult*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__GoogleSearchResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gapi1__GoogleSearchResult %p -> %p\n", q, p));
+	*(gapi1__GoogleSearchResult*)p = *(gapi1__GoogleSearchResult*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__SOAP_ENC__arrayType(struct soap *soap, std::string const*a)
+{	soap_serialize_std__string(soap, a);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default__SOAP_ENC__arrayType(struct soap *soap, std::string *a)
+{	soap_default_std__string(soap, a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put__SOAP_ENC__arrayType(struct soap *soap, const std::string *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__SOAP_ENC__arrayType);
+	if (soap_out__SOAP_ENC__arrayType(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+SOAP_FMAC3 int SOAP_FMAC4 soap_out__SOAP_ENC__arrayType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
+{
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE__SOAP_ENC__arrayType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
+		return soap->error;
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get__SOAP_ENC__arrayType(struct soap *soap, std::string *p, const char *tag, const char *type)
+{
+	if ((p = soap_in__SOAP_ENC__arrayType(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in__SOAP_ENC__arrayType(struct soap *soap, const char *tag, std::string *s, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!s)
+		s = soap_new_std__string(soap, -1);
+	if (soap->null)
+		if (s)
+			s->erase();
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	if (soap->body && !*soap->href)
+	{	char *t;
+		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE__SOAP_ENC__arrayType, sizeof(std::string), soap->type, soap->arrayType);
+		if (s)
+			if ((t = soap_string_in(soap, 1, -1, -1)))
+				s->assign(t);
+			else
+				return NULL;
+	}
+	else
+		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE__SOAP_ENC__arrayType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE__SOAP_ENC__arrayType, 0, sizeof(std::string), 0, soap_copy__SOAP_ENC__arrayType);
+	if (soap->body && soap_element_end_in(soap, tag))
+		return NULL;
+	return s;
+}
+
+SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new__SOAP_ENC__arrayType(struct soap *soap, int n)
+{	return soap_instantiate__SOAP_ENC__arrayType(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete__SOAP_ENC__arrayType(struct soap *soap, std::string *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate__SOAP_ENC__arrayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__SOAP_ENC__arrayType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__SOAP_ENC__arrayType, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new std::string;
+		if (size)
+			*size = sizeof(std::string);
+	}
+	else
+	{	cp->ptr = (void*)new std::string[n];
+		if (size)
+			*size = n * sizeof(std::string);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (std::string*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy__SOAP_ENC__arrayType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
+	*(std::string*)p = *(std::string*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
+{	(void)soap; (void)p; /* appease -Wall -Werror */
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
+{	(void)soap; /* appease -Wall -Werror */
+	p->erase();
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
+	if (soap_out_std__string(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
+{
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
+		return soap->error;
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_std__string(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!s)
+		s = soap_new_std__string(soap, -1);
+	if (soap->null)
+		if (s)
+			s->erase();
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	if (soap->body && !*soap->href)
+	{	char *t;
+		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
+		if (s)
+			if ((t = soap_string_in(soap, 1, -1, -1)))
+				s->assign(t);
+			else
+				return NULL;
+	}
+	else
+		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
+	if (soap->body && soap_element_end_in(soap, tag))
+		return NULL;
+	return s;
+}
+
+SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
+{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new std::string;
+		if (size)
+			*size = sizeof(std::string);
+	}
+	else
+	{	cp->ptr = (void*)new std::string[n];
+		if (size)
+			*size = n * sizeof(std::string);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (std::string*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
+	*(std::string*)p = *(std::string*)q;
+}
+
+void xsd__base64Binary::soap_serialize(struct soap *soap) const
+{
+	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
+		if (this->id || this->type)
+			soap->mode |= SOAP_ENC_DIME;
+}
+
+void xsd__base64Binary::soap_default(struct soap *soap)
+{
+	this->soap = soap;
+	this->__size = 0;
+	this->__ptr = NULL;
+	this->id = NULL;
+	this->type = NULL;
+	this->options = NULL;
+}
+
+int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
+{
+	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
+	if (this->soap_out(soap, tag, id, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
+{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
+{
+	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
+	if (id < 0)
+		return soap->error;
+	soap_element_begin_out(soap, tag, id, type);
+	soap_putbase64(soap, a->__ptr, a->__size);
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
+{
+	return soap_get_xsd__base64Binary(soap, this, tag, type);
+}
+
+SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
+{	return soap_in_xsd__base64Binary(soap, tag, this, type);
+}
+
+SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
+	if (!a)
+		return NULL;
+	if (soap->alloced)
+		a->soap_default(soap);
+	if (soap->body && !*soap->href)
+	{
+		a->__ptr = soap_getbase64(soap, &a->__size, 0);
+		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
+			return NULL;
+		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	if (*soap->href != '#')
+		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
+				return NULL;
+		}
+		else
+			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_new_xsd__base64Binary(struct soap *soap, int n)
+{	return soap_instantiate_xsd__base64Binary(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new xsd__base64Binary;
+		if (size)
+			*size = sizeof(xsd__base64Binary);
+		((xsd__base64Binary*)cp->ptr)->soap = soap;
+	}
+	else
+	{	cp->ptr = (void*)new xsd__base64Binary[n];
+		if (size)
+			*size = n * sizeof(xsd__base64Binary);
+		for (int i = 0; i < n; i++)
+			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (xsd__base64Binary*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
+	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
+}
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize__QName(soap, &a->faultcode);
+	soap_serialize_string(soap, &a->faultstring);
+	soap_serialize_string(soap, &a->faultactor);
+	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
+	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
+	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
+	soap_serialize_string(soap, &a->SOAP_ENV__Node);
+	soap_serialize_string(soap, &a->SOAP_ENV__Role);
+	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default__QName(soap, &a->faultcode);
+	soap_default_string(soap, &a->faultstring);
+	soap_default_string(soap, &a->faultactor);
+	a->detail = NULL;
+	a->SOAP_ENV__Code = NULL;
+	a->SOAP_ENV__Reason = NULL;
+	soap_default_string(soap, &a->SOAP_ENV__Node);
+	soap_default_string(soap, &a->SOAP_ENV__Role);
+	a->SOAP_ENV__Detail = NULL;
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
+	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
+{
+	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
+	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
+	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
+	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
+	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
+	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
+	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
+	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
+	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
+	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
+{
+	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	soap_default_SOAP_ENV__Fault(soap, a);
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
+				{	soap_flag_faultcode--;
+					continue;
+				}
+			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
+				{	soap_flag_faultstring--;
+					continue;
+				}
+			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
+				{	soap_flag_faultactor--;
+					continue;
+				}
+			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
+				{	soap_flag_detail--;
+					continue;
+				}
+			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
+				{	soap_flag_SOAP_ENV__Code--;
+					continue;
+				}
+			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
+				{	soap_flag_SOAP_ENV__Reason--;
+					continue;
+				}
+			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
+				{	soap_flag_SOAP_ENV__Node--;
+					continue;
+				}
+			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
+				{	soap_flag_SOAP_ENV__Role--;
+					continue;
+				}
+			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
+				{	soap_flag_SOAP_ENV__Detail--;
+					continue;
+				}
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
+{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
+		if (size)
+			*size = sizeof(struct SOAP_ENV__Fault);
+	}
+	else
+	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
+		if (size)
+			*size = n * sizeof(struct SOAP_ENV__Fault);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (struct SOAP_ENV__Fault*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
+	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
+}
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize_string(soap, &a->SOAP_ENV__Text);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default_string(soap, &a->SOAP_ENV__Text);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
+	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
+	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
+{
+	short soap_flag_SOAP_ENV__Text = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	soap_default_SOAP_ENV__Reason(soap, a);
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
+				{	soap_flag_SOAP_ENV__Text--;
+					continue;
+				}
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
+{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
+		if (size)
+			*size = sizeof(struct SOAP_ENV__Reason);
+	}
+	else
+	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
+		if (size)
+			*size = n * sizeof(struct SOAP_ENV__Reason);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (struct SOAP_ENV__Reason*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
+	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
+}
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_markelement(soap, a->fault, a->__type);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	a->__type = 0;
+	a->fault = NULL;
+	a->__any = NULL;
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
+	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
+	soap_putelement(soap, a->fault, "fault", -1, a->__type);
+	soap_outliteral(soap, "-any", &a->__any);
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
+{
+	short soap_flag_fault = 1, soap_flag___any = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	soap_default_SOAP_ENV__Detail(soap, a);
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
+				if ((a->fault = soap_getelement(soap, &a->__type)))
+				{	soap_flag_fault = 0;
+					continue;
+				}
+			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_inliteral(soap, "-any", &a->__any))
+				{	soap_flag___any--;
+					continue;
+				}
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
+{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
+		if (size)
+			*size = sizeof(struct SOAP_ENV__Detail);
+	}
+	else
+	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
+		if (size)
+			*size = n * sizeof(struct SOAP_ENV__Detail);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (struct SOAP_ENV__Detail*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
+	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
+}
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
+	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default__QName(soap, &a->SOAP_ENV__Value);
+	a->SOAP_ENV__Subcode = NULL;
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
+	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
+{
+	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
+	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
+	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
+{
+	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	soap_default_SOAP_ENV__Code(soap, a);
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
+				{	soap_flag_SOAP_ENV__Value--;
+					continue;
+				}
+			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
+				{	soap_flag_SOAP_ENV__Subcode--;
+					continue;
+				}
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
+{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
+		if (size)
+			*size = sizeof(struct SOAP_ENV__Code);
+	}
+	else
+	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
+		if (size)
+			*size = n * sizeof(struct SOAP_ENV__Code);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (struct SOAP_ENV__Code*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
+	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
+}
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	/* transient dummy skipped */
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	/* transient dummy skipped */
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
+	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
+	/* transient dummy skipped */
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
+{;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	soap_default_SOAP_ENV__Header(soap, a);
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+		/* transient dummy skipped */
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
+{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
+		if (size)
+			*size = sizeof(struct SOAP_ENV__Header);
+	}
+	else
+	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
+		if (size)
+			*size = n * sizeof(struct SOAP_ENV__Header);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (struct SOAP_ENV__Header*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
+	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
+}
+
+#endif
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGoogleSearch(struct soap *soap, const struct gapi1__doGoogleSearch *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &a->key);
+	soap_serialize_std__string(soap, &a->q);
+	soap_serialize_std__string(soap, &a->restrict_);
+	soap_serialize_std__string(soap, &a->lr);
+	soap_serialize_std__string(soap, &a->ie);
+	soap_serialize_std__string(soap, &a->oe);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGoogleSearch(struct soap *soap, struct gapi1__doGoogleSearch *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default_std__string(soap, &a->key);
+	soap_default_std__string(soap, &a->q);
+	soap_default_int(soap, &a->start);
+	soap_default_int(soap, &a->maxResults);
+	soap_default_bool(soap, &a->filter);
+	soap_default_std__string(soap, &a->restrict_);
+	soap_default_bool(soap, &a->safeSearch);
+	soap_default_std__string(soap, &a->lr);
+	soap_default_std__string(soap, &a->ie);
+	soap_default_std__string(soap, &a->oe);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGoogleSearch(struct soap *soap, const struct gapi1__doGoogleSearch *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_gapi1__doGoogleSearch);
+	if (soap_out_gapi1__doGoogleSearch(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGoogleSearch(struct soap *soap, const char *tag, int id, const struct gapi1__doGoogleSearch *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGoogleSearch), type);
+	soap_out_std__string(soap, "key", -1, &a->key, "");
+	soap_out_std__string(soap, "q", -1, &a->q, "");
+	soap_out_int(soap, "start", -1, &a->start, "");
+	soap_out_int(soap, "maxResults", -1, &a->maxResults, "");
+	soap_out_bool(soap, "filter", -1, &a->filter, "");
+	soap_out_std__string(soap, "restrict", -1, &a->restrict_, "");
+	soap_out_bool(soap, "safeSearch", -1, &a->safeSearch, "");
+	soap_out_std__string(soap, "lr", -1, &a->lr, "");
+	soap_out_std__string(soap, "ie", -1, &a->ie, "");
+	soap_out_std__string(soap, "oe", -1, &a->oe, "");
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_get_gapi1__doGoogleSearch(struct soap *soap, struct gapi1__doGoogleSearch *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__doGoogleSearch(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_in_gapi1__doGoogleSearch(struct soap *soap, const char *tag, struct gapi1__doGoogleSearch *a, const char *type)
+{
+	short soap_flag_key = 1, soap_flag_q = 1, soap_flag_start = 1, soap_flag_maxResults = 1, soap_flag_filter = 1, soap_flag_restrict_ = 1, soap_flag_safeSearch = 1, soap_flag_lr = 1, soap_flag_ie = 1, soap_flag_oe = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct gapi1__doGoogleSearch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gapi1__doGoogleSearch, sizeof(struct gapi1__doGoogleSearch), soap->type, soap->arrayType);
+	if (!a)
+		return NULL;
+	soap_default_gapi1__doGoogleSearch(soap, a);
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "key", &a->key, "xsd:string"))
+				{	soap_flag_key--;
+					continue;
+				}
+			if (soap_flag_q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "q", &a->q, "xsd:string"))
+				{	soap_flag_q--;
+					continue;
+				}
+			if (soap_flag_start && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_int(soap, "start", &a->start, "xsd:int"))
+				{	soap_flag_start--;
+					continue;
+				}
+			if (soap_flag_maxResults && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_int(soap, "maxResults", &a->maxResults, "xsd:int"))
+				{	soap_flag_maxResults--;
+					continue;
+				}
+			if (soap_flag_filter && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_bool(soap, "filter", &a->filter, "xsd:boolean"))
+				{	soap_flag_filter--;
+					continue;
+				}
+			if (soap_flag_restrict_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "restrict", &a->restrict_, "xsd:string"))
+				{	soap_flag_restrict_--;
+					continue;
+				}
+			if (soap_flag_safeSearch && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_bool(soap, "safeSearch", &a->safeSearch, "xsd:boolean"))
+				{	soap_flag_safeSearch--;
+					continue;
+				}
+			if (soap_flag_lr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "lr", &a->lr, "xsd:string"))
+				{	soap_flag_lr--;
+					continue;
+				}
+			if (soap_flag_ie && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "ie", &a->ie, "xsd:string"))
+				{	soap_flag_ie--;
+					continue;
+				}
+			if (soap_flag_oe && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "oe", &a->oe, "xsd:string"))
+				{	soap_flag_oe--;
+					continue;
+				}
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key > 0 || soap_flag_q > 0 || soap_flag_start > 0 || soap_flag_maxResults > 0 || soap_flag_filter > 0 || soap_flag_restrict_ > 0 || soap_flag_safeSearch > 0 || soap_flag_lr > 0 || soap_flag_ie > 0 || soap_flag_oe > 0))
+		{	soap->error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct gapi1__doGoogleSearch *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_gapi1__doGoogleSearch, 0, sizeof(struct gapi1__doGoogleSearch), 0, soap_copy_gapi1__doGoogleSearch);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct gapi1__doGoogleSearch * SOAP_FMAC6 soap_new_gapi1__doGoogleSearch(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__doGoogleSearch(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGoogleSearch(struct soap *soap, struct gapi1__doGoogleSearch *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_instantiate_gapi1__doGoogleSearch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__doGoogleSearch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doGoogleSearch, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new struct gapi1__doGoogleSearch;
+		if (size)
+			*size = sizeof(struct gapi1__doGoogleSearch);
+	}
+	else
+	{	cp->ptr = (void*)new struct gapi1__doGoogleSearch[n];
+		if (size)
+			*size = n * sizeof(struct gapi1__doGoogleSearch);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (struct gapi1__doGoogleSearch*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGoogleSearch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct gapi1__doGoogleSearch %p -> %p\n", q, p));
+	*(struct gapi1__doGoogleSearch*)p = *(struct gapi1__doGoogleSearch*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGoogleSearchResponse(struct soap *soap, const struct gapi1__doGoogleSearchResponse *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize_PointerTogapi1__GoogleSearchResult(soap, &a->return_);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGoogleSearchResponse(struct soap *soap, struct gapi1__doGoogleSearchResponse *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	a->return_ = NULL;
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGoogleSearchResponse(struct soap *soap, const struct gapi1__doGoogleSearchResponse *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_gapi1__doGoogleSearchResponse);
+	if (soap_out_gapi1__doGoogleSearchResponse(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGoogleSearchResponse(struct soap *soap, const char *tag, int id, const struct gapi1__doGoogleSearchResponse *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGoogleSearchResponse), type);
+	if (a->return_)
+		soap_element_result(soap, "return");
+	soap_out_PointerTogapi1__GoogleSearchResult(soap, "return", -1, &a->return_, "");
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_get_gapi1__doGoogleSearchResponse(struct soap *soap, struct gapi1__doGoogleSearchResponse *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__doGoogleSearchResponse(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_in_gapi1__doGoogleSearchResponse(struct soap *soap, const char *tag, struct gapi1__doGoogleSearchResponse *a, const char *type)
+{
+	short soap_flag_return_ = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct gapi1__doGoogleSearchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gapi1__doGoogleSearchResponse, sizeof(struct gapi1__doGoogleSearchResponse), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	soap_default_gapi1__doGoogleSearchResponse(soap, a);
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerTogapi1__GoogleSearchResult(soap, "return", &a->return_, "gapi1:GoogleSearchResult"))
+				{	soap_flag_return_--;
+					continue;
+				}
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct gapi1__doGoogleSearchResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_gapi1__doGoogleSearchResponse, 0, sizeof(struct gapi1__doGoogleSearchResponse), 0, NULL);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct gapi1__doGoogleSearchResponse * SOAP_FMAC6 soap_new_gapi1__doGoogleSearchResponse(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__doGoogleSearchResponse(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGoogleSearchResponse(struct soap *soap, struct gapi1__doGoogleSearchResponse *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_instantiate_gapi1__doGoogleSearchResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__doGoogleSearchResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doGoogleSearchResponse, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new struct gapi1__doGoogleSearchResponse;
+		if (size)
+			*size = sizeof(struct gapi1__doGoogleSearchResponse);
+	}
+	else
+	{	cp->ptr = (void*)new struct gapi1__doGoogleSearchResponse[n];
+		if (size)
+			*size = n * sizeof(struct gapi1__doGoogleSearchResponse);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (struct gapi1__doGoogleSearchResponse*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGoogleSearchResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct gapi1__doGoogleSearchResponse %p -> %p\n", q, p));
+	*(struct gapi1__doGoogleSearchResponse*)p = *(struct gapi1__doGoogleSearchResponse*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doSpellingSuggestion(struct soap *soap, const struct gapi1__doSpellingSuggestion *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &a->key);
+	soap_serialize_std__string(soap, &a->phrase);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doSpellingSuggestion(struct soap *soap, struct gapi1__doSpellingSuggestion *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default_std__string(soap, &a->key);
+	soap_default_std__string(soap, &a->phrase);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doSpellingSuggestion(struct soap *soap, const struct gapi1__doSpellingSuggestion *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_gapi1__doSpellingSuggestion);
+	if (soap_out_gapi1__doSpellingSuggestion(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doSpellingSuggestion(struct soap *soap, const char *tag, int id, const struct gapi1__doSpellingSuggestion *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doSpellingSuggestion), type);
+	soap_out_std__string(soap, "key", -1, &a->key, "");
+	soap_out_std__string(soap, "phrase", -1, &a->phrase, "");
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_get_gapi1__doSpellingSuggestion(struct soap *soap, struct gapi1__doSpellingSuggestion *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__doSpellingSuggestion(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_in_gapi1__doSpellingSuggestion(struct soap *soap, const char *tag, struct gapi1__doSpellingSuggestion *a, const char *type)
+{
+	short soap_flag_key = 1, soap_flag_phrase = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct gapi1__doSpellingSuggestion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gapi1__doSpellingSuggestion, sizeof(struct gapi1__doSpellingSuggestion), soap->type, soap->arrayType);
+	if (!a)
+		return NULL;
+	soap_default_gapi1__doSpellingSuggestion(soap, a);
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "key", &a->key, "xsd:string"))
+				{	soap_flag_key--;
+					continue;
+				}
+			if (soap_flag_phrase && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "phrase", &a->phrase, "xsd:string"))
+				{	soap_flag_phrase--;
+					continue;
+				}
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key > 0 || soap_flag_phrase > 0))
+		{	soap->error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct gapi1__doSpellingSuggestion *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_gapi1__doSpellingSuggestion, 0, sizeof(struct gapi1__doSpellingSuggestion), 0, soap_copy_gapi1__doSpellingSuggestion);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct gapi1__doSpellingSuggestion * SOAP_FMAC6 soap_new_gapi1__doSpellingSuggestion(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__doSpellingSuggestion(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doSpellingSuggestion(struct soap *soap, struct gapi1__doSpellingSuggestion *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_instantiate_gapi1__doSpellingSuggestion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__doSpellingSuggestion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doSpellingSuggestion, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new struct gapi1__doSpellingSuggestion;
+		if (size)
+			*size = sizeof(struct gapi1__doSpellingSuggestion);
+	}
+	else
+	{	cp->ptr = (void*)new struct gapi1__doSpellingSuggestion[n];
+		if (size)
+			*size = n * sizeof(struct gapi1__doSpellingSuggestion);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (struct gapi1__doSpellingSuggestion*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doSpellingSuggestion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct gapi1__doSpellingSuggestion %p -> %p\n", q, p));
+	*(struct gapi1__doSpellingSuggestion*)p = *(struct gapi1__doSpellingSuggestion*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doSpellingSuggestionResponse(struct soap *soap, const struct gapi1__doSpellingSuggestionResponse *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &a->return_);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doSpellingSuggestionResponse(struct soap *soap, struct gapi1__doSpellingSuggestionResponse *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default_std__string(soap, &a->return_);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doSpellingSuggestionResponse(struct soap *soap, const struct gapi1__doSpellingSuggestionResponse *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_gapi1__doSpellingSuggestionResponse);
+	if (soap_out_gapi1__doSpellingSuggestionResponse(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doSpellingSuggestionResponse(struct soap *soap, const char *tag, int id, const struct gapi1__doSpellingSuggestionResponse *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doSpellingSuggestionResponse), type);
+	soap_element_result(soap, "return");
+	soap_out_std__string(soap, "return", -1, &a->return_, "");
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_get_gapi1__doSpellingSuggestionResponse(struct soap *soap, struct gapi1__doSpellingSuggestionResponse *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__doSpellingSuggestionResponse(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_in_gapi1__doSpellingSuggestionResponse(struct soap *soap, const char *tag, struct gapi1__doSpellingSuggestionResponse *a, const char *type)
+{
+	short soap_flag_return_ = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct gapi1__doSpellingSuggestionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gapi1__doSpellingSuggestionResponse, sizeof(struct gapi1__doSpellingSuggestionResponse), soap->type, soap->arrayType);
+	if (!a)
+		return NULL;
+	soap_default_gapi1__doSpellingSuggestionResponse(soap, a);
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
+				{	soap_flag_return_--;
+					continue;
+				}
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
+		{	soap->error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct gapi1__doSpellingSuggestionResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_gapi1__doSpellingSuggestionResponse, 0, sizeof(struct gapi1__doSpellingSuggestionResponse), 0, soap_copy_gapi1__doSpellingSuggestionResponse);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC6 soap_new_gapi1__doSpellingSuggestionResponse(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__doSpellingSuggestionResponse(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doSpellingSuggestionResponse(struct soap *soap, struct gapi1__doSpellingSuggestionResponse *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_instantiate_gapi1__doSpellingSuggestionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__doSpellingSuggestionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doSpellingSuggestionResponse, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new struct gapi1__doSpellingSuggestionResponse;
+		if (size)
+			*size = sizeof(struct gapi1__doSpellingSuggestionResponse);
+	}
+	else
+	{	cp->ptr = (void*)new struct gapi1__doSpellingSuggestionResponse[n];
+		if (size)
+			*size = n * sizeof(struct gapi1__doSpellingSuggestionResponse);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (struct gapi1__doSpellingSuggestionResponse*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doSpellingSuggestionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct gapi1__doSpellingSuggestionResponse %p -> %p\n", q, p));
+	*(struct gapi1__doSpellingSuggestionResponse*)p = *(struct gapi1__doSpellingSuggestionResponse*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGetCachedPage(struct soap *soap, const struct gapi1__doGetCachedPage *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &a->key);
+	soap_serialize_std__string(soap, &a->url);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGetCachedPage(struct soap *soap, struct gapi1__doGetCachedPage *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default_std__string(soap, &a->key);
+	soap_default_std__string(soap, &a->url);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGetCachedPage(struct soap *soap, const struct gapi1__doGetCachedPage *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_gapi1__doGetCachedPage);
+	if (soap_out_gapi1__doGetCachedPage(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGetCachedPage(struct soap *soap, const char *tag, int id, const struct gapi1__doGetCachedPage *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGetCachedPage), type);
+	soap_out_std__string(soap, "key", -1, &a->key, "");
+	soap_out_std__string(soap, "url", -1, &a->url, "");
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_get_gapi1__doGetCachedPage(struct soap *soap, struct gapi1__doGetCachedPage *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__doGetCachedPage(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_in_gapi1__doGetCachedPage(struct soap *soap, const char *tag, struct gapi1__doGetCachedPage *a, const char *type)
+{
+	short soap_flag_key = 1, soap_flag_url = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct gapi1__doGetCachedPage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gapi1__doGetCachedPage, sizeof(struct gapi1__doGetCachedPage), soap->type, soap->arrayType);
+	if (!a)
+		return NULL;
+	soap_default_gapi1__doGetCachedPage(soap, a);
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "key", &a->key, "xsd:string"))
+				{	soap_flag_key--;
+					continue;
+				}
+			if (soap_flag_url && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, "url", &a->url, "xsd:string"))
+				{	soap_flag_url--;
+					continue;
+				}
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key > 0 || soap_flag_url > 0))
+		{	soap->error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct gapi1__doGetCachedPage *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_gapi1__doGetCachedPage, 0, sizeof(struct gapi1__doGetCachedPage), 0, soap_copy_gapi1__doGetCachedPage);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct gapi1__doGetCachedPage * SOAP_FMAC6 soap_new_gapi1__doGetCachedPage(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__doGetCachedPage(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGetCachedPage(struct soap *soap, struct gapi1__doGetCachedPage *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_instantiate_gapi1__doGetCachedPage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__doGetCachedPage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doGetCachedPage, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new struct gapi1__doGetCachedPage;
+		if (size)
+			*size = sizeof(struct gapi1__doGetCachedPage);
+	}
+	else
+	{	cp->ptr = (void*)new struct gapi1__doGetCachedPage[n];
+		if (size)
+			*size = n * sizeof(struct gapi1__doGetCachedPage);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (struct gapi1__doGetCachedPage*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGetCachedPage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct gapi1__doGetCachedPage %p -> %p\n", q, p));
+	*(struct gapi1__doGetCachedPage*)p = *(struct gapi1__doGetCachedPage*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGetCachedPageResponse(struct soap *soap, const struct gapi1__doGetCachedPageResponse *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	a->return_.soap_serialize(soap);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGetCachedPageResponse(struct soap *soap, struct gapi1__doGetCachedPageResponse *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	a->return_.xsd__base64Binary::soap_default(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGetCachedPageResponse(struct soap *soap, const struct gapi1__doGetCachedPageResponse *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_gapi1__doGetCachedPageResponse);
+	if (soap_out_gapi1__doGetCachedPageResponse(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGetCachedPageResponse(struct soap *soap, const char *tag, int id, const struct gapi1__doGetCachedPageResponse *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGetCachedPageResponse), type);
+	soap_element_result(soap, "return");
+	a->return_.soap_out(soap, "return", -1, "");
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_get_gapi1__doGetCachedPageResponse(struct soap *soap, struct gapi1__doGetCachedPageResponse *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__doGetCachedPageResponse(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_in_gapi1__doGetCachedPageResponse(struct soap *soap, const char *tag, struct gapi1__doGetCachedPageResponse *a, const char *type)
+{
+	short soap_flag_return_ = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap->type && soap_match_tag(soap, soap->type, type))
+	{	soap->error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct gapi1__doGetCachedPageResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gapi1__doGetCachedPageResponse, sizeof(struct gapi1__doGetCachedPageResponse), soap->type, soap->arrayType);
+	if (!a)
+		return NULL;
+	soap_default_gapi1__doGetCachedPageResponse(soap, a);
+	if (soap->body && !*soap->href)
+	{
+		for (;;)
+		{	soap->error = SOAP_TAG_MISMATCH;
+			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
+				if (a->return_.soap_in(soap, "return", "xsd:base64Binary"))
+				{	soap_flag_return_--;
+					continue;
+				}
+			if (soap->error == SOAP_TAG_MISMATCH)
+				soap->error = soap_ignore_element(soap);
+			if (soap->error == SOAP_NO_TAG)
+				break;
+			if (soap->error)
+				return NULL;
+		}
+		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
+		{	soap->error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct gapi1__doGetCachedPageResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_gapi1__doGetCachedPageResponse, 0, sizeof(struct gapi1__doGetCachedPageResponse), 0, soap_copy_gapi1__doGetCachedPageResponse);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct gapi1__doGetCachedPageResponse * SOAP_FMAC6 soap_new_gapi1__doGetCachedPageResponse(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__doGetCachedPageResponse(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGetCachedPageResponse(struct soap *soap, struct gapi1__doGetCachedPageResponse *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_instantiate_gapi1__doGetCachedPageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__doGetCachedPageResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doGetCachedPageResponse, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n < 0)
+	{	cp->ptr = (void*)new struct gapi1__doGetCachedPageResponse;
+		if (size)
+			*size = sizeof(struct gapi1__doGetCachedPageResponse);
+	}
+	else
+	{	cp->ptr = (void*)new struct gapi1__doGetCachedPageResponse[n];
+		if (size)
+			*size = n * sizeof(struct gapi1__doGetCachedPageResponse);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
+	return (struct gapi1__doGetCachedPageResponse*)cp->ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGetCachedPageResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct gapi1__doGetCachedPageResponse %p -> %p\n", q, p));
+	*(struct gapi1__doGetCachedPageResponse*)p = *(struct gapi1__doGetCachedPageResponse*)q;
+}
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
+		soap_serialize_SOAP_ENV__Reason(soap, *a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
+	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
+	if (id < 0)
+		return soap->error;
+	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
+			return NULL;
+	*a = NULL;
+	if (!soap->null && *soap->href != '#')
+	{	soap_revert(soap);
+		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
+		soap_serialize_SOAP_ENV__Detail(soap, *a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
+	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
+	if (id < 0)
+		return soap->error;
+	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
+			return NULL;
+	*a = NULL;
+	if (!soap->null && *soap->href != '#')
+	{	soap_revert(soap);
+		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
+		soap_serialize_SOAP_ENV__Code(soap, *a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
+	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
+	if (id < 0)
+		return soap->error;
+	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
+			return NULL;
+	*a = NULL;
+	if (!soap->null && *soap->href != '#')
+	{	soap_revert(soap);
+		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+#endif
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1__GoogleSearchResult(struct soap *soap, gapi1__GoogleSearchResult *const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_gapi1__GoogleSearchResult))
+		(*a)->soap_serialize(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1__GoogleSearchResult(struct soap *soap, gapi1__GoogleSearchResult *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogapi1__GoogleSearchResult);
+	if (soap_out_PointerTogapi1__GoogleSearchResult(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1__GoogleSearchResult(struct soap *soap, const char *tag, int id, gapi1__GoogleSearchResult *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gapi1__GoogleSearchResult);
+	if (id < 0)
+		return soap->error;
+	return (*a)->soap_out(soap, tag, id, type);
+}
+
+SOAP_FMAC3 gapi1__GoogleSearchResult ** SOAP_FMAC4 soap_get_PointerTogapi1__GoogleSearchResult(struct soap *soap, gapi1__GoogleSearchResult **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerTogapi1__GoogleSearchResult(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1__GoogleSearchResult ** SOAP_FMAC4 soap_in_PointerTogapi1__GoogleSearchResult(struct soap *soap, const char *tag, gapi1__GoogleSearchResult **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1__GoogleSearchResult **)soap_malloc(soap, sizeof(gapi1__GoogleSearchResult *))))
+			return NULL;
+	*a = NULL;
+	if (!soap->null && *soap->href != '#')
+	{	soap_revert(soap);
+		if (!(*a = (gapi1__GoogleSearchResult *)soap_instantiate_gapi1__GoogleSearchResult(soap, -1, soap->type, soap->arrayType, NULL)))
+			return NULL;
+		(*a)->soap_default(soap);
+		if (!(*a)->soap_in(soap, tag, NULL))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__GoogleSearchResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gapi1__GoogleSearchResult, sizeof(gapi1__GoogleSearchResult), 0);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory **const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTogapi1__DirectoryCategory))
+		soap_serialize_PointerTogapi1__DirectoryCategory(soap, *a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory **const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTogapi1__DirectoryCategory);
+	if (soap_out_PointerToPointerTogapi1__DirectoryCategory(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTogapi1__DirectoryCategory(struct soap *soap, const char *tag, int id, gapi1__DirectoryCategory **const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTogapi1__DirectoryCategory);
+	if (id < 0)
+		return soap->error;
+	return soap_out_PointerTogapi1__DirectoryCategory(soap, tag, id, *a, type);
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory *** SOAP_FMAC4 soap_get_PointerToPointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory ***p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerToPointerTogapi1__DirectoryCategory(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory *** SOAP_FMAC4 soap_in_PointerToPointerTogapi1__DirectoryCategory(struct soap *soap, const char *tag, gapi1__DirectoryCategory ***a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1__DirectoryCategory ***)soap_malloc(soap, sizeof(gapi1__DirectoryCategory **))))
+			return NULL;
+	*a = NULL;
+	if (!soap->null && *soap->href != '#')
+	{	soap_revert(soap);
+		if (!(*a = soap_in_PointerTogapi1__DirectoryCategory(soap, tag, *a, type)))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__DirectoryCategory ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTogapi1__DirectoryCategory, sizeof(gapi1__DirectoryCategory *), 1);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement **const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTogapi1__ResultElement))
+		soap_serialize_PointerTogapi1__ResultElement(soap, *a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement **const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTogapi1__ResultElement);
+	if (soap_out_PointerToPointerTogapi1__ResultElement(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTogapi1__ResultElement(struct soap *soap, const char *tag, int id, gapi1__ResultElement **const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTogapi1__ResultElement);
+	if (id < 0)
+		return soap->error;
+	return soap_out_PointerTogapi1__ResultElement(soap, tag, id, *a, type);
+}
+
+SOAP_FMAC3 gapi1__ResultElement *** SOAP_FMAC4 soap_get_PointerToPointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement ***p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerToPointerTogapi1__ResultElement(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1__ResultElement *** SOAP_FMAC4 soap_in_PointerToPointerTogapi1__ResultElement(struct soap *soap, const char *tag, gapi1__ResultElement ***a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1__ResultElement ***)soap_malloc(soap, sizeof(gapi1__ResultElement **))))
+			return NULL;
+	*a = NULL;
+	if (!soap->null && *soap->href != '#')
+	{	soap_revert(soap);
+		if (!(*a = soap_in_PointerTogapi1__ResultElement(soap, tag, *a, type)))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__ResultElement ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTogapi1__ResultElement, sizeof(gapi1__ResultElement *), 1);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement *const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_gapi1__ResultElement))
+		(*a)->soap_serialize(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogapi1__ResultElement);
+	if (soap_out_PointerTogapi1__ResultElement(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1__ResultElement(struct soap *soap, const char *tag, int id, gapi1__ResultElement *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gapi1__ResultElement);
+	if (id < 0)
+		return soap->error;
+	return (*a)->soap_out(soap, tag, id, type);
+}
+
+SOAP_FMAC3 gapi1__ResultElement ** SOAP_FMAC4 soap_get_PointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerTogapi1__ResultElement(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1__ResultElement ** SOAP_FMAC4 soap_in_PointerTogapi1__ResultElement(struct soap *soap, const char *tag, gapi1__ResultElement **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1__ResultElement **)soap_malloc(soap, sizeof(gapi1__ResultElement *))))
+			return NULL;
+	*a = NULL;
+	if (!soap->null && *soap->href != '#')
+	{	soap_revert(soap);
+		if (!(*a = (gapi1__ResultElement *)soap_instantiate_gapi1__ResultElement(soap, -1, soap->type, soap->arrayType, NULL)))
+			return NULL;
+		(*a)->soap_default(soap);
+		if (!(*a)->soap_in(soap, tag, NULL))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__ResultElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gapi1__ResultElement, sizeof(gapi1__ResultElement), 0);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory *const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_gapi1__DirectoryCategory))
+		(*a)->soap_serialize(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogapi1__DirectoryCategory);
+	if (soap_out_PointerTogapi1__DirectoryCategory(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1__DirectoryCategory(struct soap *soap, const char *tag, int id, gapi1__DirectoryCategory *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gapi1__DirectoryCategory);
+	if (id < 0)
+		return soap->error;
+	return (*a)->soap_out(soap, tag, id, type);
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory ** SOAP_FMAC4 soap_get_PointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerTogapi1__DirectoryCategory(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory ** SOAP_FMAC4 soap_in_PointerTogapi1__DirectoryCategory(struct soap *soap, const char *tag, gapi1__DirectoryCategory **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1__DirectoryCategory **)soap_malloc(soap, sizeof(gapi1__DirectoryCategory *))))
+			return NULL;
+	*a = NULL;
+	if (!soap->null && *soap->href != '#')
+	{	soap_revert(soap);
+		if (!(*a = (gapi1__DirectoryCategory *)soap_instantiate_gapi1__DirectoryCategory(soap, -1, soap->type, soap->arrayType, NULL)))
+			return NULL;
+		(*a)->soap_default(soap);
+		if (!(*a)->soap_in(soap, tag, NULL))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__DirectoryCategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gapi1__DirectoryCategory, sizeof(gapi1__DirectoryCategory), 0);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1DirectoryCategoryArray(struct soap *soap, gapi1DirectoryCategoryArray *const*a)
+{
+	if (*a)
+		(*a)->soap_serialize(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1DirectoryCategoryArray(struct soap *soap, gapi1DirectoryCategoryArray *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogapi1DirectoryCategoryArray);
+	if (soap_out_PointerTogapi1DirectoryCategoryArray(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1DirectoryCategoryArray(struct soap *soap, const char *tag, int id, gapi1DirectoryCategoryArray *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_gapi1DirectoryCategoryArray);
+	if (id < 0)
+		return soap->error;
+	return (*a)->soap_out(soap, tag, id, type);
+}
+
+SOAP_FMAC3 gapi1DirectoryCategoryArray ** SOAP_FMAC4 soap_get_PointerTogapi1DirectoryCategoryArray(struct soap *soap, gapi1DirectoryCategoryArray **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerTogapi1DirectoryCategoryArray(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1DirectoryCategoryArray ** SOAP_FMAC4 soap_in_PointerTogapi1DirectoryCategoryArray(struct soap *soap, const char *tag, gapi1DirectoryCategoryArray **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1DirectoryCategoryArray **)soap_malloc(soap, sizeof(gapi1DirectoryCategoryArray *))))
+			return NULL;
+	*a = NULL;
+	if (!soap->null && *soap->href != '#')
+	{	soap_revert(soap);
+		if (!(*a = (gapi1DirectoryCategoryArray *)soap_instantiate_gapi1DirectoryCategoryArray(soap, -1, soap->type, soap->arrayType, NULL)))
+			return NULL;
+		(*a)->soap_default(soap);
+		if (!(*a)->soap_in(soap, tag, NULL))
+			return NULL;
+	}
+	else
+	{	a = (gapi1DirectoryCategoryArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gapi1DirectoryCategoryArray, sizeof(gapi1DirectoryCategoryArray), 0);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1ResultElementArray(struct soap *soap, gapi1ResultElementArray *const*a)
+{
+	if (*a)
+		(*a)->soap_serialize(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1ResultElementArray(struct soap *soap, gapi1ResultElementArray *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogapi1ResultElementArray);
+	if (soap_out_PointerTogapi1ResultElementArray(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1ResultElementArray(struct soap *soap, const char *tag, int id, gapi1ResultElementArray *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_gapi1ResultElementArray);
+	if (id < 0)
+		return soap->error;
+	return (*a)->soap_out(soap, tag, id, type);
+}
+
+SOAP_FMAC3 gapi1ResultElementArray ** SOAP_FMAC4 soap_get_PointerTogapi1ResultElementArray(struct soap *soap, gapi1ResultElementArray **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerTogapi1ResultElementArray(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1ResultElementArray ** SOAP_FMAC4 soap_in_PointerTogapi1ResultElementArray(struct soap *soap, const char *tag, gapi1ResultElementArray **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1ResultElementArray **)soap_malloc(soap, sizeof(gapi1ResultElementArray *))))
+			return NULL;
+	*a = NULL;
+	if (!soap->null && *soap->href != '#')
+	{	soap_revert(soap);
+		if (!(*a = (gapi1ResultElementArray *)soap_instantiate_gapi1ResultElementArray(soap, -1, soap->type, soap->arrayType, NULL)))
+			return NULL;
+		(*a)->soap_default(soap);
+		if (!(*a)->soap_in(soap, tag, NULL))
+			return NULL;
+	}
+	else
+	{	a = (gapi1ResultElementArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gapi1ResultElementArray, sizeof(gapi1ResultElementArray), 0);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
+{
+	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
+	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
+	if (id < 0)
+		return soap->error;
+	return soap_out_unsignedByte(soap, tag, id, *a, type);
+}
+
+SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
+			return NULL;
+	*a = NULL;
+	if (!soap->null && *soap->href != '#')
+	{	soap_revert(soap);
+		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
+			return NULL;
+	}
+	else
+	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
+		if (soap->body && soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
+{	soap_default_string(soap, a);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
+{	soap_serialize_string(soap, a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
+	if (soap_out__QName(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
+{
+	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
+}
+
+SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
+{
+	if ((p = soap_in__QName(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
+{
+	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_string
+	*a = SOAP_DEFAULT_string;
+#else
+	*a = (char *)0;
+#endif
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
+{
+	soap_reference(soap, *a, SOAP_TYPE_string);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
+	if (soap_out_string(soap, tag, id, a, type))
+		return soap->error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
+{
+	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
+}
+
+SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_string(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
+{
+	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
+}
+
+/* End of GAPIC.cpp */

Added: trunk/Search/Google/GAPIClient.cpp
===================================================================
--- trunk/Search/Google/GAPIClient.cpp	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPIClient.cpp	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,185 @@
+/* GAPIClient.cpp
+   Generated by gSOAP 2.7.6e from GoogleSearch.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+#include "GAPIH.h"
+
+SOAP_SOURCE_STAMP("@(#) GAPIClient.cpp ver 2.7.6e 2006-04-05 04:17:23 GMT")
+
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_call_gapi1__doGetCachedPage(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string key, std::string url, xsd__base64Binary &return_)
+{	struct gapi1__doGetCachedPage soap_tmp_gapi1__doGetCachedPage;
+	struct gapi1__doGetCachedPageResponse *soap_tmp_gapi1__doGetCachedPageResponse;
+	if (!soap_endpoint)
+		soap_endpoint = "http://api.google.com/search/beta2";
+	if (!soap_action)
+		soap_action = "urn:GoogleSearchAction";
+	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
+	soap_tmp_gapi1__doGetCachedPage.key = key;
+	soap_tmp_gapi1__doGetCachedPage.url = url;
+	soap_begin(soap);
+	soap_serializeheader(soap);
+	soap_serialize_gapi1__doGetCachedPage(soap, &soap_tmp_gapi1__doGetCachedPage);
+	if (soap_begin_count(soap))
+		return soap->error;
+	if (soap->mode & SOAP_IO_LENGTH)
+	{	if (soap_envelope_begin_out(soap)
+		 || soap_putheader(soap)
+		 || soap_body_begin_out(soap)
+		 || soap_put_gapi1__doGetCachedPage(soap, &soap_tmp_gapi1__doGetCachedPage, "gapi1:doGetCachedPage", "")
+		 || soap_body_end_out(soap)
+		 || soap_envelope_end_out(soap))
+			 return soap->error;
+	}
+	if (soap_end_count(soap))
+		return soap->error;
+	if (soap_connect(soap, soap_endpoint, soap_action)
+	 || soap_envelope_begin_out(soap)
+	 || soap_putheader(soap)
+	 || soap_body_begin_out(soap)
+	 || soap_put_gapi1__doGetCachedPage(soap, &soap_tmp_gapi1__doGetCachedPage, "gapi1:doGetCachedPage", "")
+	 || soap_body_end_out(soap)
+	 || soap_envelope_end_out(soap)
+	 || soap_end_send(soap))
+		return soap_closesock(soap);
+	if (!&return_)
+		return soap_closesock(soap);
+	return_.soap_default(soap);
+	if (soap_begin_recv(soap)
+	 || soap_envelope_begin_in(soap)
+	 || soap_recv_header(soap)
+	 || soap_body_begin_in(soap))
+		return soap_closesock(soap);
+	soap_tmp_gapi1__doGetCachedPageResponse = soap_get_gapi1__doGetCachedPageResponse(soap, NULL, "gapi1:doGetCachedPageResponse", "");
+	if (soap->error)
+	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
+			return soap_recv_fault(soap);
+		return soap_closesock(soap);
+	}
+	if (soap_body_end_in(soap)
+	 || soap_envelope_end_in(soap)
+	 || soap_end_recv(soap))
+		return soap_closesock(soap);
+	return_ = soap_tmp_gapi1__doGetCachedPageResponse->return_;
+	return soap_closesock(soap);
+}
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_call_gapi1__doSpellingSuggestion(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string key, std::string phrase, std::string &return_)
+{	struct gapi1__doSpellingSuggestion soap_tmp_gapi1__doSpellingSuggestion;
+	struct gapi1__doSpellingSuggestionResponse *soap_tmp_gapi1__doSpellingSuggestionResponse;
+	if (!soap_endpoint)
+		soap_endpoint = "http://api.google.com/search/beta2";
+	if (!soap_action)
+		soap_action = "urn:GoogleSearchAction";
+	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
+	soap_tmp_gapi1__doSpellingSuggestion.key = key;
+	soap_tmp_gapi1__doSpellingSuggestion.phrase = phrase;
+	soap_begin(soap);
+	soap_serializeheader(soap);
+	soap_serialize_gapi1__doSpellingSuggestion(soap, &soap_tmp_gapi1__doSpellingSuggestion);
+	if (soap_begin_count(soap))
+		return soap->error;
+	if (soap->mode & SOAP_IO_LENGTH)
+	{	if (soap_envelope_begin_out(soap)
+		 || soap_putheader(soap)
+		 || soap_body_begin_out(soap)
+		 || soap_put_gapi1__doSpellingSuggestion(soap, &soap_tmp_gapi1__doSpellingSuggestion, "gapi1:doSpellingSuggestion", "")
+		 || soap_body_end_out(soap)
+		 || soap_envelope_end_out(soap))
+			 return soap->error;
+	}
+	if (soap_end_count(soap))
+		return soap->error;
+	if (soap_connect(soap, soap_endpoint, soap_action)
+	 || soap_envelope_begin_out(soap)
+	 || soap_putheader(soap)
+	 || soap_body_begin_out(soap)
+	 || soap_put_gapi1__doSpellingSuggestion(soap, &soap_tmp_gapi1__doSpellingSuggestion, "gapi1:doSpellingSuggestion", "")
+	 || soap_body_end_out(soap)
+	 || soap_envelope_end_out(soap)
+	 || soap_end_send(soap))
+		return soap_closesock(soap);
+	soap_default_std__string(soap, &return_);
+	if (soap_begin_recv(soap)
+	 || soap_envelope_begin_in(soap)
+	 || soap_recv_header(soap)
+	 || soap_body_begin_in(soap))
+		return soap_closesock(soap);
+	soap_tmp_gapi1__doSpellingSuggestionResponse = soap_get_gapi1__doSpellingSuggestionResponse(soap, NULL, "gapi1:doSpellingSuggestionResponse", "");
+	if (soap->error)
+	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
+			return soap_recv_fault(soap);
+		return soap_closesock(soap);
+	}
+	if (soap_body_end_in(soap)
+	 || soap_envelope_end_in(soap)
+	 || soap_end_recv(soap))
+		return soap_closesock(soap);
+	return_ = soap_tmp_gapi1__doSpellingSuggestionResponse->return_;
+	return soap_closesock(soap);
+}
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_call_gapi1__doGoogleSearch(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string key, std::string q, int start, int maxResults, bool filter, std::string restrict_, bool safeSearch, std::string lr, std::string ie, std::string oe, struct gapi1__doGoogleSearchResponse &_param_1)
+{	struct gapi1__doGoogleSearch soap_tmp_gapi1__doGoogleSearch;
+	if (!soap_endpoint)
+		soap_endpoint = "http://api.google.com/search/beta2";
+	if (!soap_action)
+		soap_action = "urn:GoogleSearchAction";
+	soap->encodingStyle = "http://schemas.xmlsoap.org/soap/encoding/";
+	soap_tmp_gapi1__doGoogleSearch.key = key;
+	soap_tmp_gapi1__doGoogleSearch.q = q;
+	soap_tmp_gapi1__doGoogleSearch.start = start;
+	soap_tmp_gapi1__doGoogleSearch.maxResults = maxResults;
+	soap_tmp_gapi1__doGoogleSearch.filter = filter;
+	soap_tmp_gapi1__doGoogleSearch.restrict_ = restrict_;
+	soap_tmp_gapi1__doGoogleSearch.safeSearch = safeSearch;
+	soap_tmp_gapi1__doGoogleSearch.lr = lr;
+	soap_tmp_gapi1__doGoogleSearch.ie = ie;
+	soap_tmp_gapi1__doGoogleSearch.oe = oe;
+	soap_begin(soap);
+	soap_serializeheader(soap);
+	soap_serialize_gapi1__doGoogleSearch(soap, &soap_tmp_gapi1__doGoogleSearch);
+	if (soap_begin_count(soap))
+		return soap->error;
+	if (soap->mode & SOAP_IO_LENGTH)
+	{	if (soap_envelope_begin_out(soap)
+		 || soap_putheader(soap)
+		 || soap_body_begin_out(soap)
+		 || soap_put_gapi1__doGoogleSearch(soap, &soap_tmp_gapi1__doGoogleSearch, "gapi1:doGoogleSearch", "")
+		 || soap_body_end_out(soap)
+		 || soap_envelope_end_out(soap))
+			 return soap->error;
+	}
+	if (soap_end_count(soap))
+		return soap->error;
+	if (soap_connect(soap, soap_endpoint, soap_action)
+	 || soap_envelope_begin_out(soap)
+	 || soap_putheader(soap)
+	 || soap_body_begin_out(soap)
+	 || soap_put_gapi1__doGoogleSearch(soap, &soap_tmp_gapi1__doGoogleSearch, "gapi1:doGoogleSearch", "")
+	 || soap_body_end_out(soap)
+	 || soap_envelope_end_out(soap)
+	 || soap_end_send(soap))
+		return soap_closesock(soap);
+	soap_default_gapi1__doGoogleSearchResponse(soap, &_param_1);
+	if (soap_begin_recv(soap)
+	 || soap_envelope_begin_in(soap)
+	 || soap_recv_header(soap)
+	 || soap_body_begin_in(soap))
+		return soap_closesock(soap);
+	soap_get_gapi1__doGoogleSearchResponse(soap, &_param_1, "gapi1:doGoogleSearchResponse", "");
+	if (soap->error)
+	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
+			return soap_recv_fault(soap);
+		return soap_closesock(soap);
+	}
+	if (soap_body_end_in(soap)
+	 || soap_envelope_end_in(soap)
+	 || soap_end_recv(soap))
+		return soap_closesock(soap);
+	return soap_closesock(soap);
+}
+
+/* End of GAPIClient.cpp */

Added: trunk/Search/Google/GAPIClientLib.cpp
===================================================================
--- trunk/Search/Google/GAPIClientLib.cpp	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPIClientLib.cpp	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,14 @@
+/* GAPIClientLib.cpp
+   Generated by gSOAP 2.7.6e from GoogleSearch.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+#ifndef WITH_NOGLOBAL
+#define WITH_NOGLOBAL
+#endif
+#define SOAP_FMAC3 static
+#include "GAPIC.cpp"
+#include "GAPIClient.cpp"
+
+/* End of GAPIClientLib.cpp */

Added: trunk/Search/Google/GAPIGoogleSearchBindingProxy.h
===================================================================
--- trunk/Search/Google/GAPIGoogleSearchBindingProxy.h	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPIGoogleSearchBindingProxy.h	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,22 @@
+/* GAPIGoogleSearchBindingProxy.h
+   Generated by gSOAP 2.7.6e from GoogleSearch.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+
+#ifndef GAPIGoogleSearchBinding_H
+#define GAPIGoogleSearchBinding_H
+#include "GAPIH.h"
+extern SOAP_NMAC struct Namespace GAPI_namespaces[];
+class GoogleSearchBinding
+{   public:
+	struct soap *soap;
+	const char *endpoint;
+	GoogleSearchBinding() { soap = soap_new(); if (soap) soap->namespaces = GAPI_namespaces; endpoint = "http://api.google.com/search/beta2"; };
+	virtual ~GoogleSearchBinding() { if (soap) { soap_destroy(soap); soap_end(soap); soap_done(soap); soap_del(soap); } };
+	virtual int gapi1__doGetCachedPage(std::string key, std::string url, xsd__base64Binary &return_) { return soap ? soap_call_gapi1__doGetCachedPage(soap, endpoint, NULL, key, url, return_) : SOAP_EOM; };
+	virtual int gapi1__doSpellingSuggestion(std::string key, std::string phrase, std::string &return_) { return soap ? soap_call_gapi1__doSpellingSuggestion(soap, endpoint, NULL, key, phrase, return_) : SOAP_EOM; };
+	virtual int gapi1__doGoogleSearch(std::string key, std::string q, int start, int maxResults, bool filter, std::string restrict_, bool safeSearch, std::string lr, std::string ie, std::string oe, struct gapi1__doGoogleSearchResponse &_param_1) { return soap ? soap_call_gapi1__doGoogleSearch(soap, endpoint, NULL, key, q, start, maxResults, filter, restrict_, safeSearch, lr, ie, oe, _param_1) : SOAP_EOM; };
+};
+#endif

Added: trunk/Search/Google/GAPIH.h
===================================================================
--- trunk/Search/Google/GAPIH.h	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPIH.h	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,490 @@
+/* GAPIH.h
+   Generated by gSOAP 2.7.6e from GoogleSearch.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+
+#ifndef GAPIH_H
+#define GAPIH_H
+#include "GAPIStub.h"
+SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap*);
+#ifndef WITH_NOIDREF
+SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap*, const void*, int);
+SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap*, const void*, const char*, int, int);
+SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap*, int*);
+#endif
+
+SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist*);
+SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap*, const char*, void*, int, size_t, const char*, const char*);
+
+SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap*, const char*, void*, size_t, int, int, size_t, unsigned int);
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_byte
+#define SOAP_TYPE_byte (2)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap*, char *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap*, const char *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap*, const char*, int, const char *, const char*);
+SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap*, char *, const char*, const char*);
+SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap*, const char*, char *, const char*);
+
+#ifndef SOAP_TYPE_int
+#define SOAP_TYPE_int (1)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap*, int *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap*, const int *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap*, const char*, int, const int *, const char*);
+SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap*, int *, const char*, const char*);
+SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap*, const char*, int *, const char*);
+
+#ifndef SOAP_TYPE_double
+#define SOAP_TYPE_double (23)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap*, double *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap*, const double *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap*, const char*, int, const double *, const char*);
+SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap*, double *, const char*, const char*);
+SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap*, const char*, double *, const char*);
+
+#ifndef SOAP_TYPE_unsignedByte
+#define SOAP_TYPE_unsignedByte (9)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap*, unsigned char *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap*, const unsigned char *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap*, const char*, int, const unsigned char *, const char*);
+SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap*, unsigned char *, const char*, const char*);
+SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap*, const char*, unsigned char *, const char*);
+
+#ifndef SOAP_TYPE_unsignedInt
+#define SOAP_TYPE_unsignedInt (8)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap*, unsigned int *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap*, const unsigned int *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap*, const char*, int, const unsigned int *, const char*);
+SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap*, unsigned int *, const char*, const char*);
+SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap*, const char*, unsigned int *, const char*);
+
+#ifndef SOAP_TYPE_bool
+#define SOAP_TYPE_bool (20)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap*, bool *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap*, const bool *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap*, const char*, int, const bool *, const char*);
+
+SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap*, bool);
+SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap*, bool *, const char*, const char*);
+SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap*, const char*, bool *, const char*);
+
+SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap*, const char*, bool *);
+
+#ifndef SOAP_TYPE_gapi1__DirectoryCategory
+#define SOAP_TYPE_gapi1__DirectoryCategory (19)
+#endif
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__DirectoryCategory(struct soap*, const char*, int, const gapi1__DirectoryCategory *, const char*);
+SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_get_gapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory *, const char*, const char*);
+SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_in_gapi1__DirectoryCategory(struct soap*, const char*, gapi1__DirectoryCategory *, const char*);
+SOAP_FMAC5 gapi1__DirectoryCategory * SOAP_FMAC6 soap_new_gapi1__DirectoryCategory(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory*);
+SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_instantiate_gapi1__DirectoryCategory(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__DirectoryCategory(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1DirectoryCategoryArray
+#define SOAP_TYPE_gapi1DirectoryCategoryArray (18)
+#endif
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1DirectoryCategoryArray(struct soap*, const char*, int, const gapi1DirectoryCategoryArray *, const char*);
+SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_get_gapi1DirectoryCategoryArray(struct soap*, gapi1DirectoryCategoryArray *, const char*, const char*);
+SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_in_gapi1DirectoryCategoryArray(struct soap*, const char*, gapi1DirectoryCategoryArray *, const char*);
+SOAP_FMAC5 gapi1DirectoryCategoryArray * SOAP_FMAC6 soap_new_gapi1DirectoryCategoryArray(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1DirectoryCategoryArray(struct soap*, gapi1DirectoryCategoryArray*);
+SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_instantiate_gapi1DirectoryCategoryArray(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1DirectoryCategoryArray(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1ResultElementArray
+#define SOAP_TYPE_gapi1ResultElementArray (17)
+#endif
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1ResultElementArray(struct soap*, const char*, int, const gapi1ResultElementArray *, const char*);
+SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_get_gapi1ResultElementArray(struct soap*, gapi1ResultElementArray *, const char*, const char*);
+SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_in_gapi1ResultElementArray(struct soap*, const char*, gapi1ResultElementArray *, const char*);
+SOAP_FMAC5 gapi1ResultElementArray * SOAP_FMAC6 soap_new_gapi1ResultElementArray(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1ResultElementArray(struct soap*, gapi1ResultElementArray*);
+SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_instantiate_gapi1ResultElementArray(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1ResultElementArray(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__ResultElement
+#define SOAP_TYPE_gapi1__ResultElement (16)
+#endif
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__ResultElement(struct soap*, const char*, int, const gapi1__ResultElement *, const char*);
+SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_get_gapi1__ResultElement(struct soap*, gapi1__ResultElement *, const char*, const char*);
+SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_in_gapi1__ResultElement(struct soap*, const char*, gapi1__ResultElement *, const char*);
+SOAP_FMAC5 gapi1__ResultElement * SOAP_FMAC6 soap_new_gapi1__ResultElement(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__ResultElement(struct soap*, gapi1__ResultElement*);
+SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_instantiate_gapi1__ResultElement(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__ResultElement(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__GoogleSearchResult
+#define SOAP_TYPE_gapi1__GoogleSearchResult (15)
+#endif
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__GoogleSearchResult(struct soap*, const char*, int, const gapi1__GoogleSearchResult *, const char*);
+SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_get_gapi1__GoogleSearchResult(struct soap*, gapi1__GoogleSearchResult *, const char*, const char*);
+SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_in_gapi1__GoogleSearchResult(struct soap*, const char*, gapi1__GoogleSearchResult *, const char*);
+SOAP_FMAC5 gapi1__GoogleSearchResult * SOAP_FMAC6 soap_new_gapi1__GoogleSearchResult(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__GoogleSearchResult(struct soap*, gapi1__GoogleSearchResult*);
+SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_instantiate_gapi1__GoogleSearchResult(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__GoogleSearchResult(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE__SOAP_ENC__arrayType
+#define SOAP_TYPE__SOAP_ENC__arrayType (14)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__SOAP_ENC__arrayType(struct soap*, std::string const*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default__SOAP_ENC__arrayType(struct soap*, std::string *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put__SOAP_ENC__arrayType(struct soap*, const std::string *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out__SOAP_ENC__arrayType(struct soap*, const char*, int, const std::string*, const char*);
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get__SOAP_ENC__arrayType(struct soap*, std::string *, const char*, const char*);
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in__SOAP_ENC__arrayType(struct soap*, const char*, std::string*, const char*);
+SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new__SOAP_ENC__arrayType(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete__SOAP_ENC__arrayType(struct soap*, std::string*);
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate__SOAP_ENC__arrayType(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy__SOAP_ENC__arrayType(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_std__string
+#define SOAP_TYPE_std__string (13)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap*, const std::string *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap*, std::string *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap*, const std::string *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap*, const char*, int, const std::string*, const char*);
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap*, std::string *, const char*, const char*);
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap*, const char*, std::string*, const char*);
+SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap*, std::string*);
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_xsd__base64Binary
+#define SOAP_TYPE_xsd__base64Binary (7)
+#endif
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap*, const char*, int, const xsd__base64Binary *, const char*);
+SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap*, xsd__base64Binary *, const char*, const char*);
+SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap*, const char*, xsd__base64Binary *, const char*);
+SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_new_xsd__base64Binary(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary(struct soap*, xsd__base64Binary*);
+SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Fault
+#define SOAP_TYPE_SOAP_ENV__Fault (48)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap*, const char*, int, const struct SOAP_ENV__Fault *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap*, const char*, struct SOAP_ENV__Fault *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault*);
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Reason
+#define SOAP_TYPE_SOAP_ENV__Reason (47)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap*, const char*, int, const struct SOAP_ENV__Reason *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason*);
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Detail
+#define SOAP_TYPE_SOAP_ENV__Detail (46)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap*, const char*, int, const struct SOAP_ENV__Detail *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail*);
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Code
+#define SOAP_TYPE_SOAP_ENV__Code (44)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap*, const char*, int, const struct SOAP_ENV__Code *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code*);
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Header
+#define SOAP_TYPE_SOAP_ENV__Header (43)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap*, const char*, int, const struct SOAP_ENV__Header *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap*, const char*, struct SOAP_ENV__Header *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header*);
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doGoogleSearch
+#define SOAP_TYPE_gapi1__doGoogleSearch (40)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGoogleSearch(struct soap*, const struct gapi1__doGoogleSearch *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGoogleSearch(struct soap*, struct gapi1__doGoogleSearch *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGoogleSearch(struct soap*, const struct gapi1__doGoogleSearch *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGoogleSearch(struct soap*, const char*, int, const struct gapi1__doGoogleSearch *, const char*);
+SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_get_gapi1__doGoogleSearch(struct soap*, struct gapi1__doGoogleSearch *, const char*, const char*);
+SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_in_gapi1__doGoogleSearch(struct soap*, const char*, struct gapi1__doGoogleSearch *, const char*);
+SOAP_FMAC5 struct gapi1__doGoogleSearch * SOAP_FMAC6 soap_new_gapi1__doGoogleSearch(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGoogleSearch(struct soap*, struct gapi1__doGoogleSearch*);
+SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_instantiate_gapi1__doGoogleSearch(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGoogleSearch(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__doGoogleSearchResponse
+#define SOAP_TYPE_gapi1__doGoogleSearchResponse (36)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGoogleSearchResponse(struct soap*, const struct gapi1__doGoogleSearchResponse *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGoogleSearchResponse(struct soap*, struct gapi1__doGoogleSearchResponse *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGoogleSearchResponse(struct soap*, const struct gapi1__doGoogleSearchResponse *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGoogleSearchResponse(struct soap*, const char*, int, const struct gapi1__doGoogleSearchResponse *, const char*);
+SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_get_gapi1__doGoogleSearchResponse(struct soap*, struct gapi1__doGoogleSearchResponse *, const char*, const char*);
+SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_in_gapi1__doGoogleSearchResponse(struct soap*, const char*, struct gapi1__doGoogleSearchResponse *, const char*);
+SOAP_FMAC5 struct gapi1__doGoogleSearchResponse * SOAP_FMAC6 soap_new_gapi1__doGoogleSearchResponse(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGoogleSearchResponse(struct soap*, struct gapi1__doGoogleSearchResponse*);
+SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_instantiate_gapi1__doGoogleSearchResponse(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGoogleSearchResponse(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__doSpellingSuggestion
+#define SOAP_TYPE_gapi1__doSpellingSuggestion (35)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doSpellingSuggestion(struct soap*, const struct gapi1__doSpellingSuggestion *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doSpellingSuggestion(struct soap*, struct gapi1__doSpellingSuggestion *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doSpellingSuggestion(struct soap*, const struct gapi1__doSpellingSuggestion *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doSpellingSuggestion(struct soap*, const char*, int, const struct gapi1__doSpellingSuggestion *, const char*);
+SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_get_gapi1__doSpellingSuggestion(struct soap*, struct gapi1__doSpellingSuggestion *, const char*, const char*);
+SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_in_gapi1__doSpellingSuggestion(struct soap*, const char*, struct gapi1__doSpellingSuggestion *, const char*);
+SOAP_FMAC5 struct gapi1__doSpellingSuggestion * SOAP_FMAC6 soap_new_gapi1__doSpellingSuggestion(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doSpellingSuggestion(struct soap*, struct gapi1__doSpellingSuggestion*);
+SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_instantiate_gapi1__doSpellingSuggestion(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doSpellingSuggestion(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__doSpellingSuggestionResponse
+#define SOAP_TYPE_gapi1__doSpellingSuggestionResponse (34)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doSpellingSuggestionResponse(struct soap*, const struct gapi1__doSpellingSuggestionResponse *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doSpellingSuggestionResponse(struct soap*, struct gapi1__doSpellingSuggestionResponse *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doSpellingSuggestionResponse(struct soap*, const struct gapi1__doSpellingSuggestionResponse *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doSpellingSuggestionResponse(struct soap*, const char*, int, const struct gapi1__doSpellingSuggestionResponse *, const char*);
+SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_get_gapi1__doSpellingSuggestionResponse(struct soap*, struct gapi1__doSpellingSuggestionResponse *, const char*, const char*);
+SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_in_gapi1__doSpellingSuggestionResponse(struct soap*, const char*, struct gapi1__doSpellingSuggestionResponse *, const char*);
+SOAP_FMAC5 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC6 soap_new_gapi1__doSpellingSuggestionResponse(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doSpellingSuggestionResponse(struct soap*, struct gapi1__doSpellingSuggestionResponse*);
+SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_instantiate_gapi1__doSpellingSuggestionResponse(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doSpellingSuggestionResponse(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__doGetCachedPage
+#define SOAP_TYPE_gapi1__doGetCachedPage (31)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGetCachedPage(struct soap*, const struct gapi1__doGetCachedPage *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGetCachedPage(struct soap*, struct gapi1__doGetCachedPage *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGetCachedPage(struct soap*, const struct gapi1__doGetCachedPage *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGetCachedPage(struct soap*, const char*, int, const struct gapi1__doGetCachedPage *, const char*);
+SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_get_gapi1__doGetCachedPage(struct soap*, struct gapi1__doGetCachedPage *, const char*, const char*);
+SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_in_gapi1__doGetCachedPage(struct soap*, const char*, struct gapi1__doGetCachedPage *, const char*);
+SOAP_FMAC5 struct gapi1__doGetCachedPage * SOAP_FMAC6 soap_new_gapi1__doGetCachedPage(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGetCachedPage(struct soap*, struct gapi1__doGetCachedPage*);
+SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_instantiate_gapi1__doGetCachedPage(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGetCachedPage(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__doGetCachedPageResponse
+#define SOAP_TYPE_gapi1__doGetCachedPageResponse (30)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGetCachedPageResponse(struct soap*, const struct gapi1__doGetCachedPageResponse *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGetCachedPageResponse(struct soap*, struct gapi1__doGetCachedPageResponse *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGetCachedPageResponse(struct soap*, const struct gapi1__doGetCachedPageResponse *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGetCachedPageResponse(struct soap*, const char*, int, const struct gapi1__doGetCachedPageResponse *, const char*);
+SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_get_gapi1__doGetCachedPageResponse(struct soap*, struct gapi1__doGetCachedPageResponse *, const char*, const char*);
+SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_in_gapi1__doGetCachedPageResponse(struct soap*, const char*, struct gapi1__doGetCachedPageResponse *, const char*);
+SOAP_FMAC5 struct gapi1__doGetCachedPageResponse * SOAP_FMAC6 soap_new_gapi1__doGetCachedPageResponse(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGetCachedPageResponse(struct soap*, struct gapi1__doGetCachedPageResponse*);
+SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_instantiate_gapi1__doGetCachedPageResponse(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGetCachedPageResponse(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
+#define SOAP_TYPE_PointerToSOAP_ENV__Reason (50)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap*, const char *, int, struct SOAP_ENV__Reason *const*, const char *);
+SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason **, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason **, const char*);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
+#define SOAP_TYPE_PointerToSOAP_ENV__Detail (49)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap*, const char *, int, struct SOAP_ENV__Detail *const*, const char *);
+SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail **, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail **, const char*);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
+#define SOAP_TYPE_PointerToSOAP_ENV__Code (45)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap*, const char *, int, struct SOAP_ENV__Code *const*, const char *);
+SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code **, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code **, const char*);
+
+#endif
+
+#ifndef SOAP_TYPE_PointerTogapi1__GoogleSearchResult
+#define SOAP_TYPE_PointerTogapi1__GoogleSearchResult (37)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1__GoogleSearchResult(struct soap*, gapi1__GoogleSearchResult *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1__GoogleSearchResult(struct soap*, gapi1__GoogleSearchResult *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1__GoogleSearchResult(struct soap*, const char *, int, gapi1__GoogleSearchResult *const*, const char *);
+SOAP_FMAC3 gapi1__GoogleSearchResult ** SOAP_FMAC4 soap_get_PointerTogapi1__GoogleSearchResult(struct soap*, gapi1__GoogleSearchResult **, const char*, const char*);
+SOAP_FMAC3 gapi1__GoogleSearchResult ** SOAP_FMAC4 soap_in_PointerTogapi1__GoogleSearchResult(struct soap*, const char*, gapi1__GoogleSearchResult **, const char*);
+
+#ifndef SOAP_TYPE_PointerToPointerTogapi1__DirectoryCategory
+#define SOAP_TYPE_PointerToPointerTogapi1__DirectoryCategory (27)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTogapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory **const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTogapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory **const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTogapi1__DirectoryCategory(struct soap*, const char *, int, gapi1__DirectoryCategory **const*, const char *);
+SOAP_FMAC3 gapi1__DirectoryCategory *** SOAP_FMAC4 soap_get_PointerToPointerTogapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory ***, const char*, const char*);
+SOAP_FMAC3 gapi1__DirectoryCategory *** SOAP_FMAC4 soap_in_PointerToPointerTogapi1__DirectoryCategory(struct soap*, const char*, gapi1__DirectoryCategory ***, const char*);
+
+#ifndef SOAP_TYPE_PointerToPointerTogapi1__ResultElement
+#define SOAP_TYPE_PointerToPointerTogapi1__ResultElement (26)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTogapi1__ResultElement(struct soap*, gapi1__ResultElement **const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTogapi1__ResultElement(struct soap*, gapi1__ResultElement **const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTogapi1__ResultElement(struct soap*, const char *, int, gapi1__ResultElement **const*, const char *);
+SOAP_FMAC3 gapi1__ResultElement *** SOAP_FMAC4 soap_get_PointerToPointerTogapi1__ResultElement(struct soap*, gapi1__ResultElement ***, const char*, const char*);
+SOAP_FMAC3 gapi1__ResultElement *** SOAP_FMAC4 soap_in_PointerToPointerTogapi1__ResultElement(struct soap*, const char*, gapi1__ResultElement ***, const char*);
+
+#ifndef SOAP_TYPE_PointerTogapi1__ResultElement
+#define SOAP_TYPE_PointerTogapi1__ResultElement (25)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1__ResultElement(struct soap*, gapi1__ResultElement *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1__ResultElement(struct soap*, gapi1__ResultElement *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1__ResultElement(struct soap*, const char *, int, gapi1__ResultElement *const*, const char *);
+SOAP_FMAC3 gapi1__ResultElement ** SOAP_FMAC4 soap_get_PointerTogapi1__ResultElement(struct soap*, gapi1__ResultElement **, const char*, const char*);
+SOAP_FMAC3 gapi1__ResultElement ** SOAP_FMAC4 soap_in_PointerTogapi1__ResultElement(struct soap*, const char*, gapi1__ResultElement **, const char*);
+
+#ifndef SOAP_TYPE_PointerTogapi1__DirectoryCategory
+#define SOAP_TYPE_PointerTogapi1__DirectoryCategory (24)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1__DirectoryCategory(struct soap*, const char *, int, gapi1__DirectoryCategory *const*, const char *);
+SOAP_FMAC3 gapi1__DirectoryCategory ** SOAP_FMAC4 soap_get_PointerTogapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory **, const char*, const char*);
+SOAP_FMAC3 gapi1__DirectoryCategory ** SOAP_FMAC4 soap_in_PointerTogapi1__DirectoryCategory(struct soap*, const char*, gapi1__DirectoryCategory **, const char*);
+
+#ifndef SOAP_TYPE_PointerTogapi1DirectoryCategoryArray
+#define SOAP_TYPE_PointerTogapi1DirectoryCategoryArray (22)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1DirectoryCategoryArray(struct soap*, gapi1DirectoryCategoryArray *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1DirectoryCategoryArray(struct soap*, gapi1DirectoryCategoryArray *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1DirectoryCategoryArray(struct soap*, const char *, int, gapi1DirectoryCategoryArray *const*, const char *);
+SOAP_FMAC3 gapi1DirectoryCategoryArray ** SOAP_FMAC4 soap_get_PointerTogapi1DirectoryCategoryArray(struct soap*, gapi1DirectoryCategoryArray **, const char*, const char*);
+SOAP_FMAC3 gapi1DirectoryCategoryArray ** SOAP_FMAC4 soap_in_PointerTogapi1DirectoryCategoryArray(struct soap*, const char*, gapi1DirectoryCategoryArray **, const char*);
+
+#ifndef SOAP_TYPE_PointerTogapi1ResultElementArray
+#define SOAP_TYPE_PointerTogapi1ResultElementArray (21)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1ResultElementArray(struct soap*, gapi1ResultElementArray *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1ResultElementArray(struct soap*, gapi1ResultElementArray *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1ResultElementArray(struct soap*, const char *, int, gapi1ResultElementArray *const*, const char *);
+SOAP_FMAC3 gapi1ResultElementArray ** SOAP_FMAC4 soap_get_PointerTogapi1ResultElementArray(struct soap*, gapi1ResultElementArray **, const char*, const char*);
+SOAP_FMAC3 gapi1ResultElementArray ** SOAP_FMAC4 soap_in_PointerTogapi1ResultElementArray(struct soap*, const char*, gapi1ResultElementArray **, const char*);
+
+#ifndef SOAP_TYPE_PointerTounsignedByte
+#define SOAP_TYPE_PointerTounsignedByte (10)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap*, unsigned char *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap*, unsigned char *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap*, const char *, int, unsigned char *const*, const char *);
+SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap*, unsigned char **, const char*, const char*);
+SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap*, const char*, unsigned char **, const char*);
+
+#ifndef SOAP_TYPE__QName
+#define SOAP_TYPE__QName (5)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap*, char **);
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap*, char *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap*, char *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap*, const char*, int, char*const*, const char*);
+SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap*, char **, const char*, const char*);
+SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap*, const char*, char **, const char*);
+
+#ifndef SOAP_TYPE_string
+#define SOAP_TYPE_string (3)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap*, char **);
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap*, char *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap*, char *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap*, const char*, int, char*const*, const char*);
+SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap*, char **, const char*, const char*);
+SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap*, const char*, char **, const char*);
+
+#endif
+
+/* End of GAPIH.h */

Added: trunk/Search/Google/GAPIStub.h
===================================================================
--- trunk/Search/Google/GAPIStub.h	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPIStub.h	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,404 @@
+/* GAPIStub.h
+   Generated by gSOAP 2.7.6e from GoogleSearch.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+
+#ifndef GAPIStub_H
+#define GAPIStub_H
+#include <vector>
+#define WITH_NONAMESPACES
+#include "stdsoap2.h"
+
+/******************************************************************************\
+ *                                                                            *
+ * Enumerations                                                               *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Classes and Structs                                                        *
+ *                                                                            *
+\******************************************************************************/
+
+
+
+
+#ifndef SOAP_TYPE_xsd__base64Binary
+#define SOAP_TYPE_xsd__base64Binary (7)
+/* Base64 schema type: */
+class SOAP_CMAC xsd__base64Binary
+{
+public:
+	unsigned char *__ptr;
+	int __size;
+	char *id;	/* optional element of type xsd:string */
+	char *type;	/* optional element of type xsd:string */
+	char *options;	/* optional element of type xsd:string */
+	struct soap *soap;	/* transient */
+public:
+	virtual int soap_type() const { return 7; } /* = unique id SOAP_TYPE_xsd__base64Binary */
+	virtual void soap_default(struct soap*);
+	virtual void soap_serialize(struct soap*) const;
+	virtual int soap_put(struct soap*, const char*, const char*) const;
+	virtual int soap_out(struct soap*, const char*, int, const char*) const;
+	virtual void *soap_get(struct soap*, const char*, const char*);
+	virtual void *soap_in(struct soap*, const char*, const char*);
+	         xsd__base64Binary() : __ptr(NULL), id(NULL), type(NULL), options(NULL), soap(NULL) { }
+	virtual ~xsd__base64Binary() { }
+};
+#endif
+
+#if 0 /* volatile type: do no redeclare */
+
+#endif
+
+#ifndef SOAP_TYPE_gapi1__GoogleSearchResult
+#define SOAP_TYPE_gapi1__GoogleSearchResult (15)
+/* gapi1:GoogleSearchResult */
+class SOAP_CMAC gapi1__GoogleSearchResult
+{
+public:
+	bool documentFiltering;	/* required element of type xsd:boolean */
+	std::string searchComments;	/* required element of type xsd:string */
+	int estimatedTotalResultsCount;	/* required element of type xsd:int */
+	bool estimateIsExact;	/* required element of type xsd:boolean */
+	class gapi1ResultElementArray *resultElements;	/* required element of type ArrayOfResultElement */
+	std::string searchQuery;	/* required element of type xsd:string */
+	int startIndex;	/* required element of type xsd:int */
+	int endIndex;	/* required element of type xsd:int */
+	std::string searchTips;	/* required element of type xsd:string */
+	class gapi1DirectoryCategoryArray *directoryCategories;	/* required element of type ArrayOfDirectoryCategory */
+	double searchTime;	/* required element of type xsd:double */
+	struct soap *soap;	/* transient */
+public:
+	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_gapi1__GoogleSearchResult */
+	virtual void soap_default(struct soap*);
+	virtual void soap_serialize(struct soap*) const;
+	virtual int soap_put(struct soap*, const char*, const char*) const;
+	virtual int soap_out(struct soap*, const char*, int, const char*) const;
+	virtual void *soap_get(struct soap*, const char*, const char*);
+	virtual void *soap_in(struct soap*, const char*, const char*);
+	         gapi1__GoogleSearchResult() : resultElements(NULL), directoryCategories(NULL), soap(NULL) { }
+	virtual ~gapi1__GoogleSearchResult() { }
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__ResultElement
+#define SOAP_TYPE_gapi1__ResultElement (16)
+/* gapi1:ResultElement */
+class SOAP_CMAC gapi1__ResultElement
+{
+public:
+	std::string summary;	/* required element of type xsd:string */
+	std::string URL;	/* required element of type xsd:string */
+	std::string snippet;	/* required element of type xsd:string */
+	std::string title;	/* required element of type xsd:string */
+	std::string cachedSize;	/* required element of type xsd:string */
+	bool relatedInformationPresent;	/* required element of type xsd:boolean */
+	std::string hostName;	/* required element of type xsd:string */
+	class gapi1__DirectoryCategory *directoryCategory;	/* required element of type gapi1:DirectoryCategory */
+	std::string directoryTitle;	/* required element of type xsd:string */
+	struct soap *soap;	/* transient */
+public:
+	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_gapi1__ResultElement */
+	virtual void soap_default(struct soap*);
+	virtual void soap_serialize(struct soap*) const;
+	virtual int soap_put(struct soap*, const char*, const char*) const;
+	virtual int soap_out(struct soap*, const char*, int, const char*) const;
+	virtual void *soap_get(struct soap*, const char*, const char*);
+	virtual void *soap_in(struct soap*, const char*, const char*);
+	         gapi1__ResultElement() : directoryCategory(NULL), soap(NULL) { }
+	virtual ~gapi1__ResultElement() { }
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__DirectoryCategory
+#define SOAP_TYPE_gapi1__DirectoryCategory (19)
+/* gapi1:DirectoryCategory */
+class SOAP_CMAC gapi1__DirectoryCategory
+{
+public:
+	std::string fullViewableName;	/* required element of type xsd:string */
+	std::string specialEncoding;	/* required element of type xsd:string */
+	struct soap *soap;	/* transient */
+public:
+	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_gapi1__DirectoryCategory */
+	virtual void soap_default(struct soap*);
+	virtual void soap_serialize(struct soap*) const;
+	virtual int soap_put(struct soap*, const char*, const char*) const;
+	virtual int soap_out(struct soap*, const char*, int, const char*) const;
+	virtual void *soap_get(struct soap*, const char*, const char*);
+	virtual void *soap_in(struct soap*, const char*, const char*);
+	         gapi1__DirectoryCategory() : soap(NULL) { }
+	virtual ~gapi1__DirectoryCategory() { }
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1ResultElementArray
+#define SOAP_TYPE_gapi1ResultElementArray (17)
+/* SOAP encoded array of gapi1:ResultElement schema type: */
+class SOAP_CMAC gapi1ResultElementArray
+{
+public:
+	gapi1__ResultElement **__ptr;
+	int __size;
+	struct soap *soap;	/* transient */
+public:
+	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_gapi1ResultElementArray */
+	virtual void soap_default(struct soap*);
+	virtual void soap_serialize(struct soap*) const;
+	virtual int soap_put(struct soap*, const char*, const char*) const;
+	virtual int soap_out(struct soap*, const char*, int, const char*) const;
+	virtual void *soap_get(struct soap*, const char*, const char*);
+	virtual void *soap_in(struct soap*, const char*, const char*);
+	         gapi1ResultElementArray() : __ptr(NULL), soap(NULL) { }
+	virtual ~gapi1ResultElementArray() { }
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1DirectoryCategoryArray
+#define SOAP_TYPE_gapi1DirectoryCategoryArray (18)
+/* SOAP encoded array of gapi1:DirectoryCategory schema type: */
+class SOAP_CMAC gapi1DirectoryCategoryArray
+{
+public:
+	gapi1__DirectoryCategory **__ptr;
+	int __size;
+	struct soap *soap;	/* transient */
+public:
+	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_gapi1DirectoryCategoryArray */
+	virtual void soap_default(struct soap*);
+	virtual void soap_serialize(struct soap*) const;
+	virtual int soap_put(struct soap*, const char*, const char*) const;
+	virtual int soap_out(struct soap*, const char*, int, const char*) const;
+	virtual void *soap_get(struct soap*, const char*, const char*);
+	virtual void *soap_in(struct soap*, const char*, const char*);
+	         gapi1DirectoryCategoryArray() : __ptr(NULL), soap(NULL) { }
+	virtual ~gapi1DirectoryCategoryArray() { }
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doGetCachedPageResponse
+#define SOAP_TYPE_gapi1__doGetCachedPageResponse (30)
+/* gapi1:doGetCachedPageResponse */
+struct gapi1__doGetCachedPageResponse
+{
+public:
+	xsd__base64Binary return_;	/* RPC return element */	/* required element of type xsd:base64Binary */
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doGetCachedPage
+#define SOAP_TYPE_gapi1__doGetCachedPage (31)
+/* gapi1:doGetCachedPage */
+struct gapi1__doGetCachedPage
+{
+public:
+	std::string key;	/* required element of type xsd:string */
+	std::string url;	/* required element of type xsd:string */
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doSpellingSuggestionResponse
+#define SOAP_TYPE_gapi1__doSpellingSuggestionResponse (34)
+/* gapi1:doSpellingSuggestionResponse */
+struct gapi1__doSpellingSuggestionResponse
+{
+public:
+	std::string return_;	/* RPC return element */	/* required element of type xsd:string */
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doSpellingSuggestion
+#define SOAP_TYPE_gapi1__doSpellingSuggestion (35)
+/* gapi1:doSpellingSuggestion */
+struct gapi1__doSpellingSuggestion
+{
+public:
+	std::string key;	/* required element of type xsd:string */
+	std::string phrase;	/* required element of type xsd:string */
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doGoogleSearchResponse
+#define SOAP_TYPE_gapi1__doGoogleSearchResponse (36)
+/* gapi1:doGoogleSearchResponse */
+struct gapi1__doGoogleSearchResponse
+{
+public:
+	gapi1__GoogleSearchResult *return_;	/* RPC return element */	/* optional element of type gapi1:GoogleSearchResult */
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doGoogleSearch
+#define SOAP_TYPE_gapi1__doGoogleSearch (40)
+/* gapi1:doGoogleSearch */
+struct gapi1__doGoogleSearch
+{
+public:
+	std::string key;	/* required element of type xsd:string */
+	std::string q;	/* required element of type xsd:string */
+	int start;	/* required element of type xsd:int */
+	int maxResults;	/* required element of type xsd:int */
+	bool filter;	/* required element of type xsd:boolean */
+	std::string restrict_;	/* required element of type xsd:string */
+	bool safeSearch;	/* required element of type xsd:boolean */
+	std::string lr;	/* required element of type xsd:string */
+	std::string ie;	/* required element of type xsd:string */
+	std::string oe;	/* required element of type xsd:string */
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Header
+#define SOAP_TYPE_SOAP_ENV__Header (43)
+/* SOAP Header: */
+struct SOAP_ENV__Header
+{
+public:
+	void *dummy;	/* transient */
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Code
+#define SOAP_TYPE_SOAP_ENV__Code (44)
+/* SOAP Fault Code: */
+struct SOAP_ENV__Code
+{
+public:
+	char *SOAP_ENV__Value;	/* optional element of type QName */
+	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Detail
+#define SOAP_TYPE_SOAP_ENV__Detail (46)
+/* SOAP-ENV:Detail */
+struct SOAP_ENV__Detail
+{
+public:
+	int __type;	/* any type of element <fault> (defined below) */
+	void *fault;	/* transient */
+	char *__any;
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Reason
+#define SOAP_TYPE_SOAP_ENV__Reason (47)
+/* SOAP-ENV:Reason */
+struct SOAP_ENV__Reason
+{
+public:
+	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Fault
+#define SOAP_TYPE_SOAP_ENV__Fault (48)
+/* SOAP Fault: */
+struct SOAP_ENV__Fault
+{
+public:
+	char *faultcode;	/* optional element of type QName */
+	char *faultstring;	/* optional element of type xsd:string */
+	char *faultactor;	/* optional element of type xsd:string */
+	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
+	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
+	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
+	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
+	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
+	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
+};
+#endif
+
+/******************************************************************************\
+ *                                                                            *
+ * Types with Custom Serializers                                              *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Typedefs                                                                   *
+ *                                                                            *
+\******************************************************************************/
+
+#ifndef SOAP_TYPE__XML
+#define SOAP_TYPE__XML (4)
+typedef char *_XML;
+#endif
+
+#ifndef SOAP_TYPE__QName
+#define SOAP_TYPE__QName (5)
+typedef char *_QName;
+#endif
+
+#ifndef SOAP_TYPE__SOAP_ENC__arrayType
+#define SOAP_TYPE__SOAP_ENC__arrayType (14)
+typedef std::string _SOAP_ENC__arrayType;
+#endif
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Typedef Synonyms                                                           *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Externals                                                                  *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Service Operations                                                         *
+ *                                                                            *
+\******************************************************************************/
+
+
+SOAP_FMAC5 int SOAP_FMAC6 gapi1__doGetCachedPage(struct soap*, std::string key, std::string url, xsd__base64Binary &return_);
+
+SOAP_FMAC5 int SOAP_FMAC6 gapi1__doSpellingSuggestion(struct soap*, std::string key, std::string phrase, std::string &return_);
+
+SOAP_FMAC5 int SOAP_FMAC6 gapi1__doGoogleSearch(struct soap*, std::string key, std::string q, int start, int maxResults, bool filter, std::string restrict_, bool safeSearch, std::string lr, std::string ie, std::string oe, struct gapi1__doGoogleSearchResponse &_param_1);
+
+/******************************************************************************\
+ *                                                                            *
+ * Stubs                                                                      *
+ *                                                                            *
+\******************************************************************************/
+
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_call_gapi1__doGetCachedPage(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string key, std::string url, xsd__base64Binary &return_);
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_call_gapi1__doSpellingSuggestion(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string key, std::string phrase, std::string &return_);
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_call_gapi1__doGoogleSearch(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string key, std::string q, int start, int maxResults, bool filter, std::string restrict_, bool safeSearch, std::string lr, std::string ie, std::string oe, struct gapi1__doGoogleSearchResponse &_param_1);
+
+/******************************************************************************\
+ *                                                                            *
+ * Skeletons                                                                  *
+ *                                                                            *
+\******************************************************************************/
+
+SOAP_FMAC5 int SOAP_FMAC6 GAPI_serve(struct soap*);
+
+SOAP_FMAC5 int SOAP_FMAC6 GAPI_serve_request(struct soap*);
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_serve_gapi1__doGetCachedPage(struct soap*);
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_serve_gapi1__doSpellingSuggestion(struct soap*);
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_serve_gapi1__doGoogleSearch(struct soap*);
+
+#endif
+
+/* End of GAPIStub.h */



From fabricecolin at berlios.de  Wed Apr  5 15:13:45 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 5 Apr 2006 15:13:45 +0200
Subject: [Pinot-svn] r190 - trunk/Search/Plugins
Message-ID: <200604051313.k35DDjno021736@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-05 15:13:38 +0200 (Wed, 05 Apr 2006)
New Revision: 190

Modified:
   trunk/Search/Plugins/BitTorrent.src
Log:
Update.


Modified: trunk/Search/Plugins/BitTorrent.src
===================================================================
--- trunk/Search/Plugins/BitTorrent.src	2006-04-05 13:08:03 UTC (rev 189)
+++ trunk/Search/Plugins/BitTorrent.src	2006-04-05 13:13:38 UTC (rev 190)
@@ -16,10 +16,10 @@
 <INPUTNEXT NAME="start" FACTOR="10">
 
 <INTERPRET
-resultListStart=''
-resultListEnd=''
-resultItemStart='<span class="titler">'
-resultItemEnd='</span><p><p></div>'
+resultListStart='<div class="searchresults">'
+resultListEnd='<div class="pages">'
+resultItemStart='<div class="d">'
+resultItemEnd='</li>'
 >
 
 </SEARCH>



From fabricecolin at berlios.de  Wed Apr  5 15:39:57 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 5 Apr 2006 15:39:57 +0200
Subject: [Pinot-svn] r191 - trunk/Search/Google
Message-ID: <200604051339.k35Ddv6H001584@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-05 15:39:55 +0200 (Wed, 05 Apr 2006)
New Revision: 191

Modified:
   trunk/Search/Google/Makefile.am
Log:
Removed dep on wsdl file and unused header from noinst_HEADERS.


Modified: trunk/Search/Google/Makefile.am
===================================================================
--- trunk/Search/Google/Makefile.am	2006-04-05 13:13:38 UTC (rev 190)
+++ trunk/Search/Google/Makefile.am	2006-04-05 13:39:55 UTC (rev 191)
@@ -1,7 +1,6 @@
 # Process this file with automake to produce Makefile.in
 
 noinst_HEADERS = \
-	GAPIGoogleSearchBindingObject.h \
 	GAPIGoogleSearchBindingProxy.h \
 	GAPIH.h \
 	GAPIStub.h \
@@ -14,7 +13,7 @@
 	GAPIClientLib.cpp \
 	GoogleAPIEngine.cpp
 
-GoogleSearch.h : googleapi/GoogleSearch.wsdl
+GoogleSearch.h :
 	wsdl2c -n gapi -o GoogleSearch.h googleapi/GoogleSearch.wsdl
 
 GAPIClientLib.cpp : GoogleSearch.h



From fabricecolin at berlios.de  Wed Apr  5 15:50:40 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 5 Apr 2006 15:50:40 +0200
Subject: [Pinot-svn] r192 - trunk/Search/Google
Message-ID: <200604051350.k35DoeXj009020@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-05 15:50:27 +0200 (Wed, 05 Apr 2006)
New Revision: 192

Modified:
   trunk/Search/Google/Makefile.am
Log:
Distribute files GAPIC.cpp and GAPIClient.cpp !


Modified: trunk/Search/Google/Makefile.am
===================================================================
--- trunk/Search/Google/Makefile.am	2006-04-05 13:39:55 UTC (rev 191)
+++ trunk/Search/Google/Makefile.am	2006-04-05 13:50:27 UTC (rev 192)
@@ -10,6 +10,8 @@
 noinst_LTLIBRARIES = libSearchGoogle.la
 
 libSearchGoogle_la_SOURCES = \
+	GAPIC.cpp \
+	GAPIClient.cpp \
 	GAPIClientLib.cpp \
 	GoogleAPIEngine.cpp
 



From fabricecolin at berlios.de  Wed Apr  5 15:58:48 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 5 Apr 2006 15:58:48 +0200
Subject: [Pinot-svn] r193 - trunk/Search/Google
Message-ID: <200604051358.k35Dwm0t016165@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-05 15:58:23 +0200 (Wed, 05 Apr 2006)
New Revision: 193

Modified:
   trunk/Search/Google/Makefile.am
Log:
.. and GAPI.nsmap !


Modified: trunk/Search/Google/Makefile.am
===================================================================
--- trunk/Search/Google/Makefile.am	2006-04-05 13:50:27 UTC (rev 192)
+++ trunk/Search/Google/Makefile.am	2006-04-05 13:58:23 UTC (rev 193)
@@ -1,6 +1,7 @@
 # Process this file with automake to produce Makefile.in
 
 noinst_HEADERS = \
+	GAPI.nsmap \
 	GAPIGoogleSearchBindingProxy.h \
 	GAPIH.h \
 	GAPIStub.h \



From fabricecolin at berlios.de  Wed Apr  5 16:09:11 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 5 Apr 2006 16:09:11 +0200
Subject: [Pinot-svn] r194 - trunk/Search
Message-ID: <200604051409.k35E9Bjh032458@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-05 16:09:10 +0200 (Wed, 05 Apr 2006)
New Revision: 194

Added:
   trunk/Search/SOAPEnvH.h
   trunk/Search/SOAPEnvStub.h
Modified:
   trunk/Search/Makefile.am
Log:
More gSOAP-generated files.


Modified: trunk/Search/Makefile.am
===================================================================
--- trunk/Search/Makefile.am	2006-04-05 13:58:23 UTC (rev 193)
+++ trunk/Search/Makefile.am	2006-04-05 14:09:10 UTC (rev 194)
@@ -12,7 +12,9 @@
 	PluginWebEngine.h \
 	SearchEngineInterface.h \
 	SherlockParser.h \
-	SOAPEnv.h
+	SOAPEnv.h \
+	SOAPEnvH.h \
+	SOAPEnvStub.h
 
 EXTRA_LTLIBRARIES = libSearch.la libSearchSOAP.la
 

Added: trunk/Search/SOAPEnvH.h
===================================================================
--- trunk/Search/SOAPEnvH.h	2006-04-05 13:58:23 UTC (rev 193)
+++ trunk/Search/SOAPEnvH.h	2006-04-05 14:09:10 UTC (rev 194)
@@ -0,0 +1,193 @@
+/* SOAPEnvH.h
+   Generated by gSOAP 2.7.6e from SOAPEnv.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+
+#ifndef SOAPEnvH_H
+#define SOAPEnvH_H
+#include "SOAPEnvStub.h"
+SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap*);
+#ifndef WITH_NOIDREF
+SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap*, const void*, int);
+SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap*, const void*, const char*, int, int);
+SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap*, int*);
+#endif
+
+SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist*);
+SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap*, const char*, void*, int, size_t, const char*, const char*);
+
+#ifndef SOAP_TYPE_byte
+#define SOAP_TYPE_byte (2)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap*, char *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap*, const char *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap*, const char*, int, const char *, const char*);
+SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap*, char *, const char*, const char*);
+SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap*, const char*, char *, const char*);
+
+#ifndef SOAP_TYPE_int
+#define SOAP_TYPE_int (1)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap*, int *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap*, const int *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap*, const char*, int, const int *, const char*);
+SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap*, int *, const char*, const char*);
+SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap*, const char*, int *, const char*);
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Fault
+#define SOAP_TYPE_SOAP_ENV__Fault (13)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap*, const char*, int, const struct SOAP_ENV__Fault *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap*, const char*, struct SOAP_ENV__Fault *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault*);
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Reason
+#define SOAP_TYPE_SOAP_ENV__Reason (12)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap*, const char*, int, const struct SOAP_ENV__Reason *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason*);
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Detail
+#define SOAP_TYPE_SOAP_ENV__Detail (11)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap*, const char*, int, const struct SOAP_ENV__Detail *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail*);
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Code
+#define SOAP_TYPE_SOAP_ENV__Code (9)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap*, const char*, int, const struct SOAP_ENV__Code *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code*);
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Header
+#define SOAP_TYPE_SOAP_ENV__Header (8)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap*, const char*, int, const struct SOAP_ENV__Header *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap*, const char*, struct SOAP_ENV__Header *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header*);
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
+#define SOAP_TYPE_PointerToSOAP_ENV__Reason (15)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap*, const char *, int, struct SOAP_ENV__Reason *const*, const char *);
+SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason **, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason **, const char*);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
+#define SOAP_TYPE_PointerToSOAP_ENV__Detail (14)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap*, const char *, int, struct SOAP_ENV__Detail *const*, const char *);
+SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail **, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail **, const char*);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
+#define SOAP_TYPE_PointerToSOAP_ENV__Code (10)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap*, const char *, int, struct SOAP_ENV__Code *const*, const char *);
+SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code **, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code **, const char*);
+
+#endif
+
+#ifndef SOAP_TYPE__QName
+#define SOAP_TYPE__QName (5)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap*, char **);
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap*, char *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap*, char *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap*, const char*, int, char*const*, const char*);
+SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap*, char **, const char*, const char*);
+SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap*, const char*, char **, const char*);
+
+#ifndef SOAP_TYPE_string
+#define SOAP_TYPE_string (3)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap*, char **);
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap*, char *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap*, char *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap*, const char*, int, char*const*, const char*);
+SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap*, char **, const char*, const char*);
+SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap*, const char*, char **, const char*);
+
+#endif
+
+/* End of SOAPEnvH.h */

Added: trunk/Search/SOAPEnvStub.h
===================================================================
--- trunk/Search/SOAPEnvStub.h	2006-04-05 13:58:23 UTC (rev 193)
+++ trunk/Search/SOAPEnvStub.h	2006-04-05 14:09:10 UTC (rev 194)
@@ -0,0 +1,151 @@
+/* SOAPEnvStub.h
+   Generated by gSOAP 2.7.6e from SOAPEnv.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+
+#ifndef SOAPEnvStub_H
+#define SOAPEnvStub_H
+#include "stdsoap2.h"
+
+/******************************************************************************\
+ *                                                                            *
+ * Enumerations                                                               *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Classes and Structs                                                        *
+ *                                                                            *
+\******************************************************************************/
+
+
+#ifndef SOAP_TYPE_SOAP_ENV__Header
+#define SOAP_TYPE_SOAP_ENV__Header (8)
+/* SOAP Header: */
+struct SOAP_ENV__Header
+{
+public:
+	void *dummy;	/* transient */
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Code
+#define SOAP_TYPE_SOAP_ENV__Code (9)
+/* SOAP Fault Code: */
+struct SOAP_ENV__Code
+{
+public:
+	char *SOAP_ENV__Value;	/* optional element of type QName */
+	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Detail
+#define SOAP_TYPE_SOAP_ENV__Detail (11)
+/* SOAP-ENV:Detail */
+struct SOAP_ENV__Detail
+{
+public:
+	int __type;	/* any type of element <fault> (defined below) */
+	void *fault;	/* transient */
+	char *__any;
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Reason
+#define SOAP_TYPE_SOAP_ENV__Reason (12)
+/* SOAP-ENV:Reason */
+struct SOAP_ENV__Reason
+{
+public:
+	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Fault
+#define SOAP_TYPE_SOAP_ENV__Fault (13)
+/* SOAP Fault: */
+struct SOAP_ENV__Fault
+{
+public:
+	char *faultcode;	/* optional element of type QName */
+	char *faultstring;	/* optional element of type xsd:string */
+	char *faultactor;	/* optional element of type xsd:string */
+	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
+	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
+	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
+	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
+	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
+	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
+};
+#endif
+
+/******************************************************************************\
+ *                                                                            *
+ * Types with Custom Serializers                                              *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Typedefs                                                                   *
+ *                                                                            *
+\******************************************************************************/
+
+#ifndef SOAP_TYPE__XML
+#define SOAP_TYPE__XML (4)
+typedef char *_XML;
+#endif
+
+#ifndef SOAP_TYPE__QName
+#define SOAP_TYPE__QName (5)
+typedef char *_QName;
+#endif
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Typedef Synonyms                                                           *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Externals                                                                  *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Service Operations                                                         *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Stubs                                                                      *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Skeletons                                                                  *
+ *                                                                            *
+\******************************************************************************/
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);
+
+#endif
+
+/* End of SOAPEnvStub.h */



From fabricecolin at berlios.de  Fri Apr  7 17:25:27 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 7 Apr 2006 17:25:27 +0200
Subject: [Pinot-svn] r195 - in trunk: . Collect Search
Message-ID: <200604071525.k37FPRNI013077@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-07 17:25:25 +0200 (Fri, 07 Apr 2006)
New Revision: 195

Modified:
   trunk/Collect/Makefile.am
   trunk/Collect/dloadtest.cpp
   trunk/Search/Makefile.am
   trunk/pinot.spec.in
Log:
Renamed pinot_search to pinot-search. Don't package pinot-collect just yet.


Modified: trunk/Collect/Makefile.am
===================================================================
--- trunk/Collect/Makefile.am	2006-04-05 14:09:10 UTC (rev 194)
+++ trunk/Collect/Makefile.am	2006-04-07 15:25:25 UTC (rev 195)
@@ -10,7 +10,7 @@
 
 noinst_LTLIBRARIES = libCollect.la
 
-bin_PROGRAMS = pinot_collect
+bin_PROGRAMS = pinot-collect
 
 pinot_collect_SOURCES = \
 	dloadtest.cpp

Modified: trunk/Collect/dloadtest.cpp
===================================================================
--- trunk/Collect/dloadtest.cpp	2006-04-05 14:09:10 UTC (rev 194)
+++ trunk/Collect/dloadtest.cpp	2006-04-07 15:25:25 UTC (rev 195)
@@ -29,7 +29,7 @@
 {
 	if (argc < 2)
 	{
-		cerr << "Usage: <URL>" << endl;
+		cerr << "Usage: " << argv[0] << " <URL>" << endl;
 		return EXIT_FAILURE;
 	}
 

Modified: trunk/Search/Makefile.am
===================================================================
--- trunk/Search/Makefile.am	2006-04-05 14:09:10 UTC (rev 194)
+++ trunk/Search/Makefile.am	2006-04-07 15:25:25 UTC (rev 195)
@@ -20,7 +20,7 @@
 
 noinst_LTLIBRARIES = @SEARCH_LTLIBRARIES@
 
-bin_PROGRAMS = pinot_search
+bin_PROGRAMS = pinot-search
 
 libSearch_la_SOURCES = \
 	AbstractGenerator.cpp \

Modified: trunk/pinot.spec.in
===================================================================
--- trunk/pinot.spec.in	2006-04-05 14:09:10 UTC (rev 194)
+++ trunk/pinot.spec.in	2006-04-07 15:25:25 UTC (rev 195)
@@ -36,7 +36,7 @@
 Requires: taglib >= 1.4
 
 %description audio-docs 
-The included tokenizer adds support for OGG and MP3 files.
+The included tokenizer adds support for OGG, MP3 and FLAC files.
 
 %package omega 
 Summary: Xapian Omega plugin for Pinot
@@ -87,7 +87,8 @@
 %defattr(-, root, root, -)
 %doc ChangeLog COPYING NEWS README TODO
 %{_bindir}/pinot
-%{_bindir}/pinot_search
+%ghost %{_bindir}/pinot-collect
+%{_bindir}/pinot-search
 %{_datadir}/pinot/index.html
 %{_datadir}/pinot/xapian-powered.png
 %{_datadir}/pinot/metase-gtk2.glade



From fabricecolin at berlios.de  Sun Apr  9 16:47:54 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sun, 9 Apr 2006 16:47:54 +0200
Subject: [Pinot-svn] r196 - trunk
Message-ID: <200604091447.k39ElsST020606@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-09 16:47:53 +0200 (Sun, 09 Apr 2006)
New Revision: 196

Modified:
   trunk/configure.in
Log:
New option --with-gecko=mozilla|firefox should enable to build against Firefox.


Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2006-04-07 15:25:25 UTC (rev 195)
+++ trunk/configure.in	2006-04-09 14:47:53 UTC (rev 196)
@@ -83,6 +83,32 @@
 AC_SUBST(SEARCH_LTLIBRARIES)
 AC_SUBST(SEARCH_LIBS)
 
+dnl Mozilla
+AC_MSG_CHECKING([which Gecko engine to use])
+AC_ARG_WITH(gecko, AS_HELP_STRING(--with-gecko@<:@=mozilla|firefox@:>@,
+   which Gecko engine to use (default: mozilla)))
+gecko=$with_gecko
+if test "x$gecko" = "x"; then
+   gecko="mozilla"
+fi
+AC_MSG_RESULT([$gecko])
+
+PKG_CHECK_MODULES(GECKO, $gecko-xpcom >= 1.4 $gecko-gtkmozembed >= 1.4 )
+dnl Mozilla NSS and NSPR
+AC_PATH_PROG(NSS_CONFIG, nss-config, no)
+if test "$NSS_CONFIG" = "no" ; then
+   PKG_CHECK_MODULES(MOZILLANS, $gecko-nss >= 1.4 $gecko-nspr >= 1.4)
+   MOZILLA_NS_DIR="HAS_MOZILLA_NSS"
+else
+   PKG_CHECK_MODULES(MOZILLANS, nss >= 1.4 nspr >= 1.4)
+   MOZILLA_NS_DIR="HAS_NSS"
+fi
+dnl Location of Mozilla's library directory
+MOZILLA_LIB_DIR="`$PKG_CONFIG --variable=libdir $MOZILLA-gtkmozembed`"
+if test "$MOZILLA_LIB_DIR" = "" ; then
+  MOZILLA_LIB_DIR=/usr/lib/mozilla
+fi
+
 dnl Neon or Curl ?
 AC_MSG_CHECKING(which HTTP library to use)
 AC_ARG_WITH(http, AS_HELP_STRING(--with-http@<:@=neon|curl@:>@,
@@ -126,16 +152,6 @@
 XAPIAN_CFLAGS=`$XAPIAN_CONFIG --cxxflags`
 XAPIAN_LIBS=`$XAPIAN_CONFIG --libs`
 
-dnl Mozilla NSS and NSPR
-AC_PATH_PROG(NSS_CONFIG, nss-config, no)
-if test "$NSS_CONFIG" = "no" ; then
-   PKG_CHECK_MODULES(MOZILLANS, mozilla-nss >= 1.4 mozilla-nspr >= 1.4)
-   MOZILLA_NS_DIR="HAS_MOZILLA_NSS"
-else
-   PKG_CHECK_MODULES(MOZILLANS, nss >= 1.4 nspr >= 1.4)
-   MOZILLA_NS_DIR="HAS_NSS"
-fi
-
 dnl Other libraries
 MISC_LIBS="-lmagic -lcrypt"
 AC_SUBST(MISC_LIBS)
@@ -159,16 +175,9 @@
 INDEX_LIBS="$XAPIAN_LIBS -ltextcat"
 AC_SUBST(INDEX_CFLAGS)
 AC_SUBST(INDEX_LIBS)
-PKG_CHECK_MODULES(UI, mozilla-xpcom >= 1.4 mozilla-gtkmozembed >= 1.4 gtkmm-2.4 >= 2.6 )
-dnl Location of Mozilla's library directory
-MOZILLA_GTKEMBED=`find /usr/lib*/mozilla* -name libgtkembedmoz.so | head -1`
-if test "$MOZILLA_GTKEMBED" = "" ; then
-  MOZILLA_LIB_DIR=/usr/lib/mozilla
-else
-  MOZILLA_LIB_DIR=`dirname $MOZILLA_GTKEMBED`
-fi
-UI_CFLAGS="$MOZILLANS_CFLAGS -D$MOZILLA_NS_DIR $UI_CFLAGS"
-UI_LIBS="-lpthread -lfam -L$MOZILLA_LIB_DIR -Xlinker -rpath -Xlinker $MOZILLA_LIB_DIR $UI_LIBS $MOZILLANS_LIBS"
+PKG_CHECK_MODULES(UI, gtkmm-2.4 >= 2.6 )
+UI_CFLAGS="$MOZILLANS_CFLAGS -D$MOZILLA_NS_DIR $GECKO_CFLAGS $UI_CFLAGS"
+UI_LIBS="-lpthread -lfam -L$MOZILLA_LIB_DIR -Xlinker -rpath -Xlinker $MOZILLA_LIB_DIR $GECKO_LIBS $MOZILLANS_LIBS $UI_LIBS"
 AC_SUBST(UI_CFLAGS)
 AC_SUBST(UI_LIBS)
 



From fabricecolin at berlios.de  Sun Apr  9 16:53:07 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sun, 9 Apr 2006 16:53:07 +0200
Subject: [Pinot-svn] r197 - trunk
Message-ID: <200604091453.k39Er7Js021065@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-09 16:53:06 +0200 (Sun, 09 Apr 2006)
New Revision: 197

Modified:
   trunk/NEWS
   trunk/README
   trunk/TODO
Log:
Updates.


Modified: trunk/NEWS
===================================================================
--- trunk/NEWS	2006-04-09 14:47:53 UTC (rev 196)
+++ trunk/NEWS	2006-04-09 14:53:06 UTC (rev 197)
@@ -1,3 +1,14 @@
+??? version_0_4_6
+Search :
+ - resurrected support for the Google API, enabled with "./configure --with-soap=yes"
+ - tweaked extraction of results' extract and URL
+ - renamed pinot_search to pinot-search
+Tokenize :
+ - new dependency on TagLib to allow extracting track information from MP3, Vorbis
+  and FLAC files
+HTML browser :
+ - can build against Mozilla or Firefox, as set with "./configure --with-gecko=mozilla|firefox"
+
 2006/03/25 version_0_4_5
 Build :
  - various fixes for building on Fedora Core 5

Modified: trunk/README
===================================================================
--- trunk/README	2006-04-09 14:47:53 UTC (rev 196)
+++ trunk/README	2006-04-09 14:53:06 UTC (rev 197)
@@ -26,14 +26,9 @@
 
 Google SOAP API (2)	Search/Google/googleapi		beta2
 
- GSOAP			$GSOAP_HOME			2.6.2
+ GSOAP							2.7.6e
  http://www.cs.fsu.edu/~engelen/soap.html
- eg GSOAP_HOME=/home/fabrice/Projects/gsoap-linux-2.6
 
-ObjectsSearch API (3)	Search/ObjectsSearch		beta
-
- GSOAP			$GSOAP_HOME			2.6.2
-
 gtkmm							2.6.2
 http://www.gtkmm.org/
 
@@ -52,7 +47,7 @@
 gmime							2.1.9
 http://spruce.sourceforge.net/gmime
 
-Mozilla with gtk-mozembed				1.6
+Mozilla's gtk-mozembed (3)				1.4
 http://www.mozilla.org/
 
 boost (4)						1.32.0
@@ -67,12 +62,15 @@
 unrtf							0.19.3
 http://www.gnu.org/software/unrtf/unrtf.html
 
+TagLib							1.4
+http://ktown.kde.org/~wheeler/taglib/
+
 glademm (5)						2.6.0_cvs-SNAP
 http://home.wtal.de/petig/Gtk/index.html
 
 (1) enabled with "./configure --with-http=neon|curl"
-(2) enabled with 'make HAS_GOOGLEAPI=yes'
-(3) enabled with 'make HAS_OSAPI=yes' (now defunct ?)
+(2) enabled with "./configure --with-soap=yes"
+(3) select Mozilla or Firefox with "./configure --with-gecko=mozilla|firefox"
 (4) for building only
 (5) to optionally regenerate the GUI code
 

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-04-09 14:47:53 UTC (rev 196)
+++ trunk/TODO	2006-04-09 14:53:06 UTC (rev 197)
@@ -85,7 +85,6 @@
 - Replace glademm with libglademm ?
 - Show activity when mail is being indexed
 - Update Last Run after the query has completed
-- Add a Recent Import section that relies on documents timestamps
 - Filter documents by language, similarly to how labels are shown
 - Save engines groups state in config file
 - Clean up method names



From fabricecolin at berlios.de  Sun Apr  9 17:15:01 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sun, 9 Apr 2006 17:15:01 +0200
Subject: [Pinot-svn] r198 - trunk
Message-ID: <200604091515.k39FF1N4022765@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-09 17:15:01 +0200 (Sun, 09 Apr 2006)
New Revision: 198

Modified:
   trunk/configure.in
Log:
Fixed MOZILLA_LIB_DIR.


Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2006-04-09 14:53:06 UTC (rev 197)
+++ trunk/configure.in	2006-04-09 15:15:01 UTC (rev 198)
@@ -104,7 +104,7 @@
    MOZILLA_NS_DIR="HAS_NSS"
 fi
 dnl Location of Mozilla's library directory
-MOZILLA_LIB_DIR="`$PKG_CONFIG --variable=libdir $MOZILLA-gtkmozembed`"
+MOZILLA_LIB_DIR="`$PKG_CONFIG --variable=libdir $gecko-gtkmozembed`"
 if test "$MOZILLA_LIB_DIR" = "" ; then
   MOZILLA_LIB_DIR=/usr/lib/mozilla
 fi



From fabricecolin at berlios.de  Mon Apr 10 15:51:39 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Mon, 10 Apr 2006 15:51:39 +0200
Subject: [Pinot-svn] r199 - in trunk: . UI/GTK2
Message-ID: <200604101351.k3ADpdCU025278@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-10 15:50:54 +0200 (Mon, 10 Apr 2006)
New Revision: 199

Added:
   trunk/UI/GTK2/index.html
Removed:
   trunk/index.html
Modified:
   trunk/Makefile.am
Log:
Moved index.html to UI/GTK2.


Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2006-04-09 15:15:01 UTC (rev 198)
+++ trunk/Makefile.am	2006-04-10 13:50:54 UTC (rev 199)
@@ -6,12 +6,12 @@
 
 EXTRA_DIST = ChangeLog NEWS README TODO mkinstalldirs pinot.spec \
 	Search/Plugins/*src Search/Plugins/*.xml \
-	index.html UI/GTK2/xapian-powered.png UI/GTK2/pinot.png \
+	UI/GTK2/index.html UI/GTK2/xapian-powered.png UI/GTK2/pinot.png \
 	textcat_conf.txt UI/GTK2/metase-gtk2.glade UI/GTK2/metase-gtk2.gladep
 
 install-data-local:
 	$(mkinstalldirs) $(DESTDIR)$(datadir)/pinot
-	$(INSTALL_DATA) index.html $(DESTDIR)$(datadir)/pinot/index.html
+	$(INSTALL_DATA) UI/GTK2/index.html $(DESTDIR)$(datadir)/pinot/index.html
 	$(INSTALL_DATA) UI/GTK2/xapian-powered.png $(DESTDIR)$(datadir)/pinot/xapian-powered.png
 	$(INSTALL_DATA) UI/GTK2/metase-gtk2.glade $(DESTDIR)$(datadir)/pinot/metase-gtk2.glade
 	$(INSTALL_DATA) UI/GTK2/metase-gtk2.gladep $(DESTDIR)$(datadir)/pinot/metase-gtk2.gladep

Copied: trunk/UI/GTK2/index.html (from rev 177, trunk/index.html)

Deleted: trunk/index.html
===================================================================
--- trunk/index.html	2006-04-09 15:15:01 UTC (rev 198)
+++ trunk/index.html	2006-04-10 13:50:54 UTC (rev 199)
@@ -1,29 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
-<HTML>
-<html>
-<head><title>Welcome to Pinot !</title>
-</head>
-<body bgcolor="#ffffff" text="#000000" link="#c80000" vlink="#900000" alink="#ea5b1a">
-
-<table width="100%">
-<tr>
-<td colspan="3" align="center">
-<strong>Welcome to Pinot !</strong>
-</td>
-</tr>
-
-<tr>
-<td colspan="3" align="center">
-Visit the web site at
-<a href="http://pinot.berlios.de/">pinot.berlios.de</a>.
-</td>
-</tr>
-
-<tr>
-<td valign="top" align="center">
-<img src="xapian-powered.png" alt="Powered By Xapian Logo" width="208" height="30">
-</td>
-</tr>
-
-</body>
-</html>



From fabricecolin at berlios.de  Tue Apr 11 16:22:10 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 11 Apr 2006 16:22:10 +0200
Subject: [Pinot-svn] r200 - trunk/UI/GTK2/src
Message-ID: <200604111422.k3BEMAcL005422@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-11 16:21:52 +0200 (Tue, 11 Apr 2006)
New Revision: 200

Modified:
   trunk/UI/GTK2/src/importDialog.cc
Log:
Disable the symlinks button when type URl is selected.


Modified: trunk/UI/GTK2/src/importDialog.cc
===================================================================
--- trunk/UI/GTK2/src/importDialog.cc	2006-04-10 13:50:54 UTC (rev 199)
+++ trunk/UI/GTK2/src/importDialog.cc	2006-04-11 14:21:52 UTC (rev 200)
@@ -394,6 +394,7 @@
 	// FIXME: this could also apply to URLs !
 	depthSpinbutton->set_sensitive(m_importDirectory);
 	locationButton->set_sensitive(selectLocation);
+	linksCheckbutton->set_sensitive(selectLocation);
 }
 
 void importDialog::on_locationEntry_changed()



From fabricecolin at berlios.de  Tue Apr 11 16:23:20 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 11 Apr 2006 16:23:20 +0200
Subject: [Pinot-svn] r201 - trunk/Search/Google
Message-ID: <200604111423.k3BENKmo007857@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-11 16:22:50 +0200 (Tue, 11 Apr 2006)
New Revision: 201

Modified:
   trunk/Search/Google/GAPIStub.h
Log:
Added missing header.


Modified: trunk/Search/Google/GAPIStub.h
===================================================================
--- trunk/Search/Google/GAPIStub.h	2006-04-11 14:21:52 UTC (rev 200)
+++ trunk/Search/Google/GAPIStub.h	2006-04-11 14:22:50 UTC (rev 201)
@@ -7,6 +7,7 @@
 
 #ifndef GAPIStub_H
 #define GAPIStub_H
+#include <string>
 #include <vector>
 #define WITH_NONAMESPACES
 #include "stdsoap2.h"



From fabricecolin at berlios.de  Wed Apr 12 15:52:53 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 12 Apr 2006 15:52:53 +0200
Subject: [Pinot-svn] r202 - trunk/Search/Google
Message-ID: <200604121352.k3CDqrjK006937@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-12 15:52:49 +0200 (Wed, 12 Apr 2006)
New Revision: 202

Modified:
   trunk/Search/Google/GoogleAPIEngine.cpp
Log:
Extra checks.


Modified: trunk/Search/Google/GoogleAPIEngine.cpp
===================================================================
--- trunk/Search/Google/GoogleAPIEngine.cpp	2006-04-11 14:22:50 UTC (rev 201)
+++ trunk/Search/Google/GoogleAPIEngine.cpp	2006-04-12 13:52:49 UTC (rev 202)
@@ -114,7 +114,6 @@
 	struct gapi1__doGoogleSearchResponse queryOut;
 
 	// No filter, no safe search
-	// std::string key, std::string q, int start, int maxResults, bool filter, std::string restrict_, bool safeSearch, std::string lr, std::string ie, std::string oe, struct gapi1__doGoogleSearchResponse &_param_1
 	int soapStatus = soapProxy.gapi1__doGoogleSearch(m_key, andTerms, 0, (int)(m_maxResultsCount > 10 ? 10 : m_maxResultsCount),
 		((phrase.empty() == false) ? true : false), phrase, false, "", "utf-8", "utf-8", queryOut);
 	if (soapStatus != SOAP_OK)
@@ -126,17 +125,22 @@
 	}
 
 	struct gapi1__GoogleSearchResult *searchResult = queryOut.return_;
-	float pseudoScore = 100;
 
-	for (int i = 0; i < searchResult->resultElements->__size; i++)
+	if ((searchResult != NULL) &&
+		(searchResult->resultElements != NULL))
 	{
-		struct gapi1__ResultElement *resultElement = searchResult->resultElements->__ptr[i];
+		float pseudoScore = 100;
 
-		string resultUrl(resultElement->URL);
-		if (processResult("http://www.google.com/", resultUrl) == true)
+		for (int i = 0; i < searchResult->resultElements->__size; ++i)
 		{
-			m_resultsList.push_back(Result(resultUrl, resultElement->title, resultElement->snippet, "", pseudoScore));
-			--pseudoScore;
+			struct gapi1__ResultElement *resultElement = searchResult->resultElements->__ptr[i];
+
+			string resultUrl(resultElement->URL);
+			if (processResult("http://www.google.com/", resultUrl) == true)
+			{
+				m_resultsList.push_back(Result(resultUrl, resultElement->title, resultElement->snippet, "", pseudoScore));
+				--pseudoScore;
+			}
 		}
 	}
 



From fabricecolin at berlios.de  Wed Apr 12 15:55:31 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 12 Apr 2006 15:55:31 +0200
Subject: [Pinot-svn] r203 - trunk/UI/RenderHTML
Message-ID: <200604121355.k3CDtVAS010103@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-12 15:55:28 +0200 (Wed, 12 Apr 2006)
New Revision: 203

Modified:
   trunk/UI/RenderHTML/MozillaRenderer.cpp
Log:
Set scrollbars flag on.


Modified: trunk/UI/RenderHTML/MozillaRenderer.cpp
===================================================================
--- trunk/UI/RenderHTML/MozillaRenderer.cpp	2006-04-12 13:52:49 UTC (rev 202)
+++ trunk/UI/RenderHTML/MozillaRenderer.cpp	2006-04-12 13:55:28 UTC (rev 203)
@@ -65,7 +65,7 @@
 	if (m_htmlWidget != NULL)
 	{
 		// Turn off all features
-		gtk_moz_embed_set_chrome_mask(GTK_MOZ_EMBED(m_htmlWidget), 0);
+		gtk_moz_embed_set_chrome_mask(GTK_MOZ_EMBED(m_htmlWidget), GTK_MOZ_EMBED_FLAG_SCROLLBARSON);
 #ifdef DEBUG
 		cout << "MozillaRenderer::ctor: embedded Mozilla" << endl;
 #endif



From fabricecolin at berlios.de  Wed Apr 12 16:01:48 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 12 Apr 2006 16:01:48 +0200
Subject: [Pinot-svn] r204 - in trunk: Index Utils
Message-ID: <200604121401.k3CE1mLb021625@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-12 16:01:47 +0200 (Wed, 12 Apr 2006)
New Revision: 204

Modified:
   trunk/Index/XapianIndex.cpp
   trunk/Utils/StringManip.cpp
   trunk/Utils/StringManip.h
Log:
StringManip::hashString() now uses same hash algorithm as omindex/scriptindex.
Maximum term length increased to 240.


Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2006-04-12 13:55:28 UTC (rev 203)
+++ trunk/Index/XapianIndex.cpp	2006-04-12 14:01:47 UTC (rev 204)
@@ -42,7 +42,7 @@
 using std::min;
 
 // This puts a limit to terms length.
-const unsigned int XapianIndex::m_maxTermLength = 128;
+const unsigned int XapianIndex::m_maxTermLength = 240;
 const string XapianIndex::MAGIC_TERM = "X-MetaSE-Doc";
 
 XapianIndex::XapianIndex(const string &indexName) :
@@ -76,11 +76,7 @@
 		}
 		else
 		{
-			string base(term.substr(0, XapianIndex::m_maxTermLength - 30));
-
-			base += StringManip::hashString(term);
-
-			return base;
+			return StringManip::hashString(term, XapianIndex::m_maxTermLength);
 		}
 	}
 

Modified: trunk/Utils/StringManip.cpp
===================================================================
--- trunk/Utils/StringManip.cpp	2006-04-12 13:55:28 UTC (rev 203)
+++ trunk/Utils/StringManip.cpp	2006-04-12 14:01:47 UTC (rev 204)
@@ -25,7 +25,7 @@
 using std::string;
 using std::for_each;
 
-#define CRYPT_SALT "$1$ajfpehom$"
+static const unsigned int HASH_LEN = ((4 * 8 + 5) / 6);
 
 // A function object to lower case strings with for_each()
 struct ToLower
@@ -178,24 +178,46 @@
 /// Hashes a string.
 string StringManip::hashString(const string &str)
 {
+	unsigned long int h = 1;
+
 	if (str.empty() == true)
 	{
 		return "";
 	}
 
-	char *hashedString = crypt(str.c_str(), CRYPT_SALT);
-	if (hashedString == NULL)
+	// The following was lifed from Xapian's xapian-applications/omega/hashterm.cc
+	// and prettified slightly
+	for (string::const_iterator i = str.begin(); i != str.end(); ++i)
 	{
-		return NULL;
+		h += (h << 5) + static_cast<unsigned char>(*i);
 	}
+	// In case sizeof(unsigned long) > 4
+	h &= 0xffffffff;
 
-	if (strlen(hashedString) > strlen(CRYPT_SALT))
+	string hashedString(HASH_LEN, ' ');
+	int i = 0;
+	while (h != 0)
 	{
-		if (strncmp(hashedString, CRYPT_SALT, strlen(CRYPT_SALT)) == 0)
-		{
-			return hashedString + strlen(CRYPT_SALT);
-		}
+		char ch = char((h & 63) + 33);
+		hashedString[i++] = ch;
+		h = h >> 6;
 	}
 
 	return hashedString;
 }
+
+/// Hashes a string so that it is no longer than maxLength.
+string StringManip::hashString(const string &str, unsigned int maxLength)
+{
+	if (str.length() <= maxLength)
+	{
+		return str;
+	}
+
+	string result(str);
+	maxLength -= HASH_LEN;
+	result.replace(maxLength, string::npos,
+		hashString(result.substr(maxLength)));
+
+	return result;
+}

Modified: trunk/Utils/StringManip.h
===================================================================
--- trunk/Utils/StringManip.h	2006-04-12 13:55:28 UTC (rev 203)
+++ trunk/Utils/StringManip.h	2006-04-12 14:01:47 UTC (rev 204)
@@ -46,6 +46,9 @@
 		/// Hashes a string.
 		static std::string hashString(const std::string &str);
 
+		/// Hashes a string so that it is no longer than maxLength.
+		static std::string hashString(const std::string &str, unsigned int maxLength);
+
 	protected:
 		StringManip();
 



From fabricecolin at berlios.de  Wed Apr 12 16:24:03 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 12 Apr 2006 16:24:03 +0200
Subject: [Pinot-svn] r205 - trunk
Message-ID: <200604121424.k3CEO3Lr031727@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-12 16:24:01 +0200 (Wed, 12 Apr 2006)
New Revision: 205

Modified:
   trunk/Makefile.am
   trunk/pinot.spec.in
Log:
AmazonAPI source is not installed in the engines directory.
The RPM can be built with "--with soap", which adds requirement on gsoap.


Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2006-04-12 14:01:47 UTC (rev 204)
+++ trunk/Makefile.am	2006-04-12 14:24:01 UTC (rev 205)
@@ -18,6 +18,7 @@
 	$(INSTALL_DATA) textcat_conf.txt $(DESTDIR)$(datadir)/pinot/textcat_conf.txt
 	$(mkinstalldirs) $(DESTDIR)$(datadir)/pinot/engines
 	$(INSTALL_DATA) Search/Plugins/*.src $(DESTDIR)$(datadir)/pinot/engines/
+	mv $(DESTDIR)$(datadir)/pinot/engines/AmazonAPI.src $(DESTDIR)$(datadir)/pinot/
 	$(INSTALL_DATA) Search/Plugins/*.xml $(DESTDIR)$(datadir)/pinot/engines/
 	$(mkinstalldirs) $(DESTDIR)$(datadir)/pinot/tokenizers
 	@rm -f $(DESTDIR)$(libdir)/lib*tokenizer.*

Modified: trunk/pinot.spec.in
===================================================================
--- trunk/pinot.spec.in	2006-04-12 14:01:47 UTC (rev 204)
+++ trunk/pinot.spec.in	2006-04-12 14:24:01 UTC (rev 205)
@@ -13,6 +13,9 @@
 BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
 Requires: xapian-core-libs >= 0.9.4, curl >= 7.13, gtkmm24 >= 2.6, libxml++ >= 2.12, mozilla >= %{mozilla_ver}, sqlite >= 3.1.2, libtextcat >= 2.2, fam >= 2.6.10, gmime >= 2.1, file
 BuildRequires: xapian-core-devel >= 0.9.4, curl-devel >= 7.13, gtkmm24-devel >= 2.6, libxml++-devel >= 2.12, mozilla-devel >= %{mozilla_ver}, sqlite-devel >= 3.1.2, libtextcat-devel >= 2.2, fam-devel >= 2.6.10, gmime-devel >= 2.1, taglib-devel >= 1.4, boost-devel >= 1.32, gettext-devel, desktop-file-utils
+%if 0%{?_with_soap:1}
+BuildRequires: gsoap
+%endif
 
 %description
 Pinot is a metasearch tool for the Free Desktop. It enables one to query
@@ -51,14 +54,12 @@
 %setup -q
 
 %build
-%configure
+%configure %{?_with_soap:--with-soap=yes}
 make
 
 %install
 [ -n "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf $RPM_BUILD_ROOT
 %makeinstall
-# This engine is not usable as it is
-mv $RPM_BUILD_ROOT/%{_datadir}/pinot/engines/AmazonAPI.src $RPM_BUILD_ROOT/%{_datadir}/pinot/
 # Desktop file
 cat >%{name}.desktop << EOF
 [Desktop Entry]



From fabricecolin at berlios.de  Wed Apr 12 17:23:49 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Wed, 12 Apr 2006 17:23:49 +0200
Subject: [Pinot-svn] r206 - trunk/Search/Google
Message-ID: <200604121523.k3CFNnBF005685@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-12 17:23:48 +0200 (Wed, 12 Apr 2006)
New Revision: 206

Modified:
   trunk/Search/Google/GAPIC.cpp
Log:
Removed calls to DBGLOG().


Modified: trunk/Search/Google/GAPIC.cpp
===================================================================
--- trunk/Search/Google/GAPIC.cpp	2006-04-12 14:24:01 UTC (rev 205)
+++ trunk/Search/Google/GAPIC.cpp	2006-04-12 15:23:48 UTC (rev 206)
@@ -320,12 +320,10 @@
 			return soap->error = SOAP_TAG_MISMATCH;
 		if (!*soap->id || !soap_getelement(soap, &t))
 		{	soap->peeked = 0;
-			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
 			if (soap->fignore)
 				soap->error = soap->fignore(soap, soap->tag);
 			else
 				soap->error = SOAP_OK;
-			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
 			if (!soap->error && soap->body)
 			{	soap->level++;
 				while (!soap_ignore_element(soap))
@@ -673,7 +671,7 @@
 {	switch (tt)
 	{
 	default:
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
+		break;
 	}
 }
 
@@ -1048,7 +1046,6 @@
 
 SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_instantiate_gapi1__DirectoryCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__DirectoryCategory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__DirectoryCategory, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -1065,13 +1062,11 @@
 		for (int i = 0; i < n; i++)
 			((gapi1__DirectoryCategory*)cp->ptr)[i].soap = soap;
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (gapi1__DirectoryCategory*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__DirectoryCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gapi1__DirectoryCategory %p -> %p\n", q, p));
 	*(gapi1__DirectoryCategory*)p = *(gapi1__DirectoryCategory*)q;
 }
 
@@ -1215,7 +1210,6 @@
 
 SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_instantiate_gapi1DirectoryCategoryArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1DirectoryCategoryArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1DirectoryCategoryArray, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -1232,13 +1226,11 @@
 		for (int i = 0; i < n; i++)
 			((gapi1DirectoryCategoryArray*)cp->ptr)[i].soap = soap;
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (gapi1DirectoryCategoryArray*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1DirectoryCategoryArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gapi1DirectoryCategoryArray %p -> %p\n", q, p));
 	*(gapi1DirectoryCategoryArray*)p = *(gapi1DirectoryCategoryArray*)q;
 }
 
@@ -1382,7 +1374,6 @@
 
 SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_instantiate_gapi1ResultElementArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1ResultElementArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1ResultElementArray, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -1399,13 +1390,11 @@
 		for (int i = 0; i < n; i++)
 			((gapi1ResultElementArray*)cp->ptr)[i].soap = soap;
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (gapi1ResultElementArray*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1ResultElementArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gapi1ResultElementArray %p -> %p\n", q, p));
 	*(gapi1ResultElementArray*)p = *(gapi1ResultElementArray*)q;
 }
 
@@ -1582,7 +1571,6 @@
 
 SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_instantiate_gapi1__ResultElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__ResultElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__ResultElement, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -1599,13 +1587,11 @@
 		for (int i = 0; i < n; i++)
 			((gapi1__ResultElement*)cp->ptr)[i].soap = soap;
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (gapi1__ResultElement*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__ResultElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gapi1__ResultElement %p -> %p\n", q, p));
 	*(gapi1__ResultElement*)p = *(gapi1__ResultElement*)q;
 }
 
@@ -1793,7 +1779,6 @@
 
 SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_instantiate_gapi1__GoogleSearchResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__GoogleSearchResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__GoogleSearchResult, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -1810,13 +1795,11 @@
 		for (int i = 0; i < n; i++)
 			((gapi1__GoogleSearchResult*)cp->ptr)[i].soap = soap;
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (gapi1__GoogleSearchResult*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__GoogleSearchResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gapi1__GoogleSearchResult %p -> %p\n", q, p));
 	*(gapi1__GoogleSearchResult*)p = *(gapi1__GoogleSearchResult*)q;
 }
 
@@ -1888,7 +1871,6 @@
 
 SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate__SOAP_ENC__arrayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__SOAP_ENC__arrayType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__SOAP_ENC__arrayType, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -1902,13 +1884,11 @@
 		if (size)
 			*size = n * sizeof(std::string);
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (std::string*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy__SOAP_ENC__arrayType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
 	*(std::string*)p = *(std::string*)q;
 }
 
@@ -1981,7 +1961,6 @@
 
 SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -1995,13 +1974,11 @@
 		if (size)
 			*size = n * sizeof(std::string);
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (std::string*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
 	*(std::string*)p = *(std::string*)q;
 }
 
@@ -2105,7 +2082,6 @@
 
 SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -2122,13 +2098,11 @@
 		for (int i = 0; i < n; i++)
 			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (xsd__base64Binary*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
 	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
 }
 
@@ -2284,7 +2258,6 @@
 
 SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -2298,13 +2271,11 @@
 		if (size)
 			*size = n * sizeof(struct SOAP_ENV__Fault);
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (struct SOAP_ENV__Fault*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
 	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
 }
 
@@ -2397,7 +2368,6 @@
 
 SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -2411,13 +2381,11 @@
 		if (size)
 			*size = n * sizeof(struct SOAP_ENV__Reason);
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (struct SOAP_ENV__Reason*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
 	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
 }
 
@@ -2518,7 +2486,6 @@
 
 SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -2532,13 +2499,11 @@
 		if (size)
 			*size = n * sizeof(struct SOAP_ENV__Detail);
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (struct SOAP_ENV__Detail*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
 	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
 }
 
@@ -2640,7 +2605,6 @@
 
 SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -2654,13 +2618,11 @@
 		if (size)
 			*size = n * sizeof(struct SOAP_ENV__Code);
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (struct SOAP_ENV__Code*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
 	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
 }
 
@@ -2748,7 +2710,6 @@
 
 SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -2762,13 +2723,11 @@
 		if (size)
 			*size = n * sizeof(struct SOAP_ENV__Header);
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (struct SOAP_ENV__Header*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
 	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
 }
 
@@ -2931,7 +2890,6 @@
 
 SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_instantiate_gapi1__doGoogleSearch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__doGoogleSearch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doGoogleSearch, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -2945,13 +2903,11 @@
 		if (size)
 			*size = n * sizeof(struct gapi1__doGoogleSearch);
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (struct gapi1__doGoogleSearch*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGoogleSearch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct gapi1__doGoogleSearch %p -> %p\n", q, p));
 	*(struct gapi1__doGoogleSearch*)p = *(struct gapi1__doGoogleSearch*)q;
 }
 
@@ -3042,7 +2998,6 @@
 
 SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_instantiate_gapi1__doGoogleSearchResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__doGoogleSearchResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doGoogleSearchResponse, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -3056,13 +3011,11 @@
 		if (size)
 			*size = n * sizeof(struct gapi1__doGoogleSearchResponse);
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (struct gapi1__doGoogleSearchResponse*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGoogleSearchResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct gapi1__doGoogleSearchResponse %p -> %p\n", q, p));
 	*(struct gapi1__doGoogleSearchResponse*)p = *(struct gapi1__doGoogleSearchResponse*)q;
 }
 
@@ -3163,7 +3116,6 @@
 
 SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_instantiate_gapi1__doSpellingSuggestion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__doSpellingSuggestion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doSpellingSuggestion, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -3177,13 +3129,11 @@
 		if (size)
 			*size = n * sizeof(struct gapi1__doSpellingSuggestion);
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (struct gapi1__doSpellingSuggestion*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doSpellingSuggestion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct gapi1__doSpellingSuggestion %p -> %p\n", q, p));
 	*(struct gapi1__doSpellingSuggestion*)p = *(struct gapi1__doSpellingSuggestion*)q;
 }
 
@@ -3277,7 +3227,6 @@
 
 SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_instantiate_gapi1__doSpellingSuggestionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__doSpellingSuggestionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doSpellingSuggestionResponse, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -3291,13 +3240,11 @@
 		if (size)
 			*size = n * sizeof(struct gapi1__doSpellingSuggestionResponse);
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (struct gapi1__doSpellingSuggestionResponse*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doSpellingSuggestionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct gapi1__doSpellingSuggestionResponse %p -> %p\n", q, p));
 	*(struct gapi1__doSpellingSuggestionResponse*)p = *(struct gapi1__doSpellingSuggestionResponse*)q;
 }
 
@@ -3398,7 +3345,6 @@
 
 SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_instantiate_gapi1__doGetCachedPage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__doGetCachedPage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doGetCachedPage, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -3412,13 +3358,11 @@
 		if (size)
 			*size = n * sizeof(struct gapi1__doGetCachedPage);
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (struct gapi1__doGetCachedPage*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGetCachedPage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct gapi1__doGetCachedPage %p -> %p\n", q, p));
 	*(struct gapi1__doGetCachedPage*)p = *(struct gapi1__doGetCachedPage*)q;
 }
 
@@ -3512,7 +3456,6 @@
 
 SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_instantiate_gapi1__doGetCachedPageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gapi1__doGetCachedPageResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
 	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doGetCachedPageResponse, n, soap_fdelete);
 	if (!cp)
 		return NULL;
@@ -3526,13 +3469,11 @@
 		if (size)
 			*size = n * sizeof(struct gapi1__doGetCachedPageResponse);
 	}
-		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
 	return (struct gapi1__doGetCachedPageResponse*)cp->ptr;
 }
 
 SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGetCachedPageResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
 {
-	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct gapi1__doGetCachedPageResponse %p -> %p\n", q, p));
 	*(struct gapi1__doGetCachedPageResponse*)p = *(struct gapi1__doGetCachedPageResponse*)q;
 }
 



From fabricecolin at berlios.de  Thu Apr 13 15:19:05 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Thu, 13 Apr 2006 15:19:05 +0200
Subject: [Pinot-svn] r207 - trunk/UI/GTK2/src
Message-ID: <200604131319.k3DDJ5fq019038@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-13 15:18:51 +0200 (Thu, 13 Apr 2006)
New Revision: 207

Modified:
   trunk/UI/GTK2/src/mainWindow.cc
Log:
Hide the View Cache menuitem if the Google API key is not set.


Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2006-04-12 15:23:48 UTC (rev 206)
+++ trunk/UI/GTK2/src/mainWindow.cc	2006-04-13 13:18:51 UTC (rev 207)
@@ -224,7 +224,8 @@
 	groupresults1->set_sensitive(false);
 	viewresults1->set_sensitive(false);
 	// Hide the View Cache menu item ?
-	if (SearchEngineFactory::isSupported("googleapi") == false)
+	if ((SearchEngineFactory::isSupported("googleapi") == false) ||
+		(m_settings.m_googleAPIKey.empty() == true))
 	{
 		viewcache1->hide();
 	}
@@ -1282,6 +1283,17 @@
 		m_state.unlock_lists();
 	}
 
+	// Hide the View Cache menu item ?
+	if ((SearchEngineFactory::isSupported("googleapi") == false) ||
+		(m_settings.m_googleAPIKey.empty() == true))
+	{
+		viewcache1->hide();
+	}
+	else
+	{
+		viewcache1->show();
+	}
+
 	// Do the changes affect the View tab ?
 	if (useExternalBrowser != m_settings.m_browseResults)
 	{



From fabricecolin at berlios.de  Fri Apr 14 07:59:10 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 14 Apr 2006 07:59:10 +0200
Subject: [Pinot-svn] r208 - trunk/Utils
Message-ID: <200604140559.k3E5xAwJ024990@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-14 07:59:03 +0200 (Fri, 14 Apr 2006)
New Revision: 208

Modified:
   trunk/Utils/StringManip.cpp
   trunk/Utils/StringManip.h
Log:
New method replaceEntities(), taken from HtmlTokenizer.


Modified: trunk/Utils/StringManip.cpp
===================================================================
--- trunk/Utils/StringManip.cpp	2006-04-13 13:18:51 UTC (rev 207)
+++ trunk/Utils/StringManip.cpp	2006-04-14 05:59:03 UTC (rev 208)
@@ -95,6 +95,62 @@
 	return fieldValue;
 }
 
+/// Replaces entities.
+string StringManip::replaceEntities(const string &str)
+{
+	// FIXME: replace all
+	static const char *escapedChars[] = { "quot", "amp", "lt", "gt", "nbsp", "eacute", "egrave", "agrave", "ccedil"};
+	static const char *unescapedChars[] = { "\"", "&", "<", ">", " ", "e", "e", "a", "c"};
+	static const unsigned int escapedCharsCount = 9;
+	string unescapedStr;
+	string::size_type startPos = 0;
+
+	string::size_type pos = str.find("&");
+	while (pos != string::npos)
+	{
+		unescapedStr += str.substr(startPos, pos - startPos);
+
+		startPos = pos + 1;
+		pos = str.find(";", startPos);
+		if ((pos != string::npos) &&
+			(pos < startPos + 10))
+		{
+			string escapedChar = str.substr(startPos, pos - startPos);
+			bool replacedChar = false;
+
+			// See if we can replace this with an actual character
+			for (unsigned int count = 0; count < escapedCharsCount; ++count)
+			{
+				if (escapedChar == escapedChars[count])
+				{
+					unescapedStr += unescapedChars[count];
+					replacedChar = true;
+					break;
+				}
+			}
+
+			if (replacedChar == false)
+			{
+				// This couldn't be replaced, leave it as it is...
+				unescapedStr += "&";
+				unescapedStr += escapedChar;
+				unescapedStr += ";";
+			}
+
+			startPos = pos + 1;
+		}
+
+		// Next
+		pos = str.find("&", startPos);
+	}
+	if (startPos < str.length())
+	{
+		unescapedStr  += str.substr(startPos);
+	}
+
+	return unescapedStr;
+}
+
 /// Replaces a sub-string.
 string StringManip::replaceSubString(const string &str, const std::string &substr, const std::string &rep)
 {

Modified: trunk/Utils/StringManip.h
===================================================================
--- trunk/Utils/StringManip.h	2006-04-13 13:18:51 UTC (rev 207)
+++ trunk/Utils/StringManip.h	2006-04-14 05:59:03 UTC (rev 208)
@@ -33,6 +33,9 @@
 		static std::string extractField(const std::string &str, const std::string &start,
 			const std::string &end, std::string::size_type &endPos);
 
+		/// Replaces entities.
+		static std::string replaceEntities(const std::string &str);
+
 		/// Replaces a sub-string.
 		static std::string replaceSubString(const std::string &str, const std::string &substr,
 			const std::string &rep);



From fabricecolin at berlios.de  Fri Apr 14 08:03:56 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 14 Apr 2006 08:03:56 +0200
Subject: [Pinot-svn] r209 - trunk/Tokenize
Message-ID: <200604140603.k3E63upc025711@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-14 08:03:52 +0200 (Fri, 14 Apr 2006)
New Revision: 209

Added:
   trunk/Tokenize/XmlTokenizer.cpp
   trunk/Tokenize/XmlTokenizer.h
Modified:
   trunk/Tokenize/HtmlTokenizer.cpp
   trunk/Tokenize/HtmlTokenizer.h
   trunk/Tokenize/Makefile.am
   trunk/Tokenize/PdfTokenizer.cpp
   trunk/Tokenize/PdfTokenizer.h
   trunk/Tokenize/RtfTokenizer.cpp
   trunk/Tokenize/RtfTokenizer.h
   trunk/Tokenize/TagLibTokenizer.cpp
   trunk/Tokenize/TagLibTokenizer.h
   trunk/Tokenize/Tokenizer.cpp
   trunk/Tokenize/Tokenizer.h
   trunk/Tokenize/TokenizerFactory.cpp
   trunk/Tokenize/TokenizerFactory.h
   trunk/Tokenize/WordTokenizer.cpp
   trunk/Tokenize/WordTokenizer.h
Log:
New tokenizers for xml and StarOffice/OpenOffice documents. The latter relies
on the former and needs unzip to extract specific files.
Modified tokenizer libraries interface slightly to make it easier for those
that support more than one type.


Modified: trunk/Tokenize/HtmlTokenizer.cpp
===================================================================
--- trunk/Tokenize/HtmlTokenizer.cpp	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/HtmlTokenizer.cpp	2006-04-14 06:03:52 UTC (rev 209)
@@ -27,7 +27,12 @@
 
 //#define DEBUG_TOKENIZER
 
-using namespace std;
+using std::cout;
+using std::endl;
+using std::string;
+using std::map;
+using std::set;
+using std::stack;
 
 HtmlTokenizer::HtmlTokenizer(const Document *pDocument, unsigned int linksStartAtPos) :
 	Tokenizer(NULL),
@@ -123,7 +128,7 @@
 			string text = str.substr(startPos, pos - startPos);
 			if (catText == true)
 			{
-				stripped += replaceEscapedCharacters(text);
+				stripped += StringManip::replaceEntities(text);
 				stripped += " ";
 			}
 
@@ -276,7 +281,7 @@
 	if ((startPos < str.length()) &&
 		(catText == true))
 	{
-		stripped  += replaceEscapedCharacters(str.substr(startPos));
+		stripped  += StringManip::replaceEntities(str.substr(startPos));
 	}
 
 	// Free the compiled regexps
@@ -315,68 +320,6 @@
 	return false;
 }
 
-/// Replaces escaped characters
-string HtmlTokenizer::replaceEscapedCharacters(const string &str)
-{
-	// FIXME: replace all escaped characters !
-	static const char *escapedChars[] = { "quot", "amp", "lt", "gt", "nbsp", "eacute", "egrave", "agrave", "ccedil"};
-	static const char *unescapedChars[] = { "\"", "&", "<", ">", " ", "e", "e", "a", "c"};
-	static const unsigned int escapedCharsCount = 9;
-	string unescaped;
-	string::size_type startPos = 0, pos = 0;
-
-#ifdef DEBUG_TOKENIZER
-	cout << "HtmlTokenizer::replaceEscapedCharacters: input " << str << endl;
-#endif
-	pos = str.find("&");
-	while (pos != string::npos)
-	{
-		unescaped += str.substr(startPos, pos - startPos);
-
-		startPos = pos + 1;
-		pos = str.find(";", startPos);
-		if ((pos != string::npos) &&
-			(pos < startPos + 10))
-		{
-			string escapedChar = str.substr(startPos, pos - startPos);
-			bool replacedChar = false;
-
-			// See if we can replace this with an actual character
-			for (unsigned int count = 0; count < escapedCharsCount; ++count)
-			{
-				if (escapedChar == escapedChars[count])
-				{
-					unescaped += unescapedChars[count];
-					replacedChar = true;
-					break;
-				}
-			}
-
-			if (replacedChar == false)
-			{
-				// This couldn't be replaced, leave it as it is...
-				unescaped += "&";
-				unescaped += escapedChar;
-				unescaped += ";";
-			}
-
-			startPos = pos + 1;
-		}
-
-		// Next
-		pos = str.find("&", startPos);
-	}
-	if (startPos < str.length())
-	{
-		unescaped  += str.substr(startPos);
-	}
-#ifdef DEBUG_TOKENIZER
-	cout << "HtmlTokenizer::replaceEscapedCharacters: output " << unescaped << endl;
-#endif
-
-	return unescaped;
-}
-
 /// Gets the specified META tag content.
 string HtmlTokenizer::getMetaTag(const string &name)
 {

Modified: trunk/Tokenize/HtmlTokenizer.h
===================================================================
--- trunk/Tokenize/HtmlTokenizer.h	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/HtmlTokenizer.h	2006-04-14 06:03:52 UTC (rev 209)
@@ -25,12 +25,11 @@
 #include "Document.h"
 #include "Tokenizer.h"
 
-using namespace std;
-
 class Link
 {
 	public:
-		Link(const string &url, const string &name, unsigned int pos, unsigned int openPos, unsigned int closePos);
+		Link(const std::string &url, const std::string &name,
+			unsigned int pos, unsigned int openPos, unsigned int closePos);
 		Link(const Link &other);
 		~Link();
 
@@ -38,8 +37,8 @@
 		bool operator==(const Link &other) const;
 		bool operator<(const Link &other) const;
 
-		string m_url;
-		string m_name;
+		std::string m_url;
+		std::string m_name;
 		unsigned int m_pos;
 		unsigned int m_open;
 		unsigned int m_close;
@@ -53,36 +52,33 @@
 		virtual ~HtmlTokenizer();
 
 		/// Gets the specified META tag content; an empty string if it wasn't found.
-		string getMetaTag(const string &name);
+		std::string getMetaTag(const std::string &name);
 
 		/// Gets the links map.
-		set<Link> &getLinks(void);
+		std::set<Link> &getLinks(void);
 
 		/// Utility method that strips HTML tags off; the string without tags.
-		static string stripTags(const string &str);
+		static std::string stripTags(const std::string &str);
 
 	protected:
 		const Document *m_pHtmlDocument;
 		unsigned int m_linkPos;
-		map<string, string> m_metaTags;
-		set<Link> m_links;
+		std::map<std::string, std::string> m_metaTags;
+		std::set<Link> m_links;
 
 		HtmlTokenizer();
 
 		void initialize(const Document *pDocument);
 
 		/// Parses HTML; the string without tags.
-		string parseHTML(const string &str, bool stripAllBlocks = false);
+		std::string parseHTML(const std::string &str, bool stripAllBlocks = false);
 
 		/// Returns true if the tag corresponds to a text block.
-		static bool textBlockStart(const string &tag);
+		static bool textBlockStart(const std::string &tag);
 
 		/// Returns true if the tag corresponds to the end of a text block.
-		static bool textBlockEnd(const string &tag);
+		static bool textBlockEnd(const std::string &tag);
 
-		/// Replaces escaped characters
-		static string replaceEscapedCharacters(const string &str);
-
 };
 
 #endif // _HTML_TOKENIZER_H

Modified: trunk/Tokenize/Makefile.am
===================================================================
--- trunk/Tokenize/Makefile.am	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/Makefile.am	2006-04-14 06:03:52 UTC (rev 209)
@@ -9,19 +9,30 @@
 
 noinst_HEADERS = \
 	HtmlTokenizer.h \
+	OpenDocumentTokenizer.h \
 	PdfTokenizer.h \
 	RtfTokenizer.h \
 	TagLibTokenizer.h \
 	Tokenizer.h \
 	TokenizerFactory.h \
 	UnknownTypeTokenizer.h \
-	WordTokenizer.h
+	WordTokenizer.h \
+	XmlTokenizer.h
 
-lib_LTLIBRARIES = libpdftokenizer.la librtftokenizer.la libwordtokenizer.la \
-	libtaglibtokenizer.la
+lib_LTLIBRARIES = libopendocumenttokenizer.la libpdftokenizer.la librtftokenizer.la \
+	libwordtokenizer.la libtaglibtokenizer.la
 
 noinst_LTLIBRARIES = libTokenize.la
 
+libopendocumenttokenizer_la_SOURCES = \
+	OpenDocumentTokenizer.cpp \
+	XmlTokenizer.cpp \
+	Tokenizer.cpp
+
+libopendocumenttokenizer_la_LDFLAGS = -module
+
+libopendocumenttokenizer_la_LIBADD = ${UTILS_OBJS}
+
 libpdftokenizer_la_SOURCES = \
 	PdfTokenizer.cpp \
 	HtmlTokenizer.cpp \
@@ -60,7 +71,8 @@
 	HtmlTokenizer.cpp \
 	Tokenizer.cpp \
 	TokenizerFactory.cpp \
-	UnknownTypeTokenizer.cpp
+	UnknownTypeTokenizer.cpp \
+	XmlTokenizer.cpp
 
 AM_CXXFLAGS = -fPIC -I../Utils @TAGLIB_CFLAGS@
 

Modified: trunk/Tokenize/PdfTokenizer.cpp
===================================================================
--- trunk/Tokenize/PdfTokenizer.cpp	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/PdfTokenizer.cpp	2006-04-14 06:03:52 UTC (rev 209)
@@ -19,21 +19,16 @@
 
 #include "PdfTokenizer.h"
 
-/**
-  * This returns the MIME type supported by the library's tokenizer.
-  * The character string is allocated with new[].
-  */
-char *getTokenizerType(unsigned int typeNum)
+using std::string;
+using std::set;
+
+/// This returns the MIME types supported by the library's tokenizer.
+bool getTokenizerTypes(set<string> &types)
 {
-	if (typeNum == 0)
-	{
-		char *pType = new char[16];
-		strncpy(pType, "application/pdf", 15);
-		pType[15] = '\0';
-		return pType;
-	}
+	types.clear();
+	types.insert("application/pdf");
 
-	return NULL;
+	return true;
 }
 
 /// This returns a pointer to a Tokenizer, allocated with new.
@@ -45,10 +40,8 @@
 PdfTokenizer::PdfTokenizer(const Document *pDocument) :
 	HtmlTokenizer(NULL)
 {
-	string cmdLine("pdftohtml -stdout");
-
-	// Run antiword
-	Document *pOutputDocument = runHelperProgram(pDocument, cmdLine);
+	// Run pdftohtml
+	Document *pOutputDocument = runHelperProgram(pDocument, "pdftohtml -stdout");
 	if (pOutputDocument != NULL)
 	{
 		// Give the result to the parent class

Modified: trunk/Tokenize/PdfTokenizer.h
===================================================================
--- trunk/Tokenize/PdfTokenizer.h	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/PdfTokenizer.h	2006-04-14 06:03:52 UTC (rev 209)
@@ -17,14 +17,14 @@
 #ifndef _PDF_TOKENIZER_H
 #define _PDF_TOKENIZER_H
 
+#include <string>
+#include <set>
+
 #include "Document.h"
 #include "HtmlTokenizer.h"
 
-/**
-  * This returns the MIME type supported by the library's tokenizer.
-  * The character string is allocated with new[].
-  */
-char *getTokenizerType(unsigned int typeNum);
+/// This returns the MIME types supported by the library's tokenizer.
+bool getTokenizerTypes(std::set<std::string> &types);
 /// This returns a pointer to a Tokenizer, allocated with new.
 Tokenizer *getTokenizer(const Document *pDocument);
 

Modified: trunk/Tokenize/RtfTokenizer.cpp
===================================================================
--- trunk/Tokenize/RtfTokenizer.cpp	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/RtfTokenizer.cpp	2006-04-14 06:03:52 UTC (rev 209)
@@ -19,28 +19,17 @@
 
 #include "RtfTokenizer.h"
 
-/**
-  * This returns the MIME type supported by the library's tokenizer.
-  * The character string is allocated with new[].
-  */
-char *getTokenizerType(unsigned int typeNum)
+using std::string;
+using std::set;
+
+/// This returns the MIME types supported by the library's tokenizer.
+bool getTokenizerTypes(set<string> &types)
 {
-	if (typeNum == 0)
-	{
-		char *pType = new char[9];
-		strncpy(pType, "text/rtf", 8);
-		pType[8] = '\0';
-		return pType;
-	}
-	else if (typeNum == 1)
-	{
-		char *pType = new char[16];
-		strncpy(pType, "application/rtf", 15);
-		pType[15] = '\0';
-		return pType;
-	}
+	types.clear();
+	types.insert("text/rtf");
+	types.insert("application/rtf");
 
-	return NULL;
+	return true;
 }
 
 /// This returns a pointer to a Tokenizer, allocated with new.
@@ -52,10 +41,8 @@
 RtfTokenizer::RtfTokenizer(const Document *pDocument) :
 	HtmlTokenizer(NULL)
 {
-	string cmdLine("unrtf --nopict --html");
-
-	// Run antiword
-	Document *pOutputDocument = runHelperProgram(pDocument, cmdLine);
+	// Run unrtf
+	Document *pOutputDocument = runHelperProgram(pDocument, "unrtf --nopict --html");
 	if (pOutputDocument != NULL)
 	{
 		// Give the result to the parent class

Modified: trunk/Tokenize/RtfTokenizer.h
===================================================================
--- trunk/Tokenize/RtfTokenizer.h	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/RtfTokenizer.h	2006-04-14 06:03:52 UTC (rev 209)
@@ -17,14 +17,14 @@
 #ifndef _RTF_TOKENIZER_H
 #define _RTF_TOKENIZER_H
 
+#include <string>
+#include <set>
+
 #include "Document.h"
 #include "HtmlTokenizer.h"
 
-/**
-  * This returns the MIME type supported by the library's tokenizer.
-  * The character string is allocated with new[].
-  */
-char *getTokenizerType(unsigned int typeNum);
+/// This returns the MIME types supported by the library's tokenizer.
+bool getTokenizerTypes(std::set<std::string> &types);
 /// This returns a pointer to a Tokenizer, allocated with new.
 Tokenizer *getTokenizer(const Document *pDocument);
 

Modified: trunk/Tokenize/TagLibTokenizer.cpp
===================================================================
--- trunk/Tokenize/TagLibTokenizer.cpp	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/TagLibTokenizer.cpp	2006-04-14 06:03:52 UTC (rev 209)
@@ -24,49 +24,20 @@
 #include "Url.h"
 #include "TagLibTokenizer.h"
 
-/**
-  * This returns the MIME type supported by the library's tokenizer.
-  * The character string is allocated with new[].
-  */
-char *getTokenizerType(unsigned int typeNum)
+using std::string;
+using std::set;
+
+/// This returns the MIME types supported by the library's tokenizer.
+bool getTokenizerTypes(set<string> &types)
 {
-	if (typeNum == 0)
-	{
-		char *pType = new char[11];
-		strncpy(pType, "audio/mpeg", 10);
-		pType[10] = '\0';
-		return pType;
-	}
-	else if (typeNum == 1)
-	{
-		char *pType = new char[12];
-		strncpy(pType, "audio/x-mp3", 11);
-		pType[11] = '\0';
-		return pType;
-	}
-	else if (typeNum == 2)
-	{
-		char *pType = new char[16];
-		strncpy(pType, "application/ogg", 15);
-		pType[15] = '\0';
-		return pType;
-	}
-	else if (typeNum == 3)
-	{
-		char *pType = new char[17];
-		strncpy(pType, "audio/x-flac+ogg", 16);
-		pType[16] = '\0';
-		return pType;
-	}
-	else if (typeNum == 4)
-	{
-		char *pType = new char[13];
-		strncpy(pType, "audio/x-flac", 12);
-		pType[12] = '\0';
-		return pType;
-	}
+	types.clear();
+	types.insert("audio/mpeg");
+	types.insert("audio/x-mp3");
+	types.insert("application/ogg");
+	types.insert("audio/x-flac+ogg");
+	types.insert("audio/x-flac");
 
-	return NULL;
+	return true;
 }
 
 /// This returns a pointer to a Tokenizer, allocated with new.

Modified: trunk/Tokenize/TagLibTokenizer.h
===================================================================
--- trunk/Tokenize/TagLibTokenizer.h	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/TagLibTokenizer.h	2006-04-14 06:03:52 UTC (rev 209)
@@ -17,14 +17,14 @@
 #ifndef _WORD_TOKENIZER_H
 #define _WORD_TOKENIZER_H
 
+#include <string>
+#include <set>
+
 #include "Document.h"
 #include "Tokenizer.h"
 
-/**
-  * This returns the MIME type supported by the library's tokenizer.
-  * The character string is allocated with new[].
-  */
-char *getTokenizerType(unsigned int typeNum);
+/// This returns the MIME types supported by the library's tokenizer.
+bool getTokenizerTypes(std::set<std::string> &types);
 /// This returns a pointer to a Tokenizer, allocated with new.
 Tokenizer *getTokenizer(const Document *pDocument);
 

Modified: trunk/Tokenize/Tokenizer.cpp
===================================================================
--- trunk/Tokenize/Tokenizer.cpp	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/Tokenizer.cpp	2006-04-14 06:03:52 UTC (rev 209)
@@ -26,6 +26,11 @@
 
 //#define DEBUG_TOKENIZER
 
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+
 Tokenizer::Tokenizer(const Document *pDocument)
 {
 	setDocument(pDocument);
@@ -36,13 +41,15 @@
 {
 }
 
-Document *Tokenizer::runHelperProgram(const Document *pDocument, const string &cmdLine)
+Document *Tokenizer::runHelperProgram(const Document *pDocument,
+	const string &programName, const string &arguments)
 {
 	Document *pOutputDocument = NULL;
 	char inTemplate[15] = "/tmp/tokXXXXXX";
 	char outTemplate[15] = "/tmp/tokXXXXXX";
 
-	if (cmdLine.empty() == true)
+	if ((pDocument == NULL) ||
+		(programName.empty() == true))
 	{
 		return NULL;
 	}
@@ -58,15 +65,22 @@
 		// Save the data into a temporary file
 		if (write(inFd, (const void*)pData, dataLength) != -1)
 		{
-			string cmdLineRedir(cmdLine);
-			cmdLineRedir += " ";
-			cmdLineRedir += inTemplate;
-			cmdLineRedir += " >";
-			cmdLineRedir += outTemplate;
-			cmdLineRedir += " 2>/dev/null";
+			string cmdLine(programName);
 
+			cmdLine += " ";
+			cmdLine += inTemplate;
+			if (arguments.empty() == false)
+			{
+				cmdLine += " ";
+				cmdLine += arguments;
+				cmdLine += " ";
+			}
+			cmdLine += " >";
+			cmdLine += outTemplate;
+			cmdLine += " 2>/dev/null";
+
 			// Run the helper program
-			if (system(cmdLineRedir.c_str()) != -1)
+			if (system(cmdLine.c_str()) != -1)
 			{
 				struct stat fileStat;
 
@@ -99,7 +113,7 @@
 				}
 #ifdef DEBUG
 				else cerr << "Tokenizer::runHelperProgram: "
-					<< cmdLineRedir << " failed" << endl;
+					<< cmdLine << " failed" << endl;
 #endif
 			}
 		}

Modified: trunk/Tokenize/Tokenizer.h
===================================================================
--- trunk/Tokenize/Tokenizer.h	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/Tokenizer.h	2006-04-14 06:03:52 UTC (rev 209)
@@ -21,8 +21,6 @@
 
 #include "Document.h"
 
-using namespace std;
-
 class Tokenizer
 {
 	public:
@@ -30,13 +28,14 @@
 		virtual ~Tokenizer();
 
 		/// Converts a document using an helper program.
-		static Document *runHelperProgram(const Document *pDocument, const string &cmdLine);
+		static Document *runHelperProgram(const Document *pDocument,
+			const std::string &programName, const std::string &arguments = "");
 
 		/// Returns a pointer to the document being tokenized.
 		virtual const Document *getDocument(void);
 
 		/// Returns the next token; false if all tokens consumed.
-		virtual bool nextToken(string &token);
+		virtual bool nextToken(std::string &token);
 
 		/// Rewinds the tokenizer.
 		virtual void rewind(void);

Modified: trunk/Tokenize/TokenizerFactory.cpp
===================================================================
--- trunk/Tokenize/TokenizerFactory.cpp	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/TokenizerFactory.cpp	2006-04-14 06:03:52 UTC (rev 209)
@@ -28,14 +28,18 @@
 #include "Tokenizer.h"
 #include "HtmlTokenizer.h"
 #include "UnknownTypeTokenizer.h"
+#include "XmlTokenizer.h"
 #include "Url.h"
 #include "TokenizerFactory.h"
 
+#define GETTOKENIZERTYPES	"_Z17getTokenizerTypesRSt3setISsSt4lessISsESaISsEE"
 #define GETTOKENIZER		"_Z12getTokenizerPK8Document"
-#define GETTOKENIZERTYPE	"_Z16getTokenizerTypej"
 
 using std::cout;
 using std::endl;
+using std::string;
+using std::map;
+using std::set;
 
 map<string, string> TokenizerFactory::m_types;
 map<string, void *> TokenizerFactory::m_handles;
@@ -152,36 +156,26 @@
 					if (pHandle != NULL)
 					{
 						// What type(s) does this support ?
-						getTokenizerTypeFunc *pFunc = (getTokenizerTypeFunc *)dlsym(pHandle,
-								GETTOKENIZERTYPE);
+						getTokenizerTypesFunc *pFunc = (getTokenizerTypesFunc *)dlsym(pHandle,
+								GETTOKENIZERTYPES);
 						if (pFunc != NULL)
 						{
-							unsigned int typeNum = 0;
+							set<string> types;
+							bool tokenizerOkay = (*pFunc)(types);
 
-							while (1)
+							if (tokenizerOkay == true)
 							{
-								char *pSupportedType = (*pFunc)(typeNum);
-								if (pSupportedType == NULL)
+								for (set<string>::iterator typeIter = types.begin();
+									typeIter != types.end(); ++typeIter)
 								{
-									break;
-								}
-
-								// Add a record for this tokenizer
-								m_types[pSupportedType] = fileName;
+									// Add a record for this tokenizer
+									m_types[*typeIter] = fileName;
 #ifdef DEBUG
-								cout << "TokenizerFactory::loadTokenizers: type "
-									<< pSupportedType << " supported by " << pEntryName << endl;
+									cout << "TokenizerFactory::loadTokenizers: type "
+										<< *typeIter << " supported by " << pEntryName << endl;
 #endif
-								// It's supposed to have been allocated with new[]
-								delete[] pSupportedType;
+								}
 
-								// Next
-								++count;
-								++typeNum;
-							}
-
-							if (typeNum > 0)
-							{
 								m_handles[fileName] = pHandle;
 							}
 						}
@@ -261,6 +255,11 @@
 	{
 		return new Tokenizer(pDocument);
 	}
+	else if ((typeOnly == "text/xml") ||
+		(typeOnly == "application/xml"))
+	{
+		return new XmlTokenizer(pDocument);
+	}
 
 	Tokenizer *pTokenizer = getLibraryTokenizer(typeOnly, pDocument);
 	if (pTokenizer == NULL)
@@ -287,6 +286,8 @@
 	// List supported types
 	types.insert("text/plain");
 	types.insert("text/html");
+	types.insert("text/xml");
+	types.insert("application/xml");
 	for (map<string, string>::iterator iter = m_types.begin(); iter != m_types.end(); ++iter)
 	{
 		types.insert(iter->first);
@@ -309,6 +310,8 @@
 
 	// Is it a built-in type ?
 	if ((typeOnly == "text/html") ||
+		(typeOnly == "text/xml") ||
+		(typeOnly == "application/html") ||
 		(strncasecmp(typeOnly.c_str(), "text", 4) == 0))
 	{
 		return true;

Modified: trunk/Tokenize/TokenizerFactory.h
===================================================================
--- trunk/Tokenize/TokenizerFactory.h	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/TokenizerFactory.h	2006-04-14 06:03:52 UTC (rev 209)
@@ -35,35 +35,35 @@
 		  * This returns the MIME type supported by the library's tokenizer.
 		  * The character string is allocated with new[].
 		  */
-		typedef char *(getTokenizerTypeFunc)(unsigned int typeNum);
+		typedef bool (getTokenizerTypesFunc)(std::set<std::string> &);
 		/// This returns a pointer to a Tokenizer, allocated with new.
 		typedef Tokenizer *(getTokenizerFunc)(const Document *);
 
 		/// Loads the tokenizer libraries in the given directory.
-		static unsigned int loadTokenizers(const string &dirName);
+		static unsigned int loadTokenizers(const std::string &dirName);
 
 		/// Returns a Tokenizer that handles the given file's type; NULL if unavailable.
-		static Tokenizer *getTokenizer(const string &fileName, const Document *pDocument);
+		static Tokenizer *getTokenizer(const std::string &fileName, const Document *pDocument);
 
 		/// Returns a Tokenizer that handles the given MIME type; NULL if unavailable.
-		static Tokenizer *getTokenizerByType(const string &type, const Document *pDocument);
+		static Tokenizer *getTokenizerByType(const std::string &type, const Document *pDocument);
 
 		/// Returns all supported MIME types.
-		static void getSupportedTypes(set<string> &types);
+		static void getSupportedTypes(std::set<std::string> &types);
 
 		/// Indicates whether a MIME type is supported or not.
-		static bool isSupportedType(const string &type);
+		static bool isSupportedType(const std::string &type);
 
 		/// Unloads all tokenizer libraries.
 		static void unloadTokenizers(void);
 
 	protected:
-		static map<string, string> m_types;
-		static map<string, void *> m_handles;
+		static std::map<std::string, std::string> m_types;
+		static std::map<std::string, void *> m_handles;
 
 		TokenizerFactory();
 
-		static Tokenizer *getLibraryTokenizer(const string &type, const Document *pDocument);
+		static Tokenizer *getLibraryTokenizer(const std::string &type, const Document *pDocument);
 
 	private:
 		TokenizerFactory(const TokenizerFactory &other);

Modified: trunk/Tokenize/WordTokenizer.cpp
===================================================================
--- trunk/Tokenize/WordTokenizer.cpp	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/WordTokenizer.cpp	2006-04-14 06:03:52 UTC (rev 209)
@@ -19,21 +19,16 @@
 
 #include "WordTokenizer.h"
 
-/**
-  * This returns the MIME type supported by the library's tokenizer.
-  * The character string is allocated with new[].
-  */
-char *getTokenizerType(unsigned int typeNum)
+using std::string;
+using std::set;
+
+/// This returns the MIME types supported by the library's tokenizer.
+bool getTokenizerTypes(set<string> &types)
 {
-	if (typeNum == 0)
-	{
-		char *pType = new char[19];
-		strncpy(pType, "application/msword", 18);
-		pType[18] = '\0';
-		return pType;
-	}
+	types.clear();
+	types.insert("application/msword");
 
-	return NULL;
+	return true;
 }
 
 /// This returns a pointer to a Tokenizer, allocated with new.
@@ -45,10 +40,8 @@
 WordTokenizer::WordTokenizer(const Document *pDocument) :
 	Tokenizer(NULL)
 {
-	string cmdLine("antiword");
-
 	// Run antiword
-	Document *pOutputDocument = runHelperProgram(pDocument, cmdLine);
+	Document *pOutputDocument = runHelperProgram(pDocument, "antiword");
 	if (pOutputDocument != NULL)
 	{
 		// Give the result to the parent class

Modified: trunk/Tokenize/WordTokenizer.h
===================================================================
--- trunk/Tokenize/WordTokenizer.h	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/WordTokenizer.h	2006-04-14 06:03:52 UTC (rev 209)
@@ -17,14 +17,14 @@
 #ifndef _WORD_TOKENIZER_H
 #define _WORD_TOKENIZER_H
 
+#include <string>
+#include <set>
+
 #include "Document.h"
 #include "Tokenizer.h"
 
-/**
-  * This returns the MIME type supported by the library's tokenizer.
-  * The character string is allocated with new[].
-  */
-char *getTokenizerType(unsigned int typeNum);
+/// This returns the MIME types supported by the library's tokenizer.
+bool getTokenizerTypes(std::set<std::string> &types);
 /// This returns a pointer to a Tokenizer, allocated with new.
 Tokenizer *getTokenizer(const Document *pDocument);
 

Added: trunk/Tokenize/XmlTokenizer.cpp
===================================================================
--- trunk/Tokenize/XmlTokenizer.cpp	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/XmlTokenizer.cpp	2006-04-14 06:03:52 UTC (rev 209)
@@ -0,0 +1,138 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <string.h>
+#include <strings.h>
+#include <sys/types.h>
+#include <iostream>
+
+#include "StringManip.h"
+#include "XmlTokenizer.h"
+
+//#define DEBUG_TOKENIZER
+
+using std::string;
+
+XmlTokenizer::XmlTokenizer(const Document *pDocument) :
+	Tokenizer(NULL),
+	m_pXmlDocument(NULL)
+{
+	initialize(pDocument);
+}
+
+XmlTokenizer::XmlTokenizer() :
+	Tokenizer(NULL),
+	m_pXmlDocument(NULL)
+{
+}
+
+XmlTokenizer::~XmlTokenizer()
+{
+	if (m_pDocument != NULL)
+	{
+		// This should have been set by setDocument(),
+		// called in initialize()
+		delete m_pDocument;
+	}
+}
+
+void XmlTokenizer::initialize(const Document *pDocument)
+{
+	unsigned int length = 0;
+
+	if (pDocument == NULL)
+	{
+		return;
+	}
+
+	const char *data = pDocument->getData(length);
+	if ((data != NULL) &&
+		(length > 0))
+	{
+		// Remove XML tags
+		string strippedData = parseXML(data);
+
+		// Pass the result to the parent class
+		Document *pStrippedDoc = new Document(pDocument->getTitle(),
+			pDocument->getLocation(), pDocument->getType(),
+			pDocument->getLanguage());
+		pStrippedDoc->setData(strippedData.c_str(), strippedData.length());
+		setDocument(pStrippedDoc);
+
+		m_pXmlDocument = pDocument;
+	}
+}
+
+/// Parses XML; the string without tags.
+string XmlTokenizer::parseXML(const string &str)
+{
+	string stripped;
+	string::size_type startPos = 0;
+	bool isXml = false, skip = false;
+
+#ifdef DEBUG_TOKENIZER
+	cout << "XmlTokenizer::parseXML: start" << endl;
+#endif
+
+	// Tag start
+	string::size_type pos = str.find("<");
+	while (pos != string::npos)
+	{
+		isXml = true;
+
+		if (skip == false)
+		{
+			string text = str.substr(startPos, pos - startPos);
+
+			stripped += StringManip::replaceEntities(text);
+			stripped += " ";
+
+			startPos = pos + 1;
+			// Tag end
+			if (str[pos] == '<')
+			{
+				pos = str.find(">", startPos);
+			}
+			// Skip stuff in the tag
+			skip = true;
+		}
+		else
+		{
+			startPos = pos + 1;
+			pos = str.find("<", startPos);
+			skip = false;
+		}
+	}
+	if (startPos < str.length())
+	{
+		stripped  += StringManip::replaceEntities(str.substr(startPos));
+	}
+
+	if (isXml == false)
+	{
+		return str;
+	}
+
+	return stripped;
+}
+
+/// Utility method that strips XML tags off; the string without tags.
+string XmlTokenizer::stripTags(const string &str)
+{
+	XmlTokenizer tokens;
+
+	return tokens.parseXML(str);
+}


Property changes on: trunk/Tokenize/XmlTokenizer.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Tokenize/XmlTokenizer.h
===================================================================
--- trunk/Tokenize/XmlTokenizer.h	2006-04-14 05:59:03 UTC (rev 208)
+++ trunk/Tokenize/XmlTokenizer.h	2006-04-14 06:03:52 UTC (rev 209)
@@ -0,0 +1,46 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XML_TOKENIZER_H
+#define _XML_TOKENIZER_H
+
+#include <string>
+
+#include "Document.h"
+#include "Tokenizer.h"
+
+class XmlTokenizer : public Tokenizer
+{
+	public:
+		XmlTokenizer(const Document *pDocument);
+		virtual ~XmlTokenizer();
+
+		/// Utility method that strips XML tags off; the string without tags.
+		static std::string stripTags(const std::string &str);
+
+	protected:
+		const Document *m_pXmlDocument;
+
+		XmlTokenizer();
+
+		void initialize(const Document *pDocument);
+
+		/// Parses XML; the string without tags.
+		std::string parseXML(const std::string &str);
+
+};
+
+#endif // _XML_TOKENIZER_H


Property changes on: trunk/Tokenize/XmlTokenizer.h
___________________________________________________________________
Name: svn:executable
   + *



From fabricecolin at berlios.de  Fri Apr 14 08:08:33 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 14 Apr 2006 08:08:33 +0200
Subject: [Pinot-svn] r210 - trunk/Tokenize
Message-ID: <200604140608.k3E68XjU026226@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-14 08:07:55 +0200 (Fri, 14 Apr 2006)
New Revision: 210

Added:
   trunk/Tokenize/OpenDocumentTokenizer.cpp
   trunk/Tokenize/OpenDocumentTokenizer.h
Log:
Unsurprisingly, I forgot to check in the new OpenDocumentTokenizer class ;-)


Added: trunk/Tokenize/OpenDocumentTokenizer.cpp
===================================================================
--- trunk/Tokenize/OpenDocumentTokenizer.cpp	2006-04-14 06:03:52 UTC (rev 209)
+++ trunk/Tokenize/OpenDocumentTokenizer.cpp	2006-04-14 06:07:55 UTC (rev 210)
@@ -0,0 +1,83 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <string.h>
+#include <iostream>
+
+#include "OpenDocumentTokenizer.h"
+
+using std::string;
+using std::set;
+
+/// This returns the MIME types supported by the library's tokenizer.
+bool getTokenizerTypes(set<string> &types)
+{
+	types.clear();
+	types.insert("application/vnd.sun.xml.writer");
+	types.insert("application/vnd.sun.xml.writer.template");
+	types.insert("application/vnd.sun.xml.calc");
+	types.insert("application/vnd.sun.xml.calc.template");
+	types.insert("application/vnd.sun.xml.draw");
+	types.insert("application/vnd.sun.xml.draw.template");
+	types.insert("application/vnd.sun.xml.impress");
+	types.insert("application/vnd.sun.xml.impress.template");
+	types.insert("application/vnd.sun.xml.writer.global");
+	types.insert("application/vnd.sun.xml.math");
+	types.insert("application/vnd.oasis.opendocument.chart");
+	types.insert("application/vnd.oasis.opendocument.database");
+	types.insert("application/vnd.oasis.opendocument.formula");
+	types.insert("application/vnd.oasis.opendocument.graphics");
+	types.insert("application/vnd.oasis.opendocument.graphics-template");
+	types.insert("application/vnd.oasis.opendocument.image");
+	types.insert("application/vnd.oasis.opendocument.presentation");
+	types.insert("application/vnd.oasis.opendocument.presentation-template");
+	types.insert("application/vnd.oasis.opendocument.spreadsheet");
+	types.insert("application/vnd.oasis.opendocument.spreadsheet-template");
+	types.insert("application/vnd.oasis.opendocument.text");
+	types.insert("application/vnd.oasis.opendocument.text-master");
+	types.insert("application/vnd.oasis.opendocument.text-template");
+	types.insert("application/vnd.oasis.opendocument.text-web");
+
+	return true;
+}
+
+/// This returns a pointer to a Tokenizer, allocated with new.
+Tokenizer *getTokenizer(const Document *pDocument)
+{
+	return new OpenDocumentTokenizer(pDocument);
+}
+
+OpenDocumentTokenizer::OpenDocumentTokenizer(const Document *pDocument) :
+	XmlTokenizer(NULL)
+{
+	// FIXME: unzip meta.xml and extract document information
+	// Unip content.xml
+	Document *pOutputDocument = runHelperProgram(pDocument, "unzip -p", "meta.xml");
+	if (pOutputDocument != NULL)
+	{
+		// Give the result to the parent class
+		initialize(pOutputDocument);
+	}
+}
+
+OpenDocumentTokenizer::OpenDocumentTokenizer() :
+	XmlTokenizer()
+{
+}
+
+OpenDocumentTokenizer::~OpenDocumentTokenizer()
+{
+}

Added: trunk/Tokenize/OpenDocumentTokenizer.h
===================================================================
--- trunk/Tokenize/OpenDocumentTokenizer.h	2006-04-14 06:03:52 UTC (rev 209)
+++ trunk/Tokenize/OpenDocumentTokenizer.h	2006-04-14 06:07:55 UTC (rev 210)
@@ -0,0 +1,46 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _OPENDOCUMENT_TOKENIZER_H
+#define _OPENDOCUMENT_TOKENIZER_H
+
+#include <string>
+#include <set>
+
+#include "Document.h"
+#include "XmlTokenizer.h"
+
+/// This returns the MIME types supported by the library's tokenizer.
+bool getTokenizerTypes(std::set<std::string> &types);
+/// This returns a pointer to a Tokenizer, allocated with new.
+Tokenizer *getTokenizer(const Document *pDocument);
+
+class OpenDocumentTokenizer : public XmlTokenizer
+{
+	public:
+		OpenDocumentTokenizer(const Document *pDocument);
+		virtual ~OpenDocumentTokenizer();
+
+	protected:
+		OpenDocumentTokenizer();
+
+	private:
+		OpenDocumentTokenizer(const OpenDocumentTokenizer &other);
+		OpenDocumentTokenizer& operator=(const OpenDocumentTokenizer& other);
+
+};
+
+#endif // _OPENDOCUMENT_TOKENIZER_H



From fabricecolin at berlios.de  Fri Apr 14 09:20:51 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 14 Apr 2006 09:20:51 +0200
Subject: [Pinot-svn] r212 - trunk/Tokenize
Message-ID: <200604140720.k3E7KpBd024667@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-14 09:20:48 +0200 (Fri, 14 Apr 2006)
New Revision: 212

Modified:
   trunk/Tokenize/OpenDocumentTokenizer.cpp
Log:
Open content.xml, not meta.xml ! Doh !


Modified: trunk/Tokenize/OpenDocumentTokenizer.cpp
===================================================================
--- trunk/Tokenize/OpenDocumentTokenizer.cpp	2006-04-14 07:18:40 UTC (rev 211)
+++ trunk/Tokenize/OpenDocumentTokenizer.cpp	2006-04-14 07:20:48 UTC (rev 212)
@@ -65,7 +65,7 @@
 {
 	// FIXME: unzip meta.xml and extract document information
 	// Unip content.xml
-	Document *pOutputDocument = runHelperProgram(pDocument, "unzip -p", "meta.xml");
+	Document *pOutputDocument = runHelperProgram(pDocument, "unzip -p", "content.xml");
 	if (pOutputDocument != NULL)
 	{
 		// Give the result to the parent class



From fabricecolin at berlios.de  Fri Apr 14 09:24:49 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 14 Apr 2006 09:24:49 +0200
Subject: [Pinot-svn] r213 - trunk
Message-ID: <200604140724.k3E7Oncp025080@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-14 09:24:46 +0200 (Fri, 14 Apr 2006)
New Revision: 213

Modified:
   trunk/NEWS
   trunk/README
   trunk/pinot.spec.in
Log:
Text-docs RPM includes libopendocumenttokenizer.so. Added dependencies on unzip
and shared-mime-info (needed by xdgmime).
Updated NEWS and README.


Modified: trunk/NEWS
===================================================================
--- trunk/NEWS	2006-04-14 07:20:48 UTC (rev 212)
+++ trunk/NEWS	2006-04-14 07:24:46 UTC (rev 213)
@@ -4,8 +4,10 @@
  - tweaked extraction of results' extract and URL
  - renamed pinot_search to pinot-search
 Tokenize :
- - new dependency on TagLib to allow extracting track information from MP3, Vorbis
-  and FLAC files
+ - new tokenizer for MP3, Vorbis and FLAC files that depend on the TagLib library
+ - new XML tokenizer
+ - new tokenizer for StarOffice and OpenDocument files (unzip required)
+ - replaced libmagic with shared-mime-info (xdgmime) for better MIME type detection
 HTML browser :
  - can build against Mozilla or Firefox, as set with "./configure --with-gecko=mozilla|firefox"
 

Modified: trunk/README
===================================================================
--- trunk/README	2006-04-14 07:20:48 UTC (rev 212)
+++ trunk/README	2006-04-14 07:24:46 UTC (rev 213)
@@ -53,6 +53,9 @@
 boost (4)						1.32.0
 http://www.boost.org/
 
+shared-mime-info					0.17
+http://freedesktop.org/Software/shared-mime-info
+
 pdftohtml						0.36
 http://pdftohtml.sourceforge.net/
 

Modified: trunk/pinot.spec.in
===================================================================
--- trunk/pinot.spec.in	2006-04-14 07:20:48 UTC (rev 212)
+++ trunk/pinot.spec.in	2006-04-14 07:24:46 UTC (rev 213)
@@ -11,7 +11,7 @@
 Source: %{name}-%{version}.tar.gz
 URL: http://pinot.berlios.de/
 BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
-Requires: xapian-core-libs >= 0.9.4, curl >= 7.13, gtkmm24 >= 2.6, libxml++ >= 2.12, mozilla >= %{mozilla_ver}, sqlite >= 3.1.2, libtextcat >= 2.2, fam >= 2.6.10, gmime >= 2.1, file
+Requires: xapian-core-libs >= 0.9.4, curl >= 7.13, gtkmm24 >= 2.6, libxml++ >= 2.12, mozilla >= %{mozilla_ver}, sqlite >= 3.1.2, libtextcat >= 2.2, fam >= 2.6.10, gmime >= 2.1, shared-mime-info
 BuildRequires: xapian-core-devel >= 0.9.4, curl-devel >= 7.13, gtkmm24-devel >= 2.6, libxml++-devel >= 2.12, mozilla-devel >= %{mozilla_ver}, sqlite-devel >= 3.1.2, libtextcat-devel >= 2.2, fam-devel >= 2.6.10, gmime-devel >= 2.1, taglib-devel >= 1.4, boost-devel >= 1.32, gettext-devel, desktop-file-utils
 %if 0%{?_with_soap:1}
 BuildRequires: gsoap
@@ -26,11 +26,12 @@
 Summary: Tokenizers for Pinot that handle various text document formats
 Group: Applications/Internet
 Requires: %{name} = %{version}
-Requires: /usr/bin/pdftohtml, antiword, unrtf
+Requires: /usr/bin/unzip, /usr/bin/pdftohtml, antiword, unrtf
 Obsoletes: pinot-pdf, pinot-word
 
 %description text-docs 
-The included tokenizers add support for PDF, MS Word and RTF documents.
+The included tokenizers add support for OpenDocument, Sun StarOffice,
+PDF, MS Word and RTF documents.
 
 %package audio-docs 
 Summary: Tokenizers for Pinot that handle various audio document formats
@@ -122,6 +123,7 @@
 
 %files text-docs 
 %defattr(-, root, root, -)
+%{_datadir}/pinot/tokenizers/libopendocumenttokenizer.so
 %{_datadir}/pinot/tokenizers/libpdftokenizer.so
 %{_datadir}/pinot/tokenizers/librtftokenizer.so
 %{_datadir}/pinot/tokenizers/libwordtokenizer.so



From fabricecolin at berlios.de  Fri Apr 14 09:18:44 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 14 Apr 2006 09:18:44 +0200
Subject: [Pinot-svn] r211 - in trunk/Utils: . xdgmime
Message-ID: <200604140718.k3E7IiRq023593@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-14 09:18:40 +0200 (Fri, 14 Apr 2006)
New Revision: 211

Added:
   trunk/Utils/xdgmime/
   trunk/Utils/xdgmime/ChangeLog
   trunk/Utils/xdgmime/xdgmime.c
   trunk/Utils/xdgmime/xdgmime.h
   trunk/Utils/xdgmime/xdgmimealias.c
   trunk/Utils/xdgmime/xdgmimealias.h
   trunk/Utils/xdgmime/xdgmimecache.c
   trunk/Utils/xdgmime/xdgmimecache.h
   trunk/Utils/xdgmime/xdgmimeglob.c
   trunk/Utils/xdgmime/xdgmimeglob.h
   trunk/Utils/xdgmime/xdgmimeint.c
   trunk/Utils/xdgmime/xdgmimeint.h
   trunk/Utils/xdgmime/xdgmimemagic.c
   trunk/Utils/xdgmime/xdgmimemagic.h
   trunk/Utils/xdgmime/xdgmimeparent.c
   trunk/Utils/xdgmime/xdgmimeparent.h
Modified:
   trunk/Utils/MIMEScanner.cpp
   trunk/Utils/Makefile.am
Log:
Import freedesktop.org's LGPL-licensed xdgmime library, pulled from CVS today.
MIMEScanner now uses that to more effectively determine a file's MIME type.
As a result, we now depend on shared-mime-info.


Modified: trunk/Utils/MIMEScanner.cpp
===================================================================
--- trunk/Utils/MIMEScanner.cpp	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/MIMEScanner.cpp	2006-04-14 07:18:40 UTC (rev 211)
@@ -15,12 +15,16 @@
  */
 
 #include <strings.h>
-#include <magic.h>
+#include <utility>
 
-#include "Url.h"
+#include "xdgmime/xdgmime.h"
+
 #include "MIMEScanner.h"
+#include "StringManip.h"
+#include "Url.h"
 
 using std::string;
+using std::min;
 
 MIMEScanner::MIMEScanner()
 {
@@ -28,35 +32,20 @@
 
 string MIMEScanner::scanFileType(const string &fileName)
 {
-	string::size_type fileExtPos = fileName.find_last_of(".");
-	if (fileExtPos != string::npos)
+	if (fileName.empty() == true)
 	{
-		string fileExt = fileName.substr(fileExtPos);
+		return "";
+	}
 
-		if (strncasecmp(fileExt.c_str(), ".txt", 4) == 0)
-		{
-			return "text/plain";
-		}
-		else if (strncasecmp(fileExt.c_str(), ".html", 5) == 0)
-		{
-			return "text/html";
-		}
-		else if (strncasecmp(fileExt.c_str(), ".xml", 4) == 0)
-		{
-			return "text/xml";
-		}
-		else if (strncasecmp(fileExt.c_str(), ".pdf", 4) == 0)
-		{
-			return "application/pdf";
-		}
-		else if (strncasecmp(fileExt.c_str(), ".ps", 3) == 0)
-		{
-			return "application/postscript";
-		}
+	// Does it have an obvious extension ?
+	const char  *pType = xdg_mime_get_mime_type_from_file_name(fileName.c_str());
+	if ((pType == NULL) ||
+		(strncasecmp(pType, xdg_mime_type_unknown, min(strlen(pType), strlen(xdg_mime_type_unknown))) == 0))
+	{
+		return "";
 	}
 
-	// Unknown type
-	return "";
+	return pType;
 }
 
 /// Finds out the given file's MIME type.
@@ -67,68 +56,46 @@
 		return "";
 	}
 
-	// Does it have an obvious extension ?
 	string mimeType = scanFileType(fileName);
-	if (mimeType.empty() == false)
+	if (mimeType.empty() == true)
 	{
-		return mimeType;
-	}
-
-	// Open
-	magic_t magicCookie = magic_open(MAGIC_SYMLINK|MAGIC_MIME);
-	if (magicCookie == NULL)
-	{
-		return "";
-	}
-	if (magic_load(magicCookie, NULL) == -1)
-	{
-		magic_close(magicCookie);
-		return "";
-	}
-
-	const char *type = magic_file(magicCookie, fileName.c_str());
-	if (type != NULL)
-	{
-		mimeType = type;
-
-		// The MIME string might be of the form "mime_type; charset=..."
-		string::size_type mimeTypeEnd = mimeType.find(";");
-		if (mimeTypeEnd != string::npos)
+		// Have a peek at the file
+		const char *pType = xdg_mime_get_mime_type_for_file(fileName.c_str(), NULL);
+		if ((pType == NULL) ||
+			(strncasecmp(pType, xdg_mime_type_unknown, min(strlen(pType), strlen(xdg_mime_type_unknown))) == 0))
 		{
-			mimeType.resize(mimeTypeEnd);
+			return "";
 		}
+
+		mimeType = pType;
 	}
 
-	// Close
-	magic_close(magicCookie);
-
 	return mimeType;
 }
 
 /// Finds out the given URL's MIME type.
 string MIMEScanner::scanUrl(const Url &urlObj)
 {
-	// Is it a local file ?
-	if (urlObj.getProtocol() == "file")
+	string mimeType = scanFileType(urlObj.getFile());
+	if (mimeType.empty() == true)
 	{
-		string fileName = urlObj.getLocation();
-		fileName += "/";
-		fileName += urlObj.getFile();
+		// Is it a local file ?
+		if (urlObj.getProtocol() == "file")
+		{
+			string fileName = urlObj.getLocation();
+			fileName += "/";
+			fileName += urlObj.getFile();
 
-		return scanFile(fileName);
+			mimeType = scanFile(fileName);
+		}
 	}
 
-	string mimeType = scanFileType(urlObj.getFile());
 	if (mimeType.empty() == true)
 	{
 		if (urlObj.getProtocol() == "http")
 		{
 			mimeType = "text/html";
 		}
-		else
-		{
-			mimeType = "text/plain";
-		}
 	}
 
 	return mimeType;

Modified: trunk/Utils/Makefile.am
===================================================================
--- trunk/Utils/Makefile.am	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/Makefile.am	2006-04-14 07:18:40 UTC (rev 211)
@@ -15,7 +15,14 @@
 	Result.h \
 	TimeConverter.h \
 	Url.h \
-	XapianDatabaseFactory.h
+	XapianDatabaseFactory.h \
+	xdgmime/xdgmimealias.h \
+	xdgmime/xdgmimecache.h \
+	xdgmime/xdgmimeglob.h \
+	xdgmime/xdgmime.h \
+	xdgmime/xdgmimeint.h \
+	xdgmime/xdgmimemagic.h \
+	xdgmime/xdgmimeparent.h
 
 noinst_LTLIBRARIES = libUtils.la
 
@@ -33,7 +40,15 @@
 	Result.cpp \
 	TimeConverter.cpp \
 	Url.cpp \
-	XapianDatabaseFactory.cpp
+	XapianDatabaseFactory.cpp \
+	xdgmime/xdgmimealias.c \
+	xdgmime/xdgmime.c \
+	xdgmime/xdgmimecache.c \
+	xdgmime/xdgmimeglob.c \
+	xdgmime/xdgmimeint.c \
+	xdgmime/xdgmimemagic.c \
+	xdgmime/xdgmimeparent.c
 
-AM_CXXFLAGS = -fPIC @HTTP_CFLAGS@ @INDEX_CFLAGS@ @MIME_CFLAGS@
+AM_CFLAGS = -fPIC -DXDG_PREFIX=pinot_xdg
+AM_CXXFLAGS = -fPIC @HTTP_CFLAGS@ @INDEX_CFLAGS@ @MIME_CFLAGS@ -DXDG_PREFIX=pinot_xdg
 

Added: trunk/Utils/xdgmime/ChangeLog
===================================================================
--- trunk/Utils/xdgmime/ChangeLog	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/ChangeLog	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,362 @@
+2006-03-02  Christian Neumair  <chris at gnome-de.org>
+
+	* src/xdgmimeglob.c: (_xdg_glob_hash_insert_text),
+	(_xdg_glob_hash_append_glob): Don't strdup the MIME type when passing
+	it to _xdg_glob_hash_insert_text, but let the function itself figure
+	out whether string duplication is needed. Fixes #5993.
+	Thanks to Martin Wehner.
+
+2006-02-25  Christian Neumair  <chris at gnome-de.org>
+
+	* src/xdgmimemagic.c: (_xdg_mime_magic_lookup_data): Make
+	priority equality check more robust so that it works for three or more
+	matches. Also allow matchlets with 0 priority.
+
+2006-02-19  Christian Neumair  <chris at gnome-de.org>
+
+	* src/xdgmimemagic.c: (_xdg_mime_magic_lookup_data): When two
+	unrelated MIME types with equal priorities match, don't assume one of
+	them matches.
+	http://bugzilla.gnome.org/show_bug.cgi?id=331719
+
+2006-01-03  Christian Neumair  <chris at gnome-de.org>
+
+	* src/xdgmimemagic.c: (_xdg_mime_magic_lookup_data): Also consider
+	match priority for the returned MIME type.
+
+2005-12-01  Christian Neumair  <chris at gnome-de.org>
+
+	* src/xdgmime.c: (xdg_mime_get_mime_type_from_file_name):
+	* src/xdgmimecache.c: (_xdg_mime_cache_get_mime_type_from_file_name):
+	Return XDG_MIME_TYPE_UNKNOWN if multiple MIME types match a simple
+	pattern.
+
+2005-12-01  Matthias Clasen  <mclasen at redhat.com>
+
+	* src/xdgmimecache.h:
+	* src/xdgmimecache.c (_xdg_mime_cache_get_mime_type_for_file): 
+	Allow passing in a struct stat * to avoid re-stat()ing. 
+	Forgotten commit from an earlier entry.
+
+	* src/xdgmimecache.c (cache_glob_lookup_literal):
+	(cache_glob_lookup_fnmatch):
+	(cache_glob_node_lookup_suffix): Change these functions to
+	allow returning more than one mime type if identical globs
+	match.
+
+	* src/xdgmimemagic.h: 
+	* src/xdgmimeglob.h: 
+	* src/xdgmimemagic.c (_xdg_mime_magic_lookup_data): 
+	* src/xdgmimeglob.c (_xdg_glob_hash_lookup_file_name): 
+	Change these functions to allow returning more than one
+	mime type if identical globs match.
+	
+	* src/xdgmimecache.c (_xdg_mime_cache_get_mime_type_for_file): 
+	* src/xdgmime.c (xdg_mime_get_mime_type_for_file): 
+	If multiple identical globs match, use magic to disambiguate.
+	
+2005-11-04  Matthias Clasen  <mclasen at redhat.com>
+
+	* xdgmime.c (xdg_mime_list_mime_parents): Prevent
+	a segfault.
+
+2005-10-18  Matthias Clasen  <mclasen at redhat.com>
+	
+	* src/xdgmime.c:
+	* src/xdgmimecache.h:
+	* src/xdgmimecache.c: Make the array of caches NULL-terminated
+	and rename it to _caches.  (#4011)
+
+	* src/xdgmime.h:
+	* src/xdgmime.c: Add a struct statbuf * argument to 
+	xdg_mime_get_mime_type_for_file().  (#3529)
+
+	* src/test-mime.c: Adjust callers. Add License.
+
+	* src/xdgmimecache.c: Make magic comparisons work correctly.
+
+Thu Jun  9 23:55:25 2005  Jonathan Blandford  <jrb at redhat.com>
+
+	* src/xdgmime.c (xdg_mime_init_from_directory): patch from
+	federico to realloc the right size, #3506
+
+2005-04-17  Christophe Fergeau  <teuf at gnome.org>
+
+	* src/xdgmimeint.c: fix gcc4 signedness warning
+
+2005-04-17  Christophe Fergeau  <teuf at gnome.org>
+
+	* src/xdgmimemagic.c: (_xdg_mime_magic_matchlet_compare_to_data),
+	(_xdg_mime_magic_matchlet_compare_level),
+	(_xdg_mime_magic_lookup_data): when  magic patterns matches, check if
+	there aren't subtypes with matching patterns too, and if so, favour
+	the subtype over the parent type, should fix #2686
+
+2005-04-16  Christophe Fergeau  <teuf at gnome.org>
+
+	* src/xdgmime.c: (xdg_mime_init_from_directory): fix leak when
+	mime.cache doesn't exist
+
+2005-04-16  Christophe Fergeau  <teuf at gnome.org>
+
+	* src/test-mime.c: (main): disabled call to xdg_mime_dump for now
+	* src/xdgmimemagic.c: (_xdg_mime_magic_matchlet_compare_to_data):
+	fixed off by 1 error when handling offsets, fixes bug #2050 and 
+	partly bug #2359
+
+Fri Apr  8 23:37:33 2005  Jonathan Blandford  <jrb at redhat.com>
+
+	* src/xdgmimecache.c: Actually add the file.  Also, patch from
+	Matthias Clasen <mclasen at redhat.com> to fix small bugs, #2939
+
+Fri Apr  1 14:59:43 2005  Jonathan Blandford  <jrb at redhat.com>
+
+	* src/xdgmimecache.c: Patch from Matthias Clasen to mmap the
+	cached xdg file.
+
+Mon Mar 28 13:58:32 2005  Jonathan Blandford  <jrb at redhat.com>
+
+	* src/xdgmimeglob.c (_xdg_glob_hash_insert_text): patch from
+	Matthias Clasen to handle globs that don't have '.' chars in
+	them.  As an example 'foo~' should match '*~'
+
+Mon Mar 21 13:16:12 2005  Jonathan Blandford  <jrb at redhat.com>
+
+	* src/xdgmime.c (xdg_mime_shutdown): fix from  Axel Liljencrantz
+	<f97-ali at nada.kth.se> to free parent_list in shutdown.
+
+2005-01-10  Christophe Fergeau  <teuf at gnome.org>
+
+	* src/xdgmimeglob.c: (_xdg_glob_hash_lookup_file_name): make previous
+	commit actually work...
+
+2005-01-10  Christophe Fergeau  <teuf at gnome.org>
+
+	* src/xdgmimeglob.c: (_xdg_glob_hash_lookup_file_name): don't get
+	confused by multiple dots in filenames when doing extension matching
+
+2004-12-13  Marco Pesenti Gritti  <marco at gnome.org>
+
+	* src/xdgmime.h:
+
+	 wrap new API in XDG_ENTRY()
+
+2004-12-13  Marco Pesenti Gritti  <marco at gnome.org>
+
+	* src/xdgmimeglob.c: (_xdg_glob_hash_lookup_file_name):
+
+	Do not assume the filename is UTF8. We just need to look
+	for the dot which is ASCII.
+
+2004-12-09  Marco Pesenti Gritti  <marco at gnome.org>
+
+	* src/xdgmimeint.h:
+
+	Remove spacings I introduced by mistake
+
+2004-12-09  Marco Pesenti Gritti  <marco at gnome.org>
+
+	* src/xdgmimealias.c: (_xdg_mime_alias_read_from_file):
+	* src/xdgmimeint.c: (_xdg_ucs4_to_lower):
+	* src/xdgmimeint.h:
+	* src/xdgmimeparent.c: (_xdg_mime_parent_read_from_file):
+
+	Check in Mariano Su?rez-Alvarez <msuarezalvarez at arnet.com.ar> patch
+	for GNOME bug #160838.
+
+2004-12-09  Marco Pesenti Gritti  <marco at gnome.org>
+
+	* src/xdgmimeglob.c: (_xdg_glob_hash_node_lookup_file_name):
+	* src/xdgmimeint.c: (_xdg_ucs4_to_lower):
+	* src/xdgmimeint.h:
+
+	Follow the freedesktop spec about case sensitiveness. Fix #732
+
+2004-12-08  Christophe Fergeau  <teuf at gnome.org>
+
+	* src/xdgmimeglob.c: (_xdg_mime_glob_read_from_file): backing out
+	"fix" for bug #1048 since it frees memory that shouldn't be freed.
+
+2004-12-08  Marco Pesenti Gritti  <marco at gnome.org>
+
+	* src/xdgmimemagic.c: (_xdg_mime_magic_read_from_file):
+
+	Check that fread succeeded reading all chars. Fix #1049
+
+2004-12-08  Marco Pesenti Gritti  <marco at gnome.org>
+
+	* src/xdgmime.c:
+	* src/xdgmimealias.c:
+	* src/xdgmimeglob.c:
+	* src/xdgmimeint.c:
+	* src/xdgmimemagic.c:
+	* src/xdgmimeparent.c:
+
+	Include config.h. Fix #913
+
+2004-12-08  Marco Pesenti Gritti  <marco at gnome.org>
+
+	* src/xdgmimealias.c: (_xdg_mime_alias_list_lookup):
+
+	Fix a typo
+
+2004-12-08  Marco Pesenti Gritti  <marco at gnome.org>
+
+	* src/xdgmime.c: (xdg_mime_unalias_mime_type),
+	(xdg_mime_mime_type_equal), (xdg_mime_mime_type_subclass),
+	(xdg_mime_get_mime_parents):
+	* src/xdgmime.h:
+
+	Add apis to get parents and to unalias mime type
+
+2004-12-08  Marco Pesenti Gritti  <marco at gnome.org>
+
+	* src/xdgmimealias.c: (_xdg_mime_alias_list_lookup):
+	* src/xdgmimeparent.c: (_xdg_mime_parent_list_lookup):
+
+	Protect against stupid bsearch() implementations.  (#1961,
+	Morten Welinder)
+
+2004-12-08  Marco Pesenti Gritti  <marco at gnome.org>
+
+	* src/xdgmimeparent.c: (_xdg_mime_parent_read_from_file):
+
+	Initialize the parent field of the newly allocate list 
+	entry.  (#1916, Alex Larsson)
+
+2004-12-08  Marco Pesenti Gritti  <marco at gnome.org>
+
+	* src/xdgmimeglob.c: (_xdg_mime_glob_read_from_file):
+
+	Patch from Matthias Clasen <mclasen at redhat.com> to fix
+	a mem leak. Bug #1048
+
+2004-12-08  Marco Pesenti Gritti  <marco at gnome.org>
+
+	* src/xdgmimeglob.h:
+
+	Patch from Michael.Wilson at bull.net to fix compile error on AIX
+
+Sun Nov  7 02:25:21 2004  Jonathan Blandford  <jrb at redhat.com>
+
+	* src/xdgmime.h: Patch from Matthias Clasen <mclasen at redhat.com>
+	to add alias and inheritence support.
+
+2004-09-16  Christophe Fergeau  <teuf at gnome.org>
+
+	* src/xdgmimeglob.c: (_xdg_glob_hash_free_nodes):
+	* src/xdgmimemagic.c: (_xdg_mime_magic_free): fix memory leaks, 
+	  fixes http://bugzilla.gnome.org/show_bug.cgi?id=152771 and
+	  http://bugzilla.gnome.org/show_bug.cgi?id=152768
+
+Mon Jul 19 00:23:00 2004  Jonathan Blandford  <jrb at gnome.org>
+
+	* src/xdgmime.c (xdg_mime_register_reload_callback): register a
+	callback when we reload MIME data.
+
+	* src/xdgmime.c (xdg_mime_remove_callback): Add capability to
+	remove callback.
+
+Sun Jul 18 20:56:22 2004  Jonathan Blandford  <jrb at gnome.org>
+
+	* src/xdgmime.c (xdg_mime_shutdown):
+	(xdg_mime_init): reread data when it changes on disk.
+
+Thu May 27 16:18:14 2004  Jonathan Blandford  <jrb at gnome.org>
+
+	* src/xdgmime.h: move xdg_mime_shutdown into the XDG_ENTRY guard.
+
+Thu May 27 15:02:13 2004  Jonathan Blandford  <jrb at gnome.org>
+
+	* src/xdgmimemagic.c (_xdg_mime_magic_read_magic_file): patch from
+	Hongli Lai <h.lai at chello.nl> to catch magic files that don't end
+	with a '\n'.
+
+Fri Apr 30 11:56:01 2004  Jonathan Blandford  <jrb at gnome.org>
+
+	* src/xdgmimemagic.c (_xdg_mime_magic_read_a_number): make the
+	buffer the right size.  Reported by Morten Welinder, #136323
+
+Sun Mar 21 23:56:46 2004  Jonathan Blandford  <jrb at gnome.org>
+
+	* src/xdgmimemagic.c: Patch from Arjan van de Ven
+	<arjanv at redhat.com> to do s/fgetc/getc_unlocked/g.
+
+Wed Mar 10 22:28:41 2004  Jonathan Blandford  <jrb at gnome.org>
+
+	* src/xdgmimemagic.c (_xdg_mime_magic_read_a_number): fix usage of
+	isdigit.  Reported by Morten Welinder, #136323
+
+	* src/xdgmimemagic.c (_xdg_mime_magic_read_magic_file): patch from
+	Christophe Fergeau to reverse the order of the matchlet before
+	adding it to the list.
+
+	* src/xdgmimeint.h (_xdg_utf8_skip): patch from Alexander Larsson
+	to make extern.
+
+Wed Jan 21 09:29:41 2004  Jonathan Blandford  <jrb at gnome.org>
+
+	* src/xdgmimemagic.c (_xdg_mime_magic_insert_match): dropped
+	patches.  Fix.
+
+	* src/xdgmimeglob.c (_xdg_glob_hash_free_nodes): dropped patches.
+	Fix.
+
+Tue Jan 20 14:55:39 2004  Jonathan Blandford  <jrb at gnome.org>
+
+	* src/xdgmime.h (XDG_MIME_TYPE_UNKNOWN): move the definition so
+	that it catches the XDG_ENTRY mangling.
+
+	* src/xdgmimemagic.c: make some functions static
+
+Tue Jan 20 14:34:26 2004  Jonathan Blandford  <jrb at gnome.org>
+
+	* src/xdgmime.c (xdg_mime_get_max_buffer_extents): add function so
+	that it's easy to get the max buffer extents.
+
+Tue Jan 20 12:55:55 2004  Jonathan Blandford  <jrb at gnome.org>
+
+	* src/Makefile: Test prefix code
+
+	* src/xdgmime*.h: Fully use the prefix code
+
+	* src/xdgmime.c: finish the syncing from both GTK+ and gnome-vfs.
+
+Tue Jan 13 16:21:04 2004  Jonathan Blandford  <jrb at gnome.org>
+
+	* src/xdgmime.[ch] (XDG_MIME_TYPE_UNKNOWN): make an extern const
+	char * so that comparisons can work.
+
+	* src/xdgmimeint.c (_xdg_utf8_to_ucs4): patch from Dave Jones
+	<davej at redhat.com> to make operations more explicit.
+
+Tue Oct 28 15:09:06 2003  Jonathan Blandford  <jrb at redhat.com>
+
+	* README: Add a readme, and clarify the licensing terms of the
+	software.
+
+Tue Oct 28 14:47:37 2003  Jonathan Blandford  <jrb at redhat.com>
+
+	* src/xdgmime.c (xdg_mime_shutdown): implement shutdown.  This
+	frees all memory and resets to an uninitialized state as best as
+	possible.
+
+Mon Oct 27 11:45:58 2003  Jonathan Blandford  <jrb at redhat.com>
+
+	* src/xdgmimemagic.c (_xdg_mime_magic_read_a_number): strtol
+	returns a long, not an int.  Thanks to Manish Singh for pointing
+	this out.
+
+	* src/xdgmimemagic.c (_xdg_mime_magic_parse_magic_line): change
+	assertion to avoid a warning.
+
+Tue Oct 21 15:56:55 2003  Jonathan Blandford  <jrb at gnome.org>
+
+	* Makefile: add a simple makefile
+	* src/Makefile: ditto
+
+Tue Jul 22 15:37:45 2003  Jonathan Blandford  <jrb at gnome.org>
+
+	* xdgmime/xdgmime.c (xdg_mime_init): use XDG_DATA_HOME instead of
+	XDG_CONFIG_HOME.
+

Added: trunk/Utils/xdgmime/xdgmime.c
===================================================================
--- trunk/Utils/xdgmime/xdgmime.c	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmime.c	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,808 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmime.c: XDG Mime Spec mime resolver.  Based on version 0.11 of the spec.
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ * 
+ * Copyright (C) 2003,2004  Red Hat, Inc.
+ * Copyright (C) 2003,2004  Jonathan Blandford <jrb at alum.mit.edu>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xdgmime.h"
+#include "xdgmimeint.h"
+#include "xdgmimeglob.h"
+#include "xdgmimemagic.h"
+#include "xdgmimealias.h"
+#include "xdgmimeparent.h"
+#include "xdgmimecache.h"
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <assert.h>
+
+typedef struct XdgDirTimeList XdgDirTimeList;
+typedef struct XdgCallbackList XdgCallbackList;
+
+static int need_reread = TRUE;
+static time_t last_stat_time = 0;
+
+static XdgGlobHash *global_hash = NULL;
+static XdgMimeMagic *global_magic = NULL;
+static XdgAliasList *alias_list = NULL;
+static XdgParentList *parent_list = NULL;
+static XdgDirTimeList *dir_time_list = NULL;
+static XdgCallbackList *callback_list = NULL;
+
+XdgMimeCache **_caches = NULL;
+static int n_caches = 0;
+
+const char *xdg_mime_type_unknown = "application/octet-stream";
+
+
+enum
+{
+  XDG_CHECKED_UNCHECKED,
+  XDG_CHECKED_VALID,
+  XDG_CHECKED_INVALID
+};
+
+struct XdgDirTimeList
+{
+  time_t mtime;
+  char *directory_name;
+  int checked;
+  XdgDirTimeList *next;
+};
+
+struct XdgCallbackList
+{
+  XdgCallbackList *next;
+  XdgCallbackList *prev;
+  int              callback_id;
+  XdgMimeCallback  callback;
+  void            *data;
+  XdgMimeDestroy   destroy;
+};
+
+/* Function called by xdg_run_command_on_dirs.  If it returns TRUE, further
+ * directories aren't looked at */
+typedef int (*XdgDirectoryFunc) (const char *directory,
+				 void       *user_data);
+
+static XdgDirTimeList *
+xdg_dir_time_list_new (void)
+{
+  XdgDirTimeList *retval;
+
+  retval = calloc (1, sizeof (XdgDirTimeList));
+  retval->checked = XDG_CHECKED_UNCHECKED;
+
+  return retval;
+}
+
+static void
+xdg_dir_time_list_free (XdgDirTimeList *list)
+{
+  XdgDirTimeList *next;
+
+  while (list)
+    {
+      next = list->next;
+      free (list->directory_name);
+      free (list);
+      list = next;
+    }
+}
+
+static int
+xdg_mime_init_from_directory (const char *directory)
+{
+  char *file_name;
+  struct stat st;
+  XdgDirTimeList *list;
+
+  assert (directory != NULL);
+
+  file_name = malloc (strlen (directory) + strlen ("/mime/mime.cache") + 1);
+  strcpy (file_name, directory); strcat (file_name, "/mime/mime.cache");
+  if (stat (file_name, &st) == 0)
+    {
+      XdgMimeCache *cache = _xdg_mime_cache_new_from_file (file_name);
+
+      if (cache != NULL)
+	{
+	  list = xdg_dir_time_list_new ();
+	  list->directory_name = file_name;
+	  list->mtime = st.st_mtime;
+	  list->next = dir_time_list;
+	  dir_time_list = list;
+
+	  _caches = realloc (_caches, sizeof (XdgMimeCache *) * (n_caches + 2));
+	  _caches[n_caches] = cache;
+          _caches[n_caches + 1] = NULL;
+	  n_caches++;
+
+	  return FALSE;
+	}
+    }
+  free (file_name);
+
+  file_name = malloc (strlen (directory) + strlen ("/mime/globs") + 1);
+  strcpy (file_name, directory); strcat (file_name, "/mime/globs");
+  if (stat (file_name, &st) == 0)
+    {
+      _xdg_mime_glob_read_from_file (global_hash, file_name);
+
+      list = xdg_dir_time_list_new ();
+      list->directory_name = file_name;
+      list->mtime = st.st_mtime;
+      list->next = dir_time_list;
+      dir_time_list = list;
+    }
+  else
+    {
+      free (file_name);
+    }
+
+  file_name = malloc (strlen (directory) + strlen ("/mime/magic") + 1);
+  strcpy (file_name, directory); strcat (file_name, "/mime/magic");
+  if (stat (file_name, &st) == 0)
+    {
+      _xdg_mime_magic_read_from_file (global_magic, file_name);
+
+      list = xdg_dir_time_list_new ();
+      list->directory_name = file_name;
+      list->mtime = st.st_mtime;
+      list->next = dir_time_list;
+      dir_time_list = list;
+    }
+  else
+    {
+      free (file_name);
+    }
+
+  file_name = malloc (strlen (directory) + strlen ("/mime/aliases") + 1);
+  strcpy (file_name, directory); strcat (file_name, "/mime/aliases");
+  _xdg_mime_alias_read_from_file (alias_list, file_name);
+  free (file_name);
+
+  file_name = malloc (strlen (directory) + strlen ("/mime/subclasses") + 1);
+  strcpy (file_name, directory); strcat (file_name, "/mime/subclasses");
+  _xdg_mime_parent_read_from_file (parent_list, file_name);
+  free (file_name);
+
+  return FALSE; /* Keep processing */
+}
+
+/* Runs a command on all the directories in the search path */
+static void
+xdg_run_command_on_dirs (XdgDirectoryFunc  func,
+			 void             *user_data)
+{
+  const char *xdg_data_home;
+  const char *xdg_data_dirs;
+  const char *ptr;
+
+  xdg_data_home = getenv ("XDG_DATA_HOME");
+  if (xdg_data_home)
+    {
+      if ((func) (xdg_data_home, user_data))
+	return;
+    }
+  else
+    {
+      const char *home;
+
+      home = getenv ("HOME");
+      if (home != NULL)
+	{
+	  char *guessed_xdg_home;
+	  int stop_processing;
+
+	  guessed_xdg_home = malloc (strlen (home) + strlen ("/.local/share/") + 1);
+	  strcpy (guessed_xdg_home, home);
+	  strcat (guessed_xdg_home, "/.local/share/");
+	  stop_processing = (func) (guessed_xdg_home, user_data);
+	  free (guessed_xdg_home);
+
+	  if (stop_processing)
+	    return;
+	}
+    }
+
+  xdg_data_dirs = getenv ("XDG_DATA_DIRS");
+  if (xdg_data_dirs == NULL)
+    xdg_data_dirs = "/usr/local/share/:/usr/share/";
+
+  ptr = xdg_data_dirs;
+
+  while (*ptr != '\000')
+    {
+      const char *end_ptr;
+      char *dir;
+      int len;
+      int stop_processing;
+
+      end_ptr = ptr;
+      while (*end_ptr != ':' && *end_ptr != '\000')
+	end_ptr ++;
+
+      if (end_ptr == ptr)
+	{
+	  ptr++;
+	  continue;
+	}
+
+      if (*end_ptr == ':')
+	len = end_ptr - ptr;
+      else
+	len = end_ptr - ptr + 1;
+      dir = malloc (len + 1);
+      strncpy (dir, ptr, len);
+      dir[len] = '\0';
+      stop_processing = (func) (dir, user_data);
+      free (dir);
+
+      if (stop_processing)
+	return;
+
+      ptr = end_ptr;
+    }
+}
+
+/* Checks file_path to make sure it has the same mtime as last time it was
+ * checked.  If it has a different mtime, or if the file doesn't exist, it
+ * returns FALSE.
+ *
+ * FIXME: This doesn't protect against permission changes.
+ */
+static int
+xdg_check_file (const char *file_path)
+{
+  struct stat st;
+
+  /* If the file exists */
+  if (stat (file_path, &st) == 0)
+    {
+      XdgDirTimeList *list;
+
+      for (list = dir_time_list; list; list = list->next)
+	{
+	  if (! strcmp (list->directory_name, file_path) &&
+	      st.st_mtime == list->mtime)
+	    {
+	      if (list->checked == XDG_CHECKED_UNCHECKED)
+		list->checked = XDG_CHECKED_VALID;
+	      else if (list->checked == XDG_CHECKED_VALID)
+		list->checked = XDG_CHECKED_INVALID;
+
+	      return (list->checked != XDG_CHECKED_VALID);
+	    }
+	}
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+static int
+xdg_check_dir (const char *directory,
+	       int        *invalid_dir_list)
+{
+  int invalid;
+  char *file_name;
+
+  assert (directory != NULL);
+
+  /* Check the globs file */
+  file_name = malloc (strlen (directory) + strlen ("/mime/globs") + 1);
+  strcpy (file_name, directory); strcat (file_name, "/mime/globs");
+  invalid = xdg_check_file (file_name);
+  free (file_name);
+  if (invalid)
+    {
+      *invalid_dir_list = TRUE;
+      return TRUE;
+    }
+
+  /* Check the magic file */
+  file_name = malloc (strlen (directory) + strlen ("/mime/magic") + 1);
+  strcpy (file_name, directory); strcat (file_name, "/mime/magic");
+  invalid = xdg_check_file (file_name);
+  free (file_name);
+  if (invalid)
+    {
+      *invalid_dir_list = TRUE;
+      return TRUE;
+    }
+
+  /* Check the mime.cache file */
+  file_name = malloc (strlen (directory) + strlen ("/mime/mime.cache") + 1);
+  strcpy (file_name, directory); strcat (file_name, "/mime/mime.cache");
+  invalid = xdg_check_file (file_name);
+  free (file_name);
+  if (invalid)
+    {
+      *invalid_dir_list = TRUE;
+      return TRUE;
+    }
+
+  return FALSE; /* Keep processing */
+}
+
+/* Walks through all the mime files stat()ing them to see if they've changed.
+ * Returns TRUE if they have. */
+static int
+xdg_check_dirs (void)
+{
+  XdgDirTimeList *list;
+  int invalid_dir_list = FALSE;
+
+  for (list = dir_time_list; list; list = list->next)
+    list->checked = XDG_CHECKED_UNCHECKED;
+
+  xdg_run_command_on_dirs ((XdgDirectoryFunc) xdg_check_dir,
+			   &invalid_dir_list);
+
+  if (invalid_dir_list)
+    return TRUE;
+
+  for (list = dir_time_list; list; list = list->next)
+    {
+      if (list->checked != XDG_CHECKED_VALID)
+	return TRUE;
+    }
+
+  return FALSE;
+}
+
+/* We want to avoid stat()ing on every single mime call, so we only look for
+ * newer files every 5 seconds.  This will return TRUE if we need to reread the
+ * mime data from disk.
+ */
+static int
+xdg_check_time_and_dirs (void)
+{
+  struct timeval tv;
+  time_t current_time;
+  int retval = FALSE;
+
+  gettimeofday (&tv, NULL);
+  current_time = tv.tv_sec;
+
+  if (current_time >= last_stat_time + 5)
+    {
+      retval = xdg_check_dirs ();
+      last_stat_time = current_time;
+    }
+
+  return retval;
+}
+
+/* Called in every public function.  It reloads the hash function if need be.
+ */
+static void
+xdg_mime_init (void)
+{
+  if (xdg_check_time_and_dirs ())
+    {
+      xdg_mime_shutdown ();
+    }
+
+  if (need_reread)
+    {
+      global_hash = _xdg_glob_hash_new ();
+      global_magic = _xdg_mime_magic_new ();
+      alias_list = _xdg_mime_alias_list_new ();
+      parent_list = _xdg_mime_parent_list_new ();
+
+      xdg_run_command_on_dirs ((XdgDirectoryFunc) xdg_mime_init_from_directory,
+			       NULL);
+
+      need_reread = FALSE;
+    }
+}
+
+const char *
+xdg_mime_get_mime_type_for_data (const void *data,
+				 size_t      len)
+{
+  const char *mime_type;
+
+  xdg_mime_init ();
+
+  if (_caches)
+    return _xdg_mime_cache_get_mime_type_for_data (data, len);
+
+  mime_type = _xdg_mime_magic_lookup_data (global_magic, data, len, NULL, 0);
+
+  if (mime_type)
+    return mime_type;
+
+  return XDG_MIME_TYPE_UNKNOWN;
+}
+
+const char *
+xdg_mime_get_mime_type_for_file (const char  *file_name,
+                                 struct stat *statbuf)
+{
+  const char *mime_type;
+  /* currently, only a few globs occur twice, and none
+   * more often, so 5 seems plenty.
+   */
+  const char *mime_types[5];
+  FILE *file;
+  unsigned char *data;
+  int max_extent;
+  int bytes_read;
+  struct stat buf;
+  const char *base_name;
+  int n;
+
+  if (file_name == NULL)
+    return NULL;
+  if (! _xdg_utf8_validate (file_name))
+    return NULL;
+
+  xdg_mime_init ();
+
+  if (_caches)
+    return _xdg_mime_cache_get_mime_type_for_file (file_name, statbuf);
+
+  base_name = _xdg_get_base_name (file_name);
+  n = _xdg_glob_hash_lookup_file_name (global_hash, base_name, mime_types, 5);
+
+  if (n == 1)
+    return mime_types[0];
+
+  if (!statbuf)
+    {
+      if (stat (file_name, &buf) != 0)
+	return XDG_MIME_TYPE_UNKNOWN;
+
+      statbuf = &buf;
+    }
+
+  if (!S_ISREG (statbuf->st_mode))
+    return XDG_MIME_TYPE_UNKNOWN;
+
+  /* FIXME: Need to make sure that max_extent isn't totally broken.  This could
+   * be large and need getting from a stream instead of just reading it all
+   * in. */
+  max_extent = _xdg_mime_magic_get_buffer_extents (global_magic);
+  data = malloc (max_extent);
+  if (data == NULL)
+    return XDG_MIME_TYPE_UNKNOWN;
+        
+  file = fopen (file_name, "r");
+  if (file == NULL)
+    {
+      free (data);
+      return XDG_MIME_TYPE_UNKNOWN;
+    }
+
+  bytes_read = fread (data, 1, max_extent, file);
+  if (ferror (file))
+    {
+      free (data);
+      fclose (file);
+      return XDG_MIME_TYPE_UNKNOWN;
+    }
+
+  mime_type = _xdg_mime_magic_lookup_data (global_magic, data, bytes_read,
+					   mime_types, n);
+
+  free (data);
+  fclose (file);
+
+  if (mime_type)
+    return mime_type;
+
+  return XDG_MIME_TYPE_UNKNOWN;
+}
+
+const char *
+xdg_mime_get_mime_type_from_file_name (const char *file_name)
+{
+  const char *mime_types[2];
+
+  xdg_mime_init ();
+
+  if (_caches)
+    return _xdg_mime_cache_get_mime_type_from_file_name (file_name);
+
+  if (_xdg_glob_hash_lookup_file_name (global_hash, file_name, mime_types, 2) == 1)
+    return mime_types[0];
+  else
+    return XDG_MIME_TYPE_UNKNOWN;
+}
+
+int
+xdg_mime_is_valid_mime_type (const char *mime_type)
+{
+  /* FIXME: We should make this a better test
+   */
+  return _xdg_utf8_validate (mime_type);
+}
+
+void
+xdg_mime_shutdown (void)
+{
+  XdgCallbackList *list;
+
+  /* FIXME: Need to make this (and the whole library) thread safe */
+  if (dir_time_list)
+    {
+      xdg_dir_time_list_free (dir_time_list);
+      dir_time_list = NULL;
+    }
+	
+  if (global_hash)
+    {
+      _xdg_glob_hash_free (global_hash);
+      global_hash = NULL;
+    }
+  if (global_magic)
+    {
+      _xdg_mime_magic_free (global_magic);
+      global_magic = NULL;
+    }
+
+  if (alias_list)
+    {
+      _xdg_mime_alias_list_free (alias_list);
+      alias_list = NULL;
+    }
+
+  if (parent_list)
+    {
+      _xdg_mime_parent_list_free (parent_list);
+      parent_list = NULL;
+    }
+  
+  for (list = callback_list; list; list = list->next)
+    (list->callback) (list->data);
+
+  need_reread = TRUE;
+}
+
+int
+xdg_mime_get_max_buffer_extents (void)
+{
+  xdg_mime_init ();
+  
+  if (_caches)
+    return _xdg_mime_cache_get_max_buffer_extents ();
+
+  return _xdg_mime_magic_get_buffer_extents (global_magic);
+}
+
+const char *
+xdg_mime_unalias_mime_type (const char *mime_type)
+{
+  const char *lookup;
+
+  xdg_mime_init ();
+
+  if (_caches)
+    return _xdg_mime_cache_unalias_mime_type (mime_type);
+
+  if ((lookup = _xdg_mime_alias_list_lookup (alias_list, mime_type)) != NULL)
+    return lookup;
+
+  return mime_type;
+}
+
+int
+xdg_mime_mime_type_equal (const char *mime_a,
+			  const char *mime_b)
+{
+  const char *unalias_a, *unalias_b;
+
+  xdg_mime_init ();
+
+  unalias_a = xdg_mime_unalias_mime_type (mime_a);
+  unalias_b = xdg_mime_unalias_mime_type (mime_b);
+
+  if (strcmp (unalias_a, unalias_b) == 0)
+    return 1;
+
+  return 0;
+}
+
+int
+xdg_mime_media_type_equal (const char *mime_a,
+			   const char *mime_b)
+{
+  char *sep;
+
+  xdg_mime_init ();
+
+  sep = strchr (mime_a, '/');
+  
+  if (sep && strncmp (mime_a, mime_b, sep - mime_a + 1) == 0)
+    return 1;
+
+  return 0;
+}
+
+#if 0
+static int
+xdg_mime_is_super_type (const char *mime)
+{
+  int length;
+  const char *type;
+
+  length = strlen (mime);
+  type = &(mime[length - 2]);
+
+  if (strcmp (type, "/*") == 0)
+    return 1;
+
+  return 0;
+}
+#endif
+
+int
+xdg_mime_mime_type_subclass (const char *mime,
+			     const char *base)
+{
+  const char *umime, *ubase;
+  const char **parents;
+
+  xdg_mime_init ();
+
+  if (_caches)
+    return _xdg_mime_cache_mime_type_subclass (mime, base);
+
+  umime = xdg_mime_unalias_mime_type (mime);
+  ubase = xdg_mime_unalias_mime_type (base);
+
+  if (strcmp (umime, ubase) == 0)
+    return 1;
+
+#if 0  
+  /* Handle supertypes */
+  if (xdg_mime_is_super_type (ubase) &&
+      xdg_mime_media_type_equal (umime, ubase))
+    return 1;
+#endif
+
+  /*  Handle special cases text/plain and application/octet-stream */
+  if (strcmp (ubase, "text/plain") == 0 && 
+      strncmp (umime, "text/", 5) == 0)
+    return 1;
+
+  if (strcmp (ubase, "application/octet-stream") == 0)
+    return 1;
+  
+  parents = _xdg_mime_parent_list_lookup (parent_list, umime);
+  for (; parents && *parents; parents++)
+    {
+      if (xdg_mime_mime_type_subclass (*parents, ubase))
+	return 1;
+    }
+
+  return 0;
+}
+
+char **
+xdg_mime_list_mime_parents (const char *mime)
+{
+  const char **parents;
+  char **result;
+  int i, n;
+
+  if (_caches)
+    return _xdg_mime_cache_list_mime_parents (mime);
+
+  parents = xdg_mime_get_mime_parents (mime);
+
+  if (!parents)
+    return NULL;
+
+  for (i = 0; parents[i]; i++) ;
+  
+  n = (i + 1) * sizeof (char *);
+  result = (char **) malloc (n);
+  memcpy (result, parents, n);
+
+  return result;
+}
+
+const char **
+xdg_mime_get_mime_parents (const char *mime)
+{
+  const char *umime;
+
+  xdg_mime_init ();
+
+  umime = xdg_mime_unalias_mime_type (mime);
+
+  return _xdg_mime_parent_list_lookup (parent_list, umime);
+}
+
+void 
+xdg_mime_dump (void)
+{
+  printf ("*** ALIASES ***\n\n");
+  _xdg_mime_alias_list_dump (alias_list);
+  printf ("\n*** PARENTS ***\n\n");
+  _xdg_mime_parent_list_dump (parent_list);
+}
+
+
+/* Registers a function to be called every time the mime database reloads its files
+ */
+int
+xdg_mime_register_reload_callback (XdgMimeCallback  callback,
+				   void            *data,
+				   XdgMimeDestroy   destroy)
+{
+  XdgCallbackList *list_el;
+  static int callback_id = 1;
+
+  /* Make a new list element */
+  list_el = calloc (1, sizeof (XdgCallbackList));
+  list_el->callback_id = callback_id;
+  list_el->callback = callback;
+  list_el->data = data;
+  list_el->destroy = destroy;
+  list_el->next = callback_list;
+  if (list_el->next)
+    list_el->next->prev = list_el;
+
+  callback_list = list_el;
+  callback_id ++;
+
+  return callback_id - 1;
+}
+
+void
+xdg_mime_remove_callback (int callback_id)
+{
+  XdgCallbackList *list;
+
+  for (list = callback_list; list; list = list->next)
+    {
+      if (list->callback_id == callback_id)
+	{
+	  if (list->next)
+	    list->next = list->prev;
+
+	  if (list->prev)
+	    list->prev->next = list->next;
+	  else
+	    callback_list = list->next;
+
+	  /* invoke the destroy handler */
+	  (list->destroy) (list->data);
+	  free (list);
+	  return;
+	}
+    }
+}

Added: trunk/Utils/xdgmime/xdgmime.h
===================================================================
--- trunk/Utils/xdgmime/xdgmime.h	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmime.h	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,102 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmime.h: XDG Mime Spec mime resolver.  Based on version 0.11 of the spec.
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ * 
+ * Copyright (C) 2003  Red Hat, Inc.
+ * Copyright (C) 2003  Jonathan Blandford <jrb at alum.mit.edu>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+#ifndef __XDG_MIME_H__
+#define __XDG_MIME_H__
+
+#include <stdlib.h>
+#include <sys/stat.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifdef XDG_PREFIX
+#define XDG_ENTRY(func) _XDG_ENTRY2(XDG_PREFIX,func)
+#define _XDG_ENTRY2(prefix,func) _XDG_ENTRY3(prefix,func)
+#define _XDG_ENTRY3(prefix,func) prefix##_##func
+#endif
+
+typedef void (*XdgMimeCallback) (void *user_data);
+typedef void (*XdgMimeDestroy)  (void *user_data);
+
+  
+#ifdef XDG_PREFIX
+#define xdg_mime_get_mime_type_for_data       XDG_ENTRY(get_mime_type_for_data)
+#define xdg_mime_get_mime_type_for_file       XDG_ENTRY(get_mime_type_for_file)
+#define xdg_mime_get_mime_type_from_file_name XDG_ENTRY(get_mime_type_from_file_name)
+#define xdg_mime_is_valid_mime_type           XDG_ENTRY(is_valid_mime_type)
+#define xdg_mime_mime_type_equal              XDG_ENTRY(mime_type_equal)
+#define xdg_mime_media_type_equal             XDG_ENTRY(media_type_equal)
+#define xdg_mime_mime_type_subclass           XDG_ENTRY(mime_type_subclass)
+#define xdg_mime_get_mime_parents             XDG_ENTRY(get_mime_parents)
+#define xdg_mime_list_mime_parents            XDG_ENTRY(list_mime_parents)
+#define xdg_mime_unalias_mime_type            XDG_ENTRY(unalias_mime_type)
+#define xdg_mime_get_max_buffer_extents       XDG_ENTRY(get_max_buffer_extents)
+#define xdg_mime_shutdown                     XDG_ENTRY(shutdown)
+#define xdg_mime_register_reload_callback     XDG_ENTRY(register_reload_callback)
+#define xdg_mime_remove_callback              XDG_ENTRY(remove_callback)
+#define xdg_mime_type_unknown                 XDG_ENTRY(type_unknown)
+#endif
+
+extern const char *xdg_mime_type_unknown;
+#define XDG_MIME_TYPE_UNKNOWN xdg_mime_type_unknown
+
+const char  *xdg_mime_get_mime_type_for_data       (const void *data,
+						    size_t      len);
+const char  *xdg_mime_get_mime_type_for_file       (const char *file_name,
+                                                    struct stat *statbuf);
+const char  *xdg_mime_get_mime_type_from_file_name (const char *file_name);
+int          xdg_mime_is_valid_mime_type           (const char *mime_type);
+int          xdg_mime_mime_type_equal              (const char *mime_a,
+						    const char *mime_b);
+int          xdg_mime_media_type_equal             (const char *mime_a,
+						    const char *mime_b);
+int          xdg_mime_mime_type_subclass           (const char *mime_a,
+						    const char *mime_b);
+  /* xdg_mime_get_mime_parents() is deprecated since it does
+   * not work correctly with caches. Use xdg_mime_list_parents() 
+   * instead, but notice that that function expects you to free
+   * the array it returns. 
+   */
+const char **xdg_mime_get_mime_parents		   (const char *mime);
+char **      xdg_mime_list_mime_parents		   (const char *mime);
+const char  *xdg_mime_unalias_mime_type		   (const char *mime);
+int          xdg_mime_get_max_buffer_extents       (void);
+void         xdg_mime_shutdown                     (void);
+void         xdg_mime_dump                         (void);
+int          xdg_mime_register_reload_callback     (XdgMimeCallback  callback,
+						    void            *data,
+						    XdgMimeDestroy   destroy);
+void         xdg_mime_remove_callback              (int              callback_id);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __XDG_MIME_H__ */

Added: trunk/Utils/xdgmime/xdgmimealias.c
===================================================================
--- trunk/Utils/xdgmime/xdgmimealias.c	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmimealias.c	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,184 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmimealias.c: Private file.  Datastructure for storing the aliases.
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ *
+ * Copyright (C) 2004  Red Hat, Inc.
+ * Copyright (C) 2004  Matthias Clasen <mclasen at redhat.com>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xdgmimealias.h"
+#include "xdgmimeint.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <fnmatch.h>
+
+#ifndef	FALSE
+#define	FALSE	(0)
+#endif
+
+#ifndef	TRUE
+#define	TRUE	(!FALSE)
+#endif
+
+typedef struct XdgAlias XdgAlias;
+
+struct XdgAlias 
+{
+  char *alias;
+  char *mime_type;
+};
+
+struct XdgAliasList
+{
+  struct XdgAlias *aliases;
+  int n_aliases;
+};
+
+XdgAliasList *
+_xdg_mime_alias_list_new (void)
+{
+  XdgAliasList *list;
+
+  list = malloc (sizeof (XdgAliasList));
+
+  list->aliases = NULL;
+  list->n_aliases = 0;
+
+  return list;
+}
+
+void         
+_xdg_mime_alias_list_free (XdgAliasList *list)
+{
+  int i;
+
+  if (list->aliases)
+    {
+      for (i = 0; i < list->n_aliases; i++)
+	{
+	  free (list->aliases[i].alias);
+	  free (list->aliases[i].mime_type);
+	}
+      free (list->aliases);
+    }
+  free (list);
+}
+
+static int
+alias_entry_cmp (const void *v1, const void *v2)
+{
+  return strcmp (((XdgAlias *)v1)->alias, ((XdgAlias *)v2)->alias);
+}
+
+const char  *
+_xdg_mime_alias_list_lookup (XdgAliasList *list,
+			     const char   *alias)
+{
+  XdgAlias *entry;
+  XdgAlias key;
+
+  if (list->n_aliases > 0)
+    {
+      key.alias = (char *)alias;
+      key.mime_type = 0;
+
+      entry = bsearch (&key, list->aliases, list->n_aliases,
+		       sizeof (XdgAlias), alias_entry_cmp);
+      if (entry)
+        return entry->mime_type;
+    }
+
+  return NULL;
+}
+
+void
+_xdg_mime_alias_read_from_file (XdgAliasList *list,
+				const char   *file_name)
+{
+  FILE *file;
+  char line[255];
+  int alloc;
+
+  file = fopen (file_name, "r");
+
+  if (file == NULL)
+    return;
+
+  /* FIXME: Not UTF-8 safe.  Doesn't work if lines are greater than 255 chars.
+   * Blah */
+  alloc = list->n_aliases + 16;
+  list->aliases = realloc (list->aliases, alloc * sizeof (XdgAlias));
+  while (fgets (line, 255, file) != NULL)
+    {
+      char *sep;
+      if (line[0] == '#')
+	continue;
+
+      sep = strchr (line, ' ');
+      if (sep == NULL)
+	continue;
+      *(sep++) = '\000';
+      sep[strlen (sep) -1] = '\000';
+      if (list->n_aliases == alloc)
+	{
+	  alloc <<= 1;
+	  list->aliases = realloc (list->aliases, 
+				   alloc * sizeof (XdgAlias));
+	}
+      list->aliases[list->n_aliases].alias = strdup (line);
+      list->aliases[list->n_aliases].mime_type = strdup (sep);
+      list->n_aliases++;
+    }
+  list->aliases = realloc (list->aliases, 
+			   list->n_aliases * sizeof (XdgAlias));
+
+  fclose (file);  
+  
+  if (list->n_aliases > 1)
+    qsort (list->aliases, list->n_aliases, 
+           sizeof (XdgAlias), alias_entry_cmp);
+}
+
+
+void
+_xdg_mime_alias_list_dump (XdgAliasList *list)
+{
+  int i;
+
+  if (list->aliases)
+    {
+      for (i = 0; i < list->n_aliases; i++)
+	{
+	  printf ("%s %s\n", 
+		  list->aliases[i].alias,
+		  list->aliases[i].mime_type);
+	}
+    }
+}
+
+

Added: trunk/Utils/xdgmime/xdgmimealias.h
===================================================================
--- trunk/Utils/xdgmime/xdgmimealias.h	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmimealias.h	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,50 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmimealias.h: Private file.  Datastructure for storing the aliases.
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ *
+ * Copyright (C) 2004  Red Hat, Inc.
+ * Copyright (C) 200  Matthias Clasen <mclasen at redhat.com>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __XDG_MIME_ALIAS_H__
+#define __XDG_MIME_ALIAS_H__
+
+#include "xdgmime.h"
+
+typedef struct XdgAliasList XdgAliasList;
+
+#ifdef XDG_PREFIX
+#define _xdg_mime_alias_read_from_file        XDG_ENTRY(alias_read_from_file)
+#define _xdg_mime_alias_list_new              XDG_ENTRY(alias_list_new)
+#define _xdg_mime_alias_list_free             XDG_ENTRY(alias_list_free)
+#define _xdg_mime_alias_list_lookup           XDG_ENTRY(alias_list_lookup)
+#endif
+
+void          _xdg_mime_alias_read_from_file (XdgAliasList *list,
+					      const char   *file_name);
+XdgAliasList *_xdg_mime_alias_list_new       (void);
+void          _xdg_mime_alias_list_free      (XdgAliasList *list);
+const char   *_xdg_mime_alias_list_lookup    (XdgAliasList *list,
+					      const char  *alias);
+void          _xdg_mime_alias_list_dump      (XdgAliasList *list);
+
+#endif /* __XDG_MIME_ALIAS_H__ */

Added: trunk/Utils/xdgmime/xdgmimecache.c
===================================================================
--- trunk/Utils/xdgmime/xdgmimecache.c	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmimecache.c	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,888 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmimealias.c: Private file.  mmappable caches for mime data
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ *
+ * Copyright (C) 2005  Matthias Clasen <mclasen at redhat.com>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <fnmatch.h>
+#include <assert.h>
+
+#include <netinet/in.h> /* for ntohl/ntohs */
+
+#ifdef HAVE_MMAP
+#include <sys/mman.h>
+#endif
+
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include "xdgmimecache.h"
+#include "xdgmimeint.h"
+
+#ifndef MAX
+#define MAX(a,b) ((a) > (b) ? (a) : (b))
+#endif
+
+#ifndef	FALSE
+#define	FALSE	(0)
+#endif
+
+#ifndef	TRUE
+#define	TRUE	(!FALSE)
+#endif
+
+#ifndef _O_BINARY
+#define _O_BINARY 0
+#endif
+
+#ifndef MAP_FAILED
+#define MAP_FAILED ((void *) -1)
+#endif
+
+#define MAJOR_VERSION 1
+#define MINOR_VERSION 0
+
+struct _XdgMimeCache
+{
+  int ref_count;
+
+  size_t  size;
+  char   *buffer;
+};
+
+#define GET_UINT16(cache,offset) (ntohs(*(xdg_uint16_t*)((cache) + (offset))))
+#define GET_UINT32(cache,offset) (ntohl(*(xdg_uint32_t*)((cache) + (offset))))
+
+XdgMimeCache *
+_xdg_mime_cache_ref (XdgMimeCache *cache)
+{
+  cache->ref_count++;
+  return cache;
+}
+
+void
+_xdg_mime_cache_unref (XdgMimeCache *cache)
+{
+  cache->ref_count--;
+
+  if (cache->ref_count == 0)
+    {
+#ifdef HAVE_MMAP
+      munmap (cache->buffer, cache->size);
+#endif
+      free (cache);
+    }
+}
+
+XdgMimeCache *
+_xdg_mime_cache_new_from_file (const char *file_name)
+{
+  XdgMimeCache *cache = NULL;
+
+#ifdef HAVE_MMAP
+  int fd = -1;
+  struct stat st;
+  char *buffer = NULL;
+
+  /* Open the file and map it into memory */
+  fd = open (file_name, O_RDONLY|_O_BINARY, 0);
+
+  if (fd < 0)
+    return NULL;
+  
+  if (fstat (fd, &st) < 0 || st.st_size < 4)
+    goto done;
+
+  buffer = (char *) mmap (NULL, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
+
+  if (buffer == MAP_FAILED)
+    goto done;
+
+  /* Verify version */
+  if (GET_UINT16 (buffer, 0) != MAJOR_VERSION ||
+      GET_UINT16 (buffer, 2) != MINOR_VERSION)
+    {
+      munmap (buffer, st.st_size);
+
+      goto done;
+    }
+  
+  cache = (XdgMimeCache *) malloc (sizeof (XdgMimeCache));
+  cache->ref_count = 1;
+  cache->buffer = buffer;
+  cache->size = st.st_size;
+
+ done:
+  if (fd != -1)
+    close (fd);
+
+#endif  /* HAVE_MMAP */
+
+  return cache;
+}
+
+static int
+cache_magic_matchlet_compare_to_data (XdgMimeCache *cache, 
+				      xdg_uint32_t  offset,
+				      const void   *data,
+				      size_t        len)
+{
+  xdg_uint32_t range_start = GET_UINT32 (cache->buffer, offset);
+  xdg_uint32_t range_length = GET_UINT32 (cache->buffer, offset + 4);
+  xdg_uint32_t data_length = GET_UINT32 (cache->buffer, offset + 12);
+  xdg_uint32_t data_offset = GET_UINT32 (cache->buffer, offset + 16);
+  xdg_uint32_t mask_offset = GET_UINT32 (cache->buffer, offset + 20);
+  
+  int i, j;
+
+  for (i = range_start; i <= range_start + range_length; i++)
+    {
+      int valid_matchlet = TRUE;
+      
+      if (i + data_length > len)
+	return FALSE;
+
+      if (mask_offset)
+	{
+	  for (j = 0; j < data_length; j++)
+	    {
+	      if ((((unsigned char *)cache->buffer)[data_offset + j] & ((unsigned char *)cache->buffer)[mask_offset + j]) !=
+		  ((((unsigned char *) data)[j + i]) & ((unsigned char *)cache->buffer)[mask_offset + j]))
+		{
+		  valid_matchlet = FALSE;
+		  break;
+		}
+	    }
+	}
+      else
+	{
+	  for (j = 0; j < data_length; j++)
+	    {
+	      if (((unsigned char *)cache->buffer)[data_offset + j] != ((unsigned char *) data)[j + i])
+		{
+		  valid_matchlet = FALSE;
+		  break;
+		}
+	    }
+	}
+      
+      if (valid_matchlet)
+	return TRUE;
+    }
+  
+  return FALSE;  
+}
+
+static int
+cache_magic_matchlet_compare (XdgMimeCache *cache, 
+			      xdg_uint32_t  offset,
+			      const void   *data,
+			      size_t        len)
+{
+  xdg_uint32_t n_children = GET_UINT32 (cache->buffer, offset + 24);
+  xdg_uint32_t child_offset = GET_UINT32 (cache->buffer, offset + 28);
+
+  int i;
+  
+  if (cache_magic_matchlet_compare_to_data (cache, offset, data, len))
+    {
+      if (n_children == 0)
+	return TRUE;
+      
+      for (i = 0; i < n_children; i++)
+	{
+	  if (cache_magic_matchlet_compare (cache, child_offset + 32 * i,
+					    data, len))
+	    return TRUE;
+	}
+    }
+  
+  return FALSE;  
+}
+
+static const char *
+cache_magic_compare_to_data (XdgMimeCache *cache, 
+			     xdg_uint32_t  offset,
+			     const void   *data, 
+			     size_t        len, 
+			     int          *prio)
+{
+  xdg_uint32_t priority = GET_UINT32 (cache->buffer, offset);
+  xdg_uint32_t mimetype_offset = GET_UINT32 (cache->buffer, offset + 4);
+  xdg_uint32_t n_matchlets = GET_UINT32 (cache->buffer, offset + 8);
+  xdg_uint32_t matchlet_offset = GET_UINT32 (cache->buffer, offset + 12);
+
+  int i;
+
+  for (i = 0; i < n_matchlets; i++)
+    {
+      if (cache_magic_matchlet_compare (cache, matchlet_offset + i * 32, 
+					data, len))
+	{
+	  *prio = priority;
+	  
+	  return cache->buffer + mimetype_offset;
+	}
+    }
+
+  return NULL;
+}
+
+static const char *
+cache_magic_lookup_data (XdgMimeCache *cache, 
+			 const void   *data, 
+			 size_t        len, 
+			 int          *prio,
+			 const char   *mime_types[],
+			 int           n_mime_types)
+{
+  xdg_uint32_t list_offset;
+  xdg_uint32_t n_entries;
+  xdg_uint32_t offset;
+
+  int j, n;
+
+  *prio = 0;
+
+  list_offset = GET_UINT32 (cache->buffer, 24);
+  n_entries = GET_UINT32 (cache->buffer, list_offset);
+  offset = GET_UINT32 (cache->buffer, list_offset + 8);
+  
+  for (j = 0; j < n_entries; j++)
+    {
+      const char *match;
+
+      match = cache_magic_compare_to_data (cache, offset + 16 * j, 
+					   data, len, prio);
+      if (match)
+	return match;
+      else
+	{
+	  xdg_uint32_t mimetype_offset;
+	  const char *non_match;
+	  
+	  mimetype_offset = GET_UINT32 (cache->buffer, offset + 16 * j + 4);
+	  non_match = cache->buffer + mimetype_offset;
+
+	  for (n = 0; n < n_mime_types; n++)
+	    {
+	      if (mime_types[n] && 
+		  xdg_mime_mime_type_equal (mime_types[n], non_match))
+		mime_types[n] = NULL;
+	    }
+	}
+    }
+
+  return NULL;
+}
+
+static const char *
+cache_alias_lookup (const char *alias)
+{
+  const char *ptr;
+  int i, min, max, mid, cmp;
+
+  for (i = 0; _caches[i]; i++)
+    {
+      XdgMimeCache *cache = _caches[i];
+      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 4);
+      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);
+      xdg_uint32_t offset;
+
+      min = 0; 
+      max = n_entries - 1;
+      while (max >= min) 
+	{
+	  mid = (min + max) / 2;
+
+	  offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * mid);
+	  ptr = cache->buffer + offset;
+	  cmp = strcmp (ptr, alias);
+	  
+	  if (cmp < 0)
+	    min = mid + 1;
+	  else if (cmp > 0)
+	    max = mid - 1;
+	  else
+	    {
+	      offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * mid + 4);
+	      return cache->buffer + offset;
+	    }
+	}
+    }
+
+  return NULL;
+}
+
+static int
+cache_glob_lookup_literal (const char *file_name,
+			   const char *mime_types[],
+			   int         n_mime_types)
+{
+  const char *ptr;
+  int i, min, max, mid, cmp;
+
+  for (i = 0; _caches[i]; i++)
+    {
+      XdgMimeCache *cache = _caches[i];
+      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 12);
+      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);
+      xdg_uint32_t offset;
+
+      min = 0; 
+      max = n_entries - 1;
+      while (max >= min) 
+	{
+	  mid = (min + max) / 2;
+
+	  offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * mid);
+	  ptr = cache->buffer + offset;
+	  cmp = strcmp (ptr, file_name);
+	  
+	  if (cmp < 0)
+	    min = mid + 1;
+	  else if (cmp > 0)
+	    max = mid - 1;
+	  else
+	    {
+	      offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * mid + 4);
+	      mime_types[0] = (const char *)(cache->buffer + offset);
+	      
+	      return 1;
+	    }
+	}
+    }
+
+  return 0;
+}
+
+static int
+cache_glob_lookup_fnmatch (const char *file_name,
+			   const char *mime_types[],
+			   int         n_mime_types)
+{
+  const char *mime_type;
+  const char *ptr;
+
+  int i, j, n;
+
+  n = 0;
+  for (i = 0; _caches[i]; i++)
+    {
+      XdgMimeCache *cache = _caches[i];
+
+      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 20);
+      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);
+
+      for (j = 0; j < n_entries && n < n_mime_types; j++)
+	{
+	  xdg_uint32_t offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * j);
+	  xdg_uint32_t mimetype_offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * j + 4);
+	  ptr = cache->buffer + offset;
+	  mime_type = cache->buffer + mimetype_offset;
+
+	  /* FIXME: Not UTF-8 safe */
+	  if (fnmatch (ptr, file_name, 0) == 0)
+	    mime_types[n++] = mime_type;
+	}
+
+      if (n > 0)
+	return n;
+    }
+  
+  return 0;
+}
+
+static int
+cache_glob_node_lookup_suffix (XdgMimeCache *cache,
+			       xdg_uint32_t  n_entries,
+			       xdg_uint32_t  offset,
+			       const char   *suffix, 
+			       int           ignore_case,
+			       const char   *mime_types[],
+			       int           n_mime_types)
+{
+  xdg_unichar_t character;
+  xdg_unichar_t match_char;
+  xdg_uint32_t mimetype_offset;
+  xdg_uint32_t n_children;
+  xdg_uint32_t child_offset; 
+
+  int min, max, mid, n, i;
+
+  character = _xdg_utf8_to_ucs4 (suffix);
+  if (ignore_case)
+    character = _xdg_ucs4_to_lower (character);
+
+  min = 0;
+  max = n_entries - 1;
+  while (max >= min)
+    {
+      mid = (min + max) /  2;
+
+      match_char = GET_UINT32 (cache->buffer, offset + 16 * mid);
+
+      if (match_char < character)
+	min = mid + 1;
+      else if (match_char > character)
+	max = mid - 1;
+      else 
+	{
+	  suffix = _xdg_utf8_next_char (suffix);
+	  if (*suffix == '\0')
+	    {
+	      mimetype_offset = GET_UINT32 (cache->buffer, offset + 16 * mid + 4);
+	      n = 0;
+	      mime_types[n++] = cache->buffer + mimetype_offset;
+	      
+	      n_children = GET_UINT32 (cache->buffer, offset + 16 * mid + 8);
+	      child_offset = GET_UINT32 (cache->buffer, offset + 16 * mid + 12);
+	      i = 0;
+	      while (n < n_mime_types && i < n_children)
+		{
+		  match_char = GET_UINT32 (cache->buffer, child_offset + 16 * i);
+		  mimetype_offset = GET_UINT32 (cache->buffer, offset + 16 * i + 4);
+		  if (match_char != 0)
+		    break;
+
+		  mime_types[n++] = cache->buffer + mimetype_offset;
+		  i++;
+		}
+
+	      return n;
+	    }
+	  else
+	    {
+	      n_children = GET_UINT32 (cache->buffer, offset + 16 * mid + 8);
+	      child_offset = GET_UINT32 (cache->buffer, offset + 16 * mid + 12);
+      
+	      return cache_glob_node_lookup_suffix (cache, 
+						    n_children, child_offset,
+						    suffix, ignore_case,
+						    mime_types,
+						    n_mime_types);
+	    }
+	}
+    }
+
+  return 0;
+}
+
+static int
+cache_glob_lookup_suffix (const char *suffix, 
+			  int         ignore_case,
+			  const char *mime_types[],
+			  int         n_mime_types)
+{
+  int i, n;
+
+  for (i = 0; _caches[i]; i++)
+    {
+      XdgMimeCache *cache = _caches[i];
+
+      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 16);
+      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);
+      xdg_uint32_t offset = GET_UINT32 (cache->buffer, list_offset + 4);
+
+      n = cache_glob_node_lookup_suffix (cache, 
+					 n_entries, offset, 
+					 suffix, ignore_case,
+					 mime_types,
+					 n_mime_types);
+      if (n > 0)
+	return n;
+    }
+
+  return 0;
+}
+
+static void
+find_stopchars (char *stopchars)
+{
+  int i, j, k, l;
+ 
+  k = 0;
+  for (i = 0; _caches[i]; i++)
+    {
+      XdgMimeCache *cache = _caches[i];
+
+      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 16);
+      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);
+      xdg_uint32_t offset = GET_UINT32 (cache->buffer, list_offset + 4);
+
+      for (j = 0; j < n_entries; j++)
+	{
+	  xdg_uint32_t match_char = GET_UINT32 (cache->buffer, offset);
+	  
+	  if (match_char < 128)
+	    {
+	      for (l = 0; l < k; l++)
+		if (stopchars[l] == match_char)
+		  break;
+	      if (l == k)
+		{
+		  stopchars[k] = (char) match_char;
+		  k++;
+		}
+	    }
+
+	  offset += 16;
+	}
+    }
+
+  stopchars[k] = '\0';
+}
+
+static int
+cache_glob_lookup_file_name (const char *file_name, 
+			     const char *mime_types[],
+			     int         n_mime_types)
+{
+  const char *ptr;
+  char stopchars[128];
+  int n;
+  
+  assert (file_name != NULL);
+
+  /* First, check the literals */
+  n = cache_glob_lookup_literal (file_name, mime_types, n_mime_types);
+  if (n > 0)
+    return n;
+
+  find_stopchars (stopchars);
+
+  /* Next, check suffixes */
+  ptr = strpbrk (file_name, stopchars);
+  while (ptr)
+    {
+      n = cache_glob_lookup_suffix (ptr, FALSE, mime_types, n_mime_types);
+      if (n > 0)
+	return n;
+      
+      n = cache_glob_lookup_suffix (ptr, TRUE, mime_types, n_mime_types);
+      if (n > 0)
+	return n;
+
+      ptr = strpbrk (ptr + 1, stopchars);
+    }
+  
+  /* Last, try fnmatch */
+  return cache_glob_lookup_fnmatch (file_name, mime_types, n_mime_types);
+}
+
+int
+_xdg_mime_cache_get_max_buffer_extents (void)
+{
+  xdg_uint32_t offset;
+  xdg_uint32_t max_extent;
+  int i;
+
+  max_extent = 0;
+  for (i = 0; _caches[i]; i++)
+    {
+      XdgMimeCache *cache = _caches[i];
+
+      offset = GET_UINT32 (cache->buffer, 24);
+      max_extent = MAX (max_extent, GET_UINT32 (cache->buffer, offset + 4));
+    }
+
+  return max_extent;
+}
+
+static const char *
+cache_get_mime_type_for_data (const void *data,
+			      size_t      len,
+			      const char *mime_types[],
+			      int         n_mime_types)
+{
+  const char *mime_type;
+  int i, n, priority;
+
+  priority = 0;
+  mime_type = NULL;
+  for (i = 0; _caches[i]; i++)
+    {
+      XdgMimeCache *cache = _caches[i];
+
+      int prio;
+      const char *match;
+
+      match = cache_magic_lookup_data (cache, data, len, &prio, 
+				       mime_types, n_mime_types);
+      if (prio > priority)
+	{
+	  priority = prio;
+	  mime_type = match;
+	}
+    }
+
+  if (priority > 0)
+    return mime_type;
+
+  for (n = 0; n < n_mime_types; n++)
+    {
+      if (mime_types[n])
+	return mime_types[n];
+    }
+
+  return XDG_MIME_TYPE_UNKNOWN;
+}
+
+const char *
+_xdg_mime_cache_get_mime_type_for_data (const void *data,
+					size_t      len)
+{
+  return cache_get_mime_type_for_data (data, len, NULL, 0);
+}
+
+const char *
+_xdg_mime_cache_get_mime_type_for_file (const char  *file_name,
+					struct stat *statbuf)
+{
+  const char *mime_type;
+  const char *mime_types[2];
+  FILE *file;
+  unsigned char *data;
+  int max_extent;
+  int bytes_read;
+  struct stat buf;
+  const char *base_name;
+  int n;
+
+  if (file_name == NULL)
+    return NULL;
+
+  if (! _xdg_utf8_validate (file_name))
+    return NULL;
+
+  base_name = _xdg_get_base_name (file_name);
+  n = cache_glob_lookup_file_name (base_name, mime_types, 2);
+
+  if (n == 1)
+    return mime_types[0];
+
+  if (!statbuf)
+    {
+      if (stat (file_name, &buf) != 0)
+	return XDG_MIME_TYPE_UNKNOWN;
+
+      statbuf = &buf;
+    }
+
+  if (!S_ISREG (statbuf->st_mode))
+    return XDG_MIME_TYPE_UNKNOWN;
+
+  /* FIXME: Need to make sure that max_extent isn't totally broken.  This could
+   * be large and need getting from a stream instead of just reading it all
+   * in. */
+  max_extent = _xdg_mime_cache_get_max_buffer_extents ();
+  data = malloc (max_extent);
+  if (data == NULL)
+    return XDG_MIME_TYPE_UNKNOWN;
+        
+  file = fopen (file_name, "r");
+  if (file == NULL)
+    {
+      free (data);
+      return XDG_MIME_TYPE_UNKNOWN;
+    }
+
+  bytes_read = fread (data, 1, max_extent, file);
+  if (ferror (file))
+    {
+      free (data);
+      fclose (file);
+      return XDG_MIME_TYPE_UNKNOWN;
+    }
+
+  mime_type = cache_get_mime_type_for_data (data, bytes_read,
+					    mime_types, n);
+
+  free (data);
+  fclose (file);
+
+  return mime_type;
+}
+
+const char *
+_xdg_mime_cache_get_mime_type_from_file_name (const char *file_name)
+{
+  const char *mime_types[2];
+
+  if (cache_glob_lookup_file_name (file_name, mime_types, 2) == 1)
+    return mime_types[0];
+  else
+    return XDG_MIME_TYPE_UNKNOWN;
+}
+
+#if 1
+static int
+is_super_type (const char *mime)
+{
+  int length;
+  const char *type;
+
+  length = strlen (mime);
+  type = &(mime[length - 2]);
+
+  if (strcmp (type, "/*") == 0)
+    return 1;
+
+  return 0;
+}
+#endif
+
+int
+_xdg_mime_cache_mime_type_subclass (const char *mime,
+				    const char *base)
+{
+  const char *umime, *ubase;
+
+  int i, j, min, max, med, cmp;
+  
+  umime = _xdg_mime_cache_unalias_mime_type (mime);
+  ubase = _xdg_mime_cache_unalias_mime_type (base);
+
+  if (strcmp (umime, ubase) == 0)
+    return 1;
+
+  /* We really want to handle text/ * in GtkFileFilter, so we just
+   * turn on the supertype matching
+   */
+#if 1
+  /* Handle supertypes */
+  if (is_super_type (ubase) &&
+      xdg_mime_media_type_equal (umime, ubase))
+    return 1;
+#endif
+
+  /*  Handle special cases text/plain and application/octet-stream */
+  if (strcmp (ubase, "text/plain") == 0 && 
+      strncmp (umime, "text/", 5) == 0)
+    return 1;
+
+  if (strcmp (ubase, "application/octet-stream") == 0)
+    return 1;
+ 
+  for (i = 0; _caches[i]; i++)
+    {
+      XdgMimeCache *cache = _caches[i];
+      
+      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 8);
+      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);
+      xdg_uint32_t offset, n_parents, parent_offset;
+
+      min = 0; 
+      max = n_entries - 1;
+      while (max >= min)
+	{
+	  med = (min + max)/2;
+	  
+	  offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * med);
+	  cmp = strcmp (cache->buffer + offset, umime);
+	  if (cmp < 0)
+	    min = med + 1;
+	  else if (cmp > 0)
+	    max = med - 1;
+	  else
+	    {
+	      offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * med + 4);
+	      n_parents = GET_UINT32 (cache->buffer, offset);
+	      
+	      for (j = 0; j < n_parents; j++)
+		{
+		  parent_offset = GET_UINT32 (cache->buffer, offset + 4 + 4 * j);
+		  if (_xdg_mime_cache_mime_type_subclass (cache->buffer + parent_offset, ubase))
+		    return 1;
+		}
+
+	      break;
+	    }
+	}
+    }
+
+  return 0;
+}
+
+const char *
+_xdg_mime_cache_unalias_mime_type (const char *mime)
+{
+  const char *lookup;
+  
+  lookup = cache_alias_lookup (mime);
+  
+  if (lookup)
+    return lookup;
+  
+  return mime;  
+}
+
+char **
+_xdg_mime_cache_list_mime_parents (const char *mime)
+{
+  int i, j, p;
+  char *all_parents[128]; /* we'll stop at 128 */ 
+  char **result;
+
+  p = 0;
+  for (i = 0; _caches[i]; i++)
+    {
+      XdgMimeCache *cache = _caches[i];
+  
+      xdg_uint32_t list_offset = GET_UINT32 (cache->buffer, 8);
+      xdg_uint32_t n_entries = GET_UINT32 (cache->buffer, list_offset);
+
+      for (j = 0; j < n_entries; j++)
+	{
+	  xdg_uint32_t mimetype_offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * i);
+	  xdg_uint32_t parents_offset = GET_UINT32 (cache->buffer, list_offset + 4 + 8 * i + 4);
+	  
+	  if (strcmp (cache->buffer + mimetype_offset, mime) == 0)
+	    {
+	      xdg_uint32_t n_parents = GET_UINT32 (cache->buffer, parents_offset);
+	      
+	      for (j = 0; j < n_parents; j++)
+		all_parents[p++] = cache->buffer + parents_offset + 4 + 4 * j;
+
+	      break;
+	    }
+	}
+    }
+  all_parents[p++] = 0;
+  
+  result = (char **) malloc (p * sizeof (char *));
+  memcpy (result, all_parents, p * sizeof (char *));
+
+  return result;
+}
+

Added: trunk/Utils/xdgmime/xdgmimecache.h
===================================================================
--- trunk/Utils/xdgmime/xdgmimecache.h	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmimecache.h	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,63 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmimecache.h: Private file.  Datastructure for mmapped caches.
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ *
+ * Copyright (C) 2005  Matthias Clasen <mclasen at redhat.com>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __XDG_MIME_CACHE_H__
+#define __XDG_MIME_CACHE_H__
+
+#include "xdgmime.h"
+
+typedef struct _XdgMimeCache XdgMimeCache;
+
+#ifdef XDG_PREFIX
+#define _xdg_mime_cache_new_from_file        XDG_ENTRY(cache_new_from_file)
+#define _xdg_mime_cache_ref                  XDG_ENTRY(cache_ref)
+#define _xdg_mime_cache_unref                XDG_ENTRY(cache_unref)
+#endif
+
+extern XdgMimeCache **_caches;
+
+XdgMimeCache *_xdg_mime_cache_new_from_file (const char   *file_name);
+XdgMimeCache *_xdg_mime_cache_ref           (XdgMimeCache *cache);
+void          _xdg_mime_cache_unref         (XdgMimeCache *cache);
+
+
+const char  *_xdg_mime_cache_get_mime_type_for_data       (const void *data,
+		 				           size_t      len);
+const char  *_xdg_mime_cache_get_mime_type_for_file       (const char  *file_name,
+							   struct stat *statbuf);
+const char  *_xdg_mime_cache_get_mime_type_from_file_name (const char *file_name);
+int          _xdg_mime_cache_is_valid_mime_type           (const char *mime_type);
+int          _xdg_mime_cache_mime_type_equal              (const char *mime_a,
+						           const char *mime_b);
+int          _xdg_mime_cache_media_type_equal             (const char *mime_a,
+							   const char *mime_b);
+int          _xdg_mime_cache_mime_type_subclass           (const char *mime_a,
+							   const char *mime_b);
+char       **_xdg_mime_cache_list_mime_parents		  (const char *mime);
+const char  *_xdg_mime_cache_unalias_mime_type            (const char *mime);
+int          _xdg_mime_cache_get_max_buffer_extents       (void);
+
+#endif /* __XDG_MIME_CACHE_H__ */

Added: trunk/Utils/xdgmime/xdgmimeglob.c
===================================================================
--- trunk/Utils/xdgmime/xdgmimeglob.c	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmimeglob.c	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,545 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmimeglob.c: Private file.  Datastructure for storing the globs.
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ *
+ * Copyright (C) 2003  Red Hat, Inc.
+ * Copyright (C) 2003  Jonathan Blandford <jrb at alum.mit.edu>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xdgmimeglob.h"
+#include "xdgmimeint.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <fnmatch.h>
+
+#ifndef	FALSE
+#define	FALSE	(0)
+#endif
+
+#ifndef	TRUE
+#define	TRUE	(!FALSE)
+#endif
+
+typedef struct XdgGlobHashNode XdgGlobHashNode;
+typedef struct XdgGlobList XdgGlobList;
+
+struct XdgGlobHashNode
+{
+  xdg_unichar_t character;
+  const char *mime_type;
+  XdgGlobHashNode *next;
+  XdgGlobHashNode *child;
+};
+struct XdgGlobList
+{
+  const char *data;
+  const char *mime_type;
+  XdgGlobList *next;
+};
+
+struct XdgGlobHash
+{
+  XdgGlobList *literal_list;
+  XdgGlobHashNode *simple_node;
+  XdgGlobList *full_list;
+};
+
+
+/* XdgGlobList
+ */
+static XdgGlobList *
+_xdg_glob_list_new (void)
+{
+  XdgGlobList *new_element;
+
+  new_element = calloc (1, sizeof (XdgGlobList));
+
+  return new_element;
+}
+
+/* Frees glob_list and all of it's children */
+static void
+_xdg_glob_list_free (XdgGlobList *glob_list)
+{
+  XdgGlobList *ptr, *next;
+
+  ptr = glob_list;
+
+  while (ptr != NULL)
+    {
+      next = ptr->next;
+
+      if (ptr->data)
+	free ((void *) ptr->data);
+      if (ptr->mime_type)
+	free ((void *) ptr->mime_type);
+      free (ptr);
+
+      ptr = next;
+    }
+}
+
+static XdgGlobList *
+_xdg_glob_list_append (XdgGlobList *glob_list,
+		       void        *data,
+		       const char  *mime_type)
+{
+  XdgGlobList *new_element;
+  XdgGlobList *tmp_element;
+
+  new_element = _xdg_glob_list_new ();
+  new_element->data = data;
+  new_element->mime_type = mime_type;
+  if (glob_list == NULL)
+    return new_element;
+
+  tmp_element = glob_list;
+  while (tmp_element->next != NULL)
+    tmp_element = tmp_element->next;
+
+  tmp_element->next = new_element;
+
+  return glob_list;
+}
+
+#if 0
+static XdgGlobList *
+_xdg_glob_list_prepend (XdgGlobList *glob_list,
+			void        *data,
+			const char  *mime_type)
+{
+  XdgGlobList *new_element;
+
+  new_element = _xdg_glob_list_new ();
+  new_element->data = data;
+  new_element->next = glob_list;
+  new_element->mime_type = mime_type;
+
+  return new_element;
+}
+#endif
+
+/* XdgGlobHashNode
+ */
+
+static XdgGlobHashNode *
+_xdg_glob_hash_node_new (void)
+{
+  XdgGlobHashNode *glob_hash_node;
+
+  glob_hash_node = calloc (1, sizeof (XdgGlobHashNode));
+
+  return glob_hash_node;
+}
+
+static void
+_xdg_glob_hash_node_dump (XdgGlobHashNode *glob_hash_node,
+			  int depth)
+{
+  int i;
+  for (i = 0; i < depth; i++)
+    printf (" ");
+
+  printf ("%c", (char)glob_hash_node->character);
+  if (glob_hash_node->mime_type)
+    printf (" - %s\n", glob_hash_node->mime_type);
+  else
+    printf ("\n");
+  if (glob_hash_node->child)
+    _xdg_glob_hash_node_dump (glob_hash_node->child, depth + 1);
+  if (glob_hash_node->next)
+    _xdg_glob_hash_node_dump (glob_hash_node->next, depth);
+}
+
+static XdgGlobHashNode *
+_xdg_glob_hash_insert_text (XdgGlobHashNode *glob_hash_node,
+			    const char      *text,
+			    const char      *mime_type)
+{
+  XdgGlobHashNode *node;
+  xdg_unichar_t character;
+
+  character = _xdg_utf8_to_ucs4 (text);
+
+  if ((glob_hash_node == NULL) ||
+      (character < glob_hash_node->character))
+    {
+      node = _xdg_glob_hash_node_new ();
+      node->character = character;
+      node->next = glob_hash_node;
+      glob_hash_node = node;
+    }
+  else if (character == glob_hash_node->character)
+    {
+      node = glob_hash_node;
+    }
+  else
+    {
+      XdgGlobHashNode *prev_node;
+      int found_node = FALSE;
+
+      /* Look for the first character of text in glob_hash_node, and insert it if we
+       * have to.*/
+      prev_node = glob_hash_node;
+      node = prev_node->next;
+
+      while (node != NULL)
+	{
+	  if (character < node->character)
+	    {
+	      node = _xdg_glob_hash_node_new ();
+	      node->character = character;
+	      node->next = prev_node->next;
+	      prev_node->next = node;
+
+	      found_node = TRUE;
+	      break;
+	    }
+	  else if (character == node->character)
+	    {
+	      found_node = TRUE;
+	      break;
+	    }
+	  prev_node = node;
+	  node = node->next;
+	}
+
+      if (! found_node)
+	{
+	  node = _xdg_glob_hash_node_new ();
+	  node->character = character;
+	  node->next = prev_node->next;
+	  prev_node->next = node;
+	}
+    }
+
+  text = _xdg_utf8_next_char (text);
+  if (*text == '\000')
+    {
+      if (node->mime_type)
+	{
+	  if (strcmp (node->mime_type, mime_type))
+	    {
+	      XdgGlobHashNode *child;
+	      int found_node = FALSE;
+	      
+	      child = node->child;
+	      while (child && child->character == '\0')
+		{
+		  if (strcmp (child->mime_type, mime_type) == 0)
+		    {
+		      found_node = TRUE;
+		      break;
+		    }
+		  child = child->next;
+		}
+
+	      if (!found_node)
+		{
+		  child = _xdg_glob_hash_node_new ();
+		  child->character = '\000';
+		  child->mime_type = strdup (mime_type);
+		  child->child = NULL;
+		  child->next = node->child;
+		  node->child = child;
+		}
+	    }
+	}
+      else
+	{
+	  node->mime_type = strdup (mime_type);
+	}
+    }
+  else
+    {
+      node->child = _xdg_glob_hash_insert_text (node->child, text, mime_type);
+    }
+  return glob_hash_node;
+}
+
+static int
+_xdg_glob_hash_node_lookup_file_name (XdgGlobHashNode *glob_hash_node,
+				      const char      *file_name,
+				      int              ignore_case,
+				      const char      *mime_types[],
+				      int              n_mime_types)
+{
+  int n;
+  XdgGlobHashNode *node;
+  xdg_unichar_t character;
+
+  if (glob_hash_node == NULL)
+    return 0;
+
+  character = _xdg_utf8_to_ucs4 (file_name);
+  if (ignore_case)
+    character = _xdg_ucs4_to_lower(character);
+
+  for (node = glob_hash_node; node && character >= node->character; node = node->next)
+    {
+      if (character == node->character)
+	{
+	  file_name = _xdg_utf8_next_char (file_name);
+	  if (*file_name == '\000')
+	    {
+	      n = 0;
+	      mime_types[n++] = node->mime_type;
+	      node = node->child;
+	      while (n < n_mime_types && node && node->character == 0)
+		{
+		  mime_types[n++] = node->mime_type;
+		  node = node->next;
+		}
+	    }
+	  else
+	    {
+	      n = _xdg_glob_hash_node_lookup_file_name (node->child,
+							file_name,
+							ignore_case,
+							mime_types,
+							n_mime_types);
+	    }
+	  return n;
+	}
+    }
+
+  return 0;
+}
+
+int
+_xdg_glob_hash_lookup_file_name (XdgGlobHash *glob_hash,
+				 const char  *file_name,
+				 const char  *mime_types[],
+				 int          n_mime_types)
+{
+  XdgGlobList *list;
+  const char *ptr;
+  char stopchars[128];
+  int i, n;
+  XdgGlobHashNode *node;
+
+  /* First, check the literals */
+
+  assert (file_name != NULL && n_mime_types > 0);
+
+  for (list = glob_hash->literal_list; list; list = list->next)
+    {
+      if (strcmp ((const char *)list->data, file_name) == 0)
+	{
+	  mime_types[0] = list->mime_type;
+	  return 1;
+	}
+    }
+
+  i = 0;
+  for (node = glob_hash->simple_node; node; node = node->next)
+    {
+      if (node->character < 128)
+ 	stopchars[i++] = (char)node->character;
+    }
+  stopchars[i] = '\0';
+ 
+  ptr = strpbrk (file_name, stopchars);
+  while (ptr)
+    {
+      n = _xdg_glob_hash_node_lookup_file_name (glob_hash->simple_node, ptr, FALSE,
+						mime_types, n_mime_types);
+      if (n > 0)
+	return n;
+      
+      n = _xdg_glob_hash_node_lookup_file_name (glob_hash->simple_node, ptr, TRUE,
+						mime_types, n_mime_types);
+      if (n > 0)
+	return n;
+      
+      ptr = strpbrk (ptr + 1, stopchars);
+    }
+
+  /* FIXME: Not UTF-8 safe */
+  n = 0;
+  for (list = glob_hash->full_list; list && n < n_mime_types; list = list->next)
+    {
+      if (fnmatch ((const char *)list->data, file_name, 0) == 0)
+	mime_types[n++] = list->mime_type;
+    }
+
+  return n;
+}
+
+
+
+/* XdgGlobHash
+ */
+
+XdgGlobHash *
+_xdg_glob_hash_new (void)
+{
+  XdgGlobHash *glob_hash;
+
+  glob_hash = calloc (1, sizeof (XdgGlobHash));
+
+  return glob_hash;
+}
+
+
+static void
+_xdg_glob_hash_free_nodes (XdgGlobHashNode *node)
+{
+  if (node)
+    {
+      if (node->child)
+       _xdg_glob_hash_free_nodes (node->child);
+      if (node->next)
+       _xdg_glob_hash_free_nodes (node->next);
+      if (node->mime_type)
+	free ((void *) node->mime_type);
+      free (node);
+    }
+}
+
+void
+_xdg_glob_hash_free (XdgGlobHash *glob_hash)
+{
+  _xdg_glob_list_free (glob_hash->literal_list);
+  _xdg_glob_list_free (glob_hash->full_list);
+  _xdg_glob_hash_free_nodes (glob_hash->simple_node);
+  free (glob_hash);
+}
+
+XdgGlobType
+_xdg_glob_determine_type (const char *glob)
+{
+  const char *ptr;
+  int maybe_in_simple_glob = FALSE;
+  int first_char = TRUE;
+
+  ptr = glob;
+
+  while (*ptr != '\000')
+    {
+      if (*ptr == '*' && first_char)
+	maybe_in_simple_glob = TRUE;
+      else if (*ptr == '\\' || *ptr == '[' || *ptr == '?' || *ptr == '*')
+	  return XDG_GLOB_FULL;
+
+      first_char = FALSE;
+      ptr = _xdg_utf8_next_char (ptr);
+    }
+  if (maybe_in_simple_glob)
+    return XDG_GLOB_SIMPLE;
+  else
+    return XDG_GLOB_LITERAL;
+}
+
+/* glob must be valid UTF-8 */
+void
+_xdg_glob_hash_append_glob (XdgGlobHash *glob_hash,
+			    const char  *glob,
+			    const char  *mime_type)
+{
+  XdgGlobType type;
+
+  assert (glob_hash != NULL);
+  assert (glob != NULL);
+
+  type = _xdg_glob_determine_type (glob);
+
+  switch (type)
+    {
+    case XDG_GLOB_LITERAL:
+      glob_hash->literal_list = _xdg_glob_list_append (glob_hash->literal_list, strdup (glob), strdup (mime_type));
+      break;
+    case XDG_GLOB_SIMPLE:
+      glob_hash->simple_node = _xdg_glob_hash_insert_text (glob_hash->simple_node, glob + 1, mime_type);
+      break;
+    case XDG_GLOB_FULL:
+      glob_hash->full_list = _xdg_glob_list_append (glob_hash->full_list, strdup (glob), strdup (mime_type));
+      break;
+    }
+}
+
+void
+_xdg_glob_hash_dump (XdgGlobHash *glob_hash)
+{
+  XdgGlobList *list;
+  printf ("LITERAL STRINGS\n");
+  if (glob_hash->literal_list == NULL)
+    {
+      printf ("    None\n");
+    }
+  else
+    {
+      for (list = glob_hash->literal_list; list; list = list->next)
+	printf ("    %s - %s\n", (char *)list->data, list->mime_type);
+    }
+  printf ("\nSIMPLE GLOBS\n");
+  _xdg_glob_hash_node_dump (glob_hash->simple_node, 4);
+
+  printf ("\nFULL GLOBS\n");
+  if (glob_hash->full_list == NULL)
+    {
+      printf ("    None\n");
+    }
+  else
+    {
+      for (list = glob_hash->full_list; list; list = list->next)
+	printf ("    %s - %s\n", (char *)list->data, list->mime_type);
+    }
+}
+
+
+void
+_xdg_mime_glob_read_from_file (XdgGlobHash *glob_hash,
+			       const char  *file_name)
+{
+  FILE *glob_file;
+  char line[255];
+
+  glob_file = fopen (file_name, "r");
+
+  if (glob_file == NULL)
+    return;
+
+  /* FIXME: Not UTF-8 safe.  Doesn't work if lines are greater than 255 chars.
+   * Blah */
+  while (fgets (line, 255, glob_file) != NULL)
+    {
+      char *colon;
+      if (line[0] == '#')
+	continue;
+
+      colon = strchr (line, ':');
+      if (colon == NULL)
+	continue;
+      *(colon++) = '\000';
+      colon[strlen (colon) -1] = '\000';
+      _xdg_glob_hash_append_glob (glob_hash, colon, line);
+    }
+
+  fclose (glob_file);
+}

Added: trunk/Utils/xdgmime/xdgmimeglob.h
===================================================================
--- trunk/Utils/xdgmime/xdgmimeglob.h	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmimeglob.h	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,67 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmimeglob.h: Private file.  Datastructure for storing the globs.
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ *
+ * Copyright (C) 2003  Red Hat, Inc.
+ * Copyright (C) 2003  Jonathan Blandford <jrb at alum.mit.edu>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __XDG_MIME_GLOB_H__
+#define __XDG_MIME_GLOB_H__
+
+#include "xdgmime.h"
+
+typedef struct XdgGlobHash XdgGlobHash;
+
+typedef enum
+{
+  XDG_GLOB_LITERAL, /* Makefile */
+  XDG_GLOB_SIMPLE,  /* *.gif */
+  XDG_GLOB_FULL     /* x*.[ch] */
+} XdgGlobType;
+
+  
+#ifdef XDG_PREFIX
+#define _xdg_mime_glob_read_from_file         XDG_ENTRY(glob_read_from_file)
+#define _xdg_glob_hash_new                    XDG_ENTRY(hash_new)
+#define _xdg_glob_hash_free                   XDG_ENTRY(hash_free)
+#define _xdg_glob_hash_lookup_file_name       XDG_ENTRY(hash_lookup_file_name)
+#define _xdg_glob_hash_append_glob            XDG_ENTRY(hash_append_glob)
+#define _xdg_glob_determine_type              XDG_ENTRY(determine_type)
+#define _xdg_glob_hash_dump                   XDG_ENTRY(hash_dump)
+#endif
+
+void         _xdg_mime_glob_read_from_file   (XdgGlobHash *glob_hash,
+					      const char  *file_name);
+XdgGlobHash *_xdg_glob_hash_new              (void);
+void         _xdg_glob_hash_free             (XdgGlobHash *glob_hash);
+int          _xdg_glob_hash_lookup_file_name (XdgGlobHash *glob_hash,
+					      const char  *text,
+					      const char  *mime_types[],
+					      int          n_mime_types);
+void         _xdg_glob_hash_append_glob      (XdgGlobHash *glob_hash,
+					      const char  *glob,
+					      const char  *mime_type);
+XdgGlobType  _xdg_glob_determine_type        (const char  *glob);
+void         _xdg_glob_hash_dump             (XdgGlobHash *glob_hash);
+
+#endif /* __XDG_MIME_GLOB_H__ */

Added: trunk/Utils/xdgmime/xdgmimeint.c
===================================================================
--- trunk/Utils/xdgmime/xdgmimeint.c	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmimeint.c	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,154 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmimeint.c: Internal defines and functions.
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ *
+ * Copyright (C) 2003  Red Hat, Inc.
+ * Copyright (C) 2003  Jonathan Blandford <jrb at alum.mit.edu>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xdgmimeint.h"
+#include <ctype.h>
+#include <string.h>
+
+#ifndef	FALSE
+#define	FALSE	(0)
+#endif
+
+#ifndef	TRUE
+#define	TRUE	(!FALSE)
+#endif
+
+static const char _xdg_utf8_skip_data[256] = {
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+  3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1
+};
+
+const char * const _xdg_utf8_skip = _xdg_utf8_skip_data;
+
+
+
+/* Returns the number of unprocessed characters. */
+xdg_unichar_t
+_xdg_utf8_to_ucs4(const char *source)
+{
+  xdg_unichar_t ucs32;
+  if( ! ( *source & 0x80 ) )
+    {
+      ucs32 = *source;
+    }
+  else
+    {
+      int bytelength = 0;
+      xdg_unichar_t result;
+      if ( ! (*source & 0x40) )
+	{
+	  ucs32 = *source;
+	}
+      else
+	{
+	  if ( ! (*source & 0x20) )
+	    {
+	      result = *source++ & 0x1F;
+	      bytelength = 2;
+	    }
+	  else if ( ! (*source & 0x10) )
+	    {
+	      result = *source++ & 0x0F;
+	      bytelength = 3;
+	    }
+	  else if ( ! (*source & 0x08) )
+	    {
+	      result = *source++ & 0x07;
+	      bytelength = 4;
+	    }
+	  else if ( ! (*source & 0x04) )
+	    {
+	      result = *source++ & 0x03;
+	      bytelength = 5;
+	    }
+	  else if ( ! (*source & 0x02) )
+	    {
+	      result = *source++ & 0x01;
+	      bytelength = 6;
+	    }
+	  else
+	    {
+	      result = *source++;
+	      bytelength = 1;
+	    }
+
+	  for ( bytelength --; bytelength > 0; bytelength -- )
+	    {
+	      result <<= 6;
+	      result |= *source++ & 0x3F;
+	    }
+	  ucs32 = result;
+	}
+    }
+  return ucs32;
+}
+
+
+/* hullo.  this is great code.  don't rewrite it */
+
+xdg_unichar_t
+_xdg_ucs4_to_lower (xdg_unichar_t source)
+{
+  /* FIXME: Do a real to_upper sometime */
+  /* CaseFolding-3.2.0.txt has a table of rules. */
+  if ((source & 0xFF) == source)
+    return (xdg_unichar_t) tolower ((unsigned char) source);
+  return source;
+}
+
+int
+_xdg_utf8_validate (const char *source)
+{
+  /* FIXME: actually write */
+  return TRUE;
+}
+
+const char *
+_xdg_get_base_name (const char *file_name)
+{
+  const char *base_name;
+
+  if (file_name == NULL)
+    return NULL;
+
+  base_name = strrchr (file_name, '/');
+
+  if (base_name == NULL)
+    return file_name;
+  else
+    return base_name + 1;
+}

Added: trunk/Utils/xdgmime/xdgmimeint.h
===================================================================
--- trunk/Utils/xdgmime/xdgmimeint.h	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmimeint.h	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,73 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmimeint.h: Internal defines and functions.
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ *
+ * Copyright (C) 2003  Red Hat, Inc.
+ * Copyright (C) 2003  Jonathan Blandford <jrb at alum.mit.edu>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __XDG_MIME_INT_H__
+#define __XDG_MIME_INT_H__
+
+#include "xdgmime.h"
+
+
+#ifndef	FALSE
+#define	FALSE (0)
+#endif
+
+#ifndef	TRUE
+#define	TRUE (!FALSE)
+#endif
+
+/* FIXME: Needs to be configure check */
+typedef unsigned int   xdg_unichar_t;
+typedef unsigned char  xdg_uchar8_t;
+typedef unsigned short xdg_uint16_t;
+typedef unsigned int   xdg_uint32_t;
+
+#ifdef XDG_PREFIX
+#define _xdg_utf8_skip   XDG_ENTRY(utf8_skip)
+#define _xdg_utf8_to_ucs4   XDG_ENTRY(utf8_to_ucs4)
+#define _xdg_ucs4_to_lower   XDG_ENTRY(ucs4_to_lower)
+#define _xdg_utf8_validate   XDG_ENTRY(utf8_validate)
+#define _xdg_get_base_name   XDG_ENTRY(get_ase_name)
+#endif
+
+#define SWAP_BE16_TO_LE16(val) (xdg_uint16_t)(((xdg_uint16_t)(val) << 8)|((xdg_uint16_t)(val) >> 8))
+
+#define SWAP_BE32_TO_LE32(val) (xdg_uint32_t)((((xdg_uint32_t)(val) & 0xFF000000U) >> 24) |	\
+					      (((xdg_uint32_t)(val) & 0x00FF0000U) >> 8) |	\
+					      (((xdg_uint32_t)(val) & 0x0000FF00U) << 8) |	\
+					      (((xdg_uint32_t)(val) & 0x000000FFU) << 24))
+/* UTF-8 utils
+ */
+extern const char *const _xdg_utf8_skip;
+#define _xdg_utf8_next_char(p) (char *)((p) + _xdg_utf8_skip[*(unsigned char *)(p)])
+#define _xdg_utf8_char_size(p) (int) (_xdg_utf8_skip[*(unsigned char *)(p)])
+
+xdg_unichar_t  _xdg_utf8_to_ucs4  (const char    *source);
+xdg_unichar_t  _xdg_ucs4_to_lower (xdg_unichar_t  source);
+int            _xdg_utf8_validate (const char    *source);
+const char    *_xdg_get_base_name (const char    *file_name);
+
+#endif /* __XDG_MIME_INT_H__ */

Added: trunk/Utils/xdgmime/xdgmimemagic.c
===================================================================
--- trunk/Utils/xdgmime/xdgmimemagic.c	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmimemagic.c	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,818 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmimemagic.: Private file.  Datastructure for storing magic files.
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ *
+ * Copyright (C) 2003  Red Hat, Inc.
+ * Copyright (C) 2003  Jonathan Blandford <jrb at alum.mit.edu>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <assert.h>
+#include "xdgmimemagic.h"
+#include "xdgmimeint.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <limits.h>
+
+#ifndef	FALSE
+#define	FALSE	(0)
+#endif
+
+#ifndef	TRUE
+#define	TRUE	(!FALSE)
+#endif
+
+extern int errno;
+
+typedef struct XdgMimeMagicMatch XdgMimeMagicMatch;
+typedef struct XdgMimeMagicMatchlet XdgMimeMagicMatchlet;
+
+typedef enum
+{
+  XDG_MIME_MAGIC_SECTION,
+  XDG_MIME_MAGIC_MAGIC,
+  XDG_MIME_MAGIC_ERROR,
+  XDG_MIME_MAGIC_EOF
+} XdgMimeMagicState;
+
+struct XdgMimeMagicMatch
+{
+  const char *mime_type;
+  int priority;
+  XdgMimeMagicMatchlet *matchlet;
+  XdgMimeMagicMatch *next;
+};
+
+
+struct XdgMimeMagicMatchlet
+{
+  int indent;
+  int offset;
+  unsigned int value_length;
+  unsigned char *value;
+  unsigned char *mask;
+  unsigned int range_length;
+  unsigned int word_size;
+  XdgMimeMagicMatchlet *next;
+};
+
+
+struct XdgMimeMagic
+{
+  XdgMimeMagicMatch *match_list;
+  int max_extent;
+};
+
+static XdgMimeMagicMatch *
+_xdg_mime_magic_match_new (void)
+{
+  return calloc (1, sizeof (XdgMimeMagicMatch));
+}
+
+
+static XdgMimeMagicMatchlet *
+_xdg_mime_magic_matchlet_new (void)
+{
+  XdgMimeMagicMatchlet *matchlet;
+
+  matchlet = malloc (sizeof (XdgMimeMagicMatchlet));
+
+  matchlet->indent = 0;
+  matchlet->offset = 0;
+  matchlet->value_length = 0;
+  matchlet->value = NULL;
+  matchlet->mask = NULL;
+  matchlet->range_length = 1;
+  matchlet->word_size = 1;
+  matchlet->next = NULL;
+
+  return matchlet;
+}
+
+
+static void
+_xdg_mime_magic_matchlet_free (XdgMimeMagicMatchlet *mime_magic_matchlet)
+{
+  if (mime_magic_matchlet)
+    {
+      if (mime_magic_matchlet->next)
+	_xdg_mime_magic_matchlet_free (mime_magic_matchlet->next);
+      if (mime_magic_matchlet->value)
+	free (mime_magic_matchlet->value);
+      if (mime_magic_matchlet->mask)
+	free (mime_magic_matchlet->mask);
+      free (mime_magic_matchlet);
+    }
+}
+
+
+/* Frees mime_magic_match and the remainder of its list
+ */
+static void
+_xdg_mime_magic_match_free (XdgMimeMagicMatch *mime_magic_match)
+{
+  XdgMimeMagicMatch *ptr, *next;
+
+  ptr = mime_magic_match;
+  while (ptr)
+    {
+      next = ptr->next;
+
+      if (ptr->mime_type)
+	free ((void *) ptr->mime_type);
+      if (ptr->matchlet)
+	_xdg_mime_magic_matchlet_free (ptr->matchlet);
+      free (ptr);
+
+      ptr = next;
+    }
+}
+
+/* Reads in a hunk of data until a newline character or a '\000' is hit.  The
+ * returned string is null terminated, and doesn't include the newline.
+ */
+static unsigned char *
+_xdg_mime_magic_read_to_newline (FILE *magic_file,
+				 int  *end_of_file)
+{
+  unsigned char *retval;
+  int c;
+  int len, pos;
+
+  len = 128;
+  pos = 0;
+  retval = malloc (len);
+  *end_of_file = FALSE;
+
+  while (TRUE)
+    {
+      c = getc_unlocked (magic_file);
+      if (c == EOF)
+	{
+	  *end_of_file = TRUE;
+	  break;
+	}
+      if (c == '\n' || c == '\000')
+	break;
+      retval[pos++] = (unsigned char) c;
+      if (pos % 128 == 127)
+	{
+	  len = len + 128;
+	  retval = realloc (retval, len);
+	}
+    }
+
+  retval[pos] = '\000';
+  return retval;
+}
+
+/* Returns the number read from the file, or -1 if no number could be read.
+ */
+static int
+_xdg_mime_magic_read_a_number (FILE *magic_file,
+			       int  *end_of_file)
+{
+  /* LONG_MAX is about 20 characters on my system */
+#define MAX_NUMBER_SIZE 30
+  char number_string[MAX_NUMBER_SIZE + 1];
+  int pos = 0;
+  int c;
+  long retval = -1;
+
+  while (TRUE)
+    {
+      c = getc_unlocked (magic_file);
+
+      if (c == EOF)
+	{
+	  *end_of_file = TRUE;
+	  break;
+	}
+      if (! isdigit (c))
+	{
+	  ungetc (c, magic_file);
+	  break;
+	}
+      number_string[pos] = (char) c;
+      pos++;
+      if (pos == MAX_NUMBER_SIZE)
+	break;
+    }
+  if (pos > 0)
+    {
+      number_string[pos] = '\000';
+      errno = 0;
+      retval = strtol (number_string, NULL, 10);
+
+      if ((retval < INT_MIN) || (retval > INT_MAX) || (errno != 0))
+	return -1;
+    }
+
+  return retval;
+}
+
+/* Headers are of the format:
+ * [<priority>:<mime-type>]
+ */
+static XdgMimeMagicState
+_xdg_mime_magic_parse_header (FILE *magic_file, XdgMimeMagicMatch *match)
+{
+  int c;
+  char *buffer;
+  char *end_ptr;
+  int end_of_file = 0;
+
+  assert (magic_file != NULL);
+  assert (match != NULL);
+
+  c = getc_unlocked (magic_file);
+  if (c == EOF)
+    return XDG_MIME_MAGIC_EOF;
+  if (c != '[')
+    return XDG_MIME_MAGIC_ERROR;
+
+  match->priority = _xdg_mime_magic_read_a_number (magic_file, &end_of_file);
+  if (end_of_file)
+    return XDG_MIME_MAGIC_EOF;
+  if (match->priority == -1)
+    return XDG_MIME_MAGIC_ERROR;
+
+  c = getc_unlocked (magic_file);
+  if (c == EOF)
+    return XDG_MIME_MAGIC_EOF;
+  if (c != ':')
+    return XDG_MIME_MAGIC_ERROR;
+
+  buffer = (char *)_xdg_mime_magic_read_to_newline (magic_file, &end_of_file);
+  if (end_of_file)
+    return XDG_MIME_MAGIC_EOF;
+
+  end_ptr = buffer;
+  while (*end_ptr != ']' && *end_ptr != '\000' && *end_ptr != '\n')
+    end_ptr++;
+  if (*end_ptr != ']')
+    {
+      free (buffer);
+      return XDG_MIME_MAGIC_ERROR;
+    }
+  *end_ptr = '\000';
+
+  match->mime_type = strdup (buffer);
+  free (buffer);
+
+  return XDG_MIME_MAGIC_MAGIC;
+}
+
+static XdgMimeMagicState
+_xdg_mime_magic_parse_error (FILE *magic_file)
+{
+  int c;
+
+  while (1)
+    {
+      c = getc_unlocked (magic_file);
+      if (c == EOF)
+	return XDG_MIME_MAGIC_EOF;
+      if (c == '\n')
+	return XDG_MIME_MAGIC_SECTION;
+    }
+}
+
+/* Headers are of the format:
+ * [ indent ] ">" start-offset "=" value
+ * [ "&" mask ] [ "~" word-size ] [ "+" range-length ] "\n"
+ */
+static XdgMimeMagicState
+_xdg_mime_magic_parse_magic_line (FILE              *magic_file,
+				  XdgMimeMagicMatch *match)
+{
+  XdgMimeMagicMatchlet *matchlet;
+  int c;
+  int end_of_file;
+  int indent = 0;
+  int bytes_read;
+
+  assert (magic_file != NULL);
+
+  /* Sniff the buffer to make sure it's a valid line */
+  c = getc_unlocked (magic_file);
+  if (c == EOF)
+    return XDG_MIME_MAGIC_EOF;
+  else if (c == '[')
+    {
+      ungetc (c, magic_file);
+      return XDG_MIME_MAGIC_SECTION;
+    }
+  else if (c == '\n')
+    return XDG_MIME_MAGIC_MAGIC;
+
+  /* At this point, it must be a digit or a '>' */
+  end_of_file = FALSE;
+  if (isdigit (c))
+    {
+      ungetc (c, magic_file);
+      indent = _xdg_mime_magic_read_a_number (magic_file, &end_of_file);
+      if (end_of_file)
+	return XDG_MIME_MAGIC_EOF;
+      if (indent == -1)
+	return XDG_MIME_MAGIC_ERROR;
+      c = getc_unlocked (magic_file);
+      if (c == EOF)
+	return XDG_MIME_MAGIC_EOF;
+    }
+
+  if (c != '>')
+    return XDG_MIME_MAGIC_ERROR;
+
+  matchlet = _xdg_mime_magic_matchlet_new ();
+  matchlet->indent = indent;
+  matchlet->offset = _xdg_mime_magic_read_a_number (magic_file, &end_of_file);
+  if (end_of_file)
+    {
+      _xdg_mime_magic_matchlet_free (matchlet);
+      return XDG_MIME_MAGIC_EOF;
+    }
+  if (matchlet->offset == -1)
+    {
+      _xdg_mime_magic_matchlet_free (matchlet);
+      return XDG_MIME_MAGIC_ERROR;
+    }
+  c = getc_unlocked (magic_file);
+  if (c == EOF)
+    {
+      _xdg_mime_magic_matchlet_free (matchlet);
+      return XDG_MIME_MAGIC_EOF;
+    }
+  else if (c != '=')
+    {
+      _xdg_mime_magic_matchlet_free (matchlet);
+      return XDG_MIME_MAGIC_ERROR;
+    }
+
+  /* Next two bytes determine how long the value is */
+  matchlet->value_length = 0;
+  c = getc_unlocked (magic_file);
+  if (c == EOF)
+    {
+      _xdg_mime_magic_matchlet_free (matchlet);
+      return XDG_MIME_MAGIC_EOF;
+    }
+  matchlet->value_length = c & 0xFF;
+  matchlet->value_length = matchlet->value_length << 8;
+
+  c = getc_unlocked (magic_file);
+  if (c == EOF)
+    {
+      _xdg_mime_magic_matchlet_free (matchlet);
+      return XDG_MIME_MAGIC_EOF;
+    }
+  matchlet->value_length = matchlet->value_length + (c & 0xFF);
+
+  matchlet->value = malloc (matchlet->value_length);
+
+  /* OOM */
+  if (matchlet->value == NULL)
+    {
+      _xdg_mime_magic_matchlet_free (matchlet);
+      return XDG_MIME_MAGIC_ERROR;
+    }
+  bytes_read = fread (matchlet->value, 1, matchlet->value_length, magic_file);
+  if (bytes_read != matchlet->value_length)
+    {
+      _xdg_mime_magic_matchlet_free (matchlet);
+      if (feof (magic_file))
+	return XDG_MIME_MAGIC_EOF;
+      else
+	return XDG_MIME_MAGIC_ERROR;
+    }
+
+  c = getc_unlocked (magic_file);
+  if (c == '&')
+    {
+      matchlet->mask = malloc (matchlet->value_length);
+      /* OOM */
+      if (matchlet->mask == NULL)
+	{
+	  _xdg_mime_magic_matchlet_free (matchlet);
+	  return XDG_MIME_MAGIC_ERROR;
+	}
+      bytes_read = fread (matchlet->mask, 1, matchlet->value_length, magic_file);
+      if (bytes_read != matchlet->value_length)
+	{
+	  _xdg_mime_magic_matchlet_free (matchlet);
+	  if (feof (magic_file))
+	    return XDG_MIME_MAGIC_EOF;
+	  else
+	    return XDG_MIME_MAGIC_ERROR;
+	}
+      c = getc_unlocked (magic_file);
+    }
+
+  if (c == '~')
+    {
+      matchlet->word_size = _xdg_mime_magic_read_a_number (magic_file, &end_of_file);
+      if (end_of_file)
+	{
+	  _xdg_mime_magic_matchlet_free (matchlet);
+	  return XDG_MIME_MAGIC_EOF;
+	}
+      if (matchlet->word_size != 0 &&
+	  matchlet->word_size != 1 &&
+	  matchlet->word_size != 2 &&
+	  matchlet->word_size != 4)
+	{
+	  _xdg_mime_magic_matchlet_free (matchlet);
+	  return XDG_MIME_MAGIC_ERROR;
+	}
+      c = getc_unlocked (magic_file);
+    }
+
+  if (c == '+')
+    {
+      matchlet->range_length = _xdg_mime_magic_read_a_number (magic_file, &end_of_file);
+      if (end_of_file)
+	{
+	  _xdg_mime_magic_matchlet_free (matchlet);
+	  return XDG_MIME_MAGIC_EOF;
+	}
+      if (matchlet->range_length == -1)
+	{
+	  _xdg_mime_magic_matchlet_free (matchlet);
+	  return XDG_MIME_MAGIC_ERROR;
+	}
+      c = getc_unlocked (magic_file);
+    }
+
+
+  if (c == '\n')
+    {
+      /* We clean up the matchlet, byte swapping if needed */
+      if (matchlet->word_size > 1)
+	{
+	  int i;
+	  if (matchlet->value_length % matchlet->word_size != 0)
+	    {
+	      _xdg_mime_magic_matchlet_free (matchlet);
+	      return XDG_MIME_MAGIC_ERROR;
+	    }
+	  /* FIXME: need to get this defined in a <config.h> style file */
+#if LITTLE_ENDIAN
+	  for (i = 0; i < matchlet->value_length; i = i + matchlet->word_size)
+	    {
+	      if (matchlet->word_size == 2)
+		*((xdg_uint16_t *) matchlet->value + i) = SWAP_BE16_TO_LE16 (*((xdg_uint16_t *) (matchlet->value + i)));
+	      else if (matchlet->word_size == 4)
+		*((xdg_uint32_t *) matchlet->value + i) = SWAP_BE32_TO_LE32 (*((xdg_uint32_t *) (matchlet->value + i)));
+	      if (matchlet->mask)
+		{
+		  if (matchlet->word_size == 2)
+		    *((xdg_uint16_t *) matchlet->mask + i) = SWAP_BE16_TO_LE16 (*((xdg_uint16_t *) (matchlet->mask + i)));
+		  else if (matchlet->word_size == 4)
+		    *((xdg_uint32_t *) matchlet->mask + i) = SWAP_BE32_TO_LE32 (*((xdg_uint32_t *) (matchlet->mask + i)));
+
+		}
+	    }
+#endif
+	}
+
+      matchlet->next = match->matchlet;
+      match->matchlet = matchlet;
+
+
+      return XDG_MIME_MAGIC_MAGIC;
+    }
+
+  _xdg_mime_magic_matchlet_free (matchlet);
+  if (c == EOF)
+    return XDG_MIME_MAGIC_EOF;
+
+  return XDG_MIME_MAGIC_ERROR;
+}
+
+static int
+_xdg_mime_magic_matchlet_compare_to_data (XdgMimeMagicMatchlet *matchlet,
+					  const void           *data,
+					  size_t                len)
+{
+  int i, j;
+  for (i = matchlet->offset; i < matchlet->offset + matchlet->range_length; i++)
+    {
+      int valid_matchlet = TRUE;
+
+      if (i + matchlet->value_length > len)
+	return FALSE;
+
+      if (matchlet->mask)
+	{
+	  for (j = 0; j < matchlet->value_length; j++)
+	    {
+	      if ((matchlet->value[j] & matchlet->mask[j]) !=
+		  ((((unsigned char *) data)[j + i]) & matchlet->mask[j]))
+		{
+		  valid_matchlet = FALSE;
+		  break;
+		}
+	    }
+	}
+      else
+	{
+	  for (j = 0; j <  matchlet->value_length; j++)
+	    {
+	      if (matchlet->value[j] != ((unsigned char *) data)[j + i])
+		{
+		  valid_matchlet = FALSE;
+		  break;
+		}
+	    }
+	}
+      if (valid_matchlet)
+	return TRUE;
+    }
+  return FALSE;
+}
+
+static int
+_xdg_mime_magic_matchlet_compare_level (XdgMimeMagicMatchlet *matchlet,
+					const void           *data,
+					size_t                len,
+					int                   indent)
+{
+  while ((matchlet != NULL) && (matchlet->indent == indent))
+    {
+      if (_xdg_mime_magic_matchlet_compare_to_data (matchlet, data, len))
+	{
+	  if ((matchlet->next == NULL) ||
+	      (matchlet->next->indent <= indent))
+	    return TRUE;
+
+	  if (_xdg_mime_magic_matchlet_compare_level (matchlet->next,
+						      data,
+						      len,
+						      indent + 1))
+	    return TRUE;
+	}
+
+      do
+	{
+	  matchlet = matchlet->next;
+	}
+      while (matchlet && matchlet->indent > indent);
+    }
+
+  return FALSE;
+}
+
+static int
+_xdg_mime_magic_match_compare_to_data (XdgMimeMagicMatch *match,
+				       const void        *data,
+				       size_t             len)
+{
+  return _xdg_mime_magic_matchlet_compare_level (match->matchlet, data, len, 0);
+}
+
+static void
+_xdg_mime_magic_insert_match (XdgMimeMagic      *mime_magic,
+			      XdgMimeMagicMatch *match)
+{
+  XdgMimeMagicMatch *list;
+
+  if (mime_magic->match_list == NULL)
+    {
+      mime_magic->match_list = match;
+      return;
+    }
+
+  if (match->priority > mime_magic->match_list->priority)
+    {
+      match->next = mime_magic->match_list;
+      mime_magic->match_list = match;
+      return;
+    }
+
+  list = mime_magic->match_list;
+  while (list->next != NULL)
+    {
+      if (list->next->priority < match->priority)
+	{
+	  match->next = list->next;
+	  list->next = match;
+	  return;
+	}
+      list = list->next;
+    }
+  list->next = match;
+  match->next = NULL;
+}
+
+XdgMimeMagic *
+_xdg_mime_magic_new (void)
+{
+  return calloc (1, sizeof (XdgMimeMagic));
+}
+
+void
+_xdg_mime_magic_free (XdgMimeMagic *mime_magic)
+{
+  if (mime_magic) {
+    _xdg_mime_magic_match_free (mime_magic->match_list);
+    free (mime_magic);
+  }
+}
+
+int
+_xdg_mime_magic_get_buffer_extents (XdgMimeMagic *mime_magic)
+{
+  return mime_magic->max_extent;
+}
+
+const char *
+_xdg_mime_magic_lookup_data (XdgMimeMagic *mime_magic,
+			     const void   *data,
+			     size_t        len,
+                             const char   *mime_types[],
+                             int           n_mime_types)
+{
+  XdgMimeMagicMatch *match;
+  const char *mime_type;
+  int n;
+  int priority;
+  int had_match;
+
+  mime_type = NULL;
+  priority = 0;
+  had_match = 0;
+  for (match = mime_magic->match_list; match; match = match->next)
+    {
+      if (_xdg_mime_magic_match_compare_to_data (match, data, len))
+	{
+	  if (!had_match || match->priority > priority ||
+	      (mime_type != NULL && xdg_mime_mime_type_subclass (match->mime_type, mime_type)))
+	    {
+	      mime_type = match->mime_type;
+	      priority = match->priority;
+	    }
+	  else if (had_match && match->priority == priority)
+	    /* multiple unrelated patterns with the same priority matched,
+	     * so we can't tell what type this is. */
+	    mime_type = NULL;
+
+	  had_match = 1;
+	}
+      else 
+	{
+	  for (n = 0; n < n_mime_types; n++)
+	    {
+	      if (mime_types[n] && 
+		  xdg_mime_mime_type_equal (mime_types[n], match->mime_type))
+		mime_types[n] = NULL;
+	    }
+	}
+    }
+
+  if (mime_type == NULL)
+    {
+      for (n = 0; n < n_mime_types; n++)
+	{
+	  if (mime_types[n])
+	    mime_type = mime_types[n];
+	}
+    }
+
+  return mime_type;
+}
+
+static void
+_xdg_mime_update_mime_magic_extents (XdgMimeMagic *mime_magic)
+{
+  XdgMimeMagicMatch *match;
+  int max_extent = 0;
+
+  for (match = mime_magic->match_list; match; match = match->next)
+    {
+      XdgMimeMagicMatchlet *matchlet;
+
+      for (matchlet = match->matchlet; matchlet; matchlet = matchlet->next)
+	{
+	  int extent;
+
+	  extent = matchlet->value_length + matchlet->offset + matchlet->range_length;
+	  if (max_extent < extent)
+	    max_extent = extent;
+	}
+    }
+
+  mime_magic->max_extent = max_extent;
+}
+
+static XdgMimeMagicMatchlet *
+_xdg_mime_magic_matchlet_mirror (XdgMimeMagicMatchlet *matchlets)
+{
+  XdgMimeMagicMatchlet *new_list;
+  XdgMimeMagicMatchlet *tmp;
+
+  if ((matchlets == NULL) || (matchlets->next == NULL))
+    return matchlets;
+
+  new_list = NULL;
+  tmp = matchlets;
+  while (tmp != NULL)
+    {
+      XdgMimeMagicMatchlet *matchlet;
+
+      matchlet = tmp;
+      tmp = tmp->next;
+      matchlet->next = new_list;
+      new_list = matchlet;
+    }
+
+  return new_list;
+
+}
+
+static void
+_xdg_mime_magic_read_magic_file (XdgMimeMagic *mime_magic,
+				 FILE         *magic_file)
+{
+  XdgMimeMagicState state;
+  XdgMimeMagicMatch *match = NULL; /* Quiet compiler */
+
+  state = XDG_MIME_MAGIC_SECTION;
+
+  while (state != XDG_MIME_MAGIC_EOF)
+    {
+      switch (state)
+	{
+	case XDG_MIME_MAGIC_SECTION:
+	  match = _xdg_mime_magic_match_new ();
+	  state = _xdg_mime_magic_parse_header (magic_file, match);
+	  if (state == XDG_MIME_MAGIC_EOF || state == XDG_MIME_MAGIC_ERROR)
+	    _xdg_mime_magic_match_free (match);
+	  break;
+	case XDG_MIME_MAGIC_MAGIC:
+	  state = _xdg_mime_magic_parse_magic_line (magic_file, match);
+	  if (state == XDG_MIME_MAGIC_SECTION ||
+	      (state == XDG_MIME_MAGIC_EOF && match->mime_type))
+	    {
+	      match->matchlet = _xdg_mime_magic_matchlet_mirror (match->matchlet);
+	      _xdg_mime_magic_insert_match (mime_magic, match);
+	    }
+	  else if (state == XDG_MIME_MAGIC_EOF || state == XDG_MIME_MAGIC_ERROR)
+	    _xdg_mime_magic_match_free (match);
+	  break;
+	case XDG_MIME_MAGIC_ERROR:
+	  state = _xdg_mime_magic_parse_error (magic_file);
+	  break;
+	case XDG_MIME_MAGIC_EOF:
+	default:
+	  /* Make the compiler happy */
+	  assert (0);
+	}
+    }
+  _xdg_mime_update_mime_magic_extents (mime_magic);
+}
+
+void
+_xdg_mime_magic_read_from_file (XdgMimeMagic *mime_magic,
+				const char   *file_name)
+{
+  FILE *magic_file;
+  char header[12];
+
+  magic_file = fopen (file_name, "r");
+
+  if (magic_file == NULL)
+    return;
+
+  if (fread (header, 1, 12, magic_file) == 12)
+    {
+      if (memcmp ("MIME-Magic\0\n", header, 12) == 0)
+        _xdg_mime_magic_read_magic_file (mime_magic, magic_file);
+    }
+
+  fclose (magic_file);
+}

Added: trunk/Utils/xdgmime/xdgmimemagic.h
===================================================================
--- trunk/Utils/xdgmime/xdgmimemagic.h	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmimemagic.h	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,56 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmimemagic.h: Private file.  Datastructure for storing the magic files.
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ *
+ * Copyright (C) 2003  Red Hat, Inc.
+ * Copyright (C) 2003  Jonathan Blandford <jrb at alum.mit.edu>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __XDG_MIME_MAGIC_H__
+#define __XDG_MIME_MAGIC_H__
+
+#include <unistd.h>
+#include "xdgmime.h"
+typedef struct XdgMimeMagic XdgMimeMagic;
+
+#ifdef XDG_PREFIX
+#define _xdg_mime_glob_read_from_file             XDG_ENTRY(glob_read_from_file)
+#define _xdg_mime_magic_new                       XDG_ENTRY(magic_new)
+#define _xdg_mime_magic_read_from_file            XDG_ENTRY(magic_read_from_file)
+#define _xdg_mime_magic_free                      XDG_ENTRY(magic_free)
+#define _xdg_mime_magic_get_buffer_extents        XDG_ENTRY(magic_get_buffer_extents)
+#define _xdg_mime_magic_lookup_data               XDG_ENTRY(magic_lookup_data)
+#endif
+
+
+XdgMimeMagic *_xdg_mime_magic_new                (void);
+void          _xdg_mime_magic_read_from_file     (XdgMimeMagic *mime_magic,
+						  const char   *file_name);
+void          _xdg_mime_magic_free               (XdgMimeMagic *mime_magic);
+int           _xdg_mime_magic_get_buffer_extents (XdgMimeMagic *mime_magic);
+const char   *_xdg_mime_magic_lookup_data        (XdgMimeMagic *mime_magic,
+						  const void   *data,
+						  size_t        len,
+						  const char   *mime_types[],
+						  int           n_mime_types);
+
+#endif /* __XDG_MIME_MAGIC_H__ */

Added: trunk/Utils/xdgmime/xdgmimeparent.c
===================================================================
--- trunk/Utils/xdgmime/xdgmimeparent.c	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmimeparent.c	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,219 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmimealias.c: Private file.  Datastructure for storing the hierarchy.
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ *
+ * Copyright (C) 2004  Red Hat, Inc.
+ * Copyright (C) 2004  Matthias Clasen <mclasen at redhat.com>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xdgmimeparent.h"
+#include "xdgmimeint.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <fnmatch.h>
+
+#ifndef	FALSE
+#define	FALSE	(0)
+#endif
+
+#ifndef	TRUE
+#define	TRUE	(!FALSE)
+#endif
+
+typedef struct XdgMimeParents XdgMimeParents;
+
+struct XdgMimeParents
+{
+  char *mime;
+  char **parents;
+  int n_parents;
+};
+
+struct XdgParentList
+{
+  struct XdgMimeParents *parents;
+  int n_mimes;
+};
+
+XdgParentList *
+_xdg_mime_parent_list_new (void)
+{
+  XdgParentList *list;
+
+  list = malloc (sizeof (XdgParentList));
+
+  list->parents = NULL;
+  list->n_mimes = 0;
+
+  return list;
+}
+
+void         
+_xdg_mime_parent_list_free (XdgParentList *list)
+{
+  int i;
+  char **p;
+
+  if (list->parents)
+    {
+      for (i = 0; i < list->n_mimes; i++)
+	{
+	  for (p = list->parents[i].parents; *p; p++)
+	    free (*p);
+
+	  free (list->parents[i].parents);
+	  free (list->parents[i].mime);
+	}
+      free (list->parents);
+    }
+  free (list);
+}
+
+static int
+parent_entry_cmp (const void *v1, const void *v2)
+{
+  return strcmp (((XdgMimeParents *)v1)->mime, ((XdgMimeParents *)v2)->mime);
+}
+
+const char **
+_xdg_mime_parent_list_lookup (XdgParentList *list,
+			      const char    *mime)
+{
+  XdgMimeParents *entry;
+  XdgMimeParents key;
+
+  if (list->n_mimes > 0)
+    {
+      key.mime = (char *)mime;
+      key.parents = NULL;
+
+      entry = bsearch (&key, list->parents, list->n_mimes,
+		       sizeof (XdgMimeParents), &parent_entry_cmp);
+      if (entry)
+        return (const char **)entry->parents;
+    }
+
+  return NULL;
+}
+
+void
+_xdg_mime_parent_read_from_file (XdgParentList *list,
+				 const char    *file_name)
+{
+  FILE *file;
+  char line[255];
+  int i, alloc;
+  XdgMimeParents *entry;
+
+  file = fopen (file_name, "r");
+
+  if (file == NULL)
+    return;
+
+  /* FIXME: Not UTF-8 safe.  Doesn't work if lines are greater than 255 chars.
+   * Blah */
+  alloc = list->n_mimes + 16;
+  list->parents = realloc (list->parents, alloc * sizeof (XdgMimeParents));
+  while (fgets (line, 255, file) != NULL)
+    {
+      char *sep;
+      if (line[0] == '#')
+	continue;
+
+      sep = strchr (line, ' ');
+      if (sep == NULL)
+	continue;
+      *(sep++) = '\000';
+      sep[strlen (sep) -1] = '\000';
+      entry = NULL;
+      for (i = 0; i < list->n_mimes; i++)
+	{
+	  if (strcmp (list->parents[i].mime, line) == 0)
+	    {
+	      entry = &(list->parents[i]);
+	      break;
+	    }
+	}
+      
+      if (!entry)
+	{
+	  if (list->n_mimes == alloc)
+	    {
+	      alloc <<= 1;
+	      list->parents = realloc (list->parents, 
+				       alloc * sizeof (XdgMimeParents));
+	    }
+	  list->parents[list->n_mimes].mime = strdup (line);
+	  list->parents[list->n_mimes].parents = NULL;
+	  entry = &(list->parents[list->n_mimes]);
+	  list->n_mimes++;
+	}
+
+      if (!entry->parents)
+	{
+	  entry->n_parents = 1;
+	  entry->parents = malloc ((entry->n_parents + 1) * sizeof (char *));
+	}
+      else
+	{
+	  entry->n_parents += 1;
+	  entry->parents = realloc (entry->parents, 
+				    (entry->n_parents + 2) * sizeof (char *));
+	}
+      entry->parents[entry->n_parents - 1] = strdup (sep);
+      entry->parents[entry->n_parents] = NULL;
+    }
+
+  list->parents = realloc (list->parents, 
+			   list->n_mimes * sizeof (XdgMimeParents));
+
+  fclose (file);  
+  
+  if (list->n_mimes > 1)
+    qsort (list->parents, list->n_mimes, 
+           sizeof (XdgMimeParents), &parent_entry_cmp);
+}
+
+
+void         
+_xdg_mime_parent_list_dump (XdgParentList *list)
+{
+  int i;
+  char **p;
+
+  if (list->parents)
+    {
+      for (i = 0; i < list->n_mimes; i++)
+	{
+	  for (p = list->parents[i].parents; *p; p++)
+	    printf ("%s %s\n", list->parents[i].mime, *p);
+	}
+    }
+}
+
+

Added: trunk/Utils/xdgmime/xdgmimeparent.h
===================================================================
--- trunk/Utils/xdgmime/xdgmimeparent.h	2006-04-14 06:07:55 UTC (rev 210)
+++ trunk/Utils/xdgmime/xdgmimeparent.h	2006-04-14 07:18:40 UTC (rev 211)
@@ -0,0 +1,50 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* xdgmimeparent.h: Private file.  Datastructure for storing the hierarchy.
+ *
+ * More info can be found at http://www.freedesktop.org/standards/
+ *
+ * Copyright (C) 2004  Red Hat, Inc.
+ * Copyright (C) 200  Matthias Clasen <mclasen at redhat.com>
+ *
+ * Licensed under the Academic Free License version 2.0
+ * Or under the following terms:
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __XDG_MIME_PARENT_H__
+#define __XDG_MIME_PARENT_H__
+
+#include "xdgmime.h"
+
+typedef struct XdgParentList XdgParentList;
+
+#ifdef XDG_PREFIX
+#define _xdg_mime_parent_read_from_file        XDG_ENTRY(parent_read_from_file)
+#define _xdg_mime_parent_list_new              XDG_ENTRY(parent_list_new)
+#define _xdg_mime_parent_list_free             XDG_ENTRY(parent_list_free)
+#define _xdg_mime_parent_list_lookup           XDG_ENTRY(parent_list_lookup)
+#endif
+
+void          _xdg_mime_parent_read_from_file (XdgParentList *list,
+					       const char    *file_name);
+XdgParentList *_xdg_mime_parent_list_new       (void);
+void           _xdg_mime_parent_list_free      (XdgParentList *list);
+const char   **_xdg_mime_parent_list_lookup    (XdgParentList *list,
+						const char    *mime);
+void           _xdg_mime_parent_list_dump      (XdgParentList *list);
+
+#endif /* __XDG_MIME_PARENT_H__ */



From fabricecolin at berlios.de  Sat Apr 15 06:12:08 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 15 Apr 2006 06:12:08 +0200
Subject: [Pinot-svn] r214 - trunk
Message-ID: <200604150412.k3F4C8Pd029615@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-15 06:11:59 +0200 (Sat, 15 Apr 2006)
New Revision: 214

Added:
   trunk/pinot.desktop
Modified:
   trunk/Makefile.am
   trunk/configure.in
   trunk/pinot.spec.in
Log:
Check for desktop-file-install program and shared-mime-info package at
configure time. Distribute and install pinot.desktop file, previously
generated by RPM spec file. 


Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2006-04-14 07:24:46 UTC (rev 213)
+++ trunk/Makefile.am	2006-04-15 04:11:59 UTC (rev 214)
@@ -4,8 +4,8 @@
 SUBDIRS = po Utils Tokenize SQL Collect @SOAP_SUBDIRS@ Search \
 	Index UI/RenderHTML UI/GTK2/src
 
-EXTRA_DIST = ChangeLog NEWS README TODO mkinstalldirs pinot.spec \
-	Search/Plugins/*src Search/Plugins/*.xml \
+EXTRA_DIST = ChangeLog NEWS README TODO mkinstalldirs pinot.desktop \
+	pinot.spec Search/Plugins/*src Search/Plugins/*.xml \
 	UI/GTK2/index.html UI/GTK2/xapian-powered.png UI/GTK2/pinot.png \
 	textcat_conf.txt UI/GTK2/metase-gtk2.glade UI/GTK2/metase-gtk2.gladep
 
@@ -18,13 +18,15 @@
 	$(INSTALL_DATA) textcat_conf.txt $(DESTDIR)$(datadir)/pinot/textcat_conf.txt
 	$(mkinstalldirs) $(DESTDIR)$(datadir)/pinot/engines
 	$(INSTALL_DATA) Search/Plugins/*.src $(DESTDIR)$(datadir)/pinot/engines/
-	mv $(DESTDIR)$(datadir)/pinot/engines/AmazonAPI.src $(DESTDIR)$(datadir)/pinot/
+	@mv $(DESTDIR)$(datadir)/pinot/engines/AmazonAPI.src $(DESTDIR)$(datadir)/pinot/
 	$(INSTALL_DATA) Search/Plugins/*.xml $(DESTDIR)$(datadir)/pinot/engines/
 	$(mkinstalldirs) $(DESTDIR)$(datadir)/pinot/tokenizers
 	@rm -f $(DESTDIR)$(libdir)/lib*tokenizer.*
 	$(INSTALL_DATA) Tokenize/.libs/*.so $(DESTDIR)$(datadir)/pinot/tokenizers/
 	$(mkinstalldirs) $(DESTDIR)$(datadir)/icons/hicolor/48x48/apps/
 	$(INSTALL_DATA) UI/GTK2/pinot.png $(DESTDIR)$(datadir)/icons/hicolor/48x48/apps/pinot.png
+	$(mkinstalldirs) $(DESTDIR)$(datadir)/applications
+	@desktop-file-install --vendor Amra --dir $(DESTDIR)$(datadir)/applications pinot.desktop
 
 ACLOCAL_AMFLAGS = -I m4
 

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2006-04-14 07:24:46 UTC (rev 213)
+++ trunk/configure.in	2006-04-15 04:11:59 UTC (rev 214)
@@ -49,6 +49,7 @@
 AC_LANG_CPLUSPLUS
 
 AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
+AC_PATH_PROG(DESKTOP_INSTALL, desktop-file-install, no)
 
 dnl SOAP API support
 AC_MSG_CHECKING(whether to enable SOAP support)
@@ -140,9 +141,6 @@
 esac
 AC_SUBST(HTTP_DOWNLOADER)
 
-dnl Textcat
-AC_CHECK_HEADERS(textcat.h)
-
 dnl Xapian
 AC_PATH_PROG(XAPIAN_CONFIG, xapian-config, no)
 if test "$XAPIAN_CONFIG" = "no" ; then
@@ -153,8 +151,10 @@
 XAPIAN_LIBS=`$XAPIAN_CONFIG --libs`
 
 dnl Other libraries
-MISC_LIBS="-lmagic -lcrypt"
+MISC_LIBS="-lcrypt"
 AC_SUBST(MISC_LIBS)
+AC_CHECK_HEADERS(textcat.h)
+PKG_CHECK_MODULES(MIMEINFO, shared-mime-info >= 0.17 )
 PKG_CHECK_MODULES(TAGLIB, taglib >= 1.4 )
 AC_SUBST(TAGLIB_CFLAGS)
 AC_SUBST(TAGLIB_LIBS)

Added: trunk/pinot.desktop
===================================================================
--- trunk/pinot.desktop	2006-04-14 07:24:46 UTC (rev 213)
+++ trunk/pinot.desktop	2006-04-15 04:11:59 UTC (rev 214)
@@ -0,0 +1,10 @@
+[Desktop Entry]
+Name=Pinot Metasearch Tool
+Comment=Search the Web and your documents
+Exec=pinot
+StartupNotify=true
+Icon=pinot.png
+Terminal=false
+Type=Application
+Categories=Application;Network;
+Encoding=UTF-8

Modified: trunk/pinot.spec.in
===================================================================
--- trunk/pinot.spec.in	2006-04-14 07:24:46 UTC (rev 213)
+++ trunk/pinot.spec.in	2006-04-15 04:11:59 UTC (rev 214)
@@ -61,23 +61,6 @@
 %install
 [ -n "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf $RPM_BUILD_ROOT
 %makeinstall
-# Desktop file
-cat >%{name}.desktop << EOF
-[Desktop Entry]
-Name=Pinot Metasearch Tool
-Comment=Search the Web and your documents
-Exec=%{_bindir}/pinot
-StartupNotify=true
-Icon=pinot.png
-Terminal=false
-Type=Application
-Categories=Application;Network;
-Encoding=UTF-8
-EOF
-mkdir -p $RPM_BUILD_ROOT/%{_datadir}/applications
-desktop-file-install --vendor Amra \
-	--dir $RPM_BUILD_ROOT/%{_datadir}/applications  \
-	%{name}.desktop
 
 %post
 gtk-update-icon-cache -q -f %{_datadir}/icons/hicolor || :
@@ -119,7 +102,7 @@
 %{_datadir}/locale/fr/LC_MESSAGES/pinot.mo
 %{_datadir}/locale/es/LC_MESSAGES/pinot.mo
 %{_datadir}/icons/hicolor/48x48/apps/pinot.png
-%{_datadir}/applications/Amra-%{name}.desktop
+%{_datadir}/applications/Amra-pinot.desktop
 
 %files text-docs 
 %defattr(-, root, root, -)



From fabricecolin at berlios.de  Sat Apr 15 06:26:54 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 15 Apr 2006 06:26:54 +0200
Subject: [Pinot-svn] r215 - trunk
Message-ID: <200604150426.k3F4QsIX032546@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-15 06:26:52 +0200 (Sat, 15 Apr 2006)
New Revision: 215

Modified:
   trunk/NEWS
   trunk/TODO
Log:
Updated with last few days' changes.


Modified: trunk/NEWS
===================================================================
--- trunk/NEWS	2006-04-15 04:11:59 UTC (rev 214)
+++ trunk/NEWS	2006-04-15 04:26:52 UTC (rev 215)
@@ -3,6 +3,9 @@
  - resurrected support for the Google API, enabled with "./configure --with-soap=yes"
  - tweaked extraction of results' extract and URL
  - renamed pinot_search to pinot-search
+Index :
+ - changed URL hash algorithm for compatibility with omindex. Reindexing documents
+  with URLs > 128 characters is necessary
 Tokenize :
  - new tokenizer for MP3, Vorbis and FLAC files that depend on the TagLib library
  - new XML tokenizer
@@ -58,7 +61,7 @@
  - URLs of results returned by Sherlock engines were incorrectly lower-cased
  - fix for Topix and Acoona
 Index :
- - Changed term prefixes to conform to conventions used by Omega and other
+ - changed term prefixes to conform to conventions used by Omega and other
   Xapian-based tools. Unfortunately, users will have to update documents and
   reapply labels !
 UI :

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-04-15 04:11:59 UTC (rev 214)
+++ trunk/TODO	2006-04-15 04:26:52 UTC (rev 215)
@@ -7,8 +7,7 @@
 - Check for leaks with valgrind (eg --tool=memcheck -v --leak-check=yes --show-reachable=yes ...)
 - Change .spec to allow building with Google and ObjectsSearch SOAP APIs support
 - Don't use system(), fork and exec, especially for the external browser
-- Replace libmagic with xdgmime (built in gtk > 2.8), use it to determine which application
-  is for which MIME type too
+- Find out how to determine what application to use for a given MIME type and drop internal browser
 
 Search
 - Write a Spirit-based parser for extracting results from web pages
@@ -26,11 +25,9 @@
 - Harvest mode grabs all pages on a specific site down to a certain depth
 - Make User-Agent string configurable
 - Make download timeout configurable
-- Investigate replacing neon (and gsoap ?) with libsoup
 - Support for HTML frames
 - Allow to cache documents that had to be converted ? eg PDF, MS Word
 - Use poppler for the PDF tokenizer
-- Write a basic XML tokenizer that skips tags
 - WordPerfect tokenizer with libwpd
 
 Index
@@ -55,11 +52,6 @@
 - Use dbus for communication
 - Index browser history in My Web index
 
-RenderHTML
-- Sort out issues with gtk_embed_moz if possible
-- Replace Mozilla GTK embed with GTK WebCore or latest gtkhtml, or drop altogether ?
-- Is it possible to build against Firefox instead of the Mozilla suite ?
-
 Mail
 - Find out what kind of locking scheme Mozilla uses (POSIX lock ?) and use that
 - Index Evolution email (Camel, might be useful for other types actually)



From fabricecolin at berlios.de  Sat Apr 15 07:29:09 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 15 Apr 2006 07:29:09 +0200
Subject: [Pinot-svn] r216 - in trunk/UI/GTK2: . src
Message-ID: <200604150529.k3F5T96n031492@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-15 07:29:06 +0200 (Sat, 15 Apr 2006)
New Revision: 216

Modified:
   trunk/UI/GTK2/metase-gtk2.glade
   trunk/UI/GTK2/src/queryDialog_glade.cc
Log:
Renamed/relabeled tabs in queryDialog.


Modified: trunk/UI/GTK2/metase-gtk2.glade
===================================================================
--- trunk/UI/GTK2/metase-gtk2.glade	2006-04-15 04:26:52 UTC (rev 215)
+++ trunk/UI/GTK2/metase-gtk2.glade	2006-04-15 05:29:06 UTC (rev 216)
@@ -19,6 +19,7 @@
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
   <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
   <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <signal name="delete_event" handler="on_mainWindow_delete_event" last_modification_time="Sat, 17 May 2003 11:06:56 GMT"/>
 
   <child>
@@ -30,6 +31,8 @@
       <child>
 	<widget class="GtkMenuBar" id="mainMenubar">
 	  <property name="visible">True</property>
+	  <property name="pack_direction">GTK_PACK_DIRECTION_LTR</property>
+	  <property name="child_pack_direction">GTK_PACK_DIRECTION_LTR</property>
 
 	  <child>
 	    <widget class="GtkMenuItem" id="sessionMenuitem">
@@ -896,6 +899,7 @@
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
   <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
   <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <property name="has_separator">True</property>
 
   <child internal-child="vbox">
@@ -1841,7 +1845,7 @@
 <widget class="GtkDialog" id="queryDialog">
   <property agent="glademm" name="cxx_visibility">public</property>
   <property name="visible">True</property>
-  <property name="title" translatable="yes">Query properties</property>
+  <property name="title" translatable="yes">Query parameters</property>
   <property name="type">GTK_WINDOW_TOPLEVEL</property>
   <property name="window_position">GTK_WIN_POS_NONE</property>
   <property name="modal">False</property>
@@ -1853,6 +1857,7 @@
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
   <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
   <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <property name="has_separator">True</property>
 
   <child internal-child="vbox">
@@ -2321,9 +2326,9 @@
 	      </child>
 
 	      <child>
-		<widget class="GtkLabel" id="propertiesLabel">
+		<widget class="GtkLabel" id="commonLabel">
 		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Properties</property>
+		  <property name="label" translatable="yes">All engines</property>
 		  <property name="use_underline">False</property>
 		  <property name="use_markup">False</property>
 		  <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -2595,7 +2600,7 @@
 	      <child>
 		<widget class="GtkLabel" id="advancedLabel">
 		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Advanced</property>
+		  <property name="label" translatable="yes">Indexes only</property>
 		  <property name="use_underline">False</property>
 		  <property name="use_markup">False</property>
 		  <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -2643,9 +2648,10 @@
   <property name="decorated">True</property>
   <property name="skip_taskbar_hint">False</property>
   <property name="skip_pager_hint">False</property>
-  <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
   <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
   <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <property name="has_separator">True</property>
 
   <child internal-child="vbox">
@@ -3011,6 +3017,7 @@
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
   <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
   <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <property name="has_separator">True</property>
 
   <child internal-child="vbox">
@@ -3332,6 +3339,7 @@
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
   <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
   <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <property name="has_separator">True</property>
   <signal name="response" handler="on_importDialog_response" last_modification_time="Tue, 10 Jan 2006 05:41:42 GMT"/>
 

Modified: trunk/UI/GTK2/src/queryDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/queryDialog_glade.cc	2006-04-15 04:26:52 UTC (rev 215)
+++ trunk/UI/GTK2/src/queryDialog_glade.cc	2006-04-15 05:29:06 UTC (rev 216)
@@ -1,9 +1,9 @@
-// generated 2006/1/9 22:33:43 SGT by fabrice at amra.dyndns.org.(none)
+// generated 2006/4/14 17:36:14 SGT by fabrice at amra.dyndns.org.(none)
 // using glademm V2.6.0
 //
 // DO NOT EDIT THIS FILE ! It was created using
 // glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
-// for gtk 2.6.10 and gtkmm 2.6.2
+// for gtk 2.8.15 and gtkmm 2.8.3
 //
 // Please modify the corresponding derived classes in ./src/queryDialog.cc
 
@@ -80,7 +80,7 @@
    
    Gtk::Table *tersmTable = Gtk::manage(new class Gtk::Table(2, 2, false));
    Gtk::VBox *termsVbox = Gtk::manage(new class Gtk::VBox(false, 0));
-   Gtk::Label *propertiesLabel = Gtk::manage(new class Gtk::Label(_("Properties")));
+   Gtk::Label *commonLabel = Gtk::manage(new class Gtk::Label(_("All engines")));
    Gtk::Label *filtersLabel = Gtk::manage(new class Gtk::Label(_("Limit to documents that match")));
    phraseEntry = Gtk::manage(new class Gtk::Entry());
    
@@ -95,7 +95,7 @@
    
    Gtk::Table *advancedTable = Gtk::manage(new class Gtk::Table(2, 2, false));
    Gtk::VBox *advancedVbox = Gtk::manage(new class Gtk::VBox(false, 0));
-   Gtk::Label *advancedLabel = Gtk::manage(new class Gtk::Label(_("Advanced")));
+   Gtk::Label *advancedLabel = Gtk::manage(new class Gtk::Label(_("Indexes only")));
    queryNotebook = Gtk::manage(new class Gtk::Notebook());
    
    Gtk::VBox *queryVbox = Gtk::manage(new class Gtk::VBox(false, 0));
@@ -200,12 +200,12 @@
    tersmTable->attach(*notLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
    tersmTable->attach(*notEntry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
    termsVbox->pack_start(*tersmTable, Gtk::PACK_SHRINK, 4);
-   propertiesLabel->set_alignment(0.5,0.5);
-   propertiesLabel->set_padding(0,0);
-   propertiesLabel->set_justify(Gtk::JUSTIFY_LEFT);
-   propertiesLabel->set_line_wrap(false);
-   propertiesLabel->set_use_markup(false);
-   propertiesLabel->set_selectable(false);
+   commonLabel->set_alignment(0.5,0.5);
+   commonLabel->set_padding(0,0);
+   commonLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   commonLabel->set_line_wrap(false);
+   commonLabel->set_use_markup(false);
+   commonLabel->set_selectable(false);
    filtersLabel->set_alignment(0,0.5);
    filtersLabel->set_padding(4,4);
    filtersLabel->set_justify(Gtk::JUSTIFY_LEFT);
@@ -271,7 +271,7 @@
    queryNotebook->set_show_border(true);
    queryNotebook->set_tab_pos(Gtk::POS_TOP);
    queryNotebook->set_scrollable(false);
-   queryNotebook->append_page(*termsVbox, *propertiesLabel);
+   queryNotebook->append_page(*termsVbox, *commonLabel);
    queryNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
    queryNotebook->append_page(*advancedVbox, *advancedLabel);
    queryNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
@@ -280,7 +280,7 @@
    queryDialog->get_vbox()->set_homogeneous(false);
    queryDialog->get_vbox()->set_spacing(0);
    queryDialog->get_vbox()->pack_start(*queryVbox);
-   queryDialog->set_title(_("Query properties"));
+   queryDialog->set_title(_("Query parameters"));
    queryDialog->set_modal(false);
    queryDialog->property_window_position().set_value(Gtk::WIN_POS_NONE);
    queryDialog->set_resizable(true);
@@ -307,7 +307,7 @@
    notEntry->show();
    tersmTable->show();
    termsVbox->show();
-   propertiesLabel->show();
+   commonLabel->show();
    filtersLabel->show();
    phraseEntry->show();
    phraseLabel->show();



From fabricecolin at berlios.de  Sat Apr 15 14:09:07 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 15 Apr 2006 14:09:07 +0200
Subject: [Pinot-svn] r217 - trunk/UI/GTK2/src
Message-ID: <200604151209.k3FC97vE013501@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-15 14:09:04 +0200 (Sat, 15 Apr 2006)
New Revision: 217

Modified:
   trunk/UI/GTK2/src/mainWindow.cc
Log:
Added missing check on index tree when IndexingThread returns. This could cause
a crash. Yeah it was that bad :-)


Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2006-04-15 05:29:06 UTC (rev 216)
+++ trunk/UI/GTK2/src/mainWindow.cc	2006-04-15 12:09:04 UTC (rev 217)
@@ -1048,23 +1048,26 @@
 				m_state.unlock_lists();
 			}
 
-			unsigned int rowsCount = pIndexTree->getRowsCount();
-
-			// Ensure the last page is being displayed and is not full
-			if ((pIndexPage->getFirstDocument() + rowsCount == pIndexPage->getDocumentsCount()) &&
-				(rowsCount < m_maxDocsCount))
+			if (pIndexTree != NULL)
 			{
-				// Add a row to the index tree
-				IndexedDocument indexedDoc(docInfo.getTitle(),
-					XapianEngine::buildUrl(m_settings.m_indexLocation, docId),
-					docInfo.getLocation(), docInfo.getType(),
-					docInfo.getLanguage());
-				indexedDoc.setTimestamp(docInfo.getTimestamp());
+				unsigned int rowsCount = pIndexTree->getRowsCount();
 
-				append_document(pIndexPage, _("My Documents"), indexedDoc);
+				// Ensure the last page is being displayed and is not full
+				if ((pIndexPage->getFirstDocument() + rowsCount == pIndexPage->getDocumentsCount()) &&
+					(rowsCount < m_maxDocsCount))
+				{
+					// Add a row to the index tree
+					IndexedDocument indexedDoc(docInfo.getTitle(),
+						XapianEngine::buildUrl(m_settings.m_indexLocation, docId),
+						docInfo.getLocation(), docInfo.getType(),
+						docInfo.getLanguage());
+					indexedDoc.setTimestamp(docInfo.getTimestamp());
+
+					append_document(pIndexPage, _("My Documents"), indexedDoc);
+				}
+				pIndexPage->setDocumentsCount(pIndexPage->getDocumentsCount() + 1);
+				pIndexPage->updateButtonsState(m_maxDocsCount);
 			}
-			pIndexPage->setDocumentsCount(pIndexPage->getDocumentsCount() + 1);
-			pIndexPage->updateButtonsState(m_maxDocsCount);
 		}
 
 		set_status(status);
@@ -1272,8 +1275,6 @@
 				IndexPage *pIndexPage = dynamic_cast<IndexPage*>(pPage);
 				if (pIndexPage != NULL)
 				{
-					IndexTree *pIndexTree = pIndexPage->getTree();
-
 					// Synchronize the labels list with the new settings
 					pIndexPage->populateLabelCombobox();
 				}
@@ -1710,7 +1711,6 @@
 		ustring indexName(_("My Documents"));
 
 		// Is the index still being shown ?
-		IndexTree *pIndexTree = NULL;
 		IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(indexName, NotebookPageBox::INDEX_PAGE));
 		if (pIndexPage != NULL)
 		{



From fabricecolin at berlios.de  Sat Apr 15 14:12:51 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 15 Apr 2006 14:12:51 +0200
Subject: [Pinot-svn] r218 - trunk/Utils
Message-ID: <200604151212.k3FCCp8v014641@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-15 14:12:10 +0200 (Sat, 15 Apr 2006)
New Revision: 218

Modified:
   trunk/Utils/Url.cpp
Log:
Slightly better parsing of relative URLs.


Modified: trunk/Utils/Url.cpp
===================================================================
--- trunk/Utils/Url.cpp	2006-04-15 12:09:04 UTC (rev 217)
+++ trunk/Utils/Url.cpp	2006-04-15 12:12:10 UTC (rev 218)
@@ -63,31 +63,42 @@
 	string::size_type pos1 =0, pos2 = 0;
 	bool hasHostName = true;
 
-	// If the URL starts with a slash, don't parse and consider it local
-	if (url[0] == '/')
+	if ((url[0] == '/') ||
+		(url[0] == '.'))
 	{
-		m_location = url;
-		return;
+		if ((url.length() > 2) &&
+				(url.substr(0, 2) == "./"))
+		{
+			pos2 = 2;
+		}
+
+		// Assume default protocol
+		m_protocol = "file";
+
+		hasHostName = false;
 	}
-
-	// Protocol
-	pos1 = url.find("://");
-	if (pos1 != string::npos)
+	else
 	{
-		m_protocol = url.substr(0, pos1);
-		pos1 += 3;
+		// Protocol
+		pos1 = url.find("://");
+		if (pos1 != string::npos)
+		{
+			m_protocol = url.substr(0, pos1);
+			pos1 += 3;
+		}
+		else
+		{
+			// Assume default protocol
+			m_protocol = "file";
+			pos1 = 0;
+		}
 
 		if (isLocal(m_protocol) == true)
 		{
 			hasHostName = false;
+			pos2 = pos1;
 		}
 	}
-	else
-	{
-		// Assume default protocol
-		m_protocol = "http";
-		pos1 = 0;
-	}
 
 	if (hasHostName == true)
 	{
@@ -143,7 +154,6 @@
 	else
 	{
 		m_host = "localhost";
-		pos2 = pos1;
 	}
 
 	string locationAndFile = url.substr(pos2);



From fabricecolin at berlios.de  Mon Apr 17 16:05:08 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Mon, 17 Apr 2006 16:05:08 +0200
Subject: [Pinot-svn] r219 - trunk
Message-ID: <200604171405.k3HE58R1013067@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-17 16:04:59 +0200 (Mon, 17 Apr 2006)
New Revision: 219

Modified:
   trunk/README
   trunk/configure.in
Log:
Preparing for v0.46 release.


Modified: trunk/README
===================================================================
--- trunk/README	2006-04-15 12:12:10 UTC (rev 218)
+++ trunk/README	2006-04-17 14:04:59 UTC (rev 219)
@@ -56,6 +56,12 @@
 shared-mime-info					0.17
 http://freedesktop.org/Software/shared-mime-info
 
+desktop-file-utils					0.10
+http://www.freedesktop.org/software/desktop-file-utils
+
+unzip							5.52
+http://www.info-zip.org/pub/infozip/UnZip.html
+
 pdftohtml						0.36
 http://pdftohtml.sourceforge.net/
 

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2006-04-15 12:12:10 UTC (rev 218)
+++ trunk/configure.in	2006-04-17 14:04:59 UTC (rev 219)
@@ -2,7 +2,7 @@
 # using glademm V2.6.0
 
 AC_PREREQ(2.50)
-AC_INIT(pinot, 0.45,[fabricecolin at users.berlios.de])
+AC_INIT(pinot, 0.46,[fabricecolin at users.berlios.de])
 AM_INIT_AUTOMAKE
 AC_CONFIG_HEADERS(config.h)
 
@@ -154,7 +154,7 @@
 MISC_LIBS="-lcrypt"
 AC_SUBST(MISC_LIBS)
 AC_CHECK_HEADERS(textcat.h)
-PKG_CHECK_MODULES(MIMEINFO, shared-mime-info >= 0.17 )
+PKG_CHECK_MODULES(MIMEINFO, shared-mime-info )
 PKG_CHECK_MODULES(TAGLIB, taglib >= 1.4 )
 AC_SUBST(TAGLIB_CFLAGS)
 AC_SUBST(TAGLIB_LIBS)



From fabricecolin at berlios.de  Tue Apr 18 16:03:45 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 18 Apr 2006 16:03:45 +0200
Subject: [Pinot-svn] r220 - in trunk: . Search/Plugins
Message-ID: <200604181403.k3IE3jIo012454@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-18 16:03:43 +0200 (Tue, 18 Apr 2006)
New Revision: 220

Removed:
   trunk/Search/Plugins/MozDexDescription.xml
Modified:
   trunk/pinot.spec.in
Log:
Removed MozDex as its OpenSearch output been unavailable for weeks. Hopefully,
this is only temporary.


Deleted: trunk/Search/Plugins/MozDexDescription.xml
===================================================================
--- trunk/Search/Plugins/MozDexDescription.xml	2006-04-17 14:04:59 UTC (rev 219)
+++ trunk/Search/Plugins/MozDexDescription.xml	2006-04-18 14:03:43 UTC (rev 220)
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<OpenSearchDescription xmlns="http://a9.com/-/spec/opensearchdescription/1.0/">
-  <Url>http://www.mozdex.com/open.jsp?query={searchTerms}&amp;start={startIndex}</Url>
-  <Format>http://a9.com/-/spec/opensearchrss/1.0/</Format>
-  <ShortName>Mozdex</ShortName>
-  <LongName>Mozdex Search Engine</LongName>
-  <Description>Search the Internet at Mozdex.com.</Description>
-  <Tags>The Web</Tags>
-  <Image>http://www.mozdex.com/spec/ico-64-unavailable.gif</Image>
-  <SampleSearch>linux</SampleSearch>
-  <Developer>Mozdex.com</Developer>
-  <Contact>byronm at gmail.com</Contact>
-  <Attribution>Search data &amp;copy; 2005, Small Productions,
-   All Rights Reserved</Attribution>
-  <SyndicationRight>open</SyndicationRight>
-  <AdultContent>false</AdultContent>
-</OpenSearchDescription>

Modified: trunk/pinot.spec.in
===================================================================
--- trunk/pinot.spec.in	2006-04-17 14:04:59 UTC (rev 219)
+++ trunk/pinot.spec.in	2006-04-18 14:03:43 UTC (rev 220)
@@ -98,7 +98,6 @@
 %config(noreplace) %{_datadir}/pinot/engines/YahooAPI.src
 %config(noreplace) %{_datadir}/pinot/engines/Wikipedia.src
 %config(noreplace) %{_datadir}/pinot/engines/KodersDescription.xml
-%config(noreplace) %{_datadir}/pinot/engines/MozDexDescription.xml
 %{_datadir}/locale/fr/LC_MESSAGES/pinot.mo
 %{_datadir}/locale/es/LC_MESSAGES/pinot.mo
 %{_datadir}/icons/hicolor/48x48/apps/pinot.png



From fabricecolin at berlios.de  Tue Apr 18 16:08:09 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 18 Apr 2006 16:08:09 +0200
Subject: [Pinot-svn] r221 - in trunk: UI/GTK2/src Utils
Message-ID: <200604181408.k3IE894o013594@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-18 16:08:07 +0200 (Tue, 18 Apr 2006)
New Revision: 221

Modified:
   trunk/UI/GTK2/src/prefsDialog.cc
   trunk/Utils/MIMEScanner.cpp
Log:
Be a bit less stringent with mbox'es as shared-mime-info/xdgmime doesn't
recognize them as text/x-mail.
MIMEScanner now returns xdg_mime_type_unknown for unknown types.


Modified: trunk/UI/GTK2/src/prefsDialog.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.cc	2006-04-18 14:03:43 UTC (rev 220)
+++ trunk/UI/GTK2/src/prefsDialog.cc	2006-04-18 14:08:07 UTC (rev 221)
@@ -250,34 +250,28 @@
 			TreeModel::Row row = *iter;
 			PinotSettings::MailAccount mailAccount;
 
-			ustring mimeType = row[m_mailColumns.m_type];
-			if (mimeType == "text/x-mail")
-			{
-				// Add this new mail account to the settings
-				mailAccount.m_name = row[m_mailColumns.m_location];
-				mailAccount.m_type = mimeType;
-				mailAccount.m_modTime = row[m_mailColumns.m_mTime];
-				mailAccount.m_lastMessageTime = row[m_mailColumns.m_minDate];
+			// FIXME: unlike libmagic, shared-mime-info fails to identify most mbox files
+			// as being of type text/x-mail
+			// Add this new mail account to the settings
+			mailAccount.m_name = row[m_mailColumns.m_location];
+			mailAccount.m_type = row[m_mailColumns.m_type];
+			mailAccount.m_modTime = row[m_mailColumns.m_mTime];
+			mailAccount.m_lastMessageTime = row[m_mailColumns.m_minDate];
 
-				string mailLabel("mailbox://");
-				mailLabel += from_utf8(mailAccount.m_name);
+			string mailLabel("mailbox://");
+			mailLabel += from_utf8(mailAccount.m_name);
 
-				// Check user didn't recreate this mail account after having deleted it
-				set<string>::iterator mailIter = m_deletedMail.find(mailLabel);
-				if (mailIter != m_deletedMail.end())
-				{
-					m_deletedMail.erase(mailIter);
-				}
+			// Check user didn't recreate this mail account after having deleted it
+			set<string>::iterator mailIter = m_deletedMail.find(mailLabel);
+			if (mailIter != m_deletedMail.end())
+			{
+				m_deletedMail.erase(mailIter);
+			}
 
 #ifdef DEBUG
-				cout << "prefsDialog::save_mailTreeview: " << mailAccount.m_name << endl;
+			cout << "prefsDialog::save_mailTreeview: " << mailAccount.m_name << endl;
 #endif
-				m_settings.m_mailAccounts.insert(mailAccount);
-			}
-#ifdef DEBUG
-			else cout << "prefsDialog::save_mailTreeview: format " << mimeType
-				<< ", file " << row[m_mailColumns.m_location] << ", is not supported" << endl;
-#endif
+			m_settings.m_mailAccounts.insert(mailAccount);
 		}
 	}
 
@@ -394,23 +388,26 @@
 	{
 		string mimeType = MIMEScanner::scanFile(fileName);
 
-		if (mimeType == "text/x-mail")
-		{
-			// Create a new entry in the mail accounts list
-			TreeModel::iterator iter = m_refMailTree->append();
-			TreeModel::Row row = *iter;
+#ifdef DEBUG
+		cout << "prefsDialog::on_addAccountButton_clicked: " << fileName
+			<< " has format " << mimeType << endl;
+#endif
+		// FIXME: unlike libmagic, shared-mime-info fails to identify most mbox files
+		// as being of type text/x-mail
+		// Create a new entry in the mail accounts list
+		TreeModel::iterator iter = m_refMailTree->append();
+		TreeModel::Row row = *iter;
 	
-			row[m_mailColumns.m_location] = to_utf8(fileName);
-			row[m_mailColumns.m_type] = to_utf8(mimeType);
-			row[m_mailColumns.m_mTime] = 0;
-			row[m_mailColumns.m_minDate] = 0;
+		row[m_mailColumns.m_location] = to_utf8(fileName);
+		row[m_mailColumns.m_type] = to_utf8(mimeType);
+		row[m_mailColumns.m_mTime] = 0;
+		row[m_mailColumns.m_minDate] = 0;
 
-			if (wasEmpty == true)
-			{
-				// Enable these buttons
-				editAccountButton->set_sensitive(true);
-				removeAccountButton->set_sensitive(true);
-			}
+		if (wasEmpty == true)
+		{
+			// Enable these buttons
+			editAccountButton->set_sensitive(true);
+			removeAccountButton->set_sensitive(true);
 		}
 	}
 }

Modified: trunk/Utils/MIMEScanner.cpp
===================================================================
--- trunk/Utils/MIMEScanner.cpp	2006-04-18 14:03:43 UTC (rev 220)
+++ trunk/Utils/MIMEScanner.cpp	2006-04-18 14:08:07 UTC (rev 221)
@@ -16,6 +16,7 @@
 
 #include <strings.h>
 #include <utility>
+#include <iostream>
 
 #include "xdgmime/xdgmime.h"
 
@@ -23,6 +24,8 @@
 #include "StringManip.h"
 #include "Url.h"
 
+using std::cout;
+using std::endl;
 using std::string;
 using std::min;
 
@@ -42,6 +45,9 @@
 	if ((pType == NULL) ||
 		(strncasecmp(pType, xdg_mime_type_unknown, min(strlen(pType), strlen(xdg_mime_type_unknown))) == 0))
 	{
+#ifdef DEBUG
+		cout << "MIMEScanner::scanFileType: couldn't determine type of " << fileName << endl;
+#endif
 		return "";
 	}
 
@@ -61,13 +67,19 @@
 	{
 		// Have a peek at the file
 		const char *pType = xdg_mime_get_mime_type_for_file(fileName.c_str(), NULL);
-		if ((pType == NULL) ||
-			(strncasecmp(pType, xdg_mime_type_unknown, min(strlen(pType), strlen(xdg_mime_type_unknown))) == 0))
+		if ((pType != NULL) &&
+			(strncasecmp(pType, xdg_mime_type_unknown, min(strlen(pType), strlen(xdg_mime_type_unknown))) != 0))
 		{
-			return "";
+			return pType;
 		}
 
-		mimeType = pType;
+#ifdef DEBUG
+		cout << "MIMEScanner::scanFile: couldn't determine type of " << fileName << endl;
+#endif
+		if (xdg_mime_type_unknown != NULL)
+		{
+			mimeType = xdg_mime_type_unknown;
+		}
 	}
 
 	return mimeType;
@@ -96,6 +108,10 @@
 		{
 			mimeType = "text/html";
 		}
+		else if (xdg_mime_type_unknown != NULL)
+		{
+			mimeType = xdg_mime_type_unknown;
+		}
 	}
 
 	return mimeType;



From fabricecolin at berlios.de  Fri Apr 21 13:21:58 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 21 Apr 2006 13:21:58 +0200
Subject: [Pinot-svn] r222 - trunk/po
Message-ID: <200604211121.k3LBLwOd008856@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-21 13:21:53 +0200 (Fri, 21 Apr 2006)
New Revision: 222

Modified:
   trunk/po/es.po
   trunk/po/fr.po
Log:
Updated translations.


Modified: trunk/po/es.po
===================================================================
--- trunk/po/es.po	2006-04-18 14:08:07 UTC (rev 221)
+++ trunk/po/es.po	2006-04-21 11:21:53 UTC (rev 222)
@@ -1,14 +1,14 @@
-# es PO file for pinot.
-# Copyright (C) 2006 Fabrice Colin, Jes?s Tramullas
-# This file is distributed under the same license as the pinot package.
-# Jes?s Tramullas <jesus at tramullas.com>, 2006.
-#
+# es PO file for pinot.
+# Copyright (C) 2006 Fabrice Colin, Jes?s Tramullas
+# This file is distributed under the same license as the pinot package.
+# Jes?s Tramullas <jesus at tramullas.com>, 2006.
+# 
 #, fuzzy
 msgid ""
 msgstr ""
 "Project-Id-Version: pinot 0.43\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2006-03-25 12:40+0800\n"
+"POT-Creation-Date: 2006-04-18 23:23+0800\n"
 "PO-Revision-Date: 2006-01-30 16:44+0800\n"
 "Last-Translator: Jes?s Tramullas <jesus at tramullas.com>\n"
 "Language-Team: es <jesus at tramullas.com>\n"
@@ -24,19 +24,19 @@
 msgid "Current User"
 msgstr "Usuario"
 
-#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:371
-#: UI/GTK2/src/mainWindow.cc:374 UI/GTK2/src/mainWindow.cc:544
-#: UI/GTK2/src/mainWindow.cc:1009 UI/GTK2/src/mainWindow.cc:1063
-#: UI/GTK2/src/mainWindow.cc:1082 UI/GTK2/src/mainWindow.cc:1117
-#: UI/GTK2/src/mainWindow.cc:1698 UI/GTK2/src/PinotSettings.cpp:201
-#: UI/GTK2/src/PinotSettings.cpp:909 UI/GTK2/src/PinotSettings.cpp:965
+#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:372
+#: UI/GTK2/src/mainWindow.cc:375 UI/GTK2/src/mainWindow.cc:545
+#: UI/GTK2/src/mainWindow.cc:1010 UI/GTK2/src/mainWindow.cc:1066
+#: UI/GTK2/src/mainWindow.cc:1086 UI/GTK2/src/mainWindow.cc:1121
+#: UI/GTK2/src/mainWindow.cc:1711 UI/GTK2/src/PinotSettings.cpp:201
+#: UI/GTK2/src/PinotSettings.cpp:911 UI/GTK2/src/PinotSettings.cpp:967
 msgid "My Documents"
 msgstr "Mis documentos"
 
-#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:377
-#: UI/GTK2/src/mainWindow.cc:380 UI/GTK2/src/mainWindow.cc:548
+#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:378
+#: UI/GTK2/src/mainWindow.cc:381 UI/GTK2/src/mainWindow.cc:549
 #: UI/GTK2/src/MonitorHandler.cpp:173 UI/GTK2/src/PinotSettings.cpp:202
-#: UI/GTK2/src/PinotSettings.cpp:910 UI/GTK2/src/PinotSettings.cpp:966
+#: UI/GTK2/src/PinotSettings.cpp:912 UI/GTK2/src/PinotSettings.cpp:968
 #: UI/GTK2/src/prefsDialog_glade.cc:115
 msgid "My Email"
 msgstr "Mi email"
@@ -45,7 +45,7 @@
 msgid "Enabled"
 msgstr "Activo"
 
-#: UI/GTK2/src/importDialog.cc:109 UI/GTK2/src/prefsDialog.cc:82
+#: UI/GTK2/src/importDialog.cc:109 UI/GTK2/src/prefsDialog.cc:83
 msgid "MIME Type"
 msgstr "Tipo MIME"
 
@@ -66,7 +66,7 @@
 msgid "None"
 msgstr "Ninguno"
 
-#: UI/GTK2/src/importDialog.cc:445
+#: UI/GTK2/src/importDialog.cc:446
 msgid "Document To Import"
 msgstr "Documento a importar"
 
@@ -160,212 +160,212 @@
 msgid "Summary"
 msgstr "Sumario"
 
-#: UI/GTK2/src/mainWindow.cc:245
+#: UI/GTK2/src/mainWindow.cc:246
 msgid "Add index"
 msgstr "A?adir ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:246
+#: UI/GTK2/src/mainWindow.cc:247
 msgid "Remove index"
 msgstr "Borrar ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:262
+#: UI/GTK2/src/mainWindow.cc:263
 msgid "Ready"
 msgstr "Listo"
 
-#: UI/GTK2/src/mainWindow.cc:276 UI/GTK2/src/mainWindow.cc:966
-#: UI/GTK2/src/mainWindow.cc:1291 UI/GTK2/src/mainWindow.cc:2871
+#: UI/GTK2/src/mainWindow.cc:277 UI/GTK2/src/mainWindow.cc:967
+#: UI/GTK2/src/mainWindow.cc:1304 UI/GTK2/src/mainWindow.cc:2883
 #: UI/GTK2/src/mainWindow_glade.cc:207
 msgid "View"
 msgstr "Ver"
 
-#: UI/GTK2/src/mainWindow.cc:308
+#: UI/GTK2/src/mainWindow.cc:309
 msgid "N/A"
 msgstr "Desconocido"
 
-#: UI/GTK2/src/mainWindow.cc:318
+#: UI/GTK2/src/mainWindow.cc:319
 msgid "<undefined>"
 msgstr "<indefinido>"
 
-#: UI/GTK2/src/mainWindow.cc:506
+#: UI/GTK2/src/mainWindow.cc:507
 msgid "Result location is"
 msgstr "La localizaci?n del resultado es"
 
-#: UI/GTK2/src/mainWindow.cc:559
+#: UI/GTK2/src/mainWindow.cc:560
 msgid "Document location is"
 msgstr "La localizaci?n del documento es"
 
-#: UI/GTK2/src/mainWindow.cc:811
+#: UI/GTK2/src/mainWindow.cc:812
 msgid "Showing"
 msgstr "Mostrando"
 
-#: UI/GTK2/src/mainWindow.cc:816
+#: UI/GTK2/src/mainWindow.cc:817
 msgid "off"
 msgstr "desactivado"
 
-#: UI/GTK2/src/mainWindow.cc:821
+#: UI/GTK2/src/mainWindow.cc:822
 msgid "documents, starting at"
 msgstr "documentos comenzando en"
 
-#: UI/GTK2/src/mainWindow.cc:855
+#: UI/GTK2/src/mainWindow.cc:856
 msgid "Query"
 msgstr "B?squeda"
 
-#: UI/GTK2/src/mainWindow.cc:859 UI/GTK2/src/mainWindow.cc:2699
+#: UI/GTK2/src/mainWindow.cc:860 UI/GTK2/src/mainWindow.cc:2711
 msgid "on"
 msgstr "en"
 
-#: UI/GTK2/src/mainWindow.cc:863
+#: UI/GTK2/src/mainWindow.cc:864
 msgid "ended"
 msgstr "finalizado"
 
-#: UI/GTK2/src/mainWindow.cc:941
+#: UI/GTK2/src/mainWindow.cc:942
 msgid "Updated label(s)"
 msgstr "Etiqueta(s) actualizada(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1019 UI/GTK2/src/mainWindow.cc:1128
+#: UI/GTK2/src/mainWindow.cc:1020 UI/GTK2/src/mainWindow.cc:1132
 msgid "Updated document"
 msgstr "Documento actualizado"
 
-#: UI/GTK2/src/mainWindow.cc:1034
+#: UI/GTK2/src/mainWindow.cc:1035
 msgid "Indexed"
 msgstr "Indizado"
 
-#: UI/GTK2/src/mainWindow.cc:1083
+#: UI/GTK2/src/mainWindow.cc:1087
 msgid "Unindexed document(s)"
 msgstr "Documento(s) no indizado(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1175
+#: UI/GTK2/src/mainWindow.cc:1179
 msgid "Couldn't rename index, name"
 msgstr "No se pudo renombrar ?ndice, nombre"
 
-#: UI/GTK2/src/mainWindow.cc:1179 UI/GTK2/src/mainWindow.cc:2036
-#: UI/GTK2/src/mainWindow.cc:2533
+#: UI/GTK2/src/mainWindow.cc:1183 UI/GTK2/src/mainWindow.cc:2048
+#: UI/GTK2/src/mainWindow.cc:2545
 msgid "is already in use"
 msgstr "ya est? en uso"
 
-#: UI/GTK2/src/mainWindow.cc:1192
+#: UI/GTK2/src/mainWindow.cc:1196
 msgid "Couldn't rename index"
 msgstr "No se pudo renombrar el ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:1205
+#: UI/GTK2/src/mainWindow.cc:1209
 msgid "Edited index"
 msgstr "?ndice editado"
 
-#: UI/GTK2/src/mainWindow.cc:1637 UI/GTK2/src/mainWindow.cc:1740
+#: UI/GTK2/src/mainWindow.cc:1650 UI/GTK2/src/mainWindow.cc:1752
 msgid "Please set a location for the index first"
 msgstr "Por favor, primero fije una localizaci?n para el ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:1664
+#: UI/GTK2/src/mainWindow.cc:1677
 msgid "Result location is unknown"
 msgstr "Se desconoce la localizaci?n del resultado"
 
-#: UI/GTK2/src/mainWindow.cc:1688
+#: UI/GTK2/src/mainWindow.cc:1701
 msgid "Import Document(s)"
 msgstr "Importar Documento(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1818 UI/GTK2/src/WorkerThreads.cpp:392
-#: UI/GTK2/src/WorkerThreads.cpp:1114
+#: UI/GTK2/src/mainWindow.cc:1830 UI/GTK2/src/WorkerThreads.cpp:390
+#: UI/GTK2/src/WorkerThreads.cpp:1112
 msgid "Index"
 msgstr "?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:1822 UI/GTK2/src/WorkerThreads.cpp:396
-#: UI/GTK2/src/WorkerThreads.cpp:1118
+#: UI/GTK2/src/mainWindow.cc:1834 UI/GTK2/src/WorkerThreads.cpp:394
+#: UI/GTK2/src/WorkerThreads.cpp:1116
 msgid "doesn't exist"
 msgstr "no existe"
 
-#: UI/GTK2/src/mainWindow.cc:1916
+#: UI/GTK2/src/mainWindow.cc:1928
 msgid "Delete this document from the index ?"
 msgstr "?Borrar este documento del ?ndice?"
 
-#: UI/GTK2/src/mainWindow.cc:1935
+#: UI/GTK2/src/mainWindow.cc:1947
 msgid "Delete these documents from the index ?"
 msgstr "?Borrar este documento del ?ndice?"
 
-#: UI/GTK2/src/mainWindow.cc:1987
+#: UI/GTK2/src/mainWindow.cc:1999
 msgid "A metasearch tool for the Free Desktop"
 msgstr "Una herramienta metabuscador para el escritorio libre"
 
-#: UI/GTK2/src/mainWindow.cc:1988
+#: UI/GTK2/src/mainWindow.cc:2000
 msgid "(C) 2005-2006 Fabrice Colin"
 msgstr "(C) 2005-2006 Fabrice Colin"
 
-#: UI/GTK2/src/mainWindow.cc:2032
+#: UI/GTK2/src/mainWindow.cc:2044
 msgid "Index name"
 msgstr "Nombre del ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:2047
+#: UI/GTK2/src/mainWindow.cc:2059
 msgid "Couldn't add index"
 msgstr "No se pudo a?adir el ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:2061
+#: UI/GTK2/src/mainWindow.cc:2073
 msgid "Added new index"
 msgstr "A?adido un nuevo ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:2096
+#: UI/GTK2/src/mainWindow.cc:2108
 msgid "Couldn't remove index"
 msgstr "No se pudo borrar el ?ndice"
 
-#: UI/GTK2/src/mainWindow.cc:2191
+#: UI/GTK2/src/mainWindow.cc:2203
 msgid "Live query"
 msgstr "B?squeda activa"
 
-#: UI/GTK2/src/mainWindow.cc:2348
+#: UI/GTK2/src/mainWindow.cc:2360
 msgid "At least one task hasn't completed yet. Quit now ?"
 msgstr "Al menos una tarea no ha finalizado. ?Parar ahora?"
 
-#: UI/GTK2/src/mainWindow.cc:2529
+#: UI/GTK2/src/mainWindow.cc:2541
 msgid "Query name"
 msgstr "Nombre la b?squeda"
 
-#: UI/GTK2/src/mainWindow.cc:2556
+#: UI/GTK2/src/mainWindow.cc:2568
 msgid "Couldn't update query"
 msgstr "No se pudo actualizar la b?squeda"
 
-#: UI/GTK2/src/mainWindow.cc:2564
+#: UI/GTK2/src/mainWindow.cc:2576
 msgid "Edited query"
 msgstr "B?squeda editada"
 
-#: UI/GTK2/src/mainWindow.cc:2571
+#: UI/GTK2/src/mainWindow.cc:2583
 msgid "Couldn't add query"
 msgstr "No se pudo a?adir la b?squeda"
 
-#: UI/GTK2/src/mainWindow.cc:2579
+#: UI/GTK2/src/mainWindow.cc:2591
 msgid "Added new query"
 msgstr "A?adida una nueva b?squeda"
 
-#: UI/GTK2/src/mainWindow.cc:2593
+#: UI/GTK2/src/mainWindow.cc:2605
 msgid "Query is not set"
 msgstr "B?squeda no definida"
 
-#: UI/GTK2/src/mainWindow.cc:2604
+#: UI/GTK2/src/mainWindow.cc:2616
 msgid "No search engine selected"
 msgstr "Motor de b?squeda no seleccionado"
 
-#: UI/GTK2/src/mainWindow.cc:2686
+#: UI/GTK2/src/mainWindow.cc:2698
 msgid "Please set the Google API key first"
 msgstr "Por favor, primero configure el API de Google"
 
-#: UI/GTK2/src/mainWindow.cc:2695
+#: UI/GTK2/src/mainWindow.cc:2707
 msgid "Running query"
 msgstr "Ejecutando la b?squeda"
 
-#: UI/GTK2/src/mainWindow.cc:2802
+#: UI/GTK2/src/mainWindow.cc:2814
 msgid "is already indexed or is being indexed"
 msgstr "ya ha sido indizado, o se est? indizando"
 
-#: UI/GTK2/src/mainWindow.cc:2829
+#: UI/GTK2/src/mainWindow.cc:2841
 msgid "No URL to browse"
 msgstr "No hay URL que mostrar"
 
-#: UI/GTK2/src/mainWindow.cc:2840
+#: UI/GTK2/src/mainWindow.cc:2852
 msgid "No browser configured to view results"
 msgstr "No ha configurado un navegador para ver los resultados"
 
-#: UI/GTK2/src/mainWindow.cc:2852
+#: UI/GTK2/src/mainWindow.cc:2864
 msgid "Couldn't browse URL:"
 msgstr "No se pudo mostrar el URL:"
 
-#: UI/GTK2/src/mainWindow.cc:2911
+#: UI/GTK2/src/mainWindow.cc:2923
 msgid "Viewing"
 msgstr "Ver"
 
@@ -427,7 +427,6 @@
 
 #: UI/GTK2/src/mainWindow_glade.cc:216
 #: UI/GTK2/src/propertiesDialog_glade.cc:171
-#: UI/GTK2/src/queryDialog_glade.cc:83
 msgid "Properties"
 msgstr "Propiedades"
 
@@ -539,35 +538,35 @@
 msgid "Couldn't parse configuration file"
 msgstr "No se pudo procesar el fichero de configuraci?n"
 
-#: UI/GTK2/src/PinotSettings.cpp:752
+#: UI/GTK2/src/PinotSettings.cpp:754
 msgid "Unclassified"
 msgstr "No clasificado"
 
-#: UI/GTK2/src/prefsDialog.cc:73
+#: UI/GTK2/src/prefsDialog.cc:74
 msgid "Name"
 msgstr "Nombre"
 
-#: UI/GTK2/src/prefsDialog.cc:81
+#: UI/GTK2/src/prefsDialog.cc:82
 msgid "Location"
 msgstr "Localizaci?n"
 
-#: UI/GTK2/src/prefsDialog.cc:118
+#: UI/GTK2/src/prefsDialog.cc:119
 msgid "In internal viewer"
 msgstr "En el visor interno"
 
-#: UI/GTK2/src/prefsDialog.cc:121
+#: UI/GTK2/src/prefsDialog.cc:122
 msgid "In browser"
 msgstr "En el navegador"
 
-#: UI/GTK2/src/prefsDialog.cc:329
+#: UI/GTK2/src/prefsDialog.cc:324
 msgid "Browser location"
 msgstr "Mostrar la localizaci?n"
 
-#: UI/GTK2/src/prefsDialog.cc:340
+#: UI/GTK2/src/prefsDialog.cc:335
 msgid "New Label"
 msgstr "Nueva etiqueta"
 
-#: UI/GTK2/src/prefsDialog.cc:392 UI/GTK2/src/prefsDialog.cc:426
+#: UI/GTK2/src/prefsDialog.cc:387 UI/GTK2/src/prefsDialog.cc:424
 msgid "Mbox File Location"
 msgstr "Localizaci?n del fichero mbox"
 
@@ -679,6 +678,10 @@
 msgid "None of the words:"
 msgstr "Ninguna de las palabras:"
 
+#: UI/GTK2/src/queryDialog_glade.cc:83
+msgid "All engines"
+msgstr "Todos los motores"
+
 #: UI/GTK2/src/queryDialog_glade.cc:84
 msgid "Limit to documents that match"
 msgstr "Limitar a los documentos que coincidan"
@@ -700,115 +703,118 @@
 msgstr "la etiqueta"
 
 #: UI/GTK2/src/queryDialog_glade.cc:98
-msgid "Advanced"
-msgstr "Avanzado"
+msgid "Indexes only"
+msgstr "S?lo ?ndices"
 
 #: UI/GTK2/src/queryDialog_glade.cc:283
-msgid "Query properties"
-msgstr "Propriedades de la b?squeda"
+msgid "Query parameters"
+msgstr "Par?metros de b?squeda"
 
-#: UI/GTK2/src/WorkerThreads.cpp:371
+#: UI/GTK2/src/WorkerThreads.cpp:369
 msgid "Stopped browsing"
 msgstr "Exploraci?n detenida"
 
-#: UI/GTK2/src/WorkerThreads.cpp:404 UI/GTK2/src/WorkerThreads.cpp:602
-#: UI/GTK2/src/WorkerThreads.cpp:611 UI/GTK2/src/WorkerThreads.cpp:800
-#: UI/GTK2/src/WorkerThreads.cpp:1007 UI/GTK2/src/WorkerThreads.cpp:1126
+#: UI/GTK2/src/WorkerThreads.cpp:402 UI/GTK2/src/WorkerThreads.cpp:600
+#: UI/GTK2/src/WorkerThreads.cpp:609 UI/GTK2/src/WorkerThreads.cpp:799
+#: UI/GTK2/src/WorkerThreads.cpp:1005 UI/GTK2/src/WorkerThreads.cpp:1124
 msgid "Index error on"
 msgstr "Error en el ?ndice"
 
-#: UI/GTK2/src/WorkerThreads.cpp:509
+#: UI/GTK2/src/WorkerThreads.cpp:507
 msgid "Stopped querying"
 msgstr "B?squeda detenida"
 
-#: UI/GTK2/src/WorkerThreads.cpp:521
+#: UI/GTK2/src/WorkerThreads.cpp:519
 msgid "Couldn't create search engine"
 msgstr "No se pudo crear el motor de b?squeda"
 
-#: UI/GTK2/src/WorkerThreads.cpp:532
+#: UI/GTK2/src/WorkerThreads.cpp:530
 msgid "Couldn't run query on search engine"
 msgstr "No se pudo ejecutar la b?squeda contra el motor"
 
-#: UI/GTK2/src/WorkerThreads.cpp:548
+#: UI/GTK2/src/WorkerThreads.cpp:546
 msgid "No title"
 msgstr "Sin t?tulo"
 
-#: UI/GTK2/src/WorkerThreads.cpp:593
+#: UI/GTK2/src/WorkerThreads.cpp:591
 msgid "Stopped querying index labels"
 msgstr "Detenida la b?squeda de etiquetas de ?ndice"
 
-#: UI/GTK2/src/WorkerThreads.cpp:670
+#: UI/GTK2/src/WorkerThreads.cpp:668
 msgid "Stopped retrieval of"
 msgstr "Detenida la recuperaci?n de"
 
-#: UI/GTK2/src/WorkerThreads.cpp:704
+#: UI/GTK2/src/WorkerThreads.cpp:702
 msgid "Couldn't obtain downloader for protocol"
 msgstr "No se pudo usar un recuperador para el protocolo"
 
-#: UI/GTK2/src/WorkerThreads.cpp:718 UI/GTK2/src/WorkerThreads.cpp:813
+#: UI/GTK2/src/WorkerThreads.cpp:716 UI/GTK2/src/WorkerThreads.cpp:812
 msgid "Couldn't retrieve"
 msgstr "No se pudo descargar"
 
-#: UI/GTK2/src/WorkerThreads.cpp:785
+#: UI/GTK2/src/WorkerThreads.cpp:784
 msgid "Stopped indexing"
 msgstr "Detenida la indizaci?n"
 
-#: UI/GTK2/src/WorkerThreads.cpp:837
+#: UI/GTK2/src/WorkerThreads.cpp:835
 msgid "Cannot index document type"
 msgstr "No se pudo indizar el tipo de documento"
 
-#: UI/GTK2/src/WorkerThreads.cpp:841
+#: UI/GTK2/src/WorkerThreads.cpp:839
 msgid "at"
 msgstr "a"
 
-#: UI/GTK2/src/WorkerThreads.cpp:865
+#: UI/GTK2/src/WorkerThreads.cpp:863
 msgid "Couldn't tokenize"
 msgstr "No se pudo extraer cadenas"
 
-#: UI/GTK2/src/WorkerThreads.cpp:885
+#: UI/GTK2/src/WorkerThreads.cpp:883
 msgid "Robots META tag forbids indexing"
 msgstr "La etiqueta META Robots proh?be la indizaci?n"
 
-#: UI/GTK2/src/WorkerThreads.cpp:940
+#: UI/GTK2/src/WorkerThreads.cpp:938
 msgid "Couldn't index"
 msgstr "No se pudo indizar"
 
-#: UI/GTK2/src/WorkerThreads.cpp:995
+#: UI/GTK2/src/WorkerThreads.cpp:993
 msgid "Stopped unindexing document(s)"
 msgstr "Detenida la des-indizaci?n de documento(s)"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1014
+#: UI/GTK2/src/WorkerThreads.cpp:1012
 msgid "Couldn't unindex document(s)"
 msgstr "No se pudo des-indizar lo(s) documento(s)"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1099
+#: UI/GTK2/src/WorkerThreads.cpp:1097
 msgid "Stopped document update for"
 msgstr "Detenida la actualizaci?n del documento por"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1134
+#: UI/GTK2/src/WorkerThreads.cpp:1132
 msgid "Couldn't update document"
 msgstr "No se pudo actualizar el documento"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1184
+#: UI/GTK2/src/WorkerThreads.cpp:1182
 msgid "Stopped monitoring"
 msgstr "Detenida la monitorizaci?n"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1205
+#: UI/GTK2/src/WorkerThreads.cpp:1202
 msgid "No monitoring handler"
 msgstr "No hay monitorizaci?n"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1248
+#: UI/GTK2/src/WorkerThreads.cpp:1245
 msgid "Couldn't open FAM connection"
 msgstr "No se pudo abrir la conexi?n FAM"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1451
+#: UI/GTK2/src/WorkerThreads.cpp:1448
 msgid "Stopped scanning"
 msgstr "Detenida la exploraci?n"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1609
+#: UI/GTK2/src/WorkerThreads.cpp:1606
 msgid "Couldn't open directory"
 msgstr "No se pudo abrir el directorio"
 
+#~ msgid "Advanced"
+#~ msgstr "Avanzado"
+
 #~ msgid "Couldn't load ui block"
 #~ msgstr "No se pudo cargar el bloque ui"
 

Modified: trunk/po/fr.po
===================================================================
--- trunk/po/fr.po	2006-04-18 14:08:07 UTC (rev 221)
+++ trunk/po/fr.po	2006-04-21 11:21:53 UTC (rev 222)
@@ -8,7 +8,7 @@
 msgstr ""
 "Project-Id-Version: pinot 0.43\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2006-03-25 12:40+0800\n"
+"POT-Creation-Date: 2006-04-18 23:23+0800\n"
 "PO-Revision-Date: 2006-01-20 19:44+0800\n"
 "Last-Translator: Fabrice Colin <colinf at chez.com>\n"
 "Language-Team: fr <colinf at chez.com>\n"
@@ -24,19 +24,19 @@
 msgid "Current User"
 msgstr "Utilisateur"
 
-#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:371
-#: UI/GTK2/src/mainWindow.cc:374 UI/GTK2/src/mainWindow.cc:544
-#: UI/GTK2/src/mainWindow.cc:1009 UI/GTK2/src/mainWindow.cc:1063
-#: UI/GTK2/src/mainWindow.cc:1082 UI/GTK2/src/mainWindow.cc:1117
-#: UI/GTK2/src/mainWindow.cc:1698 UI/GTK2/src/PinotSettings.cpp:201
-#: UI/GTK2/src/PinotSettings.cpp:909 UI/GTK2/src/PinotSettings.cpp:965
+#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:372
+#: UI/GTK2/src/mainWindow.cc:375 UI/GTK2/src/mainWindow.cc:545
+#: UI/GTK2/src/mainWindow.cc:1010 UI/GTK2/src/mainWindow.cc:1066
+#: UI/GTK2/src/mainWindow.cc:1086 UI/GTK2/src/mainWindow.cc:1121
+#: UI/GTK2/src/mainWindow.cc:1711 UI/GTK2/src/PinotSettings.cpp:201
+#: UI/GTK2/src/PinotSettings.cpp:911 UI/GTK2/src/PinotSettings.cpp:967
 msgid "My Documents"
 msgstr "Mes Documents"
 
-#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:377
-#: UI/GTK2/src/mainWindow.cc:380 UI/GTK2/src/mainWindow.cc:548
+#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:378
+#: UI/GTK2/src/mainWindow.cc:381 UI/GTK2/src/mainWindow.cc:549
 #: UI/GTK2/src/MonitorHandler.cpp:173 UI/GTK2/src/PinotSettings.cpp:202
-#: UI/GTK2/src/PinotSettings.cpp:910 UI/GTK2/src/PinotSettings.cpp:966
+#: UI/GTK2/src/PinotSettings.cpp:912 UI/GTK2/src/PinotSettings.cpp:968
 #: UI/GTK2/src/prefsDialog_glade.cc:115
 msgid "My Email"
 msgstr "Mon Courrier"
@@ -45,7 +45,7 @@
 msgid "Enabled"
 msgstr "Active"
 
-#: UI/GTK2/src/importDialog.cc:109 UI/GTK2/src/prefsDialog.cc:82
+#: UI/GTK2/src/importDialog.cc:109 UI/GTK2/src/prefsDialog.cc:83
 msgid "MIME Type"
 msgstr "Type MIME"
 
@@ -66,7 +66,7 @@
 msgid "None"
 msgstr "Aucune"
 
-#: UI/GTK2/src/importDialog.cc:445
+#: UI/GTK2/src/importDialog.cc:446
 msgid "Document To Import"
 msgstr "Document A Importer"
 
@@ -160,212 +160,212 @@
 msgid "Summary"
 msgstr "Sommaire"
 
-#: UI/GTK2/src/mainWindow.cc:245
+#: UI/GTK2/src/mainWindow.cc:246
 msgid "Add index"
 msgstr "Ajouter un index"
 
-#: UI/GTK2/src/mainWindow.cc:246
+#: UI/GTK2/src/mainWindow.cc:247
 msgid "Remove index"
 msgstr "Enlever un index"
 
-#: UI/GTK2/src/mainWindow.cc:262
+#: UI/GTK2/src/mainWindow.cc:263
 msgid "Ready"
 msgstr "Pret"
 
-#: UI/GTK2/src/mainWindow.cc:276 UI/GTK2/src/mainWindow.cc:966
-#: UI/GTK2/src/mainWindow.cc:1291 UI/GTK2/src/mainWindow.cc:2871
+#: UI/GTK2/src/mainWindow.cc:277 UI/GTK2/src/mainWindow.cc:967
+#: UI/GTK2/src/mainWindow.cc:1304 UI/GTK2/src/mainWindow.cc:2883
 #: UI/GTK2/src/mainWindow_glade.cc:207
 msgid "View"
 msgstr "Voir"
 
-#: UI/GTK2/src/mainWindow.cc:308
+#: UI/GTK2/src/mainWindow.cc:309
 msgid "N/A"
 msgstr "Inconnue"
 
-#: UI/GTK2/src/mainWindow.cc:318
+#: UI/GTK2/src/mainWindow.cc:319
 msgid "<undefined>"
 msgstr "<inconnu>"
 
-#: UI/GTK2/src/mainWindow.cc:506
+#: UI/GTK2/src/mainWindow.cc:507
 msgid "Result location is"
 msgstr "Le chemin du resultat est"
 
-#: UI/GTK2/src/mainWindow.cc:559
+#: UI/GTK2/src/mainWindow.cc:560
 msgid "Document location is"
 msgstr "Le chemin du document is"
 
-#: UI/GTK2/src/mainWindow.cc:811
+#: UI/GTK2/src/mainWindow.cc:812
 msgid "Showing"
 msgstr "Listant"
 
-#: UI/GTK2/src/mainWindow.cc:816
+#: UI/GTK2/src/mainWindow.cc:817
 msgid "off"
 msgstr "documents,"
 
-#: UI/GTK2/src/mainWindow.cc:821
+#: UI/GTK2/src/mainWindow.cc:822
 msgid "documents, starting at"
 msgstr "au total, a partir de"
 
-#: UI/GTK2/src/mainWindow.cc:855
+#: UI/GTK2/src/mainWindow.cc:856
 msgid "Query"
 msgstr "La recherche"
 
-#: UI/GTK2/src/mainWindow.cc:859 UI/GTK2/src/mainWindow.cc:2699
+#: UI/GTK2/src/mainWindow.cc:860 UI/GTK2/src/mainWindow.cc:2711
 msgid "on"
 msgstr "sur"
 
-#: UI/GTK2/src/mainWindow.cc:863
+#: UI/GTK2/src/mainWindow.cc:864
 msgid "ended"
 msgstr "est terminee"
 
-#: UI/GTK2/src/mainWindow.cc:941
+#: UI/GTK2/src/mainWindow.cc:942
 msgid "Updated label(s)"
 msgstr "Mis a jour l(es) etiquette(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1019 UI/GTK2/src/mainWindow.cc:1128
+#: UI/GTK2/src/mainWindow.cc:1020 UI/GTK2/src/mainWindow.cc:1132
 msgid "Updated document"
 msgstr "Mis a jour le document"
 
-#: UI/GTK2/src/mainWindow.cc:1034
+#: UI/GTK2/src/mainWindow.cc:1035
 msgid "Indexed"
 msgstr "Indexe"
 
-#: UI/GTK2/src/mainWindow.cc:1083
+#: UI/GTK2/src/mainWindow.cc:1087
 msgid "Unindexed document(s)"
 msgstr "Desindexe le(s) document(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1175
+#: UI/GTK2/src/mainWindow.cc:1179
 msgid "Couldn't rename index, name"
 msgstr "N'a pas pu renommer l'index, le nom"
 
-#: UI/GTK2/src/mainWindow.cc:1179 UI/GTK2/src/mainWindow.cc:2036
-#: UI/GTK2/src/mainWindow.cc:2533
+#: UI/GTK2/src/mainWindow.cc:1183 UI/GTK2/src/mainWindow.cc:2048
+#: UI/GTK2/src/mainWindow.cc:2545
 msgid "is already in use"
 msgstr "est deja utilise"
 
-#: UI/GTK2/src/mainWindow.cc:1192
+#: UI/GTK2/src/mainWindow.cc:1196
 msgid "Couldn't rename index"
 msgstr "N'a pas pu renommer l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1205
+#: UI/GTK2/src/mainWindow.cc:1209
 msgid "Edited index"
 msgstr "Edite l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1637 UI/GTK2/src/mainWindow.cc:1740
+#: UI/GTK2/src/mainWindow.cc:1650 UI/GTK2/src/mainWindow.cc:1752
 msgid "Please set a location for the index first"
 msgstr "Donnez un chemin a l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1664
+#: UI/GTK2/src/mainWindow.cc:1677
 msgid "Result location is unknown"
 msgstr "Le chemin du resultat est inconnu"
 
-#: UI/GTK2/src/mainWindow.cc:1688
+#: UI/GTK2/src/mainWindow.cc:1701
 msgid "Import Document(s)"
 msgstr "Import de Document(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1818 UI/GTK2/src/WorkerThreads.cpp:392
-#: UI/GTK2/src/WorkerThreads.cpp:1114
+#: UI/GTK2/src/mainWindow.cc:1830 UI/GTK2/src/WorkerThreads.cpp:390
+#: UI/GTK2/src/WorkerThreads.cpp:1112
 msgid "Index"
 msgstr "L'index"
 
-#: UI/GTK2/src/mainWindow.cc:1822 UI/GTK2/src/WorkerThreads.cpp:396
-#: UI/GTK2/src/WorkerThreads.cpp:1118
+#: UI/GTK2/src/mainWindow.cc:1834 UI/GTK2/src/WorkerThreads.cpp:394
+#: UI/GTK2/src/WorkerThreads.cpp:1116
 msgid "doesn't exist"
 msgstr "n'existe pas"
 
-#: UI/GTK2/src/mainWindow.cc:1916
+#: UI/GTK2/src/mainWindow.cc:1928
 msgid "Delete this document from the index ?"
 msgstr "Enlever ce document de l'index ?"
 
-#: UI/GTK2/src/mainWindow.cc:1935
+#: UI/GTK2/src/mainWindow.cc:1947
 msgid "Delete these documents from the index ?"
 msgstr "Enlever ces documents de l'index ?"
 
-#: UI/GTK2/src/mainWindow.cc:1987
+#: UI/GTK2/src/mainWindow.cc:1999
 msgid "A metasearch tool for the Free Desktop"
 msgstr "Un outil de recherche pour le Bureau Libre"
 
-#: UI/GTK2/src/mainWindow.cc:1988
+#: UI/GTK2/src/mainWindow.cc:2000
 msgid "(C) 2005-2006 Fabrice Colin"
 msgstr "(C) 2005-2006 Fabrice Colin"
 
-#: UI/GTK2/src/mainWindow.cc:2032
+#: UI/GTK2/src/mainWindow.cc:2044
 msgid "Index name"
 msgstr "Nom de l'index"
 
-#: UI/GTK2/src/mainWindow.cc:2047
+#: UI/GTK2/src/mainWindow.cc:2059
 msgid "Couldn't add index"
 msgstr "N'a pas pu ajouter l'index"
 
-#: UI/GTK2/src/mainWindow.cc:2061
+#: UI/GTK2/src/mainWindow.cc:2073
 msgid "Added new index"
 msgstr "Ajoute un nouvel index"
 
-#: UI/GTK2/src/mainWindow.cc:2096
+#: UI/GTK2/src/mainWindow.cc:2108
 msgid "Couldn't remove index"
 msgstr "N'a pas pu enlever l'index"
 
-#: UI/GTK2/src/mainWindow.cc:2191
+#: UI/GTK2/src/mainWindow.cc:2203
 msgid "Live query"
 msgstr "Recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2348
+#: UI/GTK2/src/mainWindow.cc:2360
 msgid "At least one task hasn't completed yet. Quit now ?"
 msgstr "Au moins une tache n'est pas terminee. Quitter maintenant ?"
 
-#: UI/GTK2/src/mainWindow.cc:2529
+#: UI/GTK2/src/mainWindow.cc:2541
 msgid "Query name"
 msgstr "Nom de la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2556
+#: UI/GTK2/src/mainWindow.cc:2568
 msgid "Couldn't update query"
 msgstr "N'a pas pu mettre a jour la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2564
+#: UI/GTK2/src/mainWindow.cc:2576
 msgid "Edited query"
 msgstr "Edite la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2571
+#: UI/GTK2/src/mainWindow.cc:2583
 msgid "Couldn't add query"
 msgstr "N'a pas pu ajouter la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2579
+#: UI/GTK2/src/mainWindow.cc:2591
 msgid "Added new query"
 msgstr "Ajoute une nouvelle recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2593
+#: UI/GTK2/src/mainWindow.cc:2605
 msgid "Query is not set"
 msgstr "Recherche indefinie"
 
-#: UI/GTK2/src/mainWindow.cc:2604
+#: UI/GTK2/src/mainWindow.cc:2616
 msgid "No search engine selected"
 msgstr "Pas de moteur selectionne"
 
-#: UI/GTK2/src/mainWindow.cc:2686
+#: UI/GTK2/src/mainWindow.cc:2698
 msgid "Please set the Google API key first"
 msgstr "Configurez la clef de l'API Google "
 
-#: UI/GTK2/src/mainWindow.cc:2695
+#: UI/GTK2/src/mainWindow.cc:2707
 msgid "Running query"
 msgstr "Recherche en cours"
 
-#: UI/GTK2/src/mainWindow.cc:2802
+#: UI/GTK2/src/mainWindow.cc:2814
 msgid "is already indexed or is being indexed"
 msgstr "est deja indexe ou est en cours d'indexation"
 
-#: UI/GTK2/src/mainWindow.cc:2829
+#: UI/GTK2/src/mainWindow.cc:2841
 msgid "No URL to browse"
 msgstr "Pas d'URL a brouter"
 
-#: UI/GTK2/src/mainWindow.cc:2840
+#: UI/GTK2/src/mainWindow.cc:2852
 msgid "No browser configured to view results"
 msgstr "Pas de brouter configure"
 
-#: UI/GTK2/src/mainWindow.cc:2852
+#: UI/GTK2/src/mainWindow.cc:2864
 msgid "Couldn't browse URL:"
 msgstr "N'a pas pu brouter l'URL"
 
-#: UI/GTK2/src/mainWindow.cc:2911
+#: UI/GTK2/src/mainWindow.cc:2923
 msgid "Viewing"
 msgstr "Voir"
 
@@ -427,7 +427,6 @@
 
 #: UI/GTK2/src/mainWindow_glade.cc:216
 #: UI/GTK2/src/propertiesDialog_glade.cc:171
-#: UI/GTK2/src/queryDialog_glade.cc:83
 msgid "Properties"
 msgstr "Proprietes"
 
@@ -539,35 +538,35 @@
 msgid "Couldn't parse configuration file"
 msgstr "N'a pas pu lire le fichier de configuration"
 
-#: UI/GTK2/src/PinotSettings.cpp:752
+#: UI/GTK2/src/PinotSettings.cpp:754
 msgid "Unclassified"
 msgstr "Sans classification"
 
-#: UI/GTK2/src/prefsDialog.cc:73
+#: UI/GTK2/src/prefsDialog.cc:74
 msgid "Name"
 msgstr "Nom"
 
-#: UI/GTK2/src/prefsDialog.cc:81
+#: UI/GTK2/src/prefsDialog.cc:82
 msgid "Location"
 msgstr "Chemin"
 
-#: UI/GTK2/src/prefsDialog.cc:118
+#: UI/GTK2/src/prefsDialog.cc:119
 msgid "In internal viewer"
 msgstr "Dans le brouteur interne"
 
-#: UI/GTK2/src/prefsDialog.cc:121
+#: UI/GTK2/src/prefsDialog.cc:122
 msgid "In browser"
 msgstr "Dans le brouteur"
 
-#: UI/GTK2/src/prefsDialog.cc:329
+#: UI/GTK2/src/prefsDialog.cc:324
 msgid "Browser location"
 msgstr "Chemin du brouteur"
 
-#: UI/GTK2/src/prefsDialog.cc:340
+#: UI/GTK2/src/prefsDialog.cc:335
 msgid "New Label"
 msgstr "Nouvelle Etiquette"
 
-#: UI/GTK2/src/prefsDialog.cc:392 UI/GTK2/src/prefsDialog.cc:426
+#: UI/GTK2/src/prefsDialog.cc:387 UI/GTK2/src/prefsDialog.cc:424
 msgid "Mbox File Location"
 msgstr "Chemin du Fichier mbox"
 
@@ -679,6 +678,10 @@
 msgid "None of the words:"
 msgstr "Aucun des mots:"
 
+#: UI/GTK2/src/queryDialog_glade.cc:83
+msgid "All engines"
+msgstr "Tous les moteurs"
+
 #: UI/GTK2/src/queryDialog_glade.cc:84
 msgid "Limit to documents that match"
 msgstr "Limiter aux documents qui ont"
@@ -700,129 +703,111 @@
 msgstr "l'etiquette"
 
 #: UI/GTK2/src/queryDialog_glade.cc:98
-msgid "Advanced"
-msgstr "Avance"
+msgid "Indexes only"
+msgstr "Indexes"
 
 #: UI/GTK2/src/queryDialog_glade.cc:283
-msgid "Query properties"
-msgstr "Proprietes de la recherche"
+msgid "Query parameters"
+msgstr "Parametres de la recherche"
 
-#: UI/GTK2/src/WorkerThreads.cpp:371
+#: UI/GTK2/src/WorkerThreads.cpp:369
 msgid "Stopped browsing"
 msgstr "Arrete de parcourir l'index"
 
-#: UI/GTK2/src/WorkerThreads.cpp:404 UI/GTK2/src/WorkerThreads.cpp:602
-#: UI/GTK2/src/WorkerThreads.cpp:611 UI/GTK2/src/WorkerThreads.cpp:800
-#: UI/GTK2/src/WorkerThreads.cpp:1007 UI/GTK2/src/WorkerThreads.cpp:1126
+#: UI/GTK2/src/WorkerThreads.cpp:402 UI/GTK2/src/WorkerThreads.cpp:600
+#: UI/GTK2/src/WorkerThreads.cpp:609 UI/GTK2/src/WorkerThreads.cpp:799
+#: UI/GTK2/src/WorkerThreads.cpp:1005 UI/GTK2/src/WorkerThreads.cpp:1124
 msgid "Index error on"
 msgstr "Erreur sur l'index"
 
-#: UI/GTK2/src/WorkerThreads.cpp:509
+#: UI/GTK2/src/WorkerThreads.cpp:507
 msgid "Stopped querying"
 msgstr "Arrete la recherche"
 
-#: UI/GTK2/src/WorkerThreads.cpp:521
+#: UI/GTK2/src/WorkerThreads.cpp:519
 msgid "Couldn't create search engine"
 msgstr "N'a pas pu creer le moteur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:532
+#: UI/GTK2/src/WorkerThreads.cpp:530
 msgid "Couldn't run query on search engine"
 msgstr "N'a pas pu lancer la recherche sur le moteur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:548
+#: UI/GTK2/src/WorkerThreads.cpp:546
 msgid "No title"
 msgstr "Pas de titre"
 
-#: UI/GTK2/src/WorkerThreads.cpp:593
+#: UI/GTK2/src/WorkerThreads.cpp:591
 msgid "Stopped querying index labels"
 msgstr "Arrete la recherche d'etiquettes"
 
-#: UI/GTK2/src/WorkerThreads.cpp:670
+#: UI/GTK2/src/WorkerThreads.cpp:668
 msgid "Stopped retrieval of"
 msgstr "Arrete le telechargement de"
 
-#: UI/GTK2/src/WorkerThreads.cpp:704
+#: UI/GTK2/src/WorkerThreads.cpp:702
 msgid "Couldn't obtain downloader for protocol"
 msgstr "N'a pas pu obtenir un brouteur pour"
 
-#: UI/GTK2/src/WorkerThreads.cpp:718 UI/GTK2/src/WorkerThreads.cpp:813
+#: UI/GTK2/src/WorkerThreads.cpp:716 UI/GTK2/src/WorkerThreads.cpp:812
 msgid "Couldn't retrieve"
 msgstr "N'a pas pu telecharger"
 
-#: UI/GTK2/src/WorkerThreads.cpp:785
+#: UI/GTK2/src/WorkerThreads.cpp:784
 msgid "Stopped indexing"
 msgstr "Arrete l'indexation"
 
-#: UI/GTK2/src/WorkerThreads.cpp:837
+#: UI/GTK2/src/WorkerThreads.cpp:835
 msgid "Cannot index document type"
 msgstr "Impossible d'indexer ce type de documents"
 
-#: UI/GTK2/src/WorkerThreads.cpp:841
+#: UI/GTK2/src/WorkerThreads.cpp:839
 msgid "at"
 msgstr "a"
 
-#: UI/GTK2/src/WorkerThreads.cpp:865
+#: UI/GTK2/src/WorkerThreads.cpp:863
 msgid "Couldn't tokenize"
 msgstr "N'a pas pu extraire les termes de"
 
-#: UI/GTK2/src/WorkerThreads.cpp:885
+#: UI/GTK2/src/WorkerThreads.cpp:883
 msgid "Robots META tag forbids indexing"
 msgstr "Le META tag Robots interdit d'indexer"
 
-#: UI/GTK2/src/WorkerThreads.cpp:940
+#: UI/GTK2/src/WorkerThreads.cpp:938
 msgid "Couldn't index"
 msgstr "N'a pas pu indexer"
 
-#: UI/GTK2/src/WorkerThreads.cpp:995
+#: UI/GTK2/src/WorkerThreads.cpp:993
 msgid "Stopped unindexing document(s)"
 msgstr "Arrete d'indexer les document(s)"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1014
+#: UI/GTK2/src/WorkerThreads.cpp:1012
 msgid "Couldn't unindex document(s)"
 msgstr "N'a pas pu desindexer le(s) document(s)"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1099
+#: UI/GTK2/src/WorkerThreads.cpp:1097
 msgid "Stopped document update for"
 msgstr "Arrete la mise a jour pour"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1134
+#: UI/GTK2/src/WorkerThreads.cpp:1132
 msgid "Couldn't update document"
 msgstr "N'a pas pu mettre a jour le document"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1184
+#: UI/GTK2/src/WorkerThreads.cpp:1182
 msgid "Stopped monitoring"
 msgstr "Arrete la surveillance"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1205
+#: UI/GTK2/src/WorkerThreads.cpp:1202
 msgid "No monitoring handler"
 msgstr "Pas de moniteur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1248
+#: UI/GTK2/src/WorkerThreads.cpp:1245
 msgid "Couldn't open FAM connection"
 msgstr "N'a pas pu ouvrir la connection FAM"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1451
+#: UI/GTK2/src/WorkerThreads.cpp:1448
 msgid "Stopped scanning"
 msgstr "Arrete de scanner"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1609
+#: UI/GTK2/src/WorkerThreads.cpp:1606
 msgid "Couldn't open directory"
 msgstr "N'a pas pu ouvrir le repertoire"
-
-#~ msgid "Couldn't load ui block"
-#~ msgstr "N'a pas pu charger le bloc ui"
-
-#~ msgid "Couldn't load extraindex block"
-#~ msgstr "N'a pas pu charger le bloc extraindex"
-
-#~ msgid "Couldn't load storedquery block"
-#~ msgstr "N'a pas pu charger le bloc storedquery"
-
-#~ msgid "Couldn't load results block"
-#~ msgstr "N'a pas pu charger le bloc results"
-
-#~ msgid "Couldn't load label block"
-#~ msgstr "N'a pas pu charger le bloc label"
-
-#~ msgid "Couldn't load mailaccount block"
-#~ msgstr "N'a pas pu charger le bloc mailaccount"



From fabricecolin at berlios.de  Fri Apr 21 13:24:04 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 21 Apr 2006 13:24:04 +0200
Subject: [Pinot-svn] r223 - trunk
Message-ID: <200604211124.k3LBO4h9010337@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-21 13:24:03 +0200 (Fri, 21 Apr 2006)
New Revision: 223

Modified:
   trunk/NEWS
   trunk/pinot.desktop
Log:
Internationalized desktop file. Updated news file.


Modified: trunk/NEWS
===================================================================
--- trunk/NEWS	2006-04-21 11:21:53 UTC (rev 222)
+++ trunk/NEWS	2006-04-21 11:24:03 UTC (rev 223)
@@ -1,18 +1,24 @@
-??? version_0_4_6
+2006/03/22 version_0_4_6
 Search :
- - resurrected support for the Google API, enabled with "./configure --with-soap=yes"
+ - resurrected support for the Google API, enabled with "./configure --with-soap=yes".
+  This requires the gsoap development toolkit.
  - tweaked extraction of results' extract and URL
  - renamed pinot_search to pinot-search
+ - (temporarily hopefully) removed MozDex plugin 
 Index :
  - changed URL hash algorithm for compatibility with omindex. Reindexing documents
   with URLs > 128 characters is necessary
 Tokenize :
  - new tokenizer for MP3, Vorbis and FLAC files that depend on the TagLib library
  - new XML tokenizer
- - new tokenizer for StarOffice and OpenDocument files (unzip required)
- - replaced libmagic with shared-mime-info (xdgmime) for better MIME type detection
+ - new tokenizer for OpenDocument/StarOffice files (unzip required)
+ - use xdgmime to query shared-mime-info for better MIME type detection
 HTML browser :
- - can build against Mozilla or Firefox, as set with "./configure --with-gecko=mozilla|firefox"
+ - can build against Mozilla or Firefox, set with "./configure --with-gecko=mozilla|firefox"
+UI :
+ - discovered and fixed pretty stupid bug that would cause a crash when indexing
+  search results while the My Documents tab isn't opened
+ - internationalized desktop file
 
 2006/03/25 version_0_4_5
 Build :

Modified: trunk/pinot.desktop
===================================================================
--- trunk/pinot.desktop	2006-04-21 11:21:53 UTC (rev 222)
+++ trunk/pinot.desktop	2006-04-21 11:24:03 UTC (rev 223)
@@ -1,6 +1,10 @@
 [Desktop Entry]
 Name=Pinot Metasearch Tool
+Name[es]=Metabuscador Pinot
+Name[fr]=Pinot Outil De Recherche
 Comment=Search the Web and your documents
+Comment[es]=Busca en el web y en sus documentos
+Comment[fr]=Cherche le Web et vos documents
 Exec=pinot
 StartupNotify=true
 Icon=pinot.png



From fabricecolin at berlios.de  Sat Apr 22 08:34:27 2006
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 22 Apr 2006 08:34:27 +0200
Subject: [Pinot-svn] r224 - tags
Message-ID: <200604220634.k3M6YR4U009115@sheep.berlios.de>

Author: fabricecolin
Date: 2006-04-22 08:34:23 +0200 (Sat, 22 Apr 2006)
New Revision: 224

Added:
   tags/version_0_4_6/
Log:
v0.46 release.


Copied: tags/version_0_4_6 (from rev 223, trunk)



