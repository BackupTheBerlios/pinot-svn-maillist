<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Pinot-svn] r371 - trunk/UI/GTK2/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/pinot-svn/2006-August/index.html" >
   <LINK REL="made" HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r371%20-%20trunk/UI/GTK2/src&In-Reply-To=%3C200608041215.k74CFDge027134%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000363.html">
   <LINK REL="Next"  HREF="000365.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Pinot-svn] r371 - trunk/UI/GTK2/src</H1>
    <B>fabricecolin at BerliOS</B> 
    <A HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r371%20-%20trunk/UI/GTK2/src&In-Reply-To=%3C200608041215.k74CFDge027134%40sheep.berlios.de%3E"
       TITLE="[Pinot-svn] r371 - trunk/UI/GTK2/src">fabricecolin at mail.berlios.de
       </A><BR>
    <I>Fri Aug  4 14:15:13 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000363.html">[Pinot-svn] r370 - trunk/UI/GTK2/src
</A></li>
        <LI>Next message: <A HREF="000365.html">[Pinot-svn] r372 - trunk/UI/GTK2/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#364">[ date ]</a>
              <a href="thread.html#364">[ thread ]</a>
              <a href="subject.html#364">[ subject ]</a>
              <a href="author.html#364">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fabricecolin
Date: 2006-08-04 14:14:57 +0200 (Fri, 04 Aug 2006)
New Revision: 371

Added:
   trunk/UI/GTK2/src/DaemonState.cpp
   trunk/UI/GTK2/src/DaemonState.h
   trunk/UI/GTK2/src/OnDiskHandler.cpp
   trunk/UI/GTK2/src/OnDiskHandler.h
Log:
New classes to help the daemon. DaemonState manages crawling and monitoring,
while OnDiskHandler handles events generated by MonitorThread.


Added: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2006-08-04 12:11:48 UTC (rev 370)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2006-08-04 12:14:57 UTC (rev 371)
@@ -0,0 +1,266 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+#include &lt;sigc++/class_slot.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;glibmm/stringutils.h&gt;
+#include &lt;glibmm/convert.h&gt;
+#include &lt;glibmm/thread.h&gt;
+
+#include &quot;DaemonState.h&quot;
+#include &quot;OnDiskHandler.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;WorkerThreads.h&quot;
+
+using namespace std;
+using namespace Glib;
+
+DaemonState::DaemonState() :
+	ThreadsManager(PinotSettings::getInstance().m_daemonIndexLocation, 10),
+	m_crawling(false)
+{
+	m_onThreadEndSignal.connect(SigC::slot(*this, &amp;DaemonState::on_thread_end));
+}
+
+DaemonState::~DaemonState()
+{
+}
+
+void DaemonState::start(void)
+{
+	string locationToCrawl;
+
+	for (set&lt;PinotSettings::TimestampedItem&gt;::const_iterator locationIter = PinotSettings::getInstance().m_indexableLocations.begin();
+		locationIter != PinotSettings::getInstance().m_indexableLocations.end(); ++locationIter)
+	{
+		bool crawledLocation = false;
+
+		// Has this directory been crawled before ?
+		if (locationIter-&gt;m_modTime &gt; 0)
+		{
+			// FIXME: recrawl once in a while ?
+			crawledLocation = true;
+		}
+
+		if (crawledLocation == false)
+		{
+			if (locationToCrawl.empty() == true)
+			{
+				locationToCrawl = locationIter-&gt;m_name;
+			}
+			else
+			{
+				// This will be crawled next
+				m_crawlQueue.push(locationIter-&gt;m_name);
+			}
+		}
+		else
+		{
+			m_monitoredLocations.insert(locationIter-&gt;m_name);
+		}
+	}
+
+	// ANything to crawl before starting monitoring ?
+	if (locationToCrawl.empty() == false)
+	{
+		// Scan the directory and import all its files
+		DirectoryScannerThread *pScannerThread = new DirectoryScannerThread(locationToCrawl,
+			0, true, &amp;m_scanMutex, &amp;m_scanCondVar);
+		pScannerThread-&gt;getFileFoundSignal().connect(SigC::slot(*this, &amp;DaemonState::on_message_filefound));
+
+		m_crawling = start_thread(pScannerThread);
+	}
+	else
+	{
+		// Fire up the disk monitor thread
+		OnDiskHandler *pDisk = new OnDiskHandler();
+		// Connect to its update signal
+		pDisk-&gt;getUpdateSignal().connect(
+			SigC::slot(*this, &amp;DaemonState::on_message_indexupdate));
+		MonitorThread *pMonitorThread = new MonitorThread(pDisk);
+		start_thread(pMonitorThread, true);
+		// The handler object will be deleted when the thread terminates
+	}
+}
+
+void DaemonState::signal_scanner(void)
+{
+	// Ask the scanner for another file
+	m_scanMutex.lock();
+	m_scanCondVar.signal();
+	m_scanMutex.unlock();
+}
+
+void DaemonState::on_thread_end(WorkerThread *pThread)
+{
+	if (pThread == NULL)
+	{
+		return;
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;DaemonState::on_thread_end: end of thread &quot; &lt;&lt; pThread-&gt;getId() &lt;&lt; endl;
+#endif
+
+	// What type of thread was it ?
+	string type(pThread-&gt;getType());
+	if (type == &quot;DirectoryScannerThread&quot;)
+	{
+		DirectoryScannerThread *pScannerThread = dynamic_cast&lt;DirectoryScannerThread *&gt;(pThread);
+		if (pScannerThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		DirectoryScannerThread *pNewScannerThread = NULL;
+
+		// Another location to crawl ?
+		if (write_lock_lists() == true)
+		{
+			if (m_crawlQueue.empty() == false)
+			{
+				string locationToCrawl(m_crawlQueue.front());
+
+				set&lt;PinotSettings::TimestampedItem&gt; &amp;indexableLocations = PinotSettings::getInstance().m_indexableLocations;
+				for (set&lt;PinotSettings::TimestampedItem&gt;::iterator locationIter = indexableLocations.begin();
+			                locationIter != indexableLocations.end(); ++locationIter)
+				{
+					if (locationIter-&gt;m_name == pScannerThread-&gt;getDirectory())
+					{
+						PinotSettings::TimestampedItem location(*locationIter);
+
+						// Set the timestamp
+						location.m_modTime = time(NULL);
+						indexableLocations.erase(locationIter);
+						indexableLocations.insert(location);
+
+						break;
+					}
+				}
+
+				pNewScannerThread = new DirectoryScannerThread(locationToCrawl,
+					0, true, &amp;m_scanMutex, &amp;m_scanCondVar);
+				pNewScannerThread-&gt;getFileFoundSignal().connect(SigC::slot(*this,
+					&amp;DaemonState::on_message_filefound));
+
+				m_crawlQueue.pop();
+			}
+			else
+			{
+				// Done with crawling
+				m_crawling = false;
+			}
+
+			unlock_lists();
+		}
+
+		// Start a new scanner thread ?
+		if (pNewScannerThread != NULL)
+		{
+			m_crawling = start_thread(pNewScannerThread);
+		}
+		else
+		{
+			// Now we can start monitoring
+			OnDiskHandler *pDisk = new OnDiskHandler();
+			// Connect to its update signal
+			pDisk-&gt;getUpdateSignal().connect(
+				SigC::slot(*this, &amp;DaemonState::on_message_indexupdate));
+			MonitorThread *pMonitorThread = new MonitorThread(pDisk);
+			start_thread(pMonitorThread, true);
+			// The handler object will be deleted when the thread terminates
+		}
+	}
+	else if (type == &quot;IndexingThread&quot;)
+	{
+		IndexingThread *pIndexThread = dynamic_cast&lt;IndexingThread *&gt;(pThread);
+		if (pIndexThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		// Did the thread perform an update ?
+		if (pIndexThread-&gt;isNewDocument() == true)
+		{
+			string url(pIndexThread-&gt;getURL());
+
+			// Update the in-progress list
+			if (write_lock_lists() == true)
+			{
+				set&lt;string&gt;::iterator urlIter = m_beingIndexed.find(url);
+				if (urlIter != m_beingIndexed.end())
+				{
+					m_beingIndexed.erase(urlIter);
+				}
+
+				unlock_lists();
+			}
+		}
+
+		// Get another file from the directory scanner if possible
+		if (m_crawling == true)
+		{
+			signal_scanner();
+		}
+	}
+	else if (type == &quot;UnindexingThread&quot;)
+	{
+		UnindexingThread *pUnindexThread = dynamic_cast&lt;UnindexingThread *&gt;(pThread);
+		if (pUnindexThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		// FIXME: anything to do ?
+	}
+	else if (type == &quot;MonitorThread&quot;)
+	{
+		// Fire up another disk monitor thread
+		OnDiskHandler *pDisk = new OnDiskHandler();
+		// Connect to its update signal
+		pDisk-&gt;getUpdateSignal().connect(
+			SigC::slot(*this, &amp;DaemonState::on_message_indexupdate));
+		MonitorThread *pMonitorThread = new MonitorThread(pDisk);
+		start_thread(pMonitorThread, true);
+		// The handler object will be deleted when the thread terminates
+	}
+
+	// Delete the thread
+	delete pThread;;
+
+	// We might be able to run a queued action
+	pop_queue();
+}
+
+void DaemonState::on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, string indexName)
+{
+	// FIXME: anything to do ?
+}
+
+bool DaemonState::on_message_filefound(const string &amp;location)
+{
+	DocumentInfo docInfo(location, location, &quot;&quot;, &quot;&quot;);
+
+	queue_index(docInfo);
+
+	// Don't request another file right now
+	return false;
+}
+

Added: trunk/UI/GTK2/src/DaemonState.h
===================================================================
--- trunk/UI/GTK2/src/DaemonState.h	2006-08-04 12:11:48 UTC (rev 370)
+++ trunk/UI/GTK2/src/DaemonState.h	2006-08-04 12:14:57 UTC (rev 371)
@@ -0,0 +1,53 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DBUSERVER_HH
+#define _DBUSERVER_HH
+
+#include &lt;string&gt;
+#include &lt;queue&gt;
+#include &lt;set&gt;
+#include &lt;glibmm/thread.h&gt;
+
+#include &quot;IndexedDocument.h&quot;
+#include &quot;WorkerThreads.h&quot;
+
+class DaemonState : public ThreadsManager
+{
+	public:
+		DaemonState();
+		virtual ~DaemonState();
+
+		void start(void);
+
+		void signal_scanner(void);
+
+		void on_thread_end(WorkerThread *pThread);
+
+		void on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, std::string indexName);
+
+		bool on_message_filefound(const std::string &amp;location);
+
+	protected:
+		std::queue&lt;std::string&gt; m_crawlQueue;
+		std::set&lt;std::string&gt; m_monitoredLocations;
+		bool m_crawling;
+		Glib::Mutex m_scanMutex;
+		Glib::Cond m_scanCondVar;
+
+};
+
+#endif

Added: trunk/UI/GTK2/src/OnDiskHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-04 12:11:48 UTC (rev 370)
+++ trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-04 12:14:57 UTC (rev 371)
@@ -0,0 +1,251 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;MIMEScanner.h&quot;
+#include &quot;StringManip.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;XapianDatabase.h&quot;
+#include &quot;TokenizerFactory.h&quot;
+#include &quot;FileCollector.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;OnDiskHandler.h&quot;
+
+using namespace std;
+using namespace SigC;
+
+OnDiskHandler::OnDiskHandler() :
+	MonitorHandler(),
+	m_index(PinotSettings::getInstance().m_daemonIndexLocation)
+{
+	m_index.setStemmingMode(WritableIndexInterface::STORE_BOTH);
+}
+
+OnDiskHandler::~OnDiskHandler()
+{
+}
+
+bool OnDiskHandler::indexFile(const string &amp;fileName, bool alwaysUpdate)
+{
+	string url(string(&quot;<A HREF="file://">file://</A>&quot;) + fileName);
+	Url urlObj(url);
+	set&lt;string&gt; labels;
+	bool indexedFile = false;
+
+	if ((m_index.isGood() == false) || 
+		(fileName.empty() == true))
+	{
+		return false;
+	}
+
+	// Has this file been indexed already ?
+	unsigned int docId = m_index.hasDocument(url);
+	if ((docId &gt; 0) &amp;&amp;
+		(alwaysUpdate == false))
+	{
+		// No need to update
+		return true;
+	}
+
+	DocumentInfo docInfo(url, url, MIMEScanner::scanUrl(urlObj), &quot;&quot;);
+
+	FileCollector fileCollector;
+	Document *pDoc = fileCollector.retrieveUrl(docInfo);
+	if (pDoc == NULL)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;OnDiskHandler::indexFile: couldn't download &quot; &lt;&lt; url &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	// Get an ad hoc tokenizer for the message
+	Tokenizer *pTokenizer = TokenizerFactory::getTokenizerByType(docInfo.getType(), pDoc);
+	if (pTokenizer == NULL)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;OnDiskHandler::indexFile: no tokenizer for type &quot; &lt;&lt; docInfo.getType() &lt;&lt; endl;
+#endif
+		delete pDoc;
+		return false;
+	}
+
+	// Index or update ?
+	if (docId == 0)
+	{
+		indexedFile = m_index.indexDocument(*pTokenizer, labels, docId);
+	}
+	else
+	{
+		indexedFile = m_index.updateDocument(docId, *pTokenizer);
+	}
+
+	if (indexedFile == true)
+	{
+		IndexedDocument indexedDocInfo(docInfo.getTitle(),
+			XapianDatabase::buildUrl(PinotSettings::getInstance().m_daemonIndexLocation, docId),
+			docInfo.getLocation(), docInfo.getType(), docInfo.getLanguage());
+
+		// Signal
+		m_signalUpdate(indexedDocInfo, docId, _(&quot;My Computer&quot;));
+	}
+#ifdef DEBUG
+	else cout &lt;&lt; &quot;OnDiskHandler::indexFile: couldn't index &quot; &lt;&lt; url &lt;&lt; endl;
+#endif
+
+	delete pTokenizer;
+	delete pDoc;
+
+	return indexedFile;
+}
+
+bool OnDiskHandler::getLocations(set&lt;string&gt; &amp;newLocations,
+	set&lt;string&gt; &amp;locationsToRemove)
+{
+	newLocations.clear();
+	locationsToRemove.clear();
+
+	// Take advantage of this call to flush the index
+	m_index.flush();
+
+	copy(m_locations.begin(), m_locations.end(),
+		inserter(locationsToRemove, locationsToRemove.begin()));
+
+	// Get the indexable locations map
+	set&lt;PinotSettings::TimestampedItem&gt; &amp;indexableLocations = PinotSettings::getInstance().m_indexableLocations;
+	for (set&lt;PinotSettings::TimestampedItem&gt;::iterator dirIter = indexableLocations.begin();
+		dirIter != indexableLocations.end(); ++dirIter)
+	{
+		// Is this a known location ?
+		set&lt;string&gt;::iterator locationIter = m_locations.find(dirIter-&gt;m_name);
+		if (locationIter == m_locations.end())
+		{
+			// No, it is new
+			m_locations.insert(dirIter-&gt;m_name);
+			newLocations.insert(dirIter-&gt;m_name);
+		}
+		else
+		{
+			// Since it's a known location, we'd better not remove it
+			set&lt;string&gt;::iterator removeIter = locationsToRemove.find(*locationIter);
+			if (removeIter != locationsToRemove.end())
+			{
+				locationsToRemove.erase(removeIter);
+			}
+		}
+	}
+
+	// Locations in locationsToRemove have to be removed
+	for (set&lt;string&gt;::iterator removeIter = locationsToRemove.begin();
+		removeIter != locationsToRemove.end(); ++removeIter)
+	{
+		set&lt;string&gt;::iterator locationIter = m_locations.find(*removeIter);
+		if (locationIter != m_locations.end())
+		{
+			m_locations.erase(locationIter);
+		}
+	}
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;OnDiskHandler::getLocations: &quot; &lt;&lt; m_locations.size() &lt;&lt; &quot; locations, &quot;
+		&lt;&lt; newLocations.size() &lt;&lt; &quot; new, &quot; &lt;&lt; locationsToRemove.size() &lt;&lt; &quot; to be removed&quot; &lt;&lt; endl;
+#endif
+
+	if ((newLocations.empty() == false) ||
+		(locationsToRemove.empty() == false))
+	{
+		return true;
+	}
+
+	return false;
+}
+
+bool OnDiskHandler::fileExists(const string &amp;fileName)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;OnDiskHandler::fileExists: &quot; &lt;&lt; fileName &lt;&lt; endl;
+#endif
+}
+
+bool OnDiskHandler::fileCreated(const string &amp;fileName)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;OnDiskHandler::fileCreated: &quot; &lt;&lt; fileName &lt;&lt; endl;
+#endif
+	// The file shouldn't exist in the index, but if it does for some reason, don't update it
+	return indexFile(fileName, false);
+}
+
+bool OnDiskHandler::fileModified(const string &amp;fileName)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;OnDiskHandler::fileModified: &quot; &lt;&lt; fileName &lt;&lt; endl;
+#endif
+	// Update the file, or index if necessary
+	return indexFile(fileName, true);
+}
+
+bool OnDiskHandler::fileMoved(const string &amp;fileName, const string &amp;previousFileName)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;OnDiskHandler::fileMoved: &quot; &lt;&lt; fileName &lt;&lt; endl;
+#endif
+	unsigned int oldDocId = m_index.hasDocument(string(&quot;<A HREF="file://">file://</A>&quot;) + previousFileName);
+	if (oldDocId &gt; 0)
+	{
+		DocumentInfo docInfo;
+
+		m_index.getDocumentInfo(oldDocId, docInfo);
+
+		// Has the destination file been indexed too ?
+		unsigned int docId = m_index.hasDocument(string(&quot;<A HREF="file://">file://</A>&quot;) + fileName);
+		if (docId &gt; 0)
+		{
+			// Unindex it
+			m_index.unindexDocument(docId);
+		}
+
+		// Change the location
+		docInfo.setLocation(string(&quot;<A HREF="file://">file://</A>&quot;) + fileName);
+		return m_index.updateDocumentInfo(oldDocId, docInfo);
+	}
+
+	return false; 
+}
+
+bool OnDiskHandler::fileDeleted(const string &amp;fileName)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;OnDiskHandler::fileDeleted: &quot; &lt;&lt; fileName &lt;&lt; endl;
+#endif
+	unsigned int docId = m_index.hasDocument(string(&quot;<A HREF="file://">file://</A>&quot;) + fileName);
+	if (docId &gt; 0)
+	{
+		// Unindex the file
+		return m_index.unindexDocument(docId);
+	}
+
+	return false;
+}
+

Added: trunk/UI/GTK2/src/OnDiskHandler.h
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-04 12:11:48 UTC (rev 370)
+++ trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-04 12:14:57 UTC (rev 371)
@@ -0,0 +1,69 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#ifndef _MBOXHANDLER_HH
+#define _MBOXHANDLER_HH
+
+#include &lt;time.h&gt;
+#include &lt;string&gt;
+#include &lt;set&gt;
+#include &lt;sigc++/slot.h&gt;
+
+#include &quot;IndexedDocument.h&quot;
+#include &quot;MboxParser.h&quot;
+#include &quot;WritableXapianIndex.h&quot;
+#include &quot;MonitorHandler.h&quot;
+#include &quot;PinotSettings.h&quot;
+
+class OnDiskHandler : public MonitorHandler
+{
+	public:
+		OnDiskHandler();
+		virtual ~OnDiskHandler();
+
+		/// Returns locations.
+		virtual bool getLocations(std::set&lt;std::string&gt; &amp;newLocations,
+			std::set&lt;std::string&gt; &amp;locationsToRemove);
+
+		/// Handles file existence events.
+		virtual bool fileExists(const std::string &amp;fileName);
+
+		/// Handles file creation events.
+		virtual bool fileCreated(const std::string &amp;fileName);
+
+		/// Handles file modified events.
+		virtual bool fileModified(const std::string &amp;fileName);
+
+		/// Handles file moved events.
+		virtual bool fileMoved(const std::string &amp;fileName,
+			const std::string &amp;previousFileName);
+
+		/// Handles file deleted events.
+		virtual bool fileDeleted(const std::string &amp;fileName);
+
+	protected:
+		WritableXapianIndex m_index;
+		std::set&lt;std::string&gt; m_locations;
+
+		bool indexFile(const std::string &amp;fileName, bool alwaysUpdate);
+
+	private:
+		OnDiskHandler(const OnDiskHandler &amp;other);
+		OnDiskHandler &amp;operator=(const OnDiskHandler &amp;other);
+
+};
+
+#endif // _MBOXHANDLER_HH


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000363.html">[Pinot-svn] r370 - trunk/UI/GTK2/src
</A></li>
	<LI>Next message: <A HREF="000365.html">[Pinot-svn] r372 - trunk/UI/GTK2/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#364">[ date ]</a>
              <a href="thread.html#364">[ thread ]</a>
              <a href="subject.html#364">[ subject ]</a>
              <a href="author.html#364">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/pinot-svn">More information about the Pinot-svn
mailing list</a><br>
</body></html>
