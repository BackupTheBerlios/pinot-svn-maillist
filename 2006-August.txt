From fabricecolin at mail.berlios.de  Fri Aug  4 13:59:40 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 4 Aug 2006 13:59:40 +0200
Subject: [Pinot-svn] r368 - trunk/Index
Message-ID: <200608041159.k74BxeN5022720@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-04 13:59:37 +0200 (Fri, 04 Aug 2006)
New Revision: 368

Modified:
   trunk/Index/WritableXapianIndex.cpp
   trunk/Index/WritableXapianIndex.h
Log:
In updateDocumentInfo(), refresh the document's common terms (prefixed with U
etc...) and terms generated from the title.


Modified: trunk/Index/WritableXapianIndex.cpp
===================================================================
--- trunk/Index/WritableXapianIndex.cpp	2006-07-21 14:43:46 UTC (rev 367)
+++ trunk/Index/WritableXapianIndex.cpp	2006-08-04 11:59:37 UTC (rev 368)
@@ -83,7 +83,7 @@
 	return isBadField;
 }
 
-void WritableXapianIndex::addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,
+void WritableXapianIndex::addPostingsToDocument(Tokenizer &tokens, Xapian::Document &doc,
 	const string &prefix, Xapian::termcount &termPos, StemmingMode mode) const
 {
 	Xapian::Stem *pStemmer = NULL;
@@ -134,7 +134,7 @@
 		}
 	}
 #ifdef DEBUG
-	cout << "WritableXapianIndex::addTermsToDocument: added " << termPos << " terms" << endl;
+	cout << "WritableXapianIndex::addPostingsToDocument: added " << termPos << " terms" << endl;
 #endif
 
 	if (pStemmer != NULL)
@@ -143,7 +143,84 @@
 	}
 }
 
-bool WritableXapianIndex::prepareDocument(const DocumentInfo &info, Xapian::Document &doc,
+void WritableXapianIndex::removeFirstPostingsFromDocument(Tokenizer &tokens, Xapian::Document &doc,
+	const string &prefix, const string &language, StemmingMode mode) const
+{
+	Xapian::TermIterator termListIter = doc.termlist_begin();
+	Xapian::Stem *pStemmer = NULL;
+	string term;
+
+	// Do we know what language to use for stemming ?
+	if (language.empty() == false)
+	{
+		pStemmer = new Xapian::Stem(StringManip::toLowerCase(language));
+	}
+
+	// Get the terms and remove the first posting for each
+	while (tokens.nextToken(term) == true)
+	{
+		if (term.empty() == true)
+		{
+			continue;
+		}
+		// Does it start with a capital letter ?
+		if (isupper((int)term[0]) != 0)
+		{
+			// R-prefix the raw term
+			termListIter.skip_to(string("R") + term);
+			Xapian::PositionIterator firstPosIter = termListIter.positionlist_begin();
+			if (firstPosIter != termListIter.positionlist_end())
+			{
+				doc.remove_posting(string("R") + term, *firstPosIter);
+			}
+		}
+		// Lower case the term
+		term = StringManip::toLowerCase(term);
+
+		// Stem the term ?
+		if ((mode == STORE_UNSTEM) ||
+			(pStemmer == NULL))
+		{
+			termListIter.skip_to(limitTermLength(prefix + term));
+			Xapian::PositionIterator firstPosIter = termListIter.positionlist_begin();
+			if (firstPosIter != termListIter.positionlist_end())
+			{
+				doc.remove_posting(limitTermLength(prefix + term), *firstPosIter);
+			}
+		}
+		else if (mode == STORE_STEM)
+		{
+			string stemmedTerm = pStemmer->stem_word(term);
+
+			termListIter.skip_to(limitTermLength(prefix + stemmedTerm));
+			Xapian::PositionIterator firstPosIter = termListIter.positionlist_begin();
+			if (firstPosIter != termListIter.positionlist_end())
+			{
+				doc.remove_posting(limitTermLength(prefix + stemmedTerm), *firstPosIter);
+			}
+		}
+		else if (mode == STORE_BOTH)
+		{
+			string stemmedTerm = pStemmer->stem_word(term);
+
+			// Both unstemmed and stemmed should be at the same position
+			termListIter.skip_to(limitTermLength(prefix + term));
+			Xapian::PositionIterator firstPosIter = termListIter.positionlist_begin();
+			if (firstPosIter != termListIter.positionlist_end())
+			{
+				doc.remove_posting(limitTermLength(prefix + term), *firstPosIter);
+				doc.remove_posting(limitTermLength(prefix + stemmedTerm), *firstPosIter);
+			}
+		}
+	}
+
+	if (pStemmer != NULL)
+	{
+		delete pStemmer;
+	}
+}
+
+bool WritableXapianIndex::addCommonTerms(const DocumentInfo &info, Xapian::Document &doc,
 	Xapian::termcount &termPos) const
 {
 	string title(info.getTitle());
@@ -159,9 +236,9 @@
 		Document titleDoc;
 		titleDoc.setData(title.c_str(), title.length());
 		Tokenizer titleTokens(&titleDoc);
-		addTermsToDocument(titleTokens, doc, "S", termPos, STORE_UNSTEM);
+		addPostingsToDocument(titleTokens, doc, "S", termPos, STORE_UNSTEM);
 		titleTokens.rewind();
-		addTermsToDocument(titleTokens, doc, "", termPos, m_stemMode);
+		addPostingsToDocument(titleTokens, doc, "", termPos, m_stemMode);
 	}
 
 	// Index the full URL with prefix U
@@ -189,11 +266,69 @@
 	// Finally, add the language code with prefix L
 	doc.add_term(string("L") + Languages::toCode(m_stemLanguage));
 
-	setDocumentData(doc, info, m_stemLanguage);
-
 	return true;
 }
 
+void WritableXapianIndex::removeCommonTerms(Xapian::Document &doc)
+{
+	DocumentInfo docInfo;
+	string record(doc.get_data());
+
+	// First, remove the magic term
+	doc.remove_term(MAGIC_TERM);
+
+	if (record.empty() == true)
+        {
+		// Nothing else we can do
+		return;
+	}
+
+	string language(Languages::toLocale(StringManip::extractField(record, "language=", "")));
+	docInfo = DocumentInfo(StringManip::extractField(record, "caption=", "\n"),
+		StringManip::extractField(record, "url=", "\n"),
+		StringManip::extractField(record, "type=", "\n"),
+		language);
+	docInfo.setTimestamp(StringManip::extractField(record, "timestamp=", "\n"));
+	Url urlObj(docInfo.getLocation());
+
+	// FIXME: remove terms extracted from the title if they don't have more than one posting
+	string title(docInfo.getTitle());
+	if (title.empty() == false)
+	{
+		Document titleDoc;
+		titleDoc.setData(title.c_str(), title.length());
+		Tokenizer titleTokens(&titleDoc);
+		removeFirstPostingsFromDocument(titleTokens, doc, "S", language, STORE_UNSTEM);
+		titleTokens.rewind();
+		removeFirstPostingsFromDocument(titleTokens, doc, "", language, m_stemMode);
+	}
+
+	// Title
+	doc.remove_term(limitTermLength(string("U") + docInfo.getLocation(), true));
+	// Host name
+	string hostName(StringManip::toLowerCase(urlObj.getHost()));
+	if (hostName.empty() == false)
+	{
+		doc.remove_term(limitTermLength(string("H") + hostName, true));
+		string::size_type dotPos = hostName.find('.');
+		while (dotPos != string::npos)
+		{
+			doc.remove_term(limitTermLength(string("H") + hostName.substr(dotPos + 1), true));
+
+			// Next
+			dotPos = hostName.find('.', dotPos + 1);
+		}
+	}
+	// ...and file name
+	string fileName(urlObj.getFile());
+	if (fileName.empty() == false)
+	{
+		doc.remove_term(limitTermLength(string("P") + StringManip::toLowerCase(fileName), true));
+	}
+	// Language code
+	doc.remove_term(string("L") + Languages::toCode(language));
+}
+
 string WritableXapianIndex::scanDocument(const char *pData, unsigned int dataLength,
 	DocumentInfo &info)
 {
@@ -235,7 +370,7 @@
 	return language;
 }
 
-void WritableXapianIndex::setDocumentData(Xapian::Document &doc, const DocumentInfo &info,
+void WritableXapianIndex::setDocumentData(const DocumentInfo &info, Xapian::Document &doc,
 	const string &language) const
 {
 	string title(info.getTitle());
@@ -445,15 +580,17 @@
 		cout << "WritableXapianIndex::indexDocument: adding terms" << endl;
 #endif
 		// Add the tokenizer's terms to the Xapian document
-		addTermsToDocument(tokens, doc, "", termPos, m_stemMode);
+		addPostingsToDocument(tokens, doc, "", termPos, m_stemMode);
 		// Add labels
 		for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
 			++labelIter)
 		{
 			doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
 		}
-		if (prepareDocument(docInfo, doc, termPos) == true)
+		if (addCommonTerms(docInfo, doc, termPos) == true)
 		{
+			setDocumentData(docInfo, doc, m_stemLanguage);
+
 			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
 			if (pIndex != NULL)
 			{
@@ -521,7 +658,7 @@
 		Xapian::termcount termPos = 0;
 
 		// Add the tokenizer's terms to the document
-		addTermsToDocument(tokens, doc, "", termPos, m_stemMode);
+		addPostingsToDocument(tokens, doc, "", termPos, m_stemMode);
 		// Get the document's labels
 		if (getDocumentLabels(docId, labels) == true)
 		{
@@ -532,8 +669,10 @@
 				doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
 			}
 		}
-		if (prepareDocument(docInfo, doc, termPos) == true)
+		if (addCommonTerms(docInfo, doc, termPos) == true)
 		{
+			setDocumentData(docInfo, doc, m_stemLanguage);
+
 			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
 			if (pIndex != NULL)
 			{
@@ -579,12 +718,17 @@
 		if (pIndex != NULL)
 		{
 			Xapian::Document doc = pIndex->get_document(docId);
+			Xapian::termcount termPos = 0;
 
 #ifdef DEBUG
 			cout << "WritableXapianIndex::updateDocumentInfo: language is " << docInfo.getLanguage() << endl;
 #endif
+
 			// Update the document data with the current language
-			setDocumentData(doc, docInfo, docInfo.getLanguage());
+			removeCommonTerms(doc);
+			setDocumentData(docInfo, doc, docInfo.getLanguage());
+			addCommonTerms(docInfo, doc, termPos);
+
 			pIndex->replace_document(docId, doc);
 			updated = true;
 		}

Modified: trunk/Index/WritableXapianIndex.h
===================================================================
--- trunk/Index/WritableXapianIndex.h	2006-07-21 14:43:46 UTC (rev 367)
+++ trunk/Index/WritableXapianIndex.h	2006-08-04 11:59:37 UTC (rev 368)
@@ -97,16 +97,21 @@
 
 		static bool badField(const std::string &field);
 
-		void addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,
+		void addPostingsToDocument(Tokenizer &tokens, Xapian::Document &doc,
 			const std::string &prefix, Xapian::termcount &termPos, StemmingMode mode) const;
 
-		bool prepareDocument(const DocumentInfo &info, Xapian::Document &doc,
+		void removeFirstPostingsFromDocument(Tokenizer &tokens, Xapian::Document &doc,
+			const std::string &prefix, const std::string &language, StemmingMode mode) const;
+
+		bool addCommonTerms(const DocumentInfo &info, Xapian::Document &doc,
 			Xapian::termcount &termPos) const;
 
+		void removeCommonTerms(Xapian::Document &doc);
+
 		std::string scanDocument(const char *pData, unsigned int dataLength,
 			DocumentInfo &info);
 
-		void setDocumentData(Xapian::Document &doc, const DocumentInfo &info,
+		void setDocumentData(const DocumentInfo &info, Xapian::Document &doc,
 			const std::string &language) const;
 
 		bool listDocumentsWithTerm(const std::string &term, std::set<unsigned int> &docIds,



From fabricecolin at mail.berlios.de  Fri Aug  4 14:05:01 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 4 Aug 2006 14:05:01 +0200
Subject: [Pinot-svn] r369 - in trunk: Monitor UI/GTK2/src
Message-ID: <200608041205.k74C51nZ023764@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-04 14:04:58 +0200 (Fri, 04 Aug 2006)
New Revision: 369

Modified:
   trunk/Monitor/MonitorHandler.h
   trunk/UI/GTK2/src/MboxHandler.cpp
   trunk/UI/GTK2/src/MboxHandler.h
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
Log:
Prototype of MonitorHandler::fileMoved() has changed.


Modified: trunk/Monitor/MonitorHandler.h
===================================================================
--- trunk/Monitor/MonitorHandler.h	2006-08-04 11:59:37 UTC (rev 368)
+++ trunk/Monitor/MonitorHandler.h	2006-08-04 12:04:58 UTC (rev 369)
@@ -45,7 +45,8 @@
 		virtual bool fileModified(const std::string &fileName) = 0;
 
 		/// Handles file moved events.
-		virtual bool fileMoved(const std::string &fileName) = 0;
+		virtual bool fileMoved(const std::string &fileName,
+			const std::string &previousFileName) = 0;
 
 		/// Handles file deleted events.
 		virtual bool fileDeleted(const std::string &fileName) = 0;

Modified: trunk/UI/GTK2/src/MboxHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-04 11:59:37 UTC (rev 368)
+++ trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-04 12:04:58 UTC (rev 369)
@@ -380,7 +380,7 @@
 	return indexMessages(fileName, mailAccount, mboxOffset);
 }
 
-bool MboxHandler::fileMoved(const string &fileName)
+bool MboxHandler::fileMoved(const string &fileName, const string &previousFileName)
 {
 	// Nothing to do here
 	return true;

Modified: trunk/UI/GTK2/src/MboxHandler.h
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.h	2006-08-04 11:59:37 UTC (rev 368)
+++ trunk/UI/GTK2/src/MboxHandler.h	2006-08-04 12:04:58 UTC (rev 369)
@@ -48,7 +48,8 @@
 		virtual bool fileModified(const std::string &fileName);
 
 		/// Handles file moved events.
-		virtual bool fileMoved(const std::string &fileName);
+		virtual bool fileMoved(const std::string &fileName,
+			const std::string &previousFileName);
 
 		/// Handles file deleted events.
 		virtual bool fileDeleted(const std::string &fileName);

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-04 11:59:37 UTC (rev 368)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-04 12:04:58 UTC (rev 369)
@@ -1514,7 +1514,7 @@
 				}
 				else if (event.m_type == MonitorEvent::MOVED)
 				{
-					updatedIndex = m_pHandler->fileMoved(event.m_location);
+					updatedIndex = m_pHandler->fileMoved(event.m_location, event.m_previousLocation);
 				}
 				else if (event.m_type == MonitorEvent::DELETED)
 				{
@@ -1557,6 +1557,11 @@
 	return "DirectoryScannerThread";
 }
 
+string DirectoryScannerThread::getDirectory(void) const
+{
+	return m_dirName;
+}
+
 bool DirectoryScannerThread::stop(void)
 {
 	m_done = true;

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2006-08-04 11:59:37 UTC (rev 368)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2006-08-04 12:04:58 UTC (rev 369)
@@ -398,6 +398,8 @@
 
 		virtual std::string getType(void) const;
 
+		virtual std::string getDirectory(void) const;
+
 		virtual bool stop(void);
 
 		SigC::Signal1<bool, const std::string&>& getFileFoundSignal(void);



From fabricecolin at mail.berlios.de  Fri Aug  4 14:11:51 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 4 Aug 2006 14:11:51 +0200
Subject: [Pinot-svn] r370 - trunk/UI/GTK2/src
Message-ID: <200608041211.k74CBpxp025203@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-04 14:11:48 +0200 (Fri, 04 Aug 2006)
New Revision: 370

Modified:
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/PinotSettings.h
Log:
Nested class TimestampedItem used for indexable locations.


Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2006-08-04 12:04:58 UTC (rev 369)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2006-08-04 12:11:48 UTC (rev 370)
@@ -725,14 +725,14 @@
 		{
 			mailAccount.m_name = nodeContent;
 		}
+		else if (nodeName == "mtime")
+		{
+			mailAccount.m_modTime = (time_t)atoi(nodeContent.c_str());
+		}
 		else if (nodeName == "type")
 		{
 			mailAccount.m_type = nodeContent;
 		}
-		else if (nodeName == "mtime")
-		{
-			mailAccount.m_modTime = (time_t)atoi(nodeContent.c_str());
-		}
 		else if (nodeName == "mindate")
 		{
 			mailAccount.m_lastMessageTime = (time_t)atoi(nodeContent.c_str());
@@ -764,6 +764,8 @@
 		return false;
 	}
 
+	TimestampedItem location;
+
 	// Load the indexable location's properties
 	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
 	{
@@ -779,10 +781,19 @@
 
 		if (nodeName == "location")
 		{
-			m_indexableLocations.insert(nodeContent);
+			location.m_name = nodeContent;
 		}
+		else if (nodeName == "mtime")
+		{
+			location.m_modTime = (time_t)atoi(nodeContent.c_str());
+		}
 	}
 
+	if (location.m_name.empty() == false)
+	{
+		m_indexableLocations.insert(location);
+	}
+
 	return true;
 }
 
@@ -1041,14 +1052,16 @@
 		addChildElement(pElem, "size", numStr);
 	}
 	// Locations to index 
-	for (set<string>::iterator locationIter = m_indexableLocations.begin(); locationIter != m_indexableLocations.end(); ++locationIter)
+	for (set<TimestampedItem>::iterator locationIter = m_indexableLocations.begin(); locationIter != m_indexableLocations.end(); ++locationIter)
 	{
 		pElem = pRootElem->add_child("indexable");
 		if (pElem == NULL)
 		{
 			return false;
 		}
-		addChildElement(pElem, "location", *locationIter);
+		addChildElement(pElem, "location", locationIter->m_name);
+		sprintf(numStr, "%ld", locationIter->m_modTime);
+		addChildElement(pElem, "mtime", numStr);
 	}
 
 	// Save to file
@@ -1361,37 +1374,30 @@
 	return false;
 }
 
-PinotSettings::MailAccount::MailAccount()
+PinotSettings::TimestampedItem::TimestampedItem() :
+	m_modTime(0)
 {
-	m_modTime = m_lastMessageTime = (time_t)0;
-	m_size = 0;
 }
 
-PinotSettings::MailAccount::MailAccount(const MailAccount &other) :
+PinotSettings::TimestampedItem::TimestampedItem(const TimestampedItem &other) :
 	m_name(other.m_name),
-	m_type(other.m_type),
-	m_modTime(other.m_modTime),
-	m_lastMessageTime(other.m_lastMessageTime),
-	m_size(other.m_size)
+	m_modTime(other.m_modTime)
 {
 }
 
-PinotSettings::MailAccount::~MailAccount()
+PinotSettings::TimestampedItem::~TimestampedItem()
 {
 }
 
-PinotSettings::MailAccount &PinotSettings::MailAccount::operator=(const MailAccount &other)
+PinotSettings::TimestampedItem &PinotSettings::TimestampedItem::operator=(const TimestampedItem &other)
 {
 	m_name = other.m_name;
-	m_type = other.m_type;
 	m_modTime = other.m_modTime;
-	m_lastMessageTime = other.m_lastMessageTime;
-	m_size = other.m_size;
 
 	return *this;
 }
 
-bool PinotSettings::MailAccount::operator<(const MailAccount &other) const
+bool PinotSettings::TimestampedItem::operator<(const TimestampedItem &other) const
 {
 	if (m_name < other.m_name)
 	{
@@ -1401,7 +1407,7 @@
 	return false;
 }
 
-bool PinotSettings::MailAccount::operator==(const MailAccount &other) const
+bool PinotSettings::TimestampedItem::operator==(const TimestampedItem &other) const
 {
 	if (m_name == other.m_name)
 	{
@@ -1411,6 +1417,45 @@
 	return false;
 }
 
+PinotSettings::MailAccount::MailAccount() :
+	TimestampedItem(),
+	m_lastMessageTime(0),
+	m_size(0)
+{
+}
+
+PinotSettings::MailAccount::MailAccount(const MailAccount &other) :
+	TimestampedItem(other),
+	m_type(other.m_type),
+	m_lastMessageTime(other.m_lastMessageTime),
+	m_size(other.m_size)
+{
+}
+
+PinotSettings::MailAccount::~MailAccount()
+{
+}
+
+PinotSettings::MailAccount &PinotSettings::MailAccount::operator=(const MailAccount &other)
+{
+	TimestampedItem::operator=(other);
+	m_type = other.m_type;
+	m_lastMessageTime = other.m_lastMessageTime;
+	m_size = other.m_size;
+
+	return *this;
+}
+
+bool PinotSettings::MailAccount::operator<(const MailAccount &other) const
+{
+	return TimestampedItem::operator<(other);
+}
+
+bool PinotSettings::MailAccount::operator==(const MailAccount &other) const
+{
+	return TimestampedItem::operator==(other);
+}
+
 PinotSettings::CacheProvider::CacheProvider()
 {
 }

Modified: trunk/UI/GTK2/src/PinotSettings.h
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.h	2006-08-04 12:04:58 UTC (rev 369)
+++ trunk/UI/GTK2/src/PinotSettings.h	2006-08-04 12:11:48 UTC (rev 370)
@@ -125,9 +125,24 @@
 		/// Clears the labels list.
 		void clearLabels(void);
 
-		class MailAccount
+		class TimestampedItem
 		{
 			public:
+				TimestampedItem();
+				TimestampedItem(const TimestampedItem &other);
+				~TimestampedItem();
+
+				TimestampedItem &operator=(const TimestampedItem &other);
+				bool operator<(const TimestampedItem &other) const;
+				bool operator==(const TimestampedItem &other) const;
+
+				Glib::ustring m_name;
+				time_t m_modTime;
+		};
+
+		class MailAccount : public TimestampedItem
+		{
+			public:
 				MailAccount();
 				MailAccount(const MailAccount &other);
 				~MailAccount();
@@ -136,9 +151,7 @@
 				bool operator<(const MailAccount &other) const;
 				bool operator==(const MailAccount &other) const;
 
-				Glib::ustring m_name;
 				Glib::ustring m_type;
-				time_t m_modTime;
 				time_t m_lastMessageTime;
 				off_t m_size;
 		};
@@ -174,7 +187,7 @@
 		bool m_suggestQueryTerms;
 		Gdk::Color m_newResultsColour;
 		std::set<MailAccount> m_mailAccounts;
-		std::set<std::string> m_indexableLocations;
+		std::set<TimestampedItem> m_indexableLocations;
 		std::vector<CacheProvider> m_cacheProviders;
 		std::set<Glib::ustring> m_cacheProtocols;
 



From fabricecolin at mail.berlios.de  Fri Aug  4 14:15:13 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 4 Aug 2006 14:15:13 +0200
Subject: [Pinot-svn] r371 - trunk/UI/GTK2/src
Message-ID: <200608041215.k74CFDge027134@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-04 14:14:57 +0200 (Fri, 04 Aug 2006)
New Revision: 371

Added:
   trunk/UI/GTK2/src/DaemonState.cpp
   trunk/UI/GTK2/src/DaemonState.h
   trunk/UI/GTK2/src/OnDiskHandler.cpp
   trunk/UI/GTK2/src/OnDiskHandler.h
Log:
New classes to help the daemon. DaemonState manages crawling and monitoring,
while OnDiskHandler handles events generated by MonitorThread.


Added: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2006-08-04 12:11:48 UTC (rev 370)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2006-08-04 12:14:57 UTC (rev 371)
@@ -0,0 +1,266 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+#include <sigc++/class_slot.h>
+#include <glibmm/ustring.h>
+#include <glibmm/stringutils.h>
+#include <glibmm/convert.h>
+#include <glibmm/thread.h>
+
+#include "DaemonState.h"
+#include "OnDiskHandler.h"
+#include "PinotSettings.h"
+#include "PinotUtils.h"
+#include "WorkerThreads.h"
+
+using namespace std;
+using namespace Glib;
+
+DaemonState::DaemonState() :
+	ThreadsManager(PinotSettings::getInstance().m_daemonIndexLocation, 10),
+	m_crawling(false)
+{
+	m_onThreadEndSignal.connect(SigC::slot(*this, &DaemonState::on_thread_end));
+}
+
+DaemonState::~DaemonState()
+{
+}
+
+void DaemonState::start(void)
+{
+	string locationToCrawl;
+
+	for (set<PinotSettings::TimestampedItem>::const_iterator locationIter = PinotSettings::getInstance().m_indexableLocations.begin();
+		locationIter != PinotSettings::getInstance().m_indexableLocations.end(); ++locationIter)
+	{
+		bool crawledLocation = false;
+
+		// Has this directory been crawled before ?
+		if (locationIter->m_modTime > 0)
+		{
+			// FIXME: recrawl once in a while ?
+			crawledLocation = true;
+		}
+
+		if (crawledLocation == false)
+		{
+			if (locationToCrawl.empty() == true)
+			{
+				locationToCrawl = locationIter->m_name;
+			}
+			else
+			{
+				// This will be crawled next
+				m_crawlQueue.push(locationIter->m_name);
+			}
+		}
+		else
+		{
+			m_monitoredLocations.insert(locationIter->m_name);
+		}
+	}
+
+	// ANything to crawl before starting monitoring ?
+	if (locationToCrawl.empty() == false)
+	{
+		// Scan the directory and import all its files
+		DirectoryScannerThread *pScannerThread = new DirectoryScannerThread(locationToCrawl,
+			0, true, &m_scanMutex, &m_scanCondVar);
+		pScannerThread->getFileFoundSignal().connect(SigC::slot(*this, &DaemonState::on_message_filefound));
+
+		m_crawling = start_thread(pScannerThread);
+	}
+	else
+	{
+		// Fire up the disk monitor thread
+		OnDiskHandler *pDisk = new OnDiskHandler();
+		// Connect to its update signal
+		pDisk->getUpdateSignal().connect(
+			SigC::slot(*this, &DaemonState::on_message_indexupdate));
+		MonitorThread *pMonitorThread = new MonitorThread(pDisk);
+		start_thread(pMonitorThread, true);
+		// The handler object will be deleted when the thread terminates
+	}
+}
+
+void DaemonState::signal_scanner(void)
+{
+	// Ask the scanner for another file
+	m_scanMutex.lock();
+	m_scanCondVar.signal();
+	m_scanMutex.unlock();
+}
+
+void DaemonState::on_thread_end(WorkerThread *pThread)
+{
+	if (pThread == NULL)
+	{
+		return;
+	}
+#ifdef DEBUG
+	cout << "DaemonState::on_thread_end: end of thread " << pThread->getId() << endl;
+#endif
+
+	// What type of thread was it ?
+	string type(pThread->getType());
+	if (type == "DirectoryScannerThread")
+	{
+		DirectoryScannerThread *pScannerThread = dynamic_cast<DirectoryScannerThread *>(pThread);
+		if (pScannerThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		DirectoryScannerThread *pNewScannerThread = NULL;
+
+		// Another location to crawl ?
+		if (write_lock_lists() == true)
+		{
+			if (m_crawlQueue.empty() == false)
+			{
+				string locationToCrawl(m_crawlQueue.front());
+
+				set<PinotSettings::TimestampedItem> &indexableLocations = PinotSettings::getInstance().m_indexableLocations;
+				for (set<PinotSettings::TimestampedItem>::iterator locationIter = indexableLocations.begin();
+			                locationIter != indexableLocations.end(); ++locationIter)
+				{
+					if (locationIter->m_name == pScannerThread->getDirectory())
+					{
+						PinotSettings::TimestampedItem location(*locationIter);
+
+						// Set the timestamp
+						location.m_modTime = time(NULL);
+						indexableLocations.erase(locationIter);
+						indexableLocations.insert(location);
+
+						break;
+					}
+				}
+
+				pNewScannerThread = new DirectoryScannerThread(locationToCrawl,
+					0, true, &m_scanMutex, &m_scanCondVar);
+				pNewScannerThread->getFileFoundSignal().connect(SigC::slot(*this,
+					&DaemonState::on_message_filefound));
+
+				m_crawlQueue.pop();
+			}
+			else
+			{
+				// Done with crawling
+				m_crawling = false;
+			}
+
+			unlock_lists();
+		}
+
+		// Start a new scanner thread ?
+		if (pNewScannerThread != NULL)
+		{
+			m_crawling = start_thread(pNewScannerThread);
+		}
+		else
+		{
+			// Now we can start monitoring
+			OnDiskHandler *pDisk = new OnDiskHandler();
+			// Connect to its update signal
+			pDisk->getUpdateSignal().connect(
+				SigC::slot(*this, &DaemonState::on_message_indexupdate));
+			MonitorThread *pMonitorThread = new MonitorThread(pDisk);
+			start_thread(pMonitorThread, true);
+			// The handler object will be deleted when the thread terminates
+		}
+	}
+	else if (type == "IndexingThread")
+	{
+		IndexingThread *pIndexThread = dynamic_cast<IndexingThread *>(pThread);
+		if (pIndexThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		// Did the thread perform an update ?
+		if (pIndexThread->isNewDocument() == true)
+		{
+			string url(pIndexThread->getURL());
+
+			// Update the in-progress list
+			if (write_lock_lists() == true)
+			{
+				set<string>::iterator urlIter = m_beingIndexed.find(url);
+				if (urlIter != m_beingIndexed.end())
+				{
+					m_beingIndexed.erase(urlIter);
+				}
+
+				unlock_lists();
+			}
+		}
+
+		// Get another file from the directory scanner if possible
+		if (m_crawling == true)
+		{
+			signal_scanner();
+		}
+	}
+	else if (type == "UnindexingThread")
+	{
+		UnindexingThread *pUnindexThread = dynamic_cast<UnindexingThread *>(pThread);
+		if (pUnindexThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		// FIXME: anything to do ?
+	}
+	else if (type == "MonitorThread")
+	{
+		// Fire up another disk monitor thread
+		OnDiskHandler *pDisk = new OnDiskHandler();
+		// Connect to its update signal
+		pDisk->getUpdateSignal().connect(
+			SigC::slot(*this, &DaemonState::on_message_indexupdate));
+		MonitorThread *pMonitorThread = new MonitorThread(pDisk);
+		start_thread(pMonitorThread, true);
+		// The handler object will be deleted when the thread terminates
+	}
+
+	// Delete the thread
+	delete pThread;;
+
+	// We might be able to run a queued action
+	pop_queue();
+}
+
+void DaemonState::on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, string indexName)
+{
+	// FIXME: anything to do ?
+}
+
+bool DaemonState::on_message_filefound(const string &location)
+{
+	DocumentInfo docInfo(location, location, "", "");
+
+	queue_index(docInfo);
+
+	// Don't request another file right now
+	return false;
+}
+

Added: trunk/UI/GTK2/src/DaemonState.h
===================================================================
--- trunk/UI/GTK2/src/DaemonState.h	2006-08-04 12:11:48 UTC (rev 370)
+++ trunk/UI/GTK2/src/DaemonState.h	2006-08-04 12:14:57 UTC (rev 371)
@@ -0,0 +1,53 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DBUSERVER_HH
+#define _DBUSERVER_HH
+
+#include <string>
+#include <queue>
+#include <set>
+#include <glibmm/thread.h>
+
+#include "IndexedDocument.h"
+#include "WorkerThreads.h"
+
+class DaemonState : public ThreadsManager
+{
+	public:
+		DaemonState();
+		virtual ~DaemonState();
+
+		void start(void);
+
+		void signal_scanner(void);
+
+		void on_thread_end(WorkerThread *pThread);
+
+		void on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, std::string indexName);
+
+		bool on_message_filefound(const std::string &location);
+
+	protected:
+		std::queue<std::string> m_crawlQueue;
+		std::set<std::string> m_monitoredLocations;
+		bool m_crawling;
+		Glib::Mutex m_scanMutex;
+		Glib::Cond m_scanCondVar;
+
+};
+
+#endif

Added: trunk/UI/GTK2/src/OnDiskHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-04 12:11:48 UTC (rev 370)
+++ trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-04 12:14:57 UTC (rev 371)
@@ -0,0 +1,251 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <iostream>
+#include <fstream>
+
+#include "config.h"
+#include "NLS.h"
+#include "MIMEScanner.h"
+#include "StringManip.h"
+#include "Url.h"
+#include "XapianDatabase.h"
+#include "TokenizerFactory.h"
+#include "FileCollector.h"
+#include "PinotUtils.h"
+#include "OnDiskHandler.h"
+
+using namespace std;
+using namespace SigC;
+
+OnDiskHandler::OnDiskHandler() :
+	MonitorHandler(),
+	m_index(PinotSettings::getInstance().m_daemonIndexLocation)
+{
+	m_index.setStemmingMode(WritableIndexInterface::STORE_BOTH);
+}
+
+OnDiskHandler::~OnDiskHandler()
+{
+}
+
+bool OnDiskHandler::indexFile(const string &fileName, bool alwaysUpdate)
+{
+	string url(string("file://") + fileName);
+	Url urlObj(url);
+	set<string> labels;
+	bool indexedFile = false;
+
+	if ((m_index.isGood() == false) || 
+		(fileName.empty() == true))
+	{
+		return false;
+	}
+
+	// Has this file been indexed already ?
+	unsigned int docId = m_index.hasDocument(url);
+	if ((docId > 0) &&
+		(alwaysUpdate == false))
+	{
+		// No need to update
+		return true;
+	}
+
+	DocumentInfo docInfo(url, url, MIMEScanner::scanUrl(urlObj), "");
+
+	FileCollector fileCollector;
+	Document *pDoc = fileCollector.retrieveUrl(docInfo);
+	if (pDoc == NULL)
+	{
+#ifdef DEBUG
+		cout << "OnDiskHandler::indexFile: couldn't download " << url << endl;
+#endif
+		return false;
+	}
+
+	// Get an ad hoc tokenizer for the message
+	Tokenizer *pTokenizer = TokenizerFactory::getTokenizerByType(docInfo.getType(), pDoc);
+	if (pTokenizer == NULL)
+	{
+#ifdef DEBUG
+		cout << "OnDiskHandler::indexFile: no tokenizer for type " << docInfo.getType() << endl;
+#endif
+		delete pDoc;
+		return false;
+	}
+
+	// Index or update ?
+	if (docId == 0)
+	{
+		indexedFile = m_index.indexDocument(*pTokenizer, labels, docId);
+	}
+	else
+	{
+		indexedFile = m_index.updateDocument(docId, *pTokenizer);
+	}
+
+	if (indexedFile == true)
+	{
+		IndexedDocument indexedDocInfo(docInfo.getTitle(),
+			XapianDatabase::buildUrl(PinotSettings::getInstance().m_daemonIndexLocation, docId),
+			docInfo.getLocation(), docInfo.getType(), docInfo.getLanguage());
+
+		// Signal
+		m_signalUpdate(indexedDocInfo, docId, _("My Computer"));
+	}
+#ifdef DEBUG
+	else cout << "OnDiskHandler::indexFile: couldn't index " << url << endl;
+#endif
+
+	delete pTokenizer;
+	delete pDoc;
+
+	return indexedFile;
+}
+
+bool OnDiskHandler::getLocations(set<string> &newLocations,
+	set<string> &locationsToRemove)
+{
+	newLocations.clear();
+	locationsToRemove.clear();
+
+	// Take advantage of this call to flush the index
+	m_index.flush();
+
+	copy(m_locations.begin(), m_locations.end(),
+		inserter(locationsToRemove, locationsToRemove.begin()));
+
+	// Get the indexable locations map
+	set<PinotSettings::TimestampedItem> &indexableLocations = PinotSettings::getInstance().m_indexableLocations;
+	for (set<PinotSettings::TimestampedItem>::iterator dirIter = indexableLocations.begin();
+		dirIter != indexableLocations.end(); ++dirIter)
+	{
+		// Is this a known location ?
+		set<string>::iterator locationIter = m_locations.find(dirIter->m_name);
+		if (locationIter == m_locations.end())
+		{
+			// No, it is new
+			m_locations.insert(dirIter->m_name);
+			newLocations.insert(dirIter->m_name);
+		}
+		else
+		{
+			// Since it's a known location, we'd better not remove it
+			set<string>::iterator removeIter = locationsToRemove.find(*locationIter);
+			if (removeIter != locationsToRemove.end())
+			{
+				locationsToRemove.erase(removeIter);
+			}
+		}
+	}
+
+	// Locations in locationsToRemove have to be removed
+	for (set<string>::iterator removeIter = locationsToRemove.begin();
+		removeIter != locationsToRemove.end(); ++removeIter)
+	{
+		set<string>::iterator locationIter = m_locations.find(*removeIter);
+		if (locationIter != m_locations.end())
+		{
+			m_locations.erase(locationIter);
+		}
+	}
+
+#ifdef DEBUG
+	cout << "OnDiskHandler::getLocations: " << m_locations.size() << " locations, "
+		<< newLocations.size() << " new, " << locationsToRemove.size() << " to be removed" << endl;
+#endif
+
+	if ((newLocations.empty() == false) ||
+		(locationsToRemove.empty() == false))
+	{
+		return true;
+	}
+
+	return false;
+}
+
+bool OnDiskHandler::fileExists(const string &fileName)
+{
+#ifdef DEBUG
+	cout << "OnDiskHandler::fileExists: " << fileName << endl;
+#endif
+}
+
+bool OnDiskHandler::fileCreated(const string &fileName)
+{
+#ifdef DEBUG
+	cout << "OnDiskHandler::fileCreated: " << fileName << endl;
+#endif
+	// The file shouldn't exist in the index, but if it does for some reason, don't update it
+	return indexFile(fileName, false);
+}
+
+bool OnDiskHandler::fileModified(const string &fileName)
+{
+#ifdef DEBUG
+	cout << "OnDiskHandler::fileModified: " << fileName << endl;
+#endif
+	// Update the file, or index if necessary
+	return indexFile(fileName, true);
+}
+
+bool OnDiskHandler::fileMoved(const string &fileName, const string &previousFileName)
+{
+#ifdef DEBUG
+	cout << "OnDiskHandler::fileMoved: " << fileName << endl;
+#endif
+	unsigned int oldDocId = m_index.hasDocument(string("file://") + previousFileName);
+	if (oldDocId > 0)
+	{
+		DocumentInfo docInfo;
+
+		m_index.getDocumentInfo(oldDocId, docInfo);
+
+		// Has the destination file been indexed too ?
+		unsigned int docId = m_index.hasDocument(string("file://") + fileName);
+		if (docId > 0)
+		{
+			// Unindex it
+			m_index.unindexDocument(docId);
+		}
+
+		// Change the location
+		docInfo.setLocation(string("file://") + fileName);
+		return m_index.updateDocumentInfo(oldDocId, docInfo);
+	}
+
+	return false; 
+}
+
+bool OnDiskHandler::fileDeleted(const string &fileName)
+{
+#ifdef DEBUG
+	cout << "OnDiskHandler::fileDeleted: " << fileName << endl;
+#endif
+	unsigned int docId = m_index.hasDocument(string("file://") + fileName);
+	if (docId > 0)
+	{
+		// Unindex the file
+		return m_index.unindexDocument(docId);
+	}
+
+	return false;
+}
+

Added: trunk/UI/GTK2/src/OnDiskHandler.h
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-04 12:11:48 UTC (rev 370)
+++ trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-04 12:14:57 UTC (rev 371)
@@ -0,0 +1,69 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#ifndef _MBOXHANDLER_HH
+#define _MBOXHANDLER_HH
+
+#include <time.h>
+#include <string>
+#include <set>
+#include <sigc++/slot.h>
+
+#include "IndexedDocument.h"
+#include "MboxParser.h"
+#include "WritableXapianIndex.h"
+#include "MonitorHandler.h"
+#include "PinotSettings.h"
+
+class OnDiskHandler : public MonitorHandler
+{
+	public:
+		OnDiskHandler();
+		virtual ~OnDiskHandler();
+
+		/// Returns locations.
+		virtual bool getLocations(std::set<std::string> &newLocations,
+			std::set<std::string> &locationsToRemove);
+
+		/// Handles file existence events.
+		virtual bool fileExists(const std::string &fileName);
+
+		/// Handles file creation events.
+		virtual bool fileCreated(const std::string &fileName);
+
+		/// Handles file modified events.
+		virtual bool fileModified(const std::string &fileName);
+
+		/// Handles file moved events.
+		virtual bool fileMoved(const std::string &fileName,
+			const std::string &previousFileName);
+
+		/// Handles file deleted events.
+		virtual bool fileDeleted(const std::string &fileName);
+
+	protected:
+		WritableXapianIndex m_index;
+		std::set<std::string> m_locations;
+
+		bool indexFile(const std::string &fileName, bool alwaysUpdate);
+
+	private:
+		OnDiskHandler(const OnDiskHandler &other);
+		OnDiskHandler &operator=(const OnDiskHandler &other);
+
+};
+
+#endif // _MBOXHANDLER_HH



From fabricecolin at mail.berlios.de  Fri Aug  4 14:21:37 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 4 Aug 2006 14:21:37 +0200
Subject: [Pinot-svn] r372 - trunk/UI/GTK2/src
Message-ID: <200608041221.k74CLbBq030093@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-04 14:21:01 +0200 (Fri, 04 Aug 2006)
New Revision: 372

Modified:
   trunk/UI/GTK2/src/Makefile.am
Log:
Added new source.


Modified: trunk/UI/GTK2/src/Makefile.am
===================================================================
--- trunk/UI/GTK2/src/Makefile.am	2006-08-04 12:14:57 UTC (rev 371)
+++ trunk/UI/GTK2/src/Makefile.am	2006-08-04 12:21:01 UTC (rev 372)
@@ -13,16 +13,18 @@
 	propertiesDialog.hh \
 	indexDialog_glade.hh \
 	indexDialog.hh \
+	DaemonState.h \
 	EnginesTree.h \
 	IndexPage.h \
+	IndexTree.h \
+	MboxHandler.h \
 	ModelColumns.h \
 	Notebook.h \
+	OnDiskHandler.h \
+	PinotSettings.h \
 	PinotUtils.h \
-	WorkerThreads.h \
-	IndexTree.h \
-	MboxHandler.h \
-	PinotSettings.h \
-	ResultsTree.h
+	ResultsTree.h \
+	WorkerThreads.h
 
 pinot_SOURCES = \
 	pinot.cc \
@@ -40,24 +42,38 @@
 	indexDialog.cc \
 	EnginesTree.cpp \
 	IndexPage.cpp \
+	IndexTree.cpp \
+	MboxHandler.cpp \
 	ModelColumns.cpp \
 	Notebook.cpp \
+	PinotSettings.cpp \
 	PinotUtils.cpp \
-	WorkerThreads.cpp \
-	IndexTree.cpp \
+	ResultsTree.cpp \
+	WorkerThreads.cpp
+
+pinot_dbus_daemon_SOURCES = \
+	pinot-dbus-daemon.cc \
+	DaemonState.cpp \
 	MboxHandler.cpp \
+	OnDiskHandler.cpp \
 	PinotSettings.cpp \
-	ResultsTree.cpp
+	PinotUtils.cpp \
+	WorkerThreads.cpp
 
-bin_PROGRAMS = pinot
+bin_PROGRAMS = pinot pinot-dbus-daemon
 
 AM_CXXFLAGS = -I../../../Utils -I../../../Tokenize -I../../../SQL \
 	-I../../../Monitor -I../../../Collect -I../../../Search \
 	-I../../../Search/Google -I../../../Index \
-	@SQL_CFLAGS@ @HTTP_CFLAGS@ @MIME_CFLAGS@ @XML_CFLAGS@ @SOAP_CFLAGS@ @INDEX_CFLAGS@ @UI_CFLAGS@
+	@SQL_CFLAGS@ @HTTP_CFLAGS@ @MIME_CFLAGS@ @XML_CFLAGS@ @SOAP_CFLAGS@ @DBUS_CFLAGS@ @INDEX_CFLAGS@ @UI_CFLAGS@
 
 pinot_LDADD = -L../../../Utils -L../../../Tokenize -L../../../SQL -L../../../Monitor \
 	-L../../../Collect -L../../../Search -L../../../Search/Google \
 	-L../../../Index -lIndex @SEARCH_LIBS@ -lMonitor -lCollect -lSQL -lTokenize -lUtils \
-	@LIBS@ @UI_LIBS@ @INDEX_LIBS@ @SOAP_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
+	@LIBS@ @UI_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ @SOAP_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
 
+pinot_dbus_daemon_LDADD = -L../../../Utils -L../../../Tokenize -L../../../SQL -L../../../Monitor \
+	-L../../../Collect -L../../../Search -L../../../Search/Google \
+	-L../../../Index -lIndex @SEARCH_LIBS@ -lMonitor -lCollect -lSQL -lTokenize -lUtils \
+	@LIBS@ @UI_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ @SOAP_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
+



From fabricecolin at mail.berlios.de  Fri Aug  4 15:24:00 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 4 Aug 2006 15:24:00 +0200
Subject: [Pinot-svn] r373 - trunk/UI/GTK2/src
Message-ID: <200608041324.k74DO0Fw030802@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-04 15:23:59 +0200 (Fri, 04 Aug 2006)
New Revision: 373

Modified:
   trunk/UI/GTK2/src/pinot-dbus-daemon.cc
   trunk/UI/GTK2/src/pinot-dbus-daemon.xml
Log:
First functional version of the daemon. Updated Index method.


Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-04 12:21:01 UTC (rev 372)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-04 13:23:59 UTC (rev 373)
@@ -35,7 +35,6 @@
 }
 #include <glibmm/main.h>
 
-#include "DocumentInfo.h"
 #include "TokenizerFactory.h"
 #include "Languages.h"
 #include "MIMEScanner.h"
@@ -46,13 +45,14 @@
 #include "DownloaderInterface.h"
 #include "config.h"
 #include "NLS.h"
+#include "DaemonState.h"
 #include "PinotSettings.h"
 
 using namespace std;
 
-static ofstream outputFile;
-static streambuf *coutBuf = NULL;
-static streambuf *cerrBuf = NULL;
+static ofstream g_outputFile;
+static streambuf *g_coutBuf = NULL;
+static streambuf *g_cerrBuf = NULL;
 static struct option g_longOptions[] = {
 	{"help", 0, 0, 'h'},
 	{"version", 0, 0, 'v'},
@@ -79,15 +79,15 @@
 	TokenizerFactory::unloadTokenizers();
 
 	// Restore the stream buffers
-	if (coutBuf != NULL)
+	if (g_coutBuf != NULL)
 	{
-		cout.rdbuf(coutBuf);
+		cout.rdbuf(g_coutBuf);
 	}
-	if (cerrBuf != NULL)
+	if (g_cerrBuf != NULL)
 	{
-		cerr.rdbuf(cerrBuf);
+		cerr.rdbuf(g_cerrBuf);
 	}
-	outputFile.close();
+	g_outputFile.close();
 
 	DownloaderInterface::shutdown();
 	MIMEScanner::shutdown();
@@ -118,12 +118,14 @@
 
 static DBusHandlerResult messageBusFilter(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
 {
+	DaemonState *pServer = NULL;
 	DBusMessage *pReply = NULL;
 	bool processedMessage = false;
 
-#ifdef DEBUG
-	cout << "messageBusFilter: called" << endl;
-#endif
+	if (pData != NULL)
+	{
+		pServer = (DaemonState *)pData;
+	}
 
 	// Are we about to be disconnected ?
 	if (dbus_message_is_signal(pMessage, DBUS_INTERFACE_LOCAL, "Disconnected") == TRUE)
@@ -138,14 +140,22 @@
 	}
 	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "Index") == TRUE)
 	{
+		const char *pSender = dbus_message_get_sender(pMessage);
 		DBusError error;
 		char *pTitle = NULL;
 		char *pLocation = NULL;
 		char *pType = NULL;
 		char *pLanguage = NULL;
-		char *pLabel = NULL;
-		dbus_uint64_t docId = 0;
+		char **ppLabels = NULL;
+		dbus_uint32_t labelsCount = 0;
+		dbus_uint32_t docId = 0;
 
+#ifdef DEBUG
+		if (pSender != NULL)
+		{
+			cout << "messageBusFilter: called from " << pSender << endl;
+		}
+#endif
 		// Simple types are returned as const references and don't need to be freed
 		dbus_error_init(&error);
 		if (dbus_message_get_args(pMessage, &error,
@@ -153,29 +163,39 @@
 			DBUS_TYPE_STRING, &pLocation,
 			DBUS_TYPE_STRING, &pType,
 			DBUS_TYPE_STRING, &pLanguage,
-			DBUS_TYPE_STRING, &pLabel,
-			DBUS_TYPE_UINT64, &docId,
+			DBUS_TYPE_ARRAY, &ppLabels,
+			DBUS_TYPE_UINT32, &labelsCount,
 			DBUS_TYPE_INVALID) == TRUE)
 		{
 			DocumentInfo docInfo(pTitle, pLocation, pType, pLanguage);
 
 #ifdef DEBUG
 			cout << "messageBusFilter: received " << pTitle << ", " << pLocation
-				<< ", " << pType << ", " << pLanguage << ", " << pLabel
-				<< ", " << docId << endl;
+				<< ", " << pType << ", " << pLanguage << ", " << docId
+				<< " with " << labelsCount << " labels" << endl;
 #endif
+			// FIXME: set labels on docInfo
+
 			// FIXME: index docInfo
+			pServer->queue_index(docInfo);
 
+			// Free container types
+			g_strfreev(ppLabels);
+
 			// Prepare the reply
 			pReply = dbus_message_new_method_return(pMessage);
 			if (pReply != NULL)
 			{
 				dbus_message_append_args(pReply,
-					DBUS_TYPE_UINT64, &docId, DBUS_TYPE_INVALID);
+					DBUS_TYPE_UINT32, &docId,
+					DBUS_TYPE_INVALID);
 			}
 		}
 		else
 		{
+#ifdef DEBUG
+			cout << "messageBusFilter: " << error.message << endl;
+#endif
 			// Use the error message as reply
 			pReply = dbus_message_new_error(pMessage, error.name, error.message);
 		}
@@ -266,11 +286,11 @@
 	// Redirect cout and cerr to a file
 	string logFileName = confDirectory;
 	logFileName += "/pinot-dbus-daemon.log";
-	outputFile.open(logFileName.c_str());
-	coutBuf = cout.rdbuf();
-	cerrBuf = cerr.rdbuf();
-	cout.rdbuf(outputFile.rdbuf());
-	cerr.rdbuf(outputFile.rdbuf());
+	g_outputFile.open(logFileName.c_str());
+	g_coutBuf = cout.rdbuf();
+	g_cerrBuf = cerr.rdbuf();
+	cout.rdbuf(g_outputFile.rdbuf());
+	cerr.rdbuf(g_outputFile.rdbuf());
 
 	// Localize language names
 	Languages::setIntlName(0, _("Unknown"));
@@ -304,21 +324,15 @@
 	sigaction(SIGINT, &newAction, NULL);
 	sigaction(SIGQUIT, &newAction, NULL);
 
-#if 0
-	// Ensure Xapian will be able to deal with internal indices
-	XapianDatabase *pDb = XapianDatabaseFactory::getDatabase(settings.m_indexLocation, false);
+	// Open the index in read-write mode 
+	XapianDatabase *pDb = XapianDatabaseFactory::getDatabase(settings.m_daemonIndexLocation, false);
 	if ((pDb == NULL) ||
 		(pDb->isOpen() == false))
 	{
-		cerr << _("Couldn't open index") << " " << settings.m_indexLocation << endl;;
+		cerr << _("Couldn't open index") << " " << settings.m_daemonIndexLocation << endl;;
+
+		return EXIT_FAILURE;
 	}
-	pDb = XapianDatabaseFactory::getDatabase(settings.m_mailIndexLocation, false);
-	if ((pDb == NULL) ||
-		(pDb->isOpen() == false))
-	{
-		cerr << _("Couldn't open index") << " " << settings.m_mailIndexLocation << endl;
-	}
-#endif
 
 	// Do the same for the history database
 	if ((settings.m_historyDatabase.empty() == true) ||
@@ -326,6 +340,8 @@
 		(ViewHistory::create(settings.m_historyDatabase) == false))
 	{
 		cerr << _("Couldn't create history database") << " " << settings.m_historyDatabase << endl;
+
+		return EXIT_FAILURE;
 	}
 	else
 	{
@@ -340,7 +356,8 @@
 
 	atexit(closeAll);
 
-	// Initialize the D-Bus thread system
+	// Initialize the GType and the D-Bus thread system
+	g_type_init ();
 	dbus_g_thread_init();
 
 	GError *pError = NULL;
@@ -349,48 +366,59 @@
 	{
 		if (pError != NULL)
 		{
-			cerr << "Couldn't open connection: " << pError->message << endl;
+			cerr << "Couldn't open bus connection: " << pError->message << endl;
 			g_error_free(pError);
 		}
 
 		return EXIT_FAILURE;
 	}
 
-	// Listen for messages from all objects
 	DBusConnection *pConnection = dbus_g_connection_get_connection(pBus);
-	if (pConnection != NULL)
+	if (pConnection == NULL)
 	{
-		DBusError error;
+		cerr << "Couldn't get connection" << endl;
+		return EXIT_FAILURE;
+	}
 
-		dbus_error_init(&error);
-		dbus_connection_set_exit_on_disconnect(pConnection, FALSE);
-		dbus_connection_setup_with_g_main(pConnection, NULL);
+	DBusError error;
+	DaemonState server;
 
-		dbus_connection_add_filter(pConnection, messageBusFilter, NULL, NULL);
-		if (dbus_error_is_set(&error) == FALSE)
+	dbus_error_init(&error);
+	dbus_connection_set_exit_on_disconnect(pConnection, FALSE);
+	dbus_connection_setup_with_g_main(pConnection, NULL);
+
+	dbus_connection_add_filter(pConnection, messageBusFilter, &server, NULL);
+	if (dbus_error_is_set(&error) == FALSE)
+	{
+		// Request to be identified by this name
+		// FIXME: flags are currently broken ?
+		dbus_bus_request_name(pConnection, g_pinotDBusService, 0, &error);
+		if ((dbus_error_is_set(&error) == FALSE) &&
+			(dbus_connection_register_object_path(pConnection, g_pinotDBusObjectPath,
+				&g_callVTable, NULL) == TRUE))
 		{
-			// Request to be identified by this name
-			// FIXME: flags are currently broken ?
-			dbus_bus_request_name(pConnection, g_pinotDBusService, 0, &error);
-			if ((dbus_error_is_set(&error) == FALSE) &&
-				(dbus_connection_register_object_path(pConnection, g_pinotDBusObjectPath,
-					&g_callVTable, NULL) == TRUE))
-			{
-				// Run the main loop
-				g_refMainLoop = Glib::MainLoop::create();
-				g_refMainLoop->run();
-			}
-			else
-			{
-				cerr << "Couldn't register object path: " << pError->message << endl;
-			}
+			// Get the main loop
+			g_refMainLoop = Glib::MainLoop::create();
+
+			// Connect to threads' finished signal
+			server.connect();
+
+			server.start();
+
+			// Run the main loop
+			g_refMainLoop->run();
 		}
 		else
 		{
-			cerr << "Couldn't add filter: " << pError->message << endl;
+			cerr << "Couldn't register object path: " << pError->message << endl;
 		}
-		dbus_error_free(&error);
 	}
+	else
+	{
+		cerr << "Couldn't add filter: " << pError->message << endl;
+	}
+
+	dbus_error_free(&error);
 	dbus_connection_close(pConnection);
 	dbus_g_connection_unref(pBus);
 

Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.xml
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2006-08-04 12:21:01 UTC (rev 372)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2006-08-04 13:23:59 UTC (rev 373)
@@ -7,9 +7,9 @@
       <arg type="s" name="location" direction="in"/>
       <arg type="s" name="type" direction="in"/>
       <arg type="s" name="language" direction="in"/>
-      <arg type="s" name="label" direction="in"/>
-      <arg type="u" name="currentId" direction="in"/>
-      <arg type="u" name="newId" direction="out"/>
+      <arg type="as" name="labels" direction="in"/>
+      <arg type="u" name="labelsCount" direction="in"/>
+      <arg type="u" name="docId" direction="out"/>
     </method>
   </interface>
 </node>



From fabricecolin at mail.berlios.de  Sat Aug  5 06:39:24 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 5 Aug 2006 06:39:24 +0200
Subject: [Pinot-svn] r374 - trunk/UI/GTK2/src
Message-ID: <200608050439.k754dOdC002592@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-05 06:39:20 +0200 (Sat, 05 Aug 2006)
New Revision: 374

Modified:
   trunk/UI/GTK2/src/DaemonState.cpp
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
Log:
WorkerThread::immediateFlush() controls whether threads that modify indexes
should flush before returning. This is turned off for the daemon.


Modified: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2006-08-04 13:23:59 UTC (rev 373)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2006-08-05 04:39:20 UTC (rev 374)
@@ -21,6 +21,7 @@
 #include <glibmm/convert.h>
 #include <glibmm/thread.h>
 
+#include "WritableXapianIndex.h"
 #include "DaemonState.h"
 #include "OnDiskHandler.h"
 #include "PinotSettings.h"
@@ -45,6 +46,9 @@
 {
 	string locationToCrawl;
 
+	// Disable implicit flushing after a change
+	WorkerThread::immediateFlush(false);
+
 	for (set<PinotSettings::TimestampedItem>::const_iterator locationIter = PinotSettings::getInstance().m_indexableLocations.begin();
 		locationIter != PinotSettings::getInstance().m_indexableLocations.end(); ++locationIter)
 	{
@@ -169,6 +173,10 @@
 			unlock_lists();
 		}
 
+		// Explicitely flush the index once a directory has been crawled
+		WritableXapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
+		index.flush();
+
 		// Start a new scanner thread ?
 		if (pNewScannerThread != NULL)
 		{

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-04 13:23:59 UTC (rev 373)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-05 04:39:20 UTC (rev 374)
@@ -70,12 +70,18 @@
 };
 
 Dispatcher WorkerThread::m_dispatcher;
+bool WorkerThread::m_immediateFlush = true;
 
 Dispatcher &WorkerThread::getDispatcher(void)
 {
 	return m_dispatcher;
 }
 
+void WorkerThread::immediateFlush(bool doFlush)
+{
+	m_immediateFlush = doFlush;
+}
+
 WorkerThread::WorkerThread() :
 	m_joinable(true),
 	m_id(0),
@@ -1138,8 +1144,11 @@
 			}
 			else
 			{
-				// Flush the index
-				index.flush();
+				// Flush the index ?
+				if (m_immediateFlush == true)
+				{
+					index.flush();
+				}
 
 				// The document properties may have changed
 				index.getDocumentInfo(m_docId, m_docInfo);
@@ -1251,8 +1260,11 @@
 
 		if (m_docsCount > 0)
 		{
-			// Flush the index
-			index.flush();
+			// Flush the index ?
+			if (m_immediateFlush == true)
+			{
+				index.flush();
+			}
 
 			// Nothing to report
 			m_status = "";
@@ -1330,8 +1342,11 @@
 		}
 		else
 		{
-			// Flush the index
-			index.flush();
+			// Flush the index ?
+			if (m_immediateFlush == true)
+			{
+				index.flush();
+			}
 
 			// The document properties may have changed
 			index.getDocumentInfo(m_docId, m_docInfo);

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2006-08-04 13:23:59 UTC (rev 373)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2006-08-05 04:39:20 UTC (rev 374)
@@ -45,6 +45,8 @@
 
 		static Glib::Dispatcher &getDispatcher(void);
 
+		static void immediateFlush(bool doFlush);
+
 		void setId(unsigned int id);
 
 		unsigned int getId(void);
@@ -70,6 +72,7 @@
 	protected:
 		/// Use a Dispatcher for thread safety
 		static Glib::Dispatcher m_dispatcher;
+		static bool m_immediateFlush;
 		bool m_joinable;
 		unsigned int m_id;
 		bool m_background;



From fabricecolin at mail.berlios.de  Tue Aug  8 17:05:10 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Tue, 8 Aug 2006 17:05:10 +0200
Subject: [Pinot-svn] r375 - trunk/SQL
Message-ID: <200608081505.k78F5AmV001131@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-08 17:05:09 +0200 (Tue, 08 Aug 2006)
New Revision: 375

Added:
   trunk/SQL/CrawlHistory.cpp
   trunk/SQL/CrawlHistory.h
Modified:
   trunk/SQL/Makefile.am
Log:
First shot at CrawlHistory.


Added: trunk/SQL/CrawlHistory.cpp
===================================================================
--- trunk/SQL/CrawlHistory.cpp	2006-08-05 04:39:20 UTC (rev 374)
+++ trunk/SQL/CrawlHistory.cpp	2006-08-08 15:05:09 UTC (rev 375)
@@ -0,0 +1,281 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <iostream>
+
+#include "Url.h"
+#include "CrawlHistory.h"
+
+CrawlHistory::CrawlHistory(const string &database) :
+	SQLiteBase(database)
+{
+}
+
+CrawlHistory::~CrawlHistory()
+{
+}
+
+string CrawlHistory::statusToText(CrawlStatus status)
+{
+	string text;
+
+	switch (status)
+	{
+		case UNKNOWN:
+			text = "UNKNOWN";
+			break;
+		case CRAWLING:
+			text = "CRAWLING";
+			break;
+		case CRAWLED:
+			text = "CRAWLED";
+			break;
+		default:
+			break;
+	}
+
+	return text;
+}
+
+CrawlHistory::CrawlStatus CrawlHistory::textToStatus(const string &text)
+{
+	CrawlStatus status = UNKNOWN;
+
+	if (text == "CRAWLING")
+	{
+		status = CRAWLING;
+	}
+	else if (text == "CRAWLED")
+	{
+		status = CRAWLED;
+	}
+
+	return status;
+}
+
+/// Creates the CrawlHistory table in the database.
+bool CrawlHistory::create(const string &database)
+{
+	// The specified path must be a file
+	if (SQLiteBase::check(database) == false)
+	{
+		return false;
+	}
+
+	SQLiteBase db(database);
+
+	// Does CrawlSources exist ?
+	if (db.executeSimpleStatement("SELECT * FROM CrawlSources LIMIT 1;") == false)
+	{
+		if (db.executeSimpleStatement("CREATE TABLE CrawlSources (SourceID INTEGER \
+			PRIMARY KEY, Url VARCHAR(255));") == false)
+		{
+			return false;
+		}
+	}
+
+	// Does CrawlHistory exist ?
+	if (db.executeSimpleStatement("SELECT * FROM CrawlHistory LIMIT 1;") == false)
+	{
+		if (db.executeSimpleStatement("CREATE TABLE CrawlHistory (Url VARCHAR(255) \
+			PRIMARY KEY, Status VARCHAR(255), SourceID INTEGER, DATE INTEGER);") == false)
+		{
+			return false;
+		}
+	}
+
+	return true;
+}
+
+/// Inserts a source.
+unsigned int CrawlHistory::insertSource(const string &url)
+{
+	unsigned int sourceId = 0;
+
+	SQLiteResults *results = executeStatement("SELECT MAX(SourceID) FROM CrawlSources;");
+	if (results != NULL)
+	{
+		SQLiteRow *row = results->nextRow();
+		if (row != NULL)
+		{
+			sourceId = atoi(row->getColumn(0).c_str());
+			++sourceId;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	results = executeStatement("INSERT INTO CrawlSources \
+		VALUES('%u', '%q');",
+		sourceId, Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		delete results;
+	}
+
+	return sourceId;
+}
+
+/// Checks if the source exists.
+bool CrawlHistory::hasSource(const string &url, unsigned int &sourceId)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("SELECT SourceID FROM CrawlSources \
+		WHERE Url='%q';", Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row = results->nextRow();
+		if (row != NULL)
+		{
+			sourceId = atoi(row->getColumn(0).c_str());
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Deletes a source.
+bool CrawlHistory::deleteSource(unsigned int sourceId)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("DELETE FROM CrawlSources \
+		WHERE SourceID='%u';", sourceId);
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Inserts an URL.
+bool CrawlHistory::insertItem(const string &url, CrawlStatus status, unsigned int sourceId)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("INSERT INTO CrawlHistory \
+		VALUES('%q', '%q', '%u', '%d');",
+		Url::escapeUrl(url).c_str(), statusToText(status).c_str(), sourceId, time(NULL));
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Checks if an URL is in the history.
+bool CrawlHistory::hasItem(const string &url, CrawlStatus &status) const
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("SELECT Status FROM CrawlHistory \
+		WHERE Url='%q';", Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row = results->nextRow();
+		if (row != NULL)
+		{
+			status = textToStatus(row->getColumn(0));
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Updates an URL.
+bool CrawlHistory::updateItem(const string &url, CrawlStatus status)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("UPDATE CrawlHistory \
+		SET Status='%q', Date='%d' WHERE Url='%q';",
+		statusToText(status).c_str(), Url::escapeUrl(url).c_str(), time(NULL));
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Deletes an URL.
+bool CrawlHistory::deleteItem(const string &url)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("DELETE FROM CrawlHistory \
+		WHERE Url='%q';", Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Deletes URLs belonging to a source.
+bool CrawlHistory::deleteItems(unsigned int sourceId)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("DELETE FROM CrawlHistory \
+		WHERE SourceID='%u';", sourceId);
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Expires items older than the given date.
+bool CrawlHistory::expireItems(time_t expiryDate)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("DELETE FROM CrawlHistory \
+		WHERE Date<'%d';", expiryDate);
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}

Added: trunk/SQL/CrawlHistory.h
===================================================================
--- trunk/SQL/CrawlHistory.h	2006-08-05 04:39:20 UTC (rev 374)
+++ trunk/SQL/CrawlHistory.h	2006-08-08 15:05:09 UTC (rev 375)
@@ -0,0 +1,78 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _CRAWL_HISTORY_H
+#define _CRAWL_HISTORY_H
+
+#include <time.h>
+#include <string>
+
+#include "SQLiteBase.h"
+
+using namespace std;
+
+class CrawlHistory : public SQLiteBase
+{
+	public:
+		CrawlHistory(const string &database);
+		virtual ~CrawlHistory();
+
+		typedef enum { UNKNOWN, CRAWLING, CRAWLED } CrawlStatus;
+
+		/// Creates the CrawlHistory table in the database.
+		static bool create(const string &database);
+
+		/// Inserts a source.
+		unsigned int insertSource(const string &url);
+
+		/// Checks if the source exists.
+		bool hasSource(const string &url, unsigned int &sourceId);
+
+		/// Deletes a source.
+		bool deleteSource(unsigned int sourceId);
+
+		/// Inserts an URL.
+		bool insertItem(const string &url, CrawlStatus status, unsigned int sourceId);
+
+		/// Checks if an URL is in the history.
+		bool hasItem(const string &url, CrawlStatus &status) const;
+
+		/// Updates an URL.
+		bool updateItem(const string &url, CrawlStatus status);
+
+		/// Checks if an URL is in the history.
+		bool hasItem(const string &url) const;
+
+		/// Deletes an URL.
+		bool deleteItem(const string &url);
+
+		/// Deletes URLs belonging to a source.
+		bool deleteItems(unsigned int sourceId);
+
+		/// Expires items older than the given date.
+		bool expireItems(time_t expiryDate);
+
+	protected:
+		static string statusToText(CrawlStatus status);
+		static CrawlStatus textToStatus(const string &text);
+
+	private:
+		CrawlHistory(const CrawlHistory &other);
+		CrawlHistory &operator=(const CrawlHistory &other);
+
+};
+
+#endif // _CRAWL_HISTORY_H

Modified: trunk/SQL/Makefile.am
===================================================================
--- trunk/SQL/Makefile.am	2006-08-05 04:39:20 UTC (rev 374)
+++ trunk/SQL/Makefile.am	2006-08-08 15:05:09 UTC (rev 375)
@@ -1,6 +1,7 @@
 # Process this file with automake to produce Makefile.in
 
 noinst_HEADERS = \
+	CrawlHistory.h \
 	QueryHistory.h \
 	SQLiteBase.h \
 	ViewHistory.h
@@ -8,6 +9,7 @@
 noinst_LTLIBRARIES = libSQL.la
 
 libSQL_la_SOURCES = \
+	CrawlHistory.cpp \
 	QueryHistory.cpp \
 	SQLiteBase.cpp \
 	ViewHistory.cpp



From fabricecolin at mail.berlios.de  Wed Aug  9 04:53:16 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 9 Aug 2006 04:53:16 +0200
Subject: [Pinot-svn] r376 - trunk/UI/GTK2/src
Message-ID: <200608090253.k792rGig018526@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-09 04:53:12 +0200 (Wed, 09 Aug 2006)
New Revision: 376

Modified:
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
   trunk/UI/GTK2/src/pinot-dbus-daemon.cc
Log:
DirectoryScannerThread records directories in CrawlHistory. The table is created
at startup if necessary by the daemon program.


Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-08 15:05:09 UTC (rev 375)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-09 02:53:12 UTC (rev 376)
@@ -36,6 +36,7 @@
 #include "TimeConverter.h"
 #include "Url.h"
 #include "XapianDatabase.h"
+#include "CrawlHistory.h"
 #include "QueryHistory.h"
 #include "IndexedDocument.h"
 #include "MonitorFactory.h"
@@ -1553,7 +1554,8 @@
 	m_followSymLinks(followSymLinks),
 	m_pMutex(pMutex),
 	m_pCondVar(pCondVar),
-	m_currentLevel(0)
+	m_currentLevel(0),
+	m_sourceId(0)
 {
 #ifdef DEBUG
 	if (m_followSymLinks == true)
@@ -1663,10 +1665,25 @@
 	}
 	else if (S_ISDIR(fileStat.st_mode))
 	{
-		// A directory : scan it
+		CrawlHistory history(PinotSettings::getInstance().m_historyDatabase);
+		CrawlHistory::CrawlStatus status = CrawlHistory::UNKNOWN;
+
+		// A directory : check whether it has been crawled already
+		if ((history.hasItem(string("file://") + dirName, status) == true) &&
+			(status != CrawlHistory::UNKNOWN))
+		{
+			// Skip it
+#ifdef DEBUG
+			cout << "DirectoryScannerThread::scanDirectory: skipping " << dirName << endl;
+#endif
+			return true;
+		}
+
+		// Scan it !
 		DIR *pDir = opendir(dirName.c_str());
 		if (pDir == NULL)
 		{
+			history.insertItem(string("file://") + dirName, CrawlHistory::CRAWLED, m_sourceId);
 			return false;
 		}
 #ifdef DEBUG
@@ -1729,6 +1746,9 @@
 			pDirEntry = readdir(pDir);
 		}
 		closedir(pDir);
+
+		// Update the directory's status
+		history.insertItem(string("file://") + dirName, CrawlHistory::CRAWLED, m_sourceId);
 	}
 
 	return true;
@@ -1736,6 +1756,16 @@
 
 void DirectoryScannerThread::doWork(void)
 {
+	CrawlHistory history(PinotSettings::getInstance().m_historyDatabase);
+
+	// Does this source exist ?
+	if ((m_dirName.empty() == false) &&
+		(history.hasSource(string("file://") + m_dirName, m_sourceId) == false))
+	{
+		// Create it
+		m_sourceId = history.insertSource(string("file://") + m_dirName);
+	}
+
 	if (scanDirectory(m_dirName) == false)
 	{
 		m_status = _("Couldn't open directory");

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2006-08-08 15:05:09 UTC (rev 375)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2006-08-09 02:53:12 UTC (rev 376)
@@ -414,6 +414,7 @@
 		Glib::Mutex *m_pMutex;
 		Glib::Cond *m_pCondVar;
 		unsigned int m_currentLevel;
+		unsigned int m_sourceId;
 		SigC::Signal1<bool, const std::string&> m_signalFileFound;
 
 		void foundFile(const std::string &fileName);

Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-08 15:05:09 UTC (rev 375)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-09 02:53:12 UTC (rev 376)
@@ -40,6 +40,7 @@
 #include "MIMEScanner.h"
 #include "XapianDatabase.h"
 #include "XapianDatabaseFactory.h"
+#include "CrawlHistory.h"
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "DownloaderInterface.h"
@@ -336,6 +337,7 @@
 
 	// Do the same for the history database
 	if ((settings.m_historyDatabase.empty() == true) ||
+		(CrawlHistory::create(settings.m_historyDatabase) == false) ||
 		(QueryHistory::create(settings.m_historyDatabase) == false) ||
 		(ViewHistory::create(settings.m_historyDatabase) == false))
 	{



From fabricecolin at mail.berlios.de  Wed Aug  9 05:14:54 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 9 Aug 2006 05:14:54 +0200
Subject: [Pinot-svn] r377 - trunk/UI/GTK2/src
Message-ID: <200608090314.k793Esqn023930@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-09 05:14:51 +0200 (Wed, 09 Aug 2006)
New Revision: 377

Modified:
   trunk/UI/GTK2/src/DaemonState.cpp
Log:
Always run a DirectoryScanner thread for each indexable location.


Modified: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2006-08-09 02:53:12 UTC (rev 376)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2006-08-09 03:14:51 UTC (rev 377)
@@ -52,30 +52,15 @@
 	for (set<PinotSettings::TimestampedItem>::const_iterator locationIter = PinotSettings::getInstance().m_indexableLocations.begin();
 		locationIter != PinotSettings::getInstance().m_indexableLocations.end(); ++locationIter)
 	{
-		bool crawledLocation = false;
-
-		// Has this directory been crawled before ?
-		if (locationIter->m_modTime > 0)
+		if (locationToCrawl.empty() == true)
 		{
-			// FIXME: recrawl once in a while ?
-			crawledLocation = true;
+			// Crawl this now
+			locationToCrawl = locationIter->m_name;
 		}
-
-		if (crawledLocation == false)
-		{
-			if (locationToCrawl.empty() == true)
-			{
-				locationToCrawl = locationIter->m_name;
-			}
-			else
-			{
-				// This will be crawled next
-				m_crawlQueue.push(locationIter->m_name);
-			}
-		}
 		else
 		{
-			m_monitoredLocations.insert(locationIter->m_name);
+			// This will be crawled next
+			m_crawlQueue.push(locationIter->m_name);
 		}
 	}
 
@@ -91,7 +76,7 @@
 	}
 	else
 	{
-		// Fire up the disk monitor thread
+		// Fire up the disk monitor thread right away
 		OnDiskHandler *pDisk = new OnDiskHandler();
 		// Connect to its update signal
 		pDisk->getUpdateSignal().connect(
@@ -271,4 +256,3 @@
 	// Don't request another file right now
 	return false;
 }
-



From fabricecolin at mail.berlios.de  Wed Aug  9 06:39:32 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 9 Aug 2006 06:39:32 +0200
Subject: [Pinot-svn] r378 - trunk/UI/GTK2/src
Message-ID: <200608090439.k794dWkB004732@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-09 06:39:02 +0200 (Wed, 09 Aug 2006)
New Revision: 378

Modified:
   trunk/UI/GTK2/src/pinot-dbus-daemon.cc
   trunk/UI/GTK2/src/pinot-dbus-daemon.xml
Log:
New methods GetDocumentInfo and SimpleQuery.


Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-09 03:14:51 UTC (rev 377)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-09 04:39:02 UTC (rev 378)
@@ -44,6 +44,8 @@
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "DownloaderInterface.h"
+#include "XapianIndex.h"
+#include "XapianEngine.h"
 #include "config.h"
 #include "NLS.h"
 #include "DaemonState.h"
@@ -139,6 +141,68 @@
 
 		return DBUS_HANDLER_RESULT_HANDLED;
 	}
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "GetDocumentInfo") == TRUE)
+	{
+		const char *pSender = dbus_message_get_sender(pMessage);
+		DBusError error;
+		dbus_uint32_t docId = 0;
+
+#ifdef DEBUG
+		if (pSender != NULL)
+		{
+			cout << "messageBusFilter: called from " << pSender << endl;
+		}
+#endif
+		// Simple types are returned as const references and don't need to be freed
+		dbus_error_init(&error);
+		if (dbus_message_get_args(pMessage, &error,
+			DBUS_TYPE_UINT32, &docId,
+			DBUS_TYPE_INVALID) == TRUE)
+		{
+			XapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
+			DocumentInfo docInfo;
+
+#ifdef DEBUG
+			cout << "messageBusFilter: received " << docId << endl;
+#endif
+			if (index.getDocumentInfo(docId, docInfo) == true)
+			{
+				// Prepare the reply
+				pReply = dbus_message_new_method_return(pMessage);
+				if (pReply != NULL)
+				{
+					const char *pTitle = docInfo.getTitle().c_str();
+					const char *pLocation = docInfo.getLocation().c_str();
+					const char *pType = docInfo.getType().c_str();
+					const char *pLanguage = docInfo.getLanguage().c_str();
+
+					dbus_message_append_args(pReply,
+						DBUS_TYPE_STRING, &pTitle,
+						DBUS_TYPE_STRING, &pLocation,
+						DBUS_TYPE_STRING, &pType,
+						DBUS_TYPE_STRING, &pLanguage,
+						DBUS_TYPE_INVALID);
+				}
+			}
+			else
+			{
+				pReply = dbus_message_new_error(pMessage,
+					"de.berlios.Pinot.GetDocumentInfo",
+					"Unknown document");
+			}
+		}
+		else
+		{
+#ifdef DEBUG
+			cout << "messageBusFilter: " << error.message << endl;
+#endif
+			// Use the error message as reply
+			pReply = dbus_message_new_error(pMessage, error.name, error.message);
+		}
+		dbus_error_free(&error);
+
+		processedMessage = true;
+	}
 	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "Index") == TRUE)
 	{
 		const char *pSender = dbus_message_get_sender(pMessage);
@@ -177,7 +241,6 @@
 #endif
 			// FIXME: set labels on docInfo
 
-			// FIXME: index docInfo
 			pServer->queue_index(docInfo);
 
 			// Free container types
@@ -204,7 +267,110 @@
 
 		processedMessage = true;
 	}
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "SimpleQuery") == TRUE)
+	{
+		const char *pSender = dbus_message_get_sender(pMessage);
+		DBusError error;
+		char *pSearchText = NULL;
+		dbus_uint32_t maxHits = 0;
+		dbus_uint32_t docId = 0;
+
 #ifdef DEBUG
+		if (pSender != NULL)
+		{
+			cout << "messageBusFilter: called from " << pSender << endl;
+		}
+#endif
+		// Simple types are returned as const references and don't need to be freed
+		dbus_error_init(&error);
+		if (dbus_message_get_args(pMessage, &error,
+			DBUS_TYPE_STRING, &pSearchText,
+			DBUS_TYPE_UINT32, &maxHits,
+			DBUS_TYPE_INVALID) == TRUE)
+		{
+			XapianEngine engine(PinotSettings::getInstance().m_daemonIndexLocation);
+			QueryProperties queryProps;
+			bool replyWithError = true;
+
+#ifdef DEBUG
+			cout << "messageBusFilter: received " << pSearchText << ", " << maxHits << endl;
+#endif
+			if (pSearchText != NULL)
+			{
+				queryProps.setAndWords(pSearchText);
+
+				// Run the query
+				engine.setMaxResultsCount(maxHits);
+				if (engine.runQuery(queryProps) == true)
+				{
+					const vector<Result> &resultsList = engine.getResults();
+					dbus_uint32_t docIdsCount = resultsList.size();
+
+					if (docIdsCount > 0)
+					{
+						XapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
+						char *pDocIds[docIdsCount];
+						unsigned int resultIndex = 0;
+
+						for (vector<Result>::const_iterator resultIter = resultsList.begin();
+							resultIter != resultsList.end(); ++resultIter)
+						{
+							// We only need the document ID
+							unsigned int docId = index.hasDocument(resultIter->getLocation());
+
+							pDocIds[resultIndex] = g_strdup_printf("%u", docId);
+							++resultIndex;
+						}
+
+						// Prepare the reply
+						pReply = dbus_message_new_method_return(pMessage);
+						if (pReply != NULL)
+						{
+							dbus_message_append_args(pReply,
+								DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &pDocIds, &docIdsCount,
+								DBUS_TYPE_UINT32, &docIdsCount,
+								DBUS_TYPE_INVALID);
+
+							// Send the reply here
+							if (dbus_message_get_no_reply(pMessage) == FALSE)
+							{
+								dbus_connection_send(pConnection, pReply, NULL);
+							}
+							dbus_message_unref(pReply);
+
+							pReply = NULL;
+							replyWithError = false;
+						}
+
+						// Free the array
+						for (unsigned int resultNum = 0; resultNum < resultIndex; ++resultNum)
+						{
+							g_free(pDocIds[resultNum]);
+						}
+					}
+				}
+			}
+
+			if (replyWithError == true)
+			{
+				pReply = dbus_message_new_error(pMessage,
+					"de.berlios.Pinot.SimpleQuery",
+					"Query failed");
+			}
+		}
+		else
+		{
+#ifdef DEBUG
+			cout << "messageBusFilter: " << error.message << endl;
+#endif
+			// Use the error message as reply
+			pReply = dbus_message_new_error(pMessage, error.name, error.message);
+		}
+		dbus_error_free(&error);
+
+		processedMessage = true;
+	}
+#ifdef DEBUG
 	else cout << "messageBusFilter: message for foreign object" << endl;
 #endif
 
@@ -214,13 +380,7 @@
 		if (dbus_message_get_no_reply(pMessage) == FALSE)
 		{
 			dbus_connection_send(pConnection, pReply, NULL);
-#ifdef DEBUG
-			cout << "messageBusFilter: sent reply" << endl;
-#endif
 		}
-#ifdef DEBUG
-		else cout << "messageBusFilter: no need to send a reply" << endl;
-#endif
 
 		dbus_message_unref(pReply);
 	}

Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.xml
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2006-08-09 03:14:51 UTC (rev 377)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2006-08-09 04:39:02 UTC (rev 378)
@@ -1,6 +1,14 @@
 <?xml version="1.0" encoding="UTF-8" ?>
 <node name="/de/berlios/Pinot">
   <interface name="de.berlios.Pinot">
+    <method name="GetDocumentInfo">
+      <annotation name="de.berlios.Pinot.GetDocumentInfo" value="pinotDBus"/>
+      <arg type="u" name="docId" direction="in"/>
+      <arg type="s" name="title" direction="out"/>
+      <arg type="s" name="location" direction="out"/>
+      <arg type="s" name="type" direction="out"/>
+      <arg type="s" name="language" direction="out"/>
+    </method>
     <method name="Index">
       <annotation name="de.berlios.Pinot.Index" value="pinotDBus"/>
       <arg type="s" name="title" direction="in"/>
@@ -11,5 +19,12 @@
       <arg type="u" name="labelsCount" direction="in"/>
       <arg type="u" name="docId" direction="out"/>
     </method>
+    <method name="SimpleQuery">
+      <annotation name="de.berlios.Pinot.SimpleQuery" value="pinotDBus"/>
+      <arg type="s" name="searchText" direction="in" />
+      <arg type="u" name="maxHits" direction="in" />
+      <arg type="as" name="docIds" direction="out" />
+      <arg type="u" name="docIdsCount" direction="out"/>
+    </method>
   </interface>
 </node>



From fabricecolin at mail.berlios.de  Wed Aug  9 07:58:10 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 9 Aug 2006 07:58:10 +0200
Subject: [Pinot-svn] r379 - in trunk: . UI/GTK2/src
Message-ID: <200608090558.k795wApn025920@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-09 07:58:07 +0200 (Wed, 09 Aug 2006)
New Revision: 379

Added:
   trunk/UI/GTK2/src/de.berlios.Pinot.service.in
   trunk/UI/GTK2/src/pinot-dbus-daemon.1
   trunk/acinclude.m4
Modified:
   trunk/Makefile.am
   trunk/configure.in
   trunk/pinot.spec.in
Log:
Man page and DBus service file for the daemon program.
acinclude.m4 defines a useful macro for variables expansion, copied from
Rapha?\195?\171l Slinckx's tutorial at "http://raphael.slinckx.net/dbustutorial.php".


Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2006-08-09 04:39:02 UTC (rev 378)
+++ trunk/Makefile.am	2006-08-09 05:58:07 UTC (rev 379)
@@ -5,13 +5,16 @@
 	Index Monitor UI/GTK2/src
 
 EXTRA_DIST = ChangeLog NEWS README TODO mkinstalldirs pinot.desktop \
-	pinot.spec textcat_conf.txt Search/Plugins/*src Search/Plugins/*.xml \
-	Collect/pinot-collect.1 Search/pinot-search.1 UI/GTK2/src/pinot.1 \
-	globalconfig.xml UI/GTK2/xapian-powered.png UI/GTK2/pinot.png \
-	UI/GTK2/metase-gtk2.glade UI/GTK2/metase-gtk2.gladep \
-	UI/GTK2/src/pinot-dbus-daemon.xml
+	pinot.spec textcat_conf.txt globalconfig.xml \
+	Search/Plugins/*src Search/Plugins/*.xml \
+	Collect/pinot-collect.1 Index/pinot-index.1 Search/pinot-search.1 \
+	UI/GTK2/src/pinot.1 UI/GTK2/src/pinot-dbus-daemon.1 \
+	UI/GTK2/src/pinot-dbus-daemon.xml UI/GTK2/src/de.berlios.Pinot.service \
+	UI/GTK2/xapian-powered.png UI/GTK2/pinot.png \
+	UI/GTK2/metase-gtk2.glade UI/GTK2/metase-gtk2.gladep
 
-man_MANS = Collect/pinot-collect.1 Search/pinot-search.1 UI/GTK2/src/pinot.1
+man_MANS = Collect/pinot-collect.1 Index/pinot-index.1 Search/pinot-search.1 \
+	UI/GTK2/src/pinot.1 UI/GTK2/src/pinot-dbus-daemon.1
 
 install-data-local:
 	$(mkinstalldirs) $(DESTDIR)$(datadir)/pinot
@@ -20,6 +23,7 @@
 	$(INSTALL_DATA) UI/GTK2/metase-gtk2.glade $(DESTDIR)$(datadir)/pinot/metase-gtk2.glade
 	$(INSTALL_DATA) UI/GTK2/metase-gtk2.gladep $(DESTDIR)$(datadir)/pinot/metase-gtk2.gladep
 	$(INSTALL_DATA) UI/GTK2/src/pinot-dbus-daemon.xml $(DESTDIR)$(datadir)/pinot/pinot-dbus-daemon.xml
+	$(INSTALL_DATA) UI/GTK2/src/de.berlios.Pinot.service $(DESTDIR)$(DBUS_SERVICES_DIR)
 	$(INSTALL_DATA) textcat_conf.txt $(DESTDIR)$(datadir)/pinot/textcat_conf.txt
 	$(mkinstalldirs) $(DESTDIR)$(datadir)/pinot/engines
 	$(INSTALL_DATA) Search/Plugins/*.src $(DESTDIR)$(datadir)/pinot/engines/

Added: trunk/UI/GTK2/src/de.berlios.Pinot.service.in
===================================================================
--- trunk/UI/GTK2/src/de.berlios.Pinot.service.in	2006-08-09 04:39:02 UTC (rev 378)
+++ trunk/UI/GTK2/src/de.berlios.Pinot.service.in	2006-08-09 05:58:07 UTC (rev 379)
@@ -0,0 +1,3 @@
+[D-BUS Service]
+Name=de.berlios.Pinot
+Exec=@DBUS_SERVICES_DIR@/pinot-dbus-daemon

Added: trunk/UI/GTK2/src/pinot-dbus-daemon.1
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.1	2006-08-09 04:39:02 UTC (rev 378)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.1	2006-08-09 05:58:07 UTC (rev 379)
@@ -0,0 +1,22 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
+.TH PINOT-DBUS-DAEMON "1" "August 2006" "pinot-dbus-daemon - pinot 0.50" "User Commands"
+.SH NAME
+pinot-dbus-daemon \- D-Bus search and index daemon
+.SH SYNOPSIS
+.B pinot-dbus-daemon
+[\fIOPTIONS\fR]
+.SH DESCRIPTION
+pinot\-dbus\-daemon \- D\-Bus search and index daemon
+.SH OPTIONS
+.TP
+\fB\-h\fR, \fB\-\-help\fR
+display this help and exit
+.TP
+\fB\-v\fR, \fB\-\-version\fR
+output version information and exit
+.SH "REPORTING BUGS"
+Report bugs to fabricecolin at users.berlios.de
+.PP
+This is free software.  You may redistribute copies of it under the terms of
+the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
+There is NO WARRANTY, to the extent permitted by law.

Added: trunk/acinclude.m4
===================================================================
--- trunk/acinclude.m4	2006-08-09 04:39:02 UTC (rev 378)
+++ trunk/acinclude.m4	2006-08-09 05:58:07 UTC (rev 379)
@@ -0,0 +1,42 @@
+dnl AS_AC_EXPAND(VAR, CONFIGURE_VAR)
+dnl
+dnl by Rapha?l Slinckx (http://raphael.slinckx.net/dbustutorial.php)
+dnl
+dnl example
+dnl AS_AC_EXPAND(SYSCONFDIR, $sysconfdir)
+dnl will set SYSCONFDIR to /usr/local/etc if prefix=/usr/local
+
+AC_DEFUN([AS_AC_EXPAND],
+[
+  EXP_VAR=[$1]
+  FROM_VAR=[$2]
+
+  dnl first expand prefix and exec_prefix if necessary
+  prefix_save=$prefix
+  exec_prefix_save=$exec_prefix
+
+  dnl if no prefix given, then use /usr/local, the default prefix
+  if test "x$prefix" = "xNONE"; then
+    prefix=$ac_default_prefix
+  fi
+  dnl if no exec_prefix given, then use prefix
+  if test "x$exec_prefix" = "xNONE"; then
+    exec_prefix=$prefix
+  fi
+
+  full_var="$FROM_VAR"
+  dnl loop until it doesn't change anymore
+  while true; do
+    new_full_var="`eval echo $full_var`"
+    if test "x$new_full_var"="x$full_var"; then break; fi
+    full_var=$new_full_var
+  done
+
+  dnl clean up
+  full_var=$new_full_var
+  AC_SUBST([$1], "$full_var")
+
+  dnl restore prefix and exec_prefix
+  prefix=$prefix_save
+  exec_prefix=$exec_prefix_save
+])

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2006-08-09 04:39:02 UTC (rev 378)
+++ trunk/configure.in	2006-08-09 05:58:07 UTC (rev 379)
@@ -46,6 +46,13 @@
 		[Define to the package prefix.])
 fi
 
+dnl Set DBUS_SERVICES_DIR in de.berlios.Pinot.service.
+AS_AC_EXPAND(DATADIR, $datadir)
+DBUS_SERVICES_DIR="$DATADIR/dbus-1/services"
+AC_SUBST(DBUS_SERVICES_DIR)
+AC_DEFINE_UNQUOTED(DBUS_SERVICES_DIR, "$DBUS_SERVICES_DIR",
+		[Define to the DBUS services directory.])
+
 AC_LANG_CPLUSPLUS
 
 AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
@@ -182,7 +189,8 @@
 AC_CHECK_FUNCS(lstat)
 AC_CHECK_FUNCS(mmap)
 
-AC_OUTPUT( pinot.spec Makefile Utils/Makefile Tokenize/Makefile )
+AC_OUTPUT( pinot.spec UI/GTK2/src/de.berlios.Pinot.service )
+AC_OUTPUT( Makefile Utils/Makefile Tokenize/Makefile )
 AC_OUTPUT( SQL/Makefile po/Makefile.in Collect/Makefile )
 if test "$SOAP_SUBDIRS" != "" ; then
   AC_OUTPUT( Search/Google/Makefile )

Modified: trunk/pinot.spec.in
===================================================================
--- trunk/pinot.spec.in	2006-08-09 04:39:02 UTC (rev 378)
+++ trunk/pinot.spec.in	2006-08-09 05:58:07 UTC (rev 379)
@@ -70,6 +70,8 @@
 %doc ChangeLog COPYING NEWS README TODO
 %{_bindir}/pinot
 %ghost %{_bindir}/pinot-collect
+%{_bindir}/pinot-dbus-daemon
+%{_bindir}/pinot-index
 %{_bindir}/pinot-search
 %{_datadir}/pinot/globalconfig.xml
 %{_datadir}/pinot/xapian-powered.png
@@ -77,6 +79,7 @@
 %{_datadir}/pinot/metase-gtk2.gladep
 %{_datadir}/pinot/pinot-dbus-daemon.xml
 %{_datadir}/pinot/textcat_conf.txt
+%{_datadir}/dbus-1/services/de.berlios.Pinot.service
 %{_datadir}/pinot/*.src
 %dir %{_datadir}/pinot/engines/
 %config(noreplace) %{_datadir}/pinot/engines/A9.src
@@ -88,6 +91,7 @@
 %config(noreplace) %{_datadir}/pinot/engines/Exalead.src
 %config(noreplace) %{_datadir}/pinot/engines/Freshmeat.src
 %config(noreplace) %{_datadir}/pinot/engines/Google.src
+%config(noreplace) %{_datadir}/pinot/engines/MozDexDescription.xml
 %config(noreplace) %{_datadir}/pinot/engines/MSN.src
 %config(noreplace) %{_datadir}/pinot/engines/RollYOTopNews.src
 %config(noreplace) %{_datadir}/pinot/engines/Topix.src
@@ -102,6 +106,8 @@
 %{_datadir}/applications/Amra-pinot.desktop
 %{_mandir}/man1/pinot.*
 %ghost %{_mandir}/man1/pinot-collect.*
+%{_mandir}/man1/pinot-dbus-daemon.*
+%{_mandir}/man1/pinot-index.*
 %{_mandir}/man1/pinot-search.*
 
 %files text-docs 



From fabricecolin at mail.berlios.de  Wed Aug  9 07:58:59 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 9 Aug 2006 07:58:59 +0200
Subject: [Pinot-svn] r380 - trunk/Search/Plugins
Message-ID: <200608090558.k795wxZu026000@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-09 07:58:58 +0200 (Wed, 09 Aug 2006)
New Revision: 380

Added:
   trunk/Search/Plugins/MozDexDescription.xml
Log:
Brought MozDex plugin back in.


Added: trunk/Search/Plugins/MozDexDescription.xml
===================================================================
--- trunk/Search/Plugins/MozDexDescription.xml	2006-08-09 05:58:07 UTC (rev 379)
+++ trunk/Search/Plugins/MozDexDescription.xml	2006-08-09 05:58:58 UTC (rev 380)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<OpenSearchDescription xmlns="http://a9.com/-/spec/opensearchdescription/1.0/">
+  <Url>http://www.mozdex.com/open.jsp?query={searchTerms}&amp;start={startIndex}</Url>
+  <Format>http://a9.com/-/spec/opensearchrss/1.0/</Format>
+  <ShortName>Mozdex</ShortName>
+  <LongName>Mozdex Search Engine</LongName>
+  <Description>Search the Internet at Mozdex.com.</Description>
+  <Tags>The Web</Tags>
+  <Image>http://www.mozdex.com/spec/ico-64-unavailable.gif</Image>
+  <SampleSearch>linux</SampleSearch>
+  <Developer>Mozdex.com</Developer>
+  <Contact>byronm at gmail.com</Contact>
+  <Attribution>Search data &amp;copy; 2005, Small Productions,
+   All Rights Reserved</Attribution>
+  <SyndicationRight>open</SyndicationRight>
+  <AdultContent>false</AdultContent>
+</OpenSearchDescription>



From fabricecolin at mail.berlios.de  Wed Aug  9 09:36:10 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 9 Aug 2006 09:36:10 +0200
Subject: [Pinot-svn] r381 - trunk/UI/GTK2/src
Message-ID: <200608090736.k797aABc024191@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-09 09:36:07 +0200 (Wed, 09 Aug 2006)
New Revision: 381

Modified:
   trunk/UI/GTK2/src/pinot-dbus-daemon.cc
   trunk/UI/GTK2/src/pinot-dbus-daemon.xml
Log:
Fixed handling of Disconnected, added methods GetStatistics and Stop.


Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-09 05:58:58 UTC (rev 380)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-09 07:36:07 UTC (rev 381)
@@ -123,7 +123,7 @@
 {
 	DaemonState *pServer = NULL;
 	DBusMessage *pReply = NULL;
-	bool processedMessage = false;
+	bool processedMessage = false, quitLoop = false;
 
 	if (pData != NULL)
 	{
@@ -133,13 +133,8 @@
 	// Are we about to be disconnected ?
 	if (dbus_message_is_signal(pMessage, DBUS_INTERFACE_LOCAL, "Disconnected") == TRUE)
 	{
-		// FIXME: is this legal ?
-		Glib::RefPtr<Glib::MainLoop> g_refMainLoop = Glib::MainLoop::create(true);
-
-		// Tell the main loop to quit
-		g_refMainLoop->quit();
-
-		return DBUS_HANDLER_RESULT_HANDLED;
+		quitLoop = true;
+		processedMessage = true;
 	}
 	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "GetDocumentInfo") == TRUE)
 	{
@@ -203,6 +198,36 @@
 
 		processedMessage = true;
 	}
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "GetStatistics") == TRUE)
+	{
+		const char *pSender = dbus_message_get_sender(pMessage);
+		DBusError error;
+		dbus_uint32_t docId = 0;
+
+#ifdef DEBUG
+		if (pSender != NULL)
+		{
+			cout << "messageBusFilter: called from " << pSender << endl;
+		}
+#endif
+		XapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
+		CrawlHistory history(PinotSettings::getInstance().m_historyDatabase);
+
+		unsigned int crawledDirsCount = history.getItemsCount();
+		unsigned int docsCount = index.getDocumentsCount();
+
+		// Prepare the reply
+		pReply = dbus_message_new_method_return(pMessage);
+		if (pReply != NULL)
+		{
+			dbus_message_append_args(pReply,
+				DBUS_TYPE_UINT32, &crawledDirsCount,
+				DBUS_TYPE_UINT32, &docsCount,
+				DBUS_TYPE_INVALID);
+		}
+
+		processedMessage = true;
+	}
 	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "Index") == TRUE)
 	{
 		const char *pSender = dbus_message_get_sender(pMessage);
@@ -370,6 +395,30 @@
 
 		processedMessage = true;
 	}
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "Stop") == TRUE)
+	{
+		DBusError error;
+
+		dbus_error_init(&error);
+		if (dbus_message_get_args(pMessage, &error,
+			DBUS_TYPE_INVALID) == TRUE)
+		{
+			int exitStatus = EXIT_SUCCESS;
+
+			// Prepare the reply
+			pReply = dbus_message_new_method_return(pMessage);
+			if (pReply != NULL)
+			{
+				dbus_message_append_args(pReply,
+					DBUS_TYPE_INT32, &exitStatus,
+					DBUS_TYPE_INVALID);
+			}
+
+			quitLoop = true;
+			processedMessage = true;
+		}
+		dbus_error_free(&error);
+	}
 #ifdef DEBUG
 	else cout << "messageBusFilter: message for foreign object" << endl;
 #endif
@@ -385,6 +434,11 @@
 		dbus_message_unref(pReply);
 	}
 
+	if (quitLoop == true)
+	{
+		quitAll(0);
+	}
+
 	if (processedMessage == true)
 	{
 		return DBUS_HANDLER_RESULT_HANDLED;

Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.xml
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2006-08-09 05:58:58 UTC (rev 380)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2006-08-09 07:36:07 UTC (rev 381)
@@ -1,6 +1,15 @@
 <?xml version="1.0" encoding="UTF-8" ?>
 <node name="/de/berlios/Pinot">
   <interface name="de.berlios.Pinot">
+    <!--
+	Retrieves information about a document.
+	 docId: the document's ID
+	 title : title of the document (automatically extracted from document if possible
+	         or the file name otherwise)
+	 location: the document's URL (eg "file:///home/fabrice/Documents/SomeFile.txt")
+	 type: the document's MIME type
+	 language: the document's language in English, as extracted at indexing time
+	-->
     <method name="GetDocumentInfo">
       <annotation name="de.berlios.Pinot.GetDocumentInfo" value="pinotDBus"/>
       <arg type="u" name="docId" direction="in"/>
@@ -9,6 +18,27 @@
       <arg type="s" name="type" direction="out"/>
       <arg type="s" name="language" direction="out"/>
     </method>
+    <!--
+	Retrieves statistics.
+	 crawledDirsCount: the number of directories that have been crawled prior
+	                   to entering monitoring mode
+	 docsCount: the number of documents in the index
+	-->
+    <method name="GetStatistics">
+      <annotation name="de.berlios.Pinot.GetStatistics" value="pinotDBus"/>
+      <arg type="u" name="crawledDirsCount" direction="out"/>
+      <arg type="u" name="docsCount" direction="out"/>
+    </method>
+    <!--
+	Indexes a document (NOT FULLY FUNCTIONAL YET)
+	 title : title of the document
+	 location: the document's URL
+	 type: the document's MIME type
+	 language: the document's language in English
+	 labels: array of labels to apply to the document
+	 labelsCount: the number of labels in the array
+	 docId: the document's ID
+	-->
     <method name="Index">
       <annotation name="de.berlios.Pinot.Index" value="pinotDBus"/>
       <arg type="s" name="title" direction="in"/>
@@ -19,6 +49,13 @@
       <arg type="u" name="labelsCount" direction="in"/>
       <arg type="u" name="docId" direction="out"/>
     </method>
+    <!--
+	Queries the index.
+	 searchText : search text, as would be entered in Pinot's live query field
+	 maxHits: the maximum number of hits desired
+	 docIds: array of document IDs
+	 docIdsCount: the number of document IDs in the array
+	-->
     <method name="SimpleQuery">
       <annotation name="de.berlios.Pinot.SimpleQuery" value="pinotDBus"/>
       <arg type="s" name="searchText" direction="in" />
@@ -26,5 +63,13 @@
       <arg type="as" name="docIds" direction="out" />
       <arg type="u" name="docIdsCount" direction="out"/>
     </method>
+    <!--
+	Stops the daemon program.
+	 exitStatus: the daemon's exit status.
+	-->
+    <method name="Stop">
+      <annotation name="de.berlios.Pinot.Stop" value="pinotDBus"/>
+      <arg type="i" name="exitStatus" direction="out" />
+    </method>
   </interface>
 </node>



From fabricecolin at mail.berlios.de  Wed Aug  9 09:37:05 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 9 Aug 2006 09:37:05 +0200
Subject: [Pinot-svn] r382 - trunk/SQL
Message-ID: <200608090737.k797b58n024979@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-09 09:36:46 +0200 (Wed, 09 Aug 2006)
New Revision: 382

Modified:
   trunk/SQL/CrawlHistory.cpp
   trunk/SQL/CrawlHistory.h
Log:
Added getItemsCount().


Modified: trunk/SQL/CrawlHistory.cpp
===================================================================
--- trunk/SQL/CrawlHistory.cpp	2006-08-09 07:36:07 UTC (rev 381)
+++ trunk/SQL/CrawlHistory.cpp	2006-08-09 07:36:46 UTC (rev 382)
@@ -191,6 +191,28 @@
 	return success;
 }
 
+/// Returns the number of URLs.
+unsigned int CrawlHistory::getItemsCount(void) const
+{
+	unsigned int count = 0;
+
+	SQLiteResults *results = executeStatement("SELECT COUNT(*) FROM CrawlHistory;");
+	if (results != NULL)
+	{
+		SQLiteRow *row = results->nextRow();
+		if (row != NULL)
+		{
+			count = atoi(row->getColumn(0).c_str());
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return count;
+}
+
 /// Checks if an URL is in the history.
 bool CrawlHistory::hasItem(const string &url, CrawlStatus &status) const
 {

Modified: trunk/SQL/CrawlHistory.h
===================================================================
--- trunk/SQL/CrawlHistory.h	2006-08-09 07:36:07 UTC (rev 381)
+++ trunk/SQL/CrawlHistory.h	2006-08-09 07:36:46 UTC (rev 382)
@@ -53,6 +53,9 @@
 		/// Updates an URL.
 		bool updateItem(const string &url, CrawlStatus status);
 
+		/// Returns the number of URLs.
+		unsigned int getItemsCount(void) const;
+
 		/// Checks if an URL is in the history.
 		bool hasItem(const string &url) const;
 



From fabricecolin at mail.berlios.de  Wed Aug  9 11:45:35 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 9 Aug 2006 11:45:35 +0200
Subject: [Pinot-svn] r383 - trunk/SQL
Message-ID: <200608090945.k799jZm9001665@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-09 11:45:34 +0200 (Wed, 09 Aug 2006)
New Revision: 383

Modified:
   trunk/SQL/CrawlHistory.cpp
   trunk/SQL/CrawlHistory.h
   trunk/SQL/SQLiteBase.cpp
Log:
Some modifications to CrawlHistory to accomodate MboxHandler.
SQLiteBase sets up a busy handler so that we always retry operations
if the database file is locked.


Modified: trunk/SQL/CrawlHistory.cpp
===================================================================
--- trunk/SQL/CrawlHistory.cpp	2006-08-09 07:36:46 UTC (rev 382)
+++ trunk/SQL/CrawlHistory.cpp	2006-08-09 09:45:34 UTC (rev 383)
@@ -175,13 +175,14 @@
 }
 
 /// Inserts an URL.
-bool CrawlHistory::insertItem(const string &url, CrawlStatus status, unsigned int sourceId)
+bool CrawlHistory::insertItem(const string &url, CrawlStatus status, unsigned int sourceId, time_t date)
 {
 	bool success = false;
 
 	SQLiteResults *results = executeStatement("INSERT INTO CrawlHistory \
 		VALUES('%q', '%q', '%u', '%d');",
-		Url::escapeUrl(url).c_str(), statusToText(status).c_str(), sourceId, time(NULL));
+		Url::escapeUrl(url).c_str(), statusToText(status).c_str(), sourceId,
+		(date == 0 ? time(NULL) : date));
 	if (results != NULL)
 	{
 		success = true;
@@ -191,34 +192,12 @@
 	return success;
 }
 
-/// Returns the number of URLs.
-unsigned int CrawlHistory::getItemsCount(void) const
-{
-	unsigned int count = 0;
-
-	SQLiteResults *results = executeStatement("SELECT COUNT(*) FROM CrawlHistory;");
-	if (results != NULL)
-	{
-		SQLiteRow *row = results->nextRow();
-		if (row != NULL)
-		{
-			count = atoi(row->getColumn(0).c_str());
-
-			delete row;
-		}
-
-		delete results;
-	}
-
-	return count;
-}
-
 /// Checks if an URL is in the history.
-bool CrawlHistory::hasItem(const string &url, CrawlStatus &status) const
+bool CrawlHistory::hasItem(const string &url, CrawlStatus &status, time_t &date) const
 {
 	bool success = false;
 
-	SQLiteResults *results = executeStatement("SELECT Status FROM CrawlHistory \
+	SQLiteResults *results = executeStatement("SELECT Status, Date FROM CrawlHistory \
 		WHERE Url='%q';", Url::escapeUrl(url).c_str());
 	if (results != NULL)
 	{
@@ -226,6 +205,7 @@
 		if (row != NULL)
 		{
 			status = textToStatus(row->getColumn(0));
+			date = (time_t)atoi(row->getColumn(1).c_str());
 			success = true;
 
 			delete row;
@@ -238,13 +218,14 @@
 }
 
 /// Updates an URL.
-bool CrawlHistory::updateItem(const string &url, CrawlStatus status)
+bool CrawlHistory::updateItem(const string &url, CrawlStatus status, time_t date)
 {
 	bool success = false;
 
 	SQLiteResults *results = executeStatement("UPDATE CrawlHistory \
 		SET Status='%q', Date='%d' WHERE Url='%q';",
-		statusToText(status).c_str(), Url::escapeUrl(url).c_str(), time(NULL));
+		statusToText(status).c_str(), (date == 0 ? time(NULL) : date),
+		Url::escapeUrl(url).c_str());
 	if (results != NULL)
 	{
 		success = true;
@@ -254,6 +235,28 @@
 	return success;
 }
 
+/// Returns the number of URLs.
+unsigned int CrawlHistory::getItemsCount(void) const
+{
+	unsigned int count = 0;
+
+	SQLiteResults *results = executeStatement("SELECT COUNT(*) FROM CrawlHistory;");
+	if (results != NULL)
+	{
+		SQLiteRow *row = results->nextRow();
+		if (row != NULL)
+		{
+			count = atoi(row->getColumn(0).c_str());
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return count;
+}
+
 /// Deletes an URL.
 bool CrawlHistory::deleteItem(const string &url)
 {

Modified: trunk/SQL/CrawlHistory.h
===================================================================
--- trunk/SQL/CrawlHistory.h	2006-08-09 07:36:46 UTC (rev 382)
+++ trunk/SQL/CrawlHistory.h	2006-08-09 09:45:34 UTC (rev 383)
@@ -45,13 +45,13 @@
 		bool deleteSource(unsigned int sourceId);
 
 		/// Inserts an URL.
-		bool insertItem(const string &url, CrawlStatus status, unsigned int sourceId);
+		bool insertItem(const string &url, CrawlStatus status, unsigned int sourceId, time_t date);
 
 		/// Checks if an URL is in the history.
-		bool hasItem(const string &url, CrawlStatus &status) const;
+		bool hasItem(const string &url, CrawlStatus &status, time_t &date) const;
 
 		/// Updates an URL.
-		bool updateItem(const string &url, CrawlStatus status);
+		bool updateItem(const string &url, CrawlStatus status, time_t date);
 
 		/// Returns the number of URLs.
 		unsigned int getItemsCount(void) const;

Modified: trunk/SQL/SQLiteBase.cpp
===================================================================
--- trunk/SQL/SQLiteBase.cpp	2006-08-09 07:36:46 UTC (rev 382)
+++ trunk/SQL/SQLiteBase.cpp	2006-08-09 09:45:34 UTC (rev 383)
@@ -26,6 +26,12 @@
 using std::cout;
 using std::endl;
 
+static int busyHandler(void *pData, int lockNum)
+{
+	// Try again
+	return 1;
+}
+
 SQLiteRow::SQLiteRow(const vector<string> &rowColumns, int nColumns) :
 	m_nColumns(nColumns)
 {
@@ -195,6 +201,8 @@
 #ifdef DEBUG
 	else cout << "SQLiteBase::open: opened " << database << endl;
 #endif
+	// Set up a busy handler
+	sqlite3_busy_handler(pDatabase, busyHandler, NULL);
 
 	return pDatabase;
 }



From fabricecolin at mail.berlios.de  Wed Aug  9 11:46:09 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 9 Aug 2006 11:46:09 +0200
Subject: [Pinot-svn] r384 - in trunk: . UI/GTK2/src
Message-ID: <200608090946.k799k9cH001767@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-09 11:46:09 +0200 (Wed, 09 Aug 2006)
New Revision: 384

Modified:
   trunk/Makefile.am
   trunk/UI/GTK2/src/de.berlios.Pinot.service.in
   trunk/configure.in
Log:
Fixes.


Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2006-08-09 09:45:34 UTC (rev 383)
+++ trunk/Makefile.am	2006-08-09 09:46:09 UTC (rev 384)
@@ -17,13 +17,13 @@
 	UI/GTK2/src/pinot.1 UI/GTK2/src/pinot-dbus-daemon.1
 
 install-data-local:
-	$(mkinstalldirs) $(DESTDIR)$(datadir)/pinot
+	$(mkinstalldirs) $(DESTDIR)$(datadir)/pinot $(DESTDIR)$(datadir)/dbus-1/services
 	$(INSTALL_DATA) globalconfig.xml $(DESTDIR)$(datadir)/pinot/globalconfig.xml
 	$(INSTALL_DATA) UI/GTK2/xapian-powered.png $(DESTDIR)$(datadir)/pinot/xapian-powered.png
 	$(INSTALL_DATA) UI/GTK2/metase-gtk2.glade $(DESTDIR)$(datadir)/pinot/metase-gtk2.glade
 	$(INSTALL_DATA) UI/GTK2/metase-gtk2.gladep $(DESTDIR)$(datadir)/pinot/metase-gtk2.gladep
 	$(INSTALL_DATA) UI/GTK2/src/pinot-dbus-daemon.xml $(DESTDIR)$(datadir)/pinot/pinot-dbus-daemon.xml
-	$(INSTALL_DATA) UI/GTK2/src/de.berlios.Pinot.service $(DESTDIR)$(DBUS_SERVICES_DIR)
+	$(INSTALL_DATA) UI/GTK2/src/de.berlios.Pinot.service $(DESTDIR)$(datadir)/dbus-1/services/de.berlios.Pinot.service
 	$(INSTALL_DATA) textcat_conf.txt $(DESTDIR)$(datadir)/pinot/textcat_conf.txt
 	$(mkinstalldirs) $(DESTDIR)$(datadir)/pinot/engines
 	$(INSTALL_DATA) Search/Plugins/*.src $(DESTDIR)$(datadir)/pinot/engines/

Modified: trunk/UI/GTK2/src/de.berlios.Pinot.service.in
===================================================================
--- trunk/UI/GTK2/src/de.berlios.Pinot.service.in	2006-08-09 09:45:34 UTC (rev 383)
+++ trunk/UI/GTK2/src/de.berlios.Pinot.service.in	2006-08-09 09:46:09 UTC (rev 384)
@@ -1,3 +1,3 @@
 [D-BUS Service]
 Name=de.berlios.Pinot
-Exec=@DBUS_SERVICES_DIR@/pinot-dbus-daemon
+Exec=@BINDIR@/pinot-dbus-daemon

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2006-08-09 09:45:34 UTC (rev 383)
+++ trunk/configure.in	2006-08-09 09:46:09 UTC (rev 384)
@@ -48,7 +48,9 @@
 
 dnl Set DBUS_SERVICES_DIR in de.berlios.Pinot.service.
 AS_AC_EXPAND(DATADIR, $datadir)
+AS_AC_EXPAND(BINDIR, $bindir)
 DBUS_SERVICES_DIR="$DATADIR/dbus-1/services"
+AC_SUBST(BINDIR)
 AC_SUBST(DBUS_SERVICES_DIR)
 AC_DEFINE_UNQUOTED(DBUS_SERVICES_DIR, "$DBUS_SERVICES_DIR",
 		[Define to the DBUS services directory.])



From fabricecolin at mail.berlios.de  Wed Aug  9 12:09:02 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 9 Aug 2006 12:09:02 +0200
Subject: [Pinot-svn] r385 - trunk/UI/GTK2/src
Message-ID: <200608091009.k79A92hE005428@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-09 12:09:02 +0200 (Wed, 09 Aug 2006)
New Revision: 385

Modified:
   trunk/UI/GTK2/src/DaemonState.cpp
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/pinot-dbus-daemon.cc
   trunk/UI/GTK2/src/pinot.cc
Log:
Mail monitoring and indexing is now handled by the daemon program too.


Modified: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2006-08-09 09:46:09 UTC (rev 384)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2006-08-09 10:09:02 UTC (rev 385)
@@ -23,6 +23,7 @@
 
 #include "WritableXapianIndex.h"
 #include "DaemonState.h"
+#include "MboxHandler.h"
 #include "OnDiskHandler.h"
 #include "PinotSettings.h"
 #include "PinotUtils.h"
@@ -49,6 +50,14 @@
 	// Disable implicit flushing after a change
 	WorkerThread::immediateFlush(false);
 
+	// Fire up the mail monitor thread now
+	MboxHandler *pMbox = new MboxHandler();
+	// Connect to its update signal
+	pMbox->getUpdateSignal().connect(
+		SigC::slot(*this, &DaemonState::on_message_indexupdate));
+	MonitorThread *pMailMonitorThread = new MonitorThread(pMbox);
+	start_thread(pMailMonitorThread, true);
+
 	for (set<PinotSettings::TimestampedItem>::const_iterator locationIter = PinotSettings::getInstance().m_indexableLocations.begin();
 		locationIter != PinotSettings::getInstance().m_indexableLocations.end(); ++locationIter)
 	{
@@ -64,7 +73,7 @@
 		}
 	}
 
-	// ANything to crawl before starting monitoring ?
+	// Anything to crawl before starting monitoring ?
 	if (locationToCrawl.empty() == false)
 	{
 		// Scan the directory and import all its files
@@ -81,9 +90,8 @@
 		// Connect to its update signal
 		pDisk->getUpdateSignal().connect(
 			SigC::slot(*this, &DaemonState::on_message_indexupdate));
-		MonitorThread *pMonitorThread = new MonitorThread(pDisk);
-		start_thread(pMonitorThread, true);
-		// The handler object will be deleted when the thread terminates
+		MonitorThread *pDiskMonitorThread = new MonitorThread(pDisk);
+		start_thread(pDiskMonitorThread, true);
 	}
 }
 
@@ -176,7 +184,6 @@
 				SigC::slot(*this, &DaemonState::on_message_indexupdate));
 			MonitorThread *pMonitorThread = new MonitorThread(pDisk);
 			start_thread(pMonitorThread, true);
-			// The handler object will be deleted when the thread terminates
 		}
 	}
 	else if (type == "IndexingThread")
@@ -225,14 +232,7 @@
 	}
 	else if (type == "MonitorThread")
 	{
-		// Fire up another disk monitor thread
-		OnDiskHandler *pDisk = new OnDiskHandler();
-		// Connect to its update signal
-		pDisk->getUpdateSignal().connect(
-			SigC::slot(*this, &DaemonState::on_message_indexupdate));
-		MonitorThread *pMonitorThread = new MonitorThread(pDisk);
-		start_thread(pMonitorThread, true);
-		// The handler object will be deleted when the thread terminates
+		// FIXME: do something about this
 	}
 
 	// Delete the thread

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2006-08-09 09:46:09 UTC (rev 384)
+++ trunk/UI/GTK2/src/mainWindow.cc	2006-08-09 10:09:02 UTC (rev 385)
@@ -47,7 +47,6 @@
 #include "SearchEngineFactory.h"
 #include "config.h"
 #include "NLS.h"
-#include "MboxHandler.h"
 #include "PinotUtils.h"
 #include "mainWindow.hh"
 #include "importDialog.hh"
@@ -179,16 +178,6 @@
 	// Connect to threads' finished signal
 	m_state.connect();
 
-	// FIXME: delete all "ignored" threads when exiting !!!
-	// Fire up the mail monitor thread
-	MboxHandler *pMbox = new MboxHandler();
-	// Connect to its update signal
-	pMbox->getUpdateSignal().connect(
-		SigC::slot(*this, &mainWindow::on_message_indexupdate));
-	MonitorThread *pMonitorThread = new MonitorThread(pMbox);
-	start_thread(pMonitorThread, true);
-	// The handler object will be deleted when the thread terminates
-
 	// Now we are ready
 	set_status(_("Ready"));
 	m_pNotebook->show();
@@ -203,6 +192,8 @@
 //
 mainWindow::~mainWindow()
 {
+	// FIXME: delete all "ignored" threads when exiting !!!
+
 	// Save engines
 	m_pEnginesTree->save();
 
@@ -1234,10 +1225,6 @@
 		}
 		// Else, stay silent
 	}
-	else if (type == "MonitorThread")
-	{
-		// FIXME: do something about this
-	}
 	else if (type == "UpdateDocumentThread")
 	{
 		UpdateDocumentThread *pUpdateThread = dynamic_cast<UpdateDocumentThread *>(pThread);
@@ -1381,9 +1368,6 @@
 	cout << "mainWindow::on_configure_activate: settings changed" << endl;
 #endif
 
-	// FIXME: if mail accounts are configured, make sure the MonitorThread
-	// is running and knows about the new accounts
-
 	if (m_state.read_lock_lists() == true)
 	{
 		for (int pageNum = 0; pageNum < m_pNotebook->get_n_pages(); ++pageNum)

Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-09 09:46:09 UTC (rev 384)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-09 10:09:02 UTC (rev 385)
@@ -539,15 +539,21 @@
 	sigaction(SIGINT, &newAction, NULL);
 	sigaction(SIGQUIT, &newAction, NULL);
 
-	// Open the index in read-write mode 
+	// Open these indices in read-write mode 
 	XapianDatabase *pDb = XapianDatabaseFactory::getDatabase(settings.m_daemonIndexLocation, false);
 	if ((pDb == NULL) ||
 		(pDb->isOpen() == false))
 	{
-		cerr << _("Couldn't open index") << " " << settings.m_daemonIndexLocation << endl;;
+		cerr << _("Couldn't open index") << " " << settings.m_daemonIndexLocation << endl;
 
 		return EXIT_FAILURE;
 	}
+	pDb = XapianDatabaseFactory::getDatabase(settings.m_mailIndexLocation, false);
+	if ((pDb == NULL) ||
+		(pDb->isOpen() == false))
+	{
+		cerr << _("Couldn't open index") << " " << settings.m_mailIndexLocation << endl;
+	}
 
 	// Do the same for the history database
 	if ((settings.m_historyDatabase.empty() == true) ||

Modified: trunk/UI/GTK2/src/pinot.cc
===================================================================
--- trunk/UI/GTK2/src/pinot.cc	2006-08-09 09:46:09 UTC (rev 384)
+++ trunk/UI/GTK2/src/pinot.cc	2006-08-09 10:09:02 UTC (rev 385)
@@ -184,7 +184,7 @@
 	sigaction(SIGINT, &newAction, NULL);
 	sigaction(SIGQUIT, &newAction, NULL);
 
-	// Open these indexes read-write
+	// Open this index read-write
 	XapianDatabase *pDb = XapianDatabaseFactory::getDatabase(settings.m_docsIndexLocation, false);
 	if ((pDb == NULL) ||
 		(pDb->isOpen() == false))
@@ -193,7 +193,8 @@
 		errorMsg += " ";
 		errorMsg += settings.m_docsIndexLocation;
 	}
-	pDb = XapianDatabaseFactory::getDatabase(settings.m_mailIndexLocation, false);
+	// ...and the mail and daemon indices in read-only mode
+	pDb = XapianDatabaseFactory::getDatabase(settings.m_mailIndexLocation);
 	if ((pDb == NULL) ||
 		(pDb->isOpen() == false))
 	{
@@ -201,7 +202,6 @@
 		errorMsg += " ";
 		errorMsg += settings.m_mailIndexLocation;
 	}
-	// ...the daemon's index in read-only mode
 	pDb = XapianDatabaseFactory::getDatabase(settings.m_daemonIndexLocation);
 	if ((pDb == NULL) ||
 		(pDb->isOpen() == false))



From fabricecolin at mail.berlios.de  Wed Aug  9 12:11:59 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 9 Aug 2006 12:11:59 +0200
Subject: [Pinot-svn] r386 - trunk/UI/GTK2/src
Message-ID: <200608091011.k79ABxfe006900@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-09 12:11:58 +0200 (Wed, 09 Aug 2006)
New Revision: 386

Modified:
   trunk/UI/GTK2/src/MboxHandler.cpp
   trunk/UI/GTK2/src/MboxHandler.h
   trunk/UI/GTK2/src/ModelColumns.cpp
   trunk/UI/GTK2/src/ModelColumns.h
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/PinotSettings.h
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/prefsDialog.cc
Log:
MboxHandler uses CrawlHistory to record which files have been crawled and when.
In PinotSettings, MailAccount and use of Gdk::Color were dropped.


Modified: trunk/UI/GTK2/src/MboxHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-09 10:09:02 UTC (rev 385)
+++ trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-09 10:11:58 UTC (rev 386)
@@ -30,31 +30,38 @@
 #include "TokenizerFactory.h"
 #include "FileCollector.h"
 #include "WritableXapianIndex.h"
-#include "PinotUtils.h"
 #include "MboxHandler.h"
 
 using namespace std;
 using namespace SigC;
 
 MboxHandler::MboxHandler() :
-	MonitorHandler()
+	MonitorHandler(),
+	m_history(PinotSettings::getInstance().m_historyDatabase),
+	m_sourceId(0)
 {
+	// Does the email source exist ?
+	if (m_history.hasSource("My Email", m_sourceId) == false)
+	{
+		// Create it
+		m_sourceId = m_history.insertSource("My Email");
+	}
 }
 
 MboxHandler::~MboxHandler()
 {
 }
 
-bool MboxHandler::checkMailAccount(const string &fileName, PinotSettings::MailAccount &mailAccount,
-	off_t &previousSize)
+bool MboxHandler::checkMailAccount(const string &fileName, PinotSettings::TimestampedItem &mailAccount)
 {
 	struct stat fileStat;
+	CrawlHistory::CrawlStatus status;
+	time_t lastModDate = 0;
+	mailAccount.m_name = fileName;
 
-	mailAccount.m_name = to_utf8(fileName);
-
 	// Ensure it's one of our mail accounts
-	set<PinotSettings::MailAccount> &mailAccounts = PinotSettings::getInstance().m_mailAccounts;
-	set<PinotSettings::MailAccount>::iterator mailIter = mailAccounts.find(mailAccount);
+	set<PinotSettings::TimestampedItem> &mailAccounts = PinotSettings::getInstance().m_mailAccounts;
+	set<PinotSettings::TimestampedItem>::iterator mailIter = mailAccounts.find(mailAccount);
 	if (mailIter == mailAccounts.end())
 	{
 		// It doesn't seem to be
@@ -72,30 +79,32 @@
 		return false;
 	}
 
-	if (fileStat.st_mtime <= mailIter->m_modTime)
+	// Is there a record for this mail account ?
+	if (m_history.hasItem("file://" + fileName, status, lastModDate) == true)
 	{
-		// No change since last time...
+		if (fileStat.st_mtime <= lastModDate)
+		{
+			// No change since last time...
 #ifdef DEBUG
-		cout << "MboxHandler::checkMailAccount: not modified since last time ("
-			<< mailIter->m_modTime << ">" << fileStat.st_mtime << ")" << endl;
+			cout << "MboxHandler::checkMailAccount: not modified since last time ("
+				<< lastModDate << ">" << fileStat.st_mtime << ")" << endl;
 #endif
-		return false;
+			return false;
+		}
 	}
-#ifdef DEBUG
-	cout << "MboxHandler::checkMailAccount: modified since last time ("
-		<< mailIter->m_modTime << "<" << fileStat.st_mtime << ")" << endl;
-#endif
+	else
+	{
+		m_history.insertItem("file://" + fileName, CrawlHistory::CRAWLING, m_sourceId, time(NULL));
+	}
 
 	// Update this mail account's properties
 	mailAccount = (*mailIter);
 	mailAccount.m_modTime = fileStat.st_mtime;
-	previousSize = mailAccount.m_size;
-	mailAccount.m_size = fileStat.st_size;
 
 	return true;
 }
 
-bool MboxHandler::indexMessages(const string &fileName, PinotSettings::MailAccount &mailAccount,
+bool MboxHandler::indexMessages(const string &fileName, PinotSettings::TimestampedItem &mailAccount,
 	off_t mboxOffset)
 {
 	string sourceLabel("mailbox://");
@@ -114,26 +123,19 @@
 	// Get a parser
 	MboxParser boxParser(fileName, mboxOffset);
 
-	bool indexedFile = parseMailAccount(boxParser, &index,
-		mailAccount.m_lastMessageTime, sourceLabel);
+	bool indexedFile = parseMailAccount(boxParser, &index, sourceLabel);
 
 	// Flush the index
 	index.flush();
 
-	// Update this mail account in the list
-	set<PinotSettings::MailAccount> &mailAccounts = PinotSettings::getInstance().m_mailAccounts;
-	set<PinotSettings::MailAccount>::iterator mailIter = mailAccounts.find(mailAccount);
-	if (mailIter != mailAccounts.end())
-	{
-		mailAccounts.erase(mailIter);
-	}
-	mailAccounts.insert(mailAccount);
+	// Update this mail account's record
+	m_history.updateItem("file://" + fileName, CrawlHistory::CRAWLED, mailAccount.m_modTime);
 
 	return indexedFile;
 }
 
 bool MboxHandler::parseMailAccount(MboxParser &boxParser, WritableIndexInterface *pIndex,
-	time_t &lastMessageTime, const string &sourceLabel)
+	const string &sourceLabel)
 {
 	set<unsigned int> docIdList;
 	bool indexedFile = false;
@@ -182,12 +184,6 @@
 			{
 				time_t messageDate = boxParser.getDate();
 
-				if (messageDate > lastMessageTime)
-				{
-					// This is the latest message so far
-					lastMessageTime = messageDate;
-				}
-
 				pIndex->setDocumentLabels(docId, labels);
 
 				IndexedDocument docInfo(pMessage->getTitle(),
@@ -279,8 +275,8 @@
 		inserter(locationsToRemove, locationsToRemove.begin()));
 
 	// Get the mail accounts map
-	set<PinotSettings::MailAccount> &mailAccounts = PinotSettings::getInstance().m_mailAccounts;
-	for (set<PinotSettings::MailAccount>::iterator mailIter = mailAccounts.begin();
+	set<PinotSettings::TimestampedItem> &mailAccounts = PinotSettings::getInstance().m_mailAccounts;
+	for (set<PinotSettings::TimestampedItem>::iterator mailIter = mailAccounts.begin();
 		mailIter != mailAccounts.end(); ++mailIter)
 	{
 		// Is this a known location ?
@@ -329,13 +325,12 @@
 
 bool MboxHandler::fileExists(const string &fileName)
 {
-	PinotSettings::MailAccount mailAccount;
-	off_t previousSize = 0;
+	PinotSettings::TimestampedItem mailAccount;
 
 #ifdef DEBUG
 	cout << "MboxHandler::fileExists: " << fileName << endl;
 #endif
-	if (checkMailAccount(fileName, mailAccount, previousSize) == false)
+	if (checkMailAccount(fileName, mailAccount) == false)
 	{
 		return false;
 	}
@@ -351,33 +346,18 @@
 
 bool MboxHandler::fileModified(const string &fileName)
 {
-	PinotSettings::MailAccount mailAccount;
-	off_t previousSize = 0, mboxOffset = 0;
+	PinotSettings::TimestampedItem mailAccount;
 
 #ifdef DEBUG
 	cout << "MboxHandler::fileModified: " << fileName << " changed" << endl;
 #endif
-	if (checkMailAccount(fileName, mailAccount, previousSize) == false)
+	if (checkMailAccount(fileName, mailAccount) == false)
 	{
 		return false;
 	}
 
-	if (mailAccount.m_size <= previousSize)
-	{
-		// Parse the file from the beginning...
-#ifdef DEBUG
-		cout << "MboxHandler::fileModified: file smaller or same size" << endl;
-#endif
-		return fileExists(fileName);
-	}
-#ifdef DEBUG
-	else cout << "MboxHandler::fileModified: file now larger than " << previousSize << endl;
-#endif
-
-	// Chances are new messages were added but none removed
-	mboxOffset = previousSize;
-
-	return indexMessages(fileName, mailAccount, mboxOffset);
+	// Parse the file in whole
+	return indexMessages(fileName, mailAccount, 0);
 }
 
 bool MboxHandler::fileMoved(const string &fileName, const string &previousFileName)
@@ -389,7 +369,7 @@
 bool MboxHandler::fileDeleted(const string &fileName)
 {
 	set<unsigned int> docIdList;
-	string sourceLabel(string("mailbox://"));
+	string sourceLabel("mailbox://");
 
 	sourceLabel += fileName;
 

Modified: trunk/UI/GTK2/src/MboxHandler.h
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.h	2006-08-09 10:09:02 UTC (rev 385)
+++ trunk/UI/GTK2/src/MboxHandler.h	2006-08-09 10:11:58 UTC (rev 386)
@@ -24,6 +24,7 @@
 
 #include "IndexedDocument.h"
 #include "MboxParser.h"
+#include "CrawlHistory.h"
 #include "IndexInterface.h"
 #include "MonitorHandler.h"
 #include "PinotSettings.h"
@@ -55,16 +56,17 @@
 		virtual bool fileDeleted(const std::string &fileName);
 
 	protected:
+		CrawlHistory m_history;
 		std::set<std::string> m_locations;
+		unsigned int m_sourceId;
 
-		bool checkMailAccount(const std::string &fileName, PinotSettings::MailAccount &mailAccount,
-			off_t &previousSize);
+		bool checkMailAccount(const std::string &fileName, PinotSettings::TimestampedItem &mailAccount);
 
-		bool indexMessages(const std::string &fileName, PinotSettings::MailAccount &mailAccount,
+		bool indexMessages(const std::string &fileName, PinotSettings::TimestampedItem &mailAccount,
 			off_t mboxOffset);
 
 		bool parseMailAccount(MboxParser &boxParser, WritableIndexInterface *pIndex,
-			time_t &lastMessageTime, const std::string &sourceLabel);
+			const std::string &sourceLabel);
 
 		bool deleteMessages(WritableIndexInterface *pIndex, std::set<unsigned int> &docIdList);
 

Modified: trunk/UI/GTK2/src/ModelColumns.cpp
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.cpp	2006-08-09 10:09:02 UTC (rev 385)
+++ trunk/UI/GTK2/src/ModelColumns.cpp	2006-08-09 10:11:58 UTC (rev 386)
@@ -108,9 +108,7 @@
 MailAccountModelColumns::MailAccountModelColumns()
 {
 	add(m_location);
-	add(m_type);
 	add(m_mTime);
-	add(m_minDate);
 }
 
 MailAccountModelColumns::~MailAccountModelColumns()

Modified: trunk/UI/GTK2/src/ModelColumns.h
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.h	2006-08-09 10:09:02 UTC (rev 385)
+++ trunk/UI/GTK2/src/ModelColumns.h	2006-08-09 10:11:58 UTC (rev 386)
@@ -140,9 +140,7 @@
 	virtual ~MailAccountModelColumns();
 
 	Gtk::TreeModelColumn<Glib::ustring> m_location;
-	Gtk::TreeModelColumn<Glib::ustring> m_type;
 	Gtk::TreeModelColumn<time_t> m_mTime;
-	Gtk::TreeModelColumn<time_t> m_minDate;
 
 };
 

Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2006-08-09 10:09:02 UTC (rev 385)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2006-08-09 10:11:58 UTC (rev 386)
@@ -91,7 +91,9 @@
 	m_expandQueries(true),
 	m_ignoreRobotsDirectives(false),
 	m_suggestQueryTerms(true),
-	m_newResultsColour("red"),
+	m_newResultsColourRed(65535),
+	m_newResultsColourGreen(0),
+	m_newResultsColourBlue(0),
 	m_firstRun(false)
 {
 	// Find out if there is a .pinot directory
@@ -678,15 +680,15 @@
 
 		if (nodeName == "red")
 		{
-			m_newResultsColour.set_red(value);
+			m_newResultsColourRed = value;
 		}
 		else if (nodeName == "green")
 		{
-			m_newResultsColour.set_green(value);
+			m_newResultsColourGreen = value;
 		}
 		else if (nodeName == "blue")
 		{
-			m_newResultsColour.set_blue(value);
+			m_newResultsColourBlue = value;
 		}
 	}
 
@@ -706,7 +708,7 @@
 		return false;
 	}
 
-	MailAccount mailAccount;
+	TimestampedItem mailAccount;
 
 	// Load the mail account's properties
 	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
@@ -729,18 +731,6 @@
 		{
 			mailAccount.m_modTime = (time_t)atoi(nodeContent.c_str());
 		}
-		else if (nodeName == "type")
-		{
-			mailAccount.m_type = nodeContent;
-		}
-		else if (nodeName == "mindate")
-		{
-			mailAccount.m_lastMessageTime = (time_t)atoi(nodeContent.c_str());
-		}
-		else if (nodeName == "size")
-		{
-			mailAccount.m_size = (off_t)atoi(nodeContent.c_str());
-		}
 	}
 
 	if (mailAccount.m_name.empty() == false)
@@ -779,7 +769,7 @@
 		string nodeName = pElem->get_name();
 		string nodeContent = getElementContent(pElem);
 
-		if (nodeName == "location")
+		if (nodeName == "name")
 		{
 			location.m_name = nodeContent;
 		}
@@ -1026,16 +1016,16 @@
 	{
 		return false;
 	}
-	sprintf(numStr, "%u", m_newResultsColour.get_red());
+	sprintf(numStr, "%u", m_newResultsColourRed);
 	addChildElement(pElem, "red", numStr);
-	sprintf(numStr, "%u", m_newResultsColour.get_green());
+	sprintf(numStr, "%u", m_newResultsColourGreen);
 	addChildElement(pElem, "green", numStr);
-	sprintf(numStr, "%u", m_newResultsColour.get_blue());
+	sprintf(numStr, "%u", m_newResultsColourBlue);
 	addChildElement(pElem, "blue", numStr);
 	// Enable terms suggestion
 	addChildElement(pRootElem, "suggestterms", (m_suggestQueryTerms ? "YES" : "NO"));
 	// Mail accounts
-	for (set<MailAccount>::iterator mailIter = m_mailAccounts.begin(); mailIter != m_mailAccounts.end(); ++mailIter)
+	for (set<TimestampedItem>::iterator mailIter = m_mailAccounts.begin(); mailIter != m_mailAccounts.end(); ++mailIter)
 	{
 		pElem = pRootElem->add_child("mailaccount");
 		if (pElem == NULL)
@@ -1043,13 +1033,8 @@
 			return false;
 		}
 		addChildElement(pElem, "name", mailIter->m_name);
-		addChildElement(pElem, "type", mailIter->m_type);
 		sprintf(numStr, "%ld", mailIter->m_modTime);
 		addChildElement(pElem, "mtime", numStr);
-		sprintf(numStr, "%ld", mailIter->m_lastMessageTime);
-		addChildElement(pElem, "mindate", numStr);
-		sprintf(numStr, "%ld", mailIter->m_size);
-		addChildElement(pElem, "size", numStr);
 	}
 	// Locations to index 
 	for (set<TimestampedItem>::iterator locationIter = m_indexableLocations.begin(); locationIter != m_indexableLocations.end(); ++locationIter)
@@ -1059,7 +1044,7 @@
 		{
 			return false;
 		}
-		addChildElement(pElem, "location", locationIter->m_name);
+		addChildElement(pElem, "name", locationIter->m_name);
 		sprintf(numStr, "%ld", locationIter->m_modTime);
 		addChildElement(pElem, "mtime", numStr);
 	}
@@ -1417,45 +1402,6 @@
 	return false;
 }
 
-PinotSettings::MailAccount::MailAccount() :
-	TimestampedItem(),
-	m_lastMessageTime(0),
-	m_size(0)
-{
-}
-
-PinotSettings::MailAccount::MailAccount(const MailAccount &other) :
-	TimestampedItem(other),
-	m_type(other.m_type),
-	m_lastMessageTime(other.m_lastMessageTime),
-	m_size(other.m_size)
-{
-}
-
-PinotSettings::MailAccount::~MailAccount()
-{
-}
-
-PinotSettings::MailAccount &PinotSettings::MailAccount::operator=(const MailAccount &other)
-{
-	TimestampedItem::operator=(other);
-	m_type = other.m_type;
-	m_lastMessageTime = other.m_lastMessageTime;
-	m_size = other.m_size;
-
-	return *this;
-}
-
-bool PinotSettings::MailAccount::operator<(const MailAccount &other) const
-{
-	return TimestampedItem::operator<(other);
-}
-
-bool PinotSettings::MailAccount::operator==(const MailAccount &other) const
-{
-	return TimestampedItem::operator==(other);
-}
-
 PinotSettings::CacheProvider::CacheProvider()
 {
 }

Modified: trunk/UI/GTK2/src/PinotSettings.h
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.h	2006-08-09 10:09:02 UTC (rev 385)
+++ trunk/UI/GTK2/src/PinotSettings.h	2006-08-09 10:11:58 UTC (rev 386)
@@ -24,7 +24,6 @@
 #include <set>
 #include <vector>
 #include <glibmm/ustring.h>
-#include <gdkmm/color.h>
 #include <libxml++/nodes/element.h>
 
 #include "QueryProperties.h"
@@ -140,22 +139,6 @@
 				time_t m_modTime;
 		};
 
-		class MailAccount : public TimestampedItem
-		{
-			public:
-				MailAccount();
-				MailAccount(const MailAccount &other);
-				~MailAccount();
-
-				MailAccount &operator=(const MailAccount &other);
-				bool operator<(const MailAccount &other) const;
-				bool operator==(const MailAccount &other) const;
-
-				Glib::ustring m_type;
-				time_t m_lastMessageTime;
-				off_t m_size;
-		};
-
 		class CacheProvider
 		{
 			public:
@@ -185,8 +168,10 @@
 		bool m_expandQueries;
 		bool m_ignoreRobotsDirectives;
 		bool m_suggestQueryTerms;
-		Gdk::Color m_newResultsColour;
-		std::set<MailAccount> m_mailAccounts;
+		unsigned short m_newResultsColourRed;
+		unsigned short m_newResultsColourGreen;
+		unsigned short m_newResultsColourBlue;
+		std::set<TimestampedItem> m_mailAccounts;
 		std::set<TimestampedItem> m_indexableLocations;
 		std::vector<CacheProvider> m_cacheProviders;
 		std::set<Glib::ustring> m_cacheProtocols;

Modified: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2006-08-09 10:09:02 UTC (rev 385)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2006-08-09 10:11:58 UTC (rev 386)
@@ -16,6 +16,7 @@
 
 #include <ctype.h>
 #include <iostream>
+#include <gdkmm/color.h>
 #include <gtkmm/alignment.h>
 #include <gtkmm/box.h>
 #include <gtkmm/buttonbox.h>
@@ -275,8 +276,14 @@
 		// Is this result new ?
 		if (row[m_resultsColumns.m_rankDiff] == 666)
 		{
+			Color newColour;
+
+			newColour.set_red(m_settings.m_newResultsColourRed);
+			newColour.set_green(m_settings.m_newResultsColourGreen);
+			newColour.set_blue(m_settings.m_newResultsColourBlue);
+
 			// Change the row's background
-			pTextRenderer->property_background_gdk() = m_settings.m_newResultsColour;
+			pTextRenderer->property_background_gdk() = newColour;
 		}
 		else
 		{

Modified: trunk/UI/GTK2/src/prefsDialog.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.cc	2006-08-09 10:09:02 UTC (rev 385)
+++ trunk/UI/GTK2/src/prefsDialog.cc	2006-08-09 10:11:58 UTC (rev 386)
@@ -41,6 +41,12 @@
 	prefsDialog_glade(),
 	m_settings(PinotSettings::getInstance())
 {
+	Color newColour;
+
+	newColour.set_red(m_settings.m_newResultsColourRed);
+	newColour.set_green(m_settings.m_newResultsColourGreen);
+	newColour.set_blue(m_settings.m_newResultsColourBlue);
+
 	// Initialize widgets
 	// Ignore robots directives
 	ignoreRobotsCheckbutton->set_active(m_settings.m_ignoreRobotsDirectives);
@@ -50,7 +56,7 @@
 		apiKeyEntry->set_text(m_settings.m_googleAPIKey);
 	}
 	// New results colour
-	newResultsColorbutton->set_color(m_settings.m_newResultsColour);
+	newResultsColorbutton->set_color(newColour);
 	// Enable terms suggestion
 	enableCompletionCheckbutton->set_active(m_settings.m_suggestQueryTerms);
 
@@ -66,7 +72,6 @@
 	m_refMailTree = ListStore::create(m_mailColumns);
 	mailTreeview->set_model(m_refMailTree);
 	mailTreeview->append_column(_("Location"), m_mailColumns.m_location);
-	mailTreeview->append_column(_("MIME Type"), m_mailColumns.m_type);
 	// Allow only single selection
 	mailTreeview->get_selection()->set_mode(SELECTION_SINGLE);
 	populate_mailTreeview();
@@ -184,7 +189,7 @@
 	}
 
 	// Populate the tree
-	for (set<PinotSettings::MailAccount>::iterator mailIter = m_settings.m_mailAccounts.begin();
+	for (set<PinotSettings::TimestampedItem>::iterator mailIter = m_settings.m_mailAccounts.begin();
 		mailIter != m_settings.m_mailAccounts.end();
 		++mailIter)
 	{
@@ -193,9 +198,7 @@
 		row = *iter;
 		// Set its name, type and minium date
 		row[m_mailColumns.m_location] = mailIter->m_name;
-		row[m_mailColumns.m_type] = mailIter->m_type;
 		row[m_mailColumns.m_mTime] = mailIter->m_modTime;
-		row[m_mailColumns.m_minDate] = mailIter->m_lastMessageTime;
 	}
 
 	editAccountButton->set_sensitive(true);
@@ -215,15 +218,13 @@
 		for (; iter != children.end(); ++iter)
 		{
 			TreeModel::Row row = *iter;
-			PinotSettings::MailAccount mailAccount;
+			PinotSettings::TimestampedItem mailAccount;
 
 			// FIXME: unlike libmagic, shared-mime-info fails to identify most mbox files
 			// as being of type text/x-mail
 			// Add this new mail account to the settings
 			mailAccount.m_name = row[m_mailColumns.m_location];
-			mailAccount.m_type = row[m_mailColumns.m_type];
 			mailAccount.m_modTime = row[m_mailColumns.m_mTime];
-			mailAccount.m_lastMessageTime = row[m_mailColumns.m_minDate];
 
 			string mailLabel("mailbox://");
 			mailLabel += from_utf8(mailAccount.m_name);
@@ -249,7 +250,10 @@
 {
 	// Synchronise widgets with settings
 	m_settings.m_ignoreRobotsDirectives = ignoreRobotsCheckbutton->get_active();
-	m_settings.m_newResultsColour = newResultsColorbutton->get_color();
+	Color newColour = newResultsColorbutton->get_color();
+	m_settings.m_newResultsColourRed = newColour.get_red();
+	m_settings.m_newResultsColourGreen = newColour.get_green();
+	m_settings.m_newResultsColourBlue = newColour.get_blue();
 	m_settings.m_suggestQueryTerms = enableCompletionCheckbutton->get_active();
 	m_settings.m_googleAPIKey = apiKeyEntry->get_text();
 
@@ -330,9 +334,7 @@
 		TreeModel::Row row = *iter;
 	
 		row[m_mailColumns.m_location] = to_utf8(fileName);
-		row[m_mailColumns.m_type] = to_utf8(mimeType);
-		row[m_mailColumns.m_mTime] = 0;
-		row[m_mailColumns.m_minDate] = 0;
+		row[m_mailColumns.m_mTime] = time(NULL);
 
 		if (wasEmpty == true)
 		{
@@ -355,7 +357,6 @@
 		if (select_file_name(*this, _("Mbox File Location"), fileName, true) == true)
 		{
 			row[m_mailColumns.m_location] = fileName;
-			row[m_mailColumns.m_type] = to_utf8(MIMEScanner::scanFile(fileName));
 		}
 	}
 }



From fabricecolin at mail.berlios.de  Wed Aug  9 12:14:53 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 9 Aug 2006 12:14:53 +0200
Subject: [Pinot-svn] r387 - trunk/UI/GTK2/src
Message-ID: <200608091014.k79AErCn007743@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-09 12:14:52 +0200 (Wed, 09 Aug 2006)
New Revision: 387

Modified:
   trunk/UI/GTK2/src/OnDiskHandler.h
   trunk/UI/GTK2/src/WorkerThreads.cpp
Log:
MonitorThread is now more useful and checks which files have already been
crawled. Minor fix to OnDiskHandler.h.


Modified: trunk/UI/GTK2/src/OnDiskHandler.h
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-09 10:11:58 UTC (rev 386)
+++ trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-09 10:14:52 UTC (rev 387)
@@ -14,8 +14,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
  
-#ifndef _MBOXHANDLER_HH
-#define _MBOXHANDLER_HH
+#ifndef _ONDISKHANDLER_HH
+#define _ONDISKHANDLER_HH
 
 #include <time.h>
 #include <string>
@@ -66,4 +66,4 @@
 
 };
 
-#endif // _MBOXHANDLER_HH
+#endif // _ONDISKHANDLER_HH

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-09 10:11:58 UTC (rev 386)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-09 10:14:52 UTC (rev 387)
@@ -1629,6 +1629,9 @@
 
 bool DirectoryScannerThread::scanDirectory(const string &dirName)
 {
+	CrawlHistory history(PinotSettings::getInstance().m_historyDatabase);
+	CrawlHistory::CrawlStatus status = CrawlHistory::UNKNOWN;
+	time_t itemDate;
 	struct stat fileStat;
 	int statSuccess = 0;
 
@@ -1661,29 +1664,22 @@
 	else if (S_ISREG(fileStat.st_mode))
 	{
 		// It's actually a file
-		foundFile(dirName);
+		// Skip dotfiles and those files we have already crawled
+		if ((dirName[0] != '.') &&
+			(history.hasItem("file://" + dirName, status, itemDate) == false))
+		{
+			foundFile(dirName);
+
+			// Record it
+			history.insertItem("file://" + dirName, CrawlHistory::CRAWLED, m_sourceId, 0);
+		}
 	}
 	else if (S_ISDIR(fileStat.st_mode))
 	{
-		CrawlHistory history(PinotSettings::getInstance().m_historyDatabase);
-		CrawlHistory::CrawlStatus status = CrawlHistory::UNKNOWN;
-
-		// A directory : check whether it has been crawled already
-		if ((history.hasItem(string("file://") + dirName, status) == true) &&
-			(status != CrawlHistory::UNKNOWN))
-		{
-			// Skip it
-#ifdef DEBUG
-			cout << "DirectoryScannerThread::scanDirectory: skipping " << dirName << endl;
-#endif
-			return true;
-		}
-
-		// Scan it !
+		// A directory : scan it
 		DIR *pDir = opendir(dirName.c_str());
 		if (pDir == NULL)
 		{
-			history.insertItem(string("file://") + dirName, CrawlHistory::CRAWLED, m_sourceId);
 			return false;
 		}
 #ifdef DEBUG
@@ -1707,9 +1703,7 @@
 
 				// Skip . .. and dotfiles
 				Url urlObj("file://" + entryName);
-				if ((urlObj.getFile() == ".") ||
-					(urlObj.getFile() == "..") ||
-					(urlObj.getFile()[0] == '.') ||
+				if ((urlObj.getFile()[0] == '.') ||
 					(lstat(entryName.c_str(), &fileStat) == -1))
 				{
 					// Next entry
@@ -1723,7 +1717,14 @@
 				// File or directory
 				if (S_ISREG(fileStat.st_mode))
 				{
-					foundFile(entryName);
+					// Has it already been crawled ?
+					if (history.hasItem("file://" + entryName, status, itemDate) == false)
+					{
+						foundFile(entryName);
+
+						// Record it
+						history.insertItem("file://" + entryName, CrawlHistory::CRAWLED, m_sourceId, 0);
+					}
 				}
 				else if (S_ISDIR(fileStat.st_mode))
 				{
@@ -1746,9 +1747,6 @@
 			pDirEntry = readdir(pDir);
 		}
 		closedir(pDir);
-
-		// Update the directory's status
-		history.insertItem(string("file://") + dirName, CrawlHistory::CRAWLED, m_sourceId);
 	}
 
 	return true;
@@ -1760,10 +1758,10 @@
 
 	// Does this source exist ?
 	if ((m_dirName.empty() == false) &&
-		(history.hasSource(string("file://") + m_dirName, m_sourceId) == false))
+		(history.hasSource("file://" + m_dirName, m_sourceId) == false))
 	{
 		// Create it
-		m_sourceId = history.insertSource(string("file://") + m_dirName);
+		m_sourceId = history.insertSource("file://" + m_dirName);
 	}
 
 	if (scanDirectory(m_dirName) == false)



From fabricecolin at mail.berlios.de  Wed Aug  9 12:15:42 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 9 Aug 2006 12:15:42 +0200
Subject: [Pinot-svn] r388 - trunk/UI/GTK2/src
Message-ID: <200608091015.k79AFgXc007988@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-09 12:15:42 +0200 (Wed, 09 Aug 2006)
New Revision: 388

Modified:
   trunk/UI/GTK2/src/Makefile.am
Log:
Don't link the daemon program to gtkmm, only glibmm is necessary.


Modified: trunk/UI/GTK2/src/Makefile.am
===================================================================
--- trunk/UI/GTK2/src/Makefile.am	2006-08-09 10:14:52 UTC (rev 387)
+++ trunk/UI/GTK2/src/Makefile.am	2006-08-09 10:15:42 UTC (rev 388)
@@ -57,7 +57,6 @@
 	MboxHandler.cpp \
 	OnDiskHandler.cpp \
 	PinotSettings.cpp \
-	PinotUtils.cpp \
 	WorkerThreads.cpp
 
 bin_PROGRAMS = pinot pinot-dbus-daemon
@@ -75,5 +74,5 @@
 pinot_dbus_daemon_LDADD = -L../../../Utils -L../../../Tokenize -L../../../SQL -L../../../Monitor \
 	-L../../../Collect -L../../../Search -L../../../Search/Google \
 	-L../../../Index -lIndex @SEARCH_LIBS@ -lMonitor -lCollect -lSQL -lTokenize -lUtils \
-	@LIBS@ @UI_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ @SOAP_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
+	@LIBS@ @GLIBMM_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ @SOAP_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
 



From fabricecolin at mail.berlios.de  Thu Aug 10 13:55:22 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 10 Aug 2006 13:55:22 +0200
Subject: [Pinot-svn] r389 - in trunk: Index Search
Message-ID: <200608101155.k7ABtMep020008@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-10 13:55:17 +0200 (Thu, 10 Aug 2006)
New Revision: 389

Modified:
   trunk/Index/WritableXapianIndex.cpp
   trunk/Search/SherlockParser.cpp
Log:
Cosmetic changes.


Modified: trunk/Index/WritableXapianIndex.cpp
===================================================================
--- trunk/Index/WritableXapianIndex.cpp	2006-08-09 10:15:42 UTC (rev 388)
+++ trunk/Index/WritableXapianIndex.cpp	2006-08-10 11:55:17 UTC (rev 389)
@@ -531,6 +531,7 @@
 {
 	return XapianIndex::listDocumentsWithLabel(name, docIds, maxDocsCount, startDoc);
 }
+
 //
 // Implementation of WritableIndexInterface
 //

Modified: trunk/Search/SherlockParser.cpp
===================================================================
--- trunk/Search/SherlockParser.cpp	2006-08-09 10:15:42 UTC (rev 388)
+++ trunk/Search/SherlockParser.cpp	2006-08-10 11:55:17 UTC (rev 389)
@@ -504,9 +504,6 @@
 
 	if (pthread_mutex_lock(&m_mutex) == 0)
 	{
-#ifdef DEBUG
-		cout << "SherlockParser::parse: parsing" << endl;
-#endif
 		try
 		{
 			if (extractSearchParams == false)
@@ -542,9 +539,6 @@
 			fullParsing = false;
 		}
 
-#ifdef DEBUG
-		cout << "SherlockParser::parse: parsed" << endl;
-#endif
 		pthread_mutex_unlock(&m_mutex);
 	}
 



From fabricecolin at mail.berlios.de  Thu Aug 10 14:01:15 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 10 Aug 2006 14:01:15 +0200
Subject: [Pinot-svn] r390 - trunk/UI/GTK2/src
Message-ID: <200608101201.k7AC1Fs4021887@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-10 14:00:27 +0200 (Thu, 10 Aug 2006)
New Revision: 390

Modified:
   trunk/UI/GTK2/src/DaemonState.cpp
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
Log:
DaemonState uses file name as title, not the whole URL.
In ThreadsManager::queue_index(), queue documents if the load is too high.
DirectoryScannerThread checks the file's last modification time if it has
already been crawled.


Modified: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2006-08-10 11:55:17 UTC (rev 389)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2006-08-10 12:00:27 UTC (rev 390)
@@ -21,6 +21,7 @@
 #include <glibmm/convert.h>
 #include <glibmm/thread.h>
 
+#include "Url.h"
 #include "WritableXapianIndex.h"
 #include "DaemonState.h"
 #include "MboxHandler.h"
@@ -249,8 +250,10 @@
 
 bool DaemonState::on_message_filefound(const string &location)
 {
-	DocumentInfo docInfo(location, location, "", "");
+	Url urlObj(location);
 
+	DocumentInfo docInfo(urlObj.getFile(), location, "", "");
+
 	queue_index(docInfo);
 
 	// Don't request another file right now

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-10 11:55:17 UTC (rev 389)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-10 12:00:27 UTC (rev 390)
@@ -30,7 +30,6 @@
 
 #include "HtmlTokenizer.h"
 #include "XmlTokenizer.h"
-#include "MIMEScanner.h"
 #include "TokenizerFactory.h"
 #include "StringManip.h"
 #include "TimeConverter.h"
@@ -174,10 +173,13 @@
 	m_defaultIndexLocation(defaultIndexLocation),
 	m_maxIndexThreads(maxIndexThreads),
 	m_nextId(1),
-	m_backgroundThreadsCount(0)
+	m_backgroundThreadsCount(0),
+	m_numCPUs(1)
 {
 	pthread_rwlock_init(&m_threadsLock, NULL);
 	pthread_rwlock_init(&m_listsLock, NULL);
+
+	m_numCPUs = sysconf(_SC_NPROCESSORS_ONLN);
 }
 
 ThreadsManager::~ThreadsManager()
@@ -458,8 +460,27 @@
 
 bool ThreadsManager::queue_index(const DocumentInfo &docInfo)
 {
+	double averageLoad[3];
+	bool addToQueue = false;
+
 	if (get_threads_count() >= m_maxIndexThreads)
 	{
+		addToQueue = true;
+	}
+	// Get the load averaged over the last minute
+	else if (getloadavg(averageLoad, 3) != -1)
+	{
+		// FIXME: is LOADAVG_1MIN Solaris specific ?
+		if (averageLoad[0] >= (double)m_numCPUs * 4)
+		{
+			// Don't add to the load, queue this
+			addToQueue = true;
+		}
+	}
+
+
+	if (addToQueue == true)
+	{
 		if (write_lock_lists() == true)
 		{
 			m_indexQueue.insert(docInfo);
@@ -1359,8 +1380,7 @@
 	WorkerThread(),
 	m_ctrlReadPipe(-1),
 	m_ctrlWritePipe(-1),
-	m_pHandler(pHandler),
-	m_numCPUs(1)
+	m_pHandler(pHandler)
 {
 	int pipeFds[2];
 
@@ -1370,7 +1390,6 @@
 		m_ctrlReadPipe = pipeFds[0];
 		m_ctrlWritePipe = pipeFds[1];
 	}
-	m_numCPUs = sysconf(_SC_NPROCESSORS_ONLN);
 }
 
 MonitorThread::~MonitorThread()
@@ -1492,23 +1511,7 @@
 				(m_done == false))
 			{
 				MonitorEvent &event = events.front();
-				double averageLoad[3];
 
-				// Get the load averaged over the last minute
-				if (getloadavg(averageLoad, 3) != -1)
-				{
-					// FIXME: is LOADAVG_1MIN Solaris specific ?
-					if (averageLoad[0] >= (double)m_numCPUs * 4)
-					{
-						// Ignore pending events if the load has become too high
-#ifdef DEBUG
-						cout << "MonitorThread::doWork: ignoring events because of load ("
-							<< averageLoad[0] << ")" << endl;
-#endif
-						break;
-					}
-				}
-
 				if ((event.m_location.empty() == true) ||
 					(event.m_type == MonitorEvent::UNKNOWN))
 				{
@@ -1604,7 +1607,7 @@
 	if ((m_pMutex != NULL) &&
 		(m_pCondVar != NULL))
 	{
-		string url(string("file://") + fileName);
+		string url("file://" + fileName);
 
 		m_pMutex->lock();
 		if (m_signalFileFound(url) == true)
@@ -1663,15 +1666,29 @@
 	}
 	else if (S_ISREG(fileStat.st_mode))
 	{
-		// It's actually a file
-		// Skip dotfiles and those files we have already crawled
-		if ((dirName[0] != '.') &&
-			(history.hasItem("file://" + dirName, status, itemDate) == false))
+		// It's actually a file : skip dotfiles
+		if (dirName[0] != '.')
 		{
-			foundFile(dirName);
+			bool reportFile = false;
 
-			// Record it
-			history.insertItem("file://" + dirName, CrawlHistory::CRAWLED, m_sourceId, 0);
+			// ...and check whether the file was crawled since it was last modified
+			if (history.hasItem("file://" + dirName, status, itemDate) == false)
+			{
+				// Record it
+				history.insertItem("file://" + dirName, CrawlHistory::CRAWLED, m_sourceId, fileStat.st_mtime);
+				reportFile = true;
+			}
+			else if (itemDate < fileStat.st_mtime)
+			{
+				// Update the record
+				history.updateItem("file://" + dirName, CrawlHistory::CRAWLED, fileStat.st_mtime);
+				reportFile = true;
+			}
+
+			if (reportFile == true)
+			{
+				foundFile(dirName);
+			}
 		}
 	}
 	else if (S_ISDIR(fileStat.st_mode))
@@ -1717,14 +1734,26 @@
 				// File or directory
 				if (S_ISREG(fileStat.st_mode))
 				{
-					// Has it already been crawled ?
+					bool reportFile = false;
+
+					// Was it crawled since it was last modified ?
 					if (history.hasItem("file://" + entryName, status, itemDate) == false)
 					{
-						foundFile(entryName);
-
 						// Record it
-						history.insertItem("file://" + entryName, CrawlHistory::CRAWLED, m_sourceId, 0);
+						history.insertItem("file://" + entryName, CrawlHistory::CRAWLED, m_sourceId, fileStat.st_mtime);
+						reportFile = true;
 					}
+					else if (itemDate < fileStat.st_mtime)
+					{
+						// Update the record
+						history.updateItem("file://" + entryName, CrawlHistory::CRAWLED, fileStat.st_mtime);
+						reportFile = true;
+					}
+
+					if (reportFile == true)
+					{
+						foundFile(entryName);
+					}
 				}
 				else if (S_ISDIR(fileStat.st_mode))
 				{

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2006-08-10 11:55:17 UTC (rev 389)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2006-08-10 12:00:27 UTC (rev 390)
@@ -133,6 +133,7 @@
 		unsigned int m_maxIndexThreads;
 		unsigned int m_nextId;
 		unsigned int m_backgroundThreadsCount;
+		long m_numCPUs;
 		SigC::Signal1<void, WorkerThread *> m_onThreadEndSignal;
 		std::set<DocumentInfo> m_indexQueue;
 
@@ -381,7 +382,6 @@
 		int m_ctrlReadPipe;
 		int m_ctrlWritePipe;
 		MonitorHandler *m_pHandler;
-		long m_numCPUs;
 
 		virtual void doWork(void);
 



From fabricecolin at mail.berlios.de  Thu Aug 10 14:03:27 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 10 Aug 2006 14:03:27 +0200
Subject: [Pinot-svn] r391 - trunk/Search/Plugins
Message-ID: <200608101203.k7AC3Rgb022480@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-10 14:03:24 +0200 (Thu, 10 Aug 2006)
New Revision: 391

Modified:
   trunk/Search/Plugins/Topix.src
Log:
Fixed results extraction.


Modified: trunk/Search/Plugins/Topix.src
===================================================================
--- trunk/Search/Plugins/Topix.src	2006-08-10 12:00:27 UTC (rev 390)
+++ trunk/Search/Plugins/Topix.src	2006-08-10 12:03:24 UTC (rev 391)
@@ -17,7 +17,7 @@
 resultListStart=""
 resultListEnd=""
 resultItemStart='<div class="article"'
-resultItemEnd='</div> </div>'
+resultItemEnd='<div class="divclear">'
 >
 
 </SEARCH>



From fabricecolin at mail.berlios.de  Fri Aug 11 17:13:21 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 11 Aug 2006 17:13:21 +0200
Subject: [Pinot-svn] r392 - trunk/Index
Message-ID: <200608111513.k7BFDLsu024489@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-11 17:13:19 +0200 (Fri, 11 Aug 2006)
New Revision: 392

Modified:
   trunk/Index/IndexInterface.h
   trunk/Index/WritableXapianIndex.cpp
   trunk/Index/WritableXapianIndex.h
   trunk/Index/XapianIndex.cpp
   trunk/Index/XapianIndex.h
Log:
IndexInterface has a new method, getLastDocumentID().
In WritableXapianIndex, store the MIME type and the directory hierarchy
of the document with prefixes T and XDIR. Sorted out issues with language
when updating the document info.


Modified: trunk/Index/IndexInterface.h
===================================================================
--- trunk/Index/IndexInterface.h	2006-08-10 12:03:24 UTC (rev 391)
+++ trunk/Index/IndexInterface.h	2006-08-11 15:13:19 UTC (rev 392)
@@ -50,6 +50,9 @@
 		/// Gets terms with the same root.
 		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions) = 0;
 
+		/// Returns the ID of the last document.
+		virtual unsigned int getLastDocumentID(void) const = 0;
+
 		/// Returns the number of documents.
 		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const = 0;
 

Modified: trunk/Index/WritableXapianIndex.cpp
===================================================================
--- trunk/Index/WritableXapianIndex.cpp	2006-08-10 12:03:24 UTC (rev 391)
+++ trunk/Index/WritableXapianIndex.cpp	2006-08-11 15:13:19 UTC (rev 392)
@@ -44,6 +44,28 @@
 using std::set;
 using std::min;
 
+static void removeFirstPosting(Xapian::Document &doc,
+	Xapian::TermIterator &termListIter, const string &term)
+{
+	termListIter.skip_to(term);
+
+	Xapian::PositionIterator firstPosIter = termListIter.positionlist_begin();
+	if (firstPosIter != termListIter.positionlist_end())
+	{
+		try
+		{
+			doc.remove_posting(term, *firstPosIter);
+		}
+		catch (const Xapian::Error &error)
+		{
+			// This posting may have been removed already
+#ifdef DEBUG
+			cout << "WritableXapianIndex::removeFirstPosting: " << error.get_msg() << endl;
+#endif
+		}
+	}
+}
+
 WritableXapianIndex::WritableXapianIndex(const string &indexName) :
 	WritableIndexInterface(),
 	XapianIndex(indexName)
@@ -167,12 +189,7 @@
 		if (isupper((int)term[0]) != 0)
 		{
 			// R-prefix the raw term
-			termListIter.skip_to(string("R") + term);
-			Xapian::PositionIterator firstPosIter = termListIter.positionlist_begin();
-			if (firstPosIter != termListIter.positionlist_end())
-			{
-				doc.remove_posting(string("R") + term, *firstPosIter);
-			}
+			removeFirstPosting(doc, termListIter, string("R") + term);
 		}
 		// Lower case the term
 		term = StringManip::toLowerCase(term);
@@ -181,36 +198,16 @@
 		if ((mode == STORE_UNSTEM) ||
 			(pStemmer == NULL))
 		{
-			termListIter.skip_to(limitTermLength(prefix + term));
-			Xapian::PositionIterator firstPosIter = termListIter.positionlist_begin();
-			if (firstPosIter != termListIter.positionlist_end())
-			{
-				doc.remove_posting(limitTermLength(prefix + term), *firstPosIter);
-			}
+			removeFirstPosting(doc, termListIter, limitTermLength(prefix + term));
 		}
 		else if (mode == STORE_STEM)
 		{
-			string stemmedTerm = pStemmer->stem_word(term);
-
-			termListIter.skip_to(limitTermLength(prefix + stemmedTerm));
-			Xapian::PositionIterator firstPosIter = termListIter.positionlist_begin();
-			if (firstPosIter != termListIter.positionlist_end())
-			{
-				doc.remove_posting(limitTermLength(prefix + stemmedTerm), *firstPosIter);
-			}
+			removeFirstPosting(doc, termListIter, limitTermLength(prefix + pStemmer->stem_word(term)));
 		}
 		else if (mode == STORE_BOTH)
 		{
-			string stemmedTerm = pStemmer->stem_word(term);
-
-			// Both unstemmed and stemmed should be at the same position
-			termListIter.skip_to(limitTermLength(prefix + term));
-			Xapian::PositionIterator firstPosIter = termListIter.positionlist_begin();
-			if (firstPosIter != termListIter.positionlist_end())
-			{
-				doc.remove_posting(limitTermLength(prefix + term), *firstPosIter);
-				doc.remove_posting(limitTermLength(prefix + stemmedTerm), *firstPosIter);
-			}
+			removeFirstPosting(doc, termListIter, limitTermLength(prefix + term));
+			removeFirstPosting(doc, termListIter, limitTermLength(prefix + pStemmer->stem_word(term)));
 		}
 	}
 
@@ -257,6 +254,20 @@
 			dotPos = hostName.find('.', dotPos + 1);
 		}
 	}
+	// ...the location (as is) and all directories with prefix XDIR:
+	string tree(urlObj.getLocation());
+	if (tree.empty() == false)
+	{
+		doc.add_term(limitTermLength(string("XDIR:") + tree, true));
+		string::size_type slashPos = tree.find('/', 1);
+		while (slashPos != string::npos)
+		{
+			doc.add_term(limitTermLength(string("XDIR:") + tree.substr(0, slashPos), true));
+
+			// Next
+			slashPos = tree.find('/', slashPos + 1);
+		}
+	}
 	// ...and the file name with prefix P
 	string fileName(urlObj.getFile());
 	if (fileName.empty() == false)
@@ -265,6 +276,8 @@
 	}
 	// Finally, add the language code with prefix L
 	doc.add_term(string("L") + Languages::toCode(m_stemLanguage));
+	// ...and the MIME type with prefix T
+	doc.add_term(string("T") + info.getType());
 
 	return true;
 }
@@ -283,11 +296,11 @@
 		return;
 	}
 
-	string language(Languages::toLocale(StringManip::extractField(record, "language=", "")));
+	string language(StringManip::extractField(record, "language=", ""));
 	docInfo = DocumentInfo(StringManip::extractField(record, "caption=", "\n"),
 		StringManip::extractField(record, "url=", "\n"),
 		StringManip::extractField(record, "type=", "\n"),
-		language);
+		Languages::toLocale(language));
 	docInfo.setTimestamp(StringManip::extractField(record, "timestamp=", "\n"));
 	Url urlObj(docInfo.getLocation());
 
@@ -319,6 +332,20 @@
 			dotPos = hostName.find('.', dotPos + 1);
 		}
 	}
+	// ...location
+	string tree(urlObj.getLocation());
+	if (tree.empty() == false)
+	{
+		doc.remove_term(limitTermLength(string("XDIR:") + tree, true));
+		string::size_type slashPos = tree.find('/', 1);
+		while (slashPos != string::npos)
+		{
+			doc.remove_term(limitTermLength(string("XDIR:") + tree.substr(0, slashPos), true));
+
+			// Next
+			slashPos = tree.find('/', slashPos + 1);
+		}
+	}
 	// ...and file name
 	string fileName(urlObj.getFile());
 	if (fileName.empty() == false)
@@ -327,6 +354,8 @@
 	}
 	// Language code
 	doc.remove_term(string("L") + Languages::toCode(language));
+	// MIME type
+	doc.remove_term(string("T") + docInfo.getType());
 }
 
 string WritableXapianIndex::scanDocument(const char *pData, unsigned int dataLength,
@@ -404,7 +433,7 @@
 	record += timestamp;
 	// ...and the language
 	record += "\nlanguage=";
-	record += language;
+	record += StringManip::toLowerCase(language);
 #ifdef DEBUG
 	cout << "WritableXapianIndex::setDocumentData: document data is " << record << endl;
 #endif
@@ -512,6 +541,12 @@
 	return XapianIndex::getCloseTerms(term, suggestions);
 }
 
+/// Returns the ID of the last document.
+unsigned int WritableXapianIndex::getLastDocumentID(void) const
+{
+	return XapianIndex::getLastDocumentID();
+}
+
 /// Returns the number of documents.
 unsigned int WritableXapianIndex::getDocumentsCount(const string &labelName) const
 {
@@ -727,8 +762,9 @@
 
 			// Update the document data with the current language
 			removeCommonTerms(doc);
-			setDocumentData(docInfo, doc, docInfo.getLanguage());
+			m_stemLanguage = Languages::toEnglish(docInfo.getLanguage());
 			addCommonTerms(docInfo, doc, termPos);
+			setDocumentData(docInfo, doc, m_stemLanguage);
 
 			pIndex->replace_document(docId, doc);
 			updated = true;

Modified: trunk/Index/WritableXapianIndex.h
===================================================================
--- trunk/Index/WritableXapianIndex.h	2006-08-10 12:03:24 UTC (rev 391)
+++ trunk/Index/WritableXapianIndex.h	2006-08-11 15:13:19 UTC (rev 392)
@@ -52,6 +52,9 @@
 		/// Gets terms with the same root.
 		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions);
 
+		/// Returns the ID of the last document.
+		virtual unsigned int getLastDocumentID(void) const;
+
 		/// Returns the number of documents.
 		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const;
 

Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2006-08-10 12:03:24 UTC (rev 391)
+++ trunk/Index/XapianIndex.cpp	2006-08-11 15:13:19 UTC (rev 392)
@@ -406,6 +406,39 @@
 	return suggestions.size();
 }
 
+/// Returns the ID of the last document.
+unsigned int XapianIndex::getLastDocumentID(void) const
+{
+	unsigned int docId = 0;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return 0;
+	}
+
+	try
+	{
+		Xapian::Database *pIndex = pDatabase->readLock();
+		if (pIndex != NULL)
+		{
+			docId = pIndex->get_lastdocid();
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't get last document ID: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't get last document ID, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return docId;
+}
+
 /// Returns the number of documents.
 unsigned int XapianIndex::getDocumentsCount(const string &labelName) const
 {

Modified: trunk/Index/XapianIndex.h
===================================================================
--- trunk/Index/XapianIndex.h	2006-08-10 12:03:24 UTC (rev 391)
+++ trunk/Index/XapianIndex.h	2006-08-11 15:13:19 UTC (rev 392)
@@ -52,6 +52,9 @@
 		/// Gets terms with the same root.
 		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions);
 
+		/// Returns the ID of the last document.
+		virtual unsigned int getLastDocumentID(void) const;
+
 		/// Returns the number of documents.
 		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const;
 



From fabricecolin at mail.berlios.de  Fri Aug 11 17:20:30 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 11 Aug 2006 17:20:30 +0200
Subject: [Pinot-svn] r393 - trunk/UI/GTK2/src
Message-ID: <200608111520.k7BFKUNW025063@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-11 17:20:29 +0200 (Fri, 11 Aug 2006)
New Revision: 393

Modified:
   trunk/UI/GTK2/src/DaemonState.cpp
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
   trunk/UI/GTK2/src/mainWindow.cc
Log:
The index queue is now a queue, not a set. Uniqueness is guaranteed by
ThreadsManager::m_beingIndexed, which now covers indexing and updating.
URLs are removed from it by pop_queue().


Modified: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2006-08-11 15:13:19 UTC (rev 392)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2006-08-11 15:20:29 UTC (rev 393)
@@ -106,6 +106,8 @@
 
 void DaemonState::on_thread_end(WorkerThread *pThread)
 {
+	string indexedUrl;
+
 	if (pThread == NULL)
 	{
 		return;
@@ -196,24 +198,9 @@
 			return;
 		}
 
-		// Did the thread perform an update ?
-		if (pIndexThread->isNewDocument() == true)
-		{
-			string url(pIndexThread->getURL());
+		// Get the URL we have just indexed
+		indexedUrl = pIndexThread->getURL();
 
-			// Update the in-progress list
-			if (write_lock_lists() == true)
-			{
-				set<string>::iterator urlIter = m_beingIndexed.find(url);
-				if (urlIter != m_beingIndexed.end())
-				{
-					m_beingIndexed.erase(urlIter);
-				}
-
-				unlock_lists();
-			}
-		}
-
 		// Get another file from the directory scanner if possible
 		if (m_crawling == true)
 		{
@@ -240,7 +227,7 @@
 	delete pThread;;
 
 	// We might be able to run a queued action
-	pop_queue();
+	pop_queue(indexedUrl);
 }
 
 void DaemonState::on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, string indexName)

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-11 15:13:19 UTC (rev 392)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-11 15:20:29 UTC (rev 393)
@@ -30,6 +30,7 @@
 
 #include "HtmlTokenizer.h"
 #include "XmlTokenizer.h"
+#include "MIMEScanner.h"
 #include "TokenizerFactory.h"
 #include "StringManip.h"
 #include "TimeConverter.h"
@@ -172,7 +173,7 @@
 	SigC::Object(),
 	m_defaultIndexLocation(defaultIndexLocation),
 	m_maxIndexThreads(maxIndexThreads),
-	m_nextId(1),
+	m_nextThreadId(1),
 	m_backgroundThreadsCount(0),
 	m_numCPUs(1)
 {
@@ -291,13 +292,33 @@
 		return false;
 	}
 
-	// If the document is mail, we can't index it again
+	// If the document is a mail message, we can't index it again
 	Url urlObj(location);
 	if (urlObj.getProtocol() == "mailbox")
 	{
 		return false;
 	}
 
+	// Is the document being indexed/updated ?
+	if (write_lock_lists() == true)
+	{
+		bool beingProcessed = true;
+
+		if (m_beingIndexed.find(location) == m_beingIndexed.end())
+		{
+			m_beingIndexed.insert(location);
+			beingProcessed = false;
+		}
+
+		unlock_lists();
+
+		if (beingProcessed == true)
+		{
+			// FIXME: we may have to set labels on this document
+			return false;
+		}
+	}
+
 	// Is it an update ?
 	XapianIndex index(m_defaultIndexLocation);
 	unsigned int docId = index.hasDocument(docInfo.getLocation());
@@ -308,26 +329,6 @@
 	}
 	else
 	{
-		bool isNewDocument = false;
-
-		// Is the document being indexed ?
-		if (write_lock_lists() == true)
-		{
-			if (m_beingIndexed.find(location) == m_beingIndexed.end())
-			{
-				m_beingIndexed.insert(location);
-				isNewDocument = true;
-			}
-
-			unlock_lists();
-		}
-
-		if (isNewDocument == false)
-		{
-			// FIXME: the document is being indexed but we may have to set labels on it
-			return false;
-		}
-
 		// This is a new document
 		start_thread(new IndexingThread(docInfo, docId, m_defaultIndexLocation));
 	}
@@ -342,7 +343,7 @@
 		return false;
 	}
 
-	pWorkerThread->setId(m_nextId);
+	pWorkerThread->setId(m_nextThreadId);
 	if (inBackground == true)
 	{
 		pWorkerThread->inBackground();
@@ -365,7 +366,7 @@
 
 		unlock_threads();
 	}
-	++m_nextId;
+	++m_nextThreadId;
 
 	return true;
 }
@@ -478,12 +479,11 @@
 		}
 	}
 
-
 	if (addToQueue == true)
 	{
 		if (write_lock_lists() == true)
 		{
-			m_indexQueue.insert(docInfo);
+			m_indexQueue.push(docInfo);
 
 			unlock_lists();
 		}
@@ -494,34 +494,42 @@
 	return index_document(docInfo);
 }
 
-bool ThreadsManager::pop_queue(void)
+bool ThreadsManager::pop_queue(const string &urlWasIndexed)
 {
+	bool getItem = true;
+	bool foundItem = false;
+
 	if (get_threads_count() >= m_maxIndexThreads)
 	{
 #ifdef DEBUG
 		cout << "ThreadsManager::pop_queue: too many threads" << endl;
 #endif
-		return false;
+		getItem = false;
 	}
 
 	DocumentInfo docInfo;
-	bool foundItem = false;
 
 	if (write_lock_lists() == true)
 	{
-		if (m_indexQueue.empty() == false)
+		// Update the in-progress list
+		if (urlWasIndexed.empty() == false)
 		{
-			// Get the first item
-			std::set<DocumentInfo>::iterator queueIter = m_indexQueue.begin();
-			if (queueIter != m_indexQueue.end())
+			set<string>::iterator urlIter = m_beingIndexed.find(urlWasIndexed);
+			if (urlIter != m_beingIndexed.end())
 			{
-				docInfo = *queueIter;
-				foundItem = true;
-
-				m_indexQueue.erase(queueIter);
+				m_beingIndexed.erase(urlIter);
 			}
 		}
 
+		// Get the first item ?
+		if ((getItem == true) &&
+			(m_indexQueue.empty() == false))
+		{
+			docInfo = m_indexQueue.front();
+			m_indexQueue.pop();
+			foundItem = true;
+		}
+
 		unlock_lists();
 	}
 
@@ -534,6 +542,18 @@
 	return index_document(docInfo);
 }
 
+void ThreadsManager::get_statistics(unsigned int &queueSize)
+{
+	if (read_lock_lists() == true)
+	{
+		// We want the number of documents being indexed,
+		// not the number of document waiting in the queue
+		queueSize = m_beingIndexed.size();
+
+		unlock_lists();
+	}
+}
+
 IndexBrowserThread::IndexBrowserThread(const string &indexName,
 	const string &labelName, unsigned int maxDocsCount, unsigned int startDoc) :
 	WorkerThread(),

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2006-08-11 15:13:19 UTC (rev 392)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2006-08-11 15:20:29 UTC (rev 393)
@@ -20,6 +20,7 @@
 #include <time.h>
 #include <string>
 #include <vector>
+#include <queue>
 #include <set>
 #include <map>
 #include <pthread.h>
@@ -120,9 +121,9 @@
 
 		bool queue_index(const DocumentInfo &docInfo);
 
-		bool pop_queue(void);
+		bool pop_queue(const std::string &urlWasIndexed = "");
 
-		std::set<std::string> m_beingIndexed;
+		void get_statistics(unsigned int &queueSize);
 
 	protected:
 		SigC::Connection m_threadsEndConnection;
@@ -131,11 +132,12 @@
 		std::map<WorkerThread *, Glib::Thread *> m_threads;
 		std::string m_defaultIndexLocation;
 		unsigned int m_maxIndexThreads;
-		unsigned int m_nextId;
+		unsigned int m_nextThreadId;
 		unsigned int m_backgroundThreadsCount;
 		long m_numCPUs;
 		SigC::Signal1<void, WorkerThread *> m_onThreadEndSignal;
-		std::set<DocumentInfo> m_indexQueue;
+		std::queue<DocumentInfo> m_indexQueue;
+		std::set<std::string> m_beingIndexed;
 
 		bool read_lock_threads(void);
 		bool write_lock_threads(void);

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2006-08-11 15:13:19 UTC (rev 392)
+++ trunk/UI/GTK2/src/mainWindow.cc	2006-08-11 15:20:29 UTC (rev 393)
@@ -807,6 +807,7 @@
 void mainWindow::on_thread_end(WorkerThread *pThread)
 {
 	ustring status;
+	string indexedUrl;
 
 	if (pThread == NULL)
 	{
@@ -1121,6 +1122,9 @@
 			return;
 		}
 
+		// Get the URL we have just indexed
+		indexedUrl = pIndexThread->getURL();
+
 		// Get the document properties
 		unsigned int docId = pIndexThread->getDocumentID();
 		DocumentInfo docInfo = pIndexThread->getDocumentInfo();
@@ -1150,24 +1154,10 @@
 		}
 		else
 		{
-			string url = pIndexThread->getURL();
-
 			status = _("Indexed");
 			status += " ";
-			status += to_utf8(url);
+			status += to_utf8(indexedUrl);
 
-			// Update the in-progress list
-			if (m_state.write_lock_lists() == true)
-			{
-				set<string>::iterator urlIter = m_state.m_beingIndexed.find(url);
-				if (urlIter != m_state.m_beingIndexed.end())
-				{
-					m_state.m_beingIndexed.erase(urlIter);
-				}
-
-				m_state.unlock_lists();
-			}
-
 			if (pIndexTree != NULL)
 			{
 				unsigned int rowsCount = pIndexTree->getRowsCount();
@@ -1253,7 +1243,7 @@
 	delete pThread;;
 
 	// We might be able to run a queued action
-	m_state.pop_queue();
+	m_state.pop_queue(indexedUrl);
 
 	// Any threads left to return ?
 	if (m_state.get_threads_count() == 0)



From fabricecolin at mail.berlios.de  Sat Aug 12 09:47:24 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 12 Aug 2006 09:47:24 +0200
Subject: [Pinot-svn] r394 - trunk/UI/GTK2/src
Message-ID: <200608120747.k7C7lNnY019189@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-12 09:47:23 +0200 (Sat, 12 Aug 2006)
New Revision: 394

Modified:
   trunk/UI/GTK2/src/pinot-dbus-daemon.cc
   trunk/UI/GTK2/src/pinot-dbus-daemon.xml
   trunk/UI/GTK2/src/pinot.cc
Log:
All methods of WritableIndexInterface have DBus equivalents now, even though most
don't actually do anything useful just yet...
Both Pinot and the daemon set XAPIAN_PREFER_FLINT in the environment so that the
new indices will be created with the Flint backend, instead of Quartz.


Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-11 15:20:29 UTC (rev 393)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-12 07:47:23 UTC (rev 394)
@@ -121,8 +121,11 @@
 
 static DBusHandlerResult messageBusFilter(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
 {
+	XapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
 	DaemonState *pServer = NULL;
 	DBusMessage *pReply = NULL;
+	DBusError error;
+	const char *pSender = dbus_message_get_sender(pMessage);
 	bool processedMessage = false, quitLoop = false;
 
 	if (pData != NULL)
@@ -130,31 +133,62 @@
 		pServer = (DaemonState *)pData;
 	}
 
+	dbus_error_init(&error);
+
+#ifdef DEBUG
+	if (pSender != NULL)
+	{
+		cout << "messageBusFilter: called from " << pSender << endl;
+	}
+#endif
+
 	// Are we about to be disconnected ?
 	if (dbus_message_is_signal(pMessage, DBUS_INTERFACE_LOCAL, "Disconnected") == TRUE)
 	{
 		quitLoop = true;
 		processedMessage = true;
 	}
-	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "GetDocumentInfo") == TRUE)
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "DeleteLabel") == TRUE)
 	{
-		const char *pSender = dbus_message_get_sender(pMessage);
-		DBusError error;
-		dbus_uint32_t docId = 0;
+		char *pLabel = NULL;
 
+		if (dbus_message_get_args(pMessage, &error,
+			DBUS_TYPE_STRING, &pLabel,
+			DBUS_TYPE_INVALID) == TRUE)
+		{
 #ifdef DEBUG
-		if (pSender != NULL)
+			cout << "messageBusFilter: received " << pLabel << endl;
+#endif
+			// FIXME: delete the label
+
+			// Prepare the reply
+			pReply = dbus_message_new_method_return(pMessage);
+			if (pReply != NULL)
+			{
+				dbus_message_append_args(pReply,
+					DBUS_TYPE_STRING, &pLabel,
+					DBUS_TYPE_INVALID);
+			}
+		}
+		else
 		{
-			cout << "messageBusFilter: called from " << pSender << endl;
+#ifdef DEBUG
+			cout << "messageBusFilter: " << error.message << endl;
+#endif
+			// Use the error message as reply
+			pReply = dbus_message_new_error(pMessage, error.name, error.message);
 		}
-#endif
-		// Simple types are returned as const references and don't need to be freed
-		dbus_error_init(&error);
+
+		processedMessage = true;
+	}
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "GetDocumentInfo") == TRUE)
+	{
+		unsigned int docId = 0;
+
 		if (dbus_message_get_args(pMessage, &error,
 			DBUS_TYPE_UINT32, &docId,
 			DBUS_TYPE_INVALID) == TRUE)
 		{
-			XapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
 			DocumentInfo docInfo;
 
 #ifdef DEBUG
@@ -169,7 +203,7 @@
 					const char *pTitle = docInfo.getTitle().c_str();
 					const char *pLocation = docInfo.getLocation().c_str();
 					const char *pType = docInfo.getType().c_str();
-					const char *pLanguage = docInfo.getLanguage().c_str();
+					const char *pLanguage = Languages::toEnglish(docInfo.getLanguage()).c_str();
 
 					dbus_message_append_args(pReply,
 						DBUS_TYPE_STRING, &pTitle,
@@ -194,26 +228,15 @@
 			// Use the error message as reply
 			pReply = dbus_message_new_error(pMessage, error.name, error.message);
 		}
-		dbus_error_free(&error);
 
 		processedMessage = true;
 	}
 	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "GetStatistics") == TRUE)
 	{
-		const char *pSender = dbus_message_get_sender(pMessage);
-		DBusError error;
-		dbus_uint32_t docId = 0;
-
-#ifdef DEBUG
-		if (pSender != NULL)
-		{
-			cout << "messageBusFilter: called from " << pSender << endl;
-		}
-#endif
-		XapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
 		CrawlHistory history(PinotSettings::getInstance().m_historyDatabase);
+		unsigned int docId = 0;
 
-		unsigned int crawledDirsCount = history.getItemsCount();
+		unsigned int crawledFilesCount = history.getItemsCount();
 		unsigned int docsCount = index.getDocumentsCount();
 
 		// Prepare the reply
@@ -221,33 +244,23 @@
 		if (pReply != NULL)
 		{
 			dbus_message_append_args(pReply,
-				DBUS_TYPE_UINT32, &crawledDirsCount,
+				DBUS_TYPE_UINT32, &crawledFilesCount,
 				DBUS_TYPE_UINT32, &docsCount,
 				DBUS_TYPE_INVALID);
 		}
 
 		processedMessage = true;
 	}
-	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "Index") == TRUE)
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "IndexDocument") == TRUE)
 	{
-		const char *pSender = dbus_message_get_sender(pMessage);
-		DBusError error;
 		char *pTitle = NULL;
 		char *pLocation = NULL;
 		char *pType = NULL;
 		char *pLanguage = NULL;
 		char **ppLabels = NULL;
 		dbus_uint32_t labelsCount = 0;
-		dbus_uint32_t docId = 0;
+		unsigned int docId = 0;
 
-#ifdef DEBUG
-		if (pSender != NULL)
-		{
-			cout << "messageBusFilter: called from " << pSender << endl;
-		}
-#endif
-		// Simple types are returned as const references and don't need to be freed
-		dbus_error_init(&error);
 		if (dbus_message_get_args(pMessage, &error,
 			DBUS_TYPE_STRING, &pTitle,
 			DBUS_TYPE_STRING, &pLocation,
@@ -257,16 +270,18 @@
 			DBUS_TYPE_UINT32, &labelsCount,
 			DBUS_TYPE_INVALID) == TRUE)
 		{
-			DocumentInfo docInfo(pTitle, pLocation, pType, pLanguage);
+			DocumentInfo docInfo(pTitle, pLocation, pType,
+				((pLanguage != NULL) ? Languages::toLocale(pLanguage) : ""));
 
 #ifdef DEBUG
 			cout << "messageBusFilter: received " << pTitle << ", " << pLocation
-				<< ", " << pType << ", " << pLanguage << ", " << docId
+				<< ", " << pType << ", " << pLanguage
 				<< " with " << labelsCount << " labels" << endl;
 #endif
 			// FIXME: set labels on docInfo
 
 			pServer->queue_index(docInfo);
+			// FIXME: we can't provide a document ID at the moment
 
 			// Free container types
 			g_strfreev(ppLabels);
@@ -288,27 +303,139 @@
 			// Use the error message as reply
 			pReply = dbus_message_new_error(pMessage, error.name, error.message);
 		}
-		dbus_error_free(&error);
 
 		processedMessage = true;
 	}
-	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "SimpleQuery") == TRUE)
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "RenameLabel") == TRUE)
 	{
-		const char *pSender = dbus_message_get_sender(pMessage);
-		DBusError error;
-		char *pSearchText = NULL;
-		dbus_uint32_t maxHits = 0;
-		dbus_uint32_t docId = 0;
+		char *pOldLabel = NULL;
+		char *pNewLabel = NULL;
 
+		if (dbus_message_get_args(pMessage, &error,
+			DBUS_TYPE_STRING, &pOldLabel,
+			DBUS_TYPE_STRING, &pNewLabel,
+			DBUS_TYPE_INVALID) == TRUE)
+		{
 #ifdef DEBUG
-		if (pSender != NULL)
+			cout << "messageBusFilter: received " << pOldLabel
+				<< " " << pNewLabel << endl;
+#endif
+			// FIXME: rename the label
+
+			// Prepare the reply
+			pReply = dbus_message_new_method_return(pMessage);
+			if (pReply != NULL)
+			{
+				dbus_message_append_args(pReply,
+					DBUS_TYPE_STRING, &pNewLabel,
+					DBUS_TYPE_INVALID);
+			}
+		}
+		else
 		{
-			cout << "messageBusFilter: called from " << pSender << endl;
+#ifdef DEBUG
+			cout << "messageBusFilter: " << error.message << endl;
+#endif
+			// Use the error message as reply
+			pReply = dbus_message_new_error(pMessage, error.name, error.message);
 		}
+
+		processedMessage = true;
+	}
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "SetDocumentInfo") == TRUE)
+	{
+		char *pTitle = NULL;
+		char *pLocation = NULL;
+		char *pType = NULL;
+		char *pLanguage = NULL;
+		unsigned int docId = 0;
+
+		if (dbus_message_get_args(pMessage, &error,
+			DBUS_TYPE_UINT32, &docId,
+			DBUS_TYPE_STRING, &pTitle,
+			DBUS_TYPE_STRING, &pLocation,
+			DBUS_TYPE_STRING, &pType,
+			DBUS_TYPE_STRING, &pLanguage,
+			DBUS_TYPE_INVALID) == TRUE)
+		{
+			DocumentInfo docInfo(pTitle, pLocation, pType,
+				((pLanguage != NULL) ? Languages::toLocale(pLanguage) : ""));
+
+#ifdef DEBUG
+			cout << "messageBusFilter: received " << pTitle << ", " << pLocation
+				<< ", " << pType << ", " << pLanguage << ", " << docId << endl;
 #endif
-		// Simple types are returned as const references and don't need to be freed
-		dbus_error_init(&error);
+
+			// FIXME: update the document info
+
+			// Prepare the reply
+			pReply = dbus_message_new_method_return(pMessage);
+			if (pReply != NULL)
+			{
+				dbus_message_append_args(pReply,
+					DBUS_TYPE_UINT32, &docId,
+					DBUS_TYPE_INVALID);
+			}
+		}
+		else
+		{
+#ifdef DEBUG
+			cout << "messageBusFilter: " << error.message << endl;
+#endif
+			// Use the error message as reply
+			pReply = dbus_message_new_error(pMessage, error.name, error.message);
+		}
+
+		processedMessage = true;
+	}
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "SetDocumentLabels") == TRUE)
+	{
+		char **ppLabels = NULL;
+		dbus_uint32_t labelsCount = 0;
+		unsigned int docId = 0;
+
 		if (dbus_message_get_args(pMessage, &error,
+			DBUS_TYPE_UINT32, &docId,
+			DBUS_TYPE_ARRAY, &ppLabels,
+			DBUS_TYPE_UINT32, &labelsCount,
+			DBUS_TYPE_INVALID) == TRUE)
+		{
+#ifdef DEBUG
+			cout << "messageBusFilter: received " << docId
+				<< " with " << labelsCount << " labels" << endl;
+#endif
+			// FIXME: set labels
+
+			// Free container types
+			g_strfreev(ppLabels);
+
+			// Prepare the reply
+			pReply = dbus_message_new_method_return(pMessage);
+			if (pReply != NULL)
+			{
+				dbus_message_append_args(pReply,
+					DBUS_TYPE_UINT32, &docId,
+					DBUS_TYPE_INVALID);
+			}
+		}
+		else
+		{
+#ifdef DEBUG
+			cout << "messageBusFilter: " << error.message << endl;
+#endif
+			// Use the error message as reply
+			pReply = dbus_message_new_error(pMessage, error.name, error.message);
+		}
+
+		processedMessage = true;
+	}
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "SimpleQuery") == TRUE)
+	{
+		char *pSearchText = NULL;
+		dbus_uint32_t maxHits = 0;
+		unsigned int docId = 0;
+
+		if (dbus_message_get_args(pMessage, &error,
 			DBUS_TYPE_STRING, &pSearchText,
 			DBUS_TYPE_UINT32, &maxHits,
 			DBUS_TYPE_INVALID) == TRUE)
@@ -333,7 +460,6 @@
 
 					if (docIdsCount > 0)
 					{
-						XapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
 						char *pDocIds[docIdsCount];
 						unsigned int resultIndex = 0;
 
@@ -391,15 +517,11 @@
 			// Use the error message as reply
 			pReply = dbus_message_new_error(pMessage, error.name, error.message);
 		}
-		dbus_error_free(&error);
 
 		processedMessage = true;
 	}
 	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "Stop") == TRUE)
 	{
-		DBusError error;
-
-		dbus_error_init(&error);
 		if (dbus_message_get_args(pMessage, &error,
 			DBUS_TYPE_INVALID) == TRUE)
 		{
@@ -417,11 +539,110 @@
 			quitLoop = true;
 			processedMessage = true;
 		}
-		dbus_error_free(&error);
 	}
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "UnindexDocument") == TRUE)
+	{
+		unsigned int docId = 0;
+
+		if (dbus_message_get_args(pMessage, &error,
+			DBUS_TYPE_UINT32, &docId,
+			DBUS_TYPE_INVALID) == TRUE)
+		{
 #ifdef DEBUG
+			cout << "messageBusFilter: received " << docId << endl;
+#endif
+			// FIXME: unindex document
+
+			// Prepare the reply
+			pReply = dbus_message_new_method_return(pMessage);
+			if (pReply != NULL)
+			{
+				dbus_message_append_args(pReply,
+					DBUS_TYPE_UINT32, &docId,
+					DBUS_TYPE_INVALID);
+			}
+		}
+		else
+		{
+#ifdef DEBUG
+			cout << "messageBusFilter: " << error.message << endl;
+#endif
+			// Use the error message as reply
+			pReply = dbus_message_new_error(pMessage, error.name, error.message);
+		}
+
+		processedMessage = true;
+	}
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "UnindexDocuments") == TRUE)
+	{
+		char *pLabel = NULL;
+
+		if (dbus_message_get_args(pMessage, &error,
+			DBUS_TYPE_STRING, &pLabel,
+			DBUS_TYPE_INVALID) == TRUE)
+		{
+#ifdef DEBUG
+			cout << "messageBusFilter: received " << pLabel << endl;
+#endif
+			// FIXME: unindex documents
+
+			// Prepare the reply
+			pReply = dbus_message_new_method_return(pMessage);
+			if (pReply != NULL)
+			{
+				dbus_message_append_args(pReply,
+					DBUS_TYPE_STRING, &pLabel,
+					DBUS_TYPE_INVALID);
+			}
+		}
+		else
+		{
+#ifdef DEBUG
+			cout << "messageBusFilter: " << error.message << endl;
+#endif
+			// Use the error message as reply
+			pReply = dbus_message_new_error(pMessage, error.name, error.message);
+		}
+
+		processedMessage = true;
+	}
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "UpdateDocument") == TRUE)
+	{
+		unsigned int docId = 0;
+
+		if (dbus_message_get_args(pMessage, &error,
+			DBUS_TYPE_UINT32, &docId,
+			DBUS_TYPE_INVALID) == TRUE)
+		{
+#ifdef DEBUG
+			cout << "messageBusFilter: received " << docId << endl;
+#endif
+			// FIXME: update document
+
+			// Prepare the reply
+			pReply = dbus_message_new_method_return(pMessage);
+			if (pReply != NULL)
+			{
+				dbus_message_append_args(pReply,
+					DBUS_TYPE_UINT32, &docId,
+					DBUS_TYPE_INVALID);
+			}
+		}
+		else
+		{
+#ifdef DEBUG
+			cout << "messageBusFilter: " << error.message << endl;
+#endif
+			// Use the error message as reply
+			pReply = dbus_message_new_error(pMessage, error.name, error.message);
+		}
+
+		processedMessage = true;
+	}
+#ifdef DEBUG
 	else cout << "messageBusFilter: message for foreign object" << endl;
 #endif
+	dbus_error_free(&error);
 
 	// Send a reply ?
 	if (pReply != NULL)
@@ -488,6 +709,9 @@
 	textdomain(GETTEXT_PACKAGE);
 #endif //ENABLE_NLS
 
+	// This should make Xapian use Flint rather than Quartz
+	setenv("XAPIAN_PREFER_FLINT", "1", 1);
+
 	MIMEScanner::initialize();
 	DownloaderInterface::initialize();
 	Glib::thread_init();

Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.xml
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2006-08-11 15:20:29 UTC (rev 393)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2006-08-12 07:47:23 UTC (rev 394)
@@ -2,6 +2,15 @@
 <node name="/de/berlios/Pinot">
   <interface name="de.berlios.Pinot">
     <!--
+	Deletes a label.
+	 label: the name of the label to delete
+	-->
+    <method name="DeleteLabel">
+      <annotation name="de.berlios.Pinot.DeleteLabel" value="pinotDBus"/>
+      <arg type="s" name="label" direction="in"/>
+      <arg type="s" name="label" direction="out"/>
+    </method>
+    <!--
 	Retrieves information about a document.
 	 docId: the document's ID
 	 title : title of the document (automatically extracted from document if possible
@@ -20,13 +29,12 @@
     </method>
     <!--
 	Retrieves statistics.
-	 crawledDirsCount: the number of directories that have been crawled prior
-	                   to entering monitoring mode
+	 crawledCount: the number of documents crawled
 	 docsCount: the number of documents in the index
 	-->
     <method name="GetStatistics">
       <annotation name="de.berlios.Pinot.GetStatistics" value="pinotDBus"/>
-      <arg type="u" name="crawledDirsCount" direction="out"/>
+      <arg type="u" name="crawledCount" direction="out"/>
       <arg type="u" name="docsCount" direction="out"/>
     </method>
     <!--
@@ -37,14 +45,55 @@
 	 language: the document's language in English
 	 labels: array of labels to apply to the document
 	 labelsCount: the number of labels in the array
+	 docId: the document's ID (always 0 for now)
+	-->
+    <method name="IndexDocument">
+      <annotation name="de.berlios.Pinot.IndexDocument" value="pinotDBus"/>
+      <arg type="s" name="title" direction="in"/>
+      <arg type="s" name="location" direction="in"/>
+      <arg type="s" name="type" direction="in"/>
+      <arg type="s" name="language" direction="in"/>
+      <arg type="as" name="labels" direction="in"/>
+      <arg type="u" name="labelsCount" direction="in"/>
+      <arg type="u" name="docId" direction="out"/>
+    </method>
+    <!--
+	Renames a label.
+	 oldLabel: the label to rename
+	 newLabel: the new label name
+	-->
+    <method name="RenameLabel">
+      <annotation name="de.berlios.Pinot.RenameLabel" value="pinotDBus"/>
+      <arg type="s" name="oldLabel" direction="in"/>
+      <arg type="s" name="newLabel" direction="in"/>
+      <arg type="s" name="newLabel" direction="out"/>
+    </method>
+    <!--
+	Sets information about a document.
 	 docId: the document's ID
+	 title : title of the document
+	 location: the document's URL (eg "file:///home/fabrice/Documents/SomeFile.txt")
+	 type: the document's MIME type
+	 language: the document's language in English
 	-->
-    <method name="Index">
-      <annotation name="de.berlios.Pinot.Index" value="pinotDBus"/>
+    <method name="SetDocumentInfo">
+      <annotation name="de.berlios.Pinot.SetDocumentInfo" value="pinotDBus"/>
+      <arg type="u" name="docId" direction="in"/>
       <arg type="s" name="title" direction="in"/>
       <arg type="s" name="location" direction="in"/>
       <arg type="s" name="type" direction="in"/>
       <arg type="s" name="language" direction="in"/>
+      <arg type="u" name="docId" direction="out"/>
+    </method>
+    <!--
+	Sets a document's labels.
+	 docId: the document's ID
+	 labels: array of labels to apply to the document
+	 labelsCount: the number of labels in the array
+	-->
+    <method name="SetDocumentLabels">
+      <annotation name="de.berlios.Pinot.SetDocumentLabels" value="pinotDBus"/>
+      <arg type="u" name="docId" direction="in"/>
       <arg type="as" name="labels" direction="in"/>
       <arg type="u" name="labelsCount" direction="in"/>
       <arg type="u" name="docId" direction="out"/>
@@ -71,5 +120,32 @@
       <annotation name="de.berlios.Pinot.Stop" value="pinotDBus"/>
       <arg type="i" name="exitStatus" direction="out" />
     </method>
+    <!--
+	Unindexes a document.
+	 docId: the document's ID
+	-->
+    <method name="UnindexDocument">
+      <annotation name="de.berlios.Pinot.UnindexDocument" value="pinotDBus"/>
+      <arg type="u" name="docId" direction="in"/>
+      <arg type="u" name="docId" direction="out"/>
+    </method>
+    <!--
+	Unindexes documents that match the given label.
+	 label: the name of the label to match
+	-->
+    <method name="UnindexDocuments">
+      <annotation name="de.berlios.Pinot.UnindexDocuments" value="pinotDBus"/>
+      <arg type="s" name="label" direction="in"/>
+      <arg type="s" name="label" direction="out"/>
+    </method>
+    <!--
+	Updates a document
+	 docId: the document's ID
+	-->
+    <method name="UpdateDocument">
+      <annotation name="de.berlios.Pinot.UpdateDocument" value="pinotDBus"/>
+      <arg type="u" name="docId" direction="in"/>
+      <arg type="u" name="docId" direction="out"/>
+    </method>
   </interface>
 </node>

Modified: trunk/UI/GTK2/src/pinot.cc
===================================================================
--- trunk/UI/GTK2/src/pinot.cc	2006-08-11 15:20:29 UTC (rev 393)
+++ trunk/UI/GTK2/src/pinot.cc	2006-08-12 07:47:23 UTC (rev 394)
@@ -132,6 +132,9 @@
 	textdomain(GETTEXT_PACKAGE);
 #endif //ENABLE_NLS
 
+	// This should make Xapian use Flint rather than Quartz
+	setenv("XAPIAN_PREFER_FLINT", "1", 1);
+
 	MIMEScanner::initialize();
 	DownloaderInterface::initialize();
 	Glib::thread_init();



From fabricecolin at mail.berlios.de  Wed Aug 16 16:09:25 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 16 Aug 2006 16:09:25 +0200
Subject: [Pinot-svn] r395 - trunk/Monitor
Message-ID: <200608161409.k7GE9P4j023571@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-16 16:09:24 +0200 (Wed, 16 Aug 2006)
New Revision: 395

Modified:
   trunk/Monitor/INotifyMonitor.cpp
   trunk/Monitor/MonitorEvent.cpp
   trunk/Monitor/MonitorEvent.h
   trunk/Monitor/MonitorHandler.h
Log:
Modified MonitorHandler::getLocations(), added initialize() and m_isWatchi to
MonitorEvent.
Fixed events checking in INotifyMonitor.


Modified: trunk/Monitor/INotifyMonitor.cpp
===================================================================
--- trunk/Monitor/INotifyMonitor.cpp	2006-08-12 07:47:23 UTC (rev 394)
+++ trunk/Monitor/INotifyMonitor.cpp	2006-08-16 14:09:24 UTC (rev 395)
@@ -149,7 +149,6 @@
 	{
 		struct inotify_event *pEvent = (struct inotify_event *)&buffer[offset];
 		size_t eventSize = sizeof(struct inotify_event) + pEvent->len;
-		bool isOnWatch = true;
 
 #ifdef DEBUG
 		cout << "INotifyMonitor::retrievePendingEvents: read "
@@ -169,6 +168,7 @@
 
 		MonitorEvent monEvent;
 
+		monEvent.m_isWatch = true;
 		if (pEvent->mask & IN_ISDIR)
 		{
 			monEvent.m_isDirectory = true;
@@ -180,7 +180,7 @@
 		{
 			monEvent.m_location += "/";
 			monEvent.m_location += pEvent->name;
-			isOnWatch = false;
+			monEvent.m_isWatch = false;
 		}
 #ifdef DEBUG
 		cout << "INotifyMonitor::retrievePendingEvents: event on "
@@ -190,63 +190,73 @@
 		map<uint32_t, string>::iterator movedIter = m_movedFrom.end();
 
 		// What type of event ?
-		switch (pEvent->mask)
+		if (pEvent->mask & IN_CREATE)
 		{
-			case IN_CREATE:
-				// Skip regular files
-				if (monEvent.m_isDirectory == true)
-				{
-					monEvent.m_type = MonitorEvent::CREATED;
-				}
-				break;
-			case IN_CLOSE_WRITE:
-				monEvent.m_type = MonitorEvent::WRITE_CLOSED;
-				break;
-			case IN_MOVED_FROM:
-				// Store this until we receive a IN_MOVED_TO event
-				m_movedFrom.insert(pair<uint32_t, string>(pEvent->cookie, monEvent.m_location));
-				break;
-			case IN_MOVED_TO:
-				// What was the previous location ?
-				movedIter = m_movedFrom.find(pEvent->cookie);
-				if (movedIter != m_movedFrom.end())
-				{
-					monEvent.m_previousLocation = movedIter->second;
-					monEvent.m_type = MonitorEvent::MOVED;
+			// Skip regular files
+			if (monEvent.m_isDirectory == true)
+			{
+				monEvent.m_type = MonitorEvent::CREATED;
+			}
+		}
+		else if (pEvent->mask & IN_CLOSE_WRITE)
+		{
+			monEvent.m_type = MonitorEvent::WRITE_CLOSED;
+		}
+		else if (pEvent->mask & IN_MOVED_FROM)
+		{
+			// Store this until we receive a IN_MOVED_TO event
+			m_movedFrom.insert(pair<uint32_t, string>(pEvent->cookie, monEvent.m_location));
+		}
+		else if (pEvent->mask & IN_MOVED_TO)
+		{
+			// What was the previous location ?
+			movedIter = m_movedFrom.find(pEvent->cookie);
+			if (movedIter != m_movedFrom.end())
+			{
+				monEvent.m_previousLocation = movedIter->second;
+				monEvent.m_type = MonitorEvent::MOVED;
 #ifdef DEBUG
-					cout << "INotifyMonitor::retrievePendingEvents: moved from "
-						<< monEvent.m_previousLocation << endl;
+				cout << "INotifyMonitor::retrievePendingEvents: moved from "
+					<< monEvent.m_previousLocation << endl;
 #endif
-					m_movedFrom.erase(movedIter);
-				}
+				m_movedFrom.erase(movedIter);
+			}
 #ifdef DEBUG
-				else cout << "INotifyMonitor::retrievePendingEvents: don't know where file was moved from" << endl;
+			else cout << "INotifyMonitor::retrievePendingEvents: don't know where file was moved from" << endl;
 #endif
-				break;
-			case IN_DELETE:
-				monEvent.m_type = MonitorEvent::DELETED;
-				break;
-			case IN_MOVE_SELF:
-				// FIXME: how do we find out where the watched location was moved to ?
-			case IN_DELETE_SELF:
+		}
+		else if (pEvent->mask & IN_DELETE)
+		{
+			monEvent.m_type = MonitorEvent::DELETED;
+		}
+		else if (pEvent->mask & IN_MOVE_SELF)
+		{
+			// FIXME: how do we find out where the watched location was moved to ?
+		}
+		else if (pEvent->mask & IN_DELETE_SELF)
+		{
 #ifdef DEBUG
-				cout << "INotifyMonitor::retrievePendingEvents: watch moved or deleted itself" << endl;
+			cout << "INotifyMonitor::retrievePendingEvents: watch moved or deleted itself" << endl;
 #endif
+			if (monEvent.m_isWatch == true)
+			{
 				removeLocation(monEvent.m_location);
-				break;
-			case IN_UNMOUNT:
-				if (isOnWatch == true)
-				{
-					// Watches are removed if the backing filesystem is unmounted
-					removeLocation(monEvent.m_location);
-				}
-				break;
-			default:
+			}
+		}
+		else if (pEvent->mask & IN_UNMOUNT)
+		{
+			if (monEvent.m_isWatch == true)
+			{
+				// Watches are removed silently if the backing filesystem is unmounted
+				removeLocation(monEvent.m_location);
+			}
+		}
+		else
+		{
 #ifdef DEBUG
-				cout << "INotifyMonitor::retrievePendingEvents: ignoring event "
-					<< pEvent->mask << endl;
+			cout << "INotifyMonitor::retrievePendingEvents: ignoring event "
+				<< pEvent->mask << endl;
 #endif
-				break;
 		}
 
 		// Return event ?

Modified: trunk/Monitor/MonitorEvent.cpp
===================================================================
--- trunk/Monitor/MonitorEvent.cpp	2006-08-12 07:47:23 UTC (rev 394)
+++ trunk/Monitor/MonitorEvent.cpp	2006-08-16 14:09:24 UTC (rev 395)
@@ -20,6 +20,7 @@
 using std::string;
 
 MonitorEvent::MonitorEvent() :
+	m_isWatch(false),
 	m_type(UNKNOWN),
 	m_isDirectory(false)
 {
@@ -29,6 +30,7 @@
 {
 	m_location = other.m_location;
 	m_previousLocation = other.m_previousLocation;
+	m_isWatch = other.m_isWatch;
 	m_type = other.m_type;
 	m_isDirectory = other.m_isDirectory;
 }
@@ -41,6 +43,7 @@
 {
 	m_location = other.m_location;
 	m_previousLocation = other.m_previousLocation;
+	m_isWatch = other.m_isWatch;
 	m_type = other.m_type;
 	m_isDirectory = other.m_isDirectory;
 

Modified: trunk/Monitor/MonitorEvent.h
===================================================================
--- trunk/Monitor/MonitorEvent.h	2006-08-12 07:47:23 UTC (rev 394)
+++ trunk/Monitor/MonitorEvent.h	2006-08-16 14:09:24 UTC (rev 395)
@@ -34,6 +34,7 @@
 
 		std::string m_location;
 		std::string m_previousLocation;
+		bool m_isWatch;
 		EventType m_type;
 		bool m_isDirectory;
 

Modified: trunk/Monitor/MonitorHandler.h
===================================================================
--- trunk/Monitor/MonitorHandler.h	2006-08-12 07:47:23 UTC (rev 394)
+++ trunk/Monitor/MonitorHandler.h	2006-08-16 14:09:24 UTC (rev 395)
@@ -24,6 +24,7 @@
 #include <sigc++/slot.h>
 
 #include "IndexedDocument.h"
+#include "MonitorInterface.h"
 
 class MonitorHandler
 {
@@ -31,9 +32,11 @@
 		MonitorHandler();
 		virtual ~MonitorHandler();
 
+		/// Initializes things before starting monitoring.
+		virtual void initialize(void) = 0;
+
 		/// Returns locations.
-		virtual bool getLocations(std::set<std::string> &newLocations,
-			std::set<std::string> &locationsToRemove) = 0;
+		virtual const std::set<std::string> &getLocations(void) const = 0;
 
 		/// Handles file existence events.
 		virtual bool fileExists(const std::string &fileName) = 0;
@@ -54,6 +57,7 @@
 		SigC::Signal3<void, IndexedDocument, unsigned int, std::string>& getUpdateSignal(void);
 
 	protected:
+		std::set<std::string> m_locations;
 		SigC::Signal3<void, IndexedDocument, unsigned int, std::string> m_signalUpdate;
 
 	private:



From fabricecolin at mail.berlios.de  Wed Aug 16 16:10:36 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 16 Aug 2006 16:10:36 +0200
Subject: [Pinot-svn] r396 - trunk/SQL
Message-ID: <200608161410.k7GEAaQP023700@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-16 16:10:35 +0200 (Wed, 16 Aug 2006)
New Revision: 396

Modified:
   trunk/SQL/CrawlHistory.cpp
   trunk/SQL/CrawlHistory.h
Log:
New methods getSources() and getSourceItems().


Modified: trunk/SQL/CrawlHistory.cpp
===================================================================
--- trunk/SQL/CrawlHistory.cpp	2006-08-16 14:09:24 UTC (rev 395)
+++ trunk/SQL/CrawlHistory.cpp	2006-08-16 14:10:35 UTC (rev 396)
@@ -46,6 +46,9 @@
 		case CRAWLED:
 			text = "CRAWLED";
 			break;
+		case DIRECTORY:
+			text = "DIRECTORY";
+			break;
 		default:
 			break;
 	}
@@ -65,6 +68,10 @@
 	{
 		status = CRAWLED;
 	}
+	else if (text == "DIRECTORY")
+	{
+		status = DIRECTORY;
+	}
 
 	return status;
 }
@@ -158,6 +165,34 @@
 	return success;
 }
 
+/// Returns sources.
+unsigned int CrawlHistory::getSources(map<unsigned int, string> &sources) const
+{
+	unsigned int count = 0;
+
+	SQLiteResults *results = executeStatement("SELECT SourceID, Url FROM CrawlSources;");
+	if (results != NULL)
+	{
+		while (results->hasMoreRows() == true)
+		{
+			SQLiteRow *row = results->nextRow();
+			if (row == NULL)
+			{
+				break;
+			}
+
+			sources[(unsigned int)atoi(row->getColumn(0).c_str())] = row->getColumn(1);
+			++count;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return count;
+}
+
 /// Deletes a source.
 bool CrawlHistory::deleteSource(unsigned int sourceId)
 {
@@ -235,6 +270,37 @@
 	return success;
 }
 
+/// Returns items that belong to a source.
+unsigned int CrawlHistory::getSourceItems(unsigned int sourceId, CrawlStatus status,
+	time_t minDate, set<string> &urls) const
+{
+	unsigned int count = 0;
+
+	SQLiteResults *results = executeStatement("SELECT Url FROM CrawlHistory \
+		WHERE SourceId='%u' AND CrawlStatus='%q' AND Date>='%d';",
+		sourceId, statusToText(status).c_str(), minDate);
+	if (results != NULL)
+	{
+		while (results->hasMoreRows() == true)
+		{
+			SQLiteRow *row = results->nextRow();
+			if (row == NULL)
+			{
+				break;
+			}
+
+			urls.insert(row->getColumn(0));
+			++count;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return count;
+}
+
 /// Returns the number of URLs.
 unsigned int CrawlHistory::getItemsCount(void) const
 {

Modified: trunk/SQL/CrawlHistory.h
===================================================================
--- trunk/SQL/CrawlHistory.h	2006-08-16 14:09:24 UTC (rev 395)
+++ trunk/SQL/CrawlHistory.h	2006-08-16 14:10:35 UTC (rev 396)
@@ -19,6 +19,8 @@
 
 #include <time.h>
 #include <string>
+#include <map>
+#include <set>
 
 #include "SQLiteBase.h"
 
@@ -30,7 +32,7 @@
 		CrawlHistory(const string &database);
 		virtual ~CrawlHistory();
 
-		typedef enum { UNKNOWN, CRAWLING, CRAWLED } CrawlStatus;
+		typedef enum { UNKNOWN, CRAWLING, CRAWLED, DIRECTORY } CrawlStatus;
 
 		/// Creates the CrawlHistory table in the database.
 		static bool create(const string &database);
@@ -41,6 +43,9 @@
 		/// Checks if the source exists.
 		bool hasSource(const string &url, unsigned int &sourceId);
 
+		/// Returns sources.
+		unsigned int getSources(map<unsigned int, string> &sources) const;
+
 		/// Deletes a source.
 		bool deleteSource(unsigned int sourceId);
 
@@ -53,12 +58,13 @@
 		/// Updates an URL.
 		bool updateItem(const string &url, CrawlStatus status, time_t date);
 
+		/// Returns items that belong to a source.
+		unsigned int getSourceItems(unsigned int sourceId, CrawlStatus status,
+			time_t minDate, set<string> &urls) const;
+
 		/// Returns the number of URLs.
 		unsigned int getItemsCount(void) const;
 
-		/// Checks if an URL is in the history.
-		bool hasItem(const string &url) const;
-
 		/// Deletes an URL.
 		bool deleteItem(const string &url);
 



From fabricecolin at mail.berlios.de  Wed Aug 16 16:36:12 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 16 Aug 2006 16:36:12 +0200
Subject: [Pinot-svn] r397 - trunk/UI/GTK2/src
Message-ID: <200608161436.k7GEaCjQ026026@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-16 16:36:12 +0200 (Wed, 16 Aug 2006)
New Revision: 397

Modified:
   trunk/UI/GTK2/src/MboxHandler.cpp
   trunk/UI/GTK2/src/MboxHandler.h
   trunk/UI/GTK2/src/OnDiskHandler.cpp
   trunk/UI/GTK2/src/OnDiskHandler.h
Log:
Synced with changes to MonitorHandler.
Both handlers remove documents that belong to sources that were previously
monitored but no longer are.
Use the daemon index for mail messages rather than a separate index.


Modified: trunk/UI/GTK2/src/MboxHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-16 14:10:35 UTC (rev 396)
+++ trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-16 14:36:12 UTC (rev 397)
@@ -26,10 +26,9 @@
 #include "StringManip.h"
 #include "Timer.h"
 #include "TimeConverter.h"
+#include "Url.h"
 #include "XapianDatabase.h"
 #include "TokenizerFactory.h"
-#include "FileCollector.h"
-#include "WritableXapianIndex.h"
 #include "MboxHandler.h"
 
 using namespace std;
@@ -38,6 +37,7 @@
 MboxHandler::MboxHandler() :
 	MonitorHandler(),
 	m_history(PinotSettings::getInstance().m_historyDatabase),
+	m_index(PinotSettings::getInstance().m_daemonIndexLocation),
 	m_sourceId(0)
 {
 	// Does the email source exist ?
@@ -112,9 +112,7 @@
 	// Come up with a label for this mbox file's messages
 	sourceLabel += fileName;
 
-	// Get the mail index
-	WritableXapianIndex index(PinotSettings::getInstance().m_mailIndexLocation);
-	if (index.isGood() == false)
+	if (m_index.isGood() == false)
 	{
 		cerr << "MboxHandler::indexMessages: couldn't get mail index" << endl;
 		return false;
@@ -123,10 +121,10 @@
 	// Get a parser
 	MboxParser boxParser(fileName, mboxOffset);
 
-	bool indexedFile = parseMailAccount(boxParser, &index, sourceLabel);
+	bool indexedFile = parseMailAccount(boxParser, sourceLabel);
 
 	// Flush the index
-	index.flush();
+	m_index.flush();
 
 	// Update this mail account's record
 	m_history.updateItem("file://" + fileName, CrawlHistory::CRAWLED, mailAccount.m_modTime);
@@ -134,17 +132,11 @@
 	return indexedFile;
 }
 
-bool MboxHandler::parseMailAccount(MboxParser &boxParser, WritableIndexInterface *pIndex,
-	const string &sourceLabel)
+bool MboxHandler::parseMailAccount(MboxParser &boxParser, const string &sourceLabel)
 {
 	set<unsigned int> docIdList;
 	bool indexedFile = false;
 
-	if (pIndex == NULL)
-	{
-		return false;
-	}
-
 #ifdef DEBUG
 	Timer timer;
 	timer.start();
@@ -154,7 +146,7 @@
 	unsigned int docNum = 0;
 
 	// Get a list of documents labeled with this source label
-	pIndex->listDocumentsWithLabel(sourceLabel, docIdList); 
+	m_index.listDocumentsWithLabel(sourceLabel, docIdList); 
 
 	// This is the labels we'll apply to new documents
 	labels.insert(sourceLabel);
@@ -163,10 +155,10 @@
 	while (pMessage != NULL)
 	{
 		// Has this message already been indexed ?
-		unsigned int docId = pIndex->hasDocument(pMessage->getLocation());
+		unsigned int docId = m_index.hasDocument(pMessage->getLocation());
 		if (docId == 0)
 		{
-			pIndex->setStemmingMode(WritableIndexInterface::STORE_BOTH);
+			m_index.setStemmingMode(WritableIndexInterface::STORE_BOTH);
 
 			// Get an ad hoc tokenizer for the message
 			Tokenizer *pTokenizer = TokenizerFactory::getTokenizerByType(pMessage->getType(), pMessage);
@@ -179,20 +171,20 @@
 			}
 
 			unsigned int docId = 0;
-			indexedFile = pIndex->indexDocument(*pTokenizer, labels, docId);
+			indexedFile = m_index.indexDocument(*pTokenizer, labels, docId);
 			if (indexedFile == true)
 			{
 				time_t messageDate = boxParser.getDate();
 
-				pIndex->setDocumentLabels(docId, labels);
+				m_index.setDocumentLabels(docId, labels);
 
 				IndexedDocument docInfo(pMessage->getTitle(),
-					XapianDatabase::buildUrl(PinotSettings::getInstance().m_mailIndexLocation, docId),
+					XapianDatabase::buildUrl(PinotSettings::getInstance().m_daemonIndexLocation, docId),
 					pMessage->getLocation(), pMessage->getType(), pMessage->getLanguage());
 				docInfo.setTimestamp(TimeConverter::toTimestamp(messageDate));
 
 				// Signal
-				m_signalUpdate(docInfo, docId, _("My Email"));
+				m_signalUpdate(docInfo, docId, _("My Computer"));
 			}
 #ifdef DEBUG
 			else cout << "MboxHandler::parseMailAccount: couldn't index message " << docNum << endl;
@@ -233,20 +225,15 @@
 
 	// Any document still in the list wasn't found this time around
 	// and should be unindexed
-	deleteMessages(pIndex, docIdList);
+	deleteMessages(docIdList);
 
 	return indexedFile;
 }
 
-bool MboxHandler::deleteMessages(WritableIndexInterface *pIndex, set<unsigned int> &docIdList)
+bool MboxHandler::deleteMessages(set<unsigned int> &docIdList)
 {
 	bool unindexedMsgs = false;
 
-	if (pIndex == NULL)
-	{
-		return false;
-	}
-
 #ifdef DEBUG
 	cout << "MboxHandler::deleteMessages: " << docIdList.size() << " message(s) to unindex" << endl;
 #endif
@@ -256,7 +243,7 @@
 #ifdef DEBUG
 		cout << "MboxHandler::deleteMessages: unindexing document ID " << *docIter << endl;
 #endif
-		if (pIndex->unindexDocument(*docIter) == true)
+		if (m_index.unindexDocument(*docIter) == true)
 		{
 			unindexedMsgs = true;
 		}
@@ -265,62 +252,53 @@
 	return unindexedMsgs;
 }
 
-bool MboxHandler::getLocations(set<string> &newLocations,
-	set<string> &locationsToRemove)
+void MboxHandler::initialize(void)
 {
-	newLocations.clear();
-	locationsToRemove.clear();
+	set<string> mailboxes;
 
-	copy(m_locations.begin(), m_locations.end(),
-		inserter(locationsToRemove, locationsToRemove.begin()));
-
 	// Get the mail accounts map
 	set<PinotSettings::TimestampedItem> &mailAccounts = PinotSettings::getInstance().m_mailAccounts;
 	for (set<PinotSettings::TimestampedItem>::iterator mailIter = mailAccounts.begin();
 		mailIter != mailAccounts.end(); ++mailIter)
 	{
-		// Is this a known location ?
-		set<string>::iterator locationIter = m_locations.find(mailIter->m_name);
-		if (locationIter == m_locations.end())
-		{
-			// No, it is new
-			m_locations.insert(mailIter->m_name);
-			newLocations.insert(mailIter->m_name);
-		}
-		else
-		{
-			// Since it's a known location, we'd better not remove it
-			set<string>::iterator removeIter = locationsToRemove.find(mailIter->m_name);
-			if (removeIter != locationsToRemove.end())
-			{
-				locationsToRemove.erase(removeIter);
-			}
-		}
+		m_locations.insert(mailIter->m_name);
 	}
 
-	// Locations in locationsToRemove have to be removed
-	for (set<string>::iterator removeIter = locationsToRemove.begin();
-		removeIter != locationsToRemove.end(); ++removeIter)
+	// Unindex messages that belong to mailboxes that no longer exist
+	if (m_history.getSourceItems(m_sourceId, CrawlHistory::CRAWLED, 0, mailboxes) > 0)
 	{
-		set<string>::iterator locationIter = m_locations.find(*removeIter);
-		if (locationIter != m_locations.end())
+		for(set<string>::const_iterator mailIter = mailboxes.begin();
+			mailIter != mailboxes.end(); ++mailIter)
 		{
-			m_locations.erase(locationIter);
-		}
-	}
+			Url urlObj(*mailIter);
 
+			// Is this a file and does it still exist ?
+			if ((urlObj.getProtocol() == "file") &&
+				(m_locations.find(*mailIter) == m_locations.end()))
+			{
+				string sourceLabel("mailbox://");
+
+				sourceLabel += urlObj.getLocation();
+				sourceLabel += "/";
+				sourceLabel += urlObj.getFile();
+
 #ifdef DEBUG
-	cout << "MboxHandler::getLocations: " << m_locations.size() << " locations, "
-		<< newLocations.size() << " new, " << locationsToRemove.size() << " to be removed" << endl;
+				cout << "MboxHandler::initialize: removing messages with label "
+					<< sourceLabel << endl;
 #endif
+				// All documents with this label will be unindexed
+				m_index.unindexDocuments(sourceLabel);
+			}
 
-	if ((newLocations.empty() == false) ||
-		(locationsToRemove.empty() == false))
-	{
-		return true;
+			// Delete this item
+			m_history.deleteItem(*mailIter);
+		}
 	}
+}
 
-	return false;
+const set<string> &MboxHandler::getLocations(void) const
+{
+	return m_locations;
 }
 
 bool MboxHandler::fileExists(const string &fileName)
@@ -373,21 +351,19 @@
 
 	sourceLabel += fileName;
 
-	// Get the mail index
-	WritableXapianIndex index(PinotSettings::getInstance().m_mailIndexLocation);
-	if (index.isGood() == false)
+	if (m_index.isGood() == false)
 	{
 		cerr << "MboxHandler::fileDeleted: couldn't get mail index" << endl;
 		return false;
 	}
 
 	// Get a list of documents labeled with this source label
-	if (index.listDocumentsWithLabel(sourceLabel, docIdList) == true)
+	if (m_index.listDocumentsWithLabel(sourceLabel, docIdList) == true)
 	{
 		// Unindex all documents labeled with this source label
-		deleteMessages(&index, docIdList); 
+		deleteMessages(docIdList); 
 		// Delete the label
-		index.deleteLabel(sourceLabel);
+		m_index.deleteLabel(sourceLabel);
 
 		return true;
 	}

Modified: trunk/UI/GTK2/src/MboxHandler.h
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.h	2006-08-16 14:10:35 UTC (rev 396)
+++ trunk/UI/GTK2/src/MboxHandler.h	2006-08-16 14:36:12 UTC (rev 397)
@@ -25,7 +25,7 @@
 #include "IndexedDocument.h"
 #include "MboxParser.h"
 #include "CrawlHistory.h"
-#include "IndexInterface.h"
+#include "WritableXapianIndex.h"
 #include "MonitorHandler.h"
 #include "PinotSettings.h"
 
@@ -35,9 +35,11 @@
 		MboxHandler();
 		virtual ~MboxHandler();
 
+		/// Initializes things before starting monitoring.
+		virtual void initialize(void);
+
 		/// Returns locations.
-		virtual bool getLocations(std::set<std::string> &newLocations,
-			std::set<std::string> &locationsToRemove);
+		virtual const std::set<std::string> &getLocations(void) const;
 
 		/// Handles file existence events.
 		virtual bool fileExists(const std::string &fileName);
@@ -57,7 +59,7 @@
 
 	protected:
 		CrawlHistory m_history;
-		std::set<std::string> m_locations;
+		WritableXapianIndex m_index;
 		unsigned int m_sourceId;
 
 		bool checkMailAccount(const std::string &fileName, PinotSettings::TimestampedItem &mailAccount);
@@ -65,10 +67,9 @@
 		bool indexMessages(const std::string &fileName, PinotSettings::TimestampedItem &mailAccount,
 			off_t mboxOffset);
 
-		bool parseMailAccount(MboxParser &boxParser, WritableIndexInterface *pIndex,
-			const std::string &sourceLabel);
+		bool parseMailAccount(MboxParser &boxParser, const std::string &sourceLabel);
 
-		bool deleteMessages(WritableIndexInterface *pIndex, std::set<unsigned int> &docIdList);
+		bool deleteMessages(std::set<unsigned int> &docIdList);
 
 	private:
 		MboxHandler(const MboxHandler &other);

Modified: trunk/UI/GTK2/src/OnDiskHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-16 14:10:35 UTC (rev 396)
+++ trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-16 14:36:12 UTC (rev 397)
@@ -28,6 +28,7 @@
 #include "Url.h"
 #include "XapianDatabase.h"
 #include "TokenizerFactory.h"
+#include "CrawlHistory.h"
 #include "FileCollector.h"
 #include "PinotUtils.h"
 #include "OnDiskHandler.h"
@@ -37,6 +38,7 @@
 
 OnDiskHandler::OnDiskHandler() :
 	MonitorHandler(),
+	m_history(PinotSettings::getInstance().m_historyDatabase),
 	m_index(PinotSettings::getInstance().m_daemonIndexLocation)
 {
 	m_index.setStemmingMode(WritableIndexInterface::STORE_BOTH);
@@ -120,65 +122,53 @@
 	return indexedFile;
 }
 
-bool OnDiskHandler::getLocations(set<string> &newLocations,
-	set<string> &locationsToRemove)
+void OnDiskHandler::initialize(void)
 {
-	newLocations.clear();
-	locationsToRemove.clear();
+	map<unsigned int, string> sources;
 
-	// Take advantage of this call to flush the index
-	m_index.flush();
-
-	copy(m_locations.begin(), m_locations.end(),
-		inserter(locationsToRemove, locationsToRemove.begin()));
-
-	// Get the indexable locations map
+	// Get the map of indexable locations
 	set<PinotSettings::TimestampedItem> &indexableLocations = PinotSettings::getInstance().m_indexableLocations;
 	for (set<PinotSettings::TimestampedItem>::iterator dirIter = indexableLocations.begin();
 		dirIter != indexableLocations.end(); ++dirIter)
 	{
-		// Is this a known location ?
-		set<string>::iterator locationIter = m_locations.find(dirIter->m_name);
-		if (locationIter == m_locations.end())
-		{
-			// No, it is new
-			m_locations.insert(dirIter->m_name);
-			newLocations.insert(dirIter->m_name);
-		}
-		else
-		{
-			// Since it's a known location, we'd better not remove it
-			set<string>::iterator removeIter = locationsToRemove.find(*locationIter);
-			if (removeIter != locationsToRemove.end())
-			{
-				locationsToRemove.erase(removeIter);
-			}
-		}
+		m_locations.insert(dirIter->m_name);
 	}
 
-	// Locations in locationsToRemove have to be removed
-	for (set<string>::iterator removeIter = locationsToRemove.begin();
-		removeIter != locationsToRemove.end(); ++removeIter)
+	// Unindex documents that belong to sources that no longer exist
+	if (m_history.getSources(sources) > 0)
 	{
-		set<string>::iterator locationIter = m_locations.find(*removeIter);
-		if (locationIter != m_locations.end())
+		for(map<unsigned int, string>::const_iterator sourceIter = sources.begin();
+			sourceIter != sources.end(); ++sourceIter)
 		{
-			m_locations.erase(locationIter);
-		}
-	}
+			Url urlObj(sourceIter->second);
+			unsigned int sourceId = sourceIter->first;
 
+			// Is this a file and does it still exist ?
+			if ((urlObj.getProtocol() == "file") &&
+				(m_locations.find(sourceIter->second) == m_locations.end()))
+			{
+				char sourceStr[64];
+
+				snprintf(sourceStr, 64, "SOURCE%u", sourceId);
+
 #ifdef DEBUG
-	cout << "OnDiskHandler::getLocations: " << m_locations.size() << " locations, "
-		<< newLocations.size() << " new, " << locationsToRemove.size() << " to be removed" << endl;
+				cout << "OnDiskHandler::initialize: removing messages with label "
+					<< sourceStr << endl;
 #endif
+				// All documents with this label will be unindexed
+				m_index.unindexDocuments(sourceStr);
+			}
 
-	if ((newLocations.empty() == false) ||
-		(locationsToRemove.empty() == false))
-	{
-		return true;
+			// Delete the source itself and all its items
+			m_history.deleteSource(sourceId);
+			m_history.deleteItems(sourceId);
+		}
 	}
+}
 
-	return false;
+const set<string> &OnDiskHandler::getLocations(void) const
+{
+	return m_locations;
 }
 
 bool OnDiskHandler::fileExists(const string &fileName)
@@ -248,4 +238,3 @@
 
 	return false;
 }
-

Modified: trunk/UI/GTK2/src/OnDiskHandler.h
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-16 14:10:35 UTC (rev 396)
+++ trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-16 14:36:12 UTC (rev 397)
@@ -22,6 +22,7 @@
 #include <set>
 #include <sigc++/slot.h>
 
+#include "CrawlHistory.h"
 #include "IndexedDocument.h"
 #include "MboxParser.h"
 #include "WritableXapianIndex.h"
@@ -34,9 +35,11 @@
 		OnDiskHandler();
 		virtual ~OnDiskHandler();
 
+		/// Initializes things before starting monitoring.
+		virtual void initialize(void);
+
 		/// Returns locations.
-		virtual bool getLocations(std::set<std::string> &newLocations,
-			std::set<std::string> &locationsToRemove);
+		virtual const std::set<std::string> &getLocations(void) const;
 
 		/// Handles file existence events.
 		virtual bool fileExists(const std::string &fileName);
@@ -55,8 +58,8 @@
 		virtual bool fileDeleted(const std::string &fileName);
 
 	protected:
+		CrawlHistory m_history;
 		WritableXapianIndex m_index;
-		std::set<std::string> m_locations;
 
 		bool indexFile(const std::string &fileName, bool alwaysUpdate);
 



From fabricecolin at mail.berlios.de  Wed Aug 16 16:55:42 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 16 Aug 2006 16:55:42 +0200
Subject: [Pinot-svn] r398 - trunk/Utils
Message-ID: <200608161455.k7GEtgEK030090@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-16 16:55:41 +0200 (Wed, 16 Aug 2006)
New Revision: 398

Modified:
   trunk/Utils/MIMEScanner.cpp
Log:
Minor fix.


Modified: trunk/Utils/MIMEScanner.cpp
===================================================================
--- trunk/Utils/MIMEScanner.cpp	2006-08-16 14:36:12 UTC (rev 397)
+++ trunk/Utils/MIMEScanner.cpp	2006-08-16 14:55:41 UTC (rev 398)
@@ -273,8 +273,7 @@
 	{
 		// Have a peek at the file
 		const char *pType = xdg_mime_get_mime_type_for_file(fileName.c_str(), NULL);
-		if ((pType != NULL) &&
-			(strncasecmp(pType, xdg_mime_type_unknown, strlen(pType)) != 0))
+		if (pType != NULL)
 		{
 			return pType;
 		}



From fabricecolin at mail.berlios.de  Fri Aug 18 12:56:55 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 18 Aug 2006 12:56:55 +0200
Subject: [Pinot-svn] r399 - trunk/Monitor
Message-ID: <200608181056.k7IAutaw008629@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-18 12:56:52 +0200 (Fri, 18 Aug 2006)
New Revision: 399

Modified:
   trunk/Monitor/INotifyMonitor.cpp
   trunk/Monitor/INotifyMonitor.h
   trunk/Monitor/MonitorEvent.h
   trunk/Monitor/MonitorHandler.cpp
   trunk/Monitor/MonitorHandler.h
   trunk/Monitor/MonitorInterface.h
Log:
Upon success, addLocation() generates an internal event of type EXISTS that's
returned by the next call to retrievePendingEvents().
Some minor tweaks.


Modified: trunk/Monitor/INotifyMonitor.cpp
===================================================================
--- trunk/Monitor/INotifyMonitor.cpp	2006-08-16 14:55:41 UTC (rev 398)
+++ trunk/Monitor/INotifyMonitor.cpp	2006-08-18 10:56:52 UTC (rev 399)
@@ -56,18 +56,18 @@
 }
 
 /// Starts monitoring a location.
-bool INotifyMonitor::addLocation(const string &directory)
+bool INotifyMonitor::addLocation(const string &location, bool isDirectory)
 {
 	uint32_t eventsMask = IN_CLOSE_WRITE|IN_MOVE|IN_CREATE|IN_DELETE|IN_UNMOUNT|IN_MOVE_SELF|IN_DELETE_SELF;
 
-	if ((directory.empty() == true) ||
-		(directory == "/") ||
+	if ((location.empty() == true) ||
+		(location == "/") ||
 		(m_monitorFd < 0))
 	{
 		return false;
 	}
 
-	map<string, int>::iterator locationIter = m_locations.find(directory);
+	map<string, int>::iterator locationIter = m_locations.find(location);
 	if (locationIter != m_locations.end())
 	{
 		// This is already being monitored
@@ -75,32 +75,42 @@
 	}
 
 	// FIXME: check the maximum number of watches hasn't been reached (MAX_FILE_WATCHES ?)
-	int dirWd = inotify_add_watch(m_monitorFd, directory.c_str(), eventsMask);
-	if (dirWd >= 0)
+	int watchNum = inotify_add_watch(m_monitorFd, location.c_str(), eventsMask);
+	if (watchNum >= 0)
 	{
-		m_watches.insert(pair<int, string>(dirWd, directory));
-		m_locations.insert(pair<string, int>(directory, dirWd));
+		MonitorEvent monEvent;
+
+		// Generate an event to signal it exists and is being monitored
+		monEvent.m_location = location;
+		monEvent.m_isWatch = true;
+		monEvent.m_type = MonitorEvent::EXISTS;
+		monEvent.m_isDirectory = isDirectory;
+		m_internalEvents.push(monEvent);
+
+		m_watches.insert(pair<int, string>(watchNum, location));
+		m_locations.insert(pair<string, int>(location, watchNum));
 #ifdef DEBUG
-		cout << "INotifyMonitor::addLocation: added watch " << dirWd << " " << directory << endl;
+		cout << "INotifyMonitor::addLocation: added watch "
+			<< watchNum << " " << location << endl;
 #endif
 
 		return true;
 	}
-	cerr << "INotifyMonitor::addLocation: couldn't monitor " << directory << endl;
+	cerr << "INotifyMonitor::addLocation: couldn't monitor " << location << endl;
 
 	return false;
 }
 
 /// Stops monitoring a location.
-bool INotifyMonitor::removeLocation(const string &directory)
+bool INotifyMonitor::removeLocation(const string &location)
 {
-	if ((directory.empty() == true) ||
+	if ((location.empty() == true) ||
 		(m_monitorFd < 0))
 	{
 		return false;
 	}
 
-	map<string, int>::iterator locationIter = m_locations.find(directory);
+	map<string, int>::iterator locationIter = m_locations.find(location);
 	if (locationIter != m_locations.end())
 	{
 		inotify_rm_watch(m_monitorFd, locationIter->second);
@@ -113,7 +123,8 @@
 
 		return true;
 	}
-	cerr << "INotifyMonitor::removeLocation: " << directory << " is not being monitored" << endl;
+	cerr << "INotifyMonitor::removeLocation: " << location
+		<< " is not being monitored" << endl;
 
 	return false;
 }
@@ -130,6 +141,16 @@
 		return false;
 	}
 
+	// Copy internal events
+	while (m_internalEvents.empty() == false)
+	{
+		MonitorEvent &internalEvent = m_internalEvents.front();
+		events.push(internalEvent);
+
+		// Next
+		events.pop();
+	}
+
 	if (ioctl (m_monitorFd, FIONREAD, &queueLen) == 0)
 	{
 #ifdef DEBUG

Modified: trunk/Monitor/INotifyMonitor.h
===================================================================
--- trunk/Monitor/INotifyMonitor.h	2006-08-16 14:55:41 UTC (rev 398)
+++ trunk/Monitor/INotifyMonitor.h	2006-08-18 10:56:52 UTC (rev 399)
@@ -30,15 +30,16 @@
 		virtual ~INotifyMonitor();
 
 		/// Adds a watch for the specified location.
-		virtual bool addLocation(const std::string &directory);
+		virtual bool addLocation(const std::string &location, bool isDirectory);
 
 		/// Removed the watch for the specified location.
-		virtual bool removeLocation(const std::string &directory);
+		virtual bool removeLocation(const std::string &location);
 
 		/// Retrieves pending events.
 		virtual bool retrievePendingEvents(std::queue<MonitorEvent> &events);
 
 	protected:
+		std::queue<MonitorEvent> m_internalEvents;
 		std::map<std::string, int> m_locations;
 		std::map<uint32_t, std::string> m_movedFrom;
 

Modified: trunk/Monitor/MonitorEvent.h
===================================================================
--- trunk/Monitor/MonitorEvent.h	2006-08-16 14:55:41 UTC (rev 398)
+++ trunk/Monitor/MonitorEvent.h	2006-08-18 10:56:52 UTC (rev 399)
@@ -30,7 +30,7 @@
 
 		bool operator<(const MonitorEvent& other) const;
 
-		typedef enum { UNKNOWN = 0, CREATED, WRITE_CLOSED, MOVED, DELETED } EventType;
+		typedef enum { UNKNOWN = 0, EXISTS, CREATED, WRITE_CLOSED, MOVED, DELETED } EventType;
 
 		std::string m_location;
 		std::string m_previousLocation;

Modified: trunk/Monitor/MonitorHandler.cpp
===================================================================
--- trunk/Monitor/MonitorHandler.cpp	2006-08-16 14:55:41 UTC (rev 398)
+++ trunk/Monitor/MonitorHandler.cpp	2006-08-18 10:56:52 UTC (rev 399)
@@ -27,6 +27,11 @@
 {
 }
 
+const set<string> &MonitorHandler::getLocations(void) const
+{
+	return m_locations;
+}
+
 Signal3<void, IndexedDocument, unsigned int, string>& MonitorHandler::getUpdateSignal(void)
 {
 	return m_signalUpdate;

Modified: trunk/Monitor/MonitorHandler.h
===================================================================
--- trunk/Monitor/MonitorHandler.h	2006-08-16 14:55:41 UTC (rev 398)
+++ trunk/Monitor/MonitorHandler.h	2006-08-18 10:56:52 UTC (rev 399)
@@ -35,8 +35,8 @@
 		/// Initializes things before starting monitoring.
 		virtual void initialize(void) = 0;
 
-		/// Returns locations.
-		virtual const std::set<std::string> &getLocations(void) const = 0;
+		/// Handles flushing the index.
+		virtual void flushIndex(void) = 0;
 
 		/// Handles file existence events.
 		virtual bool fileExists(const std::string &fileName) = 0;
@@ -54,6 +54,10 @@
 		/// Handles file deleted events.
 		virtual bool fileDeleted(const std::string &fileName) = 0;
 
+		/// Returns locations.
+		const std::set<std::string> &getLocations(void) const;
+
+		/// Returns the file update signal.
 		SigC::Signal3<void, IndexedDocument, unsigned int, std::string>& getUpdateSignal(void);
 
 	protected:

Modified: trunk/Monitor/MonitorInterface.h
===================================================================
--- trunk/Monitor/MonitorInterface.h	2006-08-16 14:55:41 UTC (rev 398)
+++ trunk/Monitor/MonitorInterface.h	2006-08-18 10:56:52 UTC (rev 399)
@@ -37,10 +37,10 @@
 		}
 
 		/// Adds a watch for the specified location.
-		virtual bool addLocation(const std::string &directory) = 0;
+		virtual bool addLocation(const std::string &location, bool isDirectory) = 0;
 
 		/// Removed the watch for the specified location.
-		virtual bool removeLocation(const std::string &directory) = 0;
+		virtual bool removeLocation(const std::string &location) = 0;
 
 		/// Retrieves pending events.
 		virtual bool retrievePendingEvents(std::queue<MonitorEvent> &events) = 0;



From fabricecolin at mail.berlios.de  Fri Aug 18 12:58:25 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 18 Aug 2006 12:58:25 +0200
Subject: [Pinot-svn] r400 - trunk/SQL
Message-ID: <200608181058.k7IAwPFd009163@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-18 12:57:42 +0200 (Fri, 18 Aug 2006)
New Revision: 400

Modified:
   trunk/SQL/CrawlHistory.cpp
Log:
Fixed SQL in getSourceItems().


Modified: trunk/SQL/CrawlHistory.cpp
===================================================================
--- trunk/SQL/CrawlHistory.cpp	2006-08-18 10:56:52 UTC (rev 399)
+++ trunk/SQL/CrawlHistory.cpp	2006-08-18 10:57:42 UTC (rev 400)
@@ -277,7 +277,7 @@
 	unsigned int count = 0;
 
 	SQLiteResults *results = executeStatement("SELECT Url FROM CrawlHistory \
-		WHERE SourceId='%u' AND CrawlStatus='%q' AND Date>='%d';",
+		WHERE SourceId='%u' AND Status='%q' AND Date>='%d';",
 		sourceId, statusToText(status).c_str(), minDate);
 	if (results != NULL)
 	{



From fabricecolin at mail.berlios.de  Fri Aug 18 13:04:06 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Fri, 18 Aug 2006 13:04:06 +0200
Subject: [Pinot-svn] r401 - trunk/UI/GTK2/src
Message-ID: <200608181104.k7IB46uR010030@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-18 13:03:26 +0200 (Fri, 18 Aug 2006)
New Revision: 401

Modified:
   trunk/UI/GTK2/src/MboxHandler.cpp
   trunk/UI/GTK2/src/MboxHandler.h
   trunk/UI/GTK2/src/OnDiskHandler.cpp
   trunk/UI/GTK2/src/OnDiskHandler.h
Log:
Fixed initialize(), implemented flushIndex(), synced with MonitorHandler.


Modified: trunk/UI/GTK2/src/MboxHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-18 10:57:42 UTC (rev 400)
+++ trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-18 11:03:26 UTC (rev 401)
@@ -274,7 +274,7 @@
 
 			// Is this a file and does it still exist ?
 			if ((urlObj.getProtocol() == "file") &&
-				(m_locations.find(*mailIter) == m_locations.end()))
+				(m_locations.find(mailIter->substr(7)) == m_locations.end()))
 			{
 				string sourceLabel("mailbox://");
 
@@ -288,17 +288,21 @@
 #endif
 				// All documents with this label will be unindexed
 				m_index.unindexDocuments(sourceLabel);
+
+				// Delete this item
+				m_history.deleteItem(*mailIter);
 			}
-
-			// Delete this item
-			m_history.deleteItem(*mailIter);
+#ifdef DEBUG
+			else cout << "MboxHandler::initialize: " << *mailIter
+				<< " still configured for monitoring" << endl;
+#endif
 		}
 	}
 }
 
-const set<string> &MboxHandler::getLocations(void) const
+void MboxHandler::flushIndex(void)
 {
-	return m_locations;
+	// The index is flushed after indexing a mailbox
 }
 
 bool MboxHandler::fileExists(const string &fileName)

Modified: trunk/UI/GTK2/src/MboxHandler.h
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.h	2006-08-18 10:57:42 UTC (rev 400)
+++ trunk/UI/GTK2/src/MboxHandler.h	2006-08-18 11:03:26 UTC (rev 401)
@@ -38,8 +38,8 @@
 		/// Initializes things before starting monitoring.
 		virtual void initialize(void);
 
-		/// Returns locations.
-		virtual const std::set<std::string> &getLocations(void) const;
+		/// Handles flushing the index.
+		virtual void flushIndex(void);
 
 		/// Handles file existence events.
 		virtual bool fileExists(const std::string &fileName);

Modified: trunk/UI/GTK2/src/OnDiskHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-18 10:57:42 UTC (rev 400)
+++ trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-18 11:03:26 UTC (rev 401)
@@ -140,35 +140,42 @@
 		for(map<unsigned int, string>::const_iterator sourceIter = sources.begin();
 			sourceIter != sources.end(); ++sourceIter)
 		{
-			Url urlObj(sourceIter->second);
 			unsigned int sourceId = sourceIter->first;
 
 			// Is this a file and does it still exist ?
-			if ((urlObj.getProtocol() == "file") &&
-				(m_locations.find(sourceIter->second) == m_locations.end()))
+			if (sourceIter->second.substr(0, 7) != "file://")
 			{
+				continue;
+			}
+
+			if (m_locations.find(sourceIter->second.substr(7)) == m_locations.end())
+			{
 				char sourceStr[64];
 
 				snprintf(sourceStr, 64, "SOURCE%u", sourceId);
 
 #ifdef DEBUG
-				cout << "OnDiskHandler::initialize: removing messages with label "
-					<< sourceStr << endl;
+				cout << "OnDiskHandler::initialize: " << sourceIter->second
+					<< ", source " << sourceId << " was removed" << endl;
 #endif
 				// All documents with this label will be unindexed
 				m_index.unindexDocuments(sourceStr);
+
+				// Delete the source itself and all its items
+				m_history.deleteSource(sourceId);
+				m_history.deleteItems(sourceId);
 			}
-
-			// Delete the source itself and all its items
-			m_history.deleteSource(sourceId);
-			m_history.deleteItems(sourceId);
+#ifdef DEBUG
+			else cout << "OnDiskHandler::initialize: " << sourceIter->second
+				<< " still configured for monitoring" << endl;
+#endif
 		}
 	}
 }
 
-const set<string> &OnDiskHandler::getLocations(void) const
+void OnDiskHandler::flushIndex(void)
 {
-	return m_locations;
+	m_index.flush();
 }
 
 bool OnDiskHandler::fileExists(const string &fileName)

Modified: trunk/UI/GTK2/src/OnDiskHandler.h
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-18 10:57:42 UTC (rev 400)
+++ trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-18 11:03:26 UTC (rev 401)
@@ -38,8 +38,8 @@
 		/// Initializes things before starting monitoring.
 		virtual void initialize(void);
 
-		/// Returns locations.
-		virtual const std::set<std::string> &getLocations(void) const;
+		/// Handles flushing the index.
+		virtual void flushIndex(void);
 
 		/// Handles file existence events.
 		virtual bool fileExists(const std::string &fileName);



From fabricecolin at mail.berlios.de  Sat Aug 19 07:21:35 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 07:21:35 +0200
Subject: [Pinot-svn] r402 - trunk/UI/GTK2/src
Message-ID: <200608190521.k7J5LZeE011119@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 07:21:23 +0200 (Sat, 19 Aug 2006)
New Revision: 402

Modified:
   trunk/UI/GTK2/src/pinot-dbus-daemon.cc
   trunk/UI/GTK2/src/pinot-dbus-daemon.xml
Log:
Fixed a whole bunch of stuff DBus-wise.
On second thought, it doesn't make sense to allow users to (un)index documents
so the corresponding methods were removed.


Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-18 11:03:26 UTC (rev 401)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-19 05:21:23 UTC (rev 402)
@@ -44,7 +44,7 @@
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "DownloaderInterface.h"
-#include "XapianIndex.h"
+#include "WritableXapianIndex.h"
 #include "XapianEngine.h"
 #include "config.h"
 #include "NLS.h"
@@ -121,12 +121,12 @@
 
 static DBusHandlerResult messageBusFilter(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
 {
-	XapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
+	WritableXapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
 	DaemonState *pServer = NULL;
 	DBusMessage *pReply = NULL;
 	DBusError error;
 	const char *pSender = dbus_message_get_sender(pMessage);
-	bool processedMessage = false, quitLoop = false;
+	bool processedMessage = false, flushIndex = false, quitLoop = false;
 
 	if (pData != NULL)
 	{
@@ -159,7 +159,8 @@
 #ifdef DEBUG
 			cout << "messageBusFilter: received " << pLabel << endl;
 #endif
-			// FIXME: delete the label
+			// Delete the label
+			flushIndex = index.deleteLabel(pLabel);
 
 			// Prepare the reply
 			pReply = dbus_message_new_method_return(pMessage);
@@ -231,68 +232,69 @@
 
 		processedMessage = true;
 	}
-	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "GetStatistics") == TRUE)
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "GetDocumentLabels") == TRUE)
 	{
-		CrawlHistory history(PinotSettings::getInstance().m_historyDatabase);
 		unsigned int docId = 0;
 
-		unsigned int crawledFilesCount = history.getItemsCount();
-		unsigned int docsCount = index.getDocumentsCount();
-
-		// Prepare the reply
-		pReply = dbus_message_new_method_return(pMessage);
-		if (pReply != NULL)
-		{
-			dbus_message_append_args(pReply,
-				DBUS_TYPE_UINT32, &crawledFilesCount,
-				DBUS_TYPE_UINT32, &docsCount,
-				DBUS_TYPE_INVALID);
-		}
-
-		processedMessage = true;
-	}
-	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "IndexDocument") == TRUE)
-	{
-		char *pTitle = NULL;
-		char *pLocation = NULL;
-		char *pType = NULL;
-		char *pLanguage = NULL;
-		char **ppLabels = NULL;
-		dbus_uint32_t labelsCount = 0;
-		unsigned int docId = 0;
-
 		if (dbus_message_get_args(pMessage, &error,
-			DBUS_TYPE_STRING, &pTitle,
-			DBUS_TYPE_STRING, &pLocation,
-			DBUS_TYPE_STRING, &pType,
-			DBUS_TYPE_STRING, &pLanguage,
-			DBUS_TYPE_ARRAY, &ppLabels,
-			DBUS_TYPE_UINT32, &labelsCount,
+			DBUS_TYPE_UINT32, &docId,
 			DBUS_TYPE_INVALID) == TRUE)
 		{
-			DocumentInfo docInfo(pTitle, pLocation, pType,
-				((pLanguage != NULL) ? Languages::toLocale(pLanguage) : ""));
+			set<string> labels;
+			bool replyWithError = true;
 
 #ifdef DEBUG
-			cout << "messageBusFilter: received " << pTitle << ", " << pLocation
-				<< ", " << pType << ", " << pLanguage
-				<< " with " << labelsCount << " labels" << endl;
+			cout << "messageBusFilter: received " << docId << endl;
 #endif
-			// FIXME: set labels on docInfo
+			if (index.getDocumentLabels(docId, labels) == true)
+			{
+				dbus_uint32_t labelsCount = labels.size();
 
-			pServer->queue_index(docInfo);
-			// FIXME: we can't provide a document ID at the moment
+				if (labelsCount > 0)
+				{
+					char *pLabels[labelsCount + 1];
+					unsigned int labelIndex = 0;
 
-			// Free container types
-			g_strfreev(ppLabels);
+					for (set<string>::const_iterator labelIter = labels.begin();
+						labelIter != labels.end(); ++labelIter)
+					{
+						pLabels[labelIndex] = g_strdup(labelIter->c_str());
+						++labelIndex;
+					}
+					pLabels[labelIndex] = NULL;
 
-			// Prepare the reply
-			pReply = dbus_message_new_method_return(pMessage);
-			if (pReply != NULL)
+					// Prepare the reply
+					pReply = dbus_message_new_method_return(pMessage);
+					if (pReply != NULL)
+					{
+						dbus_message_append_args(pReply,
+							DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &pLabels, (int)labelsCount,
+							DBUS_TYPE_INVALID);
+
+						// Send the reply here
+						if (dbus_message_get_no_reply(pMessage) == FALSE)
+						{
+							dbus_connection_send(pConnection, pReply, NULL);
+						}
+						dbus_message_unref(pReply);
+
+						pReply = NULL;
+						replyWithError = false;
+					}
+
+					// Free the array
+					for (unsigned int labelNum = 0; labelNum < labelIndex; ++labelNum)
+					{
+						g_free(pLabels[labelNum]);
+					}
+				}
+			}
+
+			if (replyWithError == true)
 			{
-				dbus_message_append_args(pReply,
-					DBUS_TYPE_UINT32, &docId,
-					DBUS_TYPE_INVALID);
+				pReply = dbus_message_new_error(pMessage,
+					"de.berlios.Pinot.GetDocumentLabels",
+					" failed");
 			}
 		}
 		else
@@ -306,6 +308,25 @@
 
 		processedMessage = true;
 	}
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "GetStatistics") == TRUE)
+	{
+		CrawlHistory history(PinotSettings::getInstance().m_historyDatabase);
+		unsigned int crawledFilesCount = history.getItemsCount();
+		unsigned int docsCount = index.getDocumentsCount();
+		unsigned int docId = 0;
+
+		// Prepare the reply
+		pReply = dbus_message_new_method_return(pMessage);
+		if (pReply != NULL)
+		{
+			dbus_message_append_args(pReply,
+				DBUS_TYPE_UINT32, &crawledFilesCount,
+				DBUS_TYPE_UINT32, &docsCount,
+				DBUS_TYPE_INVALID);
+		}
+
+		processedMessage = true;
+	}
 	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "RenameLabel") == TRUE)
 	{
 		char *pOldLabel = NULL;
@@ -317,10 +338,10 @@
 			DBUS_TYPE_INVALID) == TRUE)
 		{
 #ifdef DEBUG
-			cout << "messageBusFilter: received " << pOldLabel
-				<< " " << pNewLabel << endl;
+			cout << "messageBusFilter: received " << pOldLabel << ", " << pNewLabel << endl;
 #endif
-			// FIXME: rename the label
+			// Rename the label
+			flushIndex = index.renameLabel(pOldLabel, pNewLabel);
 
 			// Prepare the reply
 			pReply = dbus_message_new_method_return(pMessage);
@@ -362,11 +383,12 @@
 				((pLanguage != NULL) ? Languages::toLocale(pLanguage) : ""));
 
 #ifdef DEBUG
-			cout << "messageBusFilter: received " << pTitle << ", " << pLocation
-				<< ", " << pType << ", " << pLanguage << ", " << docId << endl;
+			cout << "messageBusFilter: received " << docId << ", " << pTitle
+				<< ", " << pLocation << ", " << pType << ", " << pLanguage << endl;
 #endif
 
-			// FIXME: update the document info
+			// Update the document info
+			flushIndex = index.updateDocumentInfo(docId, docInfo);
 
 			// Prepare the reply
 			pReply = dbus_message_new_method_return(pMessage);
@@ -393,18 +415,30 @@
 		char **ppLabels = NULL;
 		dbus_uint32_t labelsCount = 0;
 		unsigned int docId = 0;
+		gboolean resetLabels = TRUE;
 
 		if (dbus_message_get_args(pMessage, &error,
 			DBUS_TYPE_UINT32, &docId,
-			DBUS_TYPE_ARRAY, &ppLabels,
-			DBUS_TYPE_UINT32, &labelsCount,
+			DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &ppLabels, &labelsCount,
+			DBUS_TYPE_BOOLEAN, &resetLabels,
 			DBUS_TYPE_INVALID) == TRUE)
 		{
+			set<string> labels;
+
+			for (dbus_uint32_t labelIndex = 0; labelIndex < labelsCount; ++labelIndex)
+			{
+				if (ppLabels[labelIndex] == NULL)
+				{
+					break;
+				}
+				labels.insert(ppLabels[labelIndex]);
+			}
 #ifdef DEBUG
-			cout << "messageBusFilter: received " << docId
+			cout << "messageBusFilter: received " << docId << ", " << resetLabels
 				<< " with " << labelsCount << " labels" << endl;
 #endif
-			// FIXME: set labels
+			// Set labels
+			flushIndex = index.setDocumentLabels(docId, labels, ((resetLabels == TRUE) ? true : false));
 
 			// Free container types
 			g_strfreev(ppLabels);
@@ -478,7 +512,7 @@
 						if (pReply != NULL)
 						{
 							dbus_message_append_args(pReply,
-								DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &pDocIds, &docIdsCount,
+								DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &pDocIds, (int)docIdsCount,
 								DBUS_TYPE_UINT32, &docIdsCount,
 								DBUS_TYPE_INVALID);
 
@@ -540,7 +574,7 @@
 			processedMessage = true;
 		}
 	}
-	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "UnindexDocument") == TRUE)
+	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "UpdateDocument") == TRUE)
 	{
 		unsigned int docId = 0;
 
@@ -548,82 +582,22 @@
 			DBUS_TYPE_UINT32, &docId,
 			DBUS_TYPE_INVALID) == TRUE)
 		{
+			DocumentInfo docInfo;
+
 #ifdef DEBUG
 			cout << "messageBusFilter: received " << docId << endl;
 #endif
-			// FIXME: unindex document
-
-			// Prepare the reply
-			pReply = dbus_message_new_method_return(pMessage);
-			if (pReply != NULL)
+			if (index.getDocumentInfo(docId, docInfo) == true)
 			{
-				dbus_message_append_args(pReply,
-					DBUS_TYPE_UINT32, &docId,
-					DBUS_TYPE_INVALID);
+				// Update document
+				pServer->queue_index(docInfo);
 			}
-		}
-		else
-		{
-#ifdef DEBUG
-			cout << "messageBusFilter: " << error.message << endl;
-#endif
-			// Use the error message as reply
-			pReply = dbus_message_new_error(pMessage, error.name, error.message);
-		}
 
-		processedMessage = true;
-	}
-	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "UnindexDocuments") == TRUE)
-	{
-		char *pLabel = NULL;
-
-		if (dbus_message_get_args(pMessage, &error,
-			DBUS_TYPE_STRING, &pLabel,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-#ifdef DEBUG
-			cout << "messageBusFilter: received " << pLabel << endl;
-#endif
-			// FIXME: unindex documents
-
 			// Prepare the reply
 			pReply = dbus_message_new_method_return(pMessage);
 			if (pReply != NULL)
 			{
 				dbus_message_append_args(pReply,
-					DBUS_TYPE_STRING, &pLabel,
-					DBUS_TYPE_INVALID);
-			}
-		}
-		else
-		{
-#ifdef DEBUG
-			cout << "messageBusFilter: " << error.message << endl;
-#endif
-			// Use the error message as reply
-			pReply = dbus_message_new_error(pMessage, error.name, error.message);
-		}
-
-		processedMessage = true;
-	}
-	else if (dbus_message_is_method_call(pMessage, g_pinotDBusService, "UpdateDocument") == TRUE)
-	{
-		unsigned int docId = 0;
-
-		if (dbus_message_get_args(pMessage, &error,
-			DBUS_TYPE_UINT32, &docId,
-			DBUS_TYPE_INVALID) == TRUE)
-		{
-#ifdef DEBUG
-			cout << "messageBusFilter: received " << docId << endl;
-#endif
-			// FIXME: update document
-
-			// Prepare the reply
-			pReply = dbus_message_new_method_return(pMessage);
-			if (pReply != NULL)
-			{
-				dbus_message_append_args(pReply,
 					DBUS_TYPE_UINT32, &docId,
 					DBUS_TYPE_INVALID);
 			}
@@ -644,6 +618,12 @@
 #endif
 	dbus_error_free(&error);
 
+	if (flushIndex == true)
+	{
+		// Flush now for the sake of the client application
+		index.flush();
+	}
+
 	// Send a reply ?
 	if (pReply != NULL)
 	{
@@ -718,6 +698,8 @@
 
 	// This will create the necessary directories on the first run
 	PinotSettings &settings = PinotSettings::getInstance();
+	// This is the daemon so disable DBus
+	settings.enableDBus(false);
 
 	string confDirectory = PinotSettings::getConfigurationDirectory();
 	chdir(confDirectory.c_str());
@@ -763,21 +745,15 @@
 	sigaction(SIGINT, &newAction, NULL);
 	sigaction(SIGQUIT, &newAction, NULL);
 
-	// Open these indices in read-write mode 
+	// Open the daemon index in read-write mode 
 	XapianDatabase *pDb = XapianDatabaseFactory::getDatabase(settings.m_daemonIndexLocation, false);
 	if ((pDb == NULL) ||
 		(pDb->isOpen() == false))
 	{
-		cerr << _("Couldn't open index") << " " << settings.m_daemonIndexLocation << endl;
+		cerr << "Couldn't open index" << " " << settings.m_daemonIndexLocation << endl;
 
 		return EXIT_FAILURE;
 	}
-	pDb = XapianDatabaseFactory::getDatabase(settings.m_mailIndexLocation, false);
-	if ((pDb == NULL) ||
-		(pDb->isOpen() == false))
-	{
-		cerr << _("Couldn't open index") << " " << settings.m_mailIndexLocation << endl;
-	}
 
 	// Do the same for the history database
 	if ((settings.m_historyDatabase.empty() == true) ||
@@ -785,7 +761,7 @@
 		(QueryHistory::create(settings.m_historyDatabase) == false) ||
 		(ViewHistory::create(settings.m_historyDatabase) == false))
 	{
-		cerr << _("Couldn't create history database") << " " << settings.m_historyDatabase << endl;
+		cerr << "Couldn't create history database" << " " << settings.m_historyDatabase << endl;
 
 		return EXIT_FAILURE;
 	}

Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.xml
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2006-08-18 11:03:26 UTC (rev 401)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.xml	2006-08-19 05:21:23 UTC (rev 402)
@@ -28,6 +28,16 @@
       <arg type="s" name="language" direction="out"/>
     </method>
     <!--
+	Retrieves a document's labels.
+	 docId: the document's ID
+	 labels: array of labels to apply to the document
+	-->
+    <method name="GetDocumentLabels">
+      <annotation name="de.berlios.Pinot.GetDocumentLabels" value="pinotDBus"/>
+      <arg type="u" name="docId" direction="in"/>
+      <arg type="as" name="labels" direction="out"/>
+    </method>
+    <!--
 	Retrieves statistics.
 	 crawledCount: the number of documents crawled
 	 docsCount: the number of documents in the index
@@ -38,26 +48,6 @@
       <arg type="u" name="docsCount" direction="out"/>
     </method>
     <!--
-	Indexes a document (NOT FULLY FUNCTIONAL YET)
-	 title : title of the document
-	 location: the document's URL
-	 type: the document's MIME type
-	 language: the document's language in English
-	 labels: array of labels to apply to the document
-	 labelsCount: the number of labels in the array
-	 docId: the document's ID (always 0 for now)
-	-->
-    <method name="IndexDocument">
-      <annotation name="de.berlios.Pinot.IndexDocument" value="pinotDBus"/>
-      <arg type="s" name="title" direction="in"/>
-      <arg type="s" name="location" direction="in"/>
-      <arg type="s" name="type" direction="in"/>
-      <arg type="s" name="language" direction="in"/>
-      <arg type="as" name="labels" direction="in"/>
-      <arg type="u" name="labelsCount" direction="in"/>
-      <arg type="u" name="docId" direction="out"/>
-    </method>
-    <!--
 	Renames a label.
 	 oldLabel: the label to rename
 	 newLabel: the new label name
@@ -89,13 +79,13 @@
 	Sets a document's labels.
 	 docId: the document's ID
 	 labels: array of labels to apply to the document
-	 labelsCount: the number of labels in the array
+	 resetLabels: TRUE if existing labels should be unset
 	-->
     <method name="SetDocumentLabels">
       <annotation name="de.berlios.Pinot.SetDocumentLabels" value="pinotDBus"/>
       <arg type="u" name="docId" direction="in"/>
       <arg type="as" name="labels" direction="in"/>
-      <arg type="u" name="labelsCount" direction="in"/>
+      <arg type="b" name="resetLabels" direction="in"/>
       <arg type="u" name="docId" direction="out"/>
     </method>
     <!--
@@ -121,27 +111,9 @@
       <arg type="i" name="exitStatus" direction="out" />
     </method>
     <!--
-	Unindexes a document.
+	Updates a document.
 	 docId: the document's ID
 	-->
-    <method name="UnindexDocument">
-      <annotation name="de.berlios.Pinot.UnindexDocument" value="pinotDBus"/>
-      <arg type="u" name="docId" direction="in"/>
-      <arg type="u" name="docId" direction="out"/>
-    </method>
-    <!--
-	Unindexes documents that match the given label.
-	 label: the name of the label to match
-	-->
-    <method name="UnindexDocuments">
-      <annotation name="de.berlios.Pinot.UnindexDocuments" value="pinotDBus"/>
-      <arg type="s" name="label" direction="in"/>
-      <arg type="s" name="label" direction="out"/>
-    </method>
-    <!--
-	Updates a document
-	 docId: the document's ID
-	-->
     <method name="UpdateDocument">
       <annotation name="de.berlios.Pinot.UpdateDocument" value="pinotDBus"/>
       <arg type="u" name="docId" direction="in"/>



From fabricecolin at mail.berlios.de  Sat Aug 19 07:24:51 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 07:24:51 +0200
Subject: [Pinot-svn] r403 - trunk/Index
Message-ID: <200608190524.k7J5Opkg011813@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 07:24:48 +0200 (Sat, 19 Aug 2006)
New Revision: 403

Added:
   trunk/Index/DBusXapianIndex.cpp
   trunk/Index/DBusXapianIndex.h
Log:
An implementation of WritableIndexInterface that talks to the daemon via DBus.
Methods (un)indexDocument(s) don't do anything since they are not exported
by the daemon.


Added: trunk/Index/DBusXapianIndex.cpp
===================================================================
--- trunk/Index/DBusXapianIndex.cpp	2006-08-19 05:21:23 UTC (rev 402)
+++ trunk/Index/DBusXapianIndex.cpp	2006-08-19 05:24:48 UTC (rev 403)
@@ -0,0 +1,449 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+extern "C"
+{
+#define DBUS_API_SUBJECT_TO_CHANGE
+#include <dbus/dbus.h>
+#include <dbus/dbus-glib.h>
+#include <dbus/dbus-glib-lowlevel.h>
+}
+
+#include "Languages.h"
+#include "XapianDatabaseFactory.h"
+#include "DBusXapianIndex.h"
+
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+using std::set;
+using std::min;
+
+static DBusGConnection *getBusConnection(void)
+{
+	GError *pError = NULL;
+	DBusGConnection *pBus = NULL;
+
+	pBus = dbus_g_bus_get(DBUS_BUS_SESSION, &pError);
+	if (pBus == NULL)
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusXapianIndex: couldn't connect to session bus: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	return pBus;
+}
+
+static DBusGProxy *getBusProxy(DBusGConnection *pBus)
+{
+	if (pBus == NULL)
+	{
+		return NULL;
+	}
+
+	return dbus_g_proxy_new_for_name(pBus,
+		"de.berlios.Pinot", "/de/berlios/Pinot", "de.berlios.Pinot");
+}
+
+DBusXapianIndex::DBusXapianIndex(const string &indexName) :
+	WritableIndexInterface(),
+	XapianIndex(indexName)
+{
+}
+
+DBusXapianIndex::~DBusXapianIndex()
+{
+}
+
+void DBusXapianIndex::reopen(void)
+{
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
+	if (pDatabase != NULL)
+	{
+		Xapian::Database *pIndex = pDatabase->readLock();
+
+		// Re-open the database to the latest available version
+		pIndex->reopen();
+
+		pDatabase->unlock();
+	}
+
+}
+
+//
+// Implementation of IndexInterface
+//
+
+/// Returns false if the index couldn't be opened.
+bool DBusXapianIndex::isGood(void) const
+{
+	return m_goodIndex;
+}
+
+/// Gets the index location.
+string DBusXapianIndex::getLocation(void) const
+{
+	return m_databaseName;
+}
+
+/// Returns a document's properties.
+bool DBusXapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
+{
+	return XapianIndex::getDocumentInfo(docId, docInfo);
+}
+
+/// Determines whether a document has a label.
+bool DBusXapianIndex::hasLabel(unsigned int docId, const string &name) const
+{
+	return XapianIndex::hasLabel(docId, name);
+}
+
+/// Returns a document's labels.
+bool DBusXapianIndex::getDocumentLabels(unsigned int docId, set<string> &labels) const
+{
+	return XapianIndex::getDocumentLabels(docId, labels);
+}
+
+/// Checks whether the given URL is in the index.
+unsigned int DBusXapianIndex::hasDocument(const string &url) const
+{
+	return XapianIndex::hasDocument(url);
+}
+
+/// Gets terms with the same root.
+unsigned int DBusXapianIndex::getCloseTerms(const string &term, set<string> &suggestions)
+{
+	return XapianIndex::getCloseTerms(term, suggestions);
+}
+
+/// Returns the ID of the last document.
+unsigned int DBusXapianIndex::getLastDocumentID(void) const
+{
+	return XapianIndex::getLastDocumentID();
+}
+
+/// Returns the number of documents.
+unsigned int DBusXapianIndex::getDocumentsCount(const string &labelName) const
+{
+	return XapianIndex::getDocumentsCount(labelName);
+}
+
+/// Lists document IDs.
+unsigned int DBusXapianIndex::listDocuments(set<unsigned int> &docIds,
+	unsigned int maxDocsCount, unsigned int startDoc) const
+{
+	return XapianIndex::listDocuments(docIds, maxDocsCount, startDoc);
+}
+
+/// Lists documents that have a label.
+bool DBusXapianIndex::listDocumentsWithLabel(const string &name, set<unsigned int> &docIds,
+	unsigned int maxDocsCount, unsigned int startDoc) const
+{
+	return XapianIndex::listDocumentsWithLabel(name, docIds, maxDocsCount, startDoc);
+}
+
+//
+// Implementation of WritableIndexInterface
+//
+
+/// Indexes the given data.
+bool DBusXapianIndex::indexDocument(Tokenizer &tokens, const set<string> &labels,
+	unsigned int &docId)
+{
+	cerr << "DBusXapianIndex::indexDocument: not allowed" << endl;
+	return false;
+}
+
+/// Updates the given document; true if success.
+bool DBusXapianIndex::updateDocument(unsigned int docId, Tokenizer &tokens)
+{
+	bool updated = false;
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusXapianIndex::updateDocument: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	if (dbus_g_proxy_call(pBusProxy, "UpdateDocument", &pError,
+		G_TYPE_UINT, docId,
+		G_TYPE_INVALID,
+		G_TYPE_UINT, &docId,
+		G_TYPE_INVALID) == TRUE)
+	{
+		updated = true;
+		reopen();
+	}
+	else
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusXapianIndex::updateDocument: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	return updated;
+}
+
+/// Updates a document's properties.
+bool DBusXapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo)
+{
+	bool updated = false;
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusXapianIndex::updateDocumentInfo: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	const char *pTitle = docInfo.getTitle().c_str();
+	const char *pLocation = docInfo.getLocation().c_str();
+	const char *pType = docInfo.getType().c_str();
+	const char *pLanguage = Languages::toEnglish(docInfo.getLanguage()).c_str();
+
+	if (dbus_g_proxy_call(pBusProxy, "SetDocumentInfo", &pError,
+		G_TYPE_UINT, docId,
+		G_TYPE_STRING, pTitle,
+		G_TYPE_STRING, pLocation,
+		G_TYPE_STRING, pType,
+		G_TYPE_STRING, pLanguage,
+		G_TYPE_INVALID,
+		G_TYPE_UINT, &docId,
+		G_TYPE_INVALID) == TRUE)
+	{
+		updated = true;
+		reopen();
+	}
+	else
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusXapianIndex::updateDocumentInfo: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	return updated;
+}
+
+/// Sets a document's labels.
+bool DBusXapianIndex::setDocumentLabels(unsigned int docId, const set<string> &labels,
+	bool resetLabels)
+{
+	bool updatedLabels = false;
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusXapianIndex::setDocumentLabels: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	dbus_uint32_t labelsCount = labels.size();
+	char *pLabels[labelsCount + 1];
+	unsigned int labelIndex = 0;
+
+	for (set<string>::const_iterator labelIter = labels.begin();
+		labelIter != labels.end(); ++labelIter)
+	{
+		pLabels[labelIndex] = g_strdup(labelIter->c_str());
+		++labelIndex;
+	}
+	pLabels[labelIndex] = NULL;
+
+	// G_TYPE_STRV is the GLib equivalent of DBUS_TYPE_ARRAY, DBUS_TYPE_STRING
+	if (dbus_g_proxy_call(pBusProxy, "SetDocumentLabels", &pError,
+		G_TYPE_UINT, docId,
+		G_TYPE_STRV, pLabels,
+		G_TYPE_BOOLEAN, resetLabels,
+		G_TYPE_INVALID,
+		G_TYPE_UINT, &docId,
+		G_TYPE_INVALID) == TRUE)
+	{
+		updatedLabels = true;
+		reopen();
+	}
+	else
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusXapianIndex::setDocumentLabels: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	if (labelsCount > 0)
+	{
+		// Free the array
+		for (unsigned int labelNum = 0; labelNum < labelIndex; ++labelNum)
+		{
+			g_free(pLabels[labelNum]);
+		}
+	}
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	return updatedLabels;
+}
+
+/// Unindexes the given document; true if success.
+bool DBusXapianIndex::unindexDocument(unsigned int docId)
+{
+	cerr << "DBusXapianIndex::unindexDocument: not allowed" << endl;
+	return false;
+}
+
+/// Unindexes documents with the given label.
+bool DBusXapianIndex::unindexDocuments(const string &labelName)
+{
+	cerr << "DBusXapianIndex::unindexDocuments: not allowed" << endl;
+	return false;
+}
+
+/// Renames a label.
+bool DBusXapianIndex::renameLabel(const string &name, const string &newName)
+{
+	bool renamedLabel = false;
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusXapianIndex::renameLabel: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	const char *pOldLabel = name.c_str();
+	const char *pNewLabel = newName.c_str();
+
+	if (dbus_g_proxy_call(pBusProxy, "RenameLabel", &pError,
+		G_TYPE_STRING, pOldLabel,
+		G_TYPE_STRING, pNewLabel,
+		G_TYPE_INVALID,
+		G_TYPE_STRING, &pNewLabel,
+		G_TYPE_INVALID) == TRUE)
+	{
+		renamedLabel = true;
+		reopen();
+	}
+	else
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusXapianIndex::renameLabel: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	return renamedLabel;
+}
+
+/// Deletes all references to a label.
+bool DBusXapianIndex::deleteLabel(const string &name)
+{
+	bool deletedLabel = false;
+
+	DBusGConnection *pBus = getBusConnection();
+	if (pBus == NULL)
+	{
+		return false;
+	}
+
+	DBusGProxy *pBusProxy = getBusProxy(pBus);
+	if (pBusProxy == NULL)
+	{
+		cerr << "DBusXapianIndex::deleteLabel: couldn't get bus proxy" << endl;
+		return false;
+	}
+
+	GError *pError = NULL;
+	const char *pLabel = name.c_str();
+
+	if (dbus_g_proxy_call(pBusProxy, "DeleteLabel", &pError,
+		G_TYPE_STRING, pLabel,
+		G_TYPE_INVALID,
+		G_TYPE_STRING, &pLabel,
+		G_TYPE_INVALID) == TRUE)
+	{
+		deletedLabel = true;
+		reopen();
+	}
+	else
+	{
+		if (pError != NULL)
+		{
+			cerr << "DBusXapianIndex::deleteLabel: " << pError->message << endl;
+			g_error_free(pError);
+		}
+	}
+
+	g_object_unref(pBusProxy);
+	// FIXME: don't we have to call dbus_g_connection_unref(pBus); ?
+
+	return deletedLabel;
+}
+
+/// Flushes recent changes to the disk.
+bool DBusXapianIndex::flush(void)
+{
+	// There is no method for this because the daemon knows best when to flush
+	return true;
+}


Property changes on: trunk/Index/DBusXapianIndex.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Index/DBusXapianIndex.h
===================================================================
--- trunk/Index/DBusXapianIndex.h	2006-08-19 05:21:23 UTC (rev 402)
+++ trunk/Index/DBusXapianIndex.h	2006-08-19 05:24:48 UTC (rev 403)
@@ -0,0 +1,105 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DBUS_XAPIAN_INDEX_H
+#define _DBUS_XAPIAN_INDEX_H
+
+#include <string>
+#include <set>
+
+#include "DocumentInfo.h"
+#include "XapianIndex.h"
+
+class DBusXapianIndex : public WritableIndexInterface, private XapianIndex
+{
+	public:
+		DBusXapianIndex(const std::string &indexName);
+		virtual ~DBusXapianIndex();
+
+		/// Returns false if the index couldn't be opened.
+		virtual bool isGood(void) const;
+
+		/// Gets the index location.
+		virtual std::string getLocation(void) const;
+
+		/// Returns a document's properties.
+		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const;
+
+		/// Determines whether a document has a label.
+		virtual bool hasLabel(unsigned int docId, const std::string &name) const;
+
+		/// Returns a document's labels.
+		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const;
+
+		/// Checks whether the given URL is in the index.
+		virtual unsigned int hasDocument(const std::string &url) const;
+
+		/// Gets terms with the same root.
+		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions);
+
+		/// Returns the ID of the last document.
+		virtual unsigned int getLastDocumentID(void) const;
+
+		/// Returns the number of documents.
+		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const;
+
+		/// Lists document IDs.
+		virtual unsigned int listDocuments(std::set<unsigned int> &docIds,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
+
+		/// Lists documents that have a label.
+		virtual bool listDocumentsWithLabel(const std::string &name, std::set<unsigned int> &docIds,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
+
+		/// Indexes the given data.
+		virtual bool indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
+			unsigned int &docId);
+
+		/// Updates the given document.
+		virtual bool updateDocument(unsigned int docId, Tokenizer &tokens);
+
+		/// Updates a document's properties.
+		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo);
+
+		/// Sets a document's labels.
+		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
+			bool resetLabels = true);
+
+		/// Unindexes the given document.
+		virtual bool unindexDocument(unsigned int docId);
+
+		/// Unindexes documents with the given label.
+		virtual bool unindexDocuments(const std::string &labelName);
+
+		/// Renames a label.
+		virtual bool renameLabel(const std::string &name, const std::string &newName);
+
+		/// Deletes all references to a label.
+		virtual bool deleteLabel(const std::string &name);
+
+		/// Flushes recent changes to the disk.
+		virtual bool flush(void);
+
+	protected:
+		void reopen(void);
+
+	private:
+		DBusXapianIndex(const DBusXapianIndex &other);
+		DBusXapianIndex &operator=(const DBusXapianIndex &other);
+
+};
+
+#endif // _DBUS_XAPIAN_INDEX_H


Property changes on: trunk/Index/DBusXapianIndex.h
___________________________________________________________________
Name: svn:executable
   + *



From fabricecolin at mail.berlios.de  Sat Aug 19 13:13:10 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 13:13:10 +0200
Subject: [Pinot-svn] r404 - trunk/Index
Message-ID: <200608191113.k7JBDAKC009805@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 13:13:09 +0200 (Sat, 19 Aug 2006)
New Revision: 404

Added:
   trunk/Index/IndexFactory.cpp
   trunk/Index/IndexFactory.h
Log:
Factory class to build read-only and read-write index objects. Supported types
are "xapian" and "dbus".


Added: trunk/Index/IndexFactory.cpp
===================================================================
--- trunk/Index/IndexFactory.cpp	2006-08-19 05:24:48 UTC (rev 403)
+++ trunk/Index/IndexFactory.cpp	2006-08-19 11:13:09 UTC (rev 404)
@@ -0,0 +1,56 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "XapianIndex.h"
+#include "DBusXapianIndex.h"
+#include "WritableXapianIndex.h"
+#include "IndexFactory.h"
+
+using std::string;
+
+IndexFactory::IndexFactory()
+{
+}
+
+IndexFactory::~IndexFactory()
+{
+}
+
+/// Returns a read-only index of the specified type; NULL if unavailable.
+IndexInterface *IndexFactory::getROIndex(const string &type, const string &option)
+{
+	// Whatever the type, all read-only operations can be performed with XapianIndex
+	return new XapianIndex(option);
+}
+
+/// Returns a read-write index of the specified type; NULL if unavailable.
+WritableIndexInterface *IndexFactory::getRWIndex(const string &type, const string &option)
+{
+	WritableIndexInterface *pIndex = NULL;
+
+	// Choice by type
+	if (type == "dbus")
+	{
+		pIndex = new DBusXapianIndex(option);
+	}
+	else if (type == "xapian")
+	{
+		pIndex = new WritableXapianIndex(option);
+	}
+
+	return pIndex;
+}
+


Property changes on: trunk/Index/IndexFactory.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Index/IndexFactory.h
===================================================================
--- trunk/Index/IndexFactory.h	2006-08-19 05:24:48 UTC (rev 403)
+++ trunk/Index/IndexFactory.h	2006-08-19 11:13:09 UTC (rev 404)
@@ -0,0 +1,44 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _INDEX_FACTORY_H
+#define _INDEX_FACTORY_H
+
+#include <string>
+
+#include "IndexInterface.h"
+
+class IndexFactory
+{
+	public:
+		virtual ~IndexFactory();
+
+		/// Returns a read-only index of the specified type; NULL if unavailable.
+		static IndexInterface *getROIndex(const std::string &type, const std::string &option);
+
+		/// Returns a read-write index of the specified type; NULL if unavailable.
+		static WritableIndexInterface *getRWIndex(const std::string &type, const std::string &option);
+
+	protected:
+		IndexFactory();
+
+	private:
+		IndexFactory(const IndexFactory &other);
+		IndexFactory &operator=(const IndexFactory &other);
+
+};
+
+#endif // _INDEX_FACTORY_H


Property changes on: trunk/Index/IndexFactory.h
___________________________________________________________________
Name: svn:executable
   + *



From fabricecolin at mail.berlios.de  Sat Aug 19 13:22:06 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 13:22:06 +0200
Subject: [Pinot-svn] r405 - trunk/Index
Message-ID: <200608191122.k7JBM6Fs014067@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 13:22:04 +0200 (Sat, 19 Aug 2006)
New Revision: 405

Modified:
   trunk/Index/pinot-index.cpp
Log:
Modified to use IndexFactory.


Modified: trunk/Index/pinot-index.cpp
===================================================================
--- trunk/Index/pinot-index.cpp	2006-08-19 11:13:09 UTC (rev 404)
+++ trunk/Index/pinot-index.cpp	2006-08-19 11:22:04 UTC (rev 405)
@@ -26,7 +26,7 @@
 #include "XapianDatabaseFactory.h"
 #include "TokenizerFactory.h"
 #include "DownloaderFactory.h"
-#include "WritableXapianIndex.h"
+#include "IndexFactory.h"
 #include "config.h"
 
 using namespace std;
@@ -70,8 +70,10 @@
 					<< "  -h, --help		display this help and exit\n"
 					<< "  -i, --index		index the given URL\n"
 					<< "  -v, --version		output version information and exit\n\n";
+				// Don't mention type dbus here as it doesn't support indexing and
+				// is identical to xapian when checking for URLs
 				cout << "Examples:\n"
-					<< "pinot-index --check http://pinot.berlios.de/ xapian ~/.pinot/index\n\n"
+					<< "pinot-index --check file:///home/fabrice/Documents/Bozo.txt xapian ~/.pinot/daemon\n\n"
 					<< "pinot-index --index http://pinot.berlios.de/ xapian ~/.pinot/index\n\n"
 					<< "Report bugs to " << PACKAGE_BUGREPORT << endl;
 				return EXIT_SUCCESS;
@@ -108,15 +110,24 @@
 	MIMEScanner::initialize();
 	DownloaderInterface::initialize();
 
-	// FIXME: don't ignore the index type
+	// Get a read-write index of the given type
+	WritableIndexInterface *pIndex = IndexFactory::getRWIndex(argv[optind], argv[optind + 1]);
+	if (pIndex == NULL)
+	{
+		cerr << "Couldn't obtain index of type " << argv[optind] << endl;
 
+		XapianDatabaseFactory::closeAll();
+		DownloaderInterface::shutdown();
+		MIMEScanner::shutdown();
+
+		return EXIT_FAILURE;
+	}
+
 	if (checkDocument == true)
 	{
-		XapianIndex index(argv[optind + 1]);
-
-		if (index.isGood() == true)
+		if (pIndex->isGood() == true)
 		{
-			unsigned int docId = index.hasDocument(urlToCheck);
+			unsigned int docId = pIndex->hasDocument(urlToCheck);
 			if (docId > 0)
 			{
 				cout << urlToCheck << ": document ID " << docId << endl;
@@ -153,17 +164,16 @@
 			Tokenizer *pTokens = TokenizerFactory::getTokenizerByType(docInfo.getType(), pDoc);
 			if (pTokens != NULL)
 			{
-				WritableXapianIndex index(argv[optind + 1]);
 				set<string> labels;
 
-				index.setStemmingMode(WritableIndexInterface::STORE_BOTH);
+				pIndex->setStemmingMode(WritableIndexInterface::STORE_BOTH);
 
 				// Update an existing document or add to the index ?
-				unsigned int docId = index.hasDocument(urlToIndex);
+				unsigned int docId = pIndex->hasDocument(urlToIndex);
 				if (docId > 0)
 				{
 					// Update the document
-					if (index.updateDocument(docId, *pTokens) == true)
+					if (pIndex->updateDocument(docId, *pTokens) == true)
 					{
 						success = true;
 					}
@@ -171,13 +181,13 @@
 				else
 				{
 					// Index the document
-					success = index.indexDocument(*pTokens, labels, docId);
+					success = pIndex->indexDocument(*pTokens, labels, docId);
 				}
 
 				if (success == true)
 				{
 					// Flush the index
-					index.flush();
+					pIndex->flush();
 				}
 
 				delete pTokens;
@@ -188,6 +198,7 @@
 
 		delete pDownloader;
 	}
+	delete pIndex;
 
 	XapianDatabaseFactory::closeAll();
 	DownloaderInterface::shutdown();



From fabricecolin at mail.berlios.de  Sat Aug 19 13:26:48 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 13:26:48 +0200
Subject: [Pinot-svn] r406 - trunk/Index
Message-ID: <200608191126.k7JBQm1s016169@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 13:26:26 +0200 (Sat, 19 Aug 2006)
New Revision: 406

Modified:
   trunk/Index/DBusXapianIndex.cpp
   trunk/Index/DBusXapianIndex.h
   trunk/Index/IndexInterface.h
   trunk/Index/Makefile.am
   trunk/Index/WritableXapianIndex.cpp
   trunk/Index/WritableXapianIndex.h
   trunk/Index/XapianIndex.cpp
   trunk/Index/XapianIndex.h
Log:
Index object are copiable.
Build new classes.


Modified: trunk/Index/DBusXapianIndex.cpp
===================================================================
--- trunk/Index/DBusXapianIndex.cpp	2006-08-19 11:22:04 UTC (rev 405)
+++ trunk/Index/DBusXapianIndex.cpp	2006-08-19 11:26:26 UTC (rev 406)
@@ -69,10 +69,23 @@
 {
 }
 
+DBusXapianIndex::DBusXapianIndex(const DBusXapianIndex &other) :
+	WritableIndexInterface(other),
+	XapianIndex(other)
+{
+}
+
 DBusXapianIndex::~DBusXapianIndex()
 {
 }
 
+DBusXapianIndex &DBusXapianIndex::operator=(const DBusXapianIndex &other)
+{
+	WritableIndexInterface::operator=(other);
+	XapianIndex::operator=(other);
+	return *this;
+}
+
 void DBusXapianIndex::reopen(void)
 {
 	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);

Modified: trunk/Index/DBusXapianIndex.h
===================================================================
--- trunk/Index/DBusXapianIndex.h	2006-08-19 11:22:04 UTC (rev 405)
+++ trunk/Index/DBusXapianIndex.h	2006-08-19 11:26:26 UTC (rev 406)
@@ -27,8 +27,11 @@
 {
 	public:
 		DBusXapianIndex(const std::string &indexName);
+		DBusXapianIndex(const DBusXapianIndex &other);
 		virtual ~DBusXapianIndex();
 
+		DBusXapianIndex &operator=(const DBusXapianIndex &other);
+
 		/// Returns false if the index couldn't be opened.
 		virtual bool isGood(void) const;
 
@@ -96,10 +99,6 @@
 	protected:
 		void reopen(void);
 
-	private:
-		DBusXapianIndex(const DBusXapianIndex &other);
-		DBusXapianIndex &operator=(const DBusXapianIndex &other);
-
 };
 
 #endif // _DBUS_XAPIAN_INDEX_H

Modified: trunk/Index/IndexInterface.h
===================================================================
--- trunk/Index/IndexInterface.h	2006-08-19 11:22:04 UTC (rev 405)
+++ trunk/Index/IndexInterface.h	2006-08-19 11:26:26 UTC (rev 406)
@@ -27,8 +27,11 @@
 class IndexInterface
 {
 	public:
+		IndexInterface(const IndexInterface &other) {};
 		virtual ~IndexInterface() {};
 
+		IndexInterface &operator=(const IndexInterface &other) {};
+
 		/// Returns false if the index couldn't be opened.
 		virtual bool isGood(void) const = 0;
 
@@ -67,18 +70,23 @@
 	protected:
 		IndexInterface() { };
 
-	private:
-		IndexInterface(const IndexInterface &other);
-		IndexInterface &operator=(const IndexInterface &other);
-
 };
 
 /// Interface implemented by read-write indexes.
 class WritableIndexInterface : public IndexInterface
 {
 	public:
+		WritableIndexInterface(const WritableIndexInterface &other) :
+			IndexInterface(other), m_stemMode(other.m_stemMode) {};
 		virtual ~WritableIndexInterface() {};
 
+		WritableIndexInterface &operator=(const WritableIndexInterface &other)
+		{
+			IndexInterface::operator=(other);
+			m_stemMode = other.m_stemMode;
+			return *this;
+		};
+
 		typedef enum { STORE_UNSTEM = 0, STORE_STEM, STORE_BOTH } StemmingMode;
 
 		/// Sets the stemming mode.
@@ -116,12 +124,9 @@
 	protected:
 		StemmingMode m_stemMode;
 
-		WritableIndexInterface() : IndexInterface(), m_stemMode(STORE_UNSTEM) { };
+		WritableIndexInterface() :
+			IndexInterface(), m_stemMode(STORE_UNSTEM) { };
 
-	private:
-		WritableIndexInterface(const WritableIndexInterface &other);
-		WritableIndexInterface &operator=(const WritableIndexInterface &other);
-
 };
 
 #endif // _INDEX_INTERFACE_H

Modified: trunk/Index/Makefile.am
===================================================================
--- trunk/Index/Makefile.am	2006-08-19 11:22:04 UTC (rev 405)
+++ trunk/Index/Makefile.am	2006-08-19 11:26:26 UTC (rev 406)
@@ -1,6 +1,8 @@
 # Process this file with automake to produce Makefile.in
 
 noinst_HEADERS = \
+	DBusXapianIndex.h \
+	IndexFactory.h \
 	IndexInterface.h \
 	LanguageDetector.h \
 	WritableXapianIndex.h \
@@ -11,6 +13,8 @@
 bin_PROGRAMS = pinot-index
 
 libIndex_la_SOURCES = \
+	DBusXapianIndex.cpp \
+	IndexFactory.cpp \
 	LanguageDetector.cpp \
 	WritableXapianIndex.cpp \
 	XapianIndex.cpp

Modified: trunk/Index/WritableXapianIndex.cpp
===================================================================
--- trunk/Index/WritableXapianIndex.cpp	2006-08-19 11:22:04 UTC (rev 405)
+++ trunk/Index/WritableXapianIndex.cpp	2006-08-19 11:26:26 UTC (rev 406)
@@ -79,10 +79,25 @@
 	}
 }
 
+WritableXapianIndex::WritableXapianIndex(const WritableXapianIndex &other) :
+	WritableIndexInterface(other),
+	XapianIndex(other),
+	m_stemLanguage(other.m_stemLanguage)
+{
+}
+
 WritableXapianIndex::~WritableXapianIndex()
 {
 }
 
+WritableXapianIndex &WritableXapianIndex::operator=(const WritableXapianIndex &other)
+{
+	WritableIndexInterface::operator=(other);
+	XapianIndex::operator=(other);
+	m_stemLanguage = other.m_stemLanguage;
+	return *this;
+}
+
 bool WritableXapianIndex::badField(const string &field)
 {
 	regex_t fieldRegex;
@@ -1068,4 +1083,3 @@
 
 	return flushed;
 }
-

Modified: trunk/Index/WritableXapianIndex.h
===================================================================
--- trunk/Index/WritableXapianIndex.h	2006-08-19 11:22:04 UTC (rev 405)
+++ trunk/Index/WritableXapianIndex.h	2006-08-19 11:26:26 UTC (rev 406)
@@ -29,8 +29,11 @@
 {
 	public:
 		WritableXapianIndex(const std::string &indexName);
+		WritableXapianIndex(const WritableXapianIndex &other);
 		virtual ~WritableXapianIndex();
 
+		WritableXapianIndex &operator=(const WritableXapianIndex &other);
+
 		/// Returns false if the index couldn't be opened.
 		virtual bool isGood(void) const;
 
@@ -120,10 +123,6 @@
 		bool listDocumentsWithTerm(const std::string &term, std::set<unsigned int> &docIds,
 			unsigned int maxDocsCount, unsigned int startDoc) const;
 
-	private:
-		WritableXapianIndex(const WritableXapianIndex &other);
-		WritableXapianIndex &operator=(const WritableXapianIndex &other);
-
 };
 
 #endif // _WRITABLE_XAPIAN_INDEX_H

Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2006-08-19 11:22:04 UTC (rev 405)
+++ trunk/Index/XapianIndex.cpp	2006-08-19 11:26:26 UTC (rev 406)
@@ -62,10 +62,25 @@
 	}
 }
 
+XapianIndex::XapianIndex(const XapianIndex &other) :
+	IndexInterface(other),
+	m_databaseName(other.m_databaseName),
+	m_goodIndex(other .m_goodIndex)
+{
+}
+
 XapianIndex::~XapianIndex()
 {
 }
 
+XapianIndex &XapianIndex::operator=(const XapianIndex &other)
+{
+	IndexInterface::operator=(other);
+	m_databaseName = other.m_databaseName;
+	m_goodIndex = other .m_goodIndex;
+	return *this;
+}
+
 string XapianIndex::limitTermLength(const string &term, bool makeUnique)
 {
 	if (term.length() > XapianIndex::m_maxTermLength)
@@ -501,4 +516,3 @@
 	term += name;
 	return listDocumentsWithTerm(term, docIds, maxDocsCount, startDoc);
 }
-

Modified: trunk/Index/XapianIndex.h
===================================================================
--- trunk/Index/XapianIndex.h	2006-08-19 11:22:04 UTC (rev 405)
+++ trunk/Index/XapianIndex.h	2006-08-19 11:26:26 UTC (rev 406)
@@ -29,8 +29,11 @@
 {
 	public:
 		XapianIndex(const std::string &indexName);
+		XapianIndex(const XapianIndex &other);
 		virtual ~XapianIndex();
 
+		XapianIndex &operator=(const XapianIndex &other);
+
 		/// Returns false if the index couldn't be opened.
 		virtual bool isGood(void) const;
 
@@ -77,10 +80,6 @@
 		bool listDocumentsWithTerm(const std::string &term, std::set<unsigned int> &docIds,
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
 
-	private:
-		XapianIndex(const XapianIndex &other);
-		XapianIndex &operator=(const XapianIndex &other);
-
 };
 
 #endif // _XAPIAN_INDEX_H



From fabricecolin at mail.berlios.de  Sat Aug 19 13:29:31 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 13:29:31 +0200
Subject: [Pinot-svn] r407 - trunk/UI/GTK2/src
Message-ID: <200608191129.k7JBTVkg016555@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 13:29:25 +0200 (Sat, 19 Aug 2006)
New Revision: 407

Modified:
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/PinotSettings.h
Log:
Index factory methods return an Index onject of the right type depending on
where the index is located and whether DBus usage is enabled.
Dropped mail index.


Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2006-08-19 11:26:26 UTC (rev 406)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2006-08-19 11:29:25 UTC (rev 407)
@@ -33,6 +33,7 @@
 #include "Languages.h"
 #include "NLS.h"
 #include "StringManip.h"
+#include "IndexFactory.h"
 #include "PluginWebEngine.h"
 #include "PinotSettings.h"
 
@@ -81,6 +82,7 @@
 }
 
 PinotSettings PinotSettings::m_instance;
+bool PinotSettings::m_enableDBus = false;
 
 PinotSettings::PinotSettings() :
 	m_xPos(0),
@@ -116,8 +118,6 @@
 	// This is where the internal indices live
 	m_docsIndexLocation = directoryName;
 	m_docsIndexLocation += "/index";
-	m_mailIndexLocation = directoryName;
-	m_mailIndexLocation += "/mail";
 	m_daemonIndexLocation = directoryName;
 	m_daemonIndexLocation += "/daemon";
 
@@ -135,6 +135,15 @@
 	return m_instance;
 }
 
+bool PinotSettings::enableDBus(bool enable)
+{
+	bool isEnabled = m_enableDBus;
+
+	m_enableDBus = enable;
+
+	return isEnabled;
+}
+
 string PinotSettings::getConfigurationDirectory(void)
 {
 	struct passwd *pPasswd = getpwuid(geteuid());
@@ -219,7 +228,6 @@
 
 	// Internal indices
 	addIndex(_("My Documents"), m_docsIndexLocation);
-	addIndex(_("My Email"), m_mailIndexLocation);
 	addIndex(_("My Computer"), m_daemonIndexLocation);
 
 	// Add default labels on the first run
@@ -1062,11 +1070,10 @@
 }
 
 /// Returns true if the given index is internal.
-bool PinotSettings::isInternalIndex(const string &indexName) const
+bool PinotSettings::isInternalIndex(const string &name) const
 {
-	if ((indexName == _("My Documents")) ||
-		(indexName == _("My Email")) ||
-		(indexName == _("My Computer")))
+	if ((name == _("My Documents")) ||
+		(name == _("My Computer")))
 	{
 		return true;
 	}
@@ -1122,7 +1129,6 @@
 	m_indexNames.clear();
 	m_indexIds.clear();
 	addIndex(_("My Documents"), m_docsIndexLocation);
-	addIndex(_("My Email"), m_mailIndexLocation);
 	addIndex(_("My Computer"), m_daemonIndexLocation);
 }
 
@@ -1171,6 +1177,38 @@
 	} while (indexId > 0);
 }
 
+/// Returns a IndexInterface for the given index location.
+IndexInterface *PinotSettings::getROIndex(const string &location)
+{
+	if (location == m_docsIndexLocation)
+	{
+		return IndexFactory::getROIndex("xapian", m_docsIndexLocation);
+	}
+	else if ((m_enableDBus == true) &&
+		(location == m_daemonIndexLocation))
+	{
+		return IndexFactory::getROIndex("dbus", m_daemonIndexLocation);
+	}
+
+	return IndexFactory::getROIndex("xapian", location);
+}
+
+/// Returns a WritableIndexInterface for the given index location.
+WritableIndexInterface *PinotSettings::getRWIndex(const string &location)
+{
+	if (location == m_docsIndexLocation)
+	{
+		return IndexFactory::getRWIndex("xapian", m_docsIndexLocation);
+	}
+	else if ((m_enableDBus == true) &&
+		(location == m_daemonIndexLocation))
+	{
+		return IndexFactory::getRWIndex("dbus", m_daemonIndexLocation);
+	}
+
+	return IndexFactory::getRWIndex("xapian", location);
+}
+
 /// Returns the search engines set.
 bool PinotSettings::getSearchEngines(set<PinotSettings::Engine> &engines, string channelName) const
 {

Modified: trunk/UI/GTK2/src/PinotSettings.h
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.h	2006-08-19 11:26:26 UTC (rev 406)
+++ trunk/UI/GTK2/src/PinotSettings.h	2006-08-19 11:29:25 UTC (rev 407)
@@ -26,6 +26,7 @@
 #include <glibmm/ustring.h>
 #include <libxml++/nodes/element.h>
 
+#include "IndexInterface.h"
 #include "QueryProperties.h"
 
 class PinotSettings
@@ -35,6 +36,8 @@
 
 		static PinotSettings &getInstance(void);
 
+		static bool enableDBus(bool enable);
+
 		static std::string getConfigurationDirectory(void);
 
 		static std::string getConfigurationFileName(void);
@@ -55,7 +58,7 @@
 		const std::map<std::string, std::string> &getIndexes(void) const;
 
 		/// Returns true if the given index is internal.
-		bool isInternalIndex(const string &indexName) const;
+		bool isInternalIndex(const string &name) const;
 
 		/// Adds a new index.
 		bool addIndex(const std::string &name, const std::string &location);
@@ -72,6 +75,12 @@
 		/// Returns the name(s) for the given ID.
 		void getIndexNames(unsigned int id, std::set<std::string> &names);
 
+		/// Returns a IndexInterface for the given index location.
+		IndexInterface *getROIndex(const std::string &location);
+
+		/// Returns a WritableIndexInterface for the given index location.
+		WritableIndexInterface *getRWIndex(const std::string &location);
+
 		class Engine
 		{
 			public:
@@ -157,7 +166,6 @@
 
 		Glib::ustring m_googleAPIKey;
 		Glib::ustring m_docsIndexLocation;
-		Glib::ustring m_mailIndexLocation;
 		Glib::ustring m_daemonIndexLocation;
 		Glib::ustring m_historyDatabase;
 		int m_xPos;
@@ -178,6 +186,7 @@
 
 	protected:
 		static PinotSettings m_instance;
+		static bool m_enableDBus;
 		bool m_firstRun;
 		std::map<std::string, std::string> m_indexNames;
 		std::map<unsigned int, std::string> m_indexIds;



From fabricecolin at mail.berlios.de  Sat Aug 19 13:32:40 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 13:32:40 +0200
Subject: [Pinot-svn] r408 - trunk/UI/GTK2/src
Message-ID: <200608191132.k7JBWeq8017936@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 13:32:36 +0200 (Sat, 19 Aug 2006)
New Revision: 408

Modified:
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
Log:
Use PinotSettings::getR?Index() methods to get an index.
Definition of scanner's FileFound signal changed.


Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-19 11:29:25 UTC (rev 407)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-19 11:32:36 UTC (rev 408)
@@ -39,13 +39,12 @@
 #include "CrawlHistory.h"
 #include "QueryHistory.h"
 #include "IndexedDocument.h"
-#include "MonitorFactory.h"
 #include "DownloaderFactory.h"
 #include "SearchEngineFactory.h"
 #ifdef HAS_GOOGLEAPI
 #include "GoogleAPIEngine.h"
 #endif
-#include "WritableXapianIndex.h"
+#include "IndexFactory.h"
 #include "config.h"
 #include "NLS.h"
 #include "PinotSettings.h"
@@ -320,8 +319,13 @@
 	}
 
 	// Is it an update ?
-	XapianIndex index(m_defaultIndexLocation);
-	unsigned int docId = index.hasDocument(docInfo.getLocation());
+	IndexInterface *pIndex = PinotSettings::getInstance().getROIndex(m_defaultIndexLocation);
+	if (pIndex == NULL)
+	{
+		return false;
+	}
+
+	unsigned int docId = pIndex->hasDocument(docInfo.getLocation());
 	if (docId > 0)
 	{
 		// Yes, it is
@@ -332,6 +336,7 @@
 		// This is a new document
 		start_thread(new IndexingThread(docInfo, docId, m_defaultIndexLocation));
 	}
+	delete pIndex;
 
 	return true;
 }
@@ -622,16 +627,21 @@
 	}
 
 	// Get the index at that location
-	XapianIndex index(mapIter->second);
-	if (index.isGood() == false)
+	IndexInterface *pIndex = PinotSettings::getInstance().getROIndex(mapIter->second);
+	if ((pIndex == NULL) ||
+		(pIndex->isGood() == false))
 	{
 		m_status = _("Index error on");
 		m_status += " ";
 		m_status += mapIter->second;
+		if (pIndex != NULL)
+		{
+			delete pIndex;
+		}
 		return;
 	}
 
-	m_indexDocsCount = index.getDocumentsCount(m_labelName);
+	m_indexDocsCount = pIndex->getDocumentsCount(m_labelName);
 	if (m_indexDocsCount == 0)
 	{
 #ifdef DEBUG
@@ -646,11 +656,11 @@
 #endif
 	if (m_labelName.empty() == true)
 	{
-		index.listDocuments(docIDList, m_maxDocsCount, m_startDoc);
+		pIndex->listDocuments(docIDList, m_maxDocsCount, m_startDoc);
 	}
 	else
 	{
-		index.listDocumentsWithLabel(m_labelName, docIDList, m_maxDocsCount, m_startDoc);
+		pIndex->listDocumentsWithLabel(m_labelName, docIDList, m_maxDocsCount, m_startDoc);
 	}
 	for (set<unsigned int>::iterator iter = docIDList.begin(); iter != docIDList.end(); ++iter)
 	{
@@ -665,7 +675,7 @@
 		string url = XapianDatabase::buildUrl(mapIter->second, docId);
 
 		DocumentInfo docInfo;
-		if (index.getDocumentInfo(docId, docInfo) == true)
+		if (pIndex->getDocumentInfo(docId, docInfo) == true)
 		{
 			string type = docInfo.getType();
 			if (type.empty() == true)
@@ -686,6 +696,7 @@
 		else cout << "IndexBrowserThread::doWork: couldn't retrieve document " << docId << endl;
 #endif
 	}
+	delete pIndex;
 }
 
 QueryingThread::QueryingThread(const string &engineName, const string &engineDisplayableName,
@@ -853,8 +864,8 @@
 
 void LabelUpdateThread::doWork(void)
 {
-	WritableXapianIndex docsIndex(PinotSettings::getInstance().m_docsIndexLocation);
-	if (docsIndex.isGood() == false)
+	WritableIndexInterface *pDocsIndex = PinotSettings::getInstance().getRWIndex(PinotSettings::getInstance().m_docsIndexLocation);
+	if (pDocsIndex == NULL)
 	{
 		m_status = _("Index error on");
 		m_status += " ";
@@ -862,29 +873,31 @@
 		return;
 	}
 
-	WritableXapianIndex mailIndex(PinotSettings::getInstance().m_mailIndexLocation);
-	if (mailIndex.isGood() == false)
+	WritableIndexInterface *pDaemonIndex = PinotSettings::getInstance().getRWIndex(PinotSettings::getInstance().m_daemonIndexLocation);
+	if (pDaemonIndex == NULL)
 	{
 		m_status = _("Index error on");
 		m_status += " ";
-		m_status += PinotSettings::getInstance().m_mailIndexLocation;
+		m_status += PinotSettings::getInstance().m_daemonIndexLocation;
+		delete pDocsIndex;
 		return;
 	}
 
-	// FIXME: what about the daemon index ?
-
 	// Delete labels
 	for (set<string>::iterator iter = m_labelsToDelete.begin(); iter != m_labelsToDelete.end(); ++iter)
 	{
-		docsIndex.deleteLabel(*iter);
-		mailIndex.deleteLabel(*iter);
+		pDocsIndex->deleteLabel(*iter);
+		pDaemonIndex->deleteLabel(*iter);
 	}
 	// Rename labels
 	for (map<string, string>::iterator iter = m_labelsToRename.begin(); iter != m_labelsToRename.end(); ++iter)
 	{
-		docsIndex.renameLabel(iter->first, iter->second);
-		mailIndex.renameLabel(iter->first, iter->second);
+		pDocsIndex->renameLabel(iter->first, iter->second);
+		pDaemonIndex->renameLabel(iter->first, iter->second);
 	}
+
+	delete pDaemonIndex;
+	delete pDocsIndex;
 }
 
 DownloadingThread::DownloadingThread(const DocumentInfo &docInfo, bool fromCache) :
@@ -1045,13 +1058,19 @@
 
 void IndexingThread::doWork(void)
 {
+	WritableIndexInterface *pIndex = PinotSettings::getInstance().getRWIndex(m_indexLocation);
+
 	// First things first, get the index
-	WritableXapianIndex index(m_indexLocation);
-	if (index.isGood() == false)
+	if ((pIndex == NULL) ||
+		(pIndex->isGood() == false))
 	{
 		m_status = _("Index error on");
 		m_status += " ";
 		m_status += m_indexLocation;
+		if (pIndex != NULL)
+		{
+			delete pIndex;
+		}
 		return;
 	}
 
@@ -1152,26 +1171,26 @@
 		{
 			const set<string> &labels = m_docInfo.getLabels();
 
-			index.setStemmingMode(WritableIndexInterface::STORE_BOTH);
+			pIndex->setStemmingMode(WritableIndexInterface::STORE_BOTH);
 
 			// Update an existing document or add to the index ?
 			if (m_update == true)
 			{
 				// Update the document
-				if (index.updateDocument(m_docId, *pTokens) == true)
+				if (pIndex->updateDocument(m_docId, *pTokens) == true)
 				{
 					success = true;
 				}
 
 				// Set the document's labels
-				index.setDocumentLabels(m_docId, labels, false);
+				pIndex->setDocumentLabels(m_docId, labels, false);
 			}
 			else
 			{
 				unsigned int docId = 0;
 
 				// Index the document
-				success = index.indexDocument(*pTokens, labels, docId);
+				success = pIndex->indexDocument(*pTokens, labels, docId);
 				if (success == true)
 				{
 					m_docId = docId;
@@ -1189,16 +1208,18 @@
 				// Flush the index ?
 				if (m_immediateFlush == true)
 				{
-					index.flush();
+					pIndex->flush();
 				}
 
 				// The document properties may have changed
-				index.getDocumentInfo(m_docId, m_docInfo);
+				pIndex->getDocumentInfo(m_docId, m_docInfo);
 			}
 		}
 
 		delete pTokens;
 	}
+
+	delete pIndex;
 }
 
 UnindexingThread::UnindexingThread(const set<unsigned int> &docIdList) :
@@ -1244,74 +1265,78 @@
 
 void UnindexingThread::doWork(void)
 {
-	if (m_done == false)
+	WritableIndexInterface *pIndex = PinotSettings::getInstance().getRWIndex(m_indexLocation);
+
+	if ((pIndex == NULL) ||
+		(pIndex->isGood() == false))
 	{
-		WritableXapianIndex index(m_indexLocation);
-
-		if (index.isGood() == false)
+		m_status = _("Index error on");
+		m_status += " ";
+		m_status += m_indexLocation;
+		if (pIndex != NULL)
 		{
-			m_status = _("Index error on");
-			m_status += " ";
-			m_status += m_indexLocation;
-			return;
+			delete pIndex;
 		}
+		return;
+	}
 
-		// Be pessimistic and assume something will go wrong ;-)
-		m_status = _("Couldn't unindex document(s)");
+	// Be pessimistic and assume something will go wrong ;-)
+	m_status = _("Couldn't unindex document(s)");
 
-		// Are we supposed to remove documents based on labels ?
-		if (m_docIdList.empty() == true)
+	// Are we supposed to remove documents based on labels ?
+	if (m_docIdList.empty() == true)
+	{
+		// Yep
+		// FIXME: better delete documents one label at a time
+		for (set<string>::iterator iter = m_labelNames.begin(); iter != m_labelNames.end(); ++iter)
 		{
-			// Yep
-			// FIXME: better delete documents one label at a time
-			for (set<string>::iterator iter = m_labelNames.begin(); iter != m_labelNames.end(); ++iter)
+			string labelName = (*iter);
+
+			// By unindexing all documents that match the label,
+			// we effectively delete the label from the index
+			if (pIndex->unindexDocuments(labelName) == true)
 			{
-				string labelName = (*iter);
-
-				// By unindexing all documents that match the label,
-				// we effectively delete the label from the index
-				if (index.unindexDocuments(labelName) == true)
-				{
-					// OK
-					++m_docsCount;
-				}
+				// OK
+				++m_docsCount;
 			}
+		}
 
-			// Nothing to report
-			m_status = "";
-		}
-		else
+		// Nothing to report
+		m_status = "";
+	}
+	else
+	{
+		for (set<unsigned int>::iterator iter = m_docIdList.begin(); iter != m_docIdList.end(); ++iter)
 		{
-			for (set<unsigned int>::iterator iter = m_docIdList.begin(); iter != m_docIdList.end(); ++iter)
+			unsigned int docId = (*iter);
+
+			if (pIndex->unindexDocument(docId) == true)
 			{
-				unsigned int docId = (*iter);
-
-				if (index.unindexDocument(docId) == true)
-				{
-					// OK
-					++m_docsCount;
-				}
+				// OK
+				++m_docsCount;
+			}
 #ifdef DEBUG
-				else cout << "UnindexingThread::doWork: couldn't remove " << docId << endl;
+			else cout << "UnindexingThread::doWork: couldn't remove " << docId << endl;
 #endif
-			}
+		}
 #ifdef DEBUG
-			cout << "UnindexingThread::doWork: removed " << m_docsCount << " documents" << endl;
+		cout << "UnindexingThread::doWork: removed " << m_docsCount << " documents" << endl;
 #endif
-		}
+	}
 
-		if (m_docsCount > 0)
+	if (m_docsCount > 0)
+	{
+		// Flush the index ?
+		if (m_immediateFlush == true)
 		{
-			// Flush the index ?
-			if (m_immediateFlush == true)
-			{
-				index.flush();
-			}
+			pIndex->flush();
+		}
 
-			// Nothing to report
-			m_status = "";
-		}
+		// Nothing to report
+		m_status = "";
 	}
+
+	delete pIndex;
 }
 
 UpdateDocumentThread::UpdateDocumentThread(const string &indexName,
@@ -1369,16 +1394,21 @@
 		}
 
 		// Get the index at that location
-		WritableXapianIndex index(mapIter->second);
-		if (index.isGood() == false)
+		WritableIndexInterface *pIndex = PinotSettings::getInstance().getRWIndex(mapIter->second);
+		if ((pIndex == NULL) ||
+			(pIndex->isGood() == false))
 		{
 			m_status = _("Index error on");
 			m_status += " ";
 			m_status += mapIter->second;
+			if (pIndex != NULL)
+			{
+				delete pIndex;
+			}
 			return;
 		}
 
-		if (index.updateDocumentInfo(m_docId, m_docInfo) == false)
+		if (pIndex->updateDocumentInfo(m_docId, m_docInfo) == false)
 		{
 			m_status = _("Couldn't update document");
 		}
@@ -1387,19 +1417,22 @@
 			// Flush the index ?
 			if (m_immediateFlush == true)
 			{
-				index.flush();
+				pIndex->flush();
 			}
 
 			// The document properties may have changed
-			index.getDocumentInfo(m_docId, m_docInfo);
+			pIndex->getDocumentInfo(m_docId, m_docInfo);
 		}
+
+		delete pIndex;
 	}
 }
 
-MonitorThread::MonitorThread(MonitorHandler *pHandler) :
+MonitorThread::MonitorThread(MonitorInterface *pMonitor, MonitorHandler *pHandler) :
 	WorkerThread(),
 	m_ctrlReadPipe(-1),
 	m_ctrlWritePipe(-1),
+	m_pMonitor(pMonitor),
 	m_pHandler(pHandler)
 {
 	int pipeFds[2];
@@ -1442,17 +1475,18 @@
 
 void MonitorThread::doWork(void)
 {
-	MonitorInterface *pMonitor = MonitorFactory::getMonitor();
-	set<string> newLocations;
-	set<string> locationsToRemove;
-
 	if ((m_pHandler == NULL) ||
-		(pMonitor == NULL))
+		(m_pMonitor == NULL))
 	{
 		m_status = _("No monitoring handler");
 		return;
 	}
 
+	// Initialize the handler
+	m_pHandler->initialize();
+
+	// What locations to monitor is set by DirectoryScannerThread
+
 	// Wait for something to happen
 	while (m_done == false)
 	{
@@ -1468,36 +1502,10 @@
 			FD_SET(m_ctrlReadPipe, &listenSet);
 		}
 
-		// Did a change occur ?
-		if (m_pHandler->getLocations(newLocations, locationsToRemove) == true)
-		{
-#ifdef DEBUG
-			cout << "MonitorThread::doWork: change detected" << endl;
-#endif
+		m_pHandler->flushIndex();
 
-			// Add new locations
-			for (set<string>::const_iterator locationIter = newLocations.begin();
-				(locationIter != newLocations.end()) && (m_done == false); ++locationIter)
-			{
-				// Monitor this
-				if (pMonitor->addLocation(*locationIter) == true)
-				{
-					// Confirm the file exists
-					m_pHandler->fileExists(*locationIter);
-				}
-			}
-
-			// Remove others
-			for (set<string>::const_iterator locationIter = locationsToRemove.begin();
-				(locationIter != locationsToRemove.end()) && (m_done == false); ++locationIter)
-			{
-				// Stop monitoring this
-				pMonitor->removeLocation(*locationIter);
-			}
-		}
-
 		// The file descriptor may change over time
-		int monitorFd = pMonitor->getFileDescriptor();
+		int monitorFd = m_pMonitor->getFileDescriptor();
 		FD_SET(monitorFd, &listenSet);
 		if (monitorFd < 0)
 		{
@@ -1519,7 +1527,7 @@
 			queue<MonitorEvent> events;
 
 			// There might be more than one event waiting...
-			if (pMonitor->retrievePendingEvents(events) == false)
+			if (m_pMonitor->retrievePendingEvents(events) == false)
 			{
 #ifdef DEBUG
 				cout << "MonitorThread::doWork: failed to retrieve pending events" << endl;
@@ -1543,9 +1551,20 @@
 				bool updatedIndex = false;
 
 				// What's the event code ?
-				if (event.m_type == MonitorEvent::CREATED)
+				if (event.m_type == MonitorEvent::EXISTS)
 				{
+					m_pHandler->fileExists(event.m_location);
+				}
+				else if (event.m_type == MonitorEvent::CREATED)
+				{
 					m_pHandler->fileCreated(event.m_location);
+
+					// If a whole directory was created, monitor it
+					if (event.m_isDirectory == true)
+					{
+						// FIXME: crawl it first !
+						m_pMonitor->addLocation(event.m_location, true);
+					}
 				}
 				else if (event.m_type == MonitorEvent::WRITE_CLOSED)
 				{
@@ -1554,10 +1573,25 @@
 				else if (event.m_type == MonitorEvent::MOVED)
 				{
 					updatedIndex = m_pHandler->fileMoved(event.m_location, event.m_previousLocation);
+
+					if ((event.m_isDirectory == true) &&
+						(event.m_isWatch == true))
+					{
+						// Stop monitoring
+						m_pMonitor->removeLocation(event.m_previousLocation);
+						// FIXME: monitor the new location
+					}
 				}
 				else if (event.m_type == MonitorEvent::DELETED)
 				{
 					updatedIndex = m_pHandler->fileDeleted(event.m_location);
+
+					if ((event.m_isDirectory == true) &&
+						(event.m_isWatch == true))
+					{
+						// Stop monitoring
+						m_pMonitor->removeLocation(event.m_location);
+					}
 				}
 
 				// Next
@@ -1565,13 +1599,13 @@
 			}
 		}
 	}
-
-	delete pMonitor;
 }
 
-DirectoryScannerThread::DirectoryScannerThread(const string &dirName,
-	unsigned int maxLevel, bool followSymLinks, Mutex *pMutex, Cond *pCondVar) :
+DirectoryScannerThread::DirectoryScannerThread(MonitorInterface *pMonitor,
+	const string &dirName, unsigned int maxLevel, bool followSymLinks,
+	Mutex *pMutex, Cond *pCondVar) :
 	WorkerThread(),
+	m_pMonitor(pMonitor),
 	m_dirName(dirName),
 	m_maxLevel(maxLevel),
 	m_followSymLinks(followSymLinks),
@@ -1612,7 +1646,7 @@
 	return true;
 }
 
-Signal1<bool, const string&>& DirectoryScannerThread::getFileFoundSignal(void)
+Signal2<bool, const string&, const std::string&>& DirectoryScannerThread::getFileFoundSignal(void)
 {
 	return m_signalFileFound;
 }
@@ -1628,9 +1662,13 @@
 		(m_pCondVar != NULL))
 	{
 		string url("file://" + fileName);
+		char labelStr[64];
 
+		// This identifies the source
+		snprintf(labelStr, 64, "SOURCE%u", m_sourceId);
+
 		m_pMutex->lock();
-		if (m_signalFileFound(url) == true)
+		if (m_signalFileFound(url, labelStr) == true)
 		{
 			// Another file is needed right now
 			m_pMutex->unlock();
@@ -1663,6 +1701,13 @@
 		return false;
 	}
 
+	// Skip . .. and dotfiles
+	Url urlObj("file://" + dirName);
+	if (urlObj.getFile()[0] == '.')
+	{
+		return false;
+	}
+
 	if (m_followSymLinks == false)
 	{
 		statSuccess = lstat(dirName.c_str(), &fileStat);
@@ -1678,6 +1723,8 @@
 		return false;
 	}
 
+	bool itemExists = history.hasItem("file://" + dirName, status, itemDate);
+
 	// Is it a file or a directory ?
 	if (S_ISLNK(fileStat.st_mode))
 	{
@@ -1686,117 +1733,104 @@
 	}
 	else if (S_ISREG(fileStat.st_mode))
 	{
-		// It's actually a file : skip dotfiles
-		if (dirName[0] != '.')
+		bool reportFile = false;
+
+		// It's actually a file
+		// Was it crawled since it was last modified ?
+		if (itemExists == false)
 		{
-			bool reportFile = false;
+			// Record it
+			history.insertItem("file://" + dirName, CrawlHistory::CRAWLED, m_sourceId, fileStat.st_mtime);
+			reportFile = true;
+		}
+		else if (itemDate < fileStat.st_mtime)
+		{
+			// Update the record
+			history.updateItem("file://" + dirName, CrawlHistory::CRAWLED, fileStat.st_mtime);
+			reportFile = true;
+		}
 
-			// ...and check whether the file was crawled since it was last modified
-			if (history.hasItem("file://" + dirName, status, itemDate) == false)
-			{
-				// Record it
-				history.insertItem("file://" + dirName, CrawlHistory::CRAWLED, m_sourceId, fileStat.st_mtime);
-				reportFile = true;
-			}
-			else if (itemDate < fileStat.st_mtime)
-			{
-				// Update the record
-				history.updateItem("file://" + dirName, CrawlHistory::CRAWLED, fileStat.st_mtime);
-				reportFile = true;
-			}
-
-			if (reportFile == true)
-			{
-				foundFile(dirName);
-			}
+		if (reportFile == true)
+		{
+			foundFile(dirName);
 		}
 	}
 	else if (S_ISDIR(fileStat.st_mode))
 	{
-		// A directory : scan it
-		DIR *pDir = opendir(dirName.c_str());
-		if (pDir == NULL)
+		// Can we scan this directory ?
+		if ((m_maxLevel == 0) ||
+			(m_currentLevel < m_maxLevel))
 		{
-			return false;
-		}
+			++m_currentLevel;
+
+			// Open the directory
+			DIR *pDir = opendir(dirName.c_str());
+			if (pDir == NULL)
+			{
+				return false;
+			}
 #ifdef DEBUG
-		cout << "DirectoryScannerThread::scanDirectory: entering " << dirName << endl;
+			cout << "DirectoryScannerThread::scanDirectory: entering "
+				<< dirName << endl;
 #endif
 
-		// Iterate through this directory's entries
-		struct dirent *pDirEntry = readdir(pDir);
-		while ((m_done == false) &&
-			(pDirEntry != NULL))
-		{
-			char *pEntryName = pDirEntry->d_name;
-			if (pEntryName != NULL)
+			// Monitor first so that we don't miss events
+			m_pMonitor->addLocation(dirName, true);
+
+			// Iterate through this directory's entries
+			struct dirent *pDirEntry = readdir(pDir);
+			while ((m_done == false) &&
+				(pDirEntry != NULL))
 			{
-				string entryName = dirName;
-				if (dirName[dirName.length() - 1] != '/')
-				{
-					entryName += "/";
-				}
-				entryName += pEntryName;
+				char *pEntryName = pDirEntry->d_name;
 
 				// Skip . .. and dotfiles
-				Url urlObj("file://" + entryName);
-				if ((urlObj.getFile()[0] == '.') ||
-					(lstat(entryName.c_str(), &fileStat) == -1))
+				if ((pEntryName != NULL) &&
+					(pEntryName[0] != '.'))
 				{
-					// Next entry
-					pDirEntry = readdir(pDir);
-					continue;
-				}
+					string entryName(dirName);
 
-#ifdef DEBUG
-				cout << "DirectoryScannerThread::scanDirectory: stat'ing " << entryName << endl;
-#endif
-				// File or directory
-				if (S_ISREG(fileStat.st_mode))
-				{
-					bool reportFile = false;
-
-					// Was it crawled since it was last modified ?
-					if (history.hasItem("file://" + entryName, status, itemDate) == false)
+					if (dirName[dirName.length() - 1] != '/')
 					{
-						// Record it
-						history.insertItem("file://" + entryName, CrawlHistory::CRAWLED, m_sourceId, fileStat.st_mtime);
-						reportFile = true;
+						entryName += "/";
 					}
-					else if (itemDate < fileStat.st_mtime)
-					{
-						// Update the record
-						history.updateItem("file://" + entryName, CrawlHistory::CRAWLED, fileStat.st_mtime);
-						reportFile = true;
-					}
+					entryName += pEntryName;
 
-					if (reportFile == true)
+					// Scan this entry
+					if (scanDirectory(entryName) == false)
 					{
-						foundFile(entryName);
-					}
-				}
-				else if (S_ISDIR(fileStat.st_mode))
-				{
-					// Can we scan this directory ?
-					if ((m_maxLevel == 0) ||
-						(m_currentLevel + 1 < m_maxLevel))
-					{
-						++m_currentLevel;
-						scanDirectory(entryName);
 #ifdef DEBUG
-						cout << "DirectoryScannerThread::scanDirectory: done at level "
-							<< m_currentLevel << endl;
+						cout << "DirectoryScannerThread::scanDirectory: failed to open "
+							<< entryName << endl;
 #endif
-						--m_currentLevel;
 					}
 				}
+
+				// Next entry
+				pDirEntry = readdir(pDir);
 			}
 
-			// Next entry
-			pDirEntry = readdir(pDir);
+			if (itemExists == false)
+			{
+				history.insertItem("file://" + dirName, CrawlHistory::DIRECTORY, m_sourceId, fileStat.st_mtime);
+			}
+			else
+			{
+				history.updateItem("file://" + dirName, CrawlHistory::DIRECTORY, fileStat.st_mtime);
+			}
+#ifdef DEBUG
+			cout << "DirectoryScannerThread::scanDirectory: done with " << dirName << endl;
+#endif
+
+			// Close the directory
+			closedir(pDir);
+			--m_currentLevel;
 		}
-		closedir(pDir);
 	}
+	else
+	{
+		return false;
+	}
 
 	return true;
 }

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2006-08-19 11:29:25 UTC (rev 407)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2006-08-19 11:32:36 UTC (rev 408)
@@ -32,6 +32,7 @@
 #include <glibmm/ustring.h>
 
 #include "Document.h"
+#include "MonitorInterface.h"
 #include "IndexedDocument.h"
 #include "DownloaderInterface.h"
 #include "QueryProperties.h"
@@ -373,7 +374,7 @@
 class MonitorThread : public WorkerThread
 {
 	public:
-		MonitorThread(MonitorHandler *pHandler);
+		MonitorThread(MonitorInterface *pMonitor, MonitorHandler *pHandler);
 		virtual ~MonitorThread();
 
 		virtual std::string getType(void) const;
@@ -383,6 +384,7 @@
 	protected:
 		int m_ctrlReadPipe;
 		int m_ctrlWritePipe;
+		MonitorInterface *m_pMonitor;
 		MonitorHandler *m_pHandler;
 
 		virtual void doWork(void);
@@ -396,8 +398,8 @@
 class DirectoryScannerThread : public WorkerThread
 {
 	public:
-		DirectoryScannerThread(const std::string &dirName,
-			unsigned int maxLevel, bool followSymLinks,
+		DirectoryScannerThread(MonitorInterface *pMonitor,
+			const std::string &dirName, unsigned int maxLevel, bool followSymLinks,
 			Glib::Mutex *pMutex, Glib::Cond *pCondVar);
 		virtual ~DirectoryScannerThread();
 
@@ -407,9 +409,10 @@
 
 		virtual bool stop(void);
 
-		SigC::Signal1<bool, const std::string&>& getFileFoundSignal(void);
+		SigC::Signal2<bool, const std::string&, const std::string&>& getFileFoundSignal(void);
 
 	protected:
+		MonitorInterface *m_pMonitor;
 		std::string m_dirName;
 		unsigned int m_maxLevel;
 		bool m_followSymLinks;
@@ -417,7 +420,7 @@
 		Glib::Cond *m_pCondVar;
 		unsigned int m_currentLevel;
 		unsigned int m_sourceId;
-		SigC::Signal1<bool, const std::string&> m_signalFileFound;
+		SigC::Signal2<bool, const std::string&, const std::string&> m_signalFileFound;
 
 		void foundFile(const std::string &fileName);
 		bool scanDirectory(const std::string &dirName);



From fabricecolin at mail.berlios.de  Sat Aug 19 13:34:00 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 13:34:00 +0200
Subject: [Pinot-svn] r409 - trunk/UI/GTK2/src
Message-ID: <200608191134.k7JBY0F1018367@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 13:33:56 +0200 (Sat, 19 Aug 2006)
New Revision: 409

Modified:
   trunk/UI/GTK2/src/EnginesTree.cpp
   trunk/UI/GTK2/src/ResultsTree.cpp
Log:
Caught up with changes made elsewhere.


Modified: trunk/UI/GTK2/src/EnginesTree.cpp
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.cpp	2006-08-19 11:32:36 UTC (rev 408)
+++ trunk/UI/GTK2/src/EnginesTree.cpp	2006-08-19 11:33:56 UTC (rev 409)
@@ -337,7 +337,6 @@
 		EnginesModelColumns::EngineType indexType = EnginesModelColumns::INDEX_ENGINE;
 
 		if ((indexName == _("My Documents")) ||
-			(indexName == _("My Email")) ||
 			(indexName == _("My Computer")))
 		{
 			indexType = EnginesModelColumns::INTERNAL_INDEX_ENGINE;

Modified: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2006-08-19 11:32:36 UTC (rev 408)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2006-08-19 11:33:56 UTC (rev 409)
@@ -30,7 +30,7 @@
 #include "Url.h"
 #include "QueryHistory.h"
 #include "ViewHistory.h"
-#include "XapianIndex.h"
+#include "IndexFactory.h"
 #include "config.h"
 #include "NLS.h"
 #include "PinotSettings.h"
@@ -1138,15 +1138,19 @@
 #endif
 	}
 
-	XapianIndex index(m_settings.m_docsIndexLocation);
+	IndexInterface *pIndex = m_settings.getROIndex(m_settings.m_docsIndexLocation);
 	ViewHistory viewHistory(m_settings.m_historyDatabase);
 	bool isIndexed = false;
 
 	// Is this document indexed ?
-	if ((index.isGood() == true) &&
-		(index.hasDocument(url) > 0))
+	if (pIndex != NULL)
 	{
-		isIndexed = true;
+		if (pIndex->hasDocument(url) > 0)
+		{
+			isIndexed = true;
+		}
+
+		delete pIndex;
 	}
 
 	// Has it been already viewed ?



From fabricecolin at mail.berlios.de  Sat Aug 19 13:35:30 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 13:35:30 +0200
Subject: [Pinot-svn] r410 - trunk/UI/GTK2/src
Message-ID: <200608191135.k7JBZUO5018489@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 13:35:25 +0200 (Sat, 19 Aug 2006)
New Revision: 410

Modified:
   trunk/UI/GTK2/src/importDialog.cc
   trunk/UI/GTK2/src/importDialog.hh
Log:
Synced with new PinotSettings and DirectoryScannerThread.


Modified: trunk/UI/GTK2/src/importDialog.cc
===================================================================
--- trunk/UI/GTK2/src/importDialog.cc	2006-08-19 11:33:56 UTC (rev 409)
+++ trunk/UI/GTK2/src/importDialog.cc	2006-08-19 11:35:25 UTC (rev 410)
@@ -27,7 +27,8 @@
 #include "MIMEScanner.h"
 #include "NLS.h"
 #include "Url.h"
-#include "WritableXapianIndex.h"
+#include "MonitorFactory.h"
+#include "IndexFactory.h"
 #include "PinotSettings.h"
 #include "PinotUtils.h"
 #include "importDialog.hh"
@@ -51,6 +52,7 @@
 
 importDialog::importDialog(const Glib::ustring &title) :
 	importDialog_glade(),
+	m_pMonitor(MonitorFactory::getMonitor()),
 	m_docsCount(0),
 	m_importDirectory(false),
 	m_pScannerThread(NULL),
@@ -96,6 +98,10 @@
 importDialog::~importDialog()
 {
 	m_state.disconnect();
+	if (m_pMonitor != NULL)
+	{
+		delete m_pMonitor;
+	}
 }
 
 void importDialog::populate_comboboxes(bool localOnly)
@@ -151,24 +157,25 @@
 	return true;
 }
 
-bool importDialog::on_import_url(const string &location)
+bool importDialog::on_import_url(const string &location, const string &sourceLabel)
 {
-	WritableXapianIndex index(PinotSettings::getInstance().m_docsIndexLocation);
+	WritableIndexInterface *pIndex = PinotSettings::getInstance().getRWIndex(PinotSettings::getInstance().m_docsIndexLocation);
 	Url urlObj(location);
 	set<string> labels;
 	string title(from_utf8(m_title));
 
-	if (index.isGood() == true)
+	if (pIndex != NULL)
 	{
-		unsigned int docId = index.hasDocument(location);
+		unsigned int docId = pIndex->hasDocument(location);
 
 		// if the document exists, get its labels list
 		if (docId > 0)
 		{
-			index.getDocumentLabels(docId, labels);
+			pIndex->getDocumentLabels(docId, labels);
 		}
 	}
 	labels.insert(m_labelName);
+	labels.insert(sourceLabel);
 
 	if (m_importDirectory == true)
 	{
@@ -399,15 +406,15 @@
 		unsigned int maxDirLevel = (unsigned int)depthSpinbutton->get_value();
 
 		// Scan the directory and import all its files
-		m_pScannerThread = new DirectoryScannerThread(location,
-			maxDirLevel, linksCheckbutton->get_active(),
+		m_pScannerThread = new DirectoryScannerThread(m_pMonitor,
+			location, maxDirLevel, linksCheckbutton->get_active(),
 			&m_state.m_scanMutex, &m_state.m_scanCondVar);
 		m_pScannerThread->getFileFoundSignal().connect(SigC::slot(*this, &importDialog::on_import_url));
 		m_state.start_thread(m_pScannerThread);
 	}
 	else
 	{
-		if (on_import_url(location) == true)
+		if (on_import_url(location, "") == true)
 		{
 			// It's asking for another file, so this one couldn't be indexed
 			m_timeoutConnection.block();

Modified: trunk/UI/GTK2/src/importDialog.hh
===================================================================
--- trunk/UI/GTK2/src/importDialog.hh	2006-08-19 11:33:56 UTC (rev 409)
+++ trunk/UI/GTK2/src/importDialog.hh	2006-08-19 11:35:25 UTC (rev 410)
@@ -27,6 +27,7 @@
 #include <gtkmm/liststore.h>
 
 #include "DocumentInfo.h"
+#include "MonitorInterface.h"
 #include "ModelColumns.h"
 #include "WorkerThreads.h"
 #include "importDialog_glade.hh"
@@ -47,10 +48,11 @@
 	void signal_scanner(void);
 
 	bool on_activity_timeout(void);
-	bool on_import_url(const std::string &location);
+	bool on_import_url(const std::string &location, const std::string &extraLabel);
 	void on_thread_end(WorkerThread *pThread);
 
 private:
+	MonitorInterface *m_pMonitor;
 	// Type
 	ComboModelColumns m_typeColumns;
 	Glib::RefPtr<Gtk::ListStore> m_refTypeList;



From fabricecolin at mail.berlios.de  Sat Aug 19 13:41:11 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 13:41:11 +0200
Subject: [Pinot-svn] r411 - trunk/UI/GTK2/src
Message-ID: <200608191141.k7JBfB0q019325@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 13:41:09 +0200 (Sat, 19 Aug 2006)
New Revision: 411

Modified:
   trunk/UI/GTK2/src/DaemonState.cpp
   trunk/UI/GTK2/src/DaemonState.h
   trunk/UI/GTK2/src/importDialog.hh
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/pinot.cc
Log:
Synced with changes to PinotSettings and DirectoryScannerThread.


Modified: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2006-08-19 11:35:25 UTC (rev 410)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2006-08-19 11:41:09 UTC (rev 411)
@@ -22,6 +22,7 @@
 #include <glibmm/thread.h>
 
 #include "Url.h"
+#include "MonitorFactory.h"
 #include "WritableXapianIndex.h"
 #include "DaemonState.h"
 #include "MboxHandler.h"
@@ -35,6 +36,8 @@
 
 DaemonState::DaemonState() :
 	ThreadsManager(PinotSettings::getInstance().m_daemonIndexLocation, 10),
+	m_pMailMonitor(MonitorFactory::getMonitor()),
+	m_pDiskMonitor(MonitorFactory::getMonitor()),
 	m_crawling(false)
 {
 	m_onThreadEndSignal.connect(SigC::slot(*this, &DaemonState::on_thread_end));
@@ -42,6 +45,14 @@
 
 DaemonState::~DaemonState()
 {
+	if (m_pDiskMonitor != NULL)
+	{
+		delete m_pDiskMonitor;
+	}
+	if (m_pMailMonitor != NULL)
+	{
+		delete m_pMailMonitor;
+	}
 }
 
 void DaemonState::start(void)
@@ -56,9 +67,17 @@
 	// Connect to its update signal
 	pMbox->getUpdateSignal().connect(
 		SigC::slot(*this, &DaemonState::on_message_indexupdate));
-	MonitorThread *pMailMonitorThread = new MonitorThread(pMbox);
+	MonitorThread *pMailMonitorThread = new MonitorThread(m_pMailMonitor, pMbox);
 	start_thread(pMailMonitorThread, true);
 
+	// Same for the disk monitor thread
+	OnDiskHandler *pDisk = new OnDiskHandler();
+	// Connect to its update signal
+	pDisk->getUpdateSignal().connect(
+		SigC::slot(*this, &DaemonState::on_message_indexupdate));
+	MonitorThread *pDiskMonitorThread = new MonitorThread(m_pDiskMonitor, pDisk);
+	start_thread(pDiskMonitorThread, true);
+
 	for (set<PinotSettings::TimestampedItem>::const_iterator locationIter = PinotSettings::getInstance().m_indexableLocations.begin();
 		locationIter != PinotSettings::getInstance().m_indexableLocations.end(); ++locationIter)
 	{
@@ -78,22 +97,12 @@
 	if (locationToCrawl.empty() == false)
 	{
 		// Scan the directory and import all its files
-		DirectoryScannerThread *pScannerThread = new DirectoryScannerThread(locationToCrawl,
-			0, true, &m_scanMutex, &m_scanCondVar);
+		DirectoryScannerThread *pScannerThread = new DirectoryScannerThread(m_pDiskMonitor,
+			locationToCrawl, 0, true, &m_scanMutex, &m_scanCondVar);
 		pScannerThread->getFileFoundSignal().connect(SigC::slot(*this, &DaemonState::on_message_filefound));
 
 		m_crawling = start_thread(pScannerThread);
 	}
-	else
-	{
-		// Fire up the disk monitor thread right away
-		OnDiskHandler *pDisk = new OnDiskHandler();
-		// Connect to its update signal
-		pDisk->getUpdateSignal().connect(
-			SigC::slot(*this, &DaemonState::on_message_indexupdate));
-		MonitorThread *pDiskMonitorThread = new MonitorThread(pDisk);
-		start_thread(pDiskMonitorThread, true);
-	}
 }
 
 void DaemonState::signal_scanner(void)
@@ -153,8 +162,8 @@
 					}
 				}
 
-				pNewScannerThread = new DirectoryScannerThread(locationToCrawl,
-					0, true, &m_scanMutex, &m_scanCondVar);
+				pNewScannerThread = new DirectoryScannerThread(m_pDiskMonitor,
+					locationToCrawl, 0, true, &m_scanMutex, &m_scanCondVar);
 				pNewScannerThread->getFileFoundSignal().connect(SigC::slot(*this,
 					&DaemonState::on_message_filefound));
 
@@ -178,16 +187,6 @@
 		{
 			m_crawling = start_thread(pNewScannerThread);
 		}
-		else
-		{
-			// Now we can start monitoring
-			OnDiskHandler *pDisk = new OnDiskHandler();
-			// Connect to its update signal
-			pDisk->getUpdateSignal().connect(
-				SigC::slot(*this, &DaemonState::on_message_indexupdate));
-			MonitorThread *pMonitorThread = new MonitorThread(pDisk);
-			start_thread(pMonitorThread, true);
-		}
 	}
 	else if (type == "IndexingThread")
 	{
@@ -235,11 +234,15 @@
 	// FIXME: anything to do ?
 }
 
-bool DaemonState::on_message_filefound(const string &location)
+bool DaemonState::on_message_filefound(const string &location, const string &sourceLabel)
 {
 	Url urlObj(location);
+	set<string> labels;
 
 	DocumentInfo docInfo(urlObj.getFile(), location, "", "");
+	// Insert a label that identifies the source
+	labels.insert(sourceLabel);
+	docInfo.setLabels(labels);
 
 	queue_index(docInfo);
 

Modified: trunk/UI/GTK2/src/DaemonState.h
===================================================================
--- trunk/UI/GTK2/src/DaemonState.h	2006-08-19 11:35:25 UTC (rev 410)
+++ trunk/UI/GTK2/src/DaemonState.h	2006-08-19 11:41:09 UTC (rev 411)
@@ -22,6 +22,7 @@
 #include <set>
 #include <glibmm/thread.h>
 
+#include "MonitorInterface.h"
 #include "IndexedDocument.h"
 #include "WorkerThreads.h"
 
@@ -39,9 +40,11 @@
 
 		void on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, std::string indexName);
 
-		bool on_message_filefound(const std::string &location);
+		bool on_message_filefound(const std::string &location, const std::string &sourceLabel);
 
 	protected:
+		MonitorInterface *m_pMailMonitor;
+		MonitorInterface *m_pDiskMonitor;
 		std::queue<std::string> m_crawlQueue;
 		std::set<std::string> m_monitoredLocations;
 		bool m_crawling;

Modified: trunk/UI/GTK2/src/importDialog.hh
===================================================================
--- trunk/UI/GTK2/src/importDialog.hh	2006-08-19 11:35:25 UTC (rev 410)
+++ trunk/UI/GTK2/src/importDialog.hh	2006-08-19 11:41:09 UTC (rev 411)
@@ -48,7 +48,7 @@
 	void signal_scanner(void);
 
 	bool on_activity_timeout(void);
-	bool on_import_url(const std::string &location, const std::string &extraLabel);
+	bool on_import_url(const std::string &location, const std::string &sourceLabel);
 	void on_thread_end(WorkerThread *pThread);
 
 private:

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2006-08-19 11:35:25 UTC (rev 410)
+++ trunk/UI/GTK2/src/mainWindow.cc	2006-08-19 11:41:09 UTC (rev 411)
@@ -43,7 +43,7 @@
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "DownloaderFactory.h"
-#include "WritableXapianIndex.h"
+#include "IndexFactory.h"
 #include "SearchEngineFactory.h"
 #include "config.h"
 #include "NLS.h"
@@ -308,12 +308,6 @@
 	SigC::Slot0<void> documentsActivateSlot = sigc::bind(indexSlot, _("My Documents"));
 	pMenuItem->signal_activate().connect(documentsActivateSlot);
 
-	m_pIndexMenu->items().push_back(Menu_Helpers::MenuElem(_("My Email")));
-	pMenuItem = &m_pIndexMenu->items().back();
-	// Bind the callback's parameter to the index name
-	SigC::Slot0<void> emailActivateSlot = sigc::bind(indexSlot, _("My Email"));
-	pMenuItem->signal_activate().connect(emailActivateSlot);
-
 	if (m_pCacheMenu == NULL)
 	{
 		m_pCacheMenu = manage(new Menu());
@@ -444,7 +438,7 @@
 	if ((hasSelection == true) &&
 		(resultsList.empty() == false))
 	{
-		XapianIndex docsIndex(m_settings.m_docsIndexLocation);
+		IndexInterface *pIndex = m_settings.getROIndex(m_settings.m_docsIndexLocation);
 		bool firstResult = true, isViewable = true, isCached = false, isIndexed = false, isIndexable = true;
 
 		for (vector<DocumentInfo>::iterator resultIter = resultsList.begin();
@@ -481,9 +475,10 @@
 					isCached = true;
 				}
 
-				if (docsIndex.isGood() == true)
+				if ((pIndex != NULL) &&
+					(pIndex->isGood() == true))
 				{
-					if (docsIndex.hasDocument(url) > 0)
+					if (pIndex->hasDocument(url) > 0)
 					{
 						isIndexed = true;
 					}
@@ -496,6 +491,11 @@
 		viewcache1->set_sensitive(isCached);
 		morelikethis1->set_sensitive(isIndexed);
 		indexresults1->set_sensitive(isIndexable);
+
+		if (pIndex != NULL)
+		{
+			delete pIndex;
+		}
 	}
 	else
 	{
@@ -1390,7 +1390,7 @@
 	const set<string> &mailLabelsToDelete = prefsBox.getMailLabelsToDelete();
 	if (mailLabelsToDelete.empty() == false)
 	{
-		start_thread(new UnindexingThread(mailLabelsToDelete, from_utf8(m_settings.m_mailIndexLocation)));
+		start_thread(new UnindexingThread(mailLabelsToDelete, from_utf8(m_settings.m_daemonIndexLocation)));
 	}
 }
 
@@ -1721,25 +1721,30 @@
 		}
 	}
 
-        XapianIndex docsIndex(m_settings.m_docsIndexLocation);
-        set<unsigned int> docIdList;
+	IndexInterface *pIndex = m_settings.getROIndex(m_settings.m_docsIndexLocation);
+        if (pIndex != NULL)
+	{
+		if (pIndex->isGood() == true)
+		{
+        		set<unsigned int> docIdList;
 
-        if (docsIndex.isGood() == true)
-        {
-                for (vector<DocumentInfo>::const_iterator docIter = resultsList.begin();
-                        docIter != resultsList.end(); ++docIter)
-                {
-                        unsigned int docId = docsIndex.hasDocument(docIter->getLocation());
-                        if (docId > 0)
-                        {
-                                docIdList.insert(docId);
-                        }
-                }
+			for (vector<DocumentInfo>::const_iterator docIter = resultsList.begin();
+				docIter != resultsList.end(); ++docIter)
+			{
+				unsigned int docId = pIndex->hasDocument(docIter->getLocation());
+				if (docId > 0)
+				{
+					docIdList.insert(docId);
+				}
+			}
 
-		// Spawn a new thread
-		start_thread(new QueryingThread("xapian", _("My Documents"),
-			m_settings.m_docsIndexLocation, queryProps, docIdList));
-        }
+			// Spawn a new thread
+			start_thread(new QueryingThread("xapian", _("My Documents"),
+				m_settings.m_docsIndexLocation, queryProps, docIdList));
+		}
+
+		delete pIndex;
+	}
 }
 
 //
@@ -1926,8 +1931,6 @@
 		return;
 	}
 
-	WritableXapianIndex index(mapIter->second);
-
 	// Get the current documents selection
 	if ((pIndexTree == NULL) ||
 		(pIndexTree->getSelection(documentsList) == false) ||
@@ -1937,6 +1940,17 @@
 		return;
 	}
 
+	WritableIndexInterface *pIndex = m_settings.getRWIndex(mapIter->second);
+	if ((pIndex == NULL) ||
+		(pIndex->isGood() == false))
+	{
+		if (pIndex != NULL)
+		{
+			delete pIndex;
+		}
+		return;
+	}
+
 	// If there's only one document selected, get its labels
 	if (documentsList.size() == 1)
 	{
@@ -1945,20 +1959,18 @@
 		// Get the document ID
 		docId = docIter->getID();
 
-		if (index.isGood() == true)
+		// Get the properties from the index because they have been altered
+		// by the tree for display purposes
+		pIndex->getDocumentInfo(docId, docInfo);
+		pIndex->getDocumentLabels(docId, docLabels);
+
+		// Does it match the current label ?
+		if ((labelName.empty() == false) &&
+			(find(docLabels.begin(), docLabels.end(), labelName) != docLabels.end()))
 		{
-			// Get the properties from the index because they have been altered
-			// by the tree for display purposes
-			index.getDocumentInfo(docId, docInfo);
-			index.getDocumentLabels(docId, docLabels);
+			matchedLabel = true;
+		}
 
-			// Does it match the current label ?
-			if ((labelName.empty() == false) &&
-				(find(docLabels.begin(), docLabels.end(), labelName) != docLabels.end()))
-			{
-				matchedLabel = true;
-			}
-		}
 		editDocument = true;
 	}
 	else
@@ -1989,8 +2001,10 @@
 	propertiesBox.show();
 	if (propertiesBox.run() != RESPONSE_OK)
 	{
+		delete pIndex;
 		return;
 	}
+
 	const set<string> &labels = propertiesBox.getLabels();
 	string newTitle(propertiesBox.getDocumentInfo().getTitle());
 	string newLanguage(propertiesBox.getDocumentInfo().getLanguage());
@@ -1999,15 +2013,12 @@
 		<< newTitle << ", " << newLanguage << endl;
 #endif
 
-	if (index.isGood() == true)
+	// Now apply these labels to all the documents
+	for (vector<IndexedDocument>::iterator docIter = documentsList.begin();
+		docIter != documentsList.end(); ++docIter)
 	{
-		// Now apply these labels to all the documents
-		for (vector<IndexedDocument>::iterator docIter = documentsList.begin();
-			docIter != documentsList.end(); ++docIter)
-		{
-			// Set the document's labels list
-			index.setDocumentLabels(docIter->getID(), labels);
-		}
+		// Set the document's labels list
+		pIndex->setDocumentLabels(docIter->getID(), labels);
 	}
 
 	if ((documentsList.size() == 1) &&
@@ -2049,6 +2060,8 @@
 			start_thread(new IndexBrowserThread(indexName, labelName, 0, 0));
 		}
 	}
+
+	delete pIndex;
 }
 
 //
@@ -2284,14 +2297,14 @@
 	m_state.m_liveQueryLength = liveQueryLength;
 
 	// FIXME: relying on other indices may also be useful
-	XapianIndex docsIndex(m_settings.m_docsIndexLocation);
-	if (docsIndex.isGood() == true)
+	IndexInterface *pIndex = m_settings.getROIndex(m_settings.m_docsIndexLocation);
+	if (pIndex != NULL)
 	{
 		set<string> suggestedTerms;
 		int termIndex = 0;
 
 		// Get a list of suggestions
-		docsIndex.getCloseTerms(from_utf8(term), suggestedTerms);
+		pIndex->getCloseTerms(from_utf8(term), suggestedTerms);
 
 		// Populate the list
 		for (set<string>::iterator termIter = suggestedTerms.begin();
@@ -2306,6 +2319,8 @@
 #ifdef DEBUG
 		cout << "mainWindow::on_liveQueryEntry_changed: " << termIndex << " suggestions" << endl;
 #endif
+
+		delete pIndex;
 	}
 }
 
@@ -3046,12 +3061,14 @@
 		std::map<string, string>::const_iterator mapIter = indexesMap.find(indexName);
 		if (mapIter != indexesMap.end())
 		{
-			XapianIndex index(mapIter->second);
+			IndexInterface *pIndex = m_settings.getROIndex(mapIter->second);
 	
-			if (index.isGood() == true)
+			if (pIndex != NULL)
 			{
-				appendToList = index.hasLabel(docInfo.getID(), from_utf8(labelName));
+				appendToList = pIndex->hasLabel(docInfo.getID(), from_utf8(labelName));
 			}
+
+			delete pIndex;
 		}
 	}
 

Modified: trunk/UI/GTK2/src/pinot.cc
===================================================================
--- trunk/UI/GTK2/src/pinot.cc	2006-08-19 11:35:25 UTC (rev 410)
+++ trunk/UI/GTK2/src/pinot.cc	2006-08-19 11:41:09 UTC (rev 411)
@@ -142,6 +142,8 @@
 
 	// This will create the necessary directories on the first run
 	PinotSettings &settings = PinotSettings::getInstance();
+	// Talk to the daemon through DBus
+	settings.enableDBus(true);
 
 	string confDirectory = PinotSettings::getConfigurationDirectory();
 	chdir(confDirectory.c_str());
@@ -192,24 +194,16 @@
 	if ((pDb == NULL) ||
 		(pDb->isOpen() == false))
 	{
-		errorMsg = _("Couldn't open index");
+		errorMsg = "Couldn't open index";
 		errorMsg += " ";
 		errorMsg += settings.m_docsIndexLocation;
 	}
-	// ...and the mail and daemon indices in read-only mode
-	pDb = XapianDatabaseFactory::getDatabase(settings.m_mailIndexLocation);
-	if ((pDb == NULL) ||
-		(pDb->isOpen() == false))
-	{
-		errorMsg = _("Couldn't open index");
-		errorMsg += " ";
-		errorMsg += settings.m_mailIndexLocation;
-	}
+	// ...and the daemon index in read-only mode
 	pDb = XapianDatabaseFactory::getDatabase(settings.m_daemonIndexLocation);
 	if ((pDb == NULL) ||
 		(pDb->isOpen() == false))
 	{
-		errorMsg = _("Couldn't open index");
+		errorMsg = "Couldn't open index";
 		errorMsg += " ";
 		errorMsg += settings.m_daemonIndexLocation;
 	}
@@ -219,7 +213,7 @@
 		(QueryHistory::create(settings.m_historyDatabase) == false) ||
 		(ViewHistory::create(settings.m_historyDatabase) == false))
 	{
-		errorMsg = _("Couldn't create history database");
+		errorMsg = "Couldn't create history database";
 		errorMsg += " ";
 		errorMsg += settings.m_historyDatabase;
 	}



From fabricecolin at mail.berlios.de  Sat Aug 19 13:44:01 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 13:44:01 +0200
Subject: [Pinot-svn] r412 - trunk/po
Message-ID: <200608191144.k7JBi1Dg020274@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 13:43:26 +0200 (Sat, 19 Aug 2006)
New Revision: 412

Modified:
   trunk/po/POTFILES.in
Log:
Updated list of source files with translatable strings.


Modified: trunk/po/POTFILES.in
===================================================================
--- trunk/po/POTFILES.in	2006-08-19 11:41:09 UTC (rev 411)
+++ trunk/po/POTFILES.in	2006-08-19 11:43:26 UTC (rev 412)
@@ -1,4 +1,5 @@
 # List of source files containing translatable strings.
+UI/GTK2/src/DaemonState.cpp
 UI/GTK2/src/EnginesTree.cpp
 UI/GTK2/src/importDialog.cc
 UI/GTK2/src/importDialog_glade.cc
@@ -11,6 +12,7 @@
 UI/GTK2/src/ModelColumns.cpp
 UI/GTK2/src/MboxHandler.cpp
 UI/GTK2/src/Notebook.cpp
+UI/GTK2/src/OnDiskHandler.cpp
 UI/GTK2/src/pinot.cc
 UI/GTK2/src/pinot-dbus-daemon.cc
 UI/GTK2/src/PinotSettings.cpp



From fabricecolin at mail.berlios.de  Sat Aug 19 14:05:31 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 14:05:31 +0200
Subject: [Pinot-svn] r413 - in trunk: . Collect Index Search UI/GTK2/src
Message-ID: <200608191205.k7JC5VG7027702@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 14:04:57 +0200 (Sat, 19 Aug 2006)
New Revision: 413

Modified:
   trunk/Collect/pinot-collect.1
   trunk/Index/pinot-index.1
   trunk/NEWS
   trunk/Search/pinot-search.1
   trunk/UI/GTK2/src/pinot.1
   trunk/configure.in
Log:
Preparing for 0.60 release.


Modified: trunk/Collect/pinot-collect.1
===================================================================
--- trunk/Collect/pinot-collect.1	2006-08-19 11:43:26 UTC (rev 412)
+++ trunk/Collect/pinot-collect.1	2006-08-19 12:04:57 UTC (rev 413)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-COLLECT "1" "July 2006" "pinot-collect - pinot 0.50" "User Commands"
+.TH PINOT-COLLECT "1" "August 2006" "pinot-collect - pinot 0.50" "User Commands"
 .SH NAME
 pinot-collect \- Download an URL from the command-line
 .SH SYNOPSIS

Modified: trunk/Index/pinot-index.1
===================================================================
--- trunk/Index/pinot-index.1	2006-08-19 11:43:26 UTC (rev 412)
+++ trunk/Index/pinot-index.1	2006-08-19 12:04:57 UTC (rev 413)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-INDEX "1" "July 2006" "pinot-index - pinot 0.50" "User Commands"
+.TH PINOT-INDEX "1" "August 2006" "pinot-index - pinot 0.50" "User Commands"
 .SH NAME
 pinot-index \- Index documents from the command-line
 .SH SYNOPSIS
@@ -21,7 +21,7 @@
 \fB\-v\fR, \fB\-\-version\fR
 output version information and exit
 .SH EXAMPLES
-pinot\-index \fB\-\-check\fR http://pinot.berlios.de/ xapian ~/.pinot/index
+pinot\-index \fB\-\-check\fR file:///home/fabrice/Documents/Bozo.txt xapian ~/.pinot/daemon
 .PP
 pinot\-index \fB\-\-index\fR http://pinot.berlios.de/ xapian ~/.pinot/index
 .SH "REPORTING BUGS"

Modified: trunk/NEWS
===================================================================
--- trunk/NEWS	2006-08-19 11:43:26 UTC (rev 412)
+++ trunk/NEWS	2006-08-19 12:04:57 UTC (rev 413)
@@ -1,3 +1,26 @@
+??? version_0_6_0
+Monitor :
+ - inotify monitor more flexible
+SQL :
+ - saves the daemon's crawler history
+Index :
+ - able to open remote indexes that were not initially available
+ - indexes are open in write mode only when necessary
+ - prefer Xapian's Flint back-end to Quartz
+Search :
+ - fixed issue with abstract generation on remote indexes
+UI :
+ - fixed language shown in the properties box when language is unknown
+  for one or more of the documents selected
+ - better at queuing document indexing
+ - My Email index is replaced with the index managed by the daemon
+Daemon :
+ - crawls and indexes user-defined locations on the filesystem
+ - recursively monitors these locations for changes and updates the index
+ - same for mboxes
+ - provides a DBus interface suitable for querying and document inspection
+ - no dependency on gtkmm
+
 2006/07/05 version_0_5_0
 Tokenize :
  - switched to pdftotext, which seems to support more files than pdftohtml

Modified: trunk/Search/pinot-search.1
===================================================================
--- trunk/Search/pinot-search.1	2006-08-19 11:43:26 UTC (rev 412)
+++ trunk/Search/pinot-search.1	2006-08-19 12:04:57 UTC (rev 413)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-SEARCH "1" "July 2006" "pinot-search - pinot 0.50" "User Commands"
+.TH PINOT-SEARCH "1" "August 2006" "pinot-search - pinot 0.50" "User Commands"
 .SH NAME
 pinot-search \- Query search engines from the command-line
 .SH SYNOPSIS

Modified: trunk/UI/GTK2/src/pinot.1
===================================================================
--- trunk/UI/GTK2/src/pinot.1	2006-08-19 11:43:26 UTC (rev 412)
+++ trunk/UI/GTK2/src/pinot.1	2006-08-19 12:04:57 UTC (rev 413)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT "1" "July 2006" "pinot - pinot 0.50" "User Commands"
+.TH PINOT "1" "August 2006" "pinot - pinot 0.50" "User Commands"
 .SH NAME
 pinot \- A metasearch tool for the Free Desktop
 .SH SYNOPSIS

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2006-08-19 11:43:26 UTC (rev 412)
+++ trunk/configure.in	2006-08-19 12:04:57 UTC (rev 413)
@@ -2,7 +2,7 @@
 # using glademm V2.6.0
 
 AC_PREREQ(2.50)
-AC_INIT(pinot, 0.50,[fabricecolin at users.berlios.de])
+AC_INIT(pinot, 0.60,[fabricecolin at users.berlios.de])
 AM_INIT_AUTOMAKE
 AC_CONFIG_HEADERS(config.h)
 



From fabricecolin at mail.berlios.de  Sat Aug 19 16:30:31 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 16:30:31 +0200
Subject: [Pinot-svn] r414 - trunk/Index
Message-ID: <200608191430.k7JEUV9O019732@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 16:30:31 +0200 (Sat, 19 Aug 2006)
New Revision: 414

Modified:
   trunk/Index/XapianIndex.cpp
Log:
Don't request write access in hasLabel().


Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2006-08-19 12:04:57 UTC (rev 413)
+++ trunk/Index/XapianIndex.cpp	2006-08-19 14:30:31 UTC (rev 414)
@@ -236,7 +236,7 @@
 
 	try
 	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		Xapian::WritableDatabase *pIndex = pDatabase->readLock();
 		if (pIndex != NULL)
 		{
 			string term("XLABEL:");



From fabricecolin at mail.berlios.de  Sat Aug 19 17:28:07 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 19 Aug 2006 17:28:07 +0200
Subject: [Pinot-svn] r415 - trunk/Index
Message-ID: <200608191528.k7JFS7Ak025278@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-19 17:28:06 +0200 (Sat, 19 Aug 2006)
New Revision: 415

Modified:
   trunk/Index/XapianIndex.cpp
Log:
Fix for previous check-in.


Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2006-08-19 14:30:31 UTC (rev 414)
+++ trunk/Index/XapianIndex.cpp	2006-08-19 15:28:06 UTC (rev 415)
@@ -236,7 +236,7 @@
 
 	try
 	{
-		Xapian::WritableDatabase *pIndex = pDatabase->readLock();
+		Xapian::Database *pIndex = pDatabase->readLock();
 		if (pIndex != NULL)
 		{
 			string term("XLABEL:");



From fabricecolin at mail.berlios.de  Mon Aug 21 14:01:31 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Mon, 21 Aug 2006 14:01:31 +0200
Subject: [Pinot-svn] r416 - trunk/Monitor
Message-ID: <200608211201.k7LC1VU9014406@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-21 14:01:29 +0200 (Mon, 21 Aug 2006)
New Revision: 416

Modified:
   trunk/Monitor/INotifyMonitor.cpp
Log:
Bug fix in retrievePendingEvents().


Modified: trunk/Monitor/INotifyMonitor.cpp
===================================================================
--- trunk/Monitor/INotifyMonitor.cpp	2006-08-19 15:28:06 UTC (rev 415)
+++ trunk/Monitor/INotifyMonitor.cpp	2006-08-21 12:01:29 UTC (rev 416)
@@ -91,7 +91,7 @@
 		m_locations.insert(pair<string, int>(location, watchNum));
 #ifdef DEBUG
 		cout << "INotifyMonitor::addLocation: added watch "
-			<< watchNum << " " << location << endl;
+			<< watchNum << " for " << location << endl;
 #endif
 
 		return true;
@@ -148,7 +148,7 @@
 		events.push(internalEvent);
 
 		// Next
-		events.pop();
+		m_internalEvents.pop();
 	}
 
 	if (ioctl (m_monitorFd, FIONREAD, &queueLen) == 0)



From fabricecolin at mail.berlios.de  Mon Aug 21 15:49:36 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Mon, 21 Aug 2006 15:49:36 +0200
Subject: [Pinot-svn] r417 - in trunk: Monitor UI/GTK2/src
Message-ID: <200608211349.k7LDnaBS003828@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-21 15:49:35 +0200 (Mon, 21 Aug 2006)
New Revision: 417

Modified:
   trunk/Monitor/MonitorHandler.cpp
   trunk/Monitor/MonitorHandler.h
   trunk/UI/GTK2/src/MboxHandler.cpp
   trunk/UI/GTK2/src/OnDiskHandler.cpp
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
Log:
Renamed MonitorHandler::getLocations() to getFileNames() since this only deals
with files. Monitoring those is done by MonitoringThread, which checks for
events right after initializing the handler.
OnDiskHandler::indexFile() creates an empty document if the file couldn't be
downloaded.


Modified: trunk/Monitor/MonitorHandler.cpp
===================================================================
--- trunk/Monitor/MonitorHandler.cpp	2006-08-21 12:01:29 UTC (rev 416)
+++ trunk/Monitor/MonitorHandler.cpp	2006-08-21 13:49:35 UTC (rev 417)
@@ -27,9 +27,9 @@
 {
 }
 
-const set<string> &MonitorHandler::getLocations(void) const
+const set<string> &MonitorHandler::getFileNames(void) const
 {
-	return m_locations;
+	return m_fileNames;
 }
 
 Signal3<void, IndexedDocument, unsigned int, string>& MonitorHandler::getUpdateSignal(void)

Modified: trunk/Monitor/MonitorHandler.h
===================================================================
--- trunk/Monitor/MonitorHandler.h	2006-08-21 12:01:29 UTC (rev 416)
+++ trunk/Monitor/MonitorHandler.h	2006-08-21 13:49:35 UTC (rev 417)
@@ -54,14 +54,14 @@
 		/// Handles file deleted events.
 		virtual bool fileDeleted(const std::string &fileName) = 0;
 
-		/// Returns locations.
-		const std::set<std::string> &getLocations(void) const;
+		/// Returns the names of files to monitor.
+		const std::set<std::string> &getFileNames(void) const;
 
 		/// Returns the file update signal.
 		SigC::Signal3<void, IndexedDocument, unsigned int, std::string>& getUpdateSignal(void);
 
 	protected:
-		std::set<std::string> m_locations;
+		std::set<std::string> m_fileNames;
 		SigC::Signal3<void, IndexedDocument, unsigned int, std::string> m_signalUpdate;
 
 	private:

Modified: trunk/UI/GTK2/src/MboxHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-21 12:01:29 UTC (rev 416)
+++ trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-21 13:49:35 UTC (rev 417)
@@ -46,6 +46,9 @@
 		// Create it
 		m_sourceId = m_history.insertSource("My Email");
 	}
+#ifdef DEBUG
+	cout << "MboxHandler: My Email source ID is " << m_sourceId << endl;
+#endif
 }
 
 MboxHandler::~MboxHandler()
@@ -261,7 +264,7 @@
 	for (set<PinotSettings::TimestampedItem>::iterator mailIter = mailAccounts.begin();
 		mailIter != mailAccounts.end(); ++mailIter)
 	{
-		m_locations.insert(mailIter->m_name);
+		m_fileNames.insert(mailIter->m_name);
 	}
 
 	// Unindex messages that belong to mailboxes that no longer exist
@@ -274,7 +277,7 @@
 
 			// Is this a file and does it still exist ?
 			if ((urlObj.getProtocol() == "file") &&
-				(m_locations.find(mailIter->substr(7)) == m_locations.end()))
+				(m_fileNames.find(mailIter->substr(7)) == m_fileNames.end()))
 			{
 				string sourceLabel("mailbox://");
 
@@ -298,6 +301,9 @@
 #endif
 		}
 	}
+#ifdef DEBUG
+	cout << "MboxHandler::initialize: " << m_fileNames.size() << " mail accounts" << endl;
+#endif
 }
 
 void MboxHandler::flushIndex(void)

Modified: trunk/UI/GTK2/src/OnDiskHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-21 12:01:29 UTC (rev 416)
+++ trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-21 13:49:35 UTC (rev 417)
@@ -79,7 +79,9 @@
 #ifdef DEBUG
 		cout << "OnDiskHandler::indexFile: couldn't download " << url << endl;
 #endif
-		return false;
+
+		// The file  couldn't be downloaded but exists nonetheless !
+		pDoc = new Document(docInfo);
 	}
 
 	// Get an ad hoc tokenizer for the message
@@ -125,13 +127,14 @@
 void OnDiskHandler::initialize(void)
 {
 	map<unsigned int, string> sources;
+	set<string> directories;
 
 	// Get the map of indexable locations
 	set<PinotSettings::TimestampedItem> &indexableLocations = PinotSettings::getInstance().m_indexableLocations;
 	for (set<PinotSettings::TimestampedItem>::iterator dirIter = indexableLocations.begin();
 		dirIter != indexableLocations.end(); ++dirIter)
 	{
-		m_locations.insert(dirIter->m_name);
+		directories.insert(dirIter->m_name);
 	}
 
 	// Unindex documents that belong to sources that no longer exist
@@ -148,7 +151,7 @@
 				continue;
 			}
 
-			if (m_locations.find(sourceIter->second.substr(7)) == m_locations.end())
+			if (directories.find(sourceIter->second.substr(7)) == directories.end())
 			{
 				char sourceStr[64];
 

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-21 12:01:29 UTC (rev 416)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-21 13:49:35 UTC (rev 417)
@@ -1466,11 +1466,88 @@
 	m_done = true;
 	write(m_ctrlWritePipe, "Stop", 4);
 	m_status = _("Stopped monitoring");
+
+	return true;
+}
+
+void MonitorThread::processEvents(void)
+{
+	queue<MonitorEvent> events;
+
+	if (m_pMonitor->retrievePendingEvents(events) == false)
+	{
 #ifdef DEBUG
-	cout << "MonitorThread::doWork: stop called" << endl;
+		cout << "MonitorThread::processEvents: failed to retrieve pending events" << endl;
 #endif
+		return;
+	}
+#ifdef DEBUG
+	cout << "MonitorThread::processEvents: retrieved " << events.size() << " events" << endl;
+#endif
 
-	return true;
+	while ((events.empty() == false) &&
+		(m_done == false))
+	{
+		MonitorEvent &event = events.front();
+
+		if ((event.m_location.empty() == true) ||
+			(event.m_type == MonitorEvent::UNKNOWN))
+		{
+			// Next
+			events.pop();
+			continue;
+		}
+
+		// What's the event code ?
+#ifdef DEBUG
+		cout << "MonitorThread::processEvents: event on " << event.m_location << endl;
+#endif
+		if (event.m_type == MonitorEvent::EXISTS)
+		{
+			m_pHandler->fileExists(event.m_location);
+		}
+		else if (event.m_type == MonitorEvent::CREATED)
+		{
+			m_pHandler->fileCreated(event.m_location);
+
+			// If a whole directory was created, monitor it
+			if (event.m_isDirectory == true)
+			{
+				// FIXME: crawl it first !
+				m_pMonitor->addLocation(event.m_location, true);
+			}
+		}
+		else if (event.m_type == MonitorEvent::WRITE_CLOSED)
+		{
+			m_pHandler->fileModified(event.m_location);
+		}
+		else if (event.m_type == MonitorEvent::MOVED)
+		{
+			m_pHandler->fileMoved(event.m_location, event.m_previousLocation);
+
+			if ((event.m_isDirectory == true) &&
+				(event.m_isWatch == true))
+			{
+				// Stop monitoring
+				m_pMonitor->removeLocation(event.m_previousLocation);
+				// FIXME: monitor the new location
+			}
+		}
+		else if (event.m_type == MonitorEvent::DELETED)
+		{
+			m_pHandler->fileDeleted(event.m_location);
+
+			if ((event.m_isDirectory == true) &&
+				(event.m_isWatch == true))
+			{
+				// Stop monitoring
+				m_pMonitor->removeLocation(event.m_location);
+			}
+		}
+
+		// Next
+		events.pop();
+	}
 }
 
 void MonitorThread::doWork(void)
@@ -1485,8 +1562,19 @@
 	// Initialize the handler
 	m_pHandler->initialize();
 
-	// What locations to monitor is set by DirectoryScannerThread
+	// Get the list of files to monitor
+	const set<string> &fileNames = m_pHandler->getFileNames();
+	for (set<string>::const_iterator fileIter = fileNames.begin();
+		fileIter != fileNames.end(); ++fileIter)
+	{
+		m_pMonitor->addLocation(*fileIter, false);
+	}
+	// Directories, if any, are set elsewhere
+	// In the case of OnDiskHandler, they are set by DirectoryScannerThread
 
+	// There might already be events that need processing
+	processEvents();
+
 	// Wait for something to happen
 	while (m_done == false)
 	{
@@ -1524,79 +1612,7 @@
 		}
 		else if (FD_ISSET(monitorFd, &listenSet))
 		{
-			queue<MonitorEvent> events;
-
-			// There might be more than one event waiting...
-			if (m_pMonitor->retrievePendingEvents(events) == false)
-			{
-#ifdef DEBUG
-				cout << "MonitorThread::doWork: failed to retrieve pending events" << endl;
-#endif
-				break;
-			}
-
-			while ((events.empty() == false) &&
-				(m_done == false))
-			{
-				MonitorEvent &event = events.front();
-
-				if ((event.m_location.empty() == true) ||
-					(event.m_type == MonitorEvent::UNKNOWN))
-				{
-					// Next
-					events.pop();
-					continue;
-				}
-
-				bool updatedIndex = false;
-
-				// What's the event code ?
-				if (event.m_type == MonitorEvent::EXISTS)
-				{
-					m_pHandler->fileExists(event.m_location);
-				}
-				else if (event.m_type == MonitorEvent::CREATED)
-				{
-					m_pHandler->fileCreated(event.m_location);
-
-					// If a whole directory was created, monitor it
-					if (event.m_isDirectory == true)
-					{
-						// FIXME: crawl it first !
-						m_pMonitor->addLocation(event.m_location, true);
-					}
-				}
-				else if (event.m_type == MonitorEvent::WRITE_CLOSED)
-				{
-					updatedIndex = m_pHandler->fileModified(event.m_location);
-				}
-				else if (event.m_type == MonitorEvent::MOVED)
-				{
-					updatedIndex = m_pHandler->fileMoved(event.m_location, event.m_previousLocation);
-
-					if ((event.m_isDirectory == true) &&
-						(event.m_isWatch == true))
-					{
-						// Stop monitoring
-						m_pMonitor->removeLocation(event.m_previousLocation);
-						// FIXME: monitor the new location
-					}
-				}
-				else if (event.m_type == MonitorEvent::DELETED)
-				{
-					updatedIndex = m_pHandler->fileDeleted(event.m_location);
-
-					if ((event.m_isDirectory == true) &&
-						(event.m_isWatch == true))
-					{
-						// Stop monitoring
-						m_pMonitor->removeLocation(event.m_location);
-					}
-				}
-
-				// Next
-				events.pop();
-			}
+			processEvents();
 		}
 	}
 }

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2006-08-21 12:01:29 UTC (rev 416)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2006-08-21 13:49:35 UTC (rev 417)
@@ -387,6 +387,7 @@
 		MonitorInterface *m_pMonitor;
 		MonitorHandler *m_pHandler;
 
+		void processEvents(void);
 		virtual void doWork(void);
 
 	private:



From fabricecolin at mail.berlios.de  Tue Aug 22 13:56:59 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Tue, 22 Aug 2006 13:56:59 +0200
Subject: [Pinot-svn] r418 - trunk/SQL
Message-ID: <200608221156.k7MBuxjO001017@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-22 13:56:58 +0200 (Tue, 22 Aug 2006)
New Revision: 418

Modified:
   trunk/SQL/CrawlHistory.cpp
Log:
Forgot to unescape URLs in getSourceItems().


Modified: trunk/SQL/CrawlHistory.cpp
===================================================================
--- trunk/SQL/CrawlHistory.cpp	2006-08-21 13:49:35 UTC (rev 417)
+++ trunk/SQL/CrawlHistory.cpp	2006-08-22 11:56:58 UTC (rev 418)
@@ -289,7 +289,7 @@
 				break;
 			}
 
-			urls.insert(row->getColumn(0));
+			urls.insert(Url::unescapeUrl(row->getColumn(0)));
 			++count;
 
 			delete row;



From fabricecolin at mail.berlios.de  Thu Aug 24 13:33:42 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 24 Aug 2006 13:33:42 +0200
Subject: [Pinot-svn] r419 - in trunk: Monitor Search Utils
Message-ID: <200608241133.k7OBXg2N004011@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-24 13:33:17 +0200 (Thu, 24 Aug 2006)
New Revision: 419

Modified:
   trunk/Monitor/MonitorEvent.cpp
   trunk/Search/SearchPluginProperties.cpp
   trunk/Utils/Url.cpp
   trunk/Utils/Url.h
   trunk/Utils/XapianDatabase.cpp
Log:
Fixed issues with some copy constructors.


Modified: trunk/Monitor/MonitorEvent.cpp
===================================================================
--- trunk/Monitor/MonitorEvent.cpp	2006-08-22 11:56:58 UTC (rev 418)
+++ trunk/Monitor/MonitorEvent.cpp	2006-08-24 11:33:17 UTC (rev 419)
@@ -26,13 +26,13 @@
 {
 }
 
-MonitorEvent::MonitorEvent(const MonitorEvent &other)
+MonitorEvent::MonitorEvent(const MonitorEvent &other) :
+	m_location(other.m_location),
+	m_previousLocation(other.m_previousLocation),
+	m_isWatch(other.m_isWatch),
+	m_type(other.m_type),
+	m_isDirectory(other.m_isDirectory)
 {
-	m_location = other.m_location;
-	m_previousLocation = other.m_previousLocation;
-	m_isWatch = other.m_isWatch;
-	m_type = other.m_type;
-	m_isDirectory = other.m_isDirectory;
 }
 
 MonitorEvent::~MonitorEvent()

Modified: trunk/Search/SearchPluginProperties.cpp
===================================================================
--- trunk/Search/SearchPluginProperties.cpp	2006-08-22 11:56:58 UTC (rev 418)
+++ trunk/Search/SearchPluginProperties.cpp	2006-08-24 11:33:17 UTC (rev 419)
@@ -72,12 +72,16 @@
 	m_nextBase = other.m_nextBase;
 	m_response = other.m_response;
 
+	m_languages.clear();
 	copy(other.m_languages.begin(), other.m_languages.end(),
 		inserter(m_languages, m_languages.begin()));
+	m_outputEncodings.clear();
 	copy(other.m_outputEncodings.begin(), other.m_outputEncodings.end(),
 		inserter(m_outputEncodings, m_outputEncodings.begin()));
+	m_inputEncodings.clear();
 	copy(other.m_inputEncodings.begin(), other.m_inputEncodings.end(),
 		inserter(m_inputEncodings, m_inputEncodings.begin()));
+	m_parameters.clear();
 	copy(other.m_parameters.begin(), other.m_parameters.end(),
 		inserter(m_parameters, m_parameters.begin()));
 }

Modified: trunk/Utils/Url.cpp
===================================================================
--- trunk/Utils/Url.cpp	2006-08-22 11:56:58 UTC (rev 418)
+++ trunk/Utils/Url.cpp	2006-08-24 11:33:17 UTC (rev 419)
@@ -58,6 +58,19 @@
 {
 }
 
+Url& Url::operator=(const Url& other)
+{
+	m_protocol = other.m_protocol;
+	m_user = other.m_user;
+	m_password = other.m_password;
+	m_host = other.m_host;
+	m_location = other.m_location;
+	m_file = other.m_file;
+	m_parameters = other.m_parameters;
+
+	return *this;
+}
+
 void Url::parse(const string &url)
 {
 	string::size_type pos1 =0, pos2 = 0;
@@ -445,15 +458,3 @@
 	return isLocal(m_protocol);
 }
 
-Url& Url::operator=(const Url& other)
-{
-	m_protocol = other.m_protocol;
-	m_user = other.m_user;
-	m_password = other.m_password;
-	m_host = other.m_host;
-	m_location = other.m_location;
-	m_file = other.m_file;
-	m_parameters = other.m_parameters;
-
-	return *this;
-}

Modified: trunk/Utils/Url.h
===================================================================
--- trunk/Utils/Url.h	2006-08-22 11:56:58 UTC (rev 418)
+++ trunk/Utils/Url.h	2006-08-24 11:33:17 UTC (rev 419)
@@ -26,6 +26,8 @@
 		Url(const Url &other);
 		virtual ~Url();
 
+		Url& operator=(const Url& other);
+
 		/// Canonicalizes an URL.
 		static std::string canonicalizeUrl(const std::string &url);
 
@@ -50,8 +52,6 @@
 		std::string getParameters(void) const;
 		bool isLocal(void) const ;
 
-		Url& operator=(const Url& other);
-
 	protected:
 		std::string m_protocol;
 		std::string m_user;

Modified: trunk/Utils/XapianDatabase.cpp
===================================================================
--- trunk/Utils/XapianDatabase.cpp	2006-08-22 11:56:58 UTC (rev 418)
+++ trunk/Utils/XapianDatabase.cpp	2006-08-24 11:33:17 UTC (rev 419)
@@ -41,9 +41,13 @@
 XapianDatabase::XapianDatabase(const XapianDatabase &other) :
 	m_databaseName(other.m_databaseName),
 	m_readOnly(other.m_readOnly),
-	m_pDatabase(other.m_pDatabase),
+	m_pDatabase(NULL),
 	m_isOpen(other.m_isOpen)
 {
+	if (other.m_pDatabase != NULL)
+	{
+		m_pDatabase = new Xapian::Database(*other.m_pDatabase);
+	}
 	pthread_rwlock_init(&m_rwLock, NULL);
 }
 
@@ -63,8 +67,12 @@
 	if (m_pDatabase != NULL)
 	{
 		delete m_pDatabase;
+		m_pDatabase = NULL;
 	}
-	m_pDatabase = other.m_pDatabase;
+	if (other.m_pDatabase != NULL)
+	{
+		m_pDatabase = new Xapian::Database(*other.m_pDatabase);
+	}
 	m_isOpen = other.m_isOpen;
 
 	return *this;



From fabricecolin at mail.berlios.de  Thu Aug 24 15:20:35 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 24 Aug 2006 15:20:35 +0200
Subject: [Pinot-svn] r420 - trunk/Index
Message-ID: <200608241320.k7ODKZSa008497@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-24 15:20:28 +0200 (Thu, 24 Aug 2006)
New Revision: 420

Modified:
   trunk/Index/DBusXapianIndex.h
   trunk/Index/WritableXapianIndex.h
   trunk/Index/XapianIndex.cpp
   trunk/Index/XapianIndex.h
Log:
Cosmetic changes.


Modified: trunk/Index/DBusXapianIndex.h
===================================================================
--- trunk/Index/DBusXapianIndex.h	2006-08-24 11:33:17 UTC (rev 419)
+++ trunk/Index/DBusXapianIndex.h	2006-08-24 13:20:28 UTC (rev 420)
@@ -20,7 +20,6 @@
 #include <string>
 #include <set>
 
-#include "DocumentInfo.h"
 #include "XapianIndex.h"
 
 class DBusXapianIndex : public WritableIndexInterface, private XapianIndex

Modified: trunk/Index/WritableXapianIndex.h
===================================================================
--- trunk/Index/WritableXapianIndex.h	2006-08-24 11:33:17 UTC (rev 419)
+++ trunk/Index/WritableXapianIndex.h	2006-08-24 13:20:28 UTC (rev 420)
@@ -22,7 +22,6 @@
 
 #include <xapian.h>
 
-#include "DocumentInfo.h"
 #include "XapianIndex.h"
 
 class WritableXapianIndex : public WritableIndexInterface, private XapianIndex

Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2006-08-24 11:33:17 UTC (rev 419)
+++ trunk/Index/XapianIndex.cpp	2006-08-24 13:20:28 UTC (rev 420)
@@ -23,11 +23,11 @@
 #include <strings.h>
 #include <time.h>
 #include <ctype.h>
-#include <regex.h>
 #include <iostream>
 #include <fstream>
 #include <algorithm>
 #include <utility>
+#include <xapian.h>
 
 #include "Languages.h"
 #include "StringManip.h"

Modified: trunk/Index/XapianIndex.h
===================================================================
--- trunk/Index/XapianIndex.h	2006-08-24 11:33:17 UTC (rev 419)
+++ trunk/Index/XapianIndex.h	2006-08-24 13:20:28 UTC (rev 420)
@@ -20,9 +20,7 @@
 #include <string>
 #include <set>
 
-#include <xapian.h>
-
-#include "DocumentInfo.h"
+#include "XapianDatabase.h"
 #include "IndexInterface.h"
 
 class XapianIndex : public IndexInterface



From fabricecolin at mail.berlios.de  Sat Aug 26 03:34:28 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 03:34:28 +0200
Subject: [Pinot-svn] r421 - trunk/Index
Message-ID: <200608260134.k7Q1YSkm021111@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 03:34:15 +0200 (Sat, 26 Aug 2006)
New Revision: 421

Modified:
   trunk/Index/XapianIndex.cpp
Log:
getCloseTerms() can suggest terms starting with an upper-case letter.


Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2006-08-24 13:20:28 UTC (rev 420)
+++ trunk/Index/XapianIndex.cpp	2006-08-26 01:34:15 UTC (rev 421)
@@ -390,7 +390,15 @@
 			{
 				string baseTerm(StringManip::toLowerCase(term));
 				unsigned int count = 0;
+				bool isUpper = false;
 
+				if (isupper((int)term[0]) != 0)
+				{
+					// R-prefix the term
+					baseTerm = string("R") + term;
+					isUpper = true;
+				}
+
 				// Get the next 10 terms
 				for (termIter.skip_to(baseTerm);
 					(termIter != pIndex->allterms_end()) && (count < 10); ++termIter)
@@ -400,9 +408,29 @@
 					if (suggestedTerm.find(baseTerm) != 0)
 					{
 						// This term doesn't have the same root
+						if (isUpper == true)
+						{
+							// Try again without capital letters
+							baseTerm = StringManip::toLowerCase(term);
+							termIter = pIndex->allterms_begin();
+							if (termIter != pIndex->allterms_end())
+							{
+								termIter.skip_to(baseTerm);
+								isUpper = false;
+								continue;
+							}
+						}
+
 						break;
 					}
-					suggestions.insert(*termIter);
+
+					if (isUpper == true)
+					{
+						// Remove the R prefix
+						suggestedTerm.erase(0, 1);
+					}
+
+					suggestions.insert(suggestedTerm);
 					++count;
 				}
 			}



From fabricecolin at mail.berlios.de  Sat Aug 26 03:36:44 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 03:36:44 +0200
Subject: [Pinot-svn] r422 - trunk/Utils
Message-ID: <200608260136.k7Q1aiex021409@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 03:36:43 +0200 (Sat, 26 Aug 2006)
New Revision: 422

Modified:
   trunk/Utils/XapianDatabase.cpp
   trunk/Utils/XapianDatabase.h
   trunk/Utils/XapianDatabaseFactory.cpp
   trunk/Utils/XapianDatabaseFactory.h
Log:
Allow to add a database to another with Xapian::Database::add_database() while
making sure both are read-locked.


Modified: trunk/Utils/XapianDatabase.cpp
===================================================================
--- trunk/Utils/XapianDatabase.cpp	2006-08-26 01:34:15 UTC (rev 421)
+++ trunk/Utils/XapianDatabase.cpp	2006-08-26 01:36:43 UTC (rev 422)
@@ -32,23 +32,45 @@
 	m_databaseName(databaseName),
 	m_readOnly(readOnly),
 	m_pDatabase(NULL),
-	m_isOpen(false)
+	m_isOpen(false),
+	m_merge(false),
+	m_pFirst(NULL),
+	m_pSecond(NULL)
 {
 	pthread_rwlock_init(&m_rwLock, NULL);
 	openDatabase();
 }
 
+XapianDatabase::XapianDatabase(const string &databaseName, 
+	XapianDatabase *pFirst, XapianDatabase *pSecond) :
+	m_databaseName(databaseName),
+	m_readOnly(true),
+	m_pDatabase(NULL),
+	m_isOpen(pFirst->m_isOpen),
+	m_merge(true),
+	m_pFirst(pFirst),
+	m_pSecond(pSecond)
+{
+	pthread_rwlock_init(&m_rwLock, NULL);
+}
+
 XapianDatabase::XapianDatabase(const XapianDatabase &other) :
 	m_databaseName(other.m_databaseName),
 	m_readOnly(other.m_readOnly),
 	m_pDatabase(NULL),
-	m_isOpen(other.m_isOpen)
+	m_isOpen(other.m_isOpen),
+	m_merge(other.m_merge),
+	m_pFirst(other.m_pFirst),
+	m_pSecond(other.m_pSecond)
 {
+	pthread_rwlock_init(&m_rwLock, NULL);
 	if (other.m_pDatabase != NULL)
 	{
 		m_pDatabase = new Xapian::Database(*other.m_pDatabase);
+#ifdef DEBUG
+		cout << "XapianDatabase: copied " << m_databaseName << endl;
+#endif
 	}
-	pthread_rwlock_init(&m_rwLock, NULL);
 }
 
 XapianDatabase::~XapianDatabase()
@@ -56,6 +78,9 @@
 	if (m_pDatabase != NULL)
 	{
 		delete m_pDatabase;
+#ifdef DEBUG
+		cout << "XapianDatabase::~XapianDatabase:unlock: deleted" << endl;
+#endif
 	}
 	pthread_rwlock_destroy(&m_rwLock);
 }
@@ -68,12 +93,21 @@
 	{
 		delete m_pDatabase;
 		m_pDatabase = NULL;
+#ifdef DEBUG
+		cout << "XapianDatabase::operator=: deleted" << endl;
+#endif
 	}
 	if (other.m_pDatabase != NULL)
 	{
 		m_pDatabase = new Xapian::Database(*other.m_pDatabase);
+#ifdef DEBUG
+		cout << "XapianDatabase::operator=: copied " << m_databaseName << endl;
+#endif
 	}
 	m_isOpen = other.m_isOpen;
+	m_merge = other.m_merge;
+	m_pFirst = other.m_pFirst;
+	m_pSecond = other.m_pSecond;
 
 	return *this;
 }
@@ -94,6 +128,9 @@
 	{
 		delete m_pDatabase;
 		m_pDatabase = NULL;
+#ifdef DEBUG
+		cout << "XapianDatabase::openDatabase: deleted" << endl;
+#endif
 	}
 
 	// Is it a remote database ?
@@ -168,6 +205,9 @@
 		{
 			m_pDatabase = new Xapian::WritableDatabase(m_databaseName, Xapian::DB_CREATE_OR_OPEN);
 		}
+#ifdef DEBUG
+		cout << "XapianDatabase::openDatabase: opened " << m_databaseName << endl;
+#endif
 		m_isOpen = true;
 
 		return;
@@ -190,17 +230,50 @@
 /// Attempts to lock and retrieve the database.
 Xapian::Database *XapianDatabase::readLock(void)
 {
+	if (m_merge == false)
+	{
 #ifdef DEBUG
-	cout << "XapianDatabase::readLock: " << m_databaseName << endl;
+		cout << "XapianDatabase::readLock: " << m_databaseName << endl;
 #endif
-	if (pthread_rwlock_rdlock(&m_rwLock) == 0)
+		if (pthread_rwlock_rdlock(&m_rwLock) == 0)
+		{
+			if (m_pDatabase == NULL)
+			{
+				// Try again
+				openDatabase();
+			}
+			return m_pDatabase;
+		}
+	}
+	else
 	{
-		if (m_pDatabase == NULL)
+		if ((m_pFirst == NULL) ||
+			(m_pFirst->isOpen() == false) ||
+			(m_pSecond == NULL) ||
+			(m_pSecond->isOpen() == false))
 		{
-			// Try again
-			openDatabase();
+			return NULL;
 		}
-		return m_pDatabase;
+
+		if (pthread_rwlock_rdlock(&m_rwLock) == 0)
+		{
+			// Lock both indexes
+			Xapian::Database *pFirstDatabase = m_pFirst->readLock();
+			Xapian::Database *pSecondDatabase = m_pSecond->readLock();
+			// Copy the first one
+			m_pDatabase = new Xapian::Database(*pFirstDatabase);
+			// Add the second index to it
+			if (pSecondDatabase != NULL)
+			{
+				m_pDatabase->add_database(*pSecondDatabase);
+			}
+			// Until unlock() is called, both indexes are read locked
+#ifdef DEBUG
+			cout << "XapianDatabase::readLock: copied " << m_pFirst->m_databaseName << endl;
+#endif
+
+			return m_pDatabase;
+		}
 	}
 
 	return NULL;
@@ -209,7 +282,8 @@
 /// Attempts to lock and retrieve the database.
 Xapian::WritableDatabase *XapianDatabase::writeLock(void)
 {
-	if (m_readOnly == true)
+	if ((m_readOnly == true) ||
+		(m_merge == true))
 	{
 		// FIXME: close and reopen in write mode
 		cerr << "Couldn't open read-only database " << m_databaseName
@@ -240,6 +314,29 @@
 	cout << "XapianDatabase::unlock: " << m_databaseName << endl;
 #endif
 	pthread_rwlock_unlock(&m_rwLock);
+
+	if (m_merge == true)
+	{
+		// Unlock the original indexes
+		if (m_pFirst != NULL)
+		{
+			m_pFirst->unlock();
+		}
+		if (m_pSecond != NULL)
+		{
+			m_pSecond->unlock();
+		}
+
+		// Delete merge
+		if (m_pDatabase != NULL)
+		{
+			delete m_pDatabase;
+			m_pDatabase = NULL;
+#ifdef DEBUG
+			cout << "XapianDatabase::unlock: deleted merge" << endl;
+#endif
+		}
+	}
 }
 
 /// Returns the URL for the given document in the given index.

Modified: trunk/Utils/XapianDatabase.h
===================================================================
--- trunk/Utils/XapianDatabase.h	2006-08-26 01:34:15 UTC (rev 421)
+++ trunk/Utils/XapianDatabase.h	2006-08-26 01:36:43 UTC (rev 422)
@@ -27,6 +27,8 @@
 {
 	public:
 		XapianDatabase(const std::string &databaseName, bool readOnly = true);
+		XapianDatabase(const std::string &databaseName,
+			XapianDatabase *pFirst, XapianDatabase *pSecond);
 		XapianDatabase(const XapianDatabase &other);
 		virtual ~XapianDatabase();
 
@@ -53,6 +55,9 @@
 		pthread_rwlock_t m_rwLock;
 		Xapian::Database *m_pDatabase;
 		bool m_isOpen;
+		bool m_merge;
+		XapianDatabase *m_pFirst;
+		XapianDatabase *m_pSecond;
 
 		void openDatabase(void);
 

Modified: trunk/Utils/XapianDatabaseFactory.cpp
===================================================================
--- trunk/Utils/XapianDatabaseFactory.cpp	2006-08-26 01:34:15 UTC (rev 421)
+++ trunk/Utils/XapianDatabaseFactory.cpp	2006-08-26 01:36:43 UTC (rev 422)
@@ -35,6 +35,33 @@
 {
 }
 
+/// Merges two databases together and add the result to the list.
+bool XapianDatabaseFactory::mergeDatabases(const string &name,
+	XapianDatabase *pFirst, XapianDatabase *pSecond)
+{
+	map<string, XapianDatabase *>::iterator dbIter = m_databases.find(name);
+	if (dbIter != m_databases.end())
+	{
+		return false;
+	}
+
+	// Create the new database
+	XapianDatabase *pDb = new XapianDatabase(name, pFirst, pSecond);
+
+	// Insert it into the map
+	pair<map<string, XapianDatabase *>::iterator, bool> insertPair = m_databases.insert(pair<string, XapianDatabase *>(name, pDb));
+	// Was it inserted ?
+	if (insertPair.second == false)
+	{
+		// No, it wasn't : delete the object
+		delete pDb;
+
+		return false;
+	}
+
+	return true;
+}
+
 /// Returns a XapianDatabase pointer; NULL if unavailable.
 XapianDatabase *XapianDatabaseFactory::getDatabase(const string &location, bool readOnly)
 {

Modified: trunk/Utils/XapianDatabaseFactory.h
===================================================================
--- trunk/Utils/XapianDatabaseFactory.h	2006-08-26 01:34:15 UTC (rev 421)
+++ trunk/Utils/XapianDatabaseFactory.h	2006-08-26 01:36:43 UTC (rev 422)
@@ -28,6 +28,10 @@
 	public:
 		virtual ~XapianDatabaseFactory();
 
+		/// Merges two databases together and add the result to the list.
+		static bool mergeDatabases(const std::string &name,
+			XapianDatabase *pFirst, XapianDatabase *pSecond);
+
 		/// Returns a XapianDatabase pointer; NULL if unavailable.
 		static XapianDatabase *getDatabase(const std::string &location, bool readOnly = true);
 



From fabricecolin at mail.berlios.de  Sat Aug 26 04:34:03 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 04:34:03 +0200
Subject: [Pinot-svn] r423 - in trunk: SQL Utils
Message-ID: <200608260234.k7Q2Y3Ip001236@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 04:33:52 +0200 (Sat, 26 Aug 2006)
New Revision: 423

Modified:
   trunk/SQL/SQLiteBase.cpp
   trunk/Utils/XapianDatabase.cpp
   trunk/Utils/XapianDatabaseFactory.cpp
Log:
Fewer DEBUG messages.


Modified: trunk/SQL/SQLiteBase.cpp
===================================================================
--- trunk/SQL/SQLiteBase.cpp	2006-08-26 01:36:43 UTC (rev 422)
+++ trunk/SQL/SQLiteBase.cpp	2006-08-26 02:33:52 UTC (rev 423)
@@ -198,9 +198,7 @@
 		cerr << "SQLiteBase::open: couldn't open " << database << endl;
 		pDatabase = NULL;
 	}
-#ifdef DEBUG
-	else cout << "SQLiteBase::open: opened " << database << endl;
-#endif
+
 	// Set up a busy handler
 	sqlite3_busy_handler(pDatabase, busyHandler, NULL);
 
@@ -212,12 +210,9 @@
 	if (pDatabase != NULL)
 	{
 #ifdef DEBUG
-		cout << "SQLiteBase::close: changed " << sqlite3_total_changes(pDatabase) << " rows" << endl;
+		cout << "SQLiteBase::close: changed " << sqlite3_total_changes(pDatabase) << " row(s)" << endl;
 #endif
 		sqlite3_close(pDatabase);
-#ifdef DEBUG
-		cout << "SQLiteBase::close: closed database" << endl;
-#endif
 	}
 }
 

Modified: trunk/Utils/XapianDatabase.cpp
===================================================================
--- trunk/Utils/XapianDatabase.cpp	2006-08-26 01:36:43 UTC (rev 422)
+++ trunk/Utils/XapianDatabase.cpp	2006-08-26 02:33:52 UTC (rev 423)
@@ -67,9 +67,6 @@
 	if (other.m_pDatabase != NULL)
 	{
 		m_pDatabase = new Xapian::Database(*other.m_pDatabase);
-#ifdef DEBUG
-		cout << "XapianDatabase: copied " << m_databaseName << endl;
-#endif
 	}
 }
 
@@ -78,9 +75,6 @@
 	if (m_pDatabase != NULL)
 	{
 		delete m_pDatabase;
-#ifdef DEBUG
-		cout << "XapianDatabase::~XapianDatabase:unlock: deleted" << endl;
-#endif
 	}
 	pthread_rwlock_destroy(&m_rwLock);
 }
@@ -93,16 +87,10 @@
 	{
 		delete m_pDatabase;
 		m_pDatabase = NULL;
-#ifdef DEBUG
-		cout << "XapianDatabase::operator=: deleted" << endl;
-#endif
 	}
 	if (other.m_pDatabase != NULL)
 	{
 		m_pDatabase = new Xapian::Database(*other.m_pDatabase);
-#ifdef DEBUG
-		cout << "XapianDatabase::operator=: copied " << m_databaseName << endl;
-#endif
 	}
 	m_isOpen = other.m_isOpen;
 	m_merge = other.m_merge;
@@ -128,9 +116,6 @@
 	{
 		delete m_pDatabase;
 		m_pDatabase = NULL;
-#ifdef DEBUG
-		cout << "XapianDatabase::openDatabase: deleted" << endl;
-#endif
 	}
 
 	// Is it a remote database ?
@@ -268,9 +253,6 @@
 				m_pDatabase->add_database(*pSecondDatabase);
 			}
 			// Until unlock() is called, both indexes are read locked
-#ifdef DEBUG
-			cout << "XapianDatabase::readLock: copied " << m_pFirst->m_databaseName << endl;
-#endif
 
 			return m_pDatabase;
 		}
@@ -332,9 +314,6 @@
 		{
 			delete m_pDatabase;
 			m_pDatabase = NULL;
-#ifdef DEBUG
-			cout << "XapianDatabase::unlock: deleted merge" << endl;
-#endif
 		}
 	}
 }

Modified: trunk/Utils/XapianDatabaseFactory.cpp
===================================================================
--- trunk/Utils/XapianDatabaseFactory.cpp	2006-08-26 01:36:43 UTC (rev 422)
+++ trunk/Utils/XapianDatabaseFactory.cpp	2006-08-26 02:33:52 UTC (rev 423)
@@ -81,17 +81,10 @@
 	map<string, XapianDatabase *>::iterator dbIter = m_databases.find(location);
 	if (dbIter != m_databases.end())
 	{
-#ifdef DEBUG
-		cout << "XapianDatabaseFactory::getDatabase: found " << location << endl;
-#endif
 		pDb = dbIter->second;
 	}
 	else
 	{
-#ifdef DEBUG
-		cout << "XapianDatabaseFactory::getDatabase: opening " << location
-			<< " in mode " << readOnly << endl;
-#endif
 		// Create a new instance
 		pDb = new XapianDatabase(location, readOnly);
 		// Insert it into the map



From fabricecolin at mail.berlios.de  Sat Aug 26 04:38:29 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 04:38:29 +0200
Subject: [Pinot-svn] r424 - trunk/Search
Message-ID: <200608260238.k7Q2cT5i002911@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 04:38:26 +0200 (Sat, 26 Aug 2006)
New Revision: 424

Modified:
   trunk/Search/AbstractGenerator.cpp
Log:
Don't fail if a term's position list cannot be found, it's to be expected if
the query's terms were OR'ed. And check the start position makes sense too !


Modified: trunk/Search/AbstractGenerator.cpp
===================================================================
--- trunk/Search/AbstractGenerator.cpp	2006-08-26 02:33:52 UTC (rev 423)
+++ trunk/Search/AbstractGenerator.cpp	2006-08-26 02:38:26 UTC (rev 424)
@@ -62,7 +62,7 @@
 	map<Xapian::termpos, PositionWindow> abstractWindows;
 	map<Xapian::termpos, string> wordsBuffer;
 	string summary;
-	Xapian::termpos bestPosition = 0, startPosition =0;
+	Xapian::termpos bestPosition = 0, startPosition = 0;
 	unsigned int seedTermsCount = 0, bestWeight = 0;
 	bool topTerm = true;
 
@@ -136,7 +136,7 @@
 #ifdef DEBUG
 			cout << "AbstractGenerator::generateAbstract: " << error.get_msg() << endl;
 #endif
-			return "";
+			continue;
 		}
 
 #ifdef DEBUG
@@ -153,7 +153,11 @@
 		if (bestWeight < winIter->second.m_backWeight)
 		{
 			bestPosition = winIter->first;
-			startPosition = bestPosition - m_wordsCount;
+			startPosition = 0;
+			if (bestPosition > m_wordsCount)
+			{
+				startPosition = bestPosition - m_wordsCount;
+			}
 			bestWeight = winIter->second.m_backWeight;
 		}
 		if (bestWeight < winIter->second.m_forwardWeight)



From fabricecolin at mail.berlios.de  Sat Aug 26 05:30:36 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 05:30:36 +0200
Subject: [Pinot-svn] r425 - trunk/Utils
Message-ID: <200608260330.k7Q3UanO024563@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 05:30:28 +0200 (Sat, 26 Aug 2006)
New Revision: 425

Modified:
   trunk/Utils/XapianDatabase.cpp
Log:
If opening a read-only database that doesn't exist, create it first instead of
failing miserably :-)


Modified: trunk/Utils/XapianDatabase.cpp
===================================================================
--- trunk/Utils/XapianDatabase.cpp	2006-08-26 02:38:26 UTC (rev 424)
+++ trunk/Utils/XapianDatabase.cpp	2006-08-26 03:30:28 UTC (rev 425)
@@ -103,6 +103,7 @@
 void XapianDatabase::openDatabase(void)
 {
 	struct stat dbStat;
+	bool createDatabase = false;
 
 	if (m_databaseName.empty() == true)
 	{
@@ -157,12 +158,10 @@
 	// It's a local database : the specified path must be a directory
 	if (stat(m_databaseName.c_str(), &dbStat) == -1)
 	{
-		if (m_readOnly == true)
-		{
-			cerr << "XapianDatabase::openDatabase: database " << m_databaseName
-				<< " doesn't exist" << endl;
-			return;
-		}
+#ifdef DEBUG
+		cout << "XapianDatabase::openDatabase: database " << m_databaseName
+			<< " doesn't exist" << endl;
+#endif
 
 		// Database directory doesn't exist, create it (mode 755)
 		if (mkdir(m_databaseName.c_str(), (mode_t)S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) != 0)
@@ -171,6 +170,7 @@
 				<< m_databaseName << endl;
 			return;
 		}
+		createDatabase = true;
 	}
 	else if (!S_ISDIR(dbStat.st_mode))
 	{
@@ -184,6 +184,14 @@
 	{
 		if (m_readOnly == true)
 		{
+			if (createDatabase == true)
+			{
+				// We have to create the whole thing in read-write mode first
+				Xapian::WritableDatabase *pTmpDatabase = new Xapian::WritableDatabase(m_databaseName, Xapian::DB_CREATE_OR_OPEN);
+				// ...then close and reopen in read-only mode
+				delete pTmpDatabase;
+			}
+
 			m_pDatabase = new Xapian::Database(m_databaseName);
 		}
 		else



From fabricecolin at mail.berlios.de  Sat Aug 26 05:32:06 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 05:32:06 +0200
Subject: [Pinot-svn] r426 - trunk/UI/GTK2/src
Message-ID: <200608260332.k7Q3W6dE024675@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 05:32:03 +0200 (Sat, 26 Aug 2006)
New Revision: 426

Modified:
   trunk/UI/GTK2/src/pinot.cc
Log:
Merge both index and daemon into one, this will be useful for terms suggestions
and More Like This.


Modified: trunk/UI/GTK2/src/pinot.cc
===================================================================
--- trunk/UI/GTK2/src/pinot.cc	2006-08-26 03:30:28 UTC (rev 425)
+++ trunk/UI/GTK2/src/pinot.cc	2006-08-26 03:32:03 UTC (rev 426)
@@ -190,23 +190,25 @@
 	sigaction(SIGQUIT, &newAction, NULL);
 
 	// Open this index read-write
-	XapianDatabase *pDb = XapianDatabaseFactory::getDatabase(settings.m_docsIndexLocation, false);
-	if ((pDb == NULL) ||
-		(pDb->isOpen() == false))
+	XapianDatabase *pFirstDb = XapianDatabaseFactory::getDatabase(settings.m_docsIndexLocation, false);
+	if ((pFirstDb == NULL) ||
+		(pFirstDb->isOpen() == false))
 	{
 		errorMsg = "Couldn't open index";
 		errorMsg += " ";
 		errorMsg += settings.m_docsIndexLocation;
 	}
 	// ...and the daemon index in read-only mode
-	pDb = XapianDatabaseFactory::getDatabase(settings.m_daemonIndexLocation);
-	if ((pDb == NULL) ||
-		(pDb->isOpen() == false))
+	XapianDatabase *pSecondDb = XapianDatabaseFactory::getDatabase(settings.m_daemonIndexLocation);
+	if ((pSecondDb == NULL) ||
+		(pSecondDb->isOpen() == false))
 	{
 		errorMsg = "Couldn't open index";
 		errorMsg += " ";
 		errorMsg += settings.m_daemonIndexLocation;
 	}
+	// Merge these two, this will be useful later
+	XapianDatabaseFactory::mergeDatabases("MERGED", pFirstDb, pSecondDb);
 
 	// Do the same for the history database
 	if ((settings.m_historyDatabase.empty() == true) ||



From fabricecolin at mail.berlios.de  Sat Aug 26 05:36:25 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 05:36:25 +0200
Subject: [Pinot-svn] r427 - trunk/UI/GTK2
Message-ID: <200608260336.k7Q3aP37027695@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 05:36:20 +0200 (Sat, 26 Aug 2006)
New Revision: 427

Modified:
   trunk/UI/GTK2/metase-gtk2.glade
Log:
Indexable locations are configured in the preferences box. Only URLs can be
imported now.


Modified: trunk/UI/GTK2/metase-gtk2.glade
===================================================================
--- trunk/UI/GTK2/metase-gtk2.glade	2006-08-26 03:32:03 UTC (rev 426)
+++ trunk/UI/GTK2/metase-gtk2.glade	2006-08-26 03:36:20 UTC (rev 427)
@@ -178,7 +178,7 @@
 			      <property name="visible">True</property>
 			      <property name="label" translatable="yes">Host Name</property>
 			      <property name="use_underline">True</property>
-			      <property name="active">False</property>
+			      <property name="active">True</property>
 			      <property name="group">searchenginegroup1</property>
 			    </widget>
 			  </child>
@@ -196,7 +196,7 @@
 		      <signal name="activate" handler="on_clearresults_activate" last_modification_time="Wed, 03 Mar 2004 19:51:48 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image603">
+			<widget class="GtkImage" id="image610">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-clear</property>
 			  <property name="icon_size">1</property>
@@ -243,7 +243,7 @@
 		      <signal name="activate" handler="on_morelikethis_activate" last_modification_time="Sun, 18 Jun 2006 10:50:56 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image604">
+			<widget class="GtkImage" id="image611">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-find</property>
 			  <property name="icon_size">1</property>
@@ -293,12 +293,12 @@
 		    <widget class="GtkImageMenuItem" id="import1">
 		      <property agent="glademm" name="cxx_visibility">protected</property>
 		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Import</property>
+		      <property name="label" translatable="yes">Import URL</property>
 		      <property name="use_underline">True</property>
 		      <signal name="activate" handler="on_import_activate" last_modification_time="Tue, 02 Mar 2004 22:13:44 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image605">
+			<widget class="GtkImage" id="image612">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-open</property>
 			  <property name="icon_size">1</property>
@@ -336,7 +336,7 @@
 		      <signal name="activate" handler="on_refreshindex_activate" last_modification_time="Fri, 20 Feb 2004 18:57:09 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image606">
+			<widget class="GtkImage" id="image613">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-refresh</property>
 			  <property name="icon_size">1</property>
@@ -358,7 +358,7 @@
 		      <signal name="activate" handler="on_unindex_activate" last_modification_time="Thu, 28 Jul 2005 12:42:23 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image607">
+			<widget class="GtkImage" id="image614">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-delete</property>
 			  <property name="icon_size">1</property>
@@ -380,7 +380,7 @@
 		      <signal name="activate" handler="on_showfromindex_activate" last_modification_time="Sun, 06 Nov 2005 08:43:05 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image608">
+			<widget class="GtkImage" id="image615">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-properties</property>
 			  <property name="icon_size">1</property>
@@ -1498,6 +1498,232 @@
 	  </child>
 
 	  <child>
+	    <widget class="GtkVBox" id="directoriesVbox">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkLabel" id="directoriesLabel">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">These directories will be monitored and indexed:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">True</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">4</property>
+		  <property name="ypad">4</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="padding">4</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHBox" id="directoriesHbox">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkScrolledWindow" id="directoriesScrolledwindow">
+		      <property name="border_width">4</property>
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="hscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		      <property name="vscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		      <property name="shadow_type">GTK_SHADOW_NONE</property>
+		      <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+
+		      <child>
+			<widget class="GtkTreeView" id="directoriesTreeview">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="headers_visible">True</property>
+			  <property name="rules_hint">False</property>
+			  <property name="reorderable">False</property>
+			  <property name="enable_search">True</property>
+			  <property name="fixed_height_mode">True</property>
+			  <property name="hover_selection">False</property>
+			  <property name="hover_expand">False</property>
+			  <signal name="button_press_event" handler="on_mailTreeview_button_press_event" last_modification_time="Sat, 19 Mar 2005 10:05:34 GMT"/>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkVButtonBox" id="directoriesVbuttonbox">
+		      <property name="visible">True</property>
+		      <property name="layout_style">GTK_BUTTONBOX_START</property>
+		      <property name="spacing">0</property>
+
+		      <child>
+			<widget class="GtkButton" id="addDirectoryButton">
+			  <property name="border_width">4</property>
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_default">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="relief">GTK_RELIEF_NORMAL</property>
+			  <property name="focus_on_click">True</property>
+			  <signal name="clicked" handler="on_addDirectoryButton_clicked" last_modification_time="Sun, 20 Aug 2006 07:33:34 GMT"/>
+
+			  <child>
+			    <widget class="GtkAlignment" id="alignment35">
+			      <property name="visible">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xscale">0</property>
+			      <property name="yscale">0</property>
+			      <property name="top_padding">0</property>
+			      <property name="bottom_padding">0</property>
+			      <property name="left_padding">0</property>
+			      <property name="right_padding">0</property>
+
+			      <child>
+				<widget class="GtkHBox" id="hbox54">
+				  <property name="visible">True</property>
+				  <property name="homogeneous">False</property>
+				  <property name="spacing">2</property>
+
+				  <child>
+				    <widget class="GtkImage" id="image609">
+				      <property name="visible">True</property>
+				      <property name="stock">gtk-add</property>
+				      <property name="icon_size">4</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkLabel" id="label58">
+				      <property name="visible">True</property>
+				      <property name="label" translatable="yes">Add</property>
+				      <property name="use_underline">True</property>
+				      <property name="use_markup">False</property>
+				      <property name="justify">GTK_JUSTIFY_LEFT</property>
+				      <property name="wrap">False</property>
+				      <property name="selectable">False</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				      <property name="width_chars">-1</property>
+				      <property name="single_line_mode">False</property>
+				      <property name="angle">0</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+				</widget>
+			      </child>
+			    </widget>
+			  </child>
+			</widget>
+		      </child>
+
+		      <child>
+			<widget class="GtkButton" id="editDirectoryButton">
+			  <property name="border_width">4</property>
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_default">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="label">gtk-edit</property>
+			  <property name="use_stock">True</property>
+			  <property name="relief">GTK_RELIEF_NORMAL</property>
+			  <property name="focus_on_click">True</property>
+			  <signal name="clicked" handler="on_editDirectoryButton_clicked" last_modification_time="Sun, 20 Aug 2006 07:34:03 GMT"/>
+			</widget>
+		      </child>
+
+		      <child>
+			<widget class="GtkButton" id="removeDirectoryButton">
+			  <property name="border_width">4</property>
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_default">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="label">gtk-remove</property>
+			  <property name="use_stock">True</property>
+			  <property name="relief">GTK_RELIEF_NORMAL</property>
+			  <property name="focus_on_click">True</property>
+			  <signal name="clicked" handler="on_removeDirectoryButton_clicked" last_modification_time="Sun, 20 Aug 2006 07:33:50 GMT"/>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">4</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="docsLabel">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">My Documents</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+
+	  <child>
 	    <widget class="GtkVBox" id="mailVbox">
 	      <property name="visible">True</property>
 	      <property name="homogeneous">False</property>
@@ -3140,7 +3366,7 @@
 </widget>
 
 <widget class="GtkDialog" id="importDialog">
-  <property name="title" translatable="yes">Import document</property>
+  <property name="title" translatable="yes">Import URL</property>
   <property name="type">GTK_WINDOW_TOPLEVEL</property>
   <property name="window_position">GTK_WIN_POS_NONE</property>
   <property name="modal">False</property>
@@ -3198,7 +3424,7 @@
 	    <widget class="GtkTable" id="docTable">
 	      <property agent="glademm" name="cxx_visibility">protected</property>
 	      <property name="visible">True</property>
-	      <property name="n_rows">6</property>
+	      <property name="n_rows">3</property>
 	      <property name="n_columns">2</property>
 	      <property name="homogeneous">False</property>
 	      <property name="row_spacing">0</property>
@@ -3220,8 +3446,8 @@
 		<packing>
 		  <property name="left_attach">1</property>
 		  <property name="right_attach">2</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">2</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
 		  <property name="x_padding">4</property>
 		  <property name="y_padding">4</property>
 		  <property name="y_options">fill</property>
@@ -3249,8 +3475,8 @@
 		<packing>
 		  <property name="left_attach">0</property>
 		  <property name="right_attach">1</property>
-		  <property name="top_attach">2</property>
-		  <property name="bottom_attach">3</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
 		  <property name="x_options">fill</property>
 		  <property name="y_options">fill</property>
 		</packing>
@@ -3278,27 +3504,25 @@
 		<packing>
 		  <property name="left_attach">0</property>
 		  <property name="right_attach">1</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">2</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
 		  <property name="x_options">fill</property>
 		  <property name="y_options">fill</property>
 		</packing>
 	      </child>
 
 	      <child>
-		<widget class="GtkComboBox" id="typeCombobox">
+		<widget class="GtkComboBox" id="labelNameCombobox">
 		  <property agent="glademm" name="cxx_visibility">protected</property>
 		  <property name="visible">True</property>
-		  <property name="items" translatable="yes"></property>
 		  <property name="add_tearoffs">False</property>
 		  <property name="focus_on_click">True</property>
-		  <signal name="changed" handler="on_typeCombobox_changed" last_modification_time="Sun, 18 Sep 2005 04:09:29 GMT"/>
 		</widget>
 		<packing>
 		  <property name="left_attach">1</property>
 		  <property name="right_attach">2</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
 		  <property name="x_padding">4</property>
 		  <property name="y_padding">4</property>
 		  <property name="y_options">fill</property>
@@ -3306,9 +3530,9 @@
 	      </child>
 
 	      <child>
-		<widget class="GtkLabel" id="typeLabel">
+		<widget class="GtkLabel" id="labelNameLabel">
 		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Type:</property>
+		  <property name="label" translatable="yes">Apply label:</property>
 		  <property name="use_underline">False</property>
 		  <property name="use_markup">False</property>
 		  <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -3326,220 +3550,37 @@
 		<packing>
 		  <property name="left_attach">0</property>
 		  <property name="right_attach">1</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options">fill</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkHBox" id="locationHbox">
-		  <property name="visible">True</property>
-		  <property name="homogeneous">False</property>
-		  <property name="spacing">4</property>
-
-		  <child>
-		    <widget class="GtkEntry" id="locationEntry">
-		      <property agent="glademm" name="cxx_visibility">protected</property>
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">True</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		      <signal name="changed" handler="on_locationEntry_changed" last_modification_time="Sun, 18 Sep 2005 03:55:37 GMT"/>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">True</property>
-		      <property name="fill">True</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="locationButton">
-		      <property agent="glademm" name="cxx_visibility">protected</property>
-		      <property name="visible">True</property>
-		      <property name="can_default">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="label" translatable="yes">...</property>
-		      <property name="use_underline">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <property name="focus_on_click">True</property>
-		      <signal name="clicked" handler="on_locationButton_clicked" last_modification_time="Wed, 04 Jan 2006 20:22:51 GMT"/>
-		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
-		  </child>
-		</widget>
-		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
 		  <property name="top_attach">2</property>
 		  <property name="bottom_attach">3</property>
-		  <property name="x_padding">4</property>
-		  <property name="y_padding">4</property>
 		  <property name="x_options">fill</property>
-		  <property name="y_options">fill</property>
+		  <property name="y_options"></property>
 		</packing>
 	      </child>
 
 	      <child>
-		<widget class="GtkSpinButton" id="depthSpinbutton">
+		<widget class="GtkEntry" id="locationEntry">
 		  <property agent="glademm" name="cxx_visibility">protected</property>
 		  <property name="visible">True</property>
 		  <property name="can_focus">True</property>
-		  <property name="climb_rate">1</property>
-		  <property name="digits">0</property>
-		  <property name="numeric">False</property>
-		  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
-		  <property name="snap_to_ticks">False</property>
-		  <property name="wrap">False</property>
-		  <property name="adjustment">0 0 100 1 5 5</property>
+		  <property name="editable">True</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		  <signal name="changed" handler="on_locationEntry_changed" last_modification_time="Sun, 18 Sep 2005 03:55:37 GMT"/>
 		</widget>
 		<packing>
 		  <property name="left_attach">1</property>
 		  <property name="right_attach">2</property>
-		  <property name="top_attach">3</property>
-		  <property name="bottom_attach">4</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
 		  <property name="x_padding">4</property>
 		  <property name="y_padding">4</property>
 		  <property name="y_options">fill</property>
 		</packing>
 	      </child>
-
-	      <child>
-		<widget class="GtkLabel" id="depthLabel">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Depth:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">4</property>
-		  <property name="ypad">4</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">3</property>
-		  <property name="bottom_attach">4</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options">fill</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkLabel" id="linksLabel">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Symlinks:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">4</property>
-		  <property name="ypad">4</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">4</property>
-		  <property name="bottom_attach">5</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options">fill</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkCheckButton" id="linksCheckbutton">
-		  <property agent="glademm" name="cxx_visibility">protected</property>
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="label" translatable="yes">Follow symlinks</property>
-		  <property name="use_underline">True</property>
-		  <property name="relief">GTK_RELIEF_NORMAL</property>
-		  <property name="focus_on_click">True</property>
-		  <property name="active">False</property>
-		  <property name="inconsistent">False</property>
-		  <property name="draw_indicator">True</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
-		  <property name="top_attach">4</property>
-		  <property name="bottom_attach">5</property>
-		  <property name="x_padding">4</property>
-		  <property name="y_padding">4</property>
-		  <property name="y_options">fill</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkComboBox" id="labelNameCombobox">
-		  <property agent="glademm" name="cxx_visibility">protected</property>
-		  <property name="visible">True</property>
-		  <property name="add_tearoffs">False</property>
-		  <property name="focus_on_click">True</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
-		  <property name="top_attach">5</property>
-		  <property name="bottom_attach">6</property>
-		  <property name="x_padding">4</property>
-		  <property name="y_padding">4</property>
-		  <property name="y_options">fill</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkLabel" id="labelNameLabel">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Apply label:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">4</property>
-		  <property name="ypad">4</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">5</property>
-		  <property name="bottom_attach">6</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
 	    </widget>
 	    <packing>
 	      <property name="padding">0</property>



From fabricecolin at mail.berlios.de  Sat Aug 26 05:38:09 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 05:38:09 +0200
Subject: [Pinot-svn] r428 - trunk/UI/GTK2/src
Message-ID: <200608260338.k7Q3c94S029590@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 05:38:08 +0200 (Sat, 26 Aug 2006)
New Revision: 428

Modified:
   trunk/UI/GTK2/src/importDialog.cc
   trunk/UI/GTK2/src/importDialog.hh
   trunk/UI/GTK2/src/importDialog_glade.cc
   trunk/UI/GTK2/src/importDialog_glade.hh
Log:
Simplified importing. Since the daemon takes care of local files, only URLs
can be imported into the index.


Modified: trunk/UI/GTK2/src/importDialog.cc
===================================================================
--- trunk/UI/GTK2/src/importDialog.cc	2006-08-26 03:36:20 UTC (rev 427)
+++ trunk/UI/GTK2/src/importDialog.cc	2006-08-26 03:38:08 UTC (rev 428)
@@ -37,8 +37,6 @@
 using namespace Glib;
 using namespace Gtk;
 
-string importDialog::InternalState::m_defaultDirectory = "";
-
 importDialog::InternalState::InternalState(unsigned int maxIndexThreads, importDialog *pWindow) :
 	ThreadsManager(PinotSettings::getInstance().m_docsIndexLocation, maxIndexThreads),
 	m_importing(false)
@@ -50,42 +48,18 @@
 {
 }
 
-importDialog::importDialog(const Glib::ustring &title) :
+importDialog::importDialog() :
 	importDialog_glade(),
-	m_pMonitor(MonitorFactory::getMonitor()),
 	m_docsCount(0),
-	m_importDirectory(false),
-	m_pScannerThread(NULL),
 	m_state(10, this)
 {
-	set_title(title);
-
-	// Initialize the default directory
-	if (m_state.m_defaultDirectory.empty() == true)
-	{
-		char *homeDir = getenv("HOME");
-		if (homeDir != NULL)
-		{
-			m_state.m_defaultDirectory = homeDir + string("/");
-		}
-	}
-
 	// Associate the columns model to the label combo
 	m_refLabelNameTree = ListStore::create(m_labelNameColumns);
 	labelNameCombobox->set_model(m_refLabelNameTree);
 	labelNameCombobox->pack_start(m_labelNameColumns.m_name);
-	// ...and to the type combo
-	m_refTypeList = ListStore::create(m_typeColumns);
-	typeCombobox->set_model(m_refTypeList);
-	typeCombobox->pack_start(m_typeColumns.m_name);
 	// Populate
-	populate_comboboxes(false);
+	populate_comboboxes();
 
-	// The default type is not directory
-	// FIXME: this could also apply to URLs !
-	depthSpinbutton->set_sensitive(false);
-	depthSpinbutton->set_value(1);
-
 	// Connect to threads' finished signal
 	m_state.connect();
 
@@ -98,32 +72,12 @@
 importDialog::~importDialog()
 {
 	m_state.disconnect();
-	if (m_pMonitor != NULL)
-	{
-		delete m_pMonitor;
-	}
 }
 
-void importDialog::populate_comboboxes(bool localOnly)
+void importDialog::populate_comboboxes(void)
 {
-	bool foundLanguage = false;
-
-	TreeModel::iterator iter = m_refTypeList->append();
+	TreeModel::iterator iter = m_refLabelNameTree->append();
 	TreeModel::Row row = *iter;
-	row[m_typeColumns.m_name] = _("File");
-	iter = m_refTypeList->append();
-	row = *iter;
-	row[m_typeColumns.m_name] = _("Directory");
-	if (localOnly == false)
-	{
-		iter = m_refTypeList->append();
-		row = *iter;
-		row[m_typeColumns.m_name] = _("URL");
-	}
-	typeCombobox->set_active(0);
-
-	iter = m_refLabelNameTree->append();
-	row = *iter;
 	row[m_labelNameColumns.m_name] = _("None");
 	labelNameCombobox->set_active(0);
 	// Add all labels
@@ -139,17 +93,6 @@
 	}
 }
 
-void importDialog::signal_scanner(void)
-{
-	// Ask the scanner for another file
-	m_state.m_scanMutex.lock();
-	m_state.m_scanCondVar.signal();
-	m_state.m_scanMutex.unlock();
-#ifdef DEBUG
-	cout << "importDialog::signal_scanner: signaled" << endl;
-#endif
-}
-
 bool importDialog::on_activity_timeout(void)
 {
 	importProgressbar->pulse();
@@ -157,41 +100,14 @@
 	return true;
 }
 
-bool importDialog::on_import_url(const string &location, const string &sourceLabel)
+void importDialog::import_url(const string &location)
 {
-	WritableIndexInterface *pIndex = PinotSettings::getInstance().getRWIndex(PinotSettings::getInstance().m_docsIndexLocation);
 	Url urlObj(location);
 	set<string> labels;
 	string title(from_utf8(m_title));
 
-	if (pIndex != NULL)
-	{
-		unsigned int docId = pIndex->hasDocument(location);
-
-		// if the document exists, get its labels list
-		if (docId > 0)
-		{
-			pIndex->getDocumentLabels(docId, labels);
-		}
-	}
-	labels.insert(m_labelName);
-	labels.insert(sourceLabel);
-
-	if (m_importDirectory == true)
-	{
-		if (title.empty() == false)
-		{
-			title += " ";
-		}
-		title += urlObj.getFile();
-	}
-
-	DocumentInfo docInfo(title, location, MIMEScanner::scanUrl(urlObj), "");
-	docInfo.setLabels(labels);
-
+   DocumentInfo docInfo(title, location, MIMEScanner::scanUrl(urlObj), "");
 	m_state.queue_index(docInfo);
-
-	return false;
 }
 
 void importDialog::on_thread_end(WorkerThread *pThread)
@@ -225,29 +141,14 @@
 
 	// What type of thread was it ?
 	string type = pThread->getType();
-	if (type == "DirectoryScannerThread")
+	if (type == "IndexingThread")
 	{
-		if (m_pScannerThread == dynamic_cast<DirectoryScannerThread *>(pThread))
-		{
-#ifdef DEBUG
-			cout << "importDialog::on_thread_end: reset scanner" << endl;
-#endif
-			m_pScannerThread = NULL;
-		}
-	}
-	else if (type == "IndexingThread")
-	{
 		// Did it succeed ?
 		if (success == true)
 		{
 			// Yes, it did
 			++m_docsCount;
 		}
-
-		if (m_state.m_importing == true)
-		{
-			signal_scanner();
-		}
 	}
 
 	// Delete the thread
@@ -278,59 +179,21 @@
 	return m_docsCount;
 }
 
-void importDialog::on_typeCombobox_changed()
-{
-	unsigned int type = typeCombobox->get_active_row_number();
-	bool selectLocation = true;
-
-	m_importDirectory = false;
-	if (type == 1)
-	{
-		m_importDirectory = true;
-	}
-	else if (type > 1)
-	{
-		// Disable the select button only if type is URL
-		selectLocation = false;
-	}
-
-	// See whether import should be enabled
-	on_locationEntry_changed();
-
-	// FIXME: this could also apply to URLs !
-	depthSpinbutton->set_sensitive(m_importDirectory);
-	locationButton->set_sensitive(selectLocation);
-	linksCheckbutton->set_sensitive(selectLocation);
-}
-
 void importDialog::on_locationEntry_changed()
 {
-	ustring fileName = locationEntry->get_text();
+	ustring fileName = from_utf8(locationEntry->get_text());
 	bool enableImport = true;
 
 	if (fileName.empty() == false)
 	{
-		unsigned int type = typeCombobox->get_active_row_number();
+		Url urlObj(fileName);
 
-		// Check the entry makes sense
-		if (type <= 1)
+		// Check the URL is valid
+		if (urlObj.getProtocol().empty() == true)
 		{
-			if (fileName[0] != '/')
-			{
-				enableImport = false;
-			}
+			enableImport = false;
 		}
-		else
-		{
-			Url urlObj(from_utf8(fileName));
-
-			// Check the URL is valid
-			if (urlObj.getProtocol().empty() == true)
-			{
-				enableImport = false;
-			}
-			// FIXME: be more thorough
-		}
+		// FIXME: be more thorough
 	}
 	else
 	{
@@ -345,30 +208,6 @@
 	importButton->set_sensitive(enableImport);
 }
 
-void importDialog::on_locationButton_clicked()
-{
-	ustring fileName = to_utf8(m_state.m_defaultDirectory);
-
-	if (select_file_name(*this, _("Document To Import"), fileName, true, m_importDirectory) == true)
-	{
-		// Update the location
-#ifdef DEBUG
-		cout << "importDialog::on_locationButton_clicked: location is " << fileName << endl;
-#endif
-		locationEntry->set_text(fileName);
-		ustring::size_type pos = fileName.find_last_of("/");
-		if (pos != string::npos)
-		{
-			// Update the default directory
-			m_state.m_defaultDirectory = from_utf8(fileName.substr(0, pos + 1));
-#ifdef DEBUG
-			cout << "importDialog::on_locationButton_clicked: directory now "
-				<< m_state.m_defaultDirectory << endl;
-#endif
-		}
-	}
-}
-
 void importDialog::on_importButton_clicked()
 {
 	string location = from_utf8(locationEntry->get_text());
@@ -399,31 +238,9 @@
 		TreeModel::Row row = *iter;
 		m_labelName = from_utf8(row[m_labelNameColumns.m_name]);
 	}
-	// Type
-	if (typeCombobox->get_active_row_number() <= 1)
-	{
-		// Maximum depth
-		unsigned int maxDirLevel = (unsigned int)depthSpinbutton->get_value();
 
-		// Scan the directory and import all its files
-		m_pScannerThread = new DirectoryScannerThread(m_pMonitor,
-			location, maxDirLevel, linksCheckbutton->get_active(),
-			&m_state.m_scanMutex, &m_state.m_scanCondVar);
-		m_pScannerThread->getFileFoundSignal().connect(SigC::slot(*this, &importDialog::on_import_url));
-		m_state.start_thread(m_pScannerThread);
-	}
-	else
-	{
-		if (on_import_url(location, "") == true)
-		{
-			// It's asking for another file, so this one couldn't be indexed
-			m_timeoutConnection.block();
-			m_timeoutConnection.disconnect();
+	import_url(location);
 
-			importProgressbar->set_fraction(0.0);
-			importButton->set_sensitive(true);
-		}
-	}
 #ifdef DEBUG
 	cout << "importDialog::on_importButton_clicked: done" << endl;
 #endif
@@ -439,10 +256,5 @@
 
 	// Closing the window should stop everything
 	m_state.disconnect();
-	if (m_pScannerThread != NULL)
-	{
-		m_pScannerThread->stop();
-		signal_scanner();
-	}
 	m_state.stop_threads();
 }

Modified: trunk/UI/GTK2/src/importDialog.hh
===================================================================
--- trunk/UI/GTK2/src/importDialog.hh	2006-08-26 03:36:20 UTC (rev 427)
+++ trunk/UI/GTK2/src/importDialog.hh	2006-08-26 03:38:08 UTC (rev 428)
@@ -35,8 +35,7 @@
 class importDialog : public importDialog_glade
 {  
 public:
-	/// Open the dialog box in import mode.
-	importDialog(const Glib::ustring &title);
+	importDialog();
 	virtual ~importDialog();
 
 	void setHeight(int maxHeight);
@@ -44,27 +43,19 @@
 	unsigned int getDocumentsCount(void);
 
 protected:
-	void populate_comboboxes(bool localOnly);
-	void signal_scanner(void);
+	void populate_comboboxes(void);
 
 	bool on_activity_timeout(void);
-	bool on_import_url(const std::string &location, const std::string &sourceLabel);
+	void import_url(const std::string &location);
 	void on_thread_end(WorkerThread *pThread);
 
 private:
-	MonitorInterface *m_pMonitor;
-	// Type
-	ComboModelColumns m_typeColumns;
-	Glib::RefPtr<Gtk::ListStore> m_refTypeList;
 	// Label
 	ComboModelColumns m_labelNameColumns;
 	Glib::RefPtr<Gtk::ListStore> m_refLabelNameTree;
 	Glib::ustring m_title;
 	std::string m_labelName;
 	unsigned int m_docsCount;
-	bool m_importDirectory;
-	// Directory scanner
-	DirectoryScannerThread *m_pScannerThread;
 	// Activity timeout
 	SigC::Connection m_timeoutConnection;
 	// Internal state
@@ -74,18 +65,11 @@
 			InternalState(unsigned int maxIndexThreads, importDialog *pWindow);
 			~InternalState();
 
-			// Directory scanning
 			bool m_importing;
-			Glib::Mutex m_scanMutex;
-			Glib::Cond m_scanCondVar;
-			// The default directory
-			static std::string m_defaultDirectory;
 
 	} m_state;
 
-	virtual void on_typeCombobox_changed();
 	virtual void on_locationEntry_changed();
-	virtual void on_locationButton_clicked();
 	virtual void on_importButton_clicked();
 	virtual void on_importDialog_response(int response_id);
 

Modified: trunk/UI/GTK2/src/importDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/importDialog_glade.cc	2006-08-26 03:36:20 UTC (rev 427)
+++ trunk/UI/GTK2/src/importDialog_glade.cc	2006-08-26 03:38:08 UTC (rev 428)
@@ -1,9 +1,9 @@
-// generated 2006/5/27 14:34:17 SGT by fabrice at amra.dyndns.org.(none)
+// generated 2006/8/20 15:34:18 SGT by fabrice at amra.dyndns.org.(none)
 // using glademm V2.12.1
 //
 // DO NOT EDIT THIS FILE ! It was created using
 // glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
-// for gtk 2.8.17 and gtkmm 2.8.3
+// for gtk 2.8.20 and gtkmm 2.8.8
 //
 // Please modify the corresponding derived classes in ./src/importDialog.cc
 
@@ -40,9 +40,8 @@
 #include <gtkmm/button.h>
 #include <gtkmm/buttonbox.h>
 #include <gtkmm/label.h>
-#include <gtkmm/box.h>
-#include <gtkmm/adjustment.h>
 #include <gtkmm/image.h>
+#include <gtkmm/box.h>
 #include <gtkmm/alignment.h>
 #ifndef ENABLE_NLS
 #  define textdomain(String) (String)
@@ -67,22 +66,10 @@
    
    Gtk::Label *locationLabel = Gtk::manage(new class Gtk::Label(_("Location:")));
    titleLabel = Gtk::manage(new class Gtk::Label(_("Title:")));
-   typeCombobox = Gtk::manage(new class Gtk::ComboBox());
-   
-   Gtk::Label *typeLabel = Gtk::manage(new class Gtk::Label(_("Type:")));
-   locationEntry = Gtk::manage(new class Gtk::Entry());
-   locationButton = Gtk::manage(new class Gtk::Button(_("...")));
-   
-   Gtk::HBox *locationHbox = Gtk::manage(new class Gtk::HBox(false, 4));
-   Gtk::Adjustment *depthSpinbutton_adj = Gtk::manage(new class Gtk::Adjustment(0, 0, 100, 1, 5, 5));
-   depthSpinbutton = Gtk::manage(new class Gtk::SpinButton(*depthSpinbutton_adj, 1, 0));
-   
-   Gtk::Label *depthLabel = Gtk::manage(new class Gtk::Label(_("Depth:")));
-   Gtk::Label *linksLabel = Gtk::manage(new class Gtk::Label(_("Symlinks:")));
-   linksCheckbutton = Gtk::manage(new class Gtk::CheckButton(_("Follow symlinks")));
    labelNameCombobox = Gtk::manage(new class Gtk::ComboBox());
    
    Gtk::Label *labelNameLabel = Gtk::manage(new class Gtk::Label(_("Apply label:")));
+   locationEntry = Gtk::manage(new class Gtk::Entry());
    docTable = Gtk::manage(new class Gtk::Table(2, 2, false));
    importProgressbar = Gtk::manage(new class Gtk::ProgressBar());
    
@@ -116,64 +103,26 @@
    titleLabel->set_line_wrap(false);
    titleLabel->set_use_markup(false);
    titleLabel->set_selectable(false);
-   typeLabel->set_alignment(0,0.5);
-   typeLabel->set_padding(4,4);
-   typeLabel->set_justify(Gtk::JUSTIFY_LEFT);
-   typeLabel->set_line_wrap(false);
-   typeLabel->set_use_markup(false);
-   typeLabel->set_selectable(false);
-   locationEntry->set_flags(Gtk::CAN_FOCUS);
-   locationEntry->set_visibility(true);
-   locationEntry->set_editable(true);
-   locationEntry->set_max_length(0);
-   locationEntry->set_has_frame(true);
-   locationEntry->set_activates_default(false);
-   locationButton->set_flags(Gtk::CAN_FOCUS);
-   locationButton->set_flags(Gtk::CAN_DEFAULT);
-   locationButton->set_relief(Gtk::RELIEF_NORMAL);
-   locationHbox->pack_start(*locationEntry);
-   locationHbox->pack_start(*locationButton, Gtk::PACK_SHRINK, 0);
-   depthSpinbutton->set_flags(Gtk::CAN_FOCUS);
-   depthSpinbutton->set_update_policy(Gtk::UPDATE_ALWAYS);
-   depthSpinbutton->set_numeric(false);
-   depthSpinbutton->set_digits(0);
-   depthSpinbutton->set_wrap(false);
-   depthLabel->set_alignment(0,0.5);
-   depthLabel->set_padding(4,4);
-   depthLabel->set_justify(Gtk::JUSTIFY_LEFT);
-   depthLabel->set_line_wrap(false);
-   depthLabel->set_use_markup(false);
-   depthLabel->set_selectable(false);
-   linksLabel->set_alignment(0,0.5);
-   linksLabel->set_padding(4,4);
-   linksLabel->set_justify(Gtk::JUSTIFY_LEFT);
-   linksLabel->set_line_wrap(false);
-   linksLabel->set_use_markup(false);
-   linksLabel->set_selectable(false);
-   linksCheckbutton->set_flags(Gtk::CAN_FOCUS);
-   linksCheckbutton->set_relief(Gtk::RELIEF_NORMAL);
-   linksCheckbutton->set_mode(true);
-   linksCheckbutton->set_active(false);
    labelNameLabel->set_alignment(0,0.5);
    labelNameLabel->set_padding(4,4);
    labelNameLabel->set_justify(Gtk::JUSTIFY_LEFT);
    labelNameLabel->set_line_wrap(false);
    labelNameLabel->set_use_markup(false);
    labelNameLabel->set_selectable(false);
+   locationEntry->set_flags(Gtk::CAN_FOCUS);
+   locationEntry->set_visibility(true);
+   locationEntry->set_editable(true);
+   locationEntry->set_max_length(0);
+   locationEntry->set_has_frame(true);
+   locationEntry->set_activates_default(false);
    docTable->set_row_spacings(0);
    docTable->set_col_spacings(0);
-   docTable->attach(*titleEntry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
-   docTable->attach(*locationLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
-   docTable->attach(*titleLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
-   docTable->attach(*typeCombobox, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
-   docTable->attach(*typeLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
-   docTable->attach(*locationHbox, 1, 2, 2, 3, Gtk::FILL, Gtk::FILL, 4, 4);
-   docTable->attach(*depthSpinbutton, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
-   docTable->attach(*depthLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
-   docTable->attach(*linksLabel, 0, 1, 4, 5, Gtk::FILL, Gtk::FILL, 0, 0);
-   docTable->attach(*linksCheckbutton, 1, 2, 4, 5, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
-   docTable->attach(*labelNameCombobox, 1, 2, 5, 6, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
-   docTable->attach(*labelNameLabel, 0, 1, 5, 6, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
+   docTable->attach(*titleEntry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   docTable->attach(*locationLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   docTable->attach(*titleLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   docTable->attach(*labelNameCombobox, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   docTable->attach(*labelNameLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
+   docTable->attach(*locationEntry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
    image575->set_alignment(0.5,0.5);
    image575->set_padding(0,0);
    label55->set_alignment(0.5,0.5);
@@ -196,7 +145,7 @@
    importDialog->get_vbox()->set_homogeneous(false);
    importDialog->get_vbox()->set_spacing(0);
    importDialog->get_vbox()->pack_start(*importVbox);
-   importDialog->set_title(_("Import document"));
+   importDialog->set_title(_("Import URL"));
    importDialog->set_modal(false);
    importDialog->property_window_position().set_value(Gtk::WIN_POS_NONE);
    importDialog->set_resizable(true);
@@ -207,17 +156,9 @@
    titleEntry->show();
    locationLabel->show();
    titleLabel->show();
-   typeCombobox->show();
-   typeLabel->show();
-   locationEntry->show();
-   locationButton->show();
-   locationHbox->show();
-   depthSpinbutton->show();
-   depthLabel->show();
-   linksLabel->show();
-   linksCheckbutton->show();
    labelNameCombobox->show();
    labelNameLabel->show();
+   locationEntry->show();
    docTable->show();
    importProgressbar->show();
    image575->show();
@@ -227,9 +168,7 @@
    importButton->show();
    importHbox->show();
    importVbox->show();
-   typeCombobox->signal_changed().connect(SigC::slot(*this, &importDialog_glade::on_typeCombobox_changed), false);
    locationEntry->signal_changed().connect(SigC::slot(*this, &importDialog_glade::on_locationEntry_changed), false);
-   locationButton->signal_clicked().connect(SigC::slot(*this, &importDialog_glade::on_locationButton_clicked), false);
    importButton->signal_clicked().connect(SigC::slot(*this, &importDialog_glade::on_importButton_clicked), false);
    importDialog->signal_response().connect(SigC::slot(*this, &importDialog_glade::on_importDialog_response), false);
 }

Modified: trunk/UI/GTK2/src/importDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/importDialog_glade.hh	2006-08-26 03:36:20 UTC (rev 427)
+++ trunk/UI/GTK2/src/importDialog_glade.hh	2006-08-26 03:38:08 UTC (rev 428)
@@ -1,9 +1,9 @@
-// generated 2006/5/27 14:34:17 SGT by fabrice at amra.dyndns.org.(none)
+// generated 2006/8/20 15:32:26 SGT by fabrice at amra.dyndns.org.(none)
 // using glademm V2.12.1
 //
 // DO NOT EDIT THIS FILE ! It was created using
 // glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
-// for gtk 2.8.17 and gtkmm 2.8.3
+// for gtk 2.8.20 and gtkmm 2.8.8
 //
 // Please modify the corresponding derived classes in ./src/importDialog.hh and./src/importDialog.cc
 
@@ -35,11 +35,9 @@
 #include <gtkmm/entry.h>
 #include <gtkmm/label.h>
 #include <gtkmm/combobox.h>
-#include <gtkmm/button.h>
-#include <gtkmm/spinbutton.h>
-#include <gtkmm/checkbutton.h>
 #include <gtkmm/table.h>
 #include <gtkmm/progressbar.h>
+#include <gtkmm/button.h>
 
 class importDialog_glade : public Gtk::Dialog
 {  
@@ -48,12 +46,8 @@
 protected:
         class Gtk::Entry * titleEntry;
         class Gtk::Label * titleLabel;
-        class Gtk::ComboBox * typeCombobox;
-        class Gtk::Entry * locationEntry;
-        class Gtk::Button * locationButton;
-        class Gtk::SpinButton * depthSpinbutton;
-        class Gtk::CheckButton * linksCheckbutton;
         class Gtk::ComboBox * labelNameCombobox;
+        class Gtk::Entry * locationEntry;
         class Gtk::Table * docTable;
         class Gtk::ProgressBar * importProgressbar;
         class Gtk::Button * importButton;
@@ -62,9 +56,7 @@
         
         ~importDialog_glade();
 private:
-        virtual void on_typeCombobox_changed() = 0;
         virtual void on_locationEntry_changed() = 0;
-        virtual void on_locationButton_clicked() = 0;
         virtual void on_importButton_clicked() = 0;
         virtual void on_importDialog_response(int response_id) = 0;
 };



From fabricecolin at mail.berlios.de  Sat Aug 26 05:39:37 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 05:39:37 +0200
Subject: [Pinot-svn] r429 - trunk/UI/GTK2/src
Message-ID: <200608260339.k7Q3dbOk030877@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 05:39:36 +0200 (Sat, 26 Aug 2006)
New Revision: 429

Modified:
   trunk/UI/GTK2/src/ModelColumns.cpp
   trunk/UI/GTK2/src/ModelColumns.h
Log:
Renamed MailAccountModelColumns to TimestampedModelColumns.


Modified: trunk/UI/GTK2/src/ModelColumns.cpp
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.cpp	2006-08-26 03:38:08 UTC (rev 428)
+++ trunk/UI/GTK2/src/ModelColumns.cpp	2006-08-26 03:39:36 UTC (rev 429)
@@ -105,13 +105,13 @@
 {
 }
 
-MailAccountModelColumns::MailAccountModelColumns()
+TimestampedModelColumns::TimestampedModelColumns()
 {
 	add(m_location);
 	add(m_mTime);
 }
 
-MailAccountModelColumns::~MailAccountModelColumns()
+TimestampedModelColumns::~TimestampedModelColumns()
 {
 }
 

Modified: trunk/UI/GTK2/src/ModelColumns.h
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.h	2006-08-26 03:38:08 UTC (rev 428)
+++ trunk/UI/GTK2/src/ModelColumns.h	2006-08-26 03:39:36 UTC (rev 429)
@@ -132,12 +132,12 @@
 
 };
 
-/// Preferences window, model column for the mail accounts tree.
-class MailAccountModelColumns : public Gtk::TreeModel::ColumnRecord
+/// Preferences window, model column for the directories and mail accounts trees.
+class TimestampedModelColumns : public Gtk::TreeModel::ColumnRecord
 {
 public:
-	MailAccountModelColumns();
-	virtual ~MailAccountModelColumns();
+	TimestampedModelColumns();
+	virtual ~TimestampedModelColumns();
 
 	Gtk::TreeModelColumn<Glib::ustring> m_location;
 	Gtk::TreeModelColumn<time_t> m_mTime;



From fabricecolin at mail.berlios.de  Sat Aug 26 05:41:11 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 05:41:11 +0200
Subject: [Pinot-svn] r430 - trunk/UI/GTK2/src
Message-ID: <200608260341.k7Q3fBvo031934@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 05:41:09 +0200 (Sat, 26 Aug 2006)
New Revision: 430

Modified:
   trunk/UI/GTK2/src/prefsDialog.cc
   trunk/UI/GTK2/src/prefsDialog.hh
   trunk/UI/GTK2/src/prefsDialog_glade.cc
   trunk/UI/GTK2/src/prefsDialog_glade.hh
Log:
Manage the list of indexable locations.


Modified: trunk/UI/GTK2/src/prefsDialog.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.cc	2006-08-26 03:39:36 UTC (rev 429)
+++ trunk/UI/GTK2/src/prefsDialog.cc	2006-08-26 03:41:09 UTC (rev 430)
@@ -35,8 +35,6 @@
 using namespace Gdk;
 using namespace Gtk;
 
-unsigned int prefsDialog::m_maxDirLevel = 1;
-
 prefsDialog::prefsDialog() :
 	prefsDialog_glade(),
 	m_settings(PinotSettings::getInstance())
@@ -68,6 +66,14 @@
 	labelsTreeview->get_selection()->set_mode(SELECTION_SINGLE);
 	populate_labelsTreeview();
 
+	// Associate the columns model to the directories tree
+	m_refDirectoriesTree = ListStore::create(m_directoriesColumns);
+	directoriesTreeview->set_model(m_refDirectoriesTree);
+	directoriesTreeview->append_column(_("Location"), m_directoriesColumns.m_location);
+	// Allow only single selection
+	directoriesTreeview->get_selection()->set_mode(SELECTION_SINGLE);
+	populate_directoriesTreeview();
+
 	// Associate the columns model to the mail accounts tree
 	m_refMailTree = ListStore::create(m_mailColumns);
 	mailTreeview->set_model(m_refMailTree);
@@ -98,11 +104,6 @@
 	return m_renamedLabels;
 }
 
-const set<string> &prefsDialog::getMailLabelsToDelete(void) const
-{
-	return m_deletedMail;
-}
-
 void prefsDialog::populate_labelsTreeview()
 {
 	TreeModel::iterator iter;
@@ -175,6 +176,75 @@
 	return true;
 }
 
+void prefsDialog::populate_directoriesTreeview()
+{
+	TreeModel::iterator iter;
+	TreeModel::Row row;
+
+	if (m_settings.m_indexableLocations.empty() == true)
+	{
+		// These buttons will stay disabled until directories are added to the list
+		editDirectoryButton->set_sensitive(false);
+		removeDirectoryButton->set_sensitive(false);
+		return;
+	}
+
+	// Populate the tree
+	for (set<PinotSettings::TimestampedItem>::iterator dirIter = m_settings.m_indexableLocations.begin();
+		dirIter != m_settings.m_indexableLocations.end();
+		++dirIter)
+	{
+		// Create a new row
+		iter = m_refDirectoriesTree->append();
+		row = *iter;
+		// Set its name, type and minium date
+		row[m_directoriesColumns.m_location] = dirIter->m_name;
+		row[m_directoriesColumns.m_mTime] = dirIter->m_modTime;
+	}
+
+	editDirectoryButton->set_sensitive(true);
+	removeDirectoryButton->set_sensitive(true);
+}
+
+bool prefsDialog::save_directoriesTreeview()
+{
+	// Clear the current settings
+	m_settings.m_indexableLocations.clear();
+
+	// Go through the directories tree
+	TreeModel::Children children = m_refDirectoriesTree->children();
+	if (children.empty() == false)
+	{
+		TreeModel::Children::iterator iter = children.begin();
+		for (; iter != children.end(); ++iter)
+		{
+			TreeModel::Row row = *iter;
+			PinotSettings::TimestampedItem indexableLocation;
+
+			// Add this new directory to the settings
+			indexableLocation.m_name = row[m_directoriesColumns.m_location];
+			indexableLocation.m_modTime = row[m_directoriesColumns.m_mTime];
+
+			string dirLabel("file://");
+			dirLabel += from_utf8(indexableLocation.m_name);
+
+			// Check user didn't recreate this directory after having deleted it
+			set<string>::iterator dirIter = m_deletedDirectories.find(dirLabel);
+			if (dirIter != m_deletedDirectories.end())
+			{
+				m_deletedDirectories.erase(dirIter);
+			}
+
+#ifdef DEBUG
+			cout << "prefsDialog::save_directoriesTreeview: " << indexableLocation.m_name << endl;
+#endif
+			m_settings.m_indexableLocations.insert(indexableLocation);
+		}
+	}
+
+	return true;
+}
+
 void prefsDialog::populate_mailTreeview()
 {
 	TreeModel::iterator iter;
@@ -182,7 +252,7 @@
 
 	if (m_settings.m_mailAccounts.empty() == true)
 	{
-		// These buttons will stay disabled until labels are added to the list
+		// These buttons will stay disabled until mail is added to the list
 		editAccountButton->set_sensitive(false);
 		removeAccountButton->set_sensitive(false);
 		return;
@@ -312,6 +382,82 @@
 	return false;
 }
 
+void prefsDialog::on_addDirectoryButton_clicked()
+{
+	ustring dirName;
+
+	TreeModel::Children children = m_refDirectoriesTree->children();
+	bool wasEmpty = children.empty();
+
+	if (select_file_name(*this, _("Directory to index"), dirName, true, true) == true)
+	{
+#ifdef DEBUG
+		cout << "prefsDialog::on_addDirectoryButton_clicked: "
+			<< dirName << endl;
+#endif
+		// Create a new entry in the directories list
+		TreeModel::iterator iter = m_refDirectoriesTree->append();
+		TreeModel::Row row = *iter;
+	
+		row[m_directoriesColumns.m_location] = to_utf8(dirName);
+		row[m_directoriesColumns.m_mTime] = time(NULL);
+
+		if (wasEmpty == true)
+		{
+			// Enable these buttons
+			editDirectoryButton->set_sensitive(true);
+			removeDirectoryButton->set_sensitive(true);
+		}
+	}
+}
+
+void prefsDialog::on_editDirectoryButton_clicked()
+{
+	// Get the selected directory in the list
+	TreeModel::iterator iter = directoriesTreeview->get_selection()->get_selected();
+	if (iter)
+	{
+		TreeModel::Row row = *iter;
+		ustring dirName = row[m_directoriesColumns.m_location];
+		// Let the user edit the location
+		if (select_file_name(*this, _("Directory to index"), dirName, true, true) == true)
+		{
+			row[m_directoriesColumns.m_location] = dirName;
+		}
+	}
+}
+
+void prefsDialog::on_removeDirectoryButton_clicked()
+{
+	// Get the selected directory in the list
+	TreeModel::iterator iter = directoriesTreeview->get_selection()->get_selected();
+	if (iter)
+	{
+		string dirLabel("file://");
+
+		// Unselect
+		directoriesTreeview->get_selection()->unselect(iter);
+		// Select another row
+		TreeModel::Path path = m_refDirectoriesTree->get_path(iter);
+		path.next();
+		directoriesTreeview->get_selection()->select(path);
+
+		// Erase
+		TreeModel::Row row = *iter;
+		dirLabel += from_utf8(row[m_directoriesColumns.m_location]);
+		m_deletedDirectories.insert(dirLabel);
+		m_refDirectoriesTree->erase(row);
+
+		TreeModel::Children children = m_refDirectoriesTree->children();
+		if (children.empty() == true)
+		{
+			// Disable these buttons
+			editDirectoryButton->set_sensitive(false);
+			removeDirectoryButton->set_sensitive(false);
+		}
+	}
+}
+
 void prefsDialog::on_addAccountButton_clicked()
 {
 	ustring fileName;

Modified: trunk/UI/GTK2/src/prefsDialog.hh
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.hh	2006-08-26 03:39:36 UTC (rev 429)
+++ trunk/UI/GTK2/src/prefsDialog.hh	2006-08-26 03:41:09 UTC (rev 430)
@@ -38,19 +38,22 @@
 
 	const std::map<std::string, std::string> &getLabelsToRename(void) const;
 
-	const std::set<std::string> &getMailLabelsToDelete(void) const;
-
 protected:
 	virtual void on_prefsOkbutton_clicked();
 	virtual void on_addLabelButton_clicked();
 	virtual void on_removeLabelButton_clicked();
 	virtual bool on_mailTreeview_button_press_event(GdkEventButton *ev);
+	virtual void on_addDirectoryButton_clicked();
+	virtual void on_editDirectoryButton_clicked();
+	virtual void on_removeDirectoryButton_clicked();
 	virtual void on_addAccountButton_clicked();
 	virtual void on_editAccountButton_clicked();
 	virtual void on_removeAccountButton_clicked();
 
 	void populate_labelsTreeview();
 	bool save_labelsTreeview();
+	void populate_directoriesTreeview();
+	bool save_directoriesTreeview();
 	void populate_mailTreeview();
 	bool save_mailTreeview();
 
@@ -58,16 +61,16 @@
 	PinotSettings &m_settings;
 	ComboModelColumns m_viewColumns;
 	Glib::RefPtr<Gtk::ListStore> m_refViewTree;
-	OtherIndexModelColumns m_otherIndexColumns;
-	Glib::RefPtr<Gtk::ListStore> m_refOtherIndexTree;
 	LabelModelColumns m_labelsColumns;
 	Glib::RefPtr<Gtk::ListStore> m_refLabelsTree;
-	MailAccountModelColumns m_mailColumns;
+	TimestampedModelColumns m_directoriesColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refDirectoriesTree;
+	TimestampedModelColumns m_mailColumns;
 	Glib::RefPtr<Gtk::ListStore> m_refMailTree;
 	std::set<std::string> m_deletedLabels;
 	std::map<std::string, std::string> m_renamedLabels;
+	std::set<std::string> m_deletedDirectories;
 	std::set<std::string> m_deletedMail;
-	static unsigned int m_maxDirLevel;
 
 };
 #endif

Modified: trunk/UI/GTK2/src/prefsDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog_glade.cc	2006-08-26 03:39:36 UTC (rev 429)
+++ trunk/UI/GTK2/src/prefsDialog_glade.cc	2006-08-26 03:41:09 UTC (rev 430)
@@ -1,9 +1,9 @@
-// generated 2006/6/7 21:55:30 SGT by fabrice at amra.dyndns.org.(none)
+// generated 2006/8/20 15:34:17 SGT by fabrice at amra.dyndns.org.(none)
 // using glademm V2.12.1
 //
 // DO NOT EDIT THIS FILE ! It was created using
 // glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
-// for gtk 2.8.17 and gtkmm 2.8.3
+// for gtk 2.8.20 and gtkmm 2.8.8
 //
 // Please modify the corresponding derived classes in ./src/prefsDialog.cc
 
@@ -94,6 +94,22 @@
    Gtk::HBox *labelsHbox = Gtk::manage(new class Gtk::HBox(false, 0));
    Gtk::VBox *labelsVbox = Gtk::manage(new class Gtk::VBox(false, 0));
    Gtk::Label *labelsLabel = Gtk::manage(new class Gtk::Label(_("Labels")));
+   Gtk::Label *directoriesLabel = Gtk::manage(new class Gtk::Label(_("These directories will be monitored and indexed:")));
+   directoriesTreeview = Gtk::manage(new class Gtk::TreeView());
+   
+   Gtk::ScrolledWindow *directoriesScrolledwindow = Gtk::manage(new class Gtk::ScrolledWindow());
+   Gtk::Image *image609 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-add"), Gtk::IconSize(4)));
+   Gtk::Label *label58 = Gtk::manage(new class Gtk::Label(_("Add")));
+   Gtk::HBox *hbox54 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment35 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
+   addDirectoryButton = Gtk::manage(new class Gtk::Button());
+   editDirectoryButton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-edit")));
+   removeDirectoryButton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-remove")));
+   
+   Gtk::VButtonBox *directoriesVbuttonbox = Gtk::manage(new class Gtk::VButtonBox(Gtk::BUTTONBOX_START, 0));
+   Gtk::HBox *directoriesHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   Gtk::VBox *directoriesVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   Gtk::Label *docsLabel = Gtk::manage(new class Gtk::Label(_("My Documents")));
    Gtk::Label *mailAccountsLabel = Gtk::manage(new class Gtk::Label(_("Mail boxes of type mbox can be monitored and indexed:")));
    mailTreeview = Gtk::manage(new class Gtk::TreeView());
    
@@ -234,6 +250,60 @@
    labelsLabel->set_line_wrap(false);
    labelsLabel->set_use_markup(false);
    labelsLabel->set_selectable(false);
+   directoriesLabel->set_alignment(0,0.5);
+   directoriesLabel->set_padding(4,4);
+   directoriesLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   directoriesLabel->set_line_wrap(true);
+   directoriesLabel->set_use_markup(false);
+   directoriesLabel->set_selectable(false);
+   directoriesTreeview->set_flags(Gtk::CAN_FOCUS);
+   directoriesTreeview->set_headers_visible(true);
+   directoriesTreeview->set_rules_hint(false);
+   directoriesTreeview->set_reorderable(false);
+   directoriesTreeview->set_enable_search(true);
+   directoriesScrolledwindow->set_flags(Gtk::CAN_FOCUS);
+   directoriesScrolledwindow->set_border_width(4);
+   directoriesScrolledwindow->set_shadow_type(Gtk::SHADOW_NONE);
+   directoriesScrolledwindow->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+   directoriesScrolledwindow->property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+   directoriesScrolledwindow->add(*directoriesTreeview);
+   image609->set_alignment(0.5,0.5);
+   image609->set_padding(0,0);
+   label58->set_alignment(0.5,0.5);
+   label58->set_padding(0,0);
+   label58->set_justify(Gtk::JUSTIFY_LEFT);
+   label58->set_line_wrap(false);
+   label58->set_use_markup(false);
+   label58->set_selectable(false);
+   hbox54->pack_start(*image609, Gtk::PACK_SHRINK, 0);
+   hbox54->pack_start(*label58, Gtk::PACK_SHRINK, 0);
+   alignment35->add(*hbox54);
+   addDirectoryButton->set_flags(Gtk::CAN_FOCUS);
+   addDirectoryButton->set_flags(Gtk::CAN_DEFAULT);
+   addDirectoryButton->set_border_width(4);
+   addDirectoryButton->set_relief(Gtk::RELIEF_NORMAL);
+   addDirectoryButton->add(*alignment35);
+   editDirectoryButton->set_flags(Gtk::CAN_FOCUS);
+   editDirectoryButton->set_flags(Gtk::CAN_DEFAULT);
+   editDirectoryButton->set_border_width(4);
+   editDirectoryButton->set_relief(Gtk::RELIEF_NORMAL);
+   removeDirectoryButton->set_flags(Gtk::CAN_FOCUS);
+   removeDirectoryButton->set_flags(Gtk::CAN_DEFAULT);
+   removeDirectoryButton->set_border_width(4);
+   removeDirectoryButton->set_relief(Gtk::RELIEF_NORMAL);
+   directoriesVbuttonbox->pack_start(*addDirectoryButton);
+   directoriesVbuttonbox->pack_start(*editDirectoryButton);
+   directoriesVbuttonbox->pack_start(*removeDirectoryButton);
+   directoriesHbox->pack_start(*directoriesScrolledwindow);
+   directoriesHbox->pack_start(*directoriesVbuttonbox, Gtk::PACK_SHRINK, 0);
+   directoriesVbox->pack_start(*directoriesLabel, Gtk::PACK_SHRINK, 4);
+   directoriesVbox->pack_start(*directoriesHbox, Gtk::PACK_EXPAND_WIDGET, 4);
+   docsLabel->set_alignment(0.5,0.5);
+   docsLabel->set_padding(0,0);
+   docsLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   docsLabel->set_line_wrap(false);
+   docsLabel->set_use_markup(false);
+   docsLabel->set_selectable(false);
    mailAccountsLabel->set_alignment(0,0.5);
    mailAccountsLabel->set_padding(4,4);
    mailAccountsLabel->set_justify(Gtk::JUSTIFY_LEFT);
@@ -297,6 +367,8 @@
    prefsNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
    prefsNotebook->append_page(*labelsVbox, *labelsLabel);
    prefsNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   prefsNotebook->append_page(*directoriesVbox, *docsLabel);
+   prefsNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
    prefsNotebook->append_page(*mailVbox, *mailLabel);
    prefsNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
    prefsDialog->get_vbox()->set_homogeneous(false);
@@ -339,6 +411,20 @@
    labelsHbox->show();
    labelsVbox->show();
    labelsLabel->show();
+   directoriesLabel->show();
+   directoriesTreeview->show();
+   directoriesScrolledwindow->show();
+   image609->show();
+   label58->show();
+   hbox54->show();
+   alignment35->show();
+   addDirectoryButton->show();
+   editDirectoryButton->show();
+   removeDirectoryButton->show();
+   directoriesVbuttonbox->show();
+   directoriesHbox->show();
+   directoriesVbox->show();
+   docsLabel->show();
    mailAccountsLabel->show();
    mailTreeview->show();
    mailScrolledwindow->show();
@@ -358,6 +444,10 @@
    prefsOkbutton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_prefsOkbutton_clicked), false);
    addLabelButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_addLabelButton_clicked), false);
    removeLabelButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_removeLabelButton_clicked), false);
+   directoriesTreeview->signal_button_press_event().connect(SigC::slot(*this, &prefsDialog_glade::on_mailTreeview_button_press_event), false);
+   addDirectoryButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_addDirectoryButton_clicked), false);
+   editDirectoryButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_editDirectoryButton_clicked), false);
+   removeDirectoryButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_removeDirectoryButton_clicked), false);
    mailTreeview->signal_button_press_event().connect(SigC::slot(*this, &prefsDialog_glade::on_mailTreeview_button_press_event), false);
    addAccountButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_addAccountButton_clicked), false);
    editAccountButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_editAccountButton_clicked), false);

Modified: trunk/UI/GTK2/src/prefsDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/prefsDialog_glade.hh	2006-08-26 03:39:36 UTC (rev 429)
+++ trunk/UI/GTK2/src/prefsDialog_glade.hh	2006-08-26 03:41:09 UTC (rev 430)
@@ -1,9 +1,9 @@
-// generated 2006/6/7 21:55:30 SGT by fabrice at amra.dyndns.org.(none)
+// generated 2006/8/20 15:34:17 SGT by fabrice at amra.dyndns.org.(none)
 // using glademm V2.12.1
 //
 // DO NOT EDIT THIS FILE ! It was created using
 // glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
-// for gtk 2.8.17 and gtkmm 2.8.3
+// for gtk 2.8.20 and gtkmm 2.8.8
 //
 // Please modify the corresponding derived classes in ./src/prefsDialog.hh and./src/prefsDialog.cc
 
@@ -57,6 +57,10 @@
         class Gtk::TreeView * labelsTreeview;
         class Gtk::Button * addLabelButton;
         class Gtk::Button * removeLabelButton;
+        class Gtk::TreeView * directoriesTreeview;
+        class Gtk::Button * addDirectoryButton;
+        class Gtk::Button * editDirectoryButton;
+        class Gtk::Button * removeDirectoryButton;
         class Gtk::TreeView * mailTreeview;
         class Gtk::Button * addAccountButton;
         class Gtk::Button * editAccountButton;
@@ -71,6 +75,9 @@
         virtual void on_addLabelButton_clicked() = 0;
         virtual void on_removeLabelButton_clicked() = 0;
         virtual bool on_mailTreeview_button_press_event(GdkEventButton *ev) = 0;
+        virtual void on_addDirectoryButton_clicked() = 0;
+        virtual void on_editDirectoryButton_clicked() = 0;
+        virtual void on_removeDirectoryButton_clicked() = 0;
         virtual void on_addAccountButton_clicked() = 0;
         virtual void on_editAccountButton_clicked() = 0;
         virtual void on_removeAccountButton_clicked() = 0;



From fabricecolin at mail.berlios.de  Sat Aug 26 05:44:41 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 05:44:41 +0200
Subject: [Pinot-svn] r431 - trunk/UI/GTK2/src
Message-ID: <200608260344.k7Q3ifgd001163@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 05:44:38 +0200 (Sat, 26 Aug 2006)
New Revision: 431

Modified:
   trunk/UI/GTK2/src/EnginesTree.cpp
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/PinotSettings.h
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/mainWindow_glade.cc
Log:
My Documents becomes My Web Pages, My Computer becomes My Documents.
Use the "merged" index for terms suggestion, More Like This and determining
which documents are indexed locally.
Other miscellaneous changes.


Modified: trunk/UI/GTK2/src/EnginesTree.cpp
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.cpp	2006-08-26 03:41:09 UTC (rev 430)
+++ trunk/UI/GTK2/src/EnginesTree.cpp	2006-08-26 03:44:38 UTC (rev 431)
@@ -336,8 +336,8 @@
 		ustring indexName = to_utf8(indexIter->first);
 		EnginesModelColumns::EngineType indexType = EnginesModelColumns::INDEX_ENGINE;
 
-		if ((indexName == _("My Documents")) ||
-			(indexName == _("My Computer")))
+		if ((indexName == _("My Web Pages")) ||
+			(indexName == _("My Documents")))
 		{
 			indexType = EnginesModelColumns::INTERNAL_INDEX_ENGINE;
 		}

Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2006-08-26 03:41:09 UTC (rev 430)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2006-08-26 03:44:38 UTC (rev 431)
@@ -227,8 +227,8 @@
 	}
 
 	// Internal indices
-	addIndex(_("My Documents"), m_docsIndexLocation);
-	addIndex(_("My Computer"), m_daemonIndexLocation);
+	addIndex(_("My Web Pages"), m_docsIndexLocation);
+	addIndex(_("My Documents"), m_daemonIndexLocation);
 
 	// Add default labels on the first run
 	if (m_firstRun == true)
@@ -1072,8 +1072,8 @@
 /// Returns true if the given index is internal.
 bool PinotSettings::isInternalIndex(const string &name) const
 {
-	if ((name == _("My Documents")) ||
-		(name == _("My Computer")))
+	if ((name == _("My Web Pages")) ||
+		(name == _("My Documents")))
 	{
 		return true;
 	}
@@ -1128,8 +1128,8 @@
 	// Clear both maps, reinsert the internal index
 	m_indexNames.clear();
 	m_indexIds.clear();
-	addIndex(_("My Documents"), m_docsIndexLocation);
-	addIndex(_("My Computer"), m_daemonIndexLocation);
+	addIndex(_("My Web Pages"), m_docsIndexLocation);
+	addIndex(_("My Documents"), m_daemonIndexLocation);
 }
 
 /// Returns an ID that identifies the given index.
@@ -1365,18 +1365,34 @@
 {
 }
 
-PinotSettings::Engine::Engine(string name, string type, string option, string channel)
+PinotSettings::Engine::Engine(string name, string type, string option, string channel) :
+	m_name(name),
+	m_type(type),
+	m_option(option),
+	m_channel(channel)
 {
-	m_name = name;
-	m_type = type;
-	m_option = option;
-	m_channel = channel;
 }
 
+PinotSettings::Engine::Engine(const Engine &other) :
+	m_name(other.m_name),
+	m_type(other.m_type),
+	m_option(other.m_option),
+	m_channel(other.m_channel)
+{
+}
+
 PinotSettings::Engine::~Engine()
 {
 }
 
+PinotSettings::Engine &PinotSettings::Engine::operator=(const PinotSettings::Engine &other)
+{
+	m_name = other.m_name;
+	m_type = other.m_type;
+	m_option = other.m_option;
+	m_channel = other.m_channel;
+}
+
 bool PinotSettings::Engine::operator<(const PinotSettings::Engine &other) const
 {
 	if (m_name < other.m_name)

Modified: trunk/UI/GTK2/src/PinotSettings.h
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.h	2006-08-26 03:41:09 UTC (rev 430)
+++ trunk/UI/GTK2/src/PinotSettings.h	2006-08-26 03:44:38 UTC (rev 431)
@@ -85,9 +85,11 @@
 		{
 			public:
 				Engine();
+				Engine(const Engine &other);
 				Engine(std::string name, std::string type, std::string option, std::string channel);
 				~Engine();
 
+				Engine &operator=(const Engine &other);
 				bool operator<(const Engine &other) const;
 				bool operator==(const Engine &other) const;
 

Modified: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2006-08-26 03:41:09 UTC (rev 430)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2006-08-26 03:44:38 UTC (rev 431)
@@ -30,7 +30,6 @@
 #include "Url.h"
 #include "QueryHistory.h"
 #include "ViewHistory.h"
-#include "IndexFactory.h"
 #include "config.h"
 #include "NLS.h"
 #include "PinotSettings.h"
@@ -1138,7 +1137,7 @@
 #endif
 	}
 
-	IndexInterface *pIndex = m_settings.getROIndex(m_settings.m_docsIndexLocation);
+	IndexInterface *pIndex = m_settings.getROIndex("MERGED");
 	ViewHistory viewHistory(m_settings.m_historyDatabase);
 	bool isIndexed = false;
 

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2006-08-26 03:41:09 UTC (rev 430)
+++ trunk/UI/GTK2/src/mainWindow.cc	2006-08-26 03:44:38 UTC (rev 431)
@@ -43,7 +43,6 @@
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "DownloaderFactory.h"
-#include "IndexFactory.h"
 #include "SearchEngineFactory.h"
 #include "config.h"
 #include "NLS.h"
@@ -184,7 +183,7 @@
 	show();
 
 	// Browse the index
-	on_index_changed(_("My Documents"));
+	on_index_changed(_("My Web Pages"));
 }
 
 //
@@ -296,16 +295,16 @@
 	SigC::Slot1<void, ustring> indexSlot = SigC::slot(*this, &mainWindow::on_index_changed);
 
 	// Populate the submenu
-	m_pIndexMenu->items().push_back(Menu_Helpers::MenuElem(_("My Computer")));
+	m_pIndexMenu->items().push_back(Menu_Helpers::MenuElem(_("My Documents")));
 	MenuItem *pMenuItem = &m_pIndexMenu->items().back();
 	// Bind the callback's parameter to the index name
-	SigC::Slot0<void> daemonActivateSlot = sigc::bind(indexSlot, _("My Computer"));
+	SigC::Slot0<void> daemonActivateSlot = sigc::bind(indexSlot, _("My Documents"));
 	pMenuItem->signal_activate().connect(daemonActivateSlot);
 
-	m_pIndexMenu->items().push_back(Menu_Helpers::MenuElem(_("My Documents")));
+	m_pIndexMenu->items().push_back(Menu_Helpers::MenuElem(_("My Web Pages")));
 	pMenuItem = &m_pIndexMenu->items().back();
 	// Bind the callback's parameter to the index name
-	SigC::Slot0<void> documentsActivateSlot = sigc::bind(indexSlot, _("My Documents"));
+	SigC::Slot0<void> documentsActivateSlot = sigc::bind(indexSlot, _("My Web Pages"));
 	pMenuItem->signal_activate().connect(documentsActivateSlot);
 
 	if (m_pCacheMenu == NULL)
@@ -438,7 +437,7 @@
 	if ((hasSelection == true) &&
 		(resultsList.empty() == false))
 	{
-		IndexInterface *pIndex = m_settings.getROIndex(m_settings.m_docsIndexLocation);
+		IndexInterface *pIndex = m_settings.getROIndex("MERGED");
 		bool firstResult = true, isViewable = true, isCached = false, isIndexed = false, isIndexable = true;
 
 		for (vector<DocumentInfo>::iterator resultIter = resultsList.begin();
@@ -531,7 +530,7 @@
 			bool isDocumentsIndex = true;
 
 			// Enable these menu items unless it is not the documents index
-			if (indexName != _("My Documents"))
+			if (indexName != _("My Web Pages"))
 			{
 				isDocumentsIndex = false;
 			}
@@ -1131,7 +1130,7 @@
 
 		// Is the index still being shown ?
 		IndexTree *pIndexTree = NULL;
-		IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(_("My Documents"), NotebookPageBox::INDEX_PAGE));
+		IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(_("My Web Pages"), NotebookPageBox::INDEX_PAGE));
 		if (pIndexPage != NULL)
 		{
 			pIndexTree = pIndexPage->getTree();
@@ -1173,7 +1172,7 @@
 						docInfo.getLanguage());
 					indexedDoc.setTimestamp(docInfo.getTimestamp());
 
-					append_document(pIndexPage, _("My Documents"), indexedDoc);
+					append_document(pIndexPage, _("My Web Pages"), indexedDoc);
 				}
 				pIndexPage->setDocumentsCount(pIndexPage->getDocumentsCount() + 1);
 				pIndexPage->updateButtonsState(m_maxDocsCount);
@@ -1193,7 +1192,7 @@
 
 		if (pUnindexThread->getDocumentsCount() > 0)
 		{
-			ustring indexName(_("My Documents"));
+			ustring indexName(_("My Web Pages"));
 			status = _("Unindexed document(s)");
 			set_status(status);
 
@@ -1224,7 +1223,7 @@
 			return;
 		}
 
-		IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(_("My Documents"), NotebookPageBox::INDEX_PAGE));
+		IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(_("My Web Pages"), NotebookPageBox::INDEX_PAGE));
 		if (pIndexPage != NULL)
 		{
 			IndexTree *pIndexTree = pIndexPage->getTree();
@@ -1385,13 +1384,6 @@
 	{
 		start_thread(new LabelUpdateThread(labelsToDelete, labelsToRename));
 	}
-
-	// Any mail documents we should delete ?
-	const set<string> &mailLabelsToDelete = prefsBox.getMailLabelsToDelete();
-	if (mailLabelsToDelete.empty() == false)
-	{
-		start_thread(new UnindexingThread(mailLabelsToDelete, from_utf8(m_settings.m_daemonIndexLocation)));
-	}
 }
 
 //
@@ -1690,6 +1682,7 @@
 	// Find this query
 	if (queryName == _("Live query"))
 	{
+		queryProps.setName(queryName);
 		queryProps.setAndWords(from_utf8(liveQueryEntry->get_text()));
 	}
 	else
@@ -1721,13 +1714,13 @@
 		}
 	}
 
-	IndexInterface *pIndex = m_settings.getROIndex(m_settings.m_docsIndexLocation);
+	IndexInterface *pIndex = m_settings.getROIndex("MERGED");
         if (pIndex != NULL)
 	{
+       	set<unsigned int> docIdList;
+
 		if (pIndex->isGood() == true)
 		{
-        		set<unsigned int> docIdList;
-
 			for (vector<DocumentInfo>::const_iterator docIter = resultsList.begin();
 				docIter != resultsList.end(); ++docIter)
 			{
@@ -1739,8 +1732,8 @@
 			}
 
 			// Spawn a new thread
-			start_thread(new QueryingThread("xapian", _("My Documents"),
-				m_settings.m_docsIndexLocation, queryProps, docIdList));
+			start_thread(new QueryingThread("xapian", "", "MERGED",
+				queryProps, docIdList));
 		}
 
 		delete pIndex;
@@ -1796,7 +1789,7 @@
 {
 	m_state.disconnect();
 
-	importDialog importBox(_("Import Document(s)"));
+	importDialog importBox;
 	importBox.show();
 	importBox.run();
 
@@ -1805,7 +1798,7 @@
 	// Was anything imported ?
 	if (importBox.getDocumentsCount() > 0)
 	{
-		ustring indexName(_("My Documents"));
+		ustring indexName(_("My Web Pages"));
 
 		// Is the index still being shown ?
 		IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(indexName, NotebookPageBox::INDEX_PAGE));
@@ -2296,8 +2289,8 @@
 	}
 	m_state.m_liveQueryLength = liveQueryLength;
 
-	// FIXME: relying on other indices may also be useful
-	IndexInterface *pIndex = m_settings.getROIndex(m_settings.m_docsIndexLocation);
+	// Query the merged index
+	IndexInterface *pIndex = m_settings.getROIndex("MERGED");
 	if (pIndex != NULL)
 	{
 		set<string> suggestedTerms;

Modified: trunk/UI/GTK2/src/mainWindow_glade.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.cc	2006-08-26 03:41:09 UTC (rev 430)
+++ trunk/UI/GTK2/src/mainWindow_glade.cc	2006-08-26 03:44:38 UTC (rev 431)
@@ -210,7 +210,7 @@
    indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("List Contents Of")));
    list1 = (Gtk::MenuItem *)&indexMenuitem_menu->items().back();
    
-   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Import"), *image610));
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Import URL"), *image610));
    import1 = (Gtk::ImageMenuItem *)&indexMenuitem_menu->items().back();
    
    indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::SeparatorElem());



From fabricecolin at mail.berlios.de  Sat Aug 26 05:46:16 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 05:46:16 +0200
Subject: [Pinot-svn] r432 - trunk
Message-ID: <200608260346.k7Q3kGg9001608@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 05:46:16 +0200 (Sat, 26 Aug 2006)
New Revision: 432

Modified:
   trunk/pinot.spec.in
Log:
On SuSE, pdftotext is provided by xpdf-tools, not poppler-utils.


Modified: trunk/pinot.spec.in
===================================================================
--- trunk/pinot.spec.in	2006-08-26 03:44:38 UTC (rev 431)
+++ trunk/pinot.spec.in	2006-08-26 03:46:16 UTC (rev 432)
@@ -8,8 +8,11 @@
 Source: %{name}-%{version}.tar.gz
 URL: http://pinot.berlios.de/
 BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
-Requires: xapian-core-libs >= 0.9.4, curl >= 7.13, gtkmm24 >= 2.6, libxml++ >= 2.12, sqlite >= 3.1.2, libtextcat >= 2.2, gmime >= 2.1, shared-mime-info
-BuildRequires: xapian-core-devel >= 0.9.4, curl-devel >= 7.13, gtkmm24-devel >= 2.6, libxml++-devel >= 2.12, sqlite-devel >= 3.1.2, libtextcat-devel >= 2.2, gmime-devel >= 2.1, taglib-devel >= 1.4, boost-devel >= 1.32, gettext-devel, desktop-file-utils
+Requires: xapian-core-libs >= 0.9.4, libtextcat >= 2.2, sqlite >= 3.1.2, curl >= 7.13, gmime >= 2.1
+Requires: gtkmm24 >= 2.6, libxml++ >= 2.12, dbus >= 0.60, shared-mime-info
+BuildRequires: xapian-core-devel >= 0.9.4, libtextcat-devel >= 2.2, sqlite-devel >= 3.1.2, curl-devel >= 7.13, gmime-devel >= 2.1, boost-devel >= 1.32
+BuildRequires: gtkmm24-devel >= 2.6, libxml++-devel >= 2.12, dbus-devel >= 0.60, gettext-devel, desktop-file-utils
+BuildRequires: taglib-devel >= 1.4
 %if 0%{?_with_soap:1}
 BuildRequires: gsoap
 %endif
@@ -23,7 +26,12 @@
 Summary: Tokenizers for Pinot that handle various text document formats
 Group: Applications/Internet
 Requires: %{name} = %{version}
-Requires: unzip, poppler-utils, antiword, unrtf
+Requires: unzip, antiword, unrtf
+%if "%{_vendor}" == "suse"
+Requires: xpdf-tools
+%else
+Requires: poppler-utils
+%endif
 Obsoletes: pinot-pdf, pinot-word
 
 %description text-docs 



From fabricecolin at mail.berlios.de  Sat Aug 26 05:47:56 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 05:47:56 +0200
Subject: [Pinot-svn] r433 - trunk
Message-ID: <200608260347.k7Q3luQo001707@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 05:47:45 +0200 (Sat, 26 Aug 2006)
New Revision: 433

Modified:
   trunk/configure.in
Log:
Cut down on the number of calls to AC_OUTPUT, until I figure out how to do it
properly ;-)


Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2006-08-26 03:46:16 UTC (rev 432)
+++ trunk/configure.in	2006-08-26 03:47:45 UTC (rev 433)
@@ -191,9 +191,9 @@
 AC_CHECK_FUNCS(lstat)
 AC_CHECK_FUNCS(mmap)
 
-AC_OUTPUT( pinot.spec UI/GTK2/src/de.berlios.Pinot.service )
-AC_OUTPUT( Makefile Utils/Makefile Tokenize/Makefile )
-AC_OUTPUT( SQL/Makefile po/Makefile.in Collect/Makefile )
+AC_OUTPUT( pinot.spec UI/GTK2/src/de.berlios.Pinot.service Makefile \
+	Utils/Makefile Tokenize/Makefile SQL/Makefile po/Makefile.in \
+	Collect/Makefile )
 if test "$SOAP_SUBDIRS" != "" ; then
   AC_OUTPUT( Search/Google/Makefile )
 fi



From fabricecolin at mail.berlios.de  Sat Aug 26 10:33:31 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 10:33:31 +0200
Subject: [Pinot-svn] r434 - in trunk: Collect Index Search UI/GTK2/src
Message-ID: <200608260833.k7Q8XVvv018829@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 10:33:31 +0200 (Sat, 26 Aug 2006)
New Revision: 434

Modified:
   trunk/Collect/pinot-collect.1
   trunk/Index/pinot-index.1
   trunk/Search/pinot-search.1
   trunk/UI/GTK2/src/pinot-dbus-daemon.1
   trunk/UI/GTK2/src/pinot.1
Log:
Updated version number.


Modified: trunk/Collect/pinot-collect.1
===================================================================
--- trunk/Collect/pinot-collect.1	2006-08-26 03:47:45 UTC (rev 433)
+++ trunk/Collect/pinot-collect.1	2006-08-26 08:33:31 UTC (rev 434)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-COLLECT "1" "August 2006" "pinot-collect - pinot 0.50" "User Commands"
+.TH PINOT-COLLECT "1" "August 2006" "pinot-collect - pinot 0.60" "User Commands"
 .SH NAME
 pinot-collect \- Download an URL from the command-line
 .SH SYNOPSIS

Modified: trunk/Index/pinot-index.1
===================================================================
--- trunk/Index/pinot-index.1	2006-08-26 03:47:45 UTC (rev 433)
+++ trunk/Index/pinot-index.1	2006-08-26 08:33:31 UTC (rev 434)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-INDEX "1" "August 2006" "pinot-index - pinot 0.50" "User Commands"
+.TH PINOT-INDEX "1" "August 2006" "pinot-index - pinot 0.60" "User Commands"
 .SH NAME
 pinot-index \- Index documents from the command-line
 .SH SYNOPSIS

Modified: trunk/Search/pinot-search.1
===================================================================
--- trunk/Search/pinot-search.1	2006-08-26 03:47:45 UTC (rev 433)
+++ trunk/Search/pinot-search.1	2006-08-26 08:33:31 UTC (rev 434)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-SEARCH "1" "August 2006" "pinot-search - pinot 0.50" "User Commands"
+.TH PINOT-SEARCH "1" "August 2006" "pinot-search - pinot 0.60" "User Commands"
 .SH NAME
 pinot-search \- Query search engines from the command-line
 .SH SYNOPSIS

Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.1
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.1	2006-08-26 03:47:45 UTC (rev 433)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.1	2006-08-26 08:33:31 UTC (rev 434)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT-DBUS-DAEMON "1" "August 2006" "pinot-dbus-daemon - pinot 0.50" "User Commands"
+.TH PINOT-DBUS-DAEMON "1" "August 2006" "pinot-dbus-daemon - pinot 0.60" "User Commands"
 .SH NAME
 pinot-dbus-daemon \- D-Bus search and index daemon
 .SH SYNOPSIS

Modified: trunk/UI/GTK2/src/pinot.1
===================================================================
--- trunk/UI/GTK2/src/pinot.1	2006-08-26 03:47:45 UTC (rev 433)
+++ trunk/UI/GTK2/src/pinot.1	2006-08-26 08:33:31 UTC (rev 434)
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.36.
-.TH PINOT "1" "August 2006" "pinot - pinot 0.50" "User Commands"
+.TH PINOT "1" "August 2006" "pinot - pinot 0.60" "User Commands"
 .SH NAME
 pinot \- A metasearch tool for the Free Desktop
 .SH SYNOPSIS



From fabricecolin at mail.berlios.de  Sat Aug 26 11:01:15 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 11:01:15 +0200
Subject: [Pinot-svn] r435 - in trunk: Index Search Utils
Message-ID: <200608260901.k7Q91F64020626@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 11:01:14 +0200 (Sat, 26 Aug 2006)
New Revision: 435

Modified:
   trunk/Index/DBusXapianIndex.cpp
   trunk/Index/DBusXapianIndex.h
   trunk/Index/WritableXapianIndex.cpp
   trunk/Search/XapianEngine.cpp
   trunk/Utils/XapianDatabase.cpp
   trunk/Utils/XapianDatabase.h
Log:
Reopen the database to the latest version before adding it to another one
in XapianDatabase, before any read operations in DBusXapianIndex and before
querying it in XapianEngine.


Modified: trunk/Index/DBusXapianIndex.cpp
===================================================================
--- trunk/Index/DBusXapianIndex.cpp	2006-08-26 08:33:31 UTC (rev 434)
+++ trunk/Index/DBusXapianIndex.cpp	2006-08-26 09:01:14 UTC (rev 435)
@@ -86,17 +86,13 @@
 	return *this;
 }
 
-void DBusXapianIndex::reopen(void)
+void DBusXapianIndex::reopen(void) const
 {
 	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName);
 	if (pDatabase != NULL)
 	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-
 		// Re-open the database to the latest available version
-		pIndex->reopen();
-
-		pDatabase->unlock();
+		pDatabase->reopen();
 	}
 
 }
@@ -108,54 +104,68 @@
 /// Returns false if the index couldn't be opened.
 bool DBusXapianIndex::isGood(void) const
 {
-	return m_goodIndex;
+	return XapianIndex::isGood();
 }
 
 /// Gets the index location.
 string DBusXapianIndex::getLocation(void) const
 {
-	return m_databaseName;
+	return XapianIndex::getLocation();
 }
 
 /// Returns a document's properties.
 bool DBusXapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
 {
+	reopen();
+
 	return XapianIndex::getDocumentInfo(docId, docInfo);
 }
 
 /// Determines whether a document has a label.
 bool DBusXapianIndex::hasLabel(unsigned int docId, const string &name) const
 {
+	reopen();
+
 	return XapianIndex::hasLabel(docId, name);
 }
 
 /// Returns a document's labels.
 bool DBusXapianIndex::getDocumentLabels(unsigned int docId, set<string> &labels) const
 {
+	reopen();
+
 	return XapianIndex::getDocumentLabels(docId, labels);
 }
 
 /// Checks whether the given URL is in the index.
 unsigned int DBusXapianIndex::hasDocument(const string &url) const
 {
+	reopen();
+
 	return XapianIndex::hasDocument(url);
 }
 
 /// Gets terms with the same root.
 unsigned int DBusXapianIndex::getCloseTerms(const string &term, set<string> &suggestions)
 {
+	reopen();
+
 	return XapianIndex::getCloseTerms(term, suggestions);
 }
 
 /// Returns the ID of the last document.
 unsigned int DBusXapianIndex::getLastDocumentID(void) const
 {
+	reopen();
+
 	return XapianIndex::getLastDocumentID();
 }
 
 /// Returns the number of documents.
 unsigned int DBusXapianIndex::getDocumentsCount(const string &labelName) const
 {
+	reopen();
+
 	return XapianIndex::getDocumentsCount(labelName);
 }
 
@@ -163,6 +173,8 @@
 unsigned int DBusXapianIndex::listDocuments(set<unsigned int> &docIds,
 	unsigned int maxDocsCount, unsigned int startDoc) const
 {
+	reopen();
+
 	return XapianIndex::listDocuments(docIds, maxDocsCount, startDoc);
 }
 
@@ -170,6 +182,8 @@
 bool DBusXapianIndex::listDocumentsWithLabel(const string &name, set<unsigned int> &docIds,
 	unsigned int maxDocsCount, unsigned int startDoc) const
 {
+	reopen();
+
 	return XapianIndex::listDocumentsWithLabel(name, docIds, maxDocsCount, startDoc);
 }
 
@@ -211,7 +225,6 @@
 		G_TYPE_INVALID) == TRUE)
 	{
 		updated = true;
-		reopen();
 	}
 	else
 	{
@@ -263,7 +276,6 @@
 		G_TYPE_INVALID) == TRUE)
 	{
 		updated = true;
-		reopen();
 	}
 	else
 	{
@@ -322,7 +334,6 @@
 		G_TYPE_INVALID) == TRUE)
 	{
 		updatedLabels = true;
-		reopen();
 	}
 	else
 	{
@@ -392,7 +403,6 @@
 		G_TYPE_INVALID) == TRUE)
 	{
 		renamedLabel = true;
-		reopen();
 	}
 	else
 	{
@@ -437,7 +447,6 @@
 		G_TYPE_INVALID) == TRUE)
 	{
 		deletedLabel = true;
-		reopen();
 	}
 	else
 	{

Modified: trunk/Index/DBusXapianIndex.h
===================================================================
--- trunk/Index/DBusXapianIndex.h	2006-08-26 08:33:31 UTC (rev 434)
+++ trunk/Index/DBusXapianIndex.h	2006-08-26 09:01:14 UTC (rev 435)
@@ -96,7 +96,7 @@
 		virtual bool flush(void);
 
 	protected:
-		void reopen(void);
+		void reopen(void) const;
 
 };
 

Modified: trunk/Index/WritableXapianIndex.cpp
===================================================================
--- trunk/Index/WritableXapianIndex.cpp	2006-08-26 08:33:31 UTC (rev 434)
+++ trunk/Index/WritableXapianIndex.cpp	2006-08-26 09:01:14 UTC (rev 435)
@@ -517,13 +517,13 @@
 /// Returns false if the index couldn't be opened.
 bool WritableXapianIndex::isGood(void) const
 {
-	return m_goodIndex;
+	return XapianIndex::isGood();
 }
 
 /// Gets the index location.
 string WritableXapianIndex::getLocation(void) const
 {
-	return m_databaseName;
+	return XapianIndex::getLocation();
 }
 
 /// Returns a document's properties.

Modified: trunk/Search/XapianEngine.cpp
===================================================================
--- trunk/Search/XapianEngine.cpp	2006-08-26 08:33:31 UTC (rev 434)
+++ trunk/Search/XapianEngine.cpp	2006-08-26 09:01:14 UTC (rev 435)
@@ -117,6 +117,8 @@
 		return false;
 	}
 
+	// Get the latest revision...
+	pDatabase->reopen();
 	Xapian::Database *pIndex = pDatabase->readLock();
 	if (pIndex != NULL)
 	{

Modified: trunk/Utils/XapianDatabase.cpp
===================================================================
--- trunk/Utils/XapianDatabase.cpp	2006-08-26 08:33:31 UTC (rev 434)
+++ trunk/Utils/XapianDatabase.cpp	2006-08-26 09:01:14 UTC (rev 435)
@@ -188,7 +188,7 @@
 			{
 				// We have to create the whole thing in read-write mode first
 				Xapian::WritableDatabase *pTmpDatabase = new Xapian::WritableDatabase(m_databaseName, Xapian::DB_CREATE_OR_OPEN);
-				// ...then close and reopen in read-only mode
+				// ...then close and open again in read-only mode
 				delete pTmpDatabase;
 			}
 
@@ -220,6 +220,22 @@
 	return m_isOpen;
 }
 
+/// Reopens the database.
+void XapianDatabase::reopen(void)
+{
+	// This is provided by Xapian::Database
+	// FIXME: get the write lock to make sure read operations are not in progress ?
+	if (pthread_rwlock_rdlock(&m_rwLock) == 0)
+	{
+		if (m_pDatabase != NULL)
+		{
+			m_pDatabase->reopen();
+		}
+
+		pthread_rwlock_unlock(&m_rwLock);
+	}
+}
+
 /// Attempts to lock and retrieve the database.
 Xapian::Database *XapianDatabase::readLock(void)
 {
@@ -250,6 +266,9 @@
 
 		if (pthread_rwlock_rdlock(&m_rwLock) == 0)
 		{
+			// Reopen the second index
+			m_pSecond->reopen();
+
 			// Lock both indexes
 			Xapian::Database *pFirstDatabase = m_pFirst->readLock();
 			Xapian::Database *pSecondDatabase = m_pSecond->readLock();
@@ -275,7 +294,6 @@
 	if ((m_readOnly == true) ||
 		(m_merge == true))
 	{
-		// FIXME: close and reopen in write mode
 		cerr << "Couldn't open read-only database " << m_databaseName
 			<< " for writing" << endl;
 		return NULL;

Modified: trunk/Utils/XapianDatabase.h
===================================================================
--- trunk/Utils/XapianDatabase.h	2006-08-26 08:33:31 UTC (rev 434)
+++ trunk/Utils/XapianDatabase.h	2006-08-26 09:01:14 UTC (rev 435)
@@ -37,6 +37,9 @@
 		/// Returns false if the database couldn't be opened.
 		bool isOpen(void) const;
 
+		/// Reopens the database.
+		void reopen(void);
+
 		/// Attempts to lock and retrieve the database.
 		Xapian::Database *readLock(void);
 



From fabricecolin at mail.berlios.de  Sat Aug 26 12:21:09 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 12:21:09 +0200
Subject: [Pinot-svn] r436 - in trunk: Monitor UI/GTK2/src
Message-ID: <200608261021.k7QAL9lX026841@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 12:21:08 +0200 (Sat, 26 Aug 2006)
New Revision: 436

Modified:
   trunk/Monitor/INotifyMonitor.cpp
   trunk/UI/GTK2/src/OnDiskHandler.cpp
Log:
Cosmetic changes.


Modified: trunk/Monitor/INotifyMonitor.cpp
===================================================================
--- trunk/Monitor/INotifyMonitor.cpp	2006-08-26 09:01:14 UTC (rev 435)
+++ trunk/Monitor/INotifyMonitor.cpp	2006-08-26 10:21:08 UTC (rev 436)
@@ -151,7 +151,7 @@
 		m_internalEvents.pop();
 	}
 
-	if (ioctl (m_monitorFd, FIONREAD, &queueLen) == 0)
+	if (ioctl(m_monitorFd, FIONREAD, &queueLen) == 0)
 	{
 #ifdef DEBUG
 		cout << "INotifyMonitor::retrievePendingEvents: "

Modified: trunk/UI/GTK2/src/OnDiskHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-26 09:01:14 UTC (rev 435)
+++ trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-26 10:21:08 UTC (rev 436)
@@ -183,9 +183,8 @@
 
 bool OnDiskHandler::fileExists(const string &fileName)
 {
-#ifdef DEBUG
-	cout << "OnDiskHandler::fileExists: " << fileName << endl;
-#endif
+	// Nothing to do here
+	return true;
 }
 
 bool OnDiskHandler::fileCreated(const string &fileName)



From fabricecolin at mail.berlios.de  Sat Aug 26 13:44:32 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 13:44:32 +0200
Subject: [Pinot-svn] r437 - in trunk: . Collect Index Monitor SQL Search
	Tokenize UI/GTK2/src
Message-ID: <200608261144.k7QBiWSH017334@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 13:43:57 +0200 (Sat, 26 Aug 2006)
New Revision: 437

Modified:
   trunk/Collect/Makefile.am
   trunk/Index/Makefile.am
   trunk/Monitor/INotifyMonitor.cpp
   trunk/Monitor/Makefile.am
   trunk/Monitor/MonitorFactory.cpp
   trunk/SQL/Makefile.am
   trunk/Search/Makefile.am
   trunk/Search/PluginWebEngine.cpp
   trunk/Tokenize/Makefile.am
   trunk/Tokenize/TokenizerFactory.cpp
   trunk/UI/GTK2/src/Makefile.am
   trunk/configure.in
Log:
A whole bunch of changes for building with CygWin, courtesy of Reini Urban
(rurban AT x-ray DOT at). Thanks !
INotifyMonitor and SherlockParser are built based on the availability of
inotify and boost Spirit, respectively.


Modified: trunk/Collect/Makefile.am
===================================================================
--- trunk/Collect/Makefile.am	2006-08-26 10:21:08 UTC (rev 436)
+++ trunk/Collect/Makefile.am	2006-08-26 11:43:57 UTC (rev 437)
@@ -1,11 +1,12 @@
 # Process this file with automake to produce Makefile.in
 
 noinst_HEADERS = \
-	@HTTP_DOWNLOADER at .h \
+	CurlDownloader.h \
 	DownloaderFactory.h \
 	DownloaderInterface.h \
 	FileCollector.h \
 	MboxCollector.h \
+	NeonDownloader.h \
 	XapianCollector.h
 
 noinst_LTLIBRARIES = libCollect.la
@@ -27,6 +28,6 @@
 	-lCollect -lTokenize -lUtils \
 	@GLIBMM_LIBS@ @INDEX_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
 
-AM_CXXFLAGS = -I../Utils -I../Tokenize \
+AM_CXXFLAGS = -I$(srcdir)/../Utils -I$(srcdir)/../Tokenize \
 	@INDEX_CFLAGS@ @XML_CFLAGS@ @HTTP_CFLAGS@ @MIME_CFLAGS@ @GLIBMM_CFLAGS@
 

Modified: trunk/Index/Makefile.am
===================================================================
--- trunk/Index/Makefile.am	2006-08-26 10:21:08 UTC (rev 436)
+++ trunk/Index/Makefile.am	2006-08-26 11:43:57 UTC (rev 437)
@@ -22,10 +22,10 @@
 pinot_index_SOURCES = \
 	pinot-index.cpp
 
-pinot_index_LDADD = -L../Utils -L../Tokenize -L../Collect -L../Index \
+pinot_index_LDADD = -L../Utils -L../Tokenize -L../Collect \
 	-lIndex -lCollect -lTokenize -lUtils \
 	@GLIBMM_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @MISC_LIBS@
 
-AM_CXXFLAGS = -I../Utils -I../Tokenize -I../Collect -I../Index \
+AM_CXXFLAGS = -I$(srcdir)/../Utils -I$(srcdir)/../Tokenize -I$(srcdir)/../Collect \
 	@HTTP_CFLAGS@ @MIME_CFLAGS@ @XML_CFLAGS@ @DBUS_CFLAGS@ @INDEX_CFLAGS@
 

Modified: trunk/Monitor/INotifyMonitor.cpp
===================================================================
--- trunk/Monitor/INotifyMonitor.cpp	2006-08-26 10:21:08 UTC (rev 436)
+++ trunk/Monitor/INotifyMonitor.cpp	2006-08-26 11:43:57 UTC (rev 437)
@@ -16,13 +16,15 @@
 
 #include "config.h"
 #include <sys/ioctl.h>
-#ifdef HAVE_LINUX_INOTIFY
+#ifdef HAVE_LINUX_INOTIFY_H
 #include <stdint.h>
 #include <linux/inotify.h>
 #include "linux-inotify-syscalls.h"
 #else
+#ifdef HAVE_SYS_INOTIFY_H
 #include <sys/inotify.h>
 #endif
+#endif
 #include <string.h>
 #include <errno.h>
 #include <iostream>
@@ -52,7 +54,10 @@
 
 INotifyMonitor::~INotifyMonitor()
 {
-	close(m_monitorFd);
+	if (m_monitorFd >= 0)
+	{
+		close(m_monitorFd);
+	}
 }
 
 /// Starts monitoring a location.
@@ -123,8 +128,7 @@
 
 		return true;
 	}
-	cerr << "INotifyMonitor::removeLocation: " << location
-		<< " is not being monitored" << endl;
+	cerr << "INotifyMonitor::removeLocation: " << location << " is not being monitored" << endl;
 
 	return false;
 }

Modified: trunk/Monitor/Makefile.am
===================================================================
--- trunk/Monitor/Makefile.am	2006-08-26 10:21:08 UTC (rev 436)
+++ trunk/Monitor/Makefile.am	2006-08-26 11:43:57 UTC (rev 437)
@@ -11,11 +11,14 @@
 noinst_LTLIBRARIES = libMonitor.la
 
 libMonitor_la_SOURCES = \
-	INotifyMonitor.cpp \
 	MonitorEvent.cpp \
 	MonitorFactory.cpp \
 	MonitorHandler.cpp
+if HAVE_LINUX_INOTIFY
+libMonitor_la_SOURCES += INotifyMonitor.cpp
+endif
 
-AM_CXXFLAGS = -I../Utils -I../Tokenize -I../SQL -I../Collect -I../Search -I../Index \
+AM_CXXFLAGS = -I$(srcdir)/../Utils -I$(srcdir)/../Tokenize -I$(srcdir)/../SQL \
+	-I$(srcdir)/../Collect -I$(srcdir)/../Search -I$(srcdir)/../Index \
 	@HTTP_CFLAGS@ @XML_CFLAGS@ @INDEX_CFLAGS@ @SOAP_CFLAGS@ @MIME_CFLAGS@ @SIGCPP_CFLAGS@
 

Modified: trunk/Monitor/MonitorFactory.cpp
===================================================================
--- trunk/Monitor/MonitorFactory.cpp	2006-08-26 10:21:08 UTC (rev 436)
+++ trunk/Monitor/MonitorFactory.cpp	2006-08-26 11:43:57 UTC (rev 437)
@@ -14,7 +14,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#ifdef HAVE_LINUX_INOTIFY
 #include "INotifyMonitor.h"
+#endif
 #include "MonitorFactory.h"
 
 MonitorFactory::MonitorFactory()
@@ -28,5 +30,9 @@
 /// Returns a Monitor.
 MonitorInterface *MonitorFactory::getMonitor(void)
 {
+#ifdef HAVE_LINUX_INOTIFY
 	return new INotifyMonitor();
+#else
+	return NULL;
+#endif
 }

Modified: trunk/SQL/Makefile.am
===================================================================
--- trunk/SQL/Makefile.am	2006-08-26 10:21:08 UTC (rev 436)
+++ trunk/SQL/Makefile.am	2006-08-26 11:43:57 UTC (rev 437)
@@ -14,5 +14,5 @@
 	SQLiteBase.cpp \
 	ViewHistory.cpp
 
-AM_CXXFLAGS = -I../Utils
+AM_CXXFLAGS = -I$(srcdir)/../Utils
 

Modified: trunk/Search/Makefile.am
===================================================================
--- trunk/Search/Makefile.am	2006-08-26 10:21:08 UTC (rev 436)
+++ trunk/Search/Makefile.am	2006-08-26 11:43:57 UTC (rev 437)
@@ -31,8 +31,10 @@
 	SearchEngineFactory.cpp \
 	XapianEngine.cpp \
 	PluginWebEngine.cpp \
-	SearchEngineInterface.cpp \
-	SherlockParser.cpp
+	SearchEngineInterface.cpp
+if HAVE_BOOST_SPIRIT
+libSearch_la_SOURCES += SherlockParser.cpp
+endif
 
 libSearchSOAP_la_SOURCES = \
 	SOAPEnvC.cpp \
@@ -48,6 +50,6 @@
 SOAPEnvC.cpp : SOAPEnv.h
 	soapcpp2 -pSOAPEnv SOAPEnv.h
 
-AM_CXXFLAGS = -I../Utils -I../Tokenize -I../Collect -IGoogle \
+AM_CXXFLAGS = -I$(srcdir)/../Utils -I$(srcdir)/../Tokenize -I$(srcdir)/../Collect -IGoogle \
 	@HTTP_CFLAGS@ @XML_CFLAGS@ @INDEX_CFLAGS@ @SOAP_CFLAGS@ @MIME_CFLAGS@ @GLIBMM_CFLAGS@
 

Modified: trunk/Search/PluginWebEngine.cpp
===================================================================
--- trunk/Search/PluginWebEngine.cpp	2006-08-26 10:21:08 UTC (rev 436)
+++ trunk/Search/PluginWebEngine.cpp	2006-08-26 11:43:57 UTC (rev 437)
@@ -21,7 +21,9 @@
 #include "Document.h"
 #include "StringManip.h"
 #include "OpenSearchParser.h"
+#ifdef HAVE_BOOST_SPIRIT_CORE_HPP
 #include "SherlockParser.h"
+#endif
 #include "PluginWebEngine.h"
 
 using std::cout;
@@ -148,11 +150,14 @@
 	}
 
 	string extension(fileName.substr(pos + 1));
+#ifdef HAVE_BOOST_SPIRIT_CORE_HPP
 	if (strncasecmp(extension.c_str(), "src", 3) == 0)
 	{
 		return new SherlockParser(fileName);
 	}
-	else if (strncasecmp(extension.c_str(), "xml", 3) == 0)
+	else
+#endif
+	if (strncasecmp(extension.c_str(), "xml", 3) == 0)
 	{
 		return new OpenSearchParser(fileName);
 	}

Modified: trunk/Tokenize/Makefile.am
===================================================================
--- trunk/Tokenize/Makefile.am	2006-08-26 10:21:08 UTC (rev 436)
+++ trunk/Tokenize/Makefile.am	2006-08-26 11:43:57 UTC (rev 437)
@@ -74,5 +74,5 @@
 	UnknownTypeTokenizer.cpp \
 	XmlTokenizer.cpp
 
-AM_CXXFLAGS = -fPIC -I../Utils @XML_CFLAGS@ @TAGLIB_CFLAGS@
+AM_CXXFLAGS = -fPIC -I$(srcdir)/../Utils @XML_CFLAGS@ @TAGLIB_CFLAGS@
 

Modified: trunk/Tokenize/TokenizerFactory.cpp
===================================================================
--- trunk/Tokenize/TokenizerFactory.cpp	2006-08-26 10:21:08 UTC (rev 436)
+++ trunk/Tokenize/TokenizerFactory.cpp	2006-08-26 11:43:57 UTC (rev 437)
@@ -32,6 +32,12 @@
 #include "Url.h"
 #include "TokenizerFactory.h"
 
+#ifdef __CYGWIN__
+#define DLOPEN_FLAGS RTLD_LAZY
+#else
+#define DLOPEN_FLAGS (RTLD_LAZY|RTLD_LOCAL)
+#endif
+
 #define GETTOKENIZERTYPES	"_Z17getTokenizerTypesRSt3setISsSt4lessISsESaISsEE"
 #define GETTOKENIZER		"_Z12getTokenizerPK8Document"
 
@@ -150,7 +156,7 @@
 				if ((stat(fileName.c_str(), &fileStat) == 0) &&
 					(S_ISREG(fileStat.st_mode)))
 				{
-					void *pHandle = dlopen(fileName.c_str(), RTLD_LAZY|RTLD_LOCAL);
+					void *pHandle = dlopen(fileName.c_str(), DLOPEN_FLAGS);
 					if (pHandle != NULL)
 					{
 						// What type(s) does this support ?

Modified: trunk/UI/GTK2/src/Makefile.am
===================================================================
--- trunk/UI/GTK2/src/Makefile.am	2006-08-26 10:21:08 UTC (rev 436)
+++ trunk/UI/GTK2/src/Makefile.am	2006-08-26 11:43:57 UTC (rev 437)
@@ -61,18 +61,18 @@
 
 bin_PROGRAMS = pinot pinot-dbus-daemon
 
-AM_CXXFLAGS = -I../../../Utils -I../../../Tokenize -I../../../SQL \
-	-I../../../Monitor -I../../../Collect -I../../../Search \
-	-I../../../Search/Google -I../../../Index \
+AM_CXXFLAGS = -I$(top_srcdir)/Utils -I$(top_srcdir)/Tokenize -I$(top_srcdir)/SQL \
+	-I$(top_srcdir)/Monitor -I$(top_srcdir)/Collect -I$(top_srcdir)/Search \
+	-I$(top_srcdir)/Search/Google -I$(top_srcdir)/Index \
 	@SQL_CFLAGS@ @HTTP_CFLAGS@ @MIME_CFLAGS@ @XML_CFLAGS@ @SOAP_CFLAGS@ @DBUS_CFLAGS@ @INDEX_CFLAGS@ @UI_CFLAGS@
 
-pinot_LDADD = -L../../../Utils -L../../../Tokenize -L../../../SQL -L../../../Monitor \
-	-L../../../Collect -L../../../Search -L../../../Search/Google \
-	-L../../../Index -lIndex @SEARCH_LIBS@ -lMonitor -lCollect -lSQL -lTokenize -lUtils \
+pinot_LDADD = -L$(top_srcdir)/Utils -L$(top_srcdir)/Tokenize -L$(top_srcdir)/SQL -L$(top_srcdir)/Monitor \
+	-L$(top_srcdir)/Collect -L$(top_srcdir)/Search -L$(top_srcdir)/Search/Google \
+	-L$(top_srcdir)/Index -lIndex @SEARCH_LIBS@ -lMonitor -lCollect -lSQL -lTokenize -lUtils \
 	@LIBS@ @UI_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ @SOAP_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
 
-pinot_dbus_daemon_LDADD = -L../../../Utils -L../../../Tokenize -L../../../SQL -L../../../Monitor \
-	-L../../../Collect -L../../../Search -L../../../Search/Google \
-	-L../../../Index -lIndex @SEARCH_LIBS@ -lMonitor -lCollect -lSQL -lTokenize -lUtils \
+pinot_dbus_daemon_LDADD = -L$(top_srcdir)/Utils -L$(top_srcdir)/Tokenize -L$(top_srcdir)/SQL -L$(top_srcdir)/Monitor \
+	-L$(top_srcdir)/Collect -L$(top_srcdir)/Search -L$(top_srcdir)/Search/Google \
+	-L$(top_srcdir)/Index -lIndex @SEARCH_LIBS@ -lMonitor -lCollect -lSQL -lTokenize -lUtils \
 	@LIBS@ @GLIBMM_LIBS@ @INDEX_LIBS@ @DBUS_LIBS@ @SOAP_LIBS@ @XML_LIBS@ @MIME_LIBS@ @HTTP_LIBS@ @SQL_LIBS@ @MISC_LIBS@
 

Modified: trunk/configure.in
===================================================================
--- trunk/configure.in	2006-08-26 10:21:08 UTC (rev 436)
+++ trunk/configure.in	2006-08-26 11:43:57 UTC (rev 437)
@@ -134,18 +134,25 @@
 XAPIAN_LIBS=`$XAPIAN_CONFIG --libs`
 
 dnl inotify
-haslinuxinotifyh="no"
+linuxinotify="no"
 AM_CONDITIONAL(HAVE_LINUX_INOTIFY, false)
 AC_CHECK_HEADERS([linux/inotify.h],
-   [haslinuxinotifyh="yes"
-    AC_DEFINE(HAVE_LINUX_INOTIFY, [],
-		[Define if linux/inotify.h exists.])
-    AM_CONDITIONAL(HAVE_LINUX_INOTIFY, true)
+   [linuxinotify="yes"
+   AM_CONDITIONAL(HAVE_LINUX_INOTIFY, true)
    ])
-if test "$haslinuxinotifyh" = "no" ; then
-   AC_CHECK_HEADERS(sys/inotify.h)
+if test "$linuxinotify" = "no" ; then
+   AC_CHECK_HEADERS([sys/inotify.h],
+   [linuxinotify="yes"
+   AM_CONDITIONAL(HAVE_LINUX_INOTIFY, true)
+   ])
 fi
 
+dnl boost Spirit 
+AM_CONDITIONAL(HAVE_BOOST_SPIRIT, false)
+AC_CHECK_HEADERS([boost/spirit/core.hpp],
+    [AM_CONDITIONAL(HAVE_BOOST_SPIRIT, true)
+    ])
+
 dnl Other libraries
 MISC_LIBS="-lcrypt"
 AC_SUBST(MISC_LIBS)



From fabricecolin at mail.berlios.de  Sat Aug 26 13:48:38 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sat, 26 Aug 2006 13:48:38 +0200
Subject: [Pinot-svn] r438 - trunk
Message-ID: <200608261148.k7QBmcCt018543@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-26 13:48:36 +0200 (Sat, 26 Aug 2006)
New Revision: 438

Modified:
   trunk/AUTHORS
Log:
Mention Reini's contribution.


Modified: trunk/AUTHORS
===================================================================
--- trunk/AUTHORS	2006-08-26 11:43:57 UTC (rev 437)
+++ trunk/AUTHORS	2006-08-26 11:48:36 UTC (rev 438)
@@ -2,6 +2,10 @@
 
 	Fabrice Colin <fabricecolin at users dot berlios dot de>
 
+Patches, bug reports and helpful comments :
+
+	Building with CygWin - Reini Urban <rurban at x-ray dot at>
+
 The file Monitor/linux-inotify-syscalls.h is originally from libinotify
 (Copyright ? 2005 Ryan Lortie <desrt at desrt dot ca>).
 



From fabricecolin at mail.berlios.de  Sun Aug 27 04:36:10 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sun, 27 Aug 2006 04:36:10 +0200
Subject: [Pinot-svn] r439 - in trunk: Monitor Search
Message-ID: <200608270236.k7R2aAQR022630@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-27 04:35:51 +0200 (Sun, 27 Aug 2006)
New Revision: 439

Modified:
   trunk/Monitor/Makefile.am
   trunk/Monitor/MonitorFactory.cpp
   trunk/Search/Makefile.am
   trunk/Search/PluginWebEngine.cpp
Log:
Fixed conditional building.


Modified: trunk/Monitor/Makefile.am
===================================================================
--- trunk/Monitor/Makefile.am	2006-08-26 11:48:36 UTC (rev 438)
+++ trunk/Monitor/Makefile.am	2006-08-27 02:35:51 UTC (rev 439)
@@ -21,4 +21,7 @@
 AM_CXXFLAGS = -I$(srcdir)/../Utils -I$(srcdir)/../Tokenize -I$(srcdir)/../SQL \
 	-I$(srcdir)/../Collect -I$(srcdir)/../Search -I$(srcdir)/../Index \
 	@HTTP_CFLAGS@ @XML_CFLAGS@ @INDEX_CFLAGS@ @SOAP_CFLAGS@ @MIME_CFLAGS@ @SIGCPP_CFLAGS@
+if HAVE_LINUX_INOTIFY
+AM_CXXFLAGS += -DHAVE_LINUX_INOTIFY
+endif
 

Modified: trunk/Monitor/MonitorFactory.cpp
===================================================================
--- trunk/Monitor/MonitorFactory.cpp	2006-08-26 11:48:36 UTC (rev 438)
+++ trunk/Monitor/MonitorFactory.cpp	2006-08-27 02:35:51 UTC (rev 439)
@@ -14,6 +14,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include "config.h"
 #ifdef HAVE_LINUX_INOTIFY
 #include "INotifyMonitor.h"
 #endif

Modified: trunk/Search/Makefile.am
===================================================================
--- trunk/Search/Makefile.am	2006-08-26 11:48:36 UTC (rev 438)
+++ trunk/Search/Makefile.am	2006-08-27 02:35:51 UTC (rev 439)
@@ -52,4 +52,7 @@
 
 AM_CXXFLAGS = -I$(srcdir)/../Utils -I$(srcdir)/../Tokenize -I$(srcdir)/../Collect -IGoogle \
 	@HTTP_CFLAGS@ @XML_CFLAGS@ @INDEX_CFLAGS@ @SOAP_CFLAGS@ @MIME_CFLAGS@ @GLIBMM_CFLAGS@
+if HAVE_BOOST_SPIRIT
+AM_CXXFLAGS += -DHAVE_BOOST_SPIRIT
+endif
 

Modified: trunk/Search/PluginWebEngine.cpp
===================================================================
--- trunk/Search/PluginWebEngine.cpp	2006-08-26 11:48:36 UTC (rev 438)
+++ trunk/Search/PluginWebEngine.cpp	2006-08-27 02:35:51 UTC (rev 439)
@@ -18,10 +18,11 @@
 #include <fstream>
 #include <iostream>
 
+#include "config.h"
 #include "Document.h"
 #include "StringManip.h"
 #include "OpenSearchParser.h"
-#ifdef HAVE_BOOST_SPIRIT_CORE_HPP
+#ifdef HAVE_BOOST_SPIRIT
 #include "SherlockParser.h"
 #endif
 #include "PluginWebEngine.h"



From fabricecolin at mail.berlios.de  Sun Aug 27 04:38:53 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Sun, 27 Aug 2006 04:38:53 +0200
Subject: [Pinot-svn] r440 - trunk/UI/GTK2/src
Message-ID: <200608270238.k7R2crP5023611@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-27 04:38:26 +0200 (Sun, 27 Aug 2006)
New Revision: 440

Modified:
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
   trunk/UI/GTK2/src/mainWindow.cc
Log:
Expand queries with ExpandQueryThread rather than QueryingThread.


Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-27 02:35:51 UTC (rev 439)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-27 02:38:26 UTC (rev 440)
@@ -709,19 +709,6 @@
 {
 }
 
-QueryingThread::QueryingThread(const string &engineName, const string &engineDisplayableName,
-	const string &engineOption, const QueryProperties &queryProps,
-	const set<unsigned int> &relevantDocs) :
-	WorkerThread(),
-	m_engineName(engineName),
-	m_engineDisplayableName(engineDisplayableName),
-	m_engineOption(engineOption),
-	m_queryProps(queryProps)
-{
-	copy(relevantDocs.begin(), relevantDocs.end(),
-		inserter(m_relevantDocs, m_relevantDocs.begin()));
-}
-
 QueryingThread::~QueryingThread()
 {
 }
@@ -751,11 +738,6 @@
 	return m_resultsList;
 }
 
-const set<string> &QueryingThread::getExpandTerms(void) const
-{
-	return m_expandTerms;
-}
-
 bool QueryingThread::stop(void)
 {
 	m_done = true;
@@ -779,11 +761,6 @@
 
 	// Set the maximum number of results
 	pEngine->setMaxResultsCount(m_queryProps.getMaximumResultsCount());
-	if (m_relevantDocs.empty() == false)
-	{
-		// Set whether to expand the query
-		pEngine->setQueryExpansion(m_relevantDocs);
-	}
 
 	// Run the query
 	if (pEngine->runQuery(m_queryProps) == false)
@@ -829,7 +806,77 @@
 				language,
 				resultIter->getScore()));
 		}
+	}
 
+	delete pEngine;
+}
+
+ExpandQueryThread::ExpandQueryThread(const string &engineName,
+	const string &engineOption, const QueryProperties &queryProps,
+	const set<unsigned int> &relevantDocs) :
+	WorkerThread(),
+	m_engineName(engineName),
+	m_engineOption(engineOption),
+	m_queryProps(queryProps)
+{
+	copy(relevantDocs.begin(), relevantDocs.end(),
+		inserter(m_relevantDocs, m_relevantDocs.begin()));
+}
+
+ExpandQueryThread::~ExpandQueryThread()
+{
+}
+
+string ExpandQueryThread::getType(void) const
+{
+	return "ExpandQueryThread";
+}
+
+QueryProperties ExpandQueryThread::getQuery(void) const
+{
+	return m_queryProps;
+}
+
+const set<string> &ExpandQueryThread::getExpandTerms(void) const
+{
+	return m_expandTerms;
+}
+
+bool ExpandQueryThread::stop(void)
+{
+	m_done = true;
+	m_status = _("Stopped expanding ");
+	m_status += " ";
+	m_status += m_queryProps.getName();
+	return true;
+}
+
+void ExpandQueryThread::doWork(void)
+{
+	// Get the SearchEngine
+	SearchEngineInterface *pEngine = SearchEngineFactory::getSearchEngine(m_engineName, m_engineOption);
+	if (pEngine == NULL)
+	{
+		m_status = _("Couldn't create search engine");
+		m_status += " ";
+		m_status += m_queryProps.getName();
+		return;
+	}
+
+	// Set the maximum number of results
+	pEngine->setMaxResultsCount(m_queryProps.getMaximumResultsCount());
+	// Set whether to expand the query
+	pEngine->setQueryExpansion(m_relevantDocs);
+
+	// Run the query
+	if (pEngine->runQuery(m_queryProps) == false)
+	{
+		m_status = _("Couldn't expand ");
+		m_status += " ";
+		m_status += m_queryProps.getName();
+	}
+	else
+	{
 		// Copy the expand terms
 		const set<string> &expandTerms = pEngine->getExpandTerms();
 		copy(expandTerms.begin(), expandTerms.end(),

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2006-08-27 02:35:51 UTC (rev 439)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2006-08-27 02:38:26 UTC (rev 440)
@@ -192,9 +192,6 @@
 	public:
 		QueryingThread(const std::string &engineName, const std::string &engineDisplayableName,
 			const std::string &engineOption, const QueryProperties &queryProps);
-		QueryingThread(const std::string &engineName, const std::string &engineDisplayableName,
-			const std::string &engineOption, const QueryProperties &queryProps,
-			const std::set<unsigned int> &relevantDocs);
 		virtual ~QueryingThread();
 
 		virtual std::string getType(void) const;
@@ -205,8 +202,6 @@
 
 		const std::vector<Result> &getResults(std::string &charset) const;
 
-		const std::set<std::string> &getExpandTerms(void) const;
-
 		virtual bool stop(void);
 
 	protected:
@@ -214,7 +209,6 @@
 		std::string m_engineDisplayableName;
 		std::string m_engineOption;
 		QueryProperties m_queryProps;
-		std::set<unsigned int> m_relevantDocs;
 		std::vector<Result> m_resultsList;
 		std::string m_resultsCharset;
 		std::set<std::string> m_expandTerms;
@@ -227,6 +221,36 @@
 
 };
 
+class ExpandQueryThread : public WorkerThread
+{
+	public:
+		ExpandQueryThread(const std::string &engineName, const std::string &engineOption,
+			const QueryProperties &queryProps, const std::set<unsigned int> &relevantDocs);
+		virtual ~ExpandQueryThread();
+
+		virtual std::string getType(void) const;
+
+		QueryProperties getQuery(void) const;
+
+		const std::set<std::string> &getExpandTerms(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		std::string m_engineName;
+		std::string m_engineOption;
+		QueryProperties m_queryProps;
+		std::set<unsigned int> m_relevantDocs;
+		std::set<std::string> m_expandTerms;
+
+		virtual void doWork(void);
+
+	private:
+		ExpandQueryThread(const ExpandQueryThread &other);
+		ExpandQueryThread &operator=(const ExpandQueryThread &other);
+
+};
+
 class LabelUpdateThread : public WorkerThread
 {
 	public:

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2006-08-27 02:35:51 UTC (rev 439)
+++ trunk/UI/GTK2/src/mainWindow.cc	2006-08-27 02:38:26 UTC (rev 440)
@@ -989,62 +989,68 @@
 				m_state.queue_index(docInfo);
 			}
 		}
+	}
+	else if (type == "ExpandQueryThread")
+	{
+		ExpandQueryThread *pExpandThread = dynamic_cast<ExpandQueryThread *>(pThread);
+		if (pExpandThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
 
-		// Any expand terms ?
-		const set<string> &expandTerms = pQueryThread->getExpandTerms();
-		if (expandTerms.empty() == false)
+		QueryProperties queryProps = pExpandThread->getQuery();
+		const set<string> &expandTerms = pExpandThread->getExpandTerms();
+		string queryName(_("More Like"));
+		string moreLike;
+
+		if (queryProps.getName().empty() == true)
 		{
-			string queryName(_("More Like"));
-			string moreLike;
+			queryName += "...";
+		}
+		else
+		{
+			queryName += " ";
+			queryName += queryProps.getName();
+		}
+		queryProps.setName(queryName);
 
-			if (queryProps.getName().empty() == true)
+		if (queryProps.getAnyWords().empty() == false)
+		{
+			moreLike = " ";
+		}
+		for (set<string>::const_iterator termIter = expandTerms.begin();
+			termIter != expandTerms.end(); ++termIter)
+		{
+			if (moreLike.empty() == false)
 			{
-				queryName += "...";
+				moreLike += " ";
 			}
-			else
-			{
-				queryName += " ";
-				queryName += queryProps.getName();
-			}
-			queryProps.setName(queryName);
+			moreLike += *termIter;
+		}
 
-			moreLike.clear();
-			if (queryProps.getAnyWords().empty() == false)
-			{
-				moreLike = " ";
-			}
-			for (set<string>::const_iterator termIter = expandTerms.begin();
-				termIter != expandTerms.end(); ++termIter)
-			{
-				if (moreLike.empty() == false)
-				{
-					moreLike += " ";
-				}
-				moreLike += *termIter;
-			}
+		// Does such a query already exist ?
+		TreeModel::Children children = m_refQueryTree->children();
+		for (TreeModel::Children::iterator iter = children.begin();
+			iter != children.end(); ++iter)
+		{
+			TreeModel::Row row = *iter;
 
-			// Does such a query already exist ?
-			TreeModel::Children children = m_refQueryTree->children();
-			for (TreeModel::Children::iterator iter = children.begin();
-				iter != children.end(); ++iter)
+			if (queryName == from_utf8(row[m_queryColumns.m_name]))
 			{
-				TreeModel::Row row = *iter;
-
-				if (queryName == from_utf8(row[m_queryColumns.m_name]))
-				{
-					m_settings.removeQuery(queryName);
-					break;
-				}
+				m_settings.removeQuery(queryName);
+				break;
 			}
+		}
 
-			// Add these terms
-			queryProps.setAnyWords(queryProps.getAnyWords() + moreLike);
+		// Add these terms
+		queryProps.setAnyWords(queryProps.getAnyWords() + moreLike);
 
-			// Update everything
-			if (m_settings.addQuery(queryProps) == true)
-			{
-				populate_queryTreeview(queryName);
-			}
+		// Update everything
+		if (m_settings.addQuery(queryProps) == true)
+		{
+			populate_queryTreeview(queryName);
+			queryExpander->set_expanded(true);
 		}
 	}
 	else if (type == "LabelUpdateThread")
@@ -1732,7 +1738,7 @@
 			}
 
 			// Spawn a new thread
-			start_thread(new QueryingThread("xapian", "", "MERGED",
+			start_thread(new ExpandQueryThread("xapian", "MERGED",
 				queryProps, docIdList));
 		}
 



From fabricecolin at mail.berlios.de  Mon Aug 28 13:22:24 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Mon, 28 Aug 2006 13:22:24 +0200
Subject: [Pinot-svn] r441 - trunk/UI/GTK2/src
Message-ID: <200608281122.k7SBMOQX002989@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-28 13:22:21 +0200 (Mon, 28 Aug 2006)
New Revision: 441

Modified:
   trunk/UI/GTK2/src/prefsDialog.cc
Log:
Not all preferences were saved !


Modified: trunk/UI/GTK2/src/prefsDialog.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.cc	2006-08-27 02:38:26 UTC (rev 440)
+++ trunk/UI/GTK2/src/prefsDialog.cc	2006-08-28 11:22:21 UTC (rev 441)
@@ -327,8 +327,9 @@
 	m_settings.m_suggestQueryTerms = enableCompletionCheckbutton->get_active();
 	m_settings.m_googleAPIKey = apiKeyEntry->get_text();
 
-	// Validate the current labels and mail accounts
+	// Validate the current lists
 	save_labelsTreeview();
+	save_directoriesTreeview();
 	save_mailTreeview();
 }
 



From fabricecolin at mail.berlios.de  Tue Aug 29 15:32:16 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Tue, 29 Aug 2006 15:32:16 +0200
Subject: [Pinot-svn] r442 - in trunk: Index UI/GTK2/src
Message-ID: <200608291332.k7TDWGd2020344@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-29 15:31:28 +0200 (Tue, 29 Aug 2006)
New Revision: 442

Removed:
   trunk/Index/WritableXapianIndex.cpp
   trunk/Index/WritableXapianIndex.h
Modified:
   trunk/Index/DBusXapianIndex.cpp
   trunk/Index/DBusXapianIndex.h
   trunk/Index/IndexFactory.cpp
   trunk/Index/IndexFactory.h
   trunk/Index/IndexInterface.h
   trunk/Index/Makefile.am
   trunk/Index/XapianIndex.cpp
   trunk/Index/XapianIndex.h
   trunk/Index/pinot-index.cpp
   trunk/UI/GTK2/src/DaemonState.cpp
   trunk/UI/GTK2/src/MboxHandler.cpp
   trunk/UI/GTK2/src/MboxHandler.h
   trunk/UI/GTK2/src/OnDiskHandler.cpp
   trunk/UI/GTK2/src/OnDiskHandler.h
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/PinotSettings.h
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/pinot-dbus-daemon.cc
Log:
On second thought, merged WritableXapianIndex back into XapianIndex. This
complicated matters unnecessarily, especially since R/W access is handled so
nicely by XapianDatabase.


Modified: trunk/Index/DBusXapianIndex.cpp
===================================================================
--- trunk/Index/DBusXapianIndex.cpp	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/Index/DBusXapianIndex.cpp	2006-08-29 13:31:28 UTC (rev 442)
@@ -64,13 +64,11 @@
 }
 
 DBusXapianIndex::DBusXapianIndex(const string &indexName) :
-	WritableIndexInterface(),
 	XapianIndex(indexName)
 {
 }
 
 DBusXapianIndex::DBusXapianIndex(const DBusXapianIndex &other) :
-	WritableIndexInterface(other),
 	XapianIndex(other)
 {
 }
@@ -81,7 +79,6 @@
 
 DBusXapianIndex &DBusXapianIndex::operator=(const DBusXapianIndex &other)
 {
-	WritableIndexInterface::operator=(other);
 	XapianIndex::operator=(other);
 	return *this;
 }
@@ -93,8 +90,10 @@
 	{
 		// Re-open the database to the latest available version
 		pDatabase->reopen();
+#ifdef DEBUG
+		cout << "DBusXapianIndex::reopen: done" << endl;
+#endif
 	}
-
 }
 
 //
@@ -187,10 +186,6 @@
 	return XapianIndex::listDocumentsWithLabel(name, docIds, maxDocsCount, startDoc);
 }
 
-//
-// Implementation of WritableIndexInterface
-//
-
 /// Indexes the given data.
 bool DBusXapianIndex::indexDocument(Tokenizer &tokens, const set<string> &labels,
 	unsigned int &docId)

Modified: trunk/Index/DBusXapianIndex.h
===================================================================
--- trunk/Index/DBusXapianIndex.h	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/Index/DBusXapianIndex.h	2006-08-29 13:31:28 UTC (rev 442)
@@ -22,7 +22,7 @@
 
 #include "XapianIndex.h"
 
-class DBusXapianIndex : public WritableIndexInterface, private XapianIndex
+class DBusXapianIndex : public XapianIndex
 {
 	public:
 		DBusXapianIndex(const std::string &indexName);

Modified: trunk/Index/IndexFactory.cpp
===================================================================
--- trunk/Index/IndexFactory.cpp	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/Index/IndexFactory.cpp	2006-08-29 13:31:28 UTC (rev 442)
@@ -16,7 +16,6 @@
 
 #include "XapianIndex.h"
 #include "DBusXapianIndex.h"
-#include "WritableXapianIndex.h"
 #include "IndexFactory.h"
 
 using std::string;
@@ -29,18 +28,11 @@
 {
 }
 
-/// Returns a read-only index of the specified type; NULL if unavailable.
-IndexInterface *IndexFactory::getROIndex(const string &type, const string &option)
+/// Returns an index of the specified type; NULL if unavailable.
+IndexInterface *IndexFactory::getIndex(const string &type, const string &option)
 {
-	// Whatever the type, all read-only operations can be performed with XapianIndex
-	return new XapianIndex(option);
-}
+	IndexInterface *pIndex = NULL;
 
-/// Returns a read-write index of the specified type; NULL if unavailable.
-WritableIndexInterface *IndexFactory::getRWIndex(const string &type, const string &option)
-{
-	WritableIndexInterface *pIndex = NULL;
-
 	// Choice by type
 	if (type == "dbus")
 	{
@@ -48,7 +40,7 @@
 	}
 	else if (type == "xapian")
 	{
-		pIndex = new WritableXapianIndex(option);
+		pIndex = new XapianIndex(option);
 	}
 
 	return pIndex;

Modified: trunk/Index/IndexFactory.h
===================================================================
--- trunk/Index/IndexFactory.h	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/Index/IndexFactory.h	2006-08-29 13:31:28 UTC (rev 442)
@@ -26,12 +26,9 @@
 	public:
 		virtual ~IndexFactory();
 
-		/// Returns a read-only index of the specified type; NULL if unavailable.
-		static IndexInterface *getROIndex(const std::string &type, const std::string &option);
+		/// Returns an index of the specified type; NULL if unavailable.
+		static IndexInterface *getIndex(const std::string &type, const std::string &option);
 
-		/// Returns a read-write index of the specified type; NULL if unavailable.
-		static WritableIndexInterface *getRWIndex(const std::string &type, const std::string &option);
-
 	protected:
 		IndexFactory();
 

Modified: trunk/Index/IndexInterface.h
===================================================================
--- trunk/Index/IndexInterface.h	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/Index/IndexInterface.h	2006-08-29 13:31:28 UTC (rev 442)
@@ -23,15 +23,22 @@
 #include "Tokenizer.h"
 #include "DocumentInfo.h"
 
-/// Interface implemented by read-only indexes.
+/// Interface implemented by indexes.
 class IndexInterface
 {
 	public:
-		IndexInterface(const IndexInterface &other) {};
+		IndexInterface(const IndexInterface &other) :
+			m_stemMode(other.m_stemMode) {};
 		virtual ~IndexInterface() {};
 
-		IndexInterface &operator=(const IndexInterface &other) {};
+		IndexInterface &operator=(const IndexInterface &other)
+		{
+			m_stemMode = other.m_stemMode;
+			return *this;
+		};
 
+		typedef enum { STORE_UNSTEM = 0, STORE_STEM, STORE_BOTH } StemmingMode;
+
 		/// Returns false if the index couldn't be opened.
 		virtual bool isGood(void) const = 0;
 
@@ -67,28 +74,6 @@
 		virtual bool listDocumentsWithLabel(const std::string &name, std::set<unsigned int> &docIds,
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const = 0;
 
-	protected:
-		IndexInterface() { };
-
-};
-
-/// Interface implemented by read-write indexes.
-class WritableIndexInterface : public IndexInterface
-{
-	public:
-		WritableIndexInterface(const WritableIndexInterface &other) :
-			IndexInterface(other), m_stemMode(other.m_stemMode) {};
-		virtual ~WritableIndexInterface() {};
-
-		WritableIndexInterface &operator=(const WritableIndexInterface &other)
-		{
-			IndexInterface::operator=(other);
-			m_stemMode = other.m_stemMode;
-			return *this;
-		};
-
-		typedef enum { STORE_UNSTEM = 0, STORE_STEM, STORE_BOTH } StemmingMode;
-
 		/// Sets the stemming mode.
 		virtual void setStemmingMode(StemmingMode mode) { m_stemMode = mode; }
 
@@ -124,8 +109,7 @@
 	protected:
 		StemmingMode m_stemMode;
 
-		WritableIndexInterface() :
-			IndexInterface(), m_stemMode(STORE_UNSTEM) { };
+		IndexInterface() { };
 
 };
 

Modified: trunk/Index/Makefile.am
===================================================================
--- trunk/Index/Makefile.am	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/Index/Makefile.am	2006-08-29 13:31:28 UTC (rev 442)
@@ -5,7 +5,6 @@
 	IndexFactory.h \
 	IndexInterface.h \
 	LanguageDetector.h \
-	WritableXapianIndex.h \
 	XapianIndex.h
 
 noinst_LTLIBRARIES = libIndex.la
@@ -16,7 +15,6 @@
 	DBusXapianIndex.cpp \
 	IndexFactory.cpp \
 	LanguageDetector.cpp \
-	WritableXapianIndex.cpp \
 	XapianIndex.cpp
 
 pinot_index_SOURCES = \

Deleted: trunk/Index/WritableXapianIndex.cpp
===================================================================
--- trunk/Index/WritableXapianIndex.cpp	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/Index/WritableXapianIndex.cpp	2006-08-29 13:31:28 UTC (rev 442)
@@ -1,1085 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <stdarg.h>
-#include <strings.h>
-#include <time.h>
-#include <ctype.h>
-#include <regex.h>
-#include <iostream>
-#include <fstream>
-#include <algorithm>
-#include <utility>
-
-#include "Languages.h"
-#include "StringManip.h"
-#include "TimeConverter.h"
-#include "Url.h"
-#include "LanguageDetector.h"
-#include "XapianDatabaseFactory.h"
-#include "WritableXapianIndex.h"
-
-using std::cout;
-using std::cerr;
-using std::endl;
-using std::string;
-using std::set;
-using std::min;
-
-static void removeFirstPosting(Xapian::Document &doc,
-	Xapian::TermIterator &termListIter, const string &term)
-{
-	termListIter.skip_to(term);
-
-	Xapian::PositionIterator firstPosIter = termListIter.positionlist_begin();
-	if (firstPosIter != termListIter.positionlist_end())
-	{
-		try
-		{
-			doc.remove_posting(term, *firstPosIter);
-		}
-		catch (const Xapian::Error &error)
-		{
-			// This posting may have been removed already
-#ifdef DEBUG
-			cout << "WritableXapianIndex::removeFirstPosting: " << error.get_msg() << endl;
-#endif
-		}
-	}
-}
-
-WritableXapianIndex::WritableXapianIndex(const string &indexName) :
-	WritableIndexInterface(),
-	XapianIndex(indexName)
-{
-	// Open in read/write mode
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if ((pDatabase != NULL) &&
-		(pDatabase->isOpen() == true))
-	{
-		m_goodIndex = true;
-	}
-}
-
-WritableXapianIndex::WritableXapianIndex(const WritableXapianIndex &other) :
-	WritableIndexInterface(other),
-	XapianIndex(other),
-	m_stemLanguage(other.m_stemLanguage)
-{
-}
-
-WritableXapianIndex::~WritableXapianIndex()
-{
-}
-
-WritableXapianIndex &WritableXapianIndex::operator=(const WritableXapianIndex &other)
-{
-	WritableIndexInterface::operator=(other);
-	XapianIndex::operator=(other);
-	m_stemLanguage = other.m_stemLanguage;
-	return *this;
-}
-
-bool WritableXapianIndex::badField(const string &field)
-{
-	regex_t fieldRegex;
-	regmatch_t pFieldMatches[1];
-	bool isBadField = false;
-
-	// A bad field is one that includes one of our field delimiters
-	if (regcomp(&fieldRegex,
-		"(url|sample|caption|type|timestamp|language)=",
-		REG_EXTENDED|REG_ICASE) == 0)
-	{
-		if (regexec(&fieldRegex, field.c_str(), 1,
-			pFieldMatches, REG_NOTBOL|REG_NOTEOL) == 0)
-		{
-			isBadField = true;
-		}
-	}
-	regfree(&fieldRegex);
-
-	return isBadField;
-}
-
-void WritableXapianIndex::addPostingsToDocument(Tokenizer &tokens, Xapian::Document &doc,
-	const string &prefix, Xapian::termcount &termPos, StemmingMode mode) const
-{
-	Xapian::Stem *pStemmer = NULL;
-	string term;
-
-	// Do we know what language to use for stemming ?
-	if (m_stemLanguage.empty() == false)
-	{
-		pStemmer = new Xapian::Stem(StringManip::toLowerCase(m_stemLanguage));
-	}
-
-	// Get the terms
-	while (tokens.nextToken(term) == true)
-	{
-		if (term.empty() == true)
-		{
-			continue;
-		}
-		// Does it start with a capital letter ?
-		if (isupper((int)term[0]) != 0)
-		{
-			// R-prefix the raw term
-			doc.add_posting(string("R") + term, termPos);
-		}
-		// Lower case the term
-		term = StringManip::toLowerCase(term);
-
-		// Stem the term ?
-		if ((mode == STORE_UNSTEM) ||
-			(pStemmer == NULL))
-		{
-			doc.add_posting(limitTermLength(prefix + term), termPos++);
-		}
-		else if (mode == STORE_STEM)
-		{
-			string stemmedTerm = pStemmer->stem_word(term);
-
-			doc.add_posting(limitTermLength(prefix + stemmedTerm), termPos++);
-		}
-		else if (mode == STORE_BOTH)
-		{
-			string stemmedTerm = pStemmer->stem_word(term);
-
-			// Add both
-			doc.add_posting(limitTermLength(prefix + term), termPos);
-			// ...at the same position
-			doc.add_posting(limitTermLength(prefix + stemmedTerm), termPos++);
-		}
-	}
-#ifdef DEBUG
-	cout << "WritableXapianIndex::addPostingsToDocument: added " << termPos << " terms" << endl;
-#endif
-
-	if (pStemmer != NULL)
-	{
-		delete pStemmer;
-	}
-}
-
-void WritableXapianIndex::removeFirstPostingsFromDocument(Tokenizer &tokens, Xapian::Document &doc,
-	const string &prefix, const string &language, StemmingMode mode) const
-{
-	Xapian::TermIterator termListIter = doc.termlist_begin();
-	Xapian::Stem *pStemmer = NULL;
-	string term;
-
-	// Do we know what language to use for stemming ?
-	if (language.empty() == false)
-	{
-		pStemmer = new Xapian::Stem(StringManip::toLowerCase(language));
-	}
-
-	// Get the terms and remove the first posting for each
-	while (tokens.nextToken(term) == true)
-	{
-		if (term.empty() == true)
-		{
-			continue;
-		}
-		// Does it start with a capital letter ?
-		if (isupper((int)term[0]) != 0)
-		{
-			// R-prefix the raw term
-			removeFirstPosting(doc, termListIter, string("R") + term);
-		}
-		// Lower case the term
-		term = StringManip::toLowerCase(term);
-
-		// Stem the term ?
-		if ((mode == STORE_UNSTEM) ||
-			(pStemmer == NULL))
-		{
-			removeFirstPosting(doc, termListIter, limitTermLength(prefix + term));
-		}
-		else if (mode == STORE_STEM)
-		{
-			removeFirstPosting(doc, termListIter, limitTermLength(prefix + pStemmer->stem_word(term)));
-		}
-		else if (mode == STORE_BOTH)
-		{
-			removeFirstPosting(doc, termListIter, limitTermLength(prefix + term));
-			removeFirstPosting(doc, termListIter, limitTermLength(prefix + pStemmer->stem_word(term)));
-		}
-	}
-
-	if (pStemmer != NULL)
-	{
-		delete pStemmer;
-	}
-}
-
-bool WritableXapianIndex::addCommonTerms(const DocumentInfo &info, Xapian::Document &doc,
-	Xapian::termcount &termPos) const
-{
-	string title(info.getTitle());
-	string location(info.getLocation());
-	Url urlObj(location);
-
-	// Add a magic term :-)
-	doc.add_term(MAGIC_TERM);
-
-	// Index the title with and without prefix S
-	if (title.empty() == false)
-	{
-		Document titleDoc;
-		titleDoc.setData(title.c_str(), title.length());
-		Tokenizer titleTokens(&titleDoc);
-		addPostingsToDocument(titleTokens, doc, "S", termPos, STORE_UNSTEM);
-		titleTokens.rewind();
-		addPostingsToDocument(titleTokens, doc, "", termPos, m_stemMode);
-	}
-
-	// Index the full URL with prefix U
-	doc.add_term(limitTermLength(string("U") + location, true));
-	// ...the host name and included domains with prefix H
-	string hostName(StringManip::toLowerCase(urlObj.getHost()));
-	if (hostName.empty() == false)
-	{
-		doc.add_term(limitTermLength(string("H") + hostName, true));
-		string::size_type dotPos = hostName.find('.');
-		while (dotPos != string::npos)
-		{
-			doc.add_term(limitTermLength(string("H") + hostName.substr(dotPos + 1), true));
-
-			// Next
-			dotPos = hostName.find('.', dotPos + 1);
-		}
-	}
-	// ...the location (as is) and all directories with prefix XDIR:
-	string tree(urlObj.getLocation());
-	if (tree.empty() == false)
-	{
-		doc.add_term(limitTermLength(string("XDIR:") + tree, true));
-		string::size_type slashPos = tree.find('/', 1);
-		while (slashPos != string::npos)
-		{
-			doc.add_term(limitTermLength(string("XDIR:") + tree.substr(0, slashPos), true));
-
-			// Next
-			slashPos = tree.find('/', slashPos + 1);
-		}
-	}
-	// ...and the file name with prefix P
-	string fileName(urlObj.getFile());
-	if (fileName.empty() == false)
-	{
-		doc.add_term(limitTermLength(string("P") + StringManip::toLowerCase(fileName), true));
-	}
-	// Finally, add the language code with prefix L
-	doc.add_term(string("L") + Languages::toCode(m_stemLanguage));
-	// ...and the MIME type with prefix T
-	doc.add_term(string("T") + info.getType());
-
-	return true;
-}
-
-void WritableXapianIndex::removeCommonTerms(Xapian::Document &doc)
-{
-	DocumentInfo docInfo;
-	string record(doc.get_data());
-
-	// First, remove the magic term
-	doc.remove_term(MAGIC_TERM);
-
-	if (record.empty() == true)
-        {
-		// Nothing else we can do
-		return;
-	}
-
-	string language(StringManip::extractField(record, "language=", ""));
-	docInfo = DocumentInfo(StringManip::extractField(record, "caption=", "\n"),
-		StringManip::extractField(record, "url=", "\n"),
-		StringManip::extractField(record, "type=", "\n"),
-		Languages::toLocale(language));
-	docInfo.setTimestamp(StringManip::extractField(record, "timestamp=", "\n"));
-	Url urlObj(docInfo.getLocation());
-
-	// FIXME: remove terms extracted from the title if they don't have more than one posting
-	string title(docInfo.getTitle());
-	if (title.empty() == false)
-	{
-		Document titleDoc;
-		titleDoc.setData(title.c_str(), title.length());
-		Tokenizer titleTokens(&titleDoc);
-		removeFirstPostingsFromDocument(titleTokens, doc, "S", language, STORE_UNSTEM);
-		titleTokens.rewind();
-		removeFirstPostingsFromDocument(titleTokens, doc, "", language, m_stemMode);
-	}
-
-	// Title
-	doc.remove_term(limitTermLength(string("U") + docInfo.getLocation(), true));
-	// Host name
-	string hostName(StringManip::toLowerCase(urlObj.getHost()));
-	if (hostName.empty() == false)
-	{
-		doc.remove_term(limitTermLength(string("H") + hostName, true));
-		string::size_type dotPos = hostName.find('.');
-		while (dotPos != string::npos)
-		{
-			doc.remove_term(limitTermLength(string("H") + hostName.substr(dotPos + 1), true));
-
-			// Next
-			dotPos = hostName.find('.', dotPos + 1);
-		}
-	}
-	// ...location
-	string tree(urlObj.getLocation());
-	if (tree.empty() == false)
-	{
-		doc.remove_term(limitTermLength(string("XDIR:") + tree, true));
-		string::size_type slashPos = tree.find('/', 1);
-		while (slashPos != string::npos)
-		{
-			doc.remove_term(limitTermLength(string("XDIR:") + tree.substr(0, slashPos), true));
-
-			// Next
-			slashPos = tree.find('/', slashPos + 1);
-		}
-	}
-	// ...and file name
-	string fileName(urlObj.getFile());
-	if (fileName.empty() == false)
-	{
-		doc.remove_term(limitTermLength(string("P") + StringManip::toLowerCase(fileName), true));
-	}
-	// Language code
-	doc.remove_term(string("L") + Languages::toCode(language));
-	// MIME type
-	doc.remove_term(string("T") + docInfo.getType());
-}
-
-string WritableXapianIndex::scanDocument(const char *pData, unsigned int dataLength,
-	DocumentInfo &info)
-{
-	vector<string> candidates;
-	string language;
-
-	// Try to determine the document's language
-	LanguageDetector lang;
-	lang.guessLanguage(pData, max(dataLength, (unsigned int)2048), candidates);
-
-	// See which of these languages is suitable for stemming
-	for (vector<string>::iterator langIter = candidates.begin(); langIter != candidates.end(); ++langIter)
-	{
-		if (*langIter == "unknown")
-		{
-			continue;
-		}
-
-		try
-		{
-			Xapian::Stem stemmer(*langIter);
-		}
-		catch (const Xapian::Error &error)
-		{
-			cerr << "WritableXapianIndex::scanDocument: " << error.get_type() << ": " << error.get_msg() << endl;
-			continue;
-		}
-
-		language = *langIter;
-		break;
-	}
-#ifdef DEBUG
-	cout << "WritableXapianIndex::scanDocument: language " << language << endl;
-#endif
-
-	// Update the document's properties
-	info.setLanguage(language);
-
-	return language;
-}
-
-void WritableXapianIndex::setDocumentData(const DocumentInfo &info, Xapian::Document &doc,
-	const string &language) const
-{
-	string title(info.getTitle());
-	string timestamp(info.getTimestamp());
-	char timeStr[64];
-
-	// Set the document data omindex-style
-	string record = "url=";
-	record += info.getLocation();
-	// The sample will be generated at query time
-	record += "\nsample=";
-	record += "\ncaption=";
-	if (badField(title) == true)
-	{
-		// Modify the title if necessary
-		string::size_type pos = title.find("=");
-		while (pos != string::npos)
-		{
-			title[pos] = ' ';
-			pos = title.find("=", pos + 1);
-		}
-#ifdef DEBUG
-		cout << "WritableXapianIndex::setDocumentData: modified title" << endl;
-#endif
-	}
-	record += title;
-	record += "\ntype=";
-	record += info.getType();
-	// Append a timestamp
-	record += "\ntimestamp=";
-	record += timestamp;
-	// ...and the language
-	record += "\nlanguage=";
-	record += StringManip::toLowerCase(language);
-#ifdef DEBUG
-	cout << "WritableXapianIndex::setDocumentData: document data is " << record << endl;
-#endif
-	doc.set_data(record);
-
-	// Add this value to allow sorting by date
-	snprintf(timeStr, 64, "%d", TimeConverter::fromTimestamp(timestamp));
-	doc.add_value(0, timeStr);
-}
-
-bool WritableXapianIndex::listDocumentsWithTerm(const string &term, set<unsigned int> &docIds,
-	unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	unsigned int docCount = 0;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return 0;
-	}
-
-	docIds.clear();
-	try
-	{
-		Xapian::Database *pIndex = pDatabase->readLock();
-		if (pIndex != NULL)
-		{
-#ifdef DEBUG
-			cout << "WritableXapianIndex::listDocumentsWithTerm: term " << term << endl;
-#endif
-			// Get a list of documents that have the term
-			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
-				(postingIter != pIndex->postlist_end(term)) &&
-					((maxDocsCount == 0) || (docIds.size() < maxDocsCount));
-				++postingIter)
-			{
-				Xapian::docid docId = *postingIter;
-
-				// We cannot use postingIter->skip_to() because startDoc isn't an ID
-				if (docCount >= startDoc)
-				{
-					docIds.insert(docId);
-				}
-				++docCount;
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't get document list: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't get document list, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return docIds.size();
-}
-
-//
-// Implementation of IndexInterface
-//
-
-/// Returns false if the index couldn't be opened.
-bool WritableXapianIndex::isGood(void) const
-{
-	return XapianIndex::isGood();
-}
-
-/// Gets the index location.
-string WritableXapianIndex::getLocation(void) const
-{
-	return XapianIndex::getLocation();
-}
-
-/// Returns a document's properties.
-bool WritableXapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
-{
-	return XapianIndex::getDocumentInfo(docId, docInfo);
-}
-
-/// Determines whether a document has a label.
-bool WritableXapianIndex::hasLabel(unsigned int docId, const string &name) const
-{
-	return XapianIndex::hasLabel(docId, name);
-}
-
-/// Returns a document's labels.
-bool WritableXapianIndex::getDocumentLabels(unsigned int docId, set<string> &labels) const
-{
-	return XapianIndex::getDocumentLabels(docId, labels);
-}
-
-/// Checks whether the given URL is in the index.
-unsigned int WritableXapianIndex::hasDocument(const string &url) const
-{
-	return XapianIndex::hasDocument(url);
-}
-
-/// Gets terms with the same root.
-unsigned int WritableXapianIndex::getCloseTerms(const string &term, set<string> &suggestions)
-{
-	return XapianIndex::getCloseTerms(term, suggestions);
-}
-
-/// Returns the ID of the last document.
-unsigned int WritableXapianIndex::getLastDocumentID(void) const
-{
-	return XapianIndex::getLastDocumentID();
-}
-
-/// Returns the number of documents.
-unsigned int WritableXapianIndex::getDocumentsCount(const string &labelName) const
-{
-	return XapianIndex::getDocumentsCount(labelName);
-}
-
-/// Lists document IDs.
-unsigned int WritableXapianIndex::listDocuments(set<unsigned int> &docIds,
-	unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	return XapianIndex::listDocuments(docIds, maxDocsCount, startDoc);
-}
-
-/// Lists documents that have a label.
-bool WritableXapianIndex::listDocumentsWithLabel(const string &name, set<unsigned int> &docIds,
-	unsigned int maxDocsCount, unsigned int startDoc) const
-{
-	return XapianIndex::listDocumentsWithLabel(name, docIds, maxDocsCount, startDoc);
-}
-
-//
-// Implementation of WritableIndexInterface
-//
-
-/// Indexes the given data.
-bool WritableXapianIndex::indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
-	unsigned int &docId)
-{
-	unsigned int dataLength = 0;
-	bool indexed = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		// Get the document
-		const Document *pDocument = tokens.getDocument();
-		if (pDocument == NULL)
-		{
-#ifdef DEBUG
-			cout << "WritableXapianIndex::indexDocument: no document" << endl;
-#endif
-			return false;
-		}
-
-		// Cache the document's properties
-		DocumentInfo docInfo(pDocument->getTitle(), pDocument->getLocation(),
-			pDocument->getType(), pDocument->getLanguage());
-		docInfo.setTimestamp(pDocument->getTimestamp());
-		docInfo.setLocation(Url::canonicalizeUrl(docInfo.getLocation()));
-
-		const char *pData = pDocument->getData(dataLength);
-		if (pData != NULL)
-		{
-			m_stemLanguage = scanDocument(pData, dataLength, docInfo);
-		}
-
-		Xapian::Document doc;
-		Xapian::termcount termPos = 0;
-
-#ifdef DEBUG
-		cout << "WritableXapianIndex::indexDocument: adding terms" << endl;
-#endif
-		// Add the tokenizer's terms to the Xapian document
-		addPostingsToDocument(tokens, doc, "", termPos, m_stemMode);
-		// Add labels
-		for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
-			++labelIter)
-		{
-			doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
-		}
-		if (addCommonTerms(docInfo, doc, termPos) == true)
-		{
-			setDocumentData(docInfo, doc, m_stemLanguage);
-
-			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-			if (pIndex != NULL)
-			{
-				// Add this document to the Xapian index
-				docId = pIndex->add_document(doc);
-				indexed = true;
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't index document: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't index document, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return indexed;
-}
-
-/// Updates the given document; true if success.
-bool WritableXapianIndex::updateDocument(unsigned int docId, Tokenizer &tokens)
-{
-	unsigned int dataLength = 0;
-	bool updated = false;
-
-	const Document *pDocument = tokens.getDocument();
-	if (pDocument == NULL)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	const char *pData = pDocument->getData(dataLength);
-	if (pData == NULL)
-	{
-		return false;
-	}
-
-	// Cache the document's properties
-	DocumentInfo docInfo(pDocument->getTitle(), pDocument->getLocation(),
-		pDocument->getType(), pDocument->getLanguage());
-	docInfo.setTimestamp(pDocument->getTimestamp());
-	docInfo.setLocation(Url::canonicalizeUrl(docInfo.getLocation()));
-
-	// Don't scan the document if a language is specified
-	m_stemLanguage = Languages::toEnglish(pDocument->getLanguage());
-	if (m_stemLanguage.empty() == true)
-	{
-		m_stemLanguage = scanDocument(pData, dataLength, docInfo);
-	}
-
-	try
-	{
-		set<string> labels;
-		Xapian::Document doc;
-		Xapian::termcount termPos = 0;
-
-		// Add the tokenizer's terms to the document
-		addPostingsToDocument(tokens, doc, "", termPos, m_stemMode);
-		// Get the document's labels
-		if (getDocumentLabels(docId, labels) == true)
-		{
-			// Add labels
-			for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
-				++labelIter)
-			{
-				doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
-			}
-		}
-		if (addCommonTerms(docInfo, doc, termPos) == true)
-		{
-			setDocumentData(docInfo, doc, m_stemLanguage);
-
-			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-			if (pIndex != NULL)
-			{
-				// Update the document in the database
-				pIndex->replace_document(docId, doc);
-				updated = true;
-			}
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't update document: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't update document, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return updated;
-}
-
-/// Updates a document's properties.
-bool WritableXapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo)
-{
-	bool updated = false;
-
-	if (docId == 0)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc = pIndex->get_document(docId);
-			Xapian::termcount termPos = 0;
-
-#ifdef DEBUG
-			cout << "WritableXapianIndex::updateDocumentInfo: language is " << docInfo.getLanguage() << endl;
-#endif
-
-			// Update the document data with the current language
-			removeCommonTerms(doc);
-			m_stemLanguage = Languages::toEnglish(docInfo.getLanguage());
-			addCommonTerms(docInfo, doc, termPos);
-			setDocumentData(docInfo, doc, m_stemLanguage);
-
-			pIndex->replace_document(docId, doc);
-			updated = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't update document properties: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't update document properties, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return updated;
-}
-
-/// Sets a document's labels.
-bool WritableXapianIndex::setDocumentLabels(unsigned int docId, const set<string> &labels,
-	bool resetLabels)
-{
-	bool updatedLabels = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			Xapian::Document doc = pIndex->get_document(docId);
-
-			// Reset existing labels ?
-			if (resetLabels == true)
-			{
-				Xapian::TermIterator termIter = pIndex->termlist_begin(docId);
-				if (termIter != pIndex->termlist_end(docId))
-				{
-					for (termIter.skip_to("XLABEL:");
-						termIter != pIndex->termlist_end(docId); ++termIter)
-					{
-						// Is this a label ?
-						if (strncasecmp((*termIter).c_str(), "XLABEL:", min(7, (int)(*termIter).length())) == 0)
-						{
-							doc.remove_term(*termIter);
-						}
-					}
-				}
-			}
-
-			// Set new labels
-			for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
-				++labelIter)
-			{
-				if (labelIter->empty() == false)
-				{
-					doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
-				}
-			}
-
-			pIndex->replace_document(docId, doc);
-			updatedLabels = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't update document's labels: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't update document's labels, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return updatedLabels;
-}
-
-/// Unindexes the given document; true if success.
-bool WritableXapianIndex::unindexDocument(unsigned int docId)
-{
-	bool unindexed = false;
-
-	if (docId == 0)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			// Delete the document from the index
-			pIndex->delete_document(docId);
-			unindexed = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't unindex document: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't unindex document, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return unindexed;
-}
-
-/// Unindexes documents with the given label.
-bool WritableXapianIndex::unindexDocuments(const string &labelName)
-{
-	bool unindexed = false;
-
-	if (labelName.empty() == true)
-	{
-		return false;
-	}
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			string term("XLABEL:");
-
-			// Delete documents from the index
-			term += labelName;
-			pIndex->delete_document(term);
-			unindexed = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't unindex documents: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't unindex documents, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return unindexed;
-}
-
-/// Renames a label.
-bool WritableXapianIndex::renameLabel(const string &name, const string &newName)
-{
-	bool renamedLabel = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			string term("XLABEL:");
-
-			// Get documents that have this label
-			term += name;
-			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
-				postingIter != pIndex->postlist_end(term); ++postingIter)
-			{
-				Xapian::docid docId = *postingIter;
-
-				// Get the document
-				Xapian::Document doc = pIndex->get_document(docId);
-				// Remove the term
-				doc.remove_term(term);
-				// ...add the new one
-				doc.add_term(limitTermLength(string("XLABEL:") + newName));
-				// ...and update the document
-				pIndex->replace_document(docId, doc);
-			}
-
-			renamedLabel = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't delete label: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't delete label, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return renamedLabel;
-}
-
-/// Deletes all references to a label.
-bool WritableXapianIndex::deleteLabel(const string &name)
-{
-	bool deletedLabel = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			string term("XLABEL:");
-
-			// Get documents that have this label
-			term += name;
-			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
-				postingIter != pIndex->postlist_end(term); ++postingIter)
-			{
-				Xapian::docid docId = *postingIter;
-
-				// Get the document
-				Xapian::Document doc = pIndex->get_document(docId);
-				// Remove the term
-				doc.remove_term(term);
-				// ...and update the document
-				pIndex->replace_document(docId, doc);
-			}
-			deletedLabel = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't delete label: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't delete label, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return deletedLabel;
-}
-
-/// Flushes recent changes to the disk.
-bool WritableXapianIndex::flush(void)
-{
-	bool flushed = false;
-
-	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
-	{
-		cerr << "Bad index " << m_databaseName << endl;
-		return false;
-	}
-
-	try
-	{
-#ifdef DEBUG
-		cout << "WritableXapianIndex::flush: called" << endl;
-#endif
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
-		if (pIndex != NULL)
-		{
-			pIndex->flush();
-			flushed = true;
-		}
-	}
-	catch (const Xapian::Error &error)
-	{
-		cerr << "Couldn't flush database: " << error.get_type() << ": " << error.get_msg() << endl;
-	}
-	catch (...)
-	{
-		cerr << "Couldn't flush database, unknown exception occured" << endl;
-	}
-	pDatabase->unlock();
-
-	return flushed;
-}

Deleted: trunk/Index/WritableXapianIndex.h
===================================================================
--- trunk/Index/WritableXapianIndex.h	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/Index/WritableXapianIndex.h	2006-08-29 13:31:28 UTC (rev 442)
@@ -1,127 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _WRITABLE_XAPIAN_INDEX_H
-#define _WRITABLE_XAPIAN_INDEX_H
-
-#include <string>
-#include <set>
-
-#include <xapian.h>
-
-#include "XapianIndex.h"
-
-class WritableXapianIndex : public WritableIndexInterface, private XapianIndex
-{
-	public:
-		WritableXapianIndex(const std::string &indexName);
-		WritableXapianIndex(const WritableXapianIndex &other);
-		virtual ~WritableXapianIndex();
-
-		WritableXapianIndex &operator=(const WritableXapianIndex &other);
-
-		/// Returns false if the index couldn't be opened.
-		virtual bool isGood(void) const;
-
-		/// Gets the index location.
-		virtual std::string getLocation(void) const;
-
-		/// Returns a document's properties.
-		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const;
-
-		/// Determines whether a document has a label.
-		virtual bool hasLabel(unsigned int docId, const std::string &name) const;
-
-		/// Returns a document's labels.
-		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const;
-
-		/// Checks whether the given URL is in the index.
-		virtual unsigned int hasDocument(const std::string &url) const;
-
-		/// Gets terms with the same root.
-		virtual unsigned int getCloseTerms(const std::string &term, std::set<std::string> &suggestions);
-
-		/// Returns the ID of the last document.
-		virtual unsigned int getLastDocumentID(void) const;
-
-		/// Returns the number of documents.
-		virtual unsigned int getDocumentsCount(const std::string &labelName = "") const;
-
-		/// Lists document IDs.
-		virtual unsigned int listDocuments(std::set<unsigned int> &docIds,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		/// Lists documents that have a label.
-		virtual bool listDocumentsWithLabel(const std::string &name, std::set<unsigned int> &docIds,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
-
-		/// Indexes the given data.
-		virtual bool indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
-			unsigned int &docId);
-
-		/// Updates the given document.
-		virtual bool updateDocument(unsigned int docId, Tokenizer &tokens);
-
-		/// Updates a document's properties.
-		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo);
-
-		/// Sets a document's labels.
-		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
-			bool resetLabels = true);
-
-		/// Unindexes the given document.
-		virtual bool unindexDocument(unsigned int docId);
-
-		/// Unindexes documents with the given label.
-		virtual bool unindexDocuments(const std::string &labelName);
-
-		/// Renames a label.
-		virtual bool renameLabel(const std::string &name, const std::string &newName);
-
-		/// Deletes all references to a label.
-		virtual bool deleteLabel(const std::string &name);
-
-		/// Flushes recent changes to the disk.
-		virtual bool flush(void);
-
-	protected:
-		std::string m_stemLanguage;
-
-		static bool badField(const std::string &field);
-
-		void addPostingsToDocument(Tokenizer &tokens, Xapian::Document &doc,
-			const std::string &prefix, Xapian::termcount &termPos, StemmingMode mode) const;
-
-		void removeFirstPostingsFromDocument(Tokenizer &tokens, Xapian::Document &doc,
-			const std::string &prefix, const std::string &language, StemmingMode mode) const;
-
-		bool addCommonTerms(const DocumentInfo &info, Xapian::Document &doc,
-			Xapian::termcount &termPos) const;
-
-		void removeCommonTerms(Xapian::Document &doc);
-
-		std::string scanDocument(const char *pData, unsigned int dataLength,
-			DocumentInfo &info);
-
-		void setDocumentData(const DocumentInfo &info, Xapian::Document &doc,
-			const std::string &language) const;
-
-		bool listDocumentsWithTerm(const std::string &term, std::set<unsigned int> &docIds,
-			unsigned int maxDocsCount, unsigned int startDoc) const;
-
-};
-
-#endif // _WRITABLE_XAPIAN_INDEX_H

Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/Index/XapianIndex.cpp	2006-08-29 13:31:28 UTC (rev 442)
@@ -23,6 +23,7 @@
 #include <strings.h>
 #include <time.h>
 #include <ctype.h>
+#include <regex.h>
 #include <iostream>
 #include <fstream>
 #include <algorithm>
@@ -48,6 +49,28 @@
 const unsigned int XapianIndex::m_maxTermLength = 240;
 const string XapianIndex::MAGIC_TERM = "X-MetaSE-Doc";
 
+static void removeFirstPosting(Xapian::Document &doc,
+	Xapian::TermIterator &termListIter, const string &term)
+{
+	termListIter.skip_to(term);
+
+	Xapian::PositionIterator firstPosIter = termListIter.positionlist_begin();
+	if (firstPosIter != termListIter.positionlist_end())
+	{
+		try
+		{
+			doc.remove_posting(term, *firstPosIter);
+		}
+		catch (const Xapian::Error &error)
+		{
+			// This posting may have been removed already
+#ifdef DEBUG
+			cout << "XapianIndex::removeFirstPosting: " << error.get_msg() << endl;
+#endif
+		}
+	}
+}
+
 XapianIndex::XapianIndex(const string &indexName) :
 	IndexInterface(),
 	m_databaseName(indexName),
@@ -65,7 +88,8 @@
 XapianIndex::XapianIndex(const XapianIndex &other) :
 	IndexInterface(other),
 	m_databaseName(other.m_databaseName),
-	m_goodIndex(other .m_goodIndex)
+	m_goodIndex(other .m_goodIndex),
+	m_stemLanguage(other.m_stemLanguage)
 {
 }
 
@@ -78,6 +102,7 @@
 	IndexInterface::operator=(other);
 	m_databaseName = other.m_databaseName;
 	m_goodIndex = other .m_goodIndex;
+	m_stemLanguage = other.m_stemLanguage;
 	return *this;
 }
 
@@ -99,6 +124,28 @@
 	return term;
 }
 
+bool XapianIndex::badField(const string &field)
+{
+	regex_t fieldRegex;
+	regmatch_t pFieldMatches[1];
+	bool isBadField = false;
+
+	// A bad field is one that includes one of our field delimiters
+	if (regcomp(&fieldRegex,
+		"(url|sample|caption|type|timestamp|language)=",
+		REG_EXTENDED|REG_ICASE) == 0)
+	{
+		if (regexec(&fieldRegex, field.c_str(), 1,
+			pFieldMatches, REG_NOTBOL|REG_NOTEOL) == 0)
+		{
+			isBadField = true;
+		}
+	}
+	regfree(&fieldRegex);
+
+	return isBadField;
+}
+
 bool XapianIndex::listDocumentsWithTerm(const string &term, set<unsigned int> &docIds,
 	unsigned int maxDocsCount, unsigned int startDoc) const
 {
@@ -150,6 +197,353 @@
 	return docIds.size();
 }
 
+void XapianIndex::addPostingsToDocument(Tokenizer &tokens, Xapian::Document &doc,
+	const string &prefix, Xapian::termcount &termPos, StemmingMode mode) const
+{
+	Xapian::Stem *pStemmer = NULL;
+	string term;
+
+	// Do we know what language to use for stemming ?
+	if (m_stemLanguage.empty() == false)
+	{
+		pStemmer = new Xapian::Stem(StringManip::toLowerCase(m_stemLanguage));
+	}
+
+	// Get the terms
+	while (tokens.nextToken(term) == true)
+	{
+		if (term.empty() == true)
+		{
+			continue;
+		}
+		// Does it start with a capital letter ?
+		if (isupper((int)term[0]) != 0)
+		{
+			// R-prefix the raw term
+			doc.add_posting(string("R") + term, termPos);
+		}
+		// Lower case the term
+		term = StringManip::toLowerCase(term);
+
+		// Stem the term ?
+		if ((mode == STORE_UNSTEM) ||
+			(pStemmer == NULL))
+		{
+			doc.add_posting(limitTermLength(prefix + term), termPos++);
+		}
+		else if (mode == STORE_STEM)
+		{
+			string stemmedTerm = pStemmer->stem_word(term);
+
+			doc.add_posting(limitTermLength(prefix + stemmedTerm), termPos++);
+		}
+		else if (mode == STORE_BOTH)
+		{
+			string stemmedTerm = pStemmer->stem_word(term);
+
+			// Add both at the same position
+			doc.add_posting(limitTermLength(prefix + term), termPos);
+			if (stemmedTerm != term)
+			{
+				// No point adding the same term twice
+				doc.add_posting(limitTermLength(prefix + stemmedTerm), termPos++);
+			}
+		}
+	}
+#ifdef DEBUG
+	cout << "XapianIndex::addPostingsToDocument: added " << termPos << " terms" << endl;
+#endif
+
+	if (pStemmer != NULL)
+	{
+		delete pStemmer;
+	}
+}
+
+void XapianIndex::removeFirstPostingsFromDocument(Tokenizer &tokens, Xapian::Document &doc,
+	const string &prefix, const string &language, StemmingMode mode) const
+{
+	Xapian::TermIterator termListIter = doc.termlist_begin();
+	Xapian::Stem *pStemmer = NULL;
+	string term;
+
+	// Do we know what language to use for stemming ?
+	if (language.empty() == false)
+	{
+		pStemmer = new Xapian::Stem(StringManip::toLowerCase(language));
+	}
+
+	// Get the terms and remove the first posting for each
+	while (tokens.nextToken(term) == true)
+	{
+		if (term.empty() == true)
+		{
+			continue;
+		}
+		// Does it start with a capital letter ?
+		if (isupper((int)term[0]) != 0)
+		{
+			// R-prefix the raw term
+			removeFirstPosting(doc, termListIter, string("R") + term);
+		}
+		// Lower case the term
+		term = StringManip::toLowerCase(term);
+
+		// Stem the term ?
+		if ((mode == STORE_UNSTEM) ||
+			(pStemmer == NULL))
+		{
+			removeFirstPosting(doc, termListIter, limitTermLength(prefix + term));
+		}
+		else if (mode == STORE_STEM)
+		{
+			removeFirstPosting(doc, termListIter, limitTermLength(prefix + pStemmer->stem_word(term)));
+		}
+		else if (mode == STORE_BOTH)
+		{
+			string stemmedTerm = pStemmer->stem_word(term);
+
+			removeFirstPosting(doc, termListIter, limitTermLength(prefix + term));
+			if (stemmedTerm != term)
+			{
+				removeFirstPosting(doc, termListIter, limitTermLength(prefix + stemmedTerm));
+			}
+		}
+	}
+
+	if (pStemmer != NULL)
+	{
+		delete pStemmer;
+	}
+}
+
+bool XapianIndex::addCommonTerms(const DocumentInfo &info, Xapian::Document &doc,
+	Xapian::termcount &termPos) const
+{
+	string title(info.getTitle());
+	string location(info.getLocation());
+	Url urlObj(location);
+
+	// Add a magic term :-)
+	doc.add_term(MAGIC_TERM);
+
+	// Index the title with and without prefix S
+	if (title.empty() == false)
+	{
+		Document titleDoc;
+		titleDoc.setData(title.c_str(), title.length());
+		Tokenizer titleTokens(&titleDoc);
+		addPostingsToDocument(titleTokens, doc, "S", termPos, STORE_UNSTEM);
+		titleTokens.rewind();
+		addPostingsToDocument(titleTokens, doc, "", termPos, m_stemMode);
+	}
+
+	// Index the full URL with prefix U
+	doc.add_term(limitTermLength(string("U") + location, true));
+	// ...the host name and included domains with prefix H
+	string hostName(StringManip::toLowerCase(urlObj.getHost()));
+	if (hostName.empty() == false)
+	{
+		doc.add_term(limitTermLength(string("H") + hostName, true));
+		string::size_type dotPos = hostName.find('.');
+		while (dotPos != string::npos)
+		{
+			doc.add_term(limitTermLength(string("H") + hostName.substr(dotPos + 1), true));
+
+			// Next
+			dotPos = hostName.find('.', dotPos + 1);
+		}
+	}
+	// ...the location (as is) and all directories with prefix XDIR:
+	string tree(urlObj.getLocation());
+	if (tree.empty() == false)
+	{
+		doc.add_term(limitTermLength(string("XDIR:") + tree, true));
+		string::size_type slashPos = tree.find('/', 1);
+		while (slashPos != string::npos)
+		{
+			doc.add_term(limitTermLength(string("XDIR:") + tree.substr(0, slashPos), true));
+
+			// Next
+			slashPos = tree.find('/', slashPos + 1);
+		}
+	}
+	// ...and the file name with prefix P
+	string fileName(urlObj.getFile());
+	if (fileName.empty() == false)
+	{
+		doc.add_term(limitTermLength(string("P") + StringManip::toLowerCase(fileName), true));
+	}
+	// Finally, add the language code with prefix L
+	doc.add_term(string("L") + Languages::toCode(m_stemLanguage));
+	// ...and the MIME type with prefix T
+	doc.add_term(string("T") + info.getType());
+
+	return true;
+}
+
+void XapianIndex::removeCommonTerms(Xapian::Document &doc)
+{
+	DocumentInfo docInfo;
+	string record(doc.get_data());
+
+	// First, remove the magic term
+	doc.remove_term(MAGIC_TERM);
+
+	if (record.empty() == true)
+        {
+		// Nothing else we can do
+		return;
+	}
+
+	string language(StringManip::extractField(record, "language=", ""));
+	docInfo = DocumentInfo(StringManip::extractField(record, "caption=", "\n"),
+		StringManip::extractField(record, "url=", "\n"),
+		StringManip::extractField(record, "type=", "\n"),
+		Languages::toLocale(language));
+	docInfo.setTimestamp(StringManip::extractField(record, "timestamp=", "\n"));
+	Url urlObj(docInfo.getLocation());
+
+	// FIXME: remove terms extracted from the title if they don't have more than one posting
+	string title(docInfo.getTitle());
+	if (title.empty() == false)
+	{
+		Document titleDoc;
+		titleDoc.setData(title.c_str(), title.length());
+		Tokenizer titleTokens(&titleDoc);
+		removeFirstPostingsFromDocument(titleTokens, doc, "S", language, STORE_UNSTEM);
+		titleTokens.rewind();
+		removeFirstPostingsFromDocument(titleTokens, doc, "", language, m_stemMode);
+	}
+
+	// Title
+	doc.remove_term(limitTermLength(string("U") + docInfo.getLocation(), true));
+	// Host name
+	string hostName(StringManip::toLowerCase(urlObj.getHost()));
+	if (hostName.empty() == false)
+	{
+		doc.remove_term(limitTermLength(string("H") + hostName, true));
+		string::size_type dotPos = hostName.find('.');
+		while (dotPos != string::npos)
+		{
+			doc.remove_term(limitTermLength(string("H") + hostName.substr(dotPos + 1), true));
+
+			// Next
+			dotPos = hostName.find('.', dotPos + 1);
+		}
+	}
+	// ...location
+	string tree(urlObj.getLocation());
+	if (tree.empty() == false)
+	{
+		doc.remove_term(limitTermLength(string("XDIR:") + tree, true));
+		string::size_type slashPos = tree.find('/', 1);
+		while (slashPos != string::npos)
+		{
+			doc.remove_term(limitTermLength(string("XDIR:") + tree.substr(0, slashPos), true));
+
+			// Next
+			slashPos = tree.find('/', slashPos + 1);
+		}
+	}
+	// ...and file name
+	string fileName(urlObj.getFile());
+	if (fileName.empty() == false)
+	{
+		doc.remove_term(limitTermLength(string("P") + StringManip::toLowerCase(fileName), true));
+	}
+	// Language code
+	doc.remove_term(string("L") + Languages::toCode(language));
+	// MIME type
+	doc.remove_term(string("T") + docInfo.getType());
+}
+
+string XapianIndex::scanDocument(const char *pData, unsigned int dataLength,
+	DocumentInfo &info)
+{
+	vector<string> candidates;
+	string language;
+
+	// Try to determine the document's language
+	LanguageDetector lang;
+	lang.guessLanguage(pData, max(dataLength, (unsigned int)2048), candidates);
+
+	// See which of these languages is suitable for stemming
+	for (vector<string>::iterator langIter = candidates.begin(); langIter != candidates.end(); ++langIter)
+	{
+		if (*langIter == "unknown")
+		{
+			continue;
+		}
+
+		try
+		{
+			Xapian::Stem stemmer(*langIter);
+		}
+		catch (const Xapian::Error &error)
+		{
+			cerr << "XapianIndex::scanDocument: " << error.get_type() << ": " << error.get_msg() << endl;
+			continue;
+		}
+
+		language = *langIter;
+		break;
+	}
+#ifdef DEBUG
+	cout << "XapianIndex::scanDocument: language " << language << endl;
+#endif
+
+	// Update the document's properties
+	info.setLanguage(language);
+
+	return language;
+}
+
+void XapianIndex::setDocumentData(const DocumentInfo &info, Xapian::Document &doc,
+	const string &language) const
+{
+	string title(info.getTitle());
+	string timestamp(info.getTimestamp());
+	char timeStr[64];
+
+	// Set the document data omindex-style
+	string record = "url=";
+	record += info.getLocation();
+	// The sample will be generated at query time
+	record += "\nsample=";
+	record += "\ncaption=";
+	if (badField(title) == true)
+	{
+		// Modify the title if necessary
+		string::size_type pos = title.find("=");
+		while (pos != string::npos)
+		{
+			title[pos] = ' ';
+			pos = title.find("=", pos + 1);
+		}
+#ifdef DEBUG
+		cout << "XapianIndex::setDocumentData: modified title" << endl;
+#endif
+	}
+	record += title;
+	record += "\ntype=";
+	record += info.getType();
+	// Append a timestamp
+	record += "\ntimestamp=";
+	record += timestamp;
+	// ...and the language
+	record += "\nlanguage=";
+	record += StringManip::toLowerCase(language);
+#ifdef DEBUG
+	cout << "XapianIndex::setDocumentData: document data is " << record << endl;
+#endif
+	doc.set_data(record);
+
+	// Add this value to allow sorting by date
+	snprintf(timeStr, 64, "%d", TimeConverter::fromTimestamp(timestamp));
+	doc.add_value(0, timeStr);
+}
+
 //
 // Implementation of IndexInterface
 //
@@ -544,3 +938,502 @@
 	term += name;
 	return listDocumentsWithTerm(term, docIds, maxDocsCount, startDoc);
 }
+
+/// Indexes the given data.
+bool XapianIndex::indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
+	unsigned int &docId)
+{
+	unsigned int dataLength = 0;
+	bool indexed = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		// Get the document
+		const Document *pDocument = tokens.getDocument();
+		if (pDocument == NULL)
+		{
+#ifdef DEBUG
+			cout << "XapianIndex::indexDocument: no document" << endl;
+#endif
+			return false;
+		}
+
+		// Cache the document's properties
+		DocumentInfo docInfo(pDocument->getTitle(), pDocument->getLocation(),
+			pDocument->getType(), pDocument->getLanguage());
+		docInfo.setTimestamp(pDocument->getTimestamp());
+		docInfo.setLocation(Url::canonicalizeUrl(docInfo.getLocation()));
+
+		const char *pData = pDocument->getData(dataLength);
+		if (pData != NULL)
+		{
+			m_stemLanguage = scanDocument(pData, dataLength, docInfo);
+		}
+
+		Xapian::Document doc;
+		Xapian::termcount termPos = 0;
+
+#ifdef DEBUG
+		cout << "XapianIndex::indexDocument: adding terms" << endl;
+#endif
+		// Add the tokenizer's terms to the Xapian document
+		addPostingsToDocument(tokens, doc, "", termPos, m_stemMode);
+		// Add labels
+		for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
+			++labelIter)
+		{
+			doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
+		}
+		if (addCommonTerms(docInfo, doc, termPos) == true)
+		{
+			setDocumentData(docInfo, doc, m_stemLanguage);
+
+			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+			if (pIndex != NULL)
+			{
+				// Add this document to the Xapian index
+				docId = pIndex->add_document(doc);
+				indexed = true;
+			}
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't index document: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't index document, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return indexed;
+}
+
+/// Updates the given document; true if success.
+bool XapianIndex::updateDocument(unsigned int docId, Tokenizer &tokens)
+{
+	unsigned int dataLength = 0;
+	bool updated = false;
+
+	const Document *pDocument = tokens.getDocument();
+	if (pDocument == NULL)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	const char *pData = pDocument->getData(dataLength);
+	if (pData == NULL)
+	{
+		return false;
+	}
+
+	// Cache the document's properties
+	DocumentInfo docInfo(pDocument->getTitle(), pDocument->getLocation(),
+		pDocument->getType(), pDocument->getLanguage());
+	docInfo.setTimestamp(pDocument->getTimestamp());
+	docInfo.setLocation(Url::canonicalizeUrl(docInfo.getLocation()));
+
+	// Don't scan the document if a language is specified
+	m_stemLanguage = Languages::toEnglish(pDocument->getLanguage());
+	if (m_stemLanguage.empty() == true)
+	{
+		m_stemLanguage = scanDocument(pData, dataLength, docInfo);
+	}
+
+	try
+	{
+		set<string> labels;
+		Xapian::Document doc;
+		Xapian::termcount termPos = 0;
+
+		// Add the tokenizer's terms to the document
+		addPostingsToDocument(tokens, doc, "", termPos, m_stemMode);
+		// Get the document's labels
+		if (getDocumentLabels(docId, labels) == true)
+		{
+			// Add labels
+			for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
+				++labelIter)
+			{
+				doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
+			}
+		}
+		if (addCommonTerms(docInfo, doc, termPos) == true)
+		{
+			setDocumentData(docInfo, doc, m_stemLanguage);
+
+			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+			if (pIndex != NULL)
+			{
+				// Update the document in the database
+				pIndex->replace_document(docId, doc);
+				updated = true;
+			}
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't update document: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't update document, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return updated;
+}
+
+/// Updates a document's properties.
+bool XapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo)
+{
+	bool updated = false;
+
+	if (docId == 0)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			Xapian::Document doc = pIndex->get_document(docId);
+			Xapian::termcount termPos = 0;
+
+#ifdef DEBUG
+			cout << "XapianIndex::updateDocumentInfo: language is " << docInfo.getLanguage() << endl;
+#endif
+
+			// Update the document data with the current language
+			removeCommonTerms(doc);
+			m_stemLanguage = Languages::toEnglish(docInfo.getLanguage());
+			addCommonTerms(docInfo, doc, termPos);
+			setDocumentData(docInfo, doc, m_stemLanguage);
+
+			pIndex->replace_document(docId, doc);
+			updated = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't update document properties: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't update document properties, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return updated;
+}
+
+/// Sets a document's labels.
+bool XapianIndex::setDocumentLabels(unsigned int docId, const set<string> &labels,
+	bool resetLabels)
+{
+	bool updatedLabels = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			Xapian::Document doc = pIndex->get_document(docId);
+
+			// Reset existing labels ?
+			if (resetLabels == true)
+			{
+				Xapian::TermIterator termIter = pIndex->termlist_begin(docId);
+				if (termIter != pIndex->termlist_end(docId))
+				{
+					for (termIter.skip_to("XLABEL:");
+						termIter != pIndex->termlist_end(docId); ++termIter)
+					{
+						// Is this a label ?
+						if (strncasecmp((*termIter).c_str(), "XLABEL:", min(7, (int)(*termIter).length())) == 0)
+						{
+							doc.remove_term(*termIter);
+						}
+					}
+				}
+			}
+
+			// Set new labels
+			for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
+				++labelIter)
+			{
+				if (labelIter->empty() == false)
+				{
+					doc.add_term(limitTermLength(string("XLABEL:") + *labelIter));
+				}
+			}
+
+			pIndex->replace_document(docId, doc);
+			updatedLabels = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't update document's labels: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't update document's labels, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return updatedLabels;
+}
+
+/// Unindexes the given document; true if success.
+bool XapianIndex::unindexDocument(unsigned int docId)
+{
+	bool unindexed = false;
+
+	if (docId == 0)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			// Delete the document from the index
+			pIndex->delete_document(docId);
+			unindexed = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't unindex document: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't unindex document, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return unindexed;
+}
+
+/// Unindexes documents with the given label.
+bool XapianIndex::unindexDocuments(const string &labelName)
+{
+	bool unindexed = false;
+
+	if (labelName.empty() == true)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			string term("XLABEL:");
+
+			// Delete documents from the index
+			term += labelName;
+			pIndex->delete_document(term);
+			unindexed = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't unindex documents: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't unindex documents, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return unindexed;
+}
+
+/// Renames a label.
+bool XapianIndex::renameLabel(const string &name, const string &newName)
+{
+	bool renamedLabel = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			string term("XLABEL:");
+
+			// Get documents that have this label
+			term += name;
+			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
+				postingIter != pIndex->postlist_end(term); ++postingIter)
+			{
+				Xapian::docid docId = *postingIter;
+
+				// Get the document
+				Xapian::Document doc = pIndex->get_document(docId);
+				// Remove the term
+				doc.remove_term(term);
+				// ...add the new one
+				doc.add_term(limitTermLength(string("XLABEL:") + newName));
+				// ...and update the document
+				pIndex->replace_document(docId, doc);
+			}
+
+			renamedLabel = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't delete label: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't delete label, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return renamedLabel;
+}
+
+/// Deletes all references to a label.
+bool XapianIndex::deleteLabel(const string &name)
+{
+	bool deletedLabel = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			string term("XLABEL:");
+
+			// Get documents that have this label
+			term += name;
+			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
+				postingIter != pIndex->postlist_end(term); ++postingIter)
+			{
+				Xapian::docid docId = *postingIter;
+
+				// Get the document
+				Xapian::Document doc = pIndex->get_document(docId);
+				// Remove the term
+				doc.remove_term(term);
+				// ...and update the document
+				pIndex->replace_document(docId, doc);
+			}
+			deletedLabel = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't delete label: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't delete label, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return deletedLabel;
+}
+
+/// Flushes recent changes to the disk.
+bool XapianIndex::flush(void)
+{
+	bool flushed = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+#ifdef DEBUG
+		cout << "XapianIndex::flush: called" << endl;
+#endif
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			pIndex->flush();
+			flushed = true;
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't flush database: " << error.get_type() << ": " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't flush database, unknown exception occured" << endl;
+	}
+	pDatabase->unlock();
+
+	return flushed;
+}
+

Modified: trunk/Index/XapianIndex.h
===================================================================
--- trunk/Index/XapianIndex.h	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/Index/XapianIndex.h	2006-08-29 13:31:28 UTC (rev 442)
@@ -67,17 +67,66 @@
 		virtual bool listDocumentsWithLabel(const std::string &name, std::set<unsigned int> &docIds,
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
 
+		/// Indexes the given data.
+		virtual bool indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
+			unsigned int &docId);
+
+		/// Updates the given document.
+		virtual bool updateDocument(unsigned int docId, Tokenizer &tokens);
+
+		/// Updates a document's properties.
+		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo);
+
+		/// Sets a document's labels.
+		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
+			bool resetLabels = true);
+
+		/// Unindexes the given document.
+		virtual bool unindexDocument(unsigned int docId);
+
+		/// Unindexes documents with the given label.
+		virtual bool unindexDocuments(const std::string &labelName);
+
+		/// Renames a label.
+		virtual bool renameLabel(const std::string &name, const std::string &newName);
+
+		/// Deletes all references to a label.
+		virtual bool deleteLabel(const std::string &name);
+
+		/// Flushes recent changes to the disk.
+		virtual bool flush(void);
+
 	protected:
 		static const unsigned int m_maxTermLength;
 		static const std::string MAGIC_TERM;
 		std::string m_databaseName;
 		bool m_goodIndex;
+		std::string m_stemLanguage;
 
 		static std::string limitTermLength(const std::string &term, bool makeUnique = false);
 
+		static bool badField(const std::string &field);
+
 		bool listDocumentsWithTerm(const std::string &term, std::set<unsigned int> &docIds,
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
 
+		void addPostingsToDocument(Tokenizer &tokens, Xapian::Document &doc,
+			const std::string &prefix, Xapian::termcount &termPos, StemmingMode mode) const;
+
+		void removeFirstPostingsFromDocument(Tokenizer &tokens, Xapian::Document &doc,
+			const std::string &prefix, const std::string &language, StemmingMode mode) const;
+
+		bool addCommonTerms(const DocumentInfo &info, Xapian::Document &doc,
+			Xapian::termcount &termPos) const;
+
+		void removeCommonTerms(Xapian::Document &doc);
+
+		std::string scanDocument(const char *pData, unsigned int dataLength,
+			DocumentInfo &info);
+
+		void setDocumentData(const DocumentInfo &info, Xapian::Document &doc,
+			const std::string &language) const;
+
 };
 
 #endif // _XAPIAN_INDEX_H

Modified: trunk/Index/pinot-index.cpp
===================================================================
--- trunk/Index/pinot-index.cpp	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/Index/pinot-index.cpp	2006-08-29 13:31:28 UTC (rev 442)
@@ -111,7 +111,7 @@
 	DownloaderInterface::initialize();
 
 	// Get a read-write index of the given type
-	WritableIndexInterface *pIndex = IndexFactory::getRWIndex(argv[optind], argv[optind + 1]);
+	IndexInterface *pIndex = IndexFactory::getIndex(argv[optind], argv[optind + 1]);
 	if (pIndex == NULL)
 	{
 		cerr << "Couldn't obtain index of type " << argv[optind] << endl;
@@ -166,7 +166,7 @@
 			{
 				set<string> labels;
 
-				pIndex->setStemmingMode(WritableIndexInterface::STORE_BOTH);
+				pIndex->setStemmingMode(IndexInterface::STORE_BOTH);
 
 				// Update an existing document or add to the index ?
 				unsigned int docId = pIndex->hasDocument(urlToIndex);

Modified: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2006-08-29 13:31:28 UTC (rev 442)
@@ -23,7 +23,7 @@
 
 #include "Url.h"
 #include "MonitorFactory.h"
-#include "WritableXapianIndex.h"
+#include "XapianIndex.h"
 #include "DaemonState.h"
 #include "MboxHandler.h"
 #include "OnDiskHandler.h"
@@ -179,7 +179,7 @@
 		}
 
 		// Explicitely flush the index once a directory has been crawled
-		WritableXapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
+		XapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
 		index.flush();
 
 		// Start a new scanner thread ?

Modified: trunk/UI/GTK2/src/MboxHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-29 13:31:28 UTC (rev 442)
@@ -161,7 +161,7 @@
 		unsigned int docId = m_index.hasDocument(pMessage->getLocation());
 		if (docId == 0)
 		{
-			m_index.setStemmingMode(WritableIndexInterface::STORE_BOTH);
+			m_index.setStemmingMode(IndexInterface::STORE_BOTH);
 
 			// Get an ad hoc tokenizer for the message
 			Tokenizer *pTokenizer = TokenizerFactory::getTokenizerByType(pMessage->getType(), pMessage);

Modified: trunk/UI/GTK2/src/MboxHandler.h
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.h	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/UI/GTK2/src/MboxHandler.h	2006-08-29 13:31:28 UTC (rev 442)
@@ -25,8 +25,8 @@
 #include "IndexedDocument.h"
 #include "MboxParser.h"
 #include "CrawlHistory.h"
-#include "WritableXapianIndex.h"
 #include "MonitorHandler.h"
+#include "XapianIndex.h"
 #include "PinotSettings.h"
 
 class MboxHandler : public MonitorHandler
@@ -59,7 +59,7 @@
 
 	protected:
 		CrawlHistory m_history;
-		WritableXapianIndex m_index;
+		XapianIndex m_index;
 		unsigned int m_sourceId;
 
 		bool checkMailAccount(const std::string &fileName, PinotSettings::TimestampedItem &mailAccount);

Modified: trunk/UI/GTK2/src/OnDiskHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-29 13:31:28 UTC (rev 442)
@@ -41,7 +41,7 @@
 	m_history(PinotSettings::getInstance().m_historyDatabase),
 	m_index(PinotSettings::getInstance().m_daemonIndexLocation)
 {
-	m_index.setStemmingMode(WritableIndexInterface::STORE_BOTH);
+	m_index.setStemmingMode(IndexInterface::STORE_BOTH);
 }
 
 OnDiskHandler::~OnDiskHandler()

Modified: trunk/UI/GTK2/src/OnDiskHandler.h
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-29 13:31:28 UTC (rev 442)
@@ -24,9 +24,8 @@
 
 #include "CrawlHistory.h"
 #include "IndexedDocument.h"
-#include "MboxParser.h"
-#include "WritableXapianIndex.h"
 #include "MonitorHandler.h"
+#include "XapianIndex.h"
 #include "PinotSettings.h"
 
 class OnDiskHandler : public MonitorHandler
@@ -59,7 +58,7 @@
 
 	protected:
 		CrawlHistory m_history;
-		WritableXapianIndex m_index;
+		XapianIndex m_index;
 
 		bool indexFile(const std::string &fileName, bool alwaysUpdate);
 

Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2006-08-29 13:31:28 UTC (rev 442)
@@ -1177,38 +1177,22 @@
 	} while (indexId > 0);
 }
 
-/// Returns a IndexInterface for the given index location.
-IndexInterface *PinotSettings::getROIndex(const string &location)
+/// Returns an IndexInterface for the given index location.
+IndexInterface *PinotSettings::getIndex(const string &location)
 {
 	if (location == m_docsIndexLocation)
 	{
-		return IndexFactory::getROIndex("xapian", m_docsIndexLocation);
+		return IndexFactory::getIndex("xapian", m_docsIndexLocation);
 	}
 	else if ((m_enableDBus == true) &&
 		(location == m_daemonIndexLocation))
 	{
-		return IndexFactory::getROIndex("dbus", m_daemonIndexLocation);
+		return IndexFactory::getIndex("dbus", m_daemonIndexLocation);
 	}
 
-	return IndexFactory::getROIndex("xapian", location);
+	return IndexFactory::getIndex("xapian", location);
 }
 
-/// Returns a WritableIndexInterface for the given index location.
-WritableIndexInterface *PinotSettings::getRWIndex(const string &location)
-{
-	if (location == m_docsIndexLocation)
-	{
-		return IndexFactory::getRWIndex("xapian", m_docsIndexLocation);
-	}
-	else if ((m_enableDBus == true) &&
-		(location == m_daemonIndexLocation))
-	{
-		return IndexFactory::getRWIndex("dbus", m_daemonIndexLocation);
-	}
-
-	return IndexFactory::getRWIndex("xapian", location);
-}
-
 /// Returns the search engines set.
 bool PinotSettings::getSearchEngines(set<PinotSettings::Engine> &engines, string channelName) const
 {

Modified: trunk/UI/GTK2/src/PinotSettings.h
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.h	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/UI/GTK2/src/PinotSettings.h	2006-08-29 13:31:28 UTC (rev 442)
@@ -75,12 +75,9 @@
 		/// Returns the name(s) for the given ID.
 		void getIndexNames(unsigned int id, std::set<std::string> &names);
 
-		/// Returns a IndexInterface for the given index location.
-		IndexInterface *getROIndex(const std::string &location);
+		/// Returns an IndexInterface for the given index location.
+		IndexInterface *getIndex(const std::string &location);
 
-		/// Returns a WritableIndexInterface for the given index location.
-		WritableIndexInterface *getRWIndex(const std::string &location);
-
 		class Engine
 		{
 			public:

Modified: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2006-08-29 13:31:28 UTC (rev 442)
@@ -1137,7 +1137,7 @@
 #endif
 	}
 
-	IndexInterface *pIndex = m_settings.getROIndex("MERGED");
+	IndexInterface *pIndex = m_settings.getIndex("MERGED");
 	ViewHistory viewHistory(m_settings.m_historyDatabase);
 	bool isIndexed = false;
 

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-29 13:31:28 UTC (rev 442)
@@ -121,6 +121,9 @@
 
 Glib::Thread *WorkerThread::start(void)
 {
+#ifdef DEBUG
+	cout << "WorkerThread::start: " << getType() << " " << m_id << endl;
+#endif
 	return Thread::create(slot_class(*this, &WorkerThread::threadHandler), m_joinable);
 }
 
@@ -319,7 +322,7 @@
 	}
 
 	// Is it an update ?
-	IndexInterface *pIndex = PinotSettings::getInstance().getROIndex(m_defaultIndexLocation);
+	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_defaultIndexLocation);
 	if (pIndex == NULL)
 	{
 		return false;
@@ -627,7 +630,7 @@
 	}
 
 	// Get the index at that location
-	IndexInterface *pIndex = PinotSettings::getInstance().getROIndex(mapIter->second);
+	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(mapIter->second);
 	if ((pIndex == NULL) ||
 		(pIndex->isGood() == false))
 	{
@@ -911,7 +914,7 @@
 
 void LabelUpdateThread::doWork(void)
 {
-	WritableIndexInterface *pDocsIndex = PinotSettings::getInstance().getRWIndex(PinotSettings::getInstance().m_docsIndexLocation);
+	IndexInterface *pDocsIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_docsIndexLocation);
 	if (pDocsIndex == NULL)
 	{
 		m_status = _("Index error on");
@@ -920,7 +923,7 @@
 		return;
 	}
 
-	WritableIndexInterface *pDaemonIndex = PinotSettings::getInstance().getRWIndex(PinotSettings::getInstance().m_daemonIndexLocation);
+	IndexInterface *pDaemonIndex = PinotSettings::getInstance().getIndex(PinotSettings::getInstance().m_daemonIndexLocation);
 	if (pDaemonIndex == NULL)
 	{
 		m_status = _("Index error on");
@@ -1105,7 +1108,7 @@
 
 void IndexingThread::doWork(void)
 {
-	WritableIndexInterface *pIndex = PinotSettings::getInstance().getRWIndex(m_indexLocation);
+	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexLocation);
 
 	// First things first, get the index
 	if ((pIndex == NULL) ||
@@ -1218,7 +1221,7 @@
 		{
 			const set<string> &labels = m_docInfo.getLabels();
 
-			pIndex->setStemmingMode(WritableIndexInterface::STORE_BOTH);
+			pIndex->setStemmingMode(IndexInterface::STORE_BOTH);
 
 			// Update an existing document or add to the index ?
 			if (m_update == true)
@@ -1312,7 +1315,7 @@
 
 void UnindexingThread::doWork(void)
 {
-	WritableIndexInterface *pIndex = PinotSettings::getInstance().getRWIndex(m_indexLocation);
+	IndexInterface *pIndex = PinotSettings::getInstance().getIndex(m_indexLocation);
 
 	if ((pIndex == NULL) ||
 		(pIndex->isGood() == false))
@@ -1441,7 +1444,7 @@
 		}
 
 		// Get the index at that location
-		WritableIndexInterface *pIndex = PinotSettings::getInstance().getRWIndex(mapIter->second);
+		IndexInterface *pIndex = PinotSettings::getInstance().getIndex(mapIter->second);
 		if ((pIndex == NULL) ||
 			(pIndex->isGood() == false))
 		{

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/UI/GTK2/src/mainWindow.cc	2006-08-29 13:31:28 UTC (rev 442)
@@ -437,7 +437,7 @@
 	if ((hasSelection == true) &&
 		(resultsList.empty() == false))
 	{
-		IndexInterface *pIndex = m_settings.getROIndex("MERGED");
+		IndexInterface *pIndex = m_settings.getIndex("MERGED");
 		bool firstResult = true, isViewable = true, isCached = false, isIndexed = false, isIndexable = true;
 
 		for (vector<DocumentInfo>::iterator resultIter = resultsList.begin();
@@ -1720,7 +1720,7 @@
 		}
 	}
 
-	IndexInterface *pIndex = m_settings.getROIndex("MERGED");
+	IndexInterface *pIndex = m_settings.getIndex("MERGED");
         if (pIndex != NULL)
 	{
        	set<unsigned int> docIdList;
@@ -1939,7 +1939,7 @@
 		return;
 	}
 
-	WritableIndexInterface *pIndex = m_settings.getRWIndex(mapIter->second);
+	IndexInterface *pIndex = m_settings.getIndex(mapIter->second);
 	if ((pIndex == NULL) ||
 		(pIndex->isGood() == false))
 	{
@@ -2296,7 +2296,7 @@
 	m_state.m_liveQueryLength = liveQueryLength;
 
 	// Query the merged index
-	IndexInterface *pIndex = m_settings.getROIndex("MERGED");
+	IndexInterface *pIndex = m_settings.getIndex("MERGED");
 	if (pIndex != NULL)
 	{
 		set<string> suggestedTerms;
@@ -3060,7 +3060,7 @@
 		std::map<string, string>::const_iterator mapIter = indexesMap.find(indexName);
 		if (mapIter != indexesMap.end())
 		{
-			IndexInterface *pIndex = m_settings.getROIndex(mapIter->second);
+			IndexInterface *pIndex = m_settings.getIndex(mapIter->second);
 	
 			if (pIndex != NULL)
 			{

Modified: trunk/UI/GTK2/src/pinot-dbus-daemon.cc
===================================================================
--- trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-28 11:22:21 UTC (rev 441)
+++ trunk/UI/GTK2/src/pinot-dbus-daemon.cc	2006-08-29 13:31:28 UTC (rev 442)
@@ -44,7 +44,7 @@
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "DownloaderInterface.h"
-#include "WritableXapianIndex.h"
+#include "XapianIndex.h"
 #include "XapianEngine.h"
 #include "config.h"
 #include "NLS.h"
@@ -121,7 +121,7 @@
 
 static DBusHandlerResult messageBusFilter(DBusConnection *pConnection, DBusMessage *pMessage, void *pData)
 {
-	WritableXapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
+	XapianIndex index(PinotSettings::getInstance().m_daemonIndexLocation);
 	DaemonState *pServer = NULL;
 	DBusMessage *pReply = NULL;
 	DBusError error;



From fabricecolin at mail.berlios.de  Tue Aug 29 15:39:15 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Tue, 29 Aug 2006 15:39:15 +0200
Subject: [Pinot-svn] r443 - trunk/Search
Message-ID: <200608291339.k7TDdFIV024511@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-29 15:39:00 +0200 (Tue, 29 Aug 2006)
New Revision: 443

Modified:
   trunk/Search/XapianEngine.cpp
Log:
Backtracking on revision 353's changes. This will have to be revisited at some
point though.


Modified: trunk/Search/XapianEngine.cpp
===================================================================
--- trunk/Search/XapianEngine.cpp	2006-08-29 13:31:28 UTC (rev 442)
+++ trunk/Search/XapianEngine.cpp	2006-08-29 13:39:00 UTC (rev 443)
@@ -343,14 +343,7 @@
 		hostTerms.push_back(term);
 		if (followOperators == true)
 		{
-			if (queryStack.empty() == false)
-			{
-				queryOp = Xapian::Query::OP_FILTER;
-			}
-			else
-			{
-				queryOp = Xapian::Query::OP_AND;
-			}
+			queryOp = Xapian::Query::OP_AND;
 		}
 		queryStack.push(Xapian::Query(queryOp, hostTerms.begin(), hostTerms.end()));
 	}
@@ -365,14 +358,7 @@
 		fileTerms.push_back(term);
 		if (followOperators == true)
 		{
-			if (queryStack.empty() == false)
-			{
-				queryOp = Xapian::Query::OP_FILTER;
-			}
-			else
-			{
-				queryOp = Xapian::Query::OP_AND;
-			}
+			queryOp = Xapian::Query::OP_AND;
 		}
 		queryStack.push(Xapian::Query(queryOp, fileTerms.begin(), fileTerms.end()));
 	}
@@ -387,14 +373,7 @@
 		labelTerms.push_back(term);
 		if (followOperators == true)
 		{
-			if (queryStack.empty() == false)
-			{
-				queryOp = Xapian::Query::OP_FILTER;
-			}
-			else
-			{
-				queryOp = Xapian::Query::OP_AND;
-			}
+			queryOp = Xapian::Query::OP_AND;
 		}
 		queryStack.push(Xapian::Query(queryOp, labelTerms.begin(), labelTerms.end()));
 	}
@@ -413,14 +392,7 @@
 		languageTerms.push_back(term);
 		if (followOperators == true)
 		{
-			if (queryStack.empty() == false)
-			{
-				queryOp = Xapian::Query::OP_FILTER;
-			}
-			else
-			{
-				queryOp = Xapian::Query::OP_AND;
-			}
+			queryOp = Xapian::Query::OP_AND;
 		}
 		queryStack.push(Xapian::Query(queryOp, languageTerms.begin(), languageTerms.end()));
 	}



From fabricecolin at mail.berlios.de  Tue Aug 29 15:40:48 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Tue, 29 Aug 2006 15:40:48 +0200
Subject: [Pinot-svn] r444 - in trunk: SQL Tokenize
Message-ID: <200608291340.k7TDemSA026142@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-29 15:40:43 +0200 (Tue, 29 Aug 2006)
New Revision: 444

Modified:
   trunk/SQL/SQLiteBase.cpp
   trunk/Tokenize/HtmlTokenizer.cpp
Log:
Less verbose in DEBUG mode.


Modified: trunk/SQL/SQLiteBase.cpp
===================================================================
--- trunk/SQL/SQLiteBase.cpp	2006-08-29 13:39:00 UTC (rev 443)
+++ trunk/SQL/SQLiteBase.cpp	2006-08-29 13:40:43 UTC (rev 444)
@@ -41,9 +41,6 @@
 	}
 	else
 	{
-#ifdef DEBUG
-		cout << "SQLiteRow::SQLiteRow: " << rowColumns.size() << " columns" << endl;
-#endif
 		m_columns.reserve(rowColumns.size());
 #if 0
 		// FIXME: why does this segfault in string::assign() ?
@@ -209,9 +206,6 @@
 {
 	if (pDatabase != NULL)
 	{
-#ifdef DEBUG
-		cout << "SQLiteBase::close: changed " << sqlite3_total_changes(pDatabase) << " row(s)" << endl;
-#endif
 		sqlite3_close(pDatabase);
 	}
 }

Modified: trunk/Tokenize/HtmlTokenizer.cpp
===================================================================
--- trunk/Tokenize/HtmlTokenizer.cpp	2006-08-29 13:39:00 UTC (rev 443)
+++ trunk/Tokenize/HtmlTokenizer.cpp	2006-08-29 13:40:43 UTC (rev 444)
@@ -178,10 +178,6 @@
 		{
 			// FIXME: get the NodeInfo to find out the position of this link
 			pState->m_currentLink.m_startPos = pState->m_textPos;
-#ifdef DEBUG
-			cout << "HtmlTokenizer::endHandler: link " << pState->m_currentLink.m_index
-				<< " starts at position " << pState->m_textPos << endl;
-#endif
 
 			// Find abstract ?
 			if (pState->m_findAbstract == true)
@@ -269,10 +265,6 @@
 			StringManip::removeCharacters(pState->m_currentLink.m_name, "\r\n");
 
 			pState->m_currentLink.m_endPos = pState->m_textPos;
-#ifdef DEBUG
-			cout << "HtmlTokenizer::endHandler: link " << pState->m_currentLink.m_index
-				<< " ends at position " << pState->m_textPos << endl;
-#endif
 
 			// Store this link
 			pState->m_links.insert(pState->m_currentLink);



From fabricecolin at mail.berlios.de  Wed Aug 30 14:21:57 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 30 Aug 2006 14:21:57 +0200
Subject: [Pinot-svn] r445 - trunk/UI/GTK2/src
Message-ID: <200608301221.k7UCLv5b010907@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-30 14:21:55 +0200 (Wed, 30 Aug 2006)
New Revision: 445

Modified:
   trunk/UI/GTK2/src/MboxHandler.cpp
   trunk/UI/GTK2/src/OnDiskHandler.cpp
Log:
Minor fixes. OnDiskHandler sets the document's title to the file name, not
the full URL.


Modified: trunk/UI/GTK2/src/MboxHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-29 13:40:43 UTC (rev 444)
+++ trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-30 12:21:55 UTC (rev 445)
@@ -187,7 +187,7 @@
 				docInfo.setTimestamp(TimeConverter::toTimestamp(messageDate));
 
 				// Signal
-				m_signalUpdate(docInfo, docId, _("My Computer"));
+				m_signalUpdate(docInfo, docId, _("My Documents"));
 			}
 #ifdef DEBUG
 			else cout << "MboxHandler::parseMailAccount: couldn't index message " << docNum << endl;

Modified: trunk/UI/GTK2/src/OnDiskHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-29 13:40:43 UTC (rev 444)
+++ trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-30 12:21:55 UTC (rev 445)
@@ -14,8 +14,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#include <sys/types.h>
-#include <sys/stat.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <iostream>
@@ -50,8 +48,8 @@
 
 bool OnDiskHandler::indexFile(const string &fileName, bool alwaysUpdate)
 {
-	string url(string("file://") + fileName);
-	Url urlObj(url);
+	string location(string("file://") + fileName);
+	Url urlObj(location);
 	set<string> labels;
 	bool indexedFile = false;
 
@@ -62,7 +60,7 @@
 	}
 
 	// Has this file been indexed already ?
-	unsigned int docId = m_index.hasDocument(url);
+	unsigned int docId = m_index.hasDocument(location);
 	if ((docId > 0) &&
 		(alwaysUpdate == false))
 	{
@@ -70,14 +68,14 @@
 		return true;
 	}
 
-	DocumentInfo docInfo(url, url, MIMEScanner::scanUrl(urlObj), "");
+	DocumentInfo docInfo(urlObj.getFile(), location, MIMEScanner::scanUrl(urlObj), "");
 
 	FileCollector fileCollector;
 	Document *pDoc = fileCollector.retrieveUrl(docInfo);
 	if (pDoc == NULL)
 	{
 #ifdef DEBUG
-		cout << "OnDiskHandler::indexFile: couldn't download " << url << endl;
+		cout << "OnDiskHandler::indexFile: couldn't download " << location << endl;
 #endif
 
 		// The file  couldn't be downloaded but exists nonetheless !
@@ -112,10 +110,10 @@
 			docInfo.getLocation(), docInfo.getType(), docInfo.getLanguage());
 
 		// Signal
-		m_signalUpdate(indexedDocInfo, docId, _("My Computer"));
+		m_signalUpdate(indexedDocInfo, docId, _("My Documents"));
 	}
 #ifdef DEBUG
-	else cout << "OnDiskHandler::indexFile: couldn't index " << url << endl;
+	else cout << "OnDiskHandler::indexFile: couldn't index " << location << endl;
 #endif
 
 	delete pTokenizer;



From fabricecolin at mail.berlios.de  Wed Aug 30 16:15:48 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Wed, 30 Aug 2006 16:15:48 +0200
Subject: [Pinot-svn] r446 - trunk/UI/GTK2/src
Message-ID: <200608301415.k7UEFmPp031144@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-30 16:15:46 +0200 (Wed, 30 Aug 2006)
New Revision: 446

Modified:
   trunk/UI/GTK2/src/DaemonState.cpp
   trunk/UI/GTK2/src/DaemonState.h
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
Log:
Slightly better at monitoring directories. New directories are crawled and
monitored but moving and deletion don't do the right thing just yet.


Modified: trunk/UI/GTK2/src/DaemonState.cpp
===================================================================
--- trunk/UI/GTK2/src/DaemonState.cpp	2006-08-30 12:21:55 UTC (rev 445)
+++ trunk/UI/GTK2/src/DaemonState.cpp	2006-08-30 14:15:46 UTC (rev 446)
@@ -68,6 +68,7 @@
 	pMbox->getUpdateSignal().connect(
 		SigC::slot(*this, &DaemonState::on_message_indexupdate));
 	MonitorThread *pMailMonitorThread = new MonitorThread(m_pMailMonitor, pMbox);
+	pMailMonitorThread->getDirectoryFoundSignal().connect(SigC::slot(*this, &DaemonState::on_message_filefound));
 	start_thread(pMailMonitorThread, true);
 
 	// Same for the disk monitor thread
@@ -76,6 +77,7 @@
 	pDisk->getUpdateSignal().connect(
 		SigC::slot(*this, &DaemonState::on_message_indexupdate));
 	MonitorThread *pDiskMonitorThread = new MonitorThread(m_pDiskMonitor, pDisk);
+	pDiskMonitorThread->getDirectoryFoundSignal().connect(SigC::slot(*this, &DaemonState::on_message_filefound));
 	start_thread(pDiskMonitorThread, true);
 
 	for (set<PinotSettings::TimestampedItem>::const_iterator locationIter = PinotSettings::getInstance().m_indexableLocations.begin();
@@ -98,21 +100,13 @@
 	{
 		// Scan the directory and import all its files
 		DirectoryScannerThread *pScannerThread = new DirectoryScannerThread(m_pDiskMonitor,
-			locationToCrawl, 0, true, &m_scanMutex, &m_scanCondVar);
+			locationToCrawl, 0, true);
 		pScannerThread->getFileFoundSignal().connect(SigC::slot(*this, &DaemonState::on_message_filefound));
 
 		m_crawling = start_thread(pScannerThread);
 	}
 }
 
-void DaemonState::signal_scanner(void)
-{
-	// Ask the scanner for another file
-	m_scanMutex.lock();
-	m_scanCondVar.signal();
-	m_scanMutex.unlock();
-}
-
 void DaemonState::on_thread_end(WorkerThread *pThread)
 {
 	string indexedUrl;
@@ -163,7 +157,7 @@
 				}
 
 				pNewScannerThread = new DirectoryScannerThread(m_pDiskMonitor,
-					locationToCrawl, 0, true, &m_scanMutex, &m_scanCondVar);
+					locationToCrawl, 0, true);
 				pNewScannerThread->getFileFoundSignal().connect(SigC::slot(*this,
 					&DaemonState::on_message_filefound));
 
@@ -199,12 +193,6 @@
 
 		// Get the URL we have just indexed
 		indexedUrl = pIndexThread->getURL();
-
-		// Get another file from the directory scanner if possible
-		if (m_crawling == true)
-		{
-			signal_scanner();
-		}
 	}
 	else if (type == "UnindexingThread")
 	{
@@ -234,18 +222,30 @@
 	// FIXME: anything to do ?
 }
 
-bool DaemonState::on_message_filefound(const string &location, const string &sourceLabel)
+void DaemonState::on_message_filefound(const string &location, const string &sourceLabel, bool isDirectory)
 {
-	Url urlObj(location);
-	set<string> labels;
+	if (isDirectory == false)
+	{
+		Url urlObj(location);
+		DocumentInfo docInfo(urlObj.getFile(), location, "", "");
+		set<string> labels;
 
-	DocumentInfo docInfo(urlObj.getFile(), location, "", "");
-	// Insert a label that identifies the source
-	labels.insert(sourceLabel);
-	docInfo.setLabels(labels);
+		// Insert a label that identifies the source
+		labels.insert(sourceLabel);
+		docInfo.setLabels(labels);
 
-	queue_index(docInfo);
+		queue_index(docInfo);
+	}
+	else
+	{
+		DirectoryScannerThread *pScannerThread = new DirectoryScannerThread(m_pDiskMonitor,
+			location.substr(7), 0, true);
+		pScannerThread->getFileFoundSignal().connect(SigC::slot(*this, &DaemonState::on_message_filefound));
 
-	// Don't request another file right now
-	return false;
+#ifdef DEBUG
+		cout << "DaemonState::on_message_filefound: new directory " << location.substr(7) << endl;
+#endif
+		m_crawling = start_thread(pScannerThread);
+	}
 }
+

Modified: trunk/UI/GTK2/src/DaemonState.h
===================================================================
--- trunk/UI/GTK2/src/DaemonState.h	2006-08-30 12:21:55 UTC (rev 445)
+++ trunk/UI/GTK2/src/DaemonState.h	2006-08-30 14:15:46 UTC (rev 446)
@@ -20,7 +20,6 @@
 #include <string>
 #include <queue>
 #include <set>
-#include <glibmm/thread.h>
 
 #include "MonitorInterface.h"
 #include "IndexedDocument.h"
@@ -40,7 +39,8 @@
 
 		void on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, std::string indexName);
 
-		bool on_message_filefound(const std::string &location, const std::string &sourceLabel);
+		void on_message_filefound(const std::string &location, const std::string &sourceLabel,
+			bool isDirectory);
 
 	protected:
 		MonitorInterface *m_pMailMonitor;
@@ -48,8 +48,6 @@
 		std::queue<std::string> m_crawlQueue;
 		std::set<std::string> m_monitoredLocations;
 		bool m_crawling;
-		Glib::Mutex m_scanMutex;
-		Glib::Cond m_scanCondVar;
 
 };
 

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-30 12:21:55 UTC (rev 445)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-30 14:15:46 UTC (rev 446)
@@ -848,7 +848,7 @@
 bool ExpandQueryThread::stop(void)
 {
 	m_done = true;
-	m_status = _("Stopped expanding ");
+	m_status = _("Stopped expanding");
 	m_status += " ";
 	m_status += m_queryProps.getName();
 	return true;
@@ -874,7 +874,7 @@
 	// Run the query
 	if (pEngine->runQuery(m_queryProps) == false)
 	{
-		m_status = _("Couldn't expand ");
+		m_status = _("Couldn't expand");
 		m_status += " ";
 		m_status += m_queryProps.getName();
 	}
@@ -1520,6 +1520,11 @@
 	return true;
 }
 
+Signal3<void, const string&, const std::string&, bool>& MonitorThread::getDirectoryFoundSignal(void)
+{
+	return m_signalDirectoryFound;
+}
+
 void MonitorThread::processEvents(void)
 {
 	queue<MonitorEvent> events;
@@ -1547,51 +1552,63 @@
 			events.pop();
 			continue;
 		}
-
-		// What's the event code ?
 #ifdef DEBUG
-		cout << "MonitorThread::processEvents: event on " << event.m_location << endl;
+		cout << "MonitorThread::processEvents: event " << event.m_type << " on "
+			<< event.m_location << " " << event.m_isDirectory << endl;
 #endif
+
+		// What's the event code ?
 		if (event.m_type == MonitorEvent::EXISTS)
 		{
-			m_pHandler->fileExists(event.m_location);
+			if (event.m_isDirectory == false)
+			{
+				m_pHandler->fileExists(event.m_location);
+			}
 		}
 		else if (event.m_type == MonitorEvent::CREATED)
 		{
-			m_pHandler->fileCreated(event.m_location);
-
-			// If a whole directory was created, monitor it
-			if (event.m_isDirectory == true)
+			if (event.m_isDirectory == false)
 			{
-				// FIXME: crawl it first !
-				m_pMonitor->addLocation(event.m_location, true);
+				m_pHandler->fileCreated(event.m_location);
 			}
+			else
+			{
+				// Report this directory so that it is crawled
+				m_signalDirectoryFound(string("file://") + event.m_location, "", true);
+			}
 		}
 		else if (event.m_type == MonitorEvent::WRITE_CLOSED)
 		{
-			m_pHandler->fileModified(event.m_location);
+			if (event.m_isDirectory == false)
+			{
+				m_pHandler->fileModified(event.m_location);
+			}
 		}
 		else if (event.m_type == MonitorEvent::MOVED)
 		{
-			m_pHandler->fileMoved(event.m_location, event.m_previousLocation);
-
-			if ((event.m_isDirectory == true) &&
-				(event.m_isWatch == true))
+			if (event.m_isDirectory == false)
 			{
+				m_pHandler->fileMoved(event.m_location, event.m_previousLocation);
+			}
+			else
+			{
 				// Stop monitoring
 				m_pMonitor->removeLocation(event.m_previousLocation);
-				// FIXME: monitor the new location
+				// FIXME: monitor the new location if under an indexable location
+				// FIXME: do the right thing for files under this directory
 			}
 		}
 		else if (event.m_type == MonitorEvent::DELETED)
 		{
-			m_pHandler->fileDeleted(event.m_location);
-
-			if ((event.m_isDirectory == true) &&
-				(event.m_isWatch == true))
+			if (event.m_isDirectory == false)
 			{
+				m_pHandler->fileDeleted(event.m_location);
+			}
+			else
+			{
 				// Stop monitoring
 				m_pMonitor->removeLocation(event.m_location);
+				// FIXME: do the right thing for files under this directory
 			}
 		}
 
@@ -1668,15 +1685,12 @@
 }
 
 DirectoryScannerThread::DirectoryScannerThread(MonitorInterface *pMonitor,
-	const string &dirName, unsigned int maxLevel, bool followSymLinks,
-	Mutex *pMutex, Cond *pCondVar) :
+	const string &dirName, unsigned int maxLevel, bool followSymLinks) :
 	WorkerThread(),
 	m_pMonitor(pMonitor),
 	m_dirName(dirName),
 	m_maxLevel(maxLevel),
 	m_followSymLinks(followSymLinks),
-	m_pMutex(pMutex),
-	m_pCondVar(pCondVar),
 	m_currentLevel(0),
 	m_sourceId(0)
 {
@@ -1712,46 +1726,24 @@
 	return true;
 }
 
-Signal2<bool, const string&, const std::string&>& DirectoryScannerThread::getFileFoundSignal(void)
+Signal3<void, const string&, const std::string&, bool>& DirectoryScannerThread::getFileFoundSignal(void)
 {
 	return m_signalFileFound;
 }
 
 void DirectoryScannerThread::foundFile(const string &fileName)
 {
+	char labelStr[64];
+
 	if (fileName.empty() == true)
 	{
 		return;
 	}
 
-	if ((m_pMutex != NULL) &&
-		(m_pCondVar != NULL))
-	{
-		string url("file://" + fileName);
-		char labelStr[64];
+	// This identifies the source
+	snprintf(labelStr, 64, "SOURCE%u", m_sourceId);
 
-		// This identifies the source
-		snprintf(labelStr, 64, "SOURCE%u", m_sourceId);
-
-		m_pMutex->lock();
-		if (m_signalFileFound(url, labelStr) == true)
-		{
-			// Another file is needed right now
-			m_pMutex->unlock();
-		}
-		else
-		{
-#ifdef DEBUG
-			cout << "DirectoryScannerThread::foundFile: waiting" << endl;
-#endif
-			// Don't resume until signaled
-			m_pCondVar->wait(*m_pMutex);
-			m_pMutex->unlock();
-#ifdef DEBUG
-			cout << "DirectoryScannerThread::foundFile: signaled" << endl;
-#endif
-		}
-	}
+	m_signalFileFound(string("file://") + fileName, labelStr, false);
 }
 
 bool DirectoryScannerThread::scanDirectory(const string &dirName)

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2006-08-30 12:21:55 UTC (rev 445)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2006-08-30 14:15:46 UTC (rev 446)
@@ -405,11 +405,14 @@
 
 		virtual bool stop(void);
 
+		SigC::Signal3<void, const std::string&, const std::string&, bool>& getDirectoryFoundSignal(void);
+
 	protected:
 		int m_ctrlReadPipe;
 		int m_ctrlWritePipe;
 		MonitorInterface *m_pMonitor;
 		MonitorHandler *m_pHandler;
+		SigC::Signal3<void, const std::string&, const std::string&, bool> m_signalDirectoryFound;
 
 		void processEvents(void);
 		virtual void doWork(void);
@@ -424,8 +427,7 @@
 {
 	public:
 		DirectoryScannerThread(MonitorInterface *pMonitor,
-			const std::string &dirName, unsigned int maxLevel, bool followSymLinks,
-			Glib::Mutex *pMutex, Glib::Cond *pCondVar);
+			const std::string &dirName, unsigned int maxLevel, bool followSymLinks);
 		virtual ~DirectoryScannerThread();
 
 		virtual std::string getType(void) const;
@@ -434,18 +436,16 @@
 
 		virtual bool stop(void);
 
-		SigC::Signal2<bool, const std::string&, const std::string&>& getFileFoundSignal(void);
+		SigC::Signal3<void, const std::string&, const std::string&, bool>& getFileFoundSignal(void);
 
 	protected:
 		MonitorInterface *m_pMonitor;
 		std::string m_dirName;
 		unsigned int m_maxLevel;
 		bool m_followSymLinks;
-		Glib::Mutex *m_pMutex;
-		Glib::Cond *m_pCondVar;
 		unsigned int m_currentLevel;
 		unsigned int m_sourceId;
-		SigC::Signal2<bool, const std::string&, const std::string&> m_signalFileFound;
+		SigC::Signal3<void, const std::string&, const std::string&, bool> m_signalFileFound;
 
 		void foundFile(const std::string &fileName);
 		bool scanDirectory(const std::string &dirName);



From fabricecolin at mail.berlios.de  Thu Aug 31 13:42:44 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 31 Aug 2006 13:42:44 +0200
Subject: [Pinot-svn] r447 - trunk/Index
Message-ID: <200608311142.k7VBgix4026579@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-31 13:42:41 +0200 (Thu, 31 Aug 2006)
New Revision: 447

Modified:
   trunk/Index/DBusXapianIndex.cpp
   trunk/Index/DBusXapianIndex.h
   trunk/Index/IndexInterface.h
   trunk/Index/XapianIndex.cpp
   trunk/Index/XapianIndex.h
Log:
List of documents under a given directory can be obtained with
listDocumentsInDirectory().


Modified: trunk/Index/DBusXapianIndex.cpp
===================================================================
--- trunk/Index/DBusXapianIndex.cpp	2006-08-30 14:15:46 UTC (rev 446)
+++ trunk/Index/DBusXapianIndex.cpp	2006-08-31 11:42:41 UTC (rev 447)
@@ -177,7 +177,7 @@
 	return XapianIndex::listDocuments(docIds, maxDocsCount, startDoc);
 }
 
-/// Lists documents that have a label.
+/// Lists documents that have a specific label.
 bool DBusXapianIndex::listDocumentsWithLabel(const string &name, set<unsigned int> &docIds,
 	unsigned int maxDocsCount, unsigned int startDoc) const
 {
@@ -186,6 +186,15 @@
 	return XapianIndex::listDocumentsWithLabel(name, docIds, maxDocsCount, startDoc);
 }
 
+/// Lists documents that have a specific directory.
+bool DBusXapianIndex::listDocumentsInDirectory(const string &dirName, set<unsigned int> &docIds,
+	unsigned int maxDocsCount, unsigned int startDoc) const
+{
+	reopen();
+
+	return XapianIndex::listDocumentsWithLabel(dirName, docIds, maxDocsCount, startDoc);
+}
+
 /// Indexes the given data.
 bool DBusXapianIndex::indexDocument(Tokenizer &tokens, const set<string> &labels,
 	unsigned int &docId)

Modified: trunk/Index/DBusXapianIndex.h
===================================================================
--- trunk/Index/DBusXapianIndex.h	2006-08-30 14:15:46 UTC (rev 446)
+++ trunk/Index/DBusXapianIndex.h	2006-08-31 11:42:41 UTC (rev 447)
@@ -62,10 +62,14 @@
 		virtual unsigned int listDocuments(std::set<unsigned int> &docIds,
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
 
-		/// Lists documents that have a label.
+		/// Lists documents that have a specific label.
 		virtual bool listDocumentsWithLabel(const std::string &name, std::set<unsigned int> &docIds,
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
 
+		/// Lists documents that are in a specific directory.
+		virtual bool listDocumentsInDirectory(const std::string &dirName, std::set<unsigned int> &docIds,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
+
 		/// Indexes the given data.
 		virtual bool indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
 			unsigned int &docId);

Modified: trunk/Index/IndexInterface.h
===================================================================
--- trunk/Index/IndexInterface.h	2006-08-30 14:15:46 UTC (rev 446)
+++ trunk/Index/IndexInterface.h	2006-08-31 11:42:41 UTC (rev 447)
@@ -70,10 +70,14 @@
 		virtual unsigned int listDocuments(std::set<unsigned int> &docIDList,
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const = 0;
 
-		/// Lists documents that have a label.
+		/// Lists documents that have a specific label.
 		virtual bool listDocumentsWithLabel(const std::string &name, std::set<unsigned int> &docIds,
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const = 0;
 
+		/// Lists documents that are in a specific directory.
+		virtual bool listDocumentsInDirectory(const std::string &dirName, std::set<unsigned int> &docIds,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const = 0;
+
 		/// Sets the stemming mode.
 		virtual void setStemmingMode(StemmingMode mode) { m_stemMode = mode; }
 

Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2006-08-30 14:15:46 UTC (rev 446)
+++ trunk/Index/XapianIndex.cpp	2006-08-31 11:42:41 UTC (rev 447)
@@ -928,17 +928,26 @@
 	return listDocumentsWithTerm(MAGIC_TERM, docIds, maxDocsCount, startDoc);
 }
 
-/// Lists documents that have a label.
+/// Lists documents that have a specific label.
 bool XapianIndex::listDocumentsWithLabel(const string &name, set<unsigned int> &docIds,
 	unsigned int maxDocsCount, unsigned int startDoc) const
 {
 	string term("XLABEL:");
 
-	// Get documents that have this label
 	term += name;
 	return listDocumentsWithTerm(term, docIds, maxDocsCount, startDoc);
 }
 
+/// Lists documents that are in a specific directory.
+bool XapianIndex::listDocumentsInDirectory(const string &dirName, set<unsigned int> &docIds,
+	unsigned int maxDocsCount, unsigned int startDoc) const
+{
+	string term("XDIR:");
+
+	term += dirName;
+	return listDocumentsWithTerm(term, docIds, maxDocsCount, startDoc);
+}
+
 /// Indexes the given data.
 bool XapianIndex::indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
 	unsigned int &docId)

Modified: trunk/Index/XapianIndex.h
===================================================================
--- trunk/Index/XapianIndex.h	2006-08-30 14:15:46 UTC (rev 446)
+++ trunk/Index/XapianIndex.h	2006-08-31 11:42:41 UTC (rev 447)
@@ -63,10 +63,14 @@
 		virtual unsigned int listDocuments(std::set<unsigned int> &docIds,
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
 
-		/// Lists documents that have a label.
+		/// Lists documents that have a specific label.
 		virtual bool listDocumentsWithLabel(const std::string &name, std::set<unsigned int> &docIds,
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
 
+		/// Lists documents that are in a specific directory.
+		virtual bool listDocumentsInDirectory(const std::string &dirName, std::set<unsigned int> &docIds,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
+
 		/// Indexes the given data.
 		virtual bool indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
 			unsigned int &docId);



From fabricecolin at mail.berlios.de  Thu Aug 31 13:44:42 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 31 Aug 2006 13:44:42 +0200
Subject: [Pinot-svn] r448 - trunk/Monitor
Message-ID: <200608311144.k7VBigOV027423@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-31 13:44:26 +0200 (Thu, 31 Aug 2006)
New Revision: 448

Modified:
   trunk/Monitor/INotifyMonitor.cpp
   trunk/Monitor/MonitorHandler.h
Log:
If a watch has moved, INotifyMonitor updates its details.
New methods to MonitorHandler for events on directories.


Modified: trunk/Monitor/INotifyMonitor.cpp
===================================================================
--- trunk/Monitor/INotifyMonitor.cpp	2006-08-31 11:42:41 UTC (rev 447)
+++ trunk/Monitor/INotifyMonitor.cpp	2006-08-31 11:44:26 UTC (rev 448)
@@ -245,6 +245,20 @@
 					<< monEvent.m_previousLocation << endl;
 #endif
 				m_movedFrom.erase(movedIter);
+
+				// Has a watch moved ?
+				if ((monEvent.m_isWatch == true) &&
+					(monEvent.m_previousLocation == watchIter->second))
+				{
+					// Update the location for this watch
+					map<string, int>::iterator locationIter = m_locations.find(watchIter->second);
+					if (locationIter != m_locations.end())
+					{
+						m_locations.erase(locationIter);
+						m_locations[monEvent.m_location] = pEvent->wd;
+					}
+					watchIter->second = monEvent.m_location;
+				}
 			}
 #ifdef DEBUG
 			else cout << "INotifyMonitor::retrievePendingEvents: don't know where file was moved from" << endl;

Modified: trunk/Monitor/MonitorHandler.h
===================================================================
--- trunk/Monitor/MonitorHandler.h	2006-08-31 11:42:41 UTC (rev 447)
+++ trunk/Monitor/MonitorHandler.h	2006-08-31 11:44:26 UTC (rev 448)
@@ -51,9 +51,16 @@
 		virtual bool fileMoved(const std::string &fileName,
 			const std::string &previousFileName) = 0;
 
+		/// Handles directory moved events.
+		virtual bool directoryMoved(const std::string &dirName,
+			const std::string &previousDirName) = 0;
+
 		/// Handles file deleted events.
 		virtual bool fileDeleted(const std::string &fileName) = 0;
 
+		/// Handles directory deleted events.
+		virtual bool directoryDeleted(const std::string &dirName) = 0;
+
 		/// Returns the names of files to monitor.
 		const std::set<std::string> &getFileNames(void) const;
 



From fabricecolin at mail.berlios.de  Thu Aug 31 13:46:38 2006
From: fabricecolin at mail.berlios.de (fabricecolin at BerliOS)
Date: Thu, 31 Aug 2006 13:46:38 +0200
Subject: [Pinot-svn] r449 - trunk/UI/GTK2/src
Message-ID: <200608311146.k7VBkcUe028143@sheep.berlios.de>

Author: fabricecolin
Date: 2006-08-31 13:46:35 +0200 (Thu, 31 Aug 2006)
New Revision: 449

Modified:
   trunk/UI/GTK2/src/MboxHandler.cpp
   trunk/UI/GTK2/src/MboxHandler.h
   trunk/UI/GTK2/src/OnDiskHandler.cpp
   trunk/UI/GTK2/src/OnDiskHandler.h
   trunk/UI/GTK2/src/WorkerThreads.cpp
Log:
Support for move and delete events on directories. OnDisk will move or delete
all documents under a given directory.


Modified: trunk/UI/GTK2/src/MboxHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-31 11:44:26 UTC (rev 448)
+++ trunk/UI/GTK2/src/MboxHandler.cpp	2006-08-31 11:46:35 UTC (rev 449)
@@ -354,6 +354,13 @@
 	return true;
 }
 
+bool MboxHandler::directoryMoved(const string &dirName,
+	const string &previousDirName)
+{
+	// Nothing to do here
+	return true;
+}
+
 bool MboxHandler::fileDeleted(const string &fileName)
 {
 	set<unsigned int> docIdList;
@@ -380,3 +387,10 @@
 
 	return false;
 }
+
+bool MboxHandler::directoryDeleted(const string &dirName)
+{
+	// Nothing to do here
+	return true;
+}
+

Modified: trunk/UI/GTK2/src/MboxHandler.h
===================================================================
--- trunk/UI/GTK2/src/MboxHandler.h	2006-08-31 11:44:26 UTC (rev 448)
+++ trunk/UI/GTK2/src/MboxHandler.h	2006-08-31 11:46:35 UTC (rev 449)
@@ -54,9 +54,16 @@
 		virtual bool fileMoved(const std::string &fileName,
 			const std::string &previousFileName);
 
+		/// Handles directory moved events.
+		virtual bool directoryMoved(const std::string &dirName,
+			const std::string &previousDirName);
+
 		/// Handles file deleted events.
 		virtual bool fileDeleted(const std::string &fileName);
 
+		/// Handles directory deleted events.
+		virtual bool directoryDeleted(const std::string &dirName);
+
 	protected:
 		CrawlHistory m_history;
 		XapianIndex m_index;

Modified: trunk/UI/GTK2/src/OnDiskHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-31 11:44:26 UTC (rev 448)
+++ trunk/UI/GTK2/src/OnDiskHandler.cpp	2006-08-31 11:46:35 UTC (rev 449)
@@ -122,6 +122,20 @@
 	return indexedFile;
 }
 
+bool OnDiskHandler::replaceFile(unsigned int docId, DocumentInfo &docInfo)
+{
+	// Has the destination file been indexed too ?
+	unsigned int destDocId = m_index.hasDocument(docInfo.getLocation());
+	if (destDocId > 0)
+	{
+		// Unindex it
+		m_index.unindexDocument(destDocId);
+	}
+
+	// Update the document info
+	return m_index.updateDocumentInfo(docId, docInfo);
+}
+
 void OnDiskHandler::initialize(void)
 {
 	map<unsigned int, string> sources;
@@ -213,22 +227,57 @@
 	{
 		DocumentInfo docInfo;
 
-		m_index.getDocumentInfo(oldDocId, docInfo);
+		if (m_index.getDocumentInfo(oldDocId, docInfo) == true)
+		{
+			// Change the location
+			docInfo.setLocation(string("file://") + fileName);
 
-		// Has the destination file been indexed too ?
-		unsigned int docId = m_index.hasDocument(string("file://") + fileName);
-		if (docId > 0)
+			return replaceFile(oldDocId, docInfo);
+		}
+	}
+
+	return false; 
+}
+
+bool OnDiskHandler::directoryMoved(const string &dirName,
+	const string &previousDirName)
+{
+	set<unsigned int> docIdList;
+
+#ifdef DEBUG
+	cout << "OnDiskHandler::directoryMoved: " << dirName << endl;
+#endif
+	if (m_index.listDocumentsInDirectory(previousDirName, docIdList) == true)
+	{
+		for (set<unsigned int>::const_iterator iter = docIdList.begin();
+			iter != docIdList.end(); ++iter)
 		{
-			// Unindex it
-			m_index.unindexDocument(docId);
+			DocumentInfo docInfo;
+
+			if (m_index.getDocumentInfo(*iter, docInfo) == true)
+			{
+				string newLocation(docInfo.getLocation());
+
+				string::size_type pos = newLocation.find(previousDirName);
+				if (pos != string::npos)
+				{
+					newLocation.replace(pos, previousDirName.length(), dirName);
+
+					// Change the location
+					docInfo.setLocation(newLocation);
+
+					replaceFile(*iter, docInfo);
+				}
+			}
 		}
 
-		// Change the location
-		docInfo.setLocation(string("file://") + fileName);
-		return m_index.updateDocumentInfo(oldDocId, docInfo);
+		return true;
 	}
+#ifdef DEBUG
+	cout << "OnDiskHandler::directoryMoved: no documents in " << previousDirName << endl;
+#endif
 
-	return false; 
+	return false;
 }
 
 bool OnDiskHandler::fileDeleted(const string &fileName)
@@ -245,3 +294,28 @@
 
 	return false;
 }
+
+bool OnDiskHandler::directoryDeleted(const string &dirName)
+{
+	set<unsigned int> docIdList;
+
+#ifdef DEBUG
+	cout << "OnDiskHandler::directoryDeleted: " << dirName << endl;
+#endif
+	if (m_index.listDocumentsInDirectory(dirName, docIdList) == true)
+	{
+		for (set<unsigned int>::const_iterator iter = docIdList.begin();
+			iter != docIdList.end(); ++iter)
+		{
+			m_index.unindexDocument(*iter);
+		}
+
+		return true;
+	}
+#ifdef DEBUG
+	cout << "OnDiskHandler::directoryDeleted: no documents in " << dirName << endl;
+#endif
+
+	return false;
+}
+

Modified: trunk/UI/GTK2/src/OnDiskHandler.h
===================================================================
--- trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-31 11:44:26 UTC (rev 448)
+++ trunk/UI/GTK2/src/OnDiskHandler.h	2006-08-31 11:46:35 UTC (rev 449)
@@ -53,15 +53,24 @@
 		virtual bool fileMoved(const std::string &fileName,
 			const std::string &previousFileName);
 
+		/// Handles directory moved events.
+		virtual bool directoryMoved(const std::string &dirName,
+			const std::string &previousDirName);
+
 		/// Handles file deleted events.
 		virtual bool fileDeleted(const std::string &fileName);
 
+		/// Handles directory deleted events.
+		virtual bool directoryDeleted(const std::string &dirName);
+
 	protected:
 		CrawlHistory m_history;
 		XapianIndex m_index;
 
 		bool indexFile(const std::string &fileName, bool alwaysUpdate);
 
+		bool replaceFile(unsigned int docId, DocumentInfo &docInfo);
+
 	private:
 		OnDiskHandler(const OnDiskHandler &other);
 		OnDiskHandler &operator=(const OnDiskHandler &other);

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-31 11:44:26 UTC (rev 448)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2006-08-31 11:46:35 UTC (rev 449)
@@ -1592,10 +1592,9 @@
 			}
 			else
 			{
-				// Stop monitoring
-				m_pMonitor->removeLocation(event.m_previousLocation);
-				// FIXME: monitor the new location if under an indexable location
-				// FIXME: do the right thing for files under this directory
+				// FIXME: stop monitoring if not under an indexable location
+
+				m_pHandler->directoryMoved(event.m_location, event.m_previousLocation);
 			}
 		}
 		else if (event.m_type == MonitorEvent::DELETED)
@@ -1606,9 +1605,9 @@
 			}
 			else
 			{
-				// Stop monitoring
-				m_pMonitor->removeLocation(event.m_location);
-				// FIXME: do the right thing for files under this directory
+				// The monitoring should have stopped monitoring this
+				// In practice, events for the files in this directory will already have been received 
+				m_pHandler->directoryDeleted(event.m_location);
 			}
 		}
 



