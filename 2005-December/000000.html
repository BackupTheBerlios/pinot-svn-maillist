<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Pinot-svn] r1 - / trunk trunk/Collect trunk/Index trunk/SQL trunk/Search trunk/Search/Google trunk/Search/ObjectsSearch trunk/Search/Plugins trunk/Tokenize trunk/UI trunk/UI/GTK2 trunk/UI/GTK2/src trunk/UI/RenderHTML trunk/Utils trunk/po
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/pinot-svn/2005-December/index.html" >
   <LINK REL="made" HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r1%20-%20/%20trunk%20trunk/Collect%20trunk/Index%20trunk/SQL%20trunk/Search%20trunk/Search/Google%20trunk/Search/ObjectsSearch%20trunk/Search/Plugins%20trunk/Tokenize%20trunk/UI%20trunk/UI/GTK2%20trunk/UI/GTK2/src%20trunk/UI/RenderHTML%20trunk/Utils%20trunk/po&In-Reply-To=%3C200512081347.jB8DlFcA029750%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000001.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Pinot-svn] r1 - / trunk trunk/Collect trunk/Index trunk/SQL trunk/Search trunk/Search/Google trunk/Search/ObjectsSearch trunk/Search/Plugins trunk/Tokenize trunk/UI trunk/UI/GTK2 trunk/UI/GTK2/src trunk/UI/RenderHTML trunk/Utils trunk/po</H1>
    <B>fabricecolin at BerliOS</B> 
    <A HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r1%20-%20/%20trunk%20trunk/Collect%20trunk/Index%20trunk/SQL%20trunk/Search%20trunk/Search/Google%20trunk/Search/ObjectsSearch%20trunk/Search/Plugins%20trunk/Tokenize%20trunk/UI%20trunk/UI/GTK2%20trunk/UI/GTK2/src%20trunk/UI/RenderHTML%20trunk/Utils%20trunk/po&In-Reply-To=%3C200512081347.jB8DlFcA029750%40sheep.berlios.de%3E"
       TITLE="[Pinot-svn] r1 - / trunk trunk/Collect trunk/Index trunk/SQL trunk/Search trunk/Search/Google trunk/Search/ObjectsSearch trunk/Search/Plugins trunk/Tokenize trunk/UI trunk/UI/GTK2 trunk/UI/GTK2/src trunk/UI/RenderHTML trunk/Utils trunk/po">fabricecolin at berlios.de
       </A><BR>
    <I>Thu Dec  8 14:47:15 CET 2005</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000001.html">[Pinot-svn] r2 - /
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#0">[ date ]</a>
              <a href="thread.html#0">[ thread ]</a>
              <a href="subject.html#0">[ subject ]</a>
              <a href="author.html#0">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fabricecolin
Date: 2005-12-08 14:46:51 +0100 (Thu, 08 Dec 2005)
New Revision: 1

Added:
   trunk/
   trunk/COPYING
   trunk/ChangeLog
   trunk/Collect/
   trunk/Collect/DownloaderFactory.cpp
   trunk/Collect/DownloaderFactory.h
   trunk/Collect/DownloaderInterface.cpp
   trunk/Collect/DownloaderInterface.h
   trunk/Collect/FileCollector.cpp
   trunk/Collect/FileCollector.h
   trunk/Collect/Makefile
   trunk/Collect/MboxCollector.cpp
   trunk/Collect/MboxCollector.h
   trunk/Collect/NeonDownloader.cpp
   trunk/Collect/NeonDownloader.h
   trunk/Collect/XapianCollector.cpp
   trunk/Collect/XapianCollector.h
   trunk/Collect/dloadtest.cpp
   trunk/Index/
   trunk/Index/IndexInterface.h
   trunk/Index/LanguageDetector.cpp
   trunk/Index/LanguageDetector.h
   trunk/Index/Makefile
   trunk/Index/Summarizer.cpp
   trunk/Index/Summarizer.h
   trunk/Index/XapianIndex.cpp
   trunk/Index/XapianIndex.h
   trunk/Index/indextest.cpp
   trunk/Makefile
   trunk/README
   trunk/SQL/
   trunk/SQL/ActionHistory.cpp
   trunk/SQL/ActionHistory.h
   trunk/SQL/IndexHistory.cpp
   trunk/SQL/IndexHistory.h
   trunk/SQL/LabelManager.cpp
   trunk/SQL/LabelManager.h
   trunk/SQL/Makefile
   trunk/SQL/QueryHistory.cpp
   trunk/SQL/QueryHistory.h
   trunk/SQL/SQLiteBase.cpp
   trunk/SQL/SQLiteBase.h
   trunk/SQL/ViewHistory.cpp
   trunk/SQL/ViewHistory.h
   trunk/SQL/historytest.cpp
   trunk/Search/
   trunk/Search/Google/
   trunk/Search/Google/GoogleAPIEngine.cpp
   trunk/Search/Google/GoogleAPIEngine.h
   trunk/Search/Google/GoogleSearch.h
   trunk/Search/Google/Makefile
   trunk/Search/Makefile
   trunk/Search/ObjectsSearch/
   trunk/Search/ObjectsSearch/Makefile
   trunk/Search/ObjectsSearch/ObjectsSearch.h
   trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.cpp
   trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.h
   trunk/Search/PluginWebEngine.cpp
   trunk/Search/PluginWebEngine.h
   trunk/Search/Plugins/
   trunk/Search/Plugins/A9.src
   trunk/Search/Plugins/Acoona.src
   trunk/Search/Plugins/Altavista.src
   trunk/Search/Plugins/AmazonAPI.src
   trunk/Search/Plugins/AskJeeves.src
   trunk/Search/Plugins/BitTorrent.src
   trunk/Search/Plugins/Clusty.src
   trunk/Search/Plugins/Freshmeat.src
   trunk/Search/Plugins/Google.src
   trunk/Search/Plugins/Koders.src
   trunk/Search/Plugins/Lycos.src
   trunk/Search/Plugins/MSN.src
   trunk/Search/Plugins/Omega.src
   trunk/Search/Plugins/Teoma.src
   trunk/Search/Plugins/Topix.src
   trunk/Search/Plugins/Wikipedia.src
   trunk/Search/Plugins/WiseNut.src
   trunk/Search/Plugins/Yahoo.src
   trunk/Search/Plugins/YahooAPI.src
   trunk/Search/QueryProperties.cpp
   trunk/Search/QueryProperties.h
   trunk/Search/SOAPEnvNS.cpp
   trunk/Search/SearchEngineFactory.cpp
   trunk/Search/SearchEngineFactory.h
   trunk/Search/SearchEngineInterface.cpp
   trunk/Search/SearchEngineInterface.h
   trunk/Search/WebEngine.cpp
   trunk/Search/WebEngine.h
   trunk/Search/XapianEngine.cpp
   trunk/Search/XapianEngine.h
   trunk/Search/senginetest.cpp
   trunk/TODO
   trunk/Tokenize/
   trunk/Tokenize/HtmlTokenizer.cpp
   trunk/Tokenize/HtmlTokenizer.h
   trunk/Tokenize/Makefile
   trunk/Tokenize/PdfTokenizer.cpp
   trunk/Tokenize/PdfTokenizer.h
   trunk/Tokenize/Tokenizer.cpp
   trunk/Tokenize/Tokenizer.h
   trunk/Tokenize/TokenizerFactory.cpp
   trunk/Tokenize/TokenizerFactory.h
   trunk/Tokenize/UnknownTypeTokenizer.cpp
   trunk/Tokenize/UnknownTypeTokenizer.h
   trunk/Tokenize/WordTokenizer.cpp
   trunk/Tokenize/WordTokenizer.h
   trunk/Tokenize/tokenizertest.cpp
   trunk/UI/
   trunk/UI/GTK2/
   trunk/UI/GTK2/config.h
   trunk/UI/GTK2/metase-gtk2.glade
   trunk/UI/GTK2/metase-gtk2.gladep
   trunk/UI/GTK2/pinot.png
   trunk/UI/GTK2/pinot.xcf
   trunk/UI/GTK2/src/
   trunk/UI/GTK2/src/EnginesTree.cpp
   trunk/UI/GTK2/src/EnginesTree.h
   trunk/UI/GTK2/src/HtmlView.cpp
   trunk/UI/GTK2/src/HtmlView.h
   trunk/UI/GTK2/src/IndexTree.cpp
   trunk/UI/GTK2/src/IndexTree.h
   trunk/UI/GTK2/src/Makefile
   trunk/UI/GTK2/src/ModelColumns.cpp
   trunk/UI/GTK2/src/ModelColumns.h
   trunk/UI/GTK2/src/MonitorHandler.cpp
   trunk/UI/GTK2/src/MonitorHandler.h
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/PinotSettings.h
   trunk/UI/GTK2/src/PinotUtils.cpp
   trunk/UI/GTK2/src/PinotUtils.h
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/ResultsTree.h
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
   trunk/UI/GTK2/src/aboutDialog.cc
   trunk/UI/GTK2/src/aboutDialog.hh
   trunk/UI/GTK2/src/aboutDialog_glade.cc
   trunk/UI/GTK2/src/aboutDialog_glade.hh
   trunk/UI/GTK2/src/importDialog.cc
   trunk/UI/GTK2/src/importDialog.hh
   trunk/UI/GTK2/src/importDialog_glade.cc
   trunk/UI/GTK2/src/importDialog_glade.hh
   trunk/UI/GTK2/src/indexDialog.cc
   trunk/UI/GTK2/src/indexDialog.hh
   trunk/UI/GTK2/src/indexDialog_glade.cc
   trunk/UI/GTK2/src/indexDialog_glade.hh
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/mainWindow.hh
   trunk/UI/GTK2/src/mainWindow_glade.cc
   trunk/UI/GTK2/src/mainWindow_glade.hh
   trunk/UI/GTK2/src/pinot.cpp
   trunk/UI/GTK2/src/prefsDialog.cc
   trunk/UI/GTK2/src/prefsDialog.hh
   trunk/UI/GTK2/src/prefsDialog_glade.cc
   trunk/UI/GTK2/src/prefsDialog_glade.hh
   trunk/UI/GTK2/src/propertiesDialog.cc
   trunk/UI/GTK2/src/propertiesDialog.hh
   trunk/UI/GTK2/src/propertiesDialog_glade.cc
   trunk/UI/GTK2/src/propertiesDialog_glade.hh
   trunk/UI/GTK2/src/queryDialog.cc
   trunk/UI/GTK2/src/queryDialog.hh
   trunk/UI/GTK2/src/queryDialog_glade.cc
   trunk/UI/GTK2/src/queryDialog_glade.hh
   trunk/UI/GTK2/xapian-powered.png
   trunk/UI/RenderHTML/
   trunk/UI/RenderHTML/Makefile
   trunk/UI/RenderHTML/MozillaRenderer.cpp
   trunk/UI/RenderHTML/MozillaRenderer.h
   trunk/Utils/
   trunk/Utils/Document.cpp
   trunk/Utils/Document.h
   trunk/Utils/DocumentInfo.cpp
   trunk/Utils/DocumentInfo.h
   trunk/Utils/HtmlDocument.cpp
   trunk/Utils/HtmlDocument.h
   trunk/Utils/IndexedDocument.cpp
   trunk/Utils/IndexedDocument.h
   trunk/Utils/Languages.cpp
   trunk/Utils/Languages.h
   trunk/Utils/MIMEScanner.cpp
   trunk/Utils/MIMEScanner.h
   trunk/Utils/Makefile
   trunk/Utils/MboxParser.cpp
   trunk/Utils/MboxParser.h
   trunk/Utils/NLS.h
   trunk/Utils/PluginParser.cpp
   trunk/Utils/PluginParser.h
   trunk/Utils/Result.cpp
   trunk/Utils/Result.h
   trunk/Utils/StringManip.cpp
   trunk/Utils/StringManip.h
   trunk/Utils/TimeConverter.cpp
   trunk/Utils/TimeConverter.h
   trunk/Utils/Timer.cpp
   trunk/Utils/Timer.h
   trunk/Utils/Url.cpp
   trunk/Utils/Url.h
   trunk/Utils/XapianDatabase.cpp
   trunk/Utils/XapianDatabase.h
   trunk/Utils/XapianDatabaseFactory.cpp
   trunk/Utils/XapianDatabaseFactory.h
   trunk/Utils/plugintest.cpp
   trunk/index.html
   trunk/libxmlpp026.patch
   trunk/pinot.spec
   trunk/po/
   trunk/po/POTFILES
   trunk/po/en_GB.po
   trunk/po/fr_FR.po
   trunk/textcat_conf.txt
   trunk/variables.mk
Log:
v0.30 source

Added: trunk/COPYING
===================================================================
--- trunk/COPYING	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/COPYING	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The &quot;Program&quot;, below,
+refers to any such program or work, and a &quot;work based on the Program&quot;
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term &quot;modification&quot;.)  Each licensee is addressed as &quot;you&quot;.
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and &quot;any
+later version&quot;, you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the &quot;copyright&quot; line and a pointer to where the full notice is found.
+
+    &lt;one line to give the program's name and a brief idea of what it does.&gt;
+    Copyright (C) &lt;year&gt;  &lt;name of author&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a &quot;copyright disclaimer&quot; for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  &lt;signature of Ty Coon&gt;, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/ChangeLog	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,2 @@
+2005/12/08 version_0_3_0
+ - first public release

Added: trunk/Collect/DownloaderFactory.cpp
===================================================================
--- trunk/Collect/DownloaderFactory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/DownloaderFactory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,47 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &quot;XapianCollector.h&quot;
+#include &quot;NeonDownloader.h&quot;
+#include &quot;FileCollector.h&quot;
+#include &quot;MboxCollector.h&quot;
+#include &quot;DownloaderFactory.h&quot;
+
+/// Returns a Downloader of the specified type; NULL if unavailable.
+DownloaderInterface *DownloaderFactory::getDownloader(string protocol, string type)
+{
+	DownloaderInterface *myDownloader = NULL;
+
+	// Choice by protocol
+	if (protocol == &quot;http&quot;)
+	{
+		myDownloader = new NeonDownloader();
+	}
+	else if (protocol == &quot;xapian&quot;)
+	{
+		myDownloader = new XapianCollector();
+	}
+	else if (protocol == &quot;file&quot;)
+	{
+		myDownloader = new FileCollector();
+	}
+	else if (protocol == &quot;mailbox&quot;)
+	{
+		myDownloader = new MboxCollector();
+	}
+
+	return myDownloader;
+}


Property changes on: trunk/Collect/DownloaderFactory.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/DownloaderFactory.h
===================================================================
--- trunk/Collect/DownloaderFactory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/DownloaderFactory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,44 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DOWNLOADER_FACTORY_H
+#define _DOWNLOADER_FACTORY_H
+
+#include &lt;string&gt;
+
+#include &quot;DownloaderInterface.h&quot;
+
+using std::string;
+
+// Downloader factory class.
+class DownloaderFactory
+{
+	public:
+		virtual ~DownloaderFactory() {};
+
+		/// Returns a Downloader of the specified type; NULL if unavailable.
+		static DownloaderInterface *getDownloader(string protocol, string type);
+
+	protected:
+		DownloaderFactory() {};
+
+	private:
+		DownloaderFactory(const DownloaderFactory &amp;other);
+		DownloaderFactory &amp;operator=(const DownloaderFactory &amp;other);
+
+};
+
+#endif // _DOWNLOADER_FACTORY_H


Property changes on: trunk/Collect/DownloaderFactory.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/DownloaderInterface.cpp
===================================================================
--- trunk/Collect/DownloaderInterface.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/DownloaderInterface.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,47 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;DownloaderInterface.h&quot;
+
+using namespace std;
+
+DownloaderInterface::DownloaderInterface()
+{
+	m_timeout = 15000;
+}
+
+DownloaderInterface::~DownloaderInterface()
+{
+}
+
+/// Sets a (name, value) setting; true if success.
+bool DownloaderInterface::setSetting(const string &amp;name, const string &amp;value)
+{
+	return false;
+}
+
+/// Sets timeout.
+void DownloaderInterface::setTimeout(unsigned int milliseconds)
+{
+	m_timeout = milliseconds;
+}
+
+/// Stops the current action.
+bool DownloaderInterface::stop(void)
+{
+	return false;
+}


Property changes on: trunk/Collect/DownloaderInterface.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/DownloaderInterface.h
===================================================================
--- trunk/Collect/DownloaderInterface.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/DownloaderInterface.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DOWNLOADER_INTERFACE_H
+#define _DOWNLOADER_INTERFACE_H
+
+#include &lt;string&gt;
+
+#include &quot;Document.h&quot;
+
+/// Interface implemented by downloaders.
+class DownloaderInterface
+{
+	public:
+		virtual ~DownloaderInterface();
+
+		/// Sets a (name, value) setting; true if success.
+		virtual bool setSetting(const std::string &amp;name, const std::string &amp;value);
+
+		/// Sets timeout.
+		virtual void setTimeout(unsigned int milliseconds);
+
+		/// Retrieves the specified document; NULL if error. Caller deletes.
+		virtual Document *retrieveUrl(const DocumentInfo &amp;docInfo) = 0;
+
+		/// Stops the current action.
+		virtual bool stop(void);
+
+	protected:
+		unsigned int m_timeout;
+
+		DownloaderInterface();
+
+};
+
+#endif // _DOWNLOADER_INTERFACE_H


Property changes on: trunk/Collect/DownloaderInterface.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/FileCollector.cpp
===================================================================
--- trunk/Collect/FileCollector.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/FileCollector.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,74 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+#include &lt;algorithm&gt;
+
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;MIMEScanner.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;FileCollector.h&quot;
+
+using namespace std;
+
+FileCollector::FileCollector() :
+	DownloaderInterface()
+{
+}
+
+FileCollector::~FileCollector()
+{
+}
+
+//
+// Implementation of DownloaderInterface
+//
+
+/// Retrieves the specified document; NULL if error.
+Document *FileCollector::retrieveUrl(const DocumentInfo &amp;docInfo)
+{
+	Url thisUrl(docInfo.getLocation());
+	string protocol = thisUrl.getProtocol();
+
+	if (protocol != &quot;file&quot;)
+	{
+		// We can't handle that type of protocol...
+		return NULL;
+	}
+
+	string directoryName = thisUrl.getLocation();
+	string fileName = thisUrl.getFile();
+	string fileLocation = directoryName;
+	fileLocation += &quot;/&quot;;
+	fileLocation += fileName;
+
+	// Determine the file type
+	string fileType = MIMEScanner::scanFile(fileLocation);
+
+	// Use the URL as title
+	Document *fileDocument = new Document(docInfo.getTitle(),
+		docInfo.getLocation(), docInfo.getType(), docInfo.getLanguage());
+	if (fileDocument-&gt;setDataFromFile(fileLocation) == false)
+	{
+		delete fileDocument;
+		return NULL;
+	}
+
+	unsigned int fileLength = 0;
+	const char *fileContent = fileDocument-&gt;getData(fileLength);
+
+	return fileDocument;
+}

Added: trunk/Collect/FileCollector.h
===================================================================
--- trunk/Collect/FileCollector.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/FileCollector.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,39 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _FILE_COLLECTOR_H
+#define _FILE_COLLECTOR_H
+
+#include &lt;string&gt;
+
+#include &quot;DownloaderInterface.h&quot;
+
+class FileCollector : public DownloaderInterface
+{
+	public:
+		FileCollector();
+		virtual ~FileCollector();
+
+		/// Retrieves the specified document; NULL if error. Caller deletes.
+		virtual Document *retrieveUrl(const DocumentInfo &amp;docInfo);
+
+	private:
+		FileCollector(const FileCollector &amp;other);
+		FileCollector &amp;operator=(const FileCollector &amp;other);
+
+};
+
+#endif // _FILE_COLLECTOR_H

Added: trunk/Collect/Makefile
===================================================================
--- trunk/Collect/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,25 @@
+
+ROOT_DIR = ..
+include ${ROOT_DIR}/variables.mk
+
+DL_SRCS = DownloaderInterface.cpp NeonDownloader.cpp XapianCollector.cpp \
+        FileCollector.cpp MboxCollector.cpp DownloaderFactory.cpp
+DL_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${DL_SRCS})
+DL_TEST = ${BIN_DIR}/dloadtest
+
+targets : dirs ${DL_LIB} ${DL_TEST}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${DL_LIB} ${DL_TEST}
+
+# Downloader tester
+
+${DL_TEST} : ${OBJ_DIR}/dloadtest.o ${DL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB}
+	@echo Building ${DL_TEST}
+	${LINK} -o $@ ${OBJ_DIR}/dloadtest.o ${DL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS}
+
+# Library
+
+${DL_LIB} : ${DL_OBJS}
+	@echo Building ${DL_LIB}
+	${AR} cr ${DL_LIB} ${DL_OBJS}


Property changes on: trunk/Collect/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/MboxCollector.cpp
===================================================================
--- trunk/Collect/MboxCollector.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/MboxCollector.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,80 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+#include &lt;algorithm&gt;
+
+#include &quot;MboxParser.h&quot;
+#include &quot;StringManip.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;MboxCollector.h&quot;
+
+using namespace std;
+
+MboxCollector::MboxCollector() :
+	DownloaderInterface()
+{
+}
+
+MboxCollector::~MboxCollector()
+{
+}
+
+//
+// Implementation of DownloaderInterface
+//
+
+/// Retrieves the specified document; NULL if error.
+Document *MboxCollector::retrieveUrl(const DocumentInfo &amp;docInfo)
+{
+	Url thisUrl(docInfo.getLocation());
+	string protocol = thisUrl.getProtocol();
+
+	if (protocol != &quot;mailbox&quot;)
+	{
+		// We can't handle that type of protocol...
+		return NULL;
+	}
+
+	// Extract the offset
+	string offset = StringManip::extractField(thisUrl.getParameters(), &quot;o=&quot;, &quot;&amp;p=&quot;);
+	if (offset.empty() == true)
+	{
+		return NULL;
+	}
+	off_t messageOffset = (off_t)atol(offset.c_str());
+
+	string directoryName = thisUrl.getLocation();
+	string fileName = thisUrl.getFile();
+	string fileLocation = directoryName;
+	fileLocation += &quot;/&quot;;
+	fileLocation += fileName;
+
+	// Get a parser
+	MboxParser boxParser(fileLocation, messageOffset);
+	// The first document should be the message we are interested in
+	// FIXME: don't ignore the part number (p=...)
+	const Document *pMessage = boxParser.getDocument();
+	if (pMessage == NULL)
+	{
+		return NULL;
+	}
+
+	// Copy the message
+	Document *fileDocument = new Document(*pMessage);
+
+	return fileDocument;
+}

Added: trunk/Collect/MboxCollector.h
===================================================================
--- trunk/Collect/MboxCollector.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/MboxCollector.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,39 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MBOX_COLLECTOR_H
+#define _MBOX_COLLECTOR_H
+
+#include &lt;string&gt;
+
+#include &quot;DownloaderInterface.h&quot;
+
+class MboxCollector : public DownloaderInterface
+{
+	public:
+		MboxCollector();
+		virtual ~MboxCollector();
+
+		/// Retrieves the specified document; NULL if error. Caller deletes.
+		virtual Document *retrieveUrl(const DocumentInfo &amp;docInfo);
+
+	private:
+		MboxCollector(const MboxCollector &amp;other);
+		MboxCollector &amp;operator=(const MboxCollector &amp;other);
+
+};
+
+#endif // _MBOX_COLLECTOR_H

Added: trunk/Collect/NeonDownloader.cpp
===================================================================
--- trunk/Collect/NeonDownloader.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/NeonDownloader.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,377 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;cstdio&gt;
+#include &lt;strings.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;pthread.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;HtmlDocument.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;NeonDownloader.h&quot;
+
+using namespace std;
+
+static string g_locationHeaderValue;
+static string g_contentTypeHeaderValue;
+static void headerHandler(void *userdata, const char *value)
+{
+	long headerNum = (long)userdata;
+	if (headerNum == 1)
+	{
+		// Location
+		if (value == NULL)
+		{
+			g_locationHeaderValue.clear();
+		}
+		else
+		{
+			g_locationHeaderValue = value;
+		}
+	}
+	else if (headerNum == 2)
+	{
+		// Content-Type
+		if (value == NULL)
+		{
+			g_contentTypeHeaderValue.clear();
+		}
+		else
+		{
+			g_contentTypeHeaderValue = value;
+		}
+	}
+}
+
+bool NeonDownloader::m_initialized = false;
+
+NeonDownloader::NeonDownloader() :
+	m_pSession(NULL), m_pRequest(NULL), DownloaderInterface()
+{
+	// Pretend to be Mozilla
+	m_userAgent = &quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.7.3) Gecko/20041020&quot;;
+	if (m_initialized == false)
+	{
+		ne_sock_init();
+		m_initialized = true;
+	}
+}
+
+NeonDownloader::~NeonDownloader()
+{
+	// Cleanup
+	if (m_pRequest != NULL)
+	{
+		ne_request_destroy(m_pRequest);
+	}
+	if (m_pSession != NULL)
+	{
+		ne_session_destroy(m_pSession);
+	}
+}
+
+string NeonDownloader::handleRedirection(const char *pBody, unsigned int length)
+{
+	if ((pBody == NULL) ||
+		(length == 0))
+	{
+		return &quot;&quot;;
+	}
+
+	Document doc;
+	doc.setData(pBody, length);
+	HtmlTokenizer tokens(&amp;doc);
+
+	// Extract the link from the 3xx message
+	set&lt;Link&gt; linksSet = tokens.getLinks();
+	// There should be one and only one
+	if (linksSet.size() != 1)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;NeonDownloader::handleRedirection: &quot; &lt;&lt; linksSet.size() &lt;&lt; &quot; links found in &quot; &lt;&lt; length &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;
+		cout &lt;&lt; &quot;NeonDownloader::handleRedirection: redirection message was &quot; &lt;&lt; pBody &lt;&lt; endl;
+#endif
+		return &quot;&quot;;
+	}
+	set&lt;Link&gt;::const_iterator iter = linksSet.begin();
+	if (iter != linksSet.end())
+	{
+		// Update the URL
+		return iter-&gt;m_url;
+	}
+
+	return &quot;&quot;;
+}
+
+//
+// Implementation of DownloaderInterface
+//
+
+/// Sets a (name, value) setting; true if success.
+bool NeonDownloader::setSetting(const string &amp;name, const string &amp;value)
+{
+	bool goodSetting = true;
+
+	if (name == &quot;User-Agent&quot;)
+	{
+		m_userAgent = value;
+	}
+	else
+	{
+		goodSetting = false;
+	}
+
+	return goodSetting;
+}
+
+/// Retrieves the specified document; NULL if error.
+Document *NeonDownloader::retrieveUrl(const DocumentInfo &amp;docInfo)
+{
+	Document *urlDocument = NULL;
+	string url = Url::escapeUrl(docInfo.getLocation());
+	char *content = NULL;
+	size_t contentLen = 0;
+	unsigned int redirectionsCount = 0;
+
+	if (url.empty() == true)
+	{
+#ifdef DEBUG
+		cerr &lt;&lt; &quot;NeonDownloader::retrieveUrl: no URL specified !&quot; &lt;&lt; endl;
+#endif
+		return NULL;
+	}
+	Url urlObj(url);
+	string protocol = urlObj.getProtocol();
+	string hostName = urlObj.getHost();
+	string location = urlObj.getLocation();
+	string file = urlObj.getFile();
+	string parameters = urlObj.getParameters();
+
+	// Create a session
+	m_pSession = ne_session_create(protocol.c_str(), hostName.c_str(), 80); // urlObj.getPort());
+	if (m_pSession == NULL)
+	{
+#ifdef DEBUG
+		cerr &lt;&lt; &quot;NeonDownloader::retrieveUrl: couldn't create session !&quot; &lt;&lt; endl;
+#endif
+		return NULL;
+	}
+	// Set the user agent
+	ne_set_useragent(m_pSession, m_userAgent.c_str());
+	// ...and the timeout
+	ne_set_read_timeout(m_pSession, (int)m_timeout);
+
+	string fullLocation = &quot;/&quot;;
+	if (location.empty() == false)
+	{
+		fullLocation += location;
+	}
+	if (file.empty() == false)
+	{
+		if (location.empty() == false)
+		{
+			fullLocation += &quot;/&quot;;
+		}
+		fullLocation += file;
+	}
+	if (parameters.empty() == false)
+	{
+		fullLocation += &quot;?&quot;;
+		fullLocation += parameters;
+	}
+
+	// Create a request for this URL
+	m_pRequest = ne_request_create(m_pSession, &quot;GET&quot;, fullLocation.c_str());
+	if (m_pRequest == NULL)
+	{
+#ifdef DEBUG
+		cerr &lt;&lt; &quot;NeonDownloader::retrieveUrl: couldn't create request !&quot; &lt;&lt; endl;
+#endif
+		ne_session_destroy(m_pSession);
+		m_pSession = NULL;
+		return NULL;
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;NeonDownloader::retrieveUrl: request for &quot; &lt;&lt; fullLocation &lt;&lt; &quot; on &quot; &lt;&lt; hostName &lt;&lt; endl;
+#endif
+
+	int requestStatus = NE_RETRY;
+	while (requestStatus == NE_RETRY)
+	{
+		// FIXME: this is apparently the only way to get the value of an HTTP header
+		g_locationHeaderValue.clear();
+		ne_add_response_header_handler(m_pRequest, &quot;Location&quot;, headerHandler, (void*)1);
+		ne_add_response_header_handler(m_pRequest, &quot;Content-Type&quot;, headerHandler, (void*)2);
+
+		// Begin the request
+		requestStatus = ne_begin_request(m_pRequest);
+#ifdef DEBUG
+		cout &lt;&lt; &quot;NeonDownloader::retrieveUrl: request begun with status &quot; &lt;&lt; requestStatus &lt;&lt; endl;
+#endif
+		if (requestStatus == NE_OK)
+		{
+			ssize_t bytesRead = 0;
+			char buffer[1024];
+			int statusCode = 0;
+
+			// Get the status
+			const ne_status *pStatus = ne_get_status(m_pRequest);
+			if (pStatus != NULL)
+			{
+				statusCode = pStatus-&gt;code;
+#ifdef DEBUG
+				cout &lt;&lt; &quot;NeonDownloader::retrieveUrl: status is &quot; &lt;&lt; statusCode &lt;&lt; endl;
+#endif
+			}
+
+			// Read the content
+			while ((bytesRead = ne_read_response_block(m_pRequest, buffer, 1024)) &gt; 0)
+			{
+				content = (char*)realloc(content, contentLen + bytesRead);
+				memcpy((void*)(content + contentLen), (const void*)buffer, bytesRead);
+				contentLen += bytesRead;
+			}
+
+			// Redirection ?
+			if ((statusCode &gt;= 300) &amp;&amp;
+				(statusCode &lt; 400) &amp;&amp;
+				(redirectionsCount &lt; 10))
+			{
+				ne_end_request(m_pRequest);
+				ne_request_destroy(m_pRequest);
+				m_pRequest = NULL;
+
+				string documentUrl = handleRedirection(content, contentLen);
+				if (documentUrl.empty() == true)
+				{
+					// Did we find a Location header ?
+					if (g_locationHeaderValue.empty() == true)
+					{
+						// Fail
+						free(content);
+						content = NULL;
+						contentLen = 0;
+						break;
+					}
+					documentUrl = g_locationHeaderValue;
+				}
+
+#ifdef DEBUG
+				cout &lt;&lt; &quot;NeonDownloader::retrieveUrl: redirected to &quot; &lt;&lt; documentUrl &lt;&lt; endl;
+#endif
+				urlObj = Url(documentUrl);
+				location = urlObj.getLocation();
+				file = urlObj.getFile();
+
+				// Is this on the same host ?
+				if (hostName != urlObj.getHost())
+				{
+					// No, it isn't
+					hostName = urlObj.getHost();
+
+					// Create a new session
+					ne_session_destroy(m_pSession);
+					m_pSession = ne_session_create(protocol.c_str(), hostName.c_str(), 80); // urlObj.getPort());
+					if (m_pSession == NULL)
+					{
+#ifdef DEBUG
+						cerr &lt;&lt; &quot;NeonDownloader::retrieveUrl: couldn't create session !&quot; &lt;&lt; endl;
+#endif
+						return NULL;
+					}
+					ne_set_useragent(m_pSession, m_userAgent.c_str());
+					ne_set_read_timeout(m_pSession, (int)m_timeout);
+				}
+
+				// Try again
+				fullLocation = &quot;/&quot;;
+				if (location.empty() == false)
+				{
+					fullLocation += location;
+					fullLocation += &quot;/&quot;;
+				}
+				if (file.empty() == false)
+				{
+					fullLocation += file;
+				}
+#ifdef DEBUG
+				cout &lt;&lt; &quot;NeonDownloader::retrieveUrl: redirected to &quot; &lt;&lt; fullLocation &lt;&lt; &quot; on &quot; &lt;&lt; hostName &lt;&lt; endl;
+#endif
+
+				// Create a new request for this URL
+				m_pRequest = ne_request_create(m_pSession, &quot;GET&quot;, fullLocation.c_str());
+				if (m_pRequest == NULL)
+				{
+#ifdef DEBUG
+					cerr &lt;&lt; &quot;NeonDownloader::retrieveUrl: couldn't create request !&quot; &lt;&lt; endl;
+#endif
+					ne_session_destroy(m_pSession);
+					m_pSession = NULL;
+					return NULL;
+				}
+				redirectionsCount++;
+				requestStatus = NE_RETRY;
+
+				// Discard whatever content we have already got
+				free(content);
+				content = NULL;
+				contentLen = 0;
+				continue;
+			}
+		}
+
+		// End the request
+		requestStatus = ne_end_request(m_pRequest);
+	}
+
+	if ((content != NULL) &amp;&amp;
+		(contentLen &gt; 0))
+	{
+		// Is it an html type ?
+		if (g_contentTypeHeaderValue.find(&quot;htm&quot;) != string::npos)
+		{
+			urlDocument = new HtmlDocument(docInfo.getTitle(), url,
+				g_contentTypeHeaderValue, docInfo.getLanguage());
+		}
+		else
+		{
+			urlDocument = new Document(docInfo.getTitle(), url,
+				g_contentTypeHeaderValue, docInfo.getLanguage());
+		}
+		// ...and copy the content into it
+		urlDocument-&gt;setData(content, contentLen);
+#ifdef DEBUG
+		cout &lt;&lt; &quot;NeonDownloader::retrieveUrl: document size is &quot; &lt;&lt; contentLen &lt;&lt; endl;
+#endif
+		free(content);
+	}
+
+	return urlDocument;
+}
+
+/// Stops the current action.
+bool NeonDownloader::stop(void)
+{
+	if (m_pRequest != NULL)
+	{
+		// End the current request
+		ne_end_request(m_pRequest);
+	}
+
+	return true;
+}


Property changes on: trunk/Collect/NeonDownloader.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/NeonDownloader.h
===================================================================
--- trunk/Collect/NeonDownloader.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/NeonDownloader.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,57 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _NEON_DOWNLOADER_H
+#define _NEON_DOWNLOADER_H
+
+#include &lt;string&gt;
+
+#include &lt;neon/ne_socket.h&gt;
+#include &lt;neon/ne_session.h&gt;
+#include &lt;neon/ne_request.h&gt;
+
+#include &quot;DownloaderInterface.h&quot;
+
+class NeonDownloader : public DownloaderInterface
+{
+	public:
+		NeonDownloader();
+		virtual ~NeonDownloader();
+
+		/// Sets a (name, value) setting; true if success.
+		virtual bool setSetting(const std::string &amp;name, const std::string &amp;value);
+
+		/// Retrieves the specified document; NULL if error. Caller deletes.
+		virtual Document *retrieveUrl(const DocumentInfo &amp;docInfo);
+
+		/// Stops the current action.
+		virtual bool stop(void);
+
+	protected:
+		static bool m_initialized;
+		std::string m_userAgent;
+		ne_session *m_pSession;
+		ne_request *m_pRequest;
+
+		std::string handleRedirection(const char *pBody, unsigned int length);
+
+	private:
+		NeonDownloader(const NeonDownloader &amp;other);
+		NeonDownloader &amp;operator=(const NeonDownloader &amp;other);
+
+};
+
+#endif // _NEON_DOWNLOADER_H


Property changes on: trunk/Collect/NeonDownloader.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/XapianCollector.cpp
===================================================================
--- trunk/Collect/XapianCollector.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/XapianCollector.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,196 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;pthread.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;IndexedDocument.h&quot;
+#include &quot;StringManip.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;XapianCollector.h&quot;
+
+using namespace std;
+
+XapianCollector::XapianCollector() :
+	DownloaderInterface()
+{
+	m_databaseName = &quot;&quot;;
+	// Always get documents data from the index
+	m_getDocData = true;
+	m_pDatabase = NULL;
+}
+
+XapianCollector::XapianCollector(const string &amp;database, bool getDocData) :
+	DownloaderInterface()
+{
+	m_databaseName = database;
+	m_getDocData = getDocData;
+	m_pDatabase = NULL;
+
+	// Try opening this database
+	if (openDatabase() == false)
+	{
+		m_databaseName.clear();
+		m_pDatabase = NULL;
+	}
+	m_getDocData = getDocData;
+}
+
+XapianCollector::~XapianCollector()
+{
+	if (m_pDatabase != NULL)
+	{
+		delete m_pDatabase;
+	}
+}
+
+bool XapianCollector::openDatabase(void)
+{
+	struct stat dbStat;
+
+	if (m_databaseName.empty() == true)
+	{
+		return false;
+	}
+
+	// The specified path must be either a directory or a symlink (to a directory)
+	if (stat(m_databaseName.c_str(), &amp;dbStat) == -1)
+	{
+		// Database directory doesn't exist
+		cerr &lt;&lt; &quot;XapianCollector::openDatabase: database doesn't exist: &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
+		return false;
+	}
+	else if (!S_ISDIR(dbStat.st_mode))
+	{
+		cerr &lt;&lt; &quot;XapianCollector::openDatabase: &quot; &lt;&lt; m_databaseName &lt;&lt; &quot; is not a directory&quot; &lt;&lt; endl;
+		return false;
+	}
+
+	// Try opening it now
+	try
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;XapianCollector::openDatabase: opening database &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
+#endif
+		m_pDatabase = new Xapian::Database(m_databaseName);
+
+		return true;
+	}
+	catch (const Xapian::Error &amp;error)
+	{
+		cerr &lt;&lt; &quot;XapianCollector::openDatabase: couldn't open database: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
+	}
+
+	return false;
+}
+
+//
+// Implementation of DownloaderInterface
+//
+
+/// Retrieves the specified document; NULL if error.
+Document *XapianCollector::retrieveUrl(const DocumentInfo &amp;docInfo)
+{
+	string url = docInfo.getLocation();
+	Url thisUrl(url);
+
+	if (thisUrl.getProtocol() != &quot;xapian&quot;)
+	{
+		// We can't handle that type of protocol...
+		return NULL;
+	}
+
+	// Ignore host portion of the URL as we can only deal with local indexes
+	// Get the database location and document ID out of the location field
+	string database = thisUrl.getLocation();
+	string documentId = thisUrl.getFile();
+	Xapian::docid docId;
+	sscanf(documentId.c_str(), &quot;%u&quot;, &amp;docId);
+#ifdef DEBUG
+	cout &lt;&lt; &quot;XapianCollector::retrieveUrl: database is &quot; &lt;&lt; database &lt;&lt; &quot;, document ID is &quot; &lt;&lt; docId &lt;&lt; endl;
+#endif
+
+	// The constructor may already have opened an index, check this URL corresponds
+	if (database != m_databaseName)
+	{
+		// The requested URL is in some other index
+		if (m_pDatabase != NULL)
+		{
+			delete m_pDatabase;
+			m_pDatabase = NULL;
+		}
+		// Try opening that index then
+		m_databaseName = database;
+		if (openDatabase() == false)
+		{
+			m_pDatabase = NULL;
+			m_databaseName.clear();
+		}
+	}
+
+	if (m_pDatabase == NULL)
+	{
+		return NULL;
+	}
+
+	IndexedDocument *indexDoc = NULL;
+
+	try
+	{
+		// Now retrieve the desired document
+		Xapian::Document doc = m_pDatabase-&gt;get_document(docId);
+		// ... and its data
+		string record = doc.get_data();
+
+		// Extract the title, location, summary, type and timestamp
+		string title = StringManip::extractField(record, &quot;caption=&quot;, &quot;\n&quot;);
+#ifdef DEBUG
+		cout &lt;&lt; &quot;XapianCollector::retrieveUrl: found omindex title &quot; &lt;&lt; title &lt;&lt; endl;
+#endif
+		string location = StringManip::extractField(record, &quot;url=&quot;, &quot;\n&quot;);
+		string type = StringManip::extractField(record, &quot;type=&quot;, &quot;\n&quot;);
+		string timestamp = StringManip::extractField(record, &quot;timestamp=&quot;, &quot;\n&quot;);
+		string language = StringManip::extractField(record, &quot;language=&quot;, &quot;\n&quot;);
+#ifdef DEBUG
+	cout &lt;&lt; &quot;XapianCollector::retrieveUrl: &quot; &lt;&lt; docId &lt;&lt; &quot; was indexed from &quot; &lt;&lt; location &lt;&lt; &quot; at &quot; &lt;&lt; timestamp &lt;&lt; endl;
+#endif
+
+		indexDoc = new IndexedDocument(title, url, location, type, language);
+		indexDoc-&gt;setTimestamp(timestamp);
+
+		// Extract document's data ?
+		if (m_getDocData == true)
+		{
+			// The only data we have at hand is the summary
+			string summary = StringManip::extractField(record, &quot;sample=&quot;, &quot;\n&quot;);
+#ifdef DEBUG
+			cout &lt;&lt; &quot;XapianCollector::retrieveUrl: found omindex summary &quot; &lt;&lt; summary &lt;&lt; endl;
+#endif
+			indexDoc-&gt;setData(summary.c_str(), summary.length());
+		}
+	}
+	catch (const Xapian::Error &amp;error)
+	{
+		cerr &lt;&lt; &quot;Couldn't retrieve document: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
+	}
+
+	return indexDoc;
+}


Property changes on: trunk/Collect/XapianCollector.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/XapianCollector.h
===================================================================
--- trunk/Collect/XapianCollector.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/XapianCollector.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XAPIAN_COLLECTOR_H
+#define _XAPIAN_COLLECTOR_H
+
+#include &lt;string&gt;
+
+#include &lt;xapian.h&gt;
+
+#include &quot;DownloaderInterface.h&quot;
+
+class XapianCollector : public DownloaderInterface
+{
+	public:
+		XapianCollector();
+		XapianCollector(const std::string &amp;database, bool getDocData);
+		virtual ~XapianCollector();
+
+		/// Retrieves the specified document; NULL if error. Caller deletes.
+		virtual Document *retrieveUrl(const DocumentInfo &amp;docInfo);
+
+	protected:
+		std::string m_databaseName;
+		bool m_getDocData;
+		Xapian::Database *m_pDatabase;
+
+		bool openDatabase(void);
+
+	private:
+		XapianCollector(const XapianCollector &amp;other);
+		XapianCollector &amp;operator=(const XapianCollector &amp;other);
+
+};
+
+#endif // _XAPIAN_COLLECTOR_H


Property changes on: trunk/Collect/XapianCollector.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/dloadtest.cpp
===================================================================
--- trunk/Collect/dloadtest.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/dloadtest.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,115 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string&gt;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;DownloaderFactory.h&quot;
+
+using namespace std;
+
+int main(int argc, char **argv)
+{
+	if (argc &lt; 3)
+	{
+		cerr &lt;&lt; &quot;Usage: &lt;downloader name&gt; &lt;URL&gt; [STRIP]&quot; &lt;&lt; endl;
+		return EXIT_FAILURE;
+	}
+
+	string downloaderName = argv[1];
+	
+	Url thisUrl(argv[2]);
+	cout &lt;&lt; &quot;Protocol: &quot; &lt;&lt; thisUrl.getProtocol() &lt;&lt; endl;
+	cout &lt;&lt; &quot;User: &quot; &lt;&lt; thisUrl.getUser() &lt;&lt; endl;
+	cout &lt;&lt; &quot;Password: &quot; &lt;&lt; thisUrl.getPassword() &lt;&lt; endl;
+	cout &lt;&lt; &quot;Host: &quot; &lt;&lt; thisUrl.getHost() &lt;&lt; endl;
+	cout &lt;&lt; &quot;Location: &quot; &lt;&lt; thisUrl.getLocation() &lt;&lt; endl;
+	cout &lt;&lt; &quot;File: &quot; &lt;&lt; thisUrl.getFile() &lt;&lt; endl;
+	cout &lt;&lt; &quot;Parameters: &quot; &lt;&lt; thisUrl.getParameters() &lt;&lt; endl;
+
+	if (downloaderName == &quot;-&quot;)
+	{
+		// Don't go further
+		return EXIT_SUCCESS;
+	}
+
+	// Which Downloader ?
+	DownloaderInterface *myDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol(),
+		downloaderName);
+	if (myDownloader == NULL)
+	{
+		cerr &lt;&lt; &quot;Couldn't obtain downloader instance (&quot; &lt;&lt; thisUrl.getProtocol() &lt;&lt; &quot;,&quot; &lt;&lt; downloaderName &lt;&lt; &quot;)&quot; &lt;&lt; endl;
+		return EXIT_FAILURE;
+	}
+
+	unsigned int urlContentLen;
+	string contentType;
+	DocumentInfo docInfo(&quot;Test&quot;, argv[2], &quot;&quot;, &quot;&quot;);
+	Document *urlDoc = myDownloader-&gt;retrieveUrl(docInfo);
+	if (urlDoc == NULL)
+	{
+		cerr &lt;&lt; &quot;Download operation failed !&quot; &lt;&lt; endl;
+	}
+	else
+	{
+		cout &lt;&lt; &quot;Document type is &quot; &lt;&lt; urlDoc-&gt;getType() &lt;&lt; endl;
+
+		unsigned int urlContentLen;
+		const char *urlContent = urlDoc-&gt;getData(urlContentLen);
+
+		if ((urlContent != NULL) &amp;&amp;
+			(urlContentLen &gt; 0))
+		{
+			// Save the content to a file
+			string fileName = thisUrl.getFile();
+			if (fileName.empty() == true)
+			{
+				fileName = &quot;index.html&quot;;
+			}
+
+			cout &lt;&lt; &quot;Saving &quot; &lt;&lt; urlContentLen &lt;&lt; &quot; bytes to &quot; &lt;&lt; fileName &lt;&lt; endl;
+
+			ofstream outputFile(fileName.c_str());
+			//outputFile.open(fileName.c_str(), ofstream::out|ofstream::trunc);
+			// Strip tags ?
+			if ((argc &gt;= 3) &amp;&amp;
+				(strncasecmp(argv[2], &quot;STRIP&quot;, 5) == 0))
+			{
+				outputFile &lt;&lt; HtmlTokenizer::stripTags(urlContent);
+			}
+			else
+			{
+				outputFile.write(urlContent, urlContentLen);
+			}
+			outputFile.close();
+		}
+		else
+		{
+			cout &lt;&lt; &quot;Document is empty&quot; &lt;&lt; endl;
+		}
+
+		delete urlDoc;
+	}
+
+	delete myDownloader;
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/Collect/dloadtest.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Index/IndexInterface.h
===================================================================
--- trunk/Index/IndexInterface.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/IndexInterface.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,84 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#ifndef _INDEX_INTERFACE_H
+#define _INDEX_INTERFACE_H
+
+#include &lt;string&gt;
+#include &lt;set&gt;
+
+#include &quot;Tokenizer.h&quot;
+#include &quot;DocumentInfo.h&quot;
+
+/// Interface implemented by indexes.
+class IndexInterface
+{
+	public:
+		virtual ~IndexInterface() {};
+
+		/// Returns false if the index couldn't be opened.
+		bool isGood(void) const { return m_goodIndex; }
+
+		typedef enum { STORE_UNSTEM = 0, STORE_STEM, STORE_BOTH } StemmingMode;
+
+		/// Sets the stemming mode.
+		virtual void setStemmingMode(StemmingMode mode) { m_stemMode = mode; }
+
+		/// Gets the index location.
+		virtual std::string getLocation(void) const = 0;
+
+		/// Indexes the given data.
+		virtual bool indexDocument(Tokenizer &amp;tokens, unsigned int &amp;docId) = 0;
+
+		/// Updates the given document; true if success.
+		virtual bool updateDocument(unsigned int docId, Tokenizer &amp;tokens) = 0;
+
+		/// Returns the ID of the given document.
+		virtual unsigned int hasDocument(const DocumentInfo &amp;docInfo) const = 0;
+
+		/// Unindexes the given document; true if success.
+		virtual bool unindexDocument(unsigned int docId) = 0;
+
+		/// Flushes recent changes to the disk.
+		virtual bool flush(void) = 0;
+
+		/// Returns the number of documents.
+		virtual unsigned int getDocumentsCount(void) const = 0;
+
+		/// Returns a list of document IDs.
+		virtual unsigned int getDocumentIDs(std::set&lt;unsigned int&gt; &amp;docIDList,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0,
+			bool sortByDate = false) const = 0;
+
+		/// Returns a document's properties.
+		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &amp;docInfo) const = 0;
+
+		/// Updates a document's properties.
+		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &amp;docInfo) = 0;
+
+	protected:
+		StemmingMode m_stemMode;
+		bool m_goodIndex;
+
+		IndexInterface() { m_stemMode = STORE_UNSTEM; m_goodIndex = false; };
+
+	private:
+		IndexInterface(const IndexInterface &amp;other);
+		IndexInterface &amp;operator=(const IndexInterface &amp;other);
+
+};
+
+#endif // _INDEX_INTERFACE_H


Property changes on: trunk/Index/IndexInterface.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Index/LanguageDetector.cpp
===================================================================
--- trunk/Index/LanguageDetector.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/LanguageDetector.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,145 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/time.h&gt;
+#include &lt;iostream&gt;
+
+extern &quot;C&quot;
+{
+#include &lt;textcat.h&gt;
+}
+
+#include &quot;StringManip.h&quot;
+#include &quot;Timer.h&quot;
+#include &quot;LanguageDetector.h&quot;
+
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+using std::vector;
+
+LanguageDetector::LanguageDetector()
+{
+}
+
+LanguageDetector::~LanguageDetector()
+{
+}
+
+/**
+  * Attempts to guess the language.
+  * Returns a list of candidates, or &quot;unknown&quot; if detection failed.
+  */
+void LanguageDetector::guessLanguage(const char *pData, unsigned int dataLength,
+			std::vector&lt;std::string&gt; &amp;candidates)
+{
+#ifdef HAVE_TEXTCAT_CAT
+	const char *catResults[10];
+#endif
+
+	candidates.clear();
+
+	void *td = textcat_Init(&quot;/usr/share/pinot/textcat_conf.txt&quot;);
+	if (td == NULL)
+	{
+		candidates.push_back(&quot;unknown&quot;);
+		return;
+	}
+
+	// Classify
+#ifdef DEBUG
+	Timer timer;
+	timer.start();
+#endif
+#ifdef HAVE_TEXTCAT_CAT
+	unsigned int resultNum = textcat_Cat(td, pData, dataLength, catResults, 10);
+	if (resultNum == 0 )
+	{
+		candidates.push_back(&quot;unknown&quot;);
+	}
+	else
+	{
+		for (unsigned int i=0; i&lt;resultNum; ++i)
+		{
+			string language = StringManip::toLowerCase(catResults[i]);
+
+			// Remove the charset information
+			string::size_type dashPos = language.find('-');
+			if (dashPos != string::npos)
+			{
+				language.resize(dashPos);
+			}
+#ifdef DEBUG
+			cout &lt;&lt; &quot;LanguageDetector::guessLanguage: found language &quot; &lt;&lt; language &lt;&lt; endl;
+#endif
+			candidates.push_back(language);
+		}
+	}
+#else
+	const char *languages = textcat_Classify(td, pData, dataLength);
+	if (languages == NULL)
+	{
+		candidates.push_back(&quot;unknown&quot;);
+	}
+	else
+	{
+		// The output will be either SHORT, or UNKNOWN or a list of languages in []
+		if ((strncasecmp(languages, &quot;SHORT&quot;, 5) == 0) ||
+			(strncasecmp(languages, &quot;UNKNOWN&quot;, 7) == 0))
+		{
+			candidates.push_back(&quot;unknown&quot;);
+		}
+		else
+		{
+			string languageList = languages;
+			string::size_type lastPos = 0, pos = languageList.find_first_of(&quot;[&quot;);
+
+			while (pos != string::npos)
+			{
+				++pos;
+				lastPos = languageList.find_first_of(&quot;]&quot;, pos);
+				if (lastPos == string::npos)
+				{
+					break;
+				}
+
+				string language = StringManip::toLowerCase(languageList.substr(pos, lastPos - pos));
+				// Remove the charset information
+				string::size_type dashPos = language.find('-');
+				if (dashPos != string::npos)
+				{
+					language.resize(dashPos);
+				}
+#ifdef DEBUG
+				cout &lt;&lt; &quot;LanguageDetector::guessLanguage: found language &quot; &lt;&lt; language &lt;&lt; endl;
+#endif
+				candidates.push_back(language);
+
+				// Next
+				pos = languageList.find_first_of(&quot;[&quot;, lastPos);
+			}
+		}
+	}
+#endif
+#ifdef DEBUG
+	cout &lt;&lt; &quot;LanguageDetector::guessLanguage: language guessing with &quot;
+		&lt;&lt; textcat_Version() &lt;&lt; &quot; took &quot; &lt;&lt; timer.stop() &lt;&lt; &quot; us&quot; &lt;&lt; endl;
+#endif
+
+	// Close the descriptor
+	textcat_Done(td);
+}

Added: trunk/Index/LanguageDetector.h
===================================================================
--- trunk/Index/LanguageDetector.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/LanguageDetector.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,42 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _LANGUAGE_DETECTOR_H
+#define _LANGUAGE_DETECTOR_H
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+class LanguageDetector
+{
+	public:
+		LanguageDetector();
+		virtual ~LanguageDetector();
+
+		/**
+		  * Attempts to guess the language.
+		  * Returns a list of candidates, or &quot;unknown&quot; if detection failed.
+		  */
+		void guessLanguage(const char *pData, unsigned int dataLength,
+			std::vector&lt;std::string&gt; &amp;candidates);
+
+	private:
+		LanguageDetector(const LanguageDetector &amp;other);
+		LanguageDetector &amp;operator=(const LanguageDetector &amp;other);
+
+};
+
+#endif // _LANGUAGE_DETECTOR_H

Added: trunk/Index/Makefile
===================================================================
--- trunk/Index/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,24 @@
+
+ROOT_DIR = ..
+include ${ROOT_DIR}/variables.mk
+
+IDX_SRCS = Summarizer.cpp LanguageDetector.cpp XapianIndex.cpp
+IDX_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${IDX_SRCS})
+IDX_TEST = ${BIN_DIR}/indextest
+
+targets : dirs ${IDX_LIB} ${IDX_TEST} ${DISCKCAT_APP}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${IDX_LIB} ${IDX_TEST} ${DISCKCAT_APP}
+
+# Index tester
+
+${IDX_TEST} : ${OBJ_DIR}/indextest.o ${IDX_LIB} ${SQL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB}
+	@echo Building ${IDX_TEST}
+	${LINK} -o $@ ${OBJ_DIR}/indextest.o ${IDX_LIB} ${SQL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS}
+
+# Library
+
+${IDX_LIB} : ${IDX_OBJS}
+	@echo Building ${IDX_LIB}
+	${AR} cr ${IDX_LIB} ${IDX_OBJS}


Property changes on: trunk/Index/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Index/Summarizer.cpp
===================================================================
--- trunk/Index/Summarizer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/Summarizer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,128 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/time.h&gt;
+#include &lt;map&gt;
+#include &lt;iostream&gt;
+#include &lt;utility&gt;
+
+#include &lt;ots/libots.h&gt;
+
+#include &quot;Languages.h&quot;
+#include &quot;StringManip.h&quot;
+#include &quot;Timer.h&quot;
+#include &quot;Summarizer.h&quot;
+
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+using std::map;
+using std::min;
+
+unsigned int Summarizer::m_maxTextSize = 500000;
+
+Summarizer::Summarizer(const std::string &amp;language, unsigned int wordsCount) :
+	m_wordsCount(wordsCount),
+	m_dictionaryCode(&quot;en&quot;)
+{
+	string lang = StringManip::toLowerCase(language);
+
+	// Look up the language code
+	for (unsigned int count = 0; count &lt; Languages::m_count; ++count)
+	{
+		if (lang == Languages::m_names[count])
+		{
+			m_dictionaryCode = Languages::m_codes[count];
+		}
+	}
+}
+
+Summarizer::~Summarizer()
+{
+}
+
+/// Attempts to summarize the document in wordsCount words.
+string Summarizer::summarize(const char *pText, unsigned int textLen)
+{
+	if ((pText == NULL) ||
+		(textLen == 0))
+	{
+		return NULL;
+	}
+
+	m_title.clear();
+
+	// OTS may take too much time with long documents
+	if (textLen &lt; m_maxTextSize)
+	{
+		unsigned char *pSummary = NULL;
+		size_t outputLen = 0;
+#ifdef DEBUG
+		Timer timer;
+		timer.start();
+#endif
+
+		// Create a new article
+		OtsArticle *pArticle = ots_new_article();
+		if ((pArticle != NULL) &amp;&amp;
+			(ots_load_xml_dictionary(pArticle, m_dictionaryCode.c_str())))
+		{
+			ots_parse_stream((const unsigned char*)pText, textLen, pArticle);
+
+			ots_grade_doc(pArticle);
+			ots_highlight_doc_words(pArticle, m_wordsCount);
+
+			// Summarize
+			pSummary = ots_get_doc_text(pArticle, &amp;outputLen);
+#ifdef DEBUG
+			cout &lt;&lt; &quot;Summarizer::summarize: summarized to &quot; &lt;&lt; outputLen &lt;&lt; &quot; bytes in &quot;
+				&lt;&lt; timer.stop() &lt;&lt; &quot; us &quot; &lt;&lt; endl;
+#endif
+
+			// Get the title before freeing the article
+			if (pArticle-&gt;title != NULL)
+			{
+				m_title = pArticle-&gt;title;
+			}
+			ots_free_article(pArticle);
+		}
+
+		if (pSummary != NULL)
+		{
+			string sum((const char *)pSummary, outputLen);
+
+			free(pSummary);
+
+			return sum;
+		}
+	}
+	else
+	{
+		unsigned int arbitraryLen = min(5 * m_wordsCount, m_maxTextSize / 1000);
+
+		// This is totally arbitray
+		return string(pText, arbitraryLen);
+	}
+
+	return &quot;&quot;;
+}
+
+/// Gets the document's title, as determined by summarize().
+string Summarizer::getTitle(void) const
+{
+	return m_title;
+}

Added: trunk/Index/Summarizer.h
===================================================================
--- trunk/Index/Summarizer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/Summarizer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,46 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _SUMMARIZER_H
+#define _SUMMARIZER_H
+
+#include &lt;string&gt;
+
+class Summarizer
+{
+	public:
+		Summarizer(const std::string &amp;language, unsigned int wordsCount);
+		virtual ~Summarizer();
+
+		/// Attempts to summarize the document in wordsCount words.
+		std::string summarize(const char *pText, unsigned int textLen);
+
+		/// Gets the document's title, as determined by summarize().
+		std::string getTitle(void) const;
+
+	protected:
+		static unsigned int m_maxTextSize;
+		unsigned int m_wordsCount;
+		std::string m_dictionaryCode;
+		std::string m_title;
+
+	private:
+		Summarizer(const Summarizer &amp;other);
+		Summarizer &amp;operator=(const Summarizer &amp;other);
+
+};
+
+#endif // _SUMMARIZER_H

Added: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/XapianIndex.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,621 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;time.h&gt;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+#include &lt;algorithm&gt;
+
+#include &quot;StringManip.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;Summarizer.h&quot;
+#include &quot;TimeConverter.h&quot;
+#include &quot;LanguageDetector.h&quot;
+#include &quot;XapianDatabaseFactory.h&quot;
+#include &quot;XapianIndex.h&quot;
+
+using std::string;
+using std::set;
+
+// This puts a limit to terms length.
+const unsigned int XapianIndex::m_maxTermLength = 64;
+const string XapianIndex::MAGIC_TERM = &quot;X-MetaSE-Doc&quot;;
+
+XapianIndex::XapianIndex(const string &amp;indexName) :
+	IndexInterface(),
+	m_databaseName(indexName),
+	m_pHistory(NULL)
+{
+
+	string historyFile = indexName;
+	historyFile += &quot;/history&quot;;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if ((pDatabase != NULL) &amp;&amp;
+		(pDatabase-&gt;isOpen() == true) &amp;&amp;
+		(IndexHistory::create(historyFile) == true))
+	{
+		m_pHistory = new IndexHistory(historyFile);
+		m_goodIndex = true;
+	}
+}
+
+XapianIndex::~XapianIndex()
+{
+	if (m_pHistory != NULL)
+	{
+		delete m_pHistory;
+	}
+}
+
+bool XapianIndex::addTermsToDocument(Tokenizer &amp;tokens, Xapian::Document &amp;doc,
+	Xapian::termcount &amp;termPos, const string &amp;prefix, StemmingMode mode) const
+{
+	Xapian::Stem *pStemmer = NULL;
+	string term;
+
+	// Do we know what language to use for stemming ?
+	if (m_stemLanguage.empty() == false)
+	{
+		pStemmer = new Xapian::Stem(m_stemLanguage);
+	}
+
+	// Get the terms
+	while (tokens.nextToken(term) == true)
+	{
+		if (term.empty() == true)
+		{
+			continue;
+		}
+
+		// Lower case the term
+		term = StringManip::toLowerCase(term);
+		// Stem the term ?
+		if ((mode == STORE_UNSTEM) ||
+			(pStemmer == NULL))
+		{
+			// Add the term to the document
+			doc.add_posting(prefix + term, termPos);
+		}
+		else if (mode == STORE_STEM)
+		{
+			string stemmedTerm = pStemmer-&gt;stem_word(term);
+
+			// Add the stemmed term to the document
+			doc.add_posting(prefix + stemmedTerm, termPos);
+		}
+		else if (mode == STORE_BOTH)
+		{
+			string stemmedTerm = pStemmer-&gt;stem_word(term);
+
+			// Add both
+			doc.add_posting(prefix + term, termPos);
+			doc.add_posting(prefix + stemmedTerm, termPos);
+		}
+
+		// Next
+		termPos++;
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;XapianIndex::addTermsToDocument: added &quot; &lt;&lt; termPos &lt;&lt; &quot; terms&quot; &lt;&lt; endl;
+#endif
+
+	if (pStemmer != NULL)
+	{
+		delete pStemmer;
+	}
+
+	return true;
+}
+
+bool XapianIndex::prepareDocument(const DocumentInfo &amp;info, Xapian::Document &amp;doc,
+	Xapian::termcount &amp;termPos, const std::string &amp;summary) const
+{
+	// Add a magic term :-)
+	doc.add_posting(MAGIC_TERM, termPos);
+	termPos++;
+
+	// Index the title with and without prefix T
+	string title = info.getTitle();
+	if (title.empty() == false)
+	{
+		Document titleDoc;
+		titleDoc.setData(title.c_str(), title.length());
+		Tokenizer titleTokens(&amp;titleDoc);
+		termPos = addTermsToDocument(titleTokens, doc, termPos, &quot;T&quot;, STORE_UNSTEM);
+		titleTokens.rewind();
+		termPos = addTermsToDocument(titleTokens, doc, termPos, &quot;&quot;, m_stemMode);
+	}
+
+	// Index the full URL with prefix U
+	string location = info.getLocation();
+	for (string::iterator i = location.begin(); i != location.end(); i++)
+	{
+		*i = tolower(*i);
+	}
+	doc.add_posting(string(&quot;U&quot;) + location, termPos++);
+
+	Url urlObj(location);
+
+	// ...the host name with prefix H
+	string hostName = urlObj.getHost();
+	doc.add_posting(string(&quot;H&quot;) + StringManip::toLowerCase(hostName), termPos++);
+	// ...and the file name with prefix F
+	string fileName = urlObj.getFile();
+	doc.add_posting(string(&quot;F&quot;) + StringManip::toLowerCase(fileName), termPos++);
+	// Finally, add the language with prefix L
+	doc.add_posting(string(&quot;L&quot;) + StringManip::toLowerCase(m_stemLanguage), termPos++);
+
+	setDocumentData(doc, info, summary, m_stemLanguage);
+
+	return true;
+}
+
+string XapianIndex::scanDocument(const char *pData, unsigned int dataLength,
+	DocumentInfo &amp;info)
+{
+	vector&lt;string&gt; candidates;
+	string language;
+	string summary;
+
+	// Try to determine the document's language
+	LanguageDetector lang;
+	lang.guessLanguage(pData, max(dataLength, (unsigned int)2048), candidates);
+
+	// See which of these languages is suitable for stemming
+	for (vector&lt;string&gt;::iterator langIter = candidates.begin(); langIter != candidates.end(); ++langIter)
+	{
+		if (*langIter == &quot;unknown&quot;)
+		{
+			continue;
+		}
+
+		try
+		{
+			Xapian::Stem stemmer(*langIter);
+		}
+		catch (const Xapian::Error &amp;e)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;XapianIndex::scanDocument: no support for &quot; &lt;&lt; *langIter &lt;&lt; endl;
+#endif
+			continue;
+		}
+
+		language = *langIter;
+		break;
+	}
+	m_stemLanguage = language;
+#ifdef DEBUG
+	cout &lt;&lt; &quot;XapianIndex::scanDocument: language now &quot; &lt;&lt; m_stemLanguage &lt;&lt; endl;
+#endif
+
+	// Get a summary of the document
+	if (language.empty() == true)
+	{
+		// Fall back on English
+		language = &quot;english&quot;;
+	}
+	Summarizer sum(language, 100);
+	summary = sum.summarize(pData, dataLength);
+
+	// Update the document's properties
+	string title = info.getTitle();
+	if (title.empty() == true)
+	{
+		// Use the title supplied by the summarizer
+		title = sum.getTitle();
+		// Remove heading spaces
+		while (isspace(title[0]))
+		{
+			title.erase(0, 1);
+		}
+		info.setTitle(title);
+	}
+	info.setLanguage(m_stemLanguage);
+
+	return summary;
+}
+
+void XapianIndex::setDocumentData(Xapian::Document &amp;doc, const DocumentInfo &amp;info, const string &amp;extract,
+	const string &amp;language) const
+{
+	char timeStr[64];
+	string timestamp = info.getTimestamp();
+
+	// Set the document data omindex-style
+	string record = &quot;url=&quot;;
+	record += info.getLocation();
+	record += &quot;\nsample=&quot;;
+	record += extract;
+	record += &quot;\ncaption=&quot;;
+	record += info.getTitle();
+	record += &quot;\ntype=&quot;;
+	record += info.getType();
+	// Append a timestamp
+	record += &quot;\ntimestamp=&quot;;
+	record += timestamp;
+	// ...and the language
+	record += &quot;\nlanguage=&quot;;
+	record += language;
+#ifdef DEBUG
+	cout &lt;&lt; &quot;XapianIndex::setDocumentData: document data is &quot; &lt;&lt; record &lt;&lt; endl;
+#endif
+	doc.set_data(record);
+
+	// Add this value to allow sorting by date
+	snprintf(timeStr, 64, &quot;%d&quot;, TimeConverter::fromTimestamp(timestamp));
+	doc.add_value(0, timeStr);
+}
+
+//
+// Implementation of IndexInterface
+//
+
+/// Gets the index location.
+string XapianIndex::getLocation(void) const
+{
+	return m_databaseName;
+}
+
+/// Indexes the given data.
+bool XapianIndex::indexDocument(Tokenizer &amp;tokens, unsigned int &amp;docId)
+{
+	unsigned int dataLength = 0;
+	bool indexed = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if ((pDatabase == NULL) ||
+		(m_pHistory == NULL))
+	{
+		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
+		return false;
+	}
+
+	try
+	{
+		// Get the document
+		const Document *pDocument = tokens.getDocument();
+		if (pDocument == NULL)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;XapianIndex::indexDocument: no document&quot; &lt;&lt; endl;
+#endif
+			return false;
+		}
+
+		// Obtain a summary
+		const char *pData = pDocument-&gt;getData(dataLength);
+		if (pData == NULL)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;XapianIndex::indexDocument: empty document&quot; &lt;&lt; endl;
+#endif
+			return false;
+		}
+		// Cache the document's properties
+		DocumentInfo docInfo(pDocument-&gt;getTitle(), pDocument-&gt;getLocation(),
+			pDocument-&gt;getType(), pDocument-&gt;getLanguage());
+		docInfo.setTimestamp(pDocument-&gt;getTimestamp());
+
+		string summary = scanDocument(pData, dataLength, docInfo);
+
+#ifdef DEBUG
+		cout &lt;&lt; &quot;XapianIndex::indexDocument: adding terms&quot; &lt;&lt; endl;
+#endif
+		Xapian::Document doc;
+		Xapian::termcount termPos = 0;
+
+		// Add the tokenizer's terms to the Xapian document
+		termPos = addTermsToDocument(tokens, doc, termPos, &quot;&quot;, m_stemMode);
+		if (prepareDocument(docInfo, doc, termPos, summary) == true)
+		{
+			Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
+			if (pIndex != NULL)
+			{
+				// Add this document to the Xapian index
+				docId = pIndex-&gt;add_document(doc);
+				// Add an entry in the history file
+				m_pHistory-&gt;insertItem(docId, docInfo);
+				indexed = true;
+			}
+			pDatabase-&gt;unlock();
+		}
+	}
+	catch (const Xapian::Error &amp;error)
+	{
+		cerr &lt;&lt; &quot;Couldn't index document: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
+	}
+	catch (...)
+	{
+		cerr &lt;&lt; &quot;Couldn't index document, unknown exception occured&quot; &lt;&lt; endl;
+	}
+
+	return indexed;
+}
+
+/// Updates the given document; true if success.
+bool XapianIndex::updateDocument(unsigned int docId, Tokenizer &amp;tokens)
+{
+	unsigned int dataLength = 0;
+	bool updated = false;
+
+	const Document *pDocument = tokens.getDocument();
+	if (pDocument == NULL)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
+		return false;
+	}
+
+	// Obtain a summary
+	const char *pData = pDocument-&gt;getData(dataLength);
+	if (pData == NULL)
+	{
+		return false;
+	}
+
+	// Cache the document's properties
+	DocumentInfo docInfo(pDocument-&gt;getTitle(), pDocument-&gt;getLocation(),
+		pDocument-&gt;getType(), pDocument-&gt;getLanguage());
+	docInfo.setTimestamp(pDocument-&gt;getTimestamp());
+
+	string summary = scanDocument(pData, dataLength, docInfo);
+
+	try
+	{
+		Xapian::Document doc;
+		Xapian::termcount termPos = 0;
+
+		// Add the tokenizer's terms to the document
+		termPos = addTermsToDocument(tokens, doc, termPos, &quot;&quot;, m_stemMode);
+		if (prepareDocument(docInfo, doc, termPos, summary) == true)
+		{
+			Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
+			if (pIndex != NULL)
+			{
+				// Update the document in the database
+				pIndex-&gt;replace_document(docId, doc);
+				// FIXME: if the document information has changed, we need to update the history too
+				updated = true;
+			}
+			pDatabase-&gt;unlock();
+		}
+	}
+	catch (const Xapian::Error &amp;error)
+	{
+		cerr &lt;&lt; &quot;Couldn't update document: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
+	}
+	catch (...)
+	{
+		cerr &lt;&lt; &quot;Couldn't update document, unknown exception occured&quot; &lt;&lt; endl;
+	}
+
+	return updated;
+}
+
+/// Returns the ID of the given document.
+unsigned int XapianIndex::hasDocument(const DocumentInfo &amp;docInfo) const
+{
+	if (m_pHistory == NULL)
+	{
+		return 0;
+	}
+
+	// Is this URL in the history file ?
+	return m_pHistory-&gt;hasURL(docInfo.getLocation());
+}
+
+/// Unindexes the given document; true if success.
+bool XapianIndex::unindexDocument(unsigned int docId)
+{
+	bool unindexed = false;
+
+	if (docId == 0)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if ((pDatabase == NULL) ||
+		(m_pHistory == NULL))
+	{
+		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
+		if (pIndex != NULL)
+		{
+			// Delete the document from the index
+			pIndex-&gt;delete_document(docId);
+			// Remove the entry from the history file
+			m_pHistory-&gt;deleteItem(docId);
+			unindexed = true;
+		}
+		pDatabase-&gt;unlock();
+	}
+	catch (const Xapian::Error &amp;error)
+	{
+		cerr &lt;&lt; &quot;Couldn't unindex document: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
+	}
+	catch (...)
+	{
+		cerr &lt;&lt; &quot;Couldn't unindex document, unknown exception occured&quot; &lt;&lt; endl;
+	}
+
+	return unindexed;
+}
+
+/// Flushes recent changes to the disk.
+bool XapianIndex::flush(void)
+{
+	bool flushed = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
+		return false;
+	}
+
+	try
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;XapianIndex::flush: called&quot; &lt;&lt; endl;
+#endif
+		Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
+		if (pIndex != NULL)
+		{
+			pIndex-&gt;flush();
+			flushed = true;
+		}
+		pDatabase-&gt;unlock();
+	}
+	catch (const Xapian::Error &amp;error)
+	{
+		cerr &lt;&lt; &quot;Couldn't flush database: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
+	}
+	catch (...)
+	{
+		cerr &lt;&lt; &quot;Couldn't flush database, unknown exception occured&quot; &lt;&lt; endl;
+	}
+
+	return flushed;
+}
+
+/// Returns the number of documents.
+unsigned int XapianIndex::getDocumentsCount(void) const
+{
+	unsigned int docCount = 0;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
+		return 0;
+	}
+
+	try
+	{
+		Xapian::Database *pIndex = pDatabase-&gt;readLock();
+		if (pIndex != NULL)
+		{
+			docCount = pIndex-&gt;get_doccount();
+		}
+		pDatabase-&gt;unlock();
+	}
+	catch (const Xapian::Error &amp;error)
+	{
+		cerr &lt;&lt; &quot;Couldn't count documents: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
+	}
+	catch (...)
+	{
+		cerr &lt;&lt; &quot;Couldn't count documents, unknown exception occured&quot; &lt;&lt; endl;
+	}
+
+	return docCount;
+}
+
+/// Returns a list of document IDs.
+unsigned int XapianIndex::getDocumentIDs(set&lt;unsigned int&gt; &amp;docIDList,
+	unsigned int maxDocsCount, unsigned int startDoc, bool sortByDate) const
+{
+	if (m_pHistory == NULL)
+	{
+		return 0;
+	}
+
+	docIDList.clear();
+
+	return m_pHistory-&gt;listItems(docIDList, maxDocsCount, startDoc, sortByDate);
+}
+
+/// Returns a document's properties.
+bool XapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &amp;docInfo) const
+{
+	if (m_pHistory == NULL)
+	{
+		return false;
+	}
+
+	return m_pHistory-&gt;getItem(docId, docInfo);
+}
+
+/// Updates a document's properties.
+bool XapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &amp;docInfo)
+{
+	bool updated = false;
+
+	if (docId == 0)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr &lt;&lt; &quot;Bad index &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase-&gt;writeLock();
+		if (pIndex != NULL)
+		{
+			Xapian::Document doc = pIndex-&gt;get_document(docId);
+
+			// Get the current document data
+			string record = doc.get_data();
+			string extract = StringManip::extractField(record, &quot;sample=&quot;, &quot;\n&quot;);
+			string language = StringManip::extractField(record, &quot;language=&quot;, &quot;\n&quot;);
+
+			// Update the document data with the new extract
+			setDocumentData(doc, docInfo, extract, language);
+			// Update the document
+			if (m_pHistory-&gt;updateItem(docId, docInfo) == true)
+			{
+				pIndex-&gt;replace_document(docId, doc);
+				updated = true;
+			}
+		}
+		pDatabase-&gt;unlock();
+	}
+	catch (const Xapian::Error &amp;error)
+	{
+		cerr &lt;&lt; &quot;Couldn't update document: &quot; &lt;&lt; error.get_msg() &lt;&lt; endl;
+	}
+	catch (...)
+	{
+		cerr &lt;&lt; &quot;Couldn't update document, unknown exception occured&quot; &lt;&lt; endl;
+	}
+
+	return updated;
+}


Property changes on: trunk/Index/XapianIndex.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Index/XapianIndex.h
===================================================================
--- trunk/Index/XapianIndex.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/XapianIndex.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,92 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XAPIAN_INDEX_H
+#define _XAPIAN_INDEX_H
+
+#include &lt;string&gt;
+#include &lt;set&gt;
+
+#include &lt;xapian.h&gt;
+
+#include &quot;DocumentInfo.h&quot;
+#include &quot;IndexHistory.h&quot;
+#include &quot;IndexInterface.h&quot;
+
+class XapianIndex : public IndexInterface
+{
+	public:
+		XapianIndex(const std::string &amp;indexName);
+		virtual ~XapianIndex();
+
+		/// Gets the index location.
+		virtual std::string getLocation(void) const;
+
+		/// Indexes the given data.
+		virtual bool indexDocument(Tokenizer &amp;tokens, unsigned int &amp;docId);
+
+		/// Updates the given document; true if success.
+		virtual bool updateDocument(unsigned int docId, Tokenizer &amp;tokens);
+
+		/// Returns the ID of the given document.
+		virtual unsigned int hasDocument(const DocumentInfo &amp;docInfo) const;
+
+		/// Unindexes the given document; true if success.
+		virtual bool unindexDocument(unsigned int docId);
+
+		/// Flushes recent changes to the disk.
+		virtual bool flush(void);
+
+		/// Returns the number of documents.
+		virtual unsigned int getDocumentsCount(void) const;
+
+		/// Returns a list of document IDs.
+		virtual unsigned int getDocumentIDs(std::set&lt;unsigned int&gt; &amp;docIDList,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0,
+			bool sortByDate = false) const;
+
+		/// Returns a document's properties.
+		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &amp;docInfo) const;
+
+		/// Updates a document's properties.
+		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &amp;docInfo);
+
+	protected:
+		static const unsigned int m_maxTermLength;
+		static const std::string MAGIC_TERM;
+		std::string m_databaseName;
+		IndexHistory *m_pHistory;
+		std::string m_stemLanguage;
+
+		bool addTermsToDocument(Tokenizer &amp;tokens, Xapian::Document &amp;doc,
+			Xapian::termcount &amp;termPos, const std::string &amp;prefix, StemmingMode mode) const;
+
+		bool prepareDocument(const DocumentInfo &amp;info, Xapian::Document &amp;doc,
+			Xapian::termcount &amp;termPos, const std::string &amp;summary) const;
+
+		std::string scanDocument(const char *pData, unsigned int dataLength,
+			DocumentInfo &amp;info);
+
+		void setDocumentData(Xapian::Document &amp;doc, const DocumentInfo &amp;info, const string &amp;extract,
+			const string &amp;language) const;
+
+	private:
+		XapianIndex(const XapianIndex &amp;other);
+		XapianIndex &amp;operator=(const XapianIndex &amp;other);
+
+};
+
+#endif // _XAPIAN_INDEX_H


Property changes on: trunk/Index/XapianIndex.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Index/indextest.cpp
===================================================================
--- trunk/Index/indextest.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/indextest.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,119 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;Document.h&quot;
+#include &quot;TokenizerFactory.h&quot;
+#include &quot;XapianDatabaseFactory.h&quot;
+#include &quot;XapianIndex.h&quot;
+
+using namespace std;
+
+int main(int argc, char **argv)
+{
+	if (argc &lt; 4)
+	{
+		cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;index type&gt; &lt;database name&gt; &lt;file name&gt;|CHECK|CREATE&quot; &lt;&lt; endl;
+		return EXIT_FAILURE;
+	}
+
+	// Check database ?
+	if (strncasecmp(argv[3], &quot;CHECK&quot;, 5) == 0)
+	{
+		if (XapianDatabaseFactory::getDatabase(argv[2], true) != NULL)
+		{
+			XapianIndex index(argv[2]);
+			cout &lt;&lt; &quot;Index has &quot; &lt;&lt; index.getDocumentsCount() &lt;&lt; &quot; document(s)&quot; &lt;&lt; endl;
+
+			return EXIT_SUCCESS;
+		}
+
+		return EXIT_FAILURE;
+	}
+	// Create database ?
+	else if (strncasecmp(argv[3], &quot;CREATE&quot;, 6) == 0)
+	{
+		if (XapianDatabaseFactory::getDatabase(argv[2], false) != NULL)
+		{
+			return EXIT_SUCCESS;
+		}
+
+		return EXIT_FAILURE;
+	}
+
+	struct stat fileStat;
+	if ((stat(argv[3], &amp;fileStat) == 0) &amp;&amp;
+		(S_ISREG(fileStat.st_mode)))
+	{
+		char *buffer = new char[fileStat.st_size + 1];
+		int fd = open(argv[3], O_RDONLY);
+		// Read the file
+		ssize_t readBytes = read(fd, buffer, fileStat.st_size);
+		if (readBytes == -1)
+		{
+			cerr &lt;&lt; &quot;Couldn't read &quot; &lt;&lt; argv[3] &lt;&lt; &quot; !&quot; &lt;&lt; endl;
+			return EXIT_FAILURE;
+		}
+
+		// Assume file is HTML...
+		Document doc(argv[3], argv[3], &quot;text/html&quot;, &quot;&quot;);
+		doc.setData(buffer, readBytes);
+		if (doc.isBinary() == true)
+		{
+			cerr &lt;&lt; argv[3] &lt;&lt; &quot; is binary !&quot; &lt;&lt; endl;
+		}
+		else
+		{
+			unsigned int docId = 0;
+
+			Tokenizer *pTokens = TokenizerFactory::getTokenizer(argv[3], &amp;doc);
+			if (pTokens == NULL)
+			{
+				cerr &lt;&lt; &quot;Couldn't obtain tokenizer for &quot; &lt;&lt; argv[3] &lt;&lt; &quot; !&quot; &lt;&lt; endl;
+				return EXIT_FAILURE;
+			}
+
+			// Ignore index type, use a XapianIndex
+			XapianIndex index(argv[2]);
+			index.setStemmingMode(IndexInterface::STORE_BOTH);
+			if (index.indexDocument(*pTokens, docId) == false)
+			{
+				cerr &lt;&lt; &quot;Couldn't index &quot; &lt;&lt; argv[3] &lt;&lt; &quot; !&quot; &lt;&lt; endl;
+			}
+			else
+			{
+				cout &lt;&lt; &quot;Added &quot; &lt;&lt; argv[3] &lt;&lt; &quot; to index, document&quot; &lt;&lt; docId &lt;&lt; endl;
+			}
+
+			delete pTokens;
+		}
+
+		delete[] buffer;
+	}
+	else
+	{
+		cerr &lt;&lt; &quot;Couldn't stat &quot; &lt;&lt; argv[3] &lt;&lt; &quot; !&quot; &lt;&lt; endl;
+	}
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/Index/indextest.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Makefile
===================================================================
--- trunk/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,56 @@
+
+ROOT_DIR = .
+include ${ROOT_DIR}/variables.mk
+
+INSTALL_TARGETS = install-pinot
+ifeq ($(HAS_GOOGLEAPI),yes)
+SOAP_PROJECTS = Search/Google
+endif
+ifeq ($(HAS_OSAPI),yes)
+SOAP_PROJECTS += Search/ObjectsSearch
+endif
+PROJECTS := Utils Tokenize SQL Collect ${SOAP_PROJECTS} Search Index \
+	UI/RenderHTML UI/GTK2/src ${PLUGIN_PROJECTS}
+TARGETS_ALL := $(patsubst %,%_all,${PROJECTS})
+TARGETS_CLEAN := $(patsubst %,%_clean,${PROJECTS})
+
+targets : ${TARGETS_ALL}
+
+clean : ${TARGETS_CLEAN}
+
+update :
+	@cvs update
+
+pinot_po :
+	@xgettext -d pinot -o po/pinot.po --force-po --keyword=_ -f po/POTFILES
+ 
+pinot_mo :
+	@mkdir -p mo
+	@msgfmt -o mo/en_GB.mo po/en_GB.po
+	@msgfmt -o mo/fr_FR.mo po/fr_FR.po
+
+%_clean :
+	@make -C $(patsubst %_clean, %, $@) clean
+	
+%_all :
+	@make -C $(patsubst %_all, %, $@) all
+
+install: ${INSTALL_TARGETS}
+
+install-pinot:
+	@mkdir -p $(PREFIX)/usr/bin/
+	install -m 755 ${BIN_DIR}/pinot $(PREFIX)/usr/bin/pinot
+	@mkdir -p $(PREFIX)/usr/share/pinot/engines/
+	@mkdir -p $(PREFIX)/usr/share/pinot/tokenizers/
+	install -m 644 index.html $(PREFIX)/usr/share/pinot/
+	install -m 644 Search/Plugins/* $(PREFIX)/usr/share/pinot/engines/
+	install -m 755 ${LIB_DIR}/*.so $(PREFIX)/usr/share/pinot/tokenizers/
+	install -m 644 UI/GTK2/xapian-powered.png $(PREFIX)/usr/share/pinot/
+	install -m 644 UI/GTK2/metase-gtk2.glade $(PREFIX)/usr/share/pinot/
+	install -m 644 UI/GTK2/metase-gtk2.gladep $(PREFIX)/usr/share/pinot/
+	install -m 644 textcat_conf.txt $(PREFIX)/usr/share/pinot/
+	@mkdir -p $(PREFIX)/usr/share/locale/fr/LC_MESSAGES/
+	install -m 644 mo/fr_FR.mo $(PREFIX)/usr/share/locale/fr/LC_MESSAGES/pinot.mo
+	@mkdir -p $(PREFIX)/usr/share/icons/hicolor/48x48/apps/
+	install -m 644 UI/GTK2/pinot.png $(PREFIX)/usr/share/icons/hicolor/48x48/apps/
+


Property changes on: trunk/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/README
===================================================================
--- trunk/README	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/README	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,89 @@
+Pinot, <A HREF="http://pinot.berlios.de/">http://pinot.berlios.de/</A>
+
+Pinot is a metasearch tool for the X-Window desktop. It acts as a front-end for
+search engines such as Google (with support for the SOAP API), All The Web,
+Ask Jeeves, etc.. and allows one to index relevant results locally and query
+the index.
+It was developed and tested on GNU/Linux and should work on other Unix-like systems.
+
+Dependencies :
+---------------
+
+Name			Location			Version used
+----			--------			------------
+
+SQLite							sqlite-devel-3.1.2-1
+<A HREF="http://www.sqlite.org/">http://www.sqlite.org/</A>
+
+xapian-core						xapian-core-devel-0.9.0-1
+<A HREF="http://www.xapian.org/">http://www.xapian.org/</A>
+
+neon							neon-devel-0.24.7-4
+<A HREF="http://www.webdav.org/neon/">http://www.webdav.org/neon/</A>
+
+Google SOAP API (1)	Search/Google/googleapi		beta2
+
+ GSOAP			$GSOAP_HOME			2.6.2
+ <A HREF="http://www.cs.fsu.edu/~engelen/soap.html">http://www.cs.fsu.edu/~engelen/soap.html</A>
+ eg GSOAP_HOME=/home/fabrice/Projects/gsoap-linux-2.6
+
+ObjectsSearch API (2)	Search/ObjectsSearch		beta
+
+ GSOAP			$GSOAP_HOME			2.6.2
+
+gtkmm &gt;= 2.4.12						gtkmm24-devel-2.6.2-2
+<A HREF="http://www.gtkmm.org/">http://www.gtkmm.org/</A>
+
+libxml++ (3)						libxml++-devel-2.10.0-1
+<A HREF="http://libxmlplusplus.sourceforge.net/">http://libxmlplusplus.sourceforge.net/</A>
+
+ libxml2						libxml2-devel-2.6.16-3
+
+ots							ots-devel-0.4.2-2
+<A HREF="http://libots.sourceforge.net/">http://libots.sourceforge.net/</A>
+
+libtextcat						libtextcat-devel-2.2-1
+<A HREF="http://software.wise-guys.nl/libtextcat/">http://software.wise-guys.nl/libtextcat/</A>
+
+fam							fam-devel-2.6.10-9.FC2
+<A HREF="http://oss.sgi.com/projects/fam/">http://oss.sgi.com/projects/fam/</A>
+- OR -
+gamin (4)						gamin-0.1.1-3.FC4
+<A HREF="http://www.gnome.org/~veillard/gamin/">http://www.gnome.org/~veillard/gamin/</A>
+
+gmime							gmime-devel-2.1.9-3
+<A HREF="http://spruce.sourceforge.net/gmime">http://spruce.sourceforge.net/gmime</A>
+
+Mozilla with gtk-mozembed				mozilla-devel-1.6
+<A HREF="http://www.mozilla.org/">http://www.mozilla.org/</A>
+
+boost (5)						boost-devel-1.32.0-1.fc3
+<A HREF="http://www.boost.org/">http://www.boost.org/</A>
+
+pdftohtml						pdftohtml-0.36-4
+<A HREF="http://pdftohtml.sourceforge.net/">http://pdftohtml.sourceforge.net/</A>
+
+antiword						antiword-0.36.1-2
+<A HREF="http://www.winfield.demon.nl/">http://www.winfield.demon.nl/</A>
+
+glademm (6)						glademm-2.6.0_cvs-SNAP
+<A HREF="http://home.wtal.de/petig/Gtk/index.html">http://home.wtal.de/petig/Gtk/index.html</A>
+
+(1) enabled with 'make HAS_GOOGLEAPI=yes'
+(2) enabled with 'make HAS_OSAPI=yes'
+(3) or libxml++ 0.26 if HAS_LIBXMLPP026 is defined
+(4) &gt;= 0.1.6 and a recent kernel are required for the inotify backend
+(5) for building only
+(6) to optionally regenerate the GUI code
+
+FAQ :
+-----
+
+- When listing an index or indexing documents, Pinot complains of an
+  &quot;index error&quot;. What's going on ?
+
+  This is likely because a previous instance didn't exit properly and one
+  (or more) index is still locked. Quit Pinot and look for a &quot;db_lock&quot; file
+  in &quot;~/.pinot/index&quot; and &quot;~/.pinot/mail&quot;. If it's there, delete it and
+  restart Pinot. This will be fixed in the future.
+


Property changes on: trunk/README
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/SQL/ActionHistory.cpp
===================================================================
--- trunk/SQL/ActionHistory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/ActionHistory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,127 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;Url.h&quot;
+#include &quot;TimeConverter.h&quot;
+#include &quot;ActionHistory.h&quot;
+
+ActionHistory::ActionHistory(const string &amp;database) :
+	SQLiteBase(database)
+{
+}
+
+ActionHistory::~ActionHistory()
+{
+}
+
+/// Creates the ActionHistory table in the database.
+bool ActionHistory::create(const string &amp;database)
+{
+	bool success = true;
+
+	// The specified path must be a file
+	if (SQLiteBase::check(database) == false)
+	{
+		return false;
+	}
+
+	SQLiteBase db(database);
+
+	// Does ActionHistory exist ?
+	if (db.executeSimpleStatement(&quot;SELECT * FROM ActionHistory LIMIT 1;&quot;) == false)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ActionHistory::create: ActionHistory doesn't exist&quot; &lt;&lt; endl;
+#endif
+		// Create the table
+		if (db.executeSimpleStatement(&quot;CREATE TABLE ActionHistory (Type UNSIGNED INT NOT NULL, Date TIMESTAMP, Option TEXT, PRIMARY KEY(Type, Option));&quot;) == false)
+		{
+			success = false;
+		}
+	}
+
+	return success;
+}
+
+/// Inserts an item.
+bool ActionHistory::insertItem(ActionType type, const string &amp;option)
+{
+	string date = TimeConverter::toTimestamp(time(NULL));
+	bool success = false;
+
+	SQLiteResults *results = executeStatement(&quot;INSERT INTO ActionHistory \
+		VALUES(%u, '%q', '%q');&quot;, (unsigned int)type, date.c_str(), option.c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Gets and deletes the oldest item.
+bool ActionHistory::deleteOldestItem(ActionType &amp;type, string &amp;option)
+{
+	string date;
+	bool success = false;
+
+	if (getOldestItem(type, date, option) == false)
+	{
+		return false;
+	}
+
+	// Delete from ActionHistory
+	SQLiteResults *results = executeStatement(&quot;DELETE FROM ActionHistory \
+		WHERE Type=%u AND Option='%q';&quot;, (unsigned int)type, option.c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+bool ActionHistory::getOldestItem(ActionType &amp;type, string &amp;date, string &amp;option) const
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement(&quot;SELECT Type, Date, Option \
+		FROM ActionHistory ORDER BY %s DESC LIMIT 1&quot;, &quot;Date&quot;);
+	if (results != NULL)
+	{
+		SQLiteRow *row = results-&gt;nextRow();
+		if (row != NULL)
+		{
+			type = (ActionType)atoi(row-&gt;getColumn(0).c_str());
+			date = row-&gt;getColumn(1);
+			option = row-&gt;getColumn(2);
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}

Added: trunk/SQL/ActionHistory.h
===================================================================
--- trunk/SQL/ActionHistory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/ActionHistory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,52 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _ACTION_HISTORY_H
+#define _ACTION_HISTORY_H
+
+#include &lt;string&gt;
+
+#include &quot;SQLiteBase.h&quot;
+
+using namespace std;
+
+class ActionHistory : public SQLiteBase
+{
+	public:
+		ActionHistory(const string &amp;database);
+		virtual ~ActionHistory();
+
+		/// Creates the ActionHistory table in the database.
+		static bool create(const string &amp;database);
+
+		typedef enum { ACTION_INDEX = 0, ACTION_UPDATE, ACTION_UNINDEX } ActionType;
+
+		/// Inserts an item.
+		bool insertItem(ActionType type, const string &amp;option);
+
+		/// Gets and deletes the oldest item.
+		bool deleteOldestItem(ActionType &amp;type, string &amp;option);
+
+	protected:
+		bool getOldestItem(ActionType &amp;type, string &amp;date, string &amp;option) const;
+
+	private:
+		ActionHistory(const ActionHistory &amp;other);
+		ActionHistory &amp;operator=(const ActionHistory &amp;other);
+
+};
+
+#endif // _ACTION_HISTORY_H

Added: trunk/SQL/IndexHistory.cpp
===================================================================
--- trunk/SQL/IndexHistory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/IndexHistory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,246 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;Url.h&quot;
+#include &quot;TimeConverter.h&quot;
+#include &quot;IndexHistory.h&quot;
+
+IndexHistory::IndexHistory(const string &amp;database) :
+	SQLiteBase(database)
+{
+}
+
+IndexHistory::~IndexHistory()
+{
+}
+
+/// Creates the necessary tables in the database.
+bool IndexHistory::create(const string &amp;database)
+{
+	bool success = true;
+
+	// The specified path must be a file
+	if (SQLiteBase::check(database) == false)
+	{
+		return false;
+	}
+
+	SQLiteBase db(database);
+
+	// Does IndexHistory exist ?
+	if (db.executeSimpleStatement(&quot;SELECT * FROM IndexHistory LIMIT 1;&quot;) == false)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;IndexHistory::create: IndexHistory doesn't exist&quot; &lt;&lt; endl;
+#endif
+		// Create the table
+		if (db.executeSimpleStatement(&quot;CREATE TABLE IndexHistory \
+			(DocId BIGINT UNSIGNED NOT NULL PRIMARY KEY, Title VARCHAR(255), \
+			Url VARCHAR(255), Type VARCHAR(255), Language VARCHAR(255), \
+			Date TIMESTAMP, Status INT);&quot;) == false)
+		{
+			success = false;
+		}
+	}
+
+	return success;
+}
+
+/// Inserts an item.
+bool IndexHistory::insertItem(unsigned int docId, const DocumentInfo &amp;docInfo)
+{
+	bool success = false;
+
+	// FIXME: make Status configurable
+	SQLiteResults *results = executeStatement(&quot;INSERT INTO IndexHistory \
+		VALUES(%u, '%q', '%q', '%q', '%q', '%d', 1);&quot;,
+		docId, docInfo.getTitle().c_str(), Url::escapeUrl(docInfo.getLocation()).c_str(),
+		docInfo.getType().c_str(), docInfo.getLanguage().c_str(),
+		TimeConverter::fromTimestamp(docInfo.getTimestamp()));
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Checks if an URL is in the history; returns the document ID.
+unsigned int IndexHistory::hasURL(const string &amp;originalUrl) const
+{
+	unsigned int docId = 0;
+
+	SQLiteResults *results = executeStatement(&quot;SELECT DocId FROM IndexHistory \
+		WHERE Url='%q';&quot;,
+		Url::escapeUrl(originalUrl).c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row = results-&gt;nextRow();
+		if (row != NULL)
+		{
+			docId = (unsigned int)atoi(row-&gt;getColumn(0).c_str());
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return docId;
+}
+
+/// Updates an item.
+bool IndexHistory::updateItem(unsigned int docId, const DocumentInfo &amp;docInfo)
+{
+	bool success = false;
+
+	// FIXME: make Status configurable
+	SQLiteResults *results = executeStatement(&quot;UPDATE IndexHistory \
+		SET Title='%q', Url='%q', Type='%q', Language='%q', Date='%d' \
+		WHERE DocId=%u;&quot;,
+		docInfo.getTitle().c_str(), Url::escapeUrl(docInfo.getLocation()).c_str(),
+		docInfo.getType().c_str(), docInfo.getLanguage().c_str(),
+		TimeConverter::fromTimestamp(docInfo.getTimestamp()), docId);
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Lists document IDs; returns the total count.
+unsigned int IndexHistory::listItems(set&lt;unsigned int&gt; &amp;items,
+	unsigned int maxDocsCount, unsigned int startDoc,
+	bool sortByDate) const
+{
+	string sql;
+	unsigned int total = 0;
+
+	sql = &quot;SELECT DocId FROM IndexHistory&quot;;
+	if (sortByDate == true)
+	{
+		sql += &quot; ORDER BY Date&quot;;
+	}
+	if (maxDocsCount &gt; 0)
+	{
+		char docsCountStr[64];
+
+		sql += &quot; LIMIT &quot;;
+		if (startDoc &gt; 0)
+		{
+			snprintf(docsCountStr, 64, &quot;%u&quot;, startDoc);
+			sql += docsCountStr;
+			sql += &quot;,&quot;;
+		}
+		snprintf(docsCountStr, 64, &quot;%u&quot;, maxDocsCount);
+		sql += docsCountStr;
+	}
+	sql += &quot;;&quot;;
+	SQLiteResults *results = executeStatement(sql.c_str());
+	if (results != NULL)
+	{
+		while (results-&gt;hasMoreRows() == true)
+		{
+			SQLiteRow *row = results-&gt;nextRow();
+			if (row == NULL)
+			{
+				break;
+			}
+
+			unsigned int docId = (unsigned int)atoi(row-&gt;getColumn(0).c_str());
+#ifdef DEBUG
+			cout &lt;&lt; &quot;IndexHistory::listItems: item &quot; &lt;&lt; docId &lt;&lt; endl;
+#endif
+			items.insert(docId);
+			total++;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return total;
+}
+
+/// Gets an item's properties.
+bool IndexHistory::getItem(unsigned int docId, DocumentInfo &amp;docInfo) const
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement(&quot;SELECT Title, Url, Type, \
+		Language, Date FROM IndexHistory WHERE DocId=%u;&quot;, docId);
+	if (results != NULL)
+	{
+		SQLiteRow *row =results-&gt;nextRow();
+		if (row != NULL)
+		{
+			docInfo.setTitle(row-&gt;getColumn(0));
+			docInfo.setLocation(Url::unescapeUrl(row-&gt;getColumn(1)));
+			docInfo.setType(row-&gt;getColumn(2));
+			docInfo.setLanguage(row-&gt;getColumn(3));
+			docInfo.setTimestamp(TimeConverter::toTimestamp(atoi(row-&gt;getColumn(4).c_str())));
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Deletes items.
+bool IndexHistory::deleteByURL(const string &amp;originalUrl)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement(&quot;DELETE FROM IndexHistory WHERE Url='%q';&quot;,
+		Url::escapeUrl(originalUrl).c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Deletes an item.
+bool IndexHistory::deleteItem(unsigned int docId)
+{
+	bool success = false;
+
+	// Delete from both IndexHistory and DocumentLabels
+	SQLiteResults *results = executeStatement(&quot;DELETE FROM IndexHistory WHERE DocId=%u;&quot;,
+		docId);
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}

Added: trunk/SQL/IndexHistory.h
===================================================================
--- trunk/SQL/IndexHistory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/IndexHistory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,67 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _INDEX_HISTORY_H
+#define _INDEX_HISTORY_H
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;set&gt;
+
+#include &quot;DocumentInfo.h&quot;
+#include &quot;SQLiteBase.h&quot;
+
+using namespace std;
+
+class IndexHistory : public SQLiteBase
+{
+	public:
+		IndexHistory(const string &amp;database);
+		virtual ~IndexHistory();
+
+		/// Creates the necessary tables in the database.
+		static bool create(const string &amp;database);
+
+		/// Inserts an item.
+		bool insertItem(unsigned int docId, const DocumentInfo &amp;docInfo);
+
+		/// Checks if an URL is in the history; returns the document ID.
+		unsigned int hasURL(const string &amp;originalUrl) const;
+
+		/// Updates an item.
+		bool updateItem(unsigned int docId, const DocumentInfo &amp;docInfo);
+
+		/// Lists document IDs; returns the total count.
+		unsigned int listItems(set&lt;unsigned int&gt; &amp;items,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0,
+			bool sortByDate = false) const;
+
+		/// Gets an item's properties.
+		bool getItem(unsigned int docId, DocumentInfo &amp;docInfo) const;
+
+		/// Deletes items.
+		bool deleteByURL(const string &amp;originalUrl);
+
+		/// Deletes an item.
+		bool deleteItem(unsigned int docId);
+
+	private:
+		IndexHistory(const IndexHistory &amp;other);
+		IndexHistory &amp;operator=(const IndexHistory &amp;other);
+
+};
+
+#endif // _INDEX_HISTORY_H

Added: trunk/SQL/LabelManager.cpp
===================================================================
--- trunk/SQL/LabelManager.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/LabelManager.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,350 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;Url.h&quot;
+#include &quot;TimeConverter.h&quot;
+#include &quot;LabelManager.h&quot;
+
+LabelManager::LabelManager(const string &amp;database) :
+	SQLiteBase(database)
+{
+}
+
+LabelManager::~LabelManager()
+{
+}
+
+unsigned int LabelManager::getLabelId(const string &amp;labelName) const
+{
+	unsigned int labelId = 0;
+
+	// Get the label ID
+	SQLiteResults *results = executeStatement(&quot;SELECT LabelId 	FROM IndexLabels WHERE Name='%q';&quot;,
+		labelName.c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row =results-&gt;nextRow();
+		if (row != NULL)
+		{
+			labelId = (unsigned int)atoi(row-&gt;getColumn(0).c_str());
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return labelId;
+}
+
+unsigned int LabelManager::getNewLabelId(void) const
+{
+	unsigned int labelId = 1;
+
+	// Get the label ID
+	SQLiteResults *results = executeStatement(&quot;SELECT ROWID FROM IndexLabels \
+		ORDER BY ROWID DESC LIMIT 1;&quot;);
+	if (results != NULL)
+	{
+		SQLiteRow *row =results-&gt;nextRow();
+		if (row != NULL)
+		{
+			labelId = (unsigned int)atoi(row-&gt;getColumn(0).c_str());
+			++labelId;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return labelId;
+}
+
+/// Creates the necessary tables in the database.
+bool LabelManager::create(const string &amp;database)
+{
+	bool success = true;
+
+	// The specified path must be a file
+	if (SQLiteBase::check(database) == false)
+	{
+		return false;
+	}
+
+	SQLiteBase db(database);
+
+	// Does IndexLabels exist ?
+	if (db.executeSimpleStatement(&quot;SELECT * FROM IndexLabels LIMIT 1;&quot;) == false)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;LabelManager::create: IndexLabels doesn't exist&quot; &lt;&lt; endl;
+#endif
+		// Create the table
+		if (db.executeSimpleStatement(&quot;CREATE TABLE IndexLabels \
+			(LabelId BIGINT UNSIGNED NOT NULL PRIMARY KEY, Name VARCHAR(255));&quot;) == false)
+		{
+			success = false;
+		}
+	}
+	// Does DocumentLabels exist ?
+	if (db.executeSimpleStatement(&quot;SELECT * FROM DocumentLabels LIMIT 1;&quot;) == false)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;LabelManager::create: DocumentLabels doesn't exist&quot; &lt;&lt; endl;
+#endif
+		// Create the table
+		if (db.executeSimpleStatement(&quot;CREATE TABLE DocumentLabels \
+			(LabelId BIGINT UNSIGNED NOT NULL, DocId BIGINT UNSIGNED NOT NULL, \
+			Source VARCHAR(255), PRIMARY KEY(LabelId, DocId, Source));&quot;) == false)
+		{
+			success = false;
+		}
+	}
+
+	return success;
+}
+
+/// Gets a list of items with the given label.
+bool LabelManager::getDocumentsWithLabel(const string &amp;labelName, const string &amp;sourceName,
+	set&lt;unsigned int&gt; &amp;items) const
+{
+	bool success = false;
+
+	unsigned int labelId = getLabelId(labelName);
+	if (labelId == 0)
+	{
+		// Label was not found
+		return false;
+	}
+
+	SQLiteResults *results = executeStatement(&quot;SELECT DocId FROM DocumentLabels \
+		WHERE LabelId=%u AND Source='%q';&quot;,
+		labelId, sourceName.c_str());
+	if (results != NULL)
+	{
+		while (results-&gt;hasMoreRows() == true)
+		{
+			SQLiteRow *row =results-&gt;nextRow();
+			if (row == NULL)
+			{
+				break;
+			}
+
+			unsigned int docId = (unsigned int)atoi(row-&gt;getColumn(0).c_str());
+#ifdef DEBUG
+			cout &lt;&lt; &quot;LabelManager::getDocumentsWithLabel: item &quot; &lt;&lt; docId &lt;&lt; endl;
+#endif
+			items.insert(docId);
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Checks if a document has a label.
+bool LabelManager::hasLabel(unsigned int docId, const string &amp;sourceName,
+	const string &amp;labelName) const
+{
+	bool success = false;
+
+	unsigned int labelId = getLabelId(labelName);
+	if (labelId == 0)
+	{
+		// Label was not found
+		return false;
+	}
+
+	SQLiteResults *results = executeStatement(&quot;SELECT DocId FROM DocumentLabels \
+		WHERE LabelId=%u AND DocId=%u AND Source='%q';&quot;,
+		labelId, docId, sourceName.c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row =results-&gt;nextRow();
+		if (row != NULL)
+		{
+			// Yes, this document has the given label
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Sets a document's labels.
+bool LabelManager::setLabels(unsigned int docId, const string &amp;sourceName,
+	const set&lt;string&gt; &amp;labels)
+{
+	bool success = false;
+
+	// First off, delete all labels for this document
+	SQLiteResults *results = executeStatement(&quot;DELETE FROM DocumentLabels \
+		WHERE DocId=%u AND Source='%q';&quot;,
+		docId, sourceName.c_str());
+	if (results == NULL)
+	{
+		return false;
+	}
+	delete results;
+
+	for (set&lt;string&gt;::const_iterator iter = labels.begin(); iter != labels.end(); ++iter)
+	{
+		string labelName = (*iter);
+
+#ifdef DEBUG
+		cout &lt;&lt; &quot;LabelManager::setLabels: label &quot; &lt;&lt; labelName &lt;&lt; endl;
+#endif
+		// Does this label exist ?
+		unsigned int labelId = getLabelId(labelName);
+		if (labelId == 0)
+		{
+			// No, it doesn't : create it then
+			labelId = getNewLabelId();
+			results = executeStatement(&quot;INSERT INTO IndexLabels VALUES(%u, '%q');&quot;,
+				labelId, labelName.c_str());
+			if (results == NULL)
+			{
+#ifdef DEBUG
+				cout &lt;&lt; &quot;LabelManager::setLabels: couldn't create label &quot; &lt;&lt; labelName &lt;&lt; endl;
+#endif
+				continue;
+			}
+			delete results;
+		}
+
+		// Insert this label
+		SQLiteResults *results = executeStatement(&quot;INSERT INTO DocumentLabels VALUES(%u, %u, '%q');&quot;,
+			labelId, docId, sourceName.c_str());
+		if (results != NULL)
+		{
+			delete results;
+		}
+	}
+
+	return true;
+}
+
+/// Gets the labels for the given document.
+bool LabelManager::getLabels(unsigned int docId, const string &amp;sourceName,
+	set&lt;string&gt; &amp;labels) const
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement(&quot;SELECT i.Name FROM IndexLabels i, \
+		DocumentLabels d WHERE d.LabelId=i.LabelId AND d.DocId=%u AND d.Source='%q';&quot;,
+		docId, sourceName.c_str());
+	if (results != NULL)
+	{
+		while (results-&gt;hasMoreRows() == true)
+		{
+			SQLiteRow *row = results-&gt;nextRow();
+			if (row == NULL)
+			{
+				break;
+			}
+
+			string labelName = row-&gt;getColumn(0);
+#ifdef DEBUG
+			cout &lt;&lt; &quot;LabelManager::getLabels: label &quot; &lt;&lt; labelName &lt;&lt; endl;
+#endif
+			labels.insert(labelName);
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Renames a label.
+bool LabelManager::renameLabel(const string &amp;name, const string &amp;newName)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement(&quot;UPDATE IndexLabels SET Name='%q' \
+		WHERE Name='%q';&quot;,
+		newName.c_str(), name.c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;LabelManager::renameLabel: renamed &quot; &lt;&lt; name &lt;&lt; &quot; to &quot; &lt;&lt; newName &lt;&lt; endl;
+#endif
+
+	return success;
+}
+
+/// Deletes all references to a label.
+bool LabelManager::deleteLabel(const string &amp;name)
+{
+	bool success = false;
+
+	unsigned int labelId = getLabelId(name);
+	if (labelId == 0)
+	{
+		// Nothing to delete
+		return true;
+	}
+
+	// Delete from both IndexLabels and DocumentLabels
+	SQLiteResults *results = executeStatement(&quot;DELETE FROM DocumentLabels \
+		WHERE LabelId=%u; DELETE FROM IndexLabels WHERE LabelId=%u;&quot;,
+		labelId, labelId);
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Deletes an item.
+bool LabelManager::deleteItem(unsigned int docId, const string &amp;sourceName)
+{
+	bool success = false;
+
+	// Delete from both IndexHistory and DocumentLabels
+	SQLiteResults *results = executeStatement(&quot;DELETE FROM DocumentLabels WHERE DocId=%u \
+		AND Source='%q';&quot;,
+		docId, sourceName.c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}

Added: trunk/SQL/LabelManager.h
===================================================================
--- trunk/SQL/LabelManager.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/LabelManager.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,74 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _LABEL_MANAGER_H
+#define _LABEL_MANAGER_H
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;set&gt;
+
+#include &quot;DocumentInfo.h&quot;
+#include &quot;SQLiteBase.h&quot;
+
+using namespace std;
+
+class LabelManager : public SQLiteBase
+{
+	public:
+		LabelManager(const string &amp;database);
+		virtual ~LabelManager();
+
+		/// Creates the necessary tables in the database.
+		static bool create(const string &amp;database);
+
+		/// Gets a list of items with the given label.
+		bool getDocumentsWithLabel(const string &amp;labelName, const string &amp;sourceName,
+			set&lt;unsigned int&gt; &amp;items) const;
+
+		/// Checks if a document has a label.
+		bool hasLabel(unsigned int docId, const string &amp;sourceName,
+			const string &amp;labelName) const;
+
+		/// Sets a document's labels.
+		bool setLabels(unsigned int docId, const string &amp;sourceName,
+			const set&lt;string&gt; &amp;labels);
+
+		/// Gets the labels for the given document.
+		bool getLabels(unsigned int docId, const string &amp;sourceName,
+			set&lt;string&gt; &amp;labels) const;
+
+		/// Renames a label.
+		bool renameLabel(const string &amp;name, const string &amp;newName);
+
+		/// Deletes all references to a label.
+		bool deleteLabel(const string &amp;name);
+
+		/// Deletes an item.
+		bool deleteItem(unsigned int docId, const string &amp;sourceName);
+
+	protected:
+		unsigned int getLabelId(const string &amp;labelName) const;
+
+		unsigned int getNewLabelId(void) const;
+
+	private:
+		LabelManager(const LabelManager &amp;other);
+		LabelManager &amp;operator=(const LabelManager &amp;other);
+
+};
+
+#endif // _LABEL_MANAGER_H

Added: trunk/SQL/Makefile
===================================================================
--- trunk/SQL/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,25 @@
+
+ROOT_DIR = ..
+include ${ROOT_DIR}/variables.mk
+
+SQL_SRCS = SQLiteBase.cpp ActionHistory.cpp IndexHistory.cpp \
+	QueryHistory.cpp ViewHistory.cpp LabelManager.cpp
+SQL_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${SQL_SRCS})
+SQL_TEST = ${BIN_DIR}/historytest
+
+targets : dirs ${SQL_LIB} ${SQL_TEST}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${SQL_LIB} ${SQL_TEST}
+
+# SQL tester
+
+${SQL_TEST} : ${OBJ_DIR}/historytest.o ${SQL_LIB} ${UTILS_LIB}
+	@echo Building ${SQL_TEST}
+	${LINK} -o $@ ${OBJ_DIR}/historytest.o ${SQL_LIB} ${UTILS_LIB} ${LIBS}
+
+# Library
+
+${SQL_LIB} : ${SQL_OBJS}
+	@echo Building ${SQL_LIB}
+	${AR} cr ${SQL_LIB} ${SQL_OBJS}

Added: trunk/SQL/QueryHistory.cpp
===================================================================
--- trunk/SQL/QueryHistory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/QueryHistory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,269 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;Url.h&quot;
+#include &quot;TimeConverter.h&quot;
+#include &quot;QueryHistory.h&quot;
+
+QueryHistory::QueryHistory(const string &amp;database) :
+	SQLiteBase(database)
+{
+}
+
+QueryHistory::~QueryHistory()
+{
+}
+
+/// Creates the QueryHistory table in the database.
+bool QueryHistory::create(const string &amp;database)
+{
+	bool success = true;
+
+	// The specified path must be a file
+	if (SQLiteBase::check(database) == false)
+	{
+		return false;
+	}
+
+	SQLiteBase db(database);
+
+	// Does QueryHistory exist ?
+	if (db.executeSimpleStatement(&quot;SELECT * FROM QueryHistory LIMIT 1;&quot;) == false)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;QueryHistory::create: QueryHistory doesn't exist&quot; &lt;&lt; endl;
+#endif
+		// Create the table
+		if (db.executeSimpleStatement(&quot;CREATE TABLE QueryHistory (QueryName VARCHAR(255), \
+			EngineName VARCHAR(255), HostName VARCHAR(255), Url VARCHAR(255), Title VARCHAR(255), \
+			Extract VARCHAR(255), Language VARCHAR(255), Score FLOAT, PrevScore FLOAT, Date INTEGER, \
+			PRIMARY KEY(QueryName, EngineName, Url));&quot;) == false)
+		{
+			success = false;
+		}
+	}
+
+	return success;
+}
+
+/// Inserts an URL.
+bool QueryHistory::insertItem(const string &amp;queryName, const string &amp;engineName, const string &amp;url,
+	const string &amp;title, const string &amp;extract, const string &amp;language, float score)
+{
+	Url urlObj(url);
+	string hostName = urlObj.getHost();
+	string escapedUrl = Url::escapeUrl(url);
+	bool success = false;
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;QueryHistory::insertItem: called&quot; &lt;&lt; endl;
+#endif
+	SQLiteResults *results = executeStatement(&quot;INSERT INTO QueryHistory \
+		VALUES('%q', '%q', '%q', '%q', '%q', '%q', '%q', '%f', '0.0', '%d');&quot;,
+		queryName.c_str(), engineName.c_str(), hostName.c_str(),
+		escapedUrl.c_str(), title.c_str(), extract.c_str(), language.c_str(),
+		score, time(NULL));
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Checks if an URL is in the history; returns its current score or 0 if not found.
+float QueryHistory::hasItem(const string &amp;queryName, const string &amp;engineName, const string &amp;url,
+	float &amp;previousScore) const
+{
+	float score = 0;
+
+	SQLiteResults *results = executeStatement(&quot;SELECT Score, PrevScore FROM QueryHistory \
+		WHERE QueryName='%q' AND EngineName='%q' AND Url='%q';&quot;,
+		queryName.c_str(), engineName.c_str(), Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row = results-&gt;nextRow();
+		if (row != NULL)
+		{
+			score = (float)atof(row-&gt;getColumn(0).c_str());
+			previousScore = (float)atof(row-&gt;getColumn(1).c_str());
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return score;
+}
+
+/// Updates an URL's details.
+bool QueryHistory::updateItem(const string &amp;queryName, const string &amp;engineName, const string &amp;url,
+	const string &amp;title, const string &amp;extract, const string &amp;language, float score)
+{
+	bool success = false;
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;QueryHistory::updateItem: called on &quot; &lt;&lt; url &lt;&lt; endl;
+#endif
+	SQLiteResults *results = executeStatement(&quot;UPDATE QueryHistory SET PrevScore=Score, \
+		Score=%f, Date='%d', Title='%q', Extract='%q', Language='%q' \
+		WHERE QueryName='%q' AND EngineName='%q' AND Url='%q';&quot;,
+		score, time(NULL), title.c_str(), extract.c_str(), language.c_str(),
+		queryName.c_str(), engineName.c_str(), Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Gets the first max items for the given query, engine pair.
+bool QueryHistory::getItems(const string &amp;queryName, const string &amp;engineName,
+	unsigned int max, vector&lt;Result&gt; &amp;resultsList) const
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement(&quot;SELECT Url, Title, Extract, Language, Score \
+		FROM QueryHistory WHERE QueryName='%q' AND EngineName='%q' ORDER BY Score DESC \
+		LIMIT %u;&quot;, queryName.c_str(), engineName.c_str(), max);
+	if (results != NULL)
+	{
+		while (results-&gt;hasMoreRows() == true)
+		{
+			SQLiteRow *row = results-&gt;nextRow();
+			if (row == NULL)
+			{
+				break;
+			}
+
+			Result result(Url::unescapeUrl(row-&gt;getColumn(0)).c_str(),
+				row-&gt;getColumn(1),
+				row-&gt;getColumn(2),
+				row-&gt;getColumn(3),
+				(float)atof(row-&gt;getColumn(4).c_str()));
+			resultsList.push_back(result);
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Gets an item's extract.
+string QueryHistory::getItemExtract(const string &amp;queryName, const string &amp;engineName, const string &amp;url) const
+{
+	string extract;
+
+	SQLiteResults *results = executeStatement(&quot;SELECT Extract FROM QueryHistory \
+		WHERE QueryName='%q' AND EngineName='%q' AND Url='%q';&quot;,
+		queryName.c_str(), engineName.c_str(), Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row = results-&gt;nextRow();
+		if (row != NULL)
+		{
+			extract = row-&gt;getColumn(0);
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return extract;
+}
+
+/// Gets a query's last run time.
+string QueryHistory::getLastRun(const string &amp;queryName, const string &amp;engineName) const
+{
+	SQLiteResults *results = NULL;
+	string lastRun;
+
+	if (queryName.empty() == true)
+	{
+		return lastRun;
+	}
+
+	if (engineName.empty() == true)
+	{
+		results = executeStatement(&quot;SELECT MAX(Date) FROM QueryHistory \
+			WHERE QueryName='%q';&quot;, queryName.c_str());
+	}
+	else
+	{
+		results = executeStatement(&quot;SELECT MAX(Date) FROM QueryHistory \
+			WHERE QueryName='%q' AND EngineName='%q';&quot;,
+			queryName.c_str(), engineName.c_str());
+	}
+
+	if (results != NULL)
+	{
+		SQLiteRow *row = results-&gt;nextRow();
+		if (row != NULL)
+		{
+			int latestDate = atoi(row-&gt;getColumn(0).c_str());
+			if (latestDate &gt; 0)
+			{
+				lastRun = TimeConverter::toTimestamp((time_t)latestDate);
+			}
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return lastRun;
+}
+
+/// Deletes items.
+bool QueryHistory::deleteItems(const string &amp;name, bool isQueryName)
+{
+	SQLiteResults *results = NULL;
+
+	if (isQueryName == true)
+	{
+		results = executeStatement(&quot;DELETE FROM QueryHistory \
+			WHERE QueryName='%q';&quot;, name.c_str());
+	}
+	else
+	{
+		results = executeStatement(&quot;DELETE FROM QueryHistory \
+			WHERE EngineName='%q';&quot;, name.c_str());
+	}
+
+	if (results != NULL)
+	{
+		delete results;
+
+		return true;
+	}
+
+	return false;
+}

Added: trunk/SQL/QueryHistory.h
===================================================================
--- trunk/SQL/QueryHistory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/QueryHistory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,71 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _QUERY_HISTORY_H
+#define _QUERY_HISTORY_H
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+#include &quot;Result.h&quot;
+#include &quot;SQLiteBase.h&quot;
+
+using namespace std;
+
+class QueryHistory : public SQLiteBase
+{
+	public:
+		QueryHistory(const string &amp;database);
+		virtual ~QueryHistory();
+
+		/// Creates the QueryHistory table in the database.
+		static bool create(const string &amp;database);
+
+		/// Inserts an URL.
+		bool insertItem(const string &amp;queryName, const string &amp;engineName, const string &amp;url,
+			const string &amp;title, const string &amp;extract, const string &amp;language, float score);
+
+		/**
+		  * Checks if an URL is in the query's history.
+		  * If it is, it returns the current and previous scores; returns 0 if not found.
+		  */
+		float hasItem(const string &amp;queryName, const string &amp;engineName, const string &amp;url,
+			float &amp;previousScore) const;
+
+		/// Updates an URL's details.
+		bool updateItem(const string &amp;queryName, const string &amp;engineName, const string &amp;url,
+			const string &amp;title, const string &amp;extract, const string &amp;language, float score);
+
+		/// Gets the first max items for the given query, engine pair.
+		bool getItems(const string &amp;queryName, const string &amp;engineName,
+			unsigned int max, vector&lt;Result&gt; &amp;resultsList) const;
+
+		/// Gets an item's extract.
+		string getItemExtract(const string &amp;queryName, const string &amp;engineName, const string &amp;url) const;
+
+		/// Gets a query's last run time.
+		string getLastRun(const string &amp;queryName, const string &amp;engineName = &quot;&quot;) const;
+
+		/// Deletes items.
+		bool deleteItems(const string &amp;name, bool isQueryName);
+
+	private:
+		QueryHistory(const QueryHistory &amp;other);
+		QueryHistory &amp;operator=(const QueryHistory &amp;other);
+
+};
+
+#endif // _QUERY_HISTORY_H

Added: trunk/SQL/SQLiteBase.cpp
===================================================================
--- trunk/SQL/SQLiteBase.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/SQLiteBase.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,331 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;algorithm&gt;
+#include &lt;iostream&gt;
+
+#include &quot;SQLiteBase.h&quot;
+
+SQLiteRow::SQLiteRow(const vector&lt;string&gt; &amp;rowColumns, int nColumns) :
+	m_nColumns(nColumns)
+{
+	if (rowColumns.empty() == true)
+	{
+		m_nColumns = 0;
+	}
+	else
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;SQLiteRow::SQLiteRow: &quot; &lt;&lt; rowColumns.size() &lt;&lt; &quot; columns&quot; &lt;&lt; endl;
+#endif
+		m_columns.reserve(rowColumns.size());
+#if 0
+		// FIXME: why does this segfault in string::assign() ?
+		copy(rowColumns.begin(), rowColumns.end(), m_columns.begin());
+#else
+		for (vector&lt;string&gt;::const_iterator colIter = rowColumns.begin(); colIter != rowColumns.end(); ++colIter)
+		{
+			m_columns.push_back(*colIter);
+		}
+#endif
+	}
+}
+
+SQLiteRow::~SQLiteRow()
+{
+}
+
+int SQLiteRow::getColumnsCount(void) const
+{
+	return m_nColumns;
+}
+
+string SQLiteRow::getColumn(int nColumn) const
+{
+	if (nColumn &lt; m_nColumns)
+	{
+		vector&lt;string&gt;::const_iterator colIter = m_columns.begin();
+		for (unsigned int i = 0; (i &lt; m_nColumns) &amp;&amp; (colIter != m_columns.end()); ++i)
+		{
+			if (i == nColumn)
+			{
+				string column = *colIter;
+				return column;
+			}
+			++colIter;
+		}
+	}
+
+	return &quot;&quot;;
+}
+
+SQLiteResults::SQLiteResults(char **results, int nRows, int nColumns) :
+	m_results(results),
+	m_nRows(nRows),
+	m_nColumns(nColumns),
+	m_nCurrentRow(0)
+{
+	// Check we actually have results
+	if ((m_results == NULL) ||
+		(m_nRows &lt;= 0))
+	{
+		m_nRows = m_nColumns = m_nCurrentRow = 0;
+	}
+}
+
+SQLiteResults::~SQLiteResults()
+{
+	sqlite3_free_table(m_results);
+}
+
+bool SQLiteResults::hasMoreRows(void) const
+{
+	if ((m_nCurrentRow &gt;= 0) &amp;&amp;
+		(m_nCurrentRow &lt; m_nRows))
+	{
+		return true;
+	}
+
+	return false;
+}
+
+string SQLiteResults::getColumnName(int nColumn) const
+{
+	if (nColumn &lt; m_nColumns)
+	{
+		return m_results[nColumn];
+	}
+
+	return &quot;&quot;;
+}
+
+SQLiteRow *SQLiteResults::nextRow(void)
+{
+	if ((m_nCurrentRow &lt; 0) ||
+		(m_nCurrentRow &gt;= m_nRows))
+	{
+		return NULL;
+	}
+
+	// The very first row holds the column names
+	unsigned int firstIndex = (m_nCurrentRow  + 1) * m_nColumns;
+	unsigned int lastIndex = firstIndex + m_nColumns - 1;
+	vector&lt;string&gt; rowColumns;
+
+	for (unsigned int i = firstIndex; i &lt;= lastIndex; ++i)
+	{
+		if (m_results[i] == NULL)
+		{
+			rowColumns.push_back(&quot;&quot;);
+		}
+		else
+		{
+			rowColumns.push_back(m_results[i]);
+		}
+	}
+	++m_nCurrentRow;
+
+	return new SQLiteRow(rowColumns, m_nColumns);
+}
+
+bool SQLiteResults::reset(void)
+{
+	m_nCurrentRow = 0;
+
+	return true;
+}
+
+SQLiteBase::SQLiteBase(const string &amp;database) :
+	m_databaseName(&quot;&quot;)
+{
+	m_databaseName = database;
+}
+
+SQLiteBase::~SQLiteBase()
+{
+}
+
+bool SQLiteBase::check(const string &amp;database)
+{
+	struct stat dbStat;
+
+	// The specified path must be a file
+	if ((stat(database.c_str(), &amp;dbStat) != -1) &amp;&amp;
+		(!S_ISREG(dbStat.st_mode)))
+	{
+		// It exists, but it's not a file as expected
+		cerr &lt;&lt; &quot;SQLiteBase::check: &quot; &lt;&lt; database &lt;&lt; &quot; is not a file&quot; &lt;&lt; endl;
+		return false;
+	}
+
+	return true;
+}
+
+sqlite3 *SQLiteBase::open(const string &amp;database) const
+{
+	sqlite3 *pDatabase = NULL;
+
+	// Open the new database
+	if ((sqlite3_open(database.c_str(), &amp;pDatabase) != SQLITE_OK) ||
+		(pDatabase == NULL))
+	{
+		cerr &lt;&lt; &quot;SQLiteBase::open: couldn't open &quot; &lt;&lt; database &lt;&lt; endl;
+		pDatabase = NULL;
+	}
+#ifdef DEBUG
+	else cout &lt;&lt; &quot;SQLiteBase::open: opened &quot; &lt;&lt; database &lt;&lt; endl;
+#endif
+
+	return pDatabase;
+}
+
+void SQLiteBase::close(sqlite3 *pDatabase) const
+{
+	if (pDatabase != NULL)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;SQLiteBase::close: changed &quot; &lt;&lt; sqlite3_total_changes(pDatabase) &lt;&lt; &quot; rows&quot; &lt;&lt; endl;
+#endif
+		sqlite3_close(pDatabase);
+#ifdef DEBUG
+		cout &lt;&lt; &quot;SQLiteBase::close: closed database&quot; &lt;&lt; endl;
+#endif
+	}
+}
+
+bool SQLiteBase::executeSimpleStatement(const string &amp;sql) const
+{
+	char *errMsg = NULL;
+	bool success = true;
+
+	if (sql.empty() == true)
+	{
+		return false;
+	}
+
+	sqlite3 *pDatabase = open(m_databaseName);
+	if (pDatabase == NULL)
+	{
+		return false;
+	}
+
+	if (sqlite3_exec(pDatabase,
+		sql.c_str(), 
+		NULL, NULL, // No callback
+		&amp;errMsg) != SQLITE_OK)
+	{
+		if (errMsg != NULL)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;SQLiteBase::executeSimpleStatement: statement &lt;&quot; &lt;&lt; sql &lt;&lt; &quot;&gt; failed: &quot; &lt;&lt; errMsg &lt;&lt; endl;
+#endif
+			sqlite3_free(errMsg);
+		}
+
+		success = false;
+	}
+	close(pDatabase);
+
+	return success;
+}
+
+SQLiteResults *SQLiteBase::executeStatement(const char *sqlFormat, ...) const
+{
+	SQLiteResults *pResults = NULL;
+	const char *pzTail = NULL;
+#ifdef _USE_VSNPRINTF
+	char stringBuff[2048];
+#endif
+	va_list ap;
+
+	if (sqlFormat == NULL)
+	{
+		return NULL;
+	}
+
+	sqlite3 *pDatabase = open(m_databaseName);
+	if (pDatabase == NULL)
+	{
+		return NULL;
+	}
+
+	va_start(ap, sqlFormat);
+#ifdef _USE_VSNPRINTF
+	int numChars = vsnprintf(stringBuff, 2048, sqlFormat, ap);
+	if (numChars &lt;= 0)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;SQLiteBase::executeStatement: couldn't format statement&quot; &lt;&lt; endl;
+#endif
+		close(pDatabase);
+		return NULL;
+	}
+	if (numChars &gt;= 2048)
+	{
+		// Not enough space
+#ifdef DEBUG
+		cout &lt;&lt; &quot;SQLiteBase::executeStatement: not enough space (&quot; &lt;&lt; numChars &lt;&lt; &quot;)&quot; &lt;&lt; endl;
+#endif
+		close(pDatabase);
+		return NULL;
+	}
+	stringBuff[numChars] = '\0';
+#else
+	char *stringBuff = sqlite3_vmprintf(sqlFormat, ap);
+	if (stringBuff == NULL)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;SQLiteBase::executeStatement: couldn't format statement&quot; &lt;&lt; endl;
+#endif
+		close(pDatabase);
+		return NULL;
+	}
+#endif
+
+	char **results;
+	char *errMsg;
+	int nRows, nColumns;
+	if (sqlite3_get_table(pDatabase,
+			stringBuff,
+			&amp;results,
+			&amp;nRows,
+			&amp;nColumns,
+			&amp;errMsg) != SQLITE_OK)
+	{
+		if (errMsg != NULL)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;SQLiteBase::executeStatement: statement &lt;&quot; &lt;&lt; stringBuff &lt;&lt; &quot;&gt; failed: &quot; &lt;&lt; errMsg &lt;&lt; endl;
+#endif
+			sqlite3_free(errMsg);
+		}
+	}
+	else
+	{
+		pResults = new SQLiteResults(results, nRows, nColumns);
+	}
+	va_end(ap);
+#ifndef _USE_VSNPRINTF
+	sqlite3_free(stringBuff);
+#endif
+	close(pDatabase);
+
+	return pResults;
+}

Added: trunk/SQL/SQLiteBase.h
===================================================================
--- trunk/SQL/SQLiteBase.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/SQLiteBase.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,92 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _SQLITE_BASE_H
+#define _SQLITE_BASE_H
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+#include &lt;sqlite3.h&gt;
+
+using namespace std;
+
+class SQLiteRow
+{
+	public:
+		SQLiteRow(const vector&lt;string&gt; &amp;rowColumns, int nColumns);
+		virtual ~SQLiteRow();
+
+		int getColumnsCount(void) const;
+
+		string getColumn(int nColumn) const;
+
+	protected:
+		vector&lt;string&gt; m_columns;
+		int m_nColumns;
+
+};
+
+class SQLiteResults
+{
+	public:
+		SQLiteResults(char **results, int nRows, int nColumns);
+		virtual ~SQLiteResults();
+
+		bool hasMoreRows(void) const;
+
+		string getColumnName(int nColumn) const;
+
+		SQLiteRow *nextRow(void);
+
+		bool reset(void);
+
+	protected:
+		char **m_results;
+		int m_nRows;
+		int m_nColumns;
+		int m_nCurrentRow;
+
+	private:
+		SQLiteResults(const SQLiteResults &amp;other);
+		SQLiteResults &amp;operator=(const SQLiteResults &amp;other);
+
+};
+
+class SQLiteBase
+{
+	public:
+		SQLiteBase(const string &amp;database);
+		virtual ~SQLiteBase();
+
+		static bool check(const string &amp;database);
+
+		bool executeSimpleStatement(const string &amp;sql) const;
+		SQLiteResults *executeStatement(const char *sqlFormat, ...) const;
+
+	protected:
+		string m_databaseName;
+
+		sqlite3 *open(const string &amp;database) const;
+		void close(sqlite3 *pDatabase) const;
+
+	private:
+		SQLiteBase(const SQLiteBase &amp;other);
+		SQLiteBase &amp;operator=(const SQLiteBase &amp;other);
+
+};
+
+#endif // _SQLITE_BASE_H

Added: trunk/SQL/ViewHistory.cpp
===================================================================
--- trunk/SQL/ViewHistory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/ViewHistory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,120 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;Url.h&quot;
+#include &quot;ViewHistory.h&quot;
+
+ViewHistory::ViewHistory(const string &amp;database) :
+	SQLiteBase(database)
+{
+}
+
+ViewHistory::~ViewHistory()
+{
+}
+
+/// Creates the ViewHistory table in the database.
+bool ViewHistory::create(const string &amp;database)
+{
+	bool success = true;
+
+	// The specified path must be a file
+	if (SQLiteBase::check(database) == false)
+	{
+		return false;
+	}
+
+	SQLiteBase db(database);
+
+	// Does ViewHistory exist ?
+	if (db.executeSimpleStatement(&quot;SELECT * FROM ViewHistory LIMIT 1;&quot;) == false)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ViewHistory::create: ViewHistory doesn't exist&quot; &lt;&lt; endl;
+#endif
+		// Create the table
+		if (db.executeSimpleStatement(&quot;CREATE TABLE ViewHistory (Url VARCHAR(255) PRIMARY KEY, Status INT);&quot;) == false)
+		{
+			success = false;
+		}
+	}
+
+	return success;
+}
+
+/// Inserts an URL.
+bool ViewHistory::insertItem(const string &amp;url)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement(&quot;INSERT INTO ViewHistory \
+		VALUES('%q', '1');&quot;, Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Checks if an URL is in the history.
+bool ViewHistory::hasItem(const string &amp;url) const
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement(&quot;SELECT Url FROM ViewHistory WHERE Url='%q';&quot;,
+		Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row = results-&gt;nextRow();
+		if (row != NULL)
+		{
+			// If this returns anything, it's the URL we are looking for
+#ifdef DEBUG
+			cout &lt;&lt; &quot;ViewHistory::hasItem: URL &quot; &lt;&lt; row-&gt;getColumn(0) &lt;&lt; endl;
+#endif
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Deletes an URL.
+bool ViewHistory::deleteItem(const string &amp;url)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement(&quot;DELETE FROM ViewHistory \
+		WHERE Url='%q';&quot;, Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}

Added: trunk/SQL/ViewHistory.h
===================================================================
--- trunk/SQL/ViewHistory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/ViewHistory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,50 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _VIEW_HISTORY_H
+#define _VIEW_HISTORY_H
+
+#include &lt;string&gt;
+
+#include &quot;SQLiteBase.h&quot;
+
+using namespace std;
+
+class ViewHistory : public SQLiteBase
+{
+	public:
+		ViewHistory(const string &amp;database);
+		virtual ~ViewHistory();
+
+		/// Creates the ViewHistory table in the database.
+		static bool create(const string &amp;database);
+
+		/// Inserts an URL.
+		bool insertItem(const string &amp;url);
+
+		/// Checks if an URL is in the history.
+		bool hasItem(const string &amp;url) const;
+
+		/// Deletes an URL.
+		bool deleteItem(const string &amp;url);
+
+	private:
+		ViewHistory(const ViewHistory &amp;other);
+		ViewHistory &amp;operator=(const ViewHistory &amp;other);
+
+};
+
+#endif // _VIEW_HISTORY_H

Added: trunk/SQL/historytest.cpp
===================================================================
--- trunk/SQL/historytest.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/historytest.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,90 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+
+#include &quot;ActionHistory.h&quot;
+#include &quot;IndexHistory.h&quot;
+#include &quot;QueryHistory.h&quot;
+#include &quot;ViewHistory.h&quot;
+
+using namespace std;
+
+int main(int argc, char **argv)
+{
+	if (argc &lt; 3)
+	{
+		cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;database&gt; CREATE|CHECK=&lt;url&gt;|LISTACTIONS=&lt;max&gt;&quot; &lt;&lt; endl;
+		return EXIT_FAILURE;
+	}
+
+	if (strncmp(argv[2], &quot;CREATE&quot;, 6) == 0)
+	{
+		if ((ActionHistory::create(argv[1]) == true) &amp;&amp;
+			(IndexHistory::create(argv[1]) == true) &amp;&amp;
+			(QueryHistory::create(argv[1]) == true) &amp;&amp;
+			(ViewHistory::create(argv[1]) == true))
+		{
+			cout &lt;&lt; &quot;Created database &quot; &lt;&lt; argv[1] &lt;&lt; &quot; and its tables&quot; &lt;&lt; endl;
+		}
+		else
+		{
+			cout &lt;&lt; &quot;Couldn't create database &quot; &lt;&lt; argv[1] &lt;&lt; endl;
+		}
+	}
+	else if (strncmp(argv[2], &quot;CHECK=&quot;, 6) == 0)
+	{
+		IndexHistory history(argv[1]);
+
+		if (history.hasURL(argv[2] + 6) &gt; 0)
+		{
+			cout &lt;&lt; &quot;URL exists in IndexHistory&quot; &lt;&lt; endl;
+		}
+		else
+		{
+			cout &lt;&lt; &quot;URL doesn't exist in IndexHistory&quot; &lt;&lt; endl;
+		}
+	}
+	else if (strncmp(argv[2], &quot;LISTACTIONS=&quot;, 12) == 0)
+	{
+		ActionHistory actions(argv[1]);
+		SQLiteResults *results = actions.executeStatement(&quot;SELECT Option, Date FROM ActionHistory ORDER BY %s DESC LIMIT %s;&quot;, &quot;Date&quot;, argv[2] + 12);
+		if (results != NULL)
+		{
+			while (results-&gt;hasMoreRows() == true)
+			{
+				SQLiteRow *row = results-&gt;nextRow();
+				if (row == NULL)
+				{
+					break;
+				}
+
+				for (int i = 0; i &lt; row-&gt;getColumnsCount(); ++i)
+				{
+					cout &lt;&lt; results-&gt;getColumnName(i) &lt;&lt; &quot;: &quot; &lt;&lt; row-&gt;getColumn(i) &lt;&lt; endl;
+				}
+				delete row;
+			}
+			delete results;
+		}
+		else
+		{
+			cout &lt;&lt; &quot;Couldn't list actions in database &quot; &lt;&lt; argv[1] &lt;&lt; endl;
+		}
+	}
+
+	return EXIT_SUCCESS;
+}

Added: trunk/Search/Google/GoogleAPIEngine.cpp
===================================================================
--- trunk/Search/Google/GoogleAPIEngine.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Google/GoogleAPIEngine.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,134 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &quot;Url.h&quot;
+#include &quot;MIMEScanner.h&quot;
+
+#include &quot;GoogleAPIEngine.h&quot;
+#include &quot;GAPIGoogleSearchBindingProxy.h&quot;
+#include &quot;GAPI.nsmap&quot;
+
+using namespace GAPI;
+
+GoogleAPIEngine::GoogleAPIEngine() :
+	SearchEngineInterface()
+{
+	// SearchEngineInterface members
+	m_maxResultsCount = 10;
+}
+
+GoogleAPIEngine::~GoogleAPIEngine()
+{
+	m_resultsList.clear();
+}
+
+/// Retrieves the specified URL from the cache; NULL if error. Caller deletes.
+Document *GoogleAPIEngine::retrieveCachedUrl(const string &amp;url)
+{
+	GoogleSearchBinding soapProxy;
+	struct gapi1__doGetCachedPageResponse cacheOut;
+
+	if (soapProxy.gapi1__doGetCachedPage(m_key, url, cacheOut))
+	{
+		return NULL;
+	}
+
+	xsd__base64Binary base64Page = cacheOut.return_;
+	if ((base64Page.__ptr != NULL) &amp;&amp;
+		(base64Page. __size &gt; 0))
+	{
+		Url urlObj(url);
+
+		Document *pDoc = new Document(url, url, MIMEScanner::scanUrl(urlObj), &quot;&quot;);
+		pDoc-&gt;setData((const char*)base64Page.__ptr, (unsigned int)base64Page. __size);
+
+		return pDoc;
+	}
+	
+	return NULL;
+}
+
+/// Checks spelling.
+string GoogleAPIEngine::checkSpelling(const string &amp;text)
+{
+	GoogleSearchBinding soapProxy;
+	struct gapi1__doSpellingSuggestionResponse spellOut;
+
+	if (soapProxy.gapi1__doSpellingSuggestion(m_key, text, spellOut))
+	{
+		return &quot;&quot;;
+	}
+
+	return spellOut.return_;
+}
+
+//
+// Implementation of SearchEngineInterface
+//
+
+/// Runs a query; true if success.
+bool GoogleAPIEngine::runQuery(QueryProperties&amp; queryProps)
+{
+	string andTerms = queryProps.getAndWords();
+	string phrase = queryProps.getPhrase();
+
+	setHostNameFilter(queryProps.getHostNameFilter());
+	setFileNameFilter(queryProps.getFileNameFilter());
+
+	if (m_key.empty() == true)
+	{
+		return false;
+	}
+
+	// FIXME: find out how m_notWords and m_anyWords could be used
+	if (andTerms.empty() == true)
+	{
+		if (phrase.empty() == true)
+		{
+			return false;
+		}
+		// Use the phrase as search terms then...
+		andTerms = phrase;
+		phrase = &quot;&quot;;
+	}
+
+	GoogleSearchBinding soapProxy;
+	struct gapi1__doGoogleSearchResponse queryOut;
+
+	// No filter, no safe search
+	if (soapProxy.gapi1__doGoogleSearch(m_key, andTerms, 0, (m_maxResultsCount &gt; 10 ? 10 : m_maxResultsCount),
+		((phrase.empty() == false) ? true : false), phrase, false, &quot;&quot;, &quot;latin1&quot;, &quot;latin1&quot;, queryOut))
+	{
+		return false;
+	}
+
+	struct gapi1__GoogleSearchResult *searchResult = queryOut.return_;
+	float pseudoScore = 100;
+
+	for (int i = 0; i &lt; searchResult-&gt;resultElements-&gt;__size; i++)
+	{
+		struct gapi1__ResultElement *resultElement = searchResult-&gt;resultElements-&gt;__ptr[i];
+
+		string resultUrl(resultElement-&gt;URL);
+		if (processResult(resultUrl) == true)
+		{
+			m_resultsList.push_back(Result(resultUrl, resultElement-&gt;title, resultElement-&gt;snippet, &quot;&quot;, pseudoScore));
+			--pseudoScore;
+		}
+	}
+
+	return true;
+}


Property changes on: trunk/Search/Google/GoogleAPIEngine.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/Google/GoogleAPIEngine.h
===================================================================
--- trunk/Search/Google/GoogleAPIEngine.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Google/GoogleAPIEngine.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,48 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GOOGLE_API_ENGINE_H
+#define _GOOGLE_API_ENGINE_H
+
+#include &lt;string&gt;
+
+#include &quot;Document.h&quot;
+#include &quot;SearchEngineInterface.h&quot;
+
+using namespace std;
+
+class GoogleAPIEngine : public SearchEngineInterface
+{
+	public:
+		GoogleAPIEngine();
+		virtual ~GoogleAPIEngine();
+
+		/// Runs a query; true if success.
+		virtual bool runQuery(QueryProperties&amp; queryProps);
+
+		/// Retrieves the specified URL from the cache; NULL if error. Caller deletes.
+		Document *retrieveCachedUrl(const string &amp;url);
+
+		/// Checks spelling.
+		string checkSpelling(const string &amp;text);
+
+	private:
+		GoogleAPIEngine(const GoogleAPIEngine &amp;other);
+		GoogleAPIEngine &amp;operator=(const GoogleAPIEngine &amp;other);
+
+};
+
+#endif // _GOOGLE_API_ENGINE_H


Property changes on: trunk/Search/Google/GoogleAPIEngine.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/Google/GoogleSearch.h
===================================================================
--- trunk/Search/Google/GoogleSearch.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Google/GoogleSearch.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,224 @@
+namespace GAPI
+{
+/*  Web Services Definitions urn:GoogleSearch */
+
+/*  Modify this file to customize the generated data type declarations */
+
+/*
+
+**  The gSOAP WSDL parser for C and C++ 1.1.2
+**  Copyright (C) 2001-2004 Robert van Engelen, Genivia, Inc.
+**  All Rights Reserved. This product is provided &quot;as is&quot;, without any warranty.
+
+
+--------------------------------------------------------------------------------
+gSOAP XML Web services tools
+Copyright (C) 2001-2004, Robert van Engelen, Genivia, Inc. All Rights Reserved.
+
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
<A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">+engelen at genivia.com</A> / <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">engelen at acm.org</A>
+--------------------------------------------------------------------------------
+*/
+
+//gsoapopt w
+#import &quot;stl.h&quot;
+// built-in type &quot;xs:base64Binary&quot;:
+class xsd__base64Binary { unsigned char *__ptr; int __size; };
+
+/*
+To customize the names of the namespace prefixes generated by wsdl2h, modify
+the prefix names below and add the modified lines to typemap.dat to run wsdl2h:
+
+gapi1 = urn:GoogleSearch
+*/
+
+//gsoap gapi1 schema namespace:	urn:GoogleSearch
+
+// forward declarations
+class gapi1__GoogleSearchResult;
+class gapi1__ResultElement;
+class ResultElementArray;
+class DirectoryCategoryArray;
+class gapi1__DirectoryCategory;
+
+
+class gapi1__GoogleSearchResult
+{ public:
+    bool                                 documentFiltering             ;
+    std::string                          searchComments                ;
+    int                                  estimatedTotalResultsCount    ;
+    bool                                 estimateIsExact               ;
+    ResultElementArray*                  resultElements                ;
+    std::string                          searchQuery                   ;
+    int                                  startIndex                    ;
+    int                                  endIndex                      ;
+    std::string                          searchTips                    ;
+    DirectoryCategoryArray*              directoryCategories           ;
+    double                               searchTime                    ;
+    struct soap                         *soap                          ;
+};
+
+class gapi1__ResultElement
+{ public:
+    std::string                          summary                       ;
+    std::string                          URL                           ;
+    std::string                          snippet                       ;
+    std::string                          title                         ;
+    std::string                          cachedSize                    ;
+    bool                                 relatedInformationPresent     ;
+    std::string                          hostName                      ;
+    gapi1__DirectoryCategory*            directoryCategory             ;
+    std::string                          directoryTitle                ;
+    struct soap                         *soap                          ;
+};
+
+class gapi1__DirectoryCategory
+{ public:
+    std::string                          fullViewableName              ;
+    std::string                          specialEncoding               ;
+    struct soap                         *soap                          ;
+};
+
+// SOAP encoded array ResultElementArray
+class ResultElementArray
+{ public:
+    gapi1__ResultElement*               *__ptr                         ;
+    int                                  __size                        ;
+    struct soap                         *soap                          ;
+};
+
+// SOAP encoded array DirectoryCategoryArray
+class DirectoryCategoryArray
+{ public:
+    gapi1__DirectoryCategory*           *__ptr                         ;
+    int                                  __size                        ;
+    struct soap                         *soap                          ;
+};
+
+/* Service GoogleSearchBinding operations:
+
+  gapi1__doGetCachedPage
+  gapi1__doSpellingSuggestion
+  gapi1__doGoogleSearch
+
+*/
+
+//gsoap gapi1 service name:	GoogleSearchBinding 
+//gsoap gapi1 service type:	GoogleSearchPort 
+//gsoap gapi1 service port:	<A HREF="http://api.google.com/search/beta2">http://api.google.com/search/beta2</A> 
+//gsoap gapi1 service namespace:	urn:GoogleSearch 
+
+/* Service GoogleSearchBinding operation gapi1__doGetCachedPage
+
+  C stub function (defined in soapClient.c[pp]):
+  int soap_call_gapi1__doGetCachedPage(struct soap *soap,
+    NULL, (char *endpoint = NULL selects default endpoint for this operation)
+    NULL, (char *action = NULL selects default action for this operation)
+    std::string                         key,
+    std::string                         url,
+  struct gapi1__doGetCachedPageResponse {
+    xsd__base64Binary                   return_;
+  } &amp; );
+
+  C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
+  class GoogleSearchBinding;
+
+*/
+
+//gsoap gapi1 service method-style:	doGetCachedPage rpc
+//gsoap gapi1 service method-encoding:	doGetCachedPage <A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>
+//gsoap gapi1 service method-action:	doGetCachedPage urn:GoogleSearchAction
+int gapi1__doGetCachedPage(
+    std::string                         key,
+    std::string                         url,
+  struct gapi1__doGetCachedPageResponse {
+    xsd__base64Binary                   return_;
+  } &amp; );
+
+/* Service GoogleSearchBinding operation gapi1__doSpellingSuggestion
+
+  C stub function (defined in soapClient.c[pp]):
+  int soap_call_gapi1__doSpellingSuggestion(struct soap *soap,
+    NULL, (char *endpoint = NULL selects default endpoint for this operation)
+    NULL, (char *action = NULL selects default action for this operation)
+    std::string                         key,
+    std::string                         phrase,
+  struct gapi1__doSpellingSuggestionResponse {
+    std::string                         return_;
+  } &amp; );
+
+  C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
+  class GoogleSearchBinding;
+
+*/
+
+//gsoap gapi1 service method-style:	doSpellingSuggestion rpc
+//gsoap gapi1 service method-encoding:	doSpellingSuggestion <A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>
+//gsoap gapi1 service method-action:	doSpellingSuggestion urn:GoogleSearchAction
+int gapi1__doSpellingSuggestion(
+    std::string                         key,
+    std::string                         phrase,
+  struct gapi1__doSpellingSuggestionResponse {
+    std::string                         return_;
+  } &amp; );
+
+/* Service GoogleSearchBinding operation gapi1__doGoogleSearch
+
+  C stub function (defined in soapClient.c[pp]):
+  int soap_call_gapi1__doGoogleSearch(struct soap *soap,
+    NULL, (char *endpoint = NULL selects default endpoint for this operation)
+    NULL, (char *action = NULL selects default action for this operation)
+    std::string                         key,
+    std::string                         q,
+    int                                 start,
+    int                                 maxResults,
+    bool                                filter,
+    std::string                         restrict_,
+    bool                                safeSearch,
+    std::string                         lr,
+    std::string                         ie,
+    std::string                         oe,
+  struct gapi1__doGoogleSearchResponse {
+    gapi1__GoogleSearchResult*          return_;
+  } &amp; );
+
+  C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
+  class GoogleSearchBinding;
+
+*/
+
+//gsoap gapi1 service method-style:	doGoogleSearch rpc
+//gsoap gapi1 service method-encoding:	doGoogleSearch <A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>
+//gsoap gapi1 service method-action:	doGoogleSearch urn:GoogleSearchAction
+int gapi1__doGoogleSearch(
+    std::string                         key,
+    std::string                         q,
+    int                                 start,
+    int                                 maxResults,
+    bool                                filter,
+    std::string                         restrict_,
+    bool                                safeSearch,
+    std::string                         lr,
+    std::string                         ie,
+    std::string                         oe,
+  struct gapi1__doGoogleSearchResponse {
+    gapi1__GoogleSearchResult*          return_;
+  } &amp; );
+
+/*  End of Web Services Definitions urn:GoogleSearch */
+}


Property changes on: trunk/Search/Google/GoogleSearch.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/Google/Makefile
===================================================================
--- trunk/Search/Google/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Google/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,28 @@
+
+ROOT_DIR = ../..
+include ${ROOT_DIR}/variables.mk
+
+GAPI_SRCS = GAPIClientLib.cpp GoogleAPIEngine.cpp
+GAPI_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${GAPI_SRCS})
+
+targets : dirs ${GAPI_LIB}
+
+clean : clean-stubs
+	@rm -f ${OBJ_DIR}/* ${GAPI_LIB}
+
+clean-stubs:
+	@rm -f GAPI* ${OBJ_DIR}/GAPI* *.xml
+
+# Google API stuff
+
+GoogleSearch.h : googleapi/GoogleSearch.wsdl
+	${WSDLC} -n gapi -o GoogleSearch.h googleapi/GoogleSearch.wsdl
+
+GAPIClientLib.cpp : GoogleSearch.h
+	${SOAPC} -n -pGAPI GoogleSearch.h
+
+# Library
+
+${GAPI_LIB} : ${GAPI_OBJS}
+	@echo Building ${GAPI_LIB}
+	${AR} cr ${GAPI_LIB} ${GAPI_OBJS}


Property changes on: trunk/Search/Google/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/Makefile
===================================================================
--- trunk/Search/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,56 @@
+
+ROOT_DIR = ..
+include ${ROOT_DIR}/variables.mk
+
+SE_SRCS = PluginWebEngine.cpp QueryProperties.cpp SearchEngineFactory.cpp \
+	SearchEngineInterface.cpp WebEngine.cpp XapianEngine.cpp
+SE_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${SE_SRCS})
+ifeq (${NEEDS_SOAP},yes)
+SOAPENV_OBJS = ${OBJ_DIR}/stdsoap.o ${OBJ_DIR}/SOAPEnvNS.o ${OBJ_DIR}/SOAPEnvC.o
+else
+SOAPENV_OBJS = 
+endif
+SE_TEST = ${BIN_DIR}/senginetest
+
+targets : dirs ${SE_LIB} ${SOAPENV_LIB} ${SE_TEST}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${SE_LIB} ${SOAPENV_LIB} ${SE_TEST}
+
+# SOAP environment
+
+${OBJ_DIR}/stdsoap.o : ${GSOAP_HOME}/stdsoap2.cpp
+	${CXX} -o ${OBJ_DIR}/stdsoap.o -c ${GSOAP_HOME}/stdsoap2.cpp ${CXXFLAGS}
+
+${OBJ_DIR}/SOAPEnvNS.o : SOAPEnvNS.cpp
+	${CXX} -o ${OBJ_DIR}/SOAPEnvNS.o -c SOAPEnvNS.cpp ${CXXFLAGS}
+
+SOAPEnv.h :
+	# Create an empty file, we just want to get global functions
+	@touch SOAPEnv.h
+
+SOAPEnvC.cpp : SOAPEnv.h
+	${SOAPC} -pSOAPEnv SOAPEnv.h
+
+${OBJ_DIR}/SOAPEnvC.o : SOAPEnvC.cpp
+	${CXX} -o ${OBJ_DIR}/SOAPEnvC.o -c SOAPEnvC.cpp ${CXXFLAGS}
+
+# SearchEngine tester
+
+${SE_TEST} : ${OBJ_DIR}/senginetest.o ${SE_LIBS} ${DL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB}
+	@echo Building ${SE_TEST}
+	${LINK} -o $@ ${OBJ_DIR}/senginetest.o ${SE_LIBS} ${DL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS}
+	
+# Libraries
+
+${SE_LIB} : ${SE_OBJS}
+	@echo Building ${SE_LIB}
+	${AR} cr ${SE_LIB} ${SE_OBJS}
+
+${SOAPENV_LIB} : ${SOAPENV_OBJS}
+ifeq (${NEEDS_SOAP},yes)
+	@echo Building ${SOAPENV_LIB}
+	${AR} cr ${SOAPENV_LIB} ${SOAPENV_OBJS}
+else
+	@echo Not building ${SOAPENV_LIB}
+endif


Property changes on: trunk/Search/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/ObjectsSearch/Makefile
===================================================================
--- trunk/Search/ObjectsSearch/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/ObjectsSearch/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,28 @@
+
+ROOT_DIR = ../..
+include ${ROOT_DIR}/variables.mk
+
+OSAPI_SRCS = OSAPIClientLib.cpp ObjectsSearchAPIEngine.cpp
+OSAPI_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${OSAPI_SRCS})
+
+targets : dirs ${OSAPI_LIB}
+
+clean : clean-stubs
+	@rm -f ${OBJ_DIR}/* ${OSAPI_LIB}
+
+clean-stubs:
+	@rm -f OSAPI* ${OBJ_DIR}/OSAPI* *.xml
+
+# ObjectsSearch API stuff
+
+ObjectsSearch.h : ObjectsSearch.wsdl
+	${WSDLC} -n osapi -o ObjectsSearch.h ObjectsSearch.wsdl
+
+OSAPIClientLib.cpp : ObjectsSearch.h
+	${SOAPC} -n -pOSAPI ObjectsSearch.h
+
+# Library
+
+${OSAPI_LIB} : ${OSAPI_OBJS}
+	@echo Building ${OSAPI_LIB}
+	${AR} cr ${OSAPI_LIB} ${OSAPI_OBJS}

Added: trunk/Search/ObjectsSearch/ObjectsSearch.h
===================================================================
--- trunk/Search/ObjectsSearch/ObjectsSearch.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/ObjectsSearch/ObjectsSearch.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,123 @@
+namespace OSAPI
+{
+/*  Web Services Definitions  */
+
+/*  Modify this file to customize the generated data type declarations */
+
+/*
+
+**  The gSOAP WSDL parser for C and C++ 1.1.2
+**  Copyright (C) 2001-2004 Robert van Engelen, Genivia, Inc.
+**  All Rights Reserved. This product is provided &quot;as is&quot;, without any warranty.
+
+
+--------------------------------------------------------------------------------
+gSOAP XML Web services tools
+Copyright (C) 2001-2004, Robert van Engelen, Genivia, Inc. All Rights Reserved.
+
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
<A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">+engelen at genivia.com</A> / <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">engelen at acm.org</A>
+--------------------------------------------------------------------------------
+*/
+
+//gsoapopt w
+#import &quot;stl.h&quot;
+
+/*
+To customize the names of the namespace prefixes generated by wsdl2h, modify
+the prefix names below and add the modified lines to typemap.dat to run wsdl2h:
+
+osapi1 = urn:OS_Search
+*/
+
+//gsoap osapi1 schema namespace:	urn:OS_Search
+
+// forward declarations
+class osapi1__OS_USCORESearchResultElement;
+class ArrayOfOS_USCORESearchResultElement;
+class osapi1__OS_USCORESearchResult;
+
+
+class osapi1__OS_USCORESearchResultElement
+{ public:
+    std::string*                         URL                           ;//nillable
+    std::string*                         summary                       ;//nillable
+    std::string*                         title                         ;//nillable
+    struct soap                         *soap                          ;
+};
+
+class osapi1__OS_USCORESearchResult
+{ public:
+    ArrayOfOS_USCORESearchResultElement*  resultElements                ;//nillable
+    int                                  endIndex                      ;
+    int                                  startIndex                    ;
+    std::string*                         searchQuery                   ;//nillable
+    int                                  estimatedTotalResultsCount    ;
+    struct soap                         *soap                          ;
+};
+
+// SOAP encoded array ArrayOfOS_USCORESearchResultElement
+class ArrayOfOS_USCORESearchResultElement
+{ public:
+    osapi1__OS_USCORESearchResultElement* *__ptr                         ;
+    int                                  __size                        ;
+    struct soap                         *soap                          ;
+};
+
+/* Service betaSoapBinding operations:
+
+  osapi2__doSearch
+
+*/
+
+//gsoap osapi2 service name:	betaSoapBinding 
+//gsoap osapi2 service type:	beta 
+//gsoap osapi2 service port:	<A HREF="http://www.objectssearch.com/search/services/beta">http://www.objectssearch.com/search/services/beta</A> 
+//gsoap osapi2 service namespace:	<A HREF="http://www.objectssearch.com/search/services/beta">http://www.objectssearch.com/search/services/beta</A> 
+
+/* Service betaSoapBinding operation osapi2__doSearch
+
+  C stub function (defined in soapClient.c[pp]):
+  int soap_call_osapi2__doSearch(struct soap *soap,
+    NULL, (char *endpoint = NULL selects default endpoint for this operation)
+    NULL, (char *action = NULL selects default action for this operation)
+    std::string                         queryParameter,
+    int                                 startParameter,
+    int                                 hitsPerPageParameter,
+  struct osapi2__doSearchResponse {
+    osapi1__OS_USCORESearchResult*      doSearchReturn;
+  } &amp; );
+
+  C++ proxy class (defined in soapbetaSoapBindingProxy.h):
+  class betaSoapBinding;
+
+*/
+
+//gsoap osapi2 service method-style:	doSearch rpc
+//gsoap osapi2 service method-encoding:	doSearch <A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>
+//gsoap osapi2 service method-action:	doSearch &quot;&quot;
+int osapi2__doSearch(
+    std::string                         _queryParameter,
+    int                                 _startParameter,
+    int                                 _hitsPerPageParameter,
+  struct osapi2__doSearchResponse {
+    osapi1__OS_USCORESearchResult*      _doSearchReturn;
+  } &amp; );
+
+/*  End of Web Services Definitions  */
+}

Added: trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.cpp
===================================================================
--- trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,128 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+
+#include &quot;Url.h&quot;
+
+#include &quot;ObjectsSearchAPIEngine.h&quot;
+#include &quot;OSAPIbetaSoapBindingProxy.h&quot;
+#include &quot;OSAPI.nsmap&quot;
+
+using std::cout;
+using std::endl;
+using namespace OSAPI;
+
+ObjectsSearchAPIEngine::ObjectsSearchAPIEngine() :
+	SearchEngineInterface()
+{
+	// SearchEngineInterface members
+	m_maxResultsCount = 10;
+}
+
+ObjectsSearchAPIEngine::~ObjectsSearchAPIEngine()
+{
+	m_resultsList.clear();
+}
+
+bool ObjectsSearchAPIEngine::makeCall(const string &amp;query)
+{
+	if (query.empty() == true)
+	{
+		return false;
+	}
+
+	betaSoapBinding soapProxy;
+
+	struct osapi2__doSearchResponse searchResults;
+	searchResults._doSearchReturn = NULL;
+	cout &lt;&lt; &quot;ObjectsSearchAPIEngine::makeCall: query is &quot; &lt;&lt; query &lt;&lt; endl;
+
+	int status = soapProxy.osapi2__doSearch(query, 0, 10, searchResults);
+	cout &lt;&lt; &quot;ObjectsSearchAPIEngine::makeCall: doSearch returned &quot; &lt;&lt; status &lt;&lt; endl;
+	if (status == 0)
+	{
+		if (searchResults._doSearchReturn != NULL)
+		{
+			cout &lt;&lt; &quot;ObjectsSearchAPIEngine::makeCall: results !&quot; &lt;&lt; endl;
+
+			osapi1__OS_USCORESearchResult *pResult = searchResults._doSearchReturn;
+			unsigned int count = pResult-&gt;endIndex - pResult-&gt;startIndex;
+			cout &lt;&lt; &quot;ObjectsSearchAPIEngine::makeCall: &quot; &lt;&lt; count &lt;&lt; &quot; results out of &quot; &lt;&lt; pResult-&gt;estimatedTotalResultsCount &lt;&lt; endl;
+
+			if ((pResult-&gt;resultElements != NULL) &amp;&amp;
+				(pResult-&gt;resultElements-&gt;__size &gt; 0))
+			{
+				unsigned int numElements = (unsigned int)pResult-&gt;resultElements-&gt;__size;
+				float pseudoScore = 100;
+
+				cout &lt;&lt; &quot;ObjectsSearchAPIEngine::makeCall: array has &quot; &lt;&lt; numElements &lt;&lt; &quot; elements&quot; &lt;&lt; endl;
+				for (unsigned int currentElement = 0; currentElement &lt; numElements; ++currentElement)
+				{
+					osapi1__OS_USCORESearchResultElement *pElem = pResult-&gt;resultElements-&gt;__ptr[currentElement];
+
+					if (pElem != NULL)
+					{
+						cout &lt;&lt; &quot;ObjectsSearchAPIEngine::makeCall: found result&quot; &lt;&lt; endl;
+						cout &lt;&lt; &quot;ObjectsSearchAPIEngine::makeCall: &quot; &lt;&lt; *(pElem-&gt;URL) &lt;&lt; endl;
+						cout &lt;&lt; &quot;ObjectsSearchAPIEngine::makeCall: &quot; &lt;&lt; *(pElem-&gt;summary) &lt;&lt; endl;
+						cout &lt;&lt; &quot;ObjectsSearchAPIEngine::makeCall: &quot; &lt;&lt; *(pElem-&gt;title) &lt;&lt; endl;
+
+						string resultUrl(*(pElem-&gt;URL));
+						if (processResult(resultUrl) == true)
+						{
+							m_resultsList.push_back(Result(*(pElem-&gt;URL), *(pElem-&gt;title), *(pElem-&gt;summary), &quot;&quot;, pseudoScore));
+							--pseudoScore;
+						}
+					}
+				}
+			}
+		}
+		else cout &lt;&lt; &quot;ObjectsSearchAPIEngine::makeCall: no results !&quot; &lt;&lt; endl;
+	}
+
+	return true;
+}
+
+//
+// Implementation of SearchEngineInterface
+//
+
+/// Runs a query; true if success.
+bool ObjectsSearchAPIEngine::runQuery(QueryProperties&amp; queryProps)
+{
+	setHostNameFilter(queryProps.getHostNameFilter());
+	setFileNameFilter(queryProps.getFileNameFilter());
+
+	// See <A HREF="http://www.objectssearch.com/en/help.html">http://www.objectssearch.com/en/help.html</A> for a description of queries
+	string query = queryProps.getAndWords();
+	string phrase = queryProps.getPhrase();
+	if (phrase.empty() == false)
+	{
+		query += &quot; \&quot;&quot;;
+		query += phrase;
+		query += &quot;\&quot; &quot;;
+	}
+	string notWords = queryProps.getNotWords();
+	if (notWords.empty() == false)
+	{
+		query += &quot; -&quot;;
+		query += notWords;
+	}
+	// FIXME: not sure what to do about m_anyWords...
+
+	return makeCall(query);
+}

Added: trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.h
===================================================================
--- trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,44 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _OBJECTSSEARCH_API_ENGINE_H
+#define _OBJECTSSEARCH_API_ENGINE_H
+
+#include &lt;string&gt;
+
+#include &quot;SearchEngineInterface.h&quot;
+
+using namespace std;
+
+class ObjectsSearchAPIEngine : public SearchEngineInterface
+{
+	public:
+		ObjectsSearchAPIEngine();
+		virtual ~ObjectsSearchAPIEngine();
+
+		/// Runs a query; true if success.
+		virtual bool runQuery(QueryProperties&amp; queryProps);
+
+	protected:
+		bool makeCall(const string &amp;query);
+
+	private:
+		ObjectsSearchAPIEngine(const ObjectsSearchAPIEngine &amp;other);
+		ObjectsSearchAPIEngine &amp;operator=(const ObjectsSearchAPIEngine &amp;other);
+
+};
+
+#endif // _OBJECTSSEARCH_API_ENGINE_H

Added: trunk/Search/PluginWebEngine.cpp
===================================================================
--- trunk/Search/PluginWebEngine.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/PluginWebEngine.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,575 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;algorithm&gt;
+#include &lt;fstream&gt;
+#include &lt;iostream&gt;
+
+#include &quot;Document.h&quot;
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;PluginParser.h&quot;
+#include &quot;StringManip.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;FileCollector.h&quot;
+#include &quot;PluginWebEngine.h&quot;
+
+// A function object to lower case map keys with for_each()
+struct LowerAndCopy
+{
+	public:
+		LowerAndCopy(map&lt;string, string&gt; &amp;other) : m_other(other)
+		{
+		}
+
+		void operator()(map&lt;string, string&gt;::value_type &amp;p)
+		{
+			m_other[StringManip::toLowerCase(p.first)] = p.second;
+		}
+
+		map&lt;string, string&gt; &amp;m_other;
+
+};
+
+PluginWebEngine::PluginWebEngine(const string &amp;fileName) :
+	WebEngine()
+{
+	m_skipLocal = true;
+	m_nextFactor = 10;
+	m_nextBase = 0;
+	// SearchEngineInterface members
+	m_maxResultsCount = 10;
+
+	load(fileName);
+}
+
+PluginWebEngine::~PluginWebEngine()
+{
+}
+
+bool PluginWebEngine::load(const string &amp;fileName)
+{
+	if (fileName.empty() == true)
+	{
+		return false;
+	}
+
+	// Get the definition file
+	FileCollector fileCollect;
+	DocumentInfo docInfo(&quot;Plugin&quot;, string(&quot;<A HREF="file://">file://</A>&quot;) + fileName,
+		&quot;text/plain&quot;, &quot;&quot;);
+	Document *pPluginDoc = fileCollect.retrieveUrl(docInfo);
+	if (pPluginDoc == NULL)
+	{
+#ifdef DEBUG
+		cerr &lt;&lt; &quot;PluginWebEngine::load: couldn't load &quot; &lt;&lt; fileName &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	PluginParser parser(pPluginDoc);
+	if (parser.parse() == false)
+	{
+		delete pPluginDoc;
+
+		return false;
+	}
+	PluginProperties &amp;properties = parser.getProperties();
+
+	map&lt;string, string&gt; searchParams, interpretParams;
+
+	// Lower case these maps' keys
+	LowerAndCopy lowCopy1(searchParams);
+	for_each(properties.m_searchParams.begin(), properties.m_searchParams.end(), lowCopy1);
+	LowerAndCopy lowCopy2(interpretParams);
+	for_each(properties.m_interpretParams.begin(), properties.m_interpretParams.end(), lowCopy2);
+
+	map&lt;string, string&gt;::iterator mapIter = searchParams.find(&quot;name&quot;);
+	if (mapIter != searchParams.end())
+	{
+		m_name = mapIter-&gt;second;
+	}
+
+	mapIter = searchParams.find(&quot;action&quot;);
+	if (mapIter != searchParams.end())
+	{
+		m_baseUrl = mapIter-&gt;second;
+	}
+
+	mapIter = searchParams.find(&quot;routetype&quot;);
+	if (mapIter != searchParams.end())
+	{
+		m_channel = mapIter-&gt;second;
+	}
+
+	copy(properties.m_inputItems.begin(), properties.m_inputItems.end(), inserter(m_inputTags, m_inputTags.begin()));
+	if (properties.m_userInput.empty() == false)
+	{
+		// Remove the user input tag from the input tags map
+		mapIter = m_inputTags.find(properties.m_userInput);
+		if (mapIter != m_inputTags.end())
+		{
+			m_inputTags.erase(mapIter);
+		}
+		m_userInputTag = properties.m_userInput;
+	}
+
+	mapIter = interpretParams.find(&quot;resultliststart&quot;);
+	if (mapIter != interpretParams.end())
+	{
+		m_resultListStart = StringManip::replaceSubString(mapIter-&gt;second, &quot;\\n&quot;, &quot;\n&quot;);
+	}
+
+	mapIter = interpretParams.find(&quot;resultlistend&quot;);
+	if (mapIter != interpretParams.end())
+	{
+		m_resultListEnd = StringManip::replaceSubString(mapIter-&gt;second, &quot;\\n&quot;, &quot;\n&quot;);
+	}
+
+	mapIter = interpretParams.find(&quot;resultitemstart&quot;);
+	if (mapIter != interpretParams.end())
+	{
+		m_resultItemStart = StringManip::replaceSubString(mapIter-&gt;second, &quot;\\n&quot;, &quot;\n&quot;);
+	}
+
+	mapIter = interpretParams.find(&quot;resultitemend&quot;);
+	if (mapIter != interpretParams.end())
+	{
+		m_resultItemEnd = StringManip::replaceSubString(mapIter-&gt;second, &quot;\\n&quot;, &quot;\n&quot;);
+	}
+
+	mapIter = interpretParams.find(&quot;resulttitlestart&quot;);
+	if (mapIter != interpretParams.end())
+	{
+		m_resultTitleStart = mapIter-&gt;second;
+	}
+
+	mapIter = interpretParams.find(&quot;resulttitleend&quot;);
+	if (mapIter != interpretParams.end())
+	{
+		
+		m_resultTitleEnd = mapIter-&gt;second;
+	}
+
+	mapIter = interpretParams.find(&quot;resultlinkstart&quot;);
+	if (mapIter != interpretParams.end())
+	{
+		m_resultLinkStart = mapIter-&gt;second;
+	}
+
+	mapIter = interpretParams.find(&quot;resultlinkend&quot;);
+	if (mapIter != interpretParams.end())
+	{
+		m_resultLinkEnd = mapIter-&gt;second;
+	}
+
+	mapIter = interpretParams.find(&quot;resultextractstart&quot;);
+	if (mapIter != interpretParams.end())
+	{
+		m_resultExtractStart = mapIter-&gt;second;
+	}
+
+	mapIter = interpretParams.find(&quot;resultextractend&quot;);
+	if (mapIter != interpretParams.end())
+	{
+		m_resultExtractEnd = mapIter-&gt;second;
+	}
+
+	mapIter = interpretParams.find(&quot;skiplocal&quot;);
+	if (mapIter != interpretParams.end())
+	{
+		if (mapIter-&gt;second == &quot;false&quot;)
+		{
+			m_skipLocal = false;
+		}
+	}
+
+	m_nextTag = properties.m_nextInput;
+	// Here we differ from how Mozilla uses these parameters
+	// Normally, either factor or value is used, but we use value
+	// as the parameter's initial value
+	if (properties.m_nextFactor.empty() == false)
+	{
+		m_nextFactor = (unsigned int)atoi(properties.m_nextFactor.c_str());
+	}
+	if (properties.m_nextValue.empty() == false)
+	{
+		m_nextBase = (unsigned int)atoi(properties.m_nextValue.c_str());
+	}
+
+	delete pPluginDoc;
+
+	return true;
+}
+
+bool PluginWebEngine::getPage(const string &amp;formattedQuery)
+{
+	bool foundResult = false;
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;PluginWebEngine::getPage: getting &quot; &lt;&lt; formattedQuery &lt;&lt; endl;
+#endif
+	DocumentInfo docInfo(&quot;Results Page&quot;, formattedQuery,
+		&quot;text/html&quot;, &quot;&quot;);
+	Document *pUrlDoc = downloadPage(docInfo);
+	if (pUrlDoc == NULL)
+	{
+#ifdef DEBUG
+		cerr &lt;&lt; &quot;PluginWebEngine::getPage: couldn't download page &quot; &lt;&lt; formattedQuery &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	float pseudoScore = 100;
+	unsigned int urlContentLen;
+	const char *urlContent = pUrlDoc-&gt;getData(urlContentLen);
+	if ((urlContent == NULL) ||
+		(urlContentLen == 0))
+	{
+#ifdef DEBUG
+		cerr &lt;&lt; &quot;PluginWebEngine::getPage: downloaded empty page&quot; &lt;&lt; endl;
+#endif
+		delete pUrlDoc;
+		return false;
+	}
+#ifdef DEBUG
+	ofstream pageBackup(&quot;PluginWebEngine.html&quot;);
+	pageBackup.write(urlContent, urlContentLen);
+	pageBackup.close();
+#endif
+
+	// Extract the results list
+#ifdef DEBUG
+	cout &lt;&lt; &quot;PluginWebEngine::getPage: getting results list (&quot; &lt;&lt; m_resultListStart &lt;&lt; &quot;, &quot; &lt;&lt; m_resultListEnd &lt;&lt; &quot;)&quot; &lt;&lt; endl;
+#endif
+	string resultList = StringManip::extractField(urlContent, m_resultListStart, m_resultListEnd);
+	if (resultList.empty() == true)
+	{
+		resultList = string(urlContent, urlContentLen);
+	}
+
+	// Extract results
+	string::size_type endPos = 0;
+#ifdef DEBUG
+	cout &lt;&lt; &quot;PluginWebEngine::getPage: getting first result (&quot; &lt;&lt; m_resultItemStart &lt;&lt; &quot;, &quot; &lt;&lt; m_resultItemEnd &lt;&lt; &quot;)&quot; &lt;&lt; endl;
+#endif
+	string resultItem = StringManip::extractField(resultList, m_resultItemStart, m_resultItemEnd, endPos);
+	while ((resultItem.empty() == false) &amp;&amp;
+		(m_resultsList.size() &lt;= m_maxResultsCount))
+	{
+		string contentType, url, name, extract;
+
+#ifdef DEBUG
+		cout &lt;&lt; &quot;PluginWebEngine::getPage: candidate chunk \&quot;&quot; &lt;&lt; resultItem &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+#endif
+		contentType = pUrlDoc-&gt;getType();
+		if (strncasecmp(contentType.c_str(), &quot;text/html&quot;, 9) == 0)
+		{
+			Document chunkDoc(&quot;&quot;, &quot;&quot;, contentType, &quot;&quot;);
+			chunkDoc.setData(resultItem.c_str(), resultItem.length());
+			HtmlTokenizer chunkTokens(&amp;chunkDoc);
+			set&lt;Link&gt; &amp;chunkLinks = chunkTokens.getLinks();
+			unsigned int endOfFirstLink = 0, startOfSecondLink = 0, endOfSecondLink = 0, startOfThirdLink = 0;
+
+			// The result's URL and title should be given by the first link
+			for (set&lt;Link&gt;::iterator linkIter = chunkLinks.begin(); linkIter != chunkLinks.end(); ++linkIter)
+			{
+				if (linkIter-&gt;m_pos == 0)
+				{
+					url = linkIter-&gt;m_url;
+					name = linkIter-&gt;m_name;
+#ifdef DEBUG
+					cout &lt;&lt; &quot;PluginWebEngine::getPage: first link in chunk is &quot; &lt;&lt; url &lt;&lt; endl;
+#endif
+					endOfFirstLink = linkIter-&gt;m_close;
+				}
+				else if (linkIter-&gt;m_pos == 1)
+				{
+					startOfSecondLink = linkIter-&gt;m_open;
+					endOfSecondLink = linkIter-&gt;m_close;
+				}
+				else if (linkIter-&gt;m_pos == 2)
+				{
+					startOfThirdLink = linkIter-&gt;m_open;
+				}
+			}
+
+			// Chances are the extract is between the first two links
+			if (endOfFirstLink &gt; 0)
+			{
+				string extractWithMarkup1, extractWithMarkup2;
+				string extractCandidate1, extractCandidate2;
+
+				if (startOfSecondLink &gt; 0)
+				{
+					extractWithMarkup1 = resultItem.substr(endOfFirstLink, startOfSecondLink - endOfFirstLink);
+				}
+				else
+				{
+					extractWithMarkup1 = resultItem.substr(endOfFirstLink);
+				}
+				extractCandidate1 = HtmlTokenizer::stripTags(extractWithMarkup1);
+
+				// ... or between the second and third link :-)
+				if (endOfSecondLink &gt; 0)
+				{
+					if (startOfThirdLink &gt; 0)
+					{
+						extractWithMarkup2 = resultItem.substr(endOfSecondLink, startOfThirdLink - endOfSecondLink);
+					}
+					else
+					{
+						extractWithMarkup2 = resultItem.substr(endOfSecondLink);
+					}
+				}
+				extractCandidate2 = HtmlTokenizer::stripTags(extractWithMarkup2);
+
+				// It seems we can rely on length to determine which is the right one
+				if (extractCandidate1.length() &gt; extractCandidate2.length())
+				{
+					extract = extractCandidate1;
+				}
+				else
+				{
+					extract = extractCandidate2;
+				}
+#ifdef DEBUG
+				cout &lt;&lt; &quot;PluginWebEngine::getPage: extract is \&quot;&quot; &lt;&lt; extract &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
+#endif
+			}
+		}
+		else
+		{
+			// This is not HTML
+			// Use extended attributes
+			if ((m_resultTitleStart.empty() == false) &amp;&amp;
+				(m_resultTitleEnd.empty() == false))
+			{
+				name = StringManip::extractField(resultItem, m_resultTitleStart, m_resultTitleEnd);
+			}
+
+			if ((m_resultLinkStart.empty() == false) &amp;&amp;
+				(m_resultLinkEnd.empty() == false))
+			{
+				url = StringManip::extractField(resultItem, m_resultLinkStart, m_resultLinkEnd);
+			}
+
+			if ((m_resultExtractStart.empty() == false) &amp;&amp;
+				(m_resultExtractEnd.empty() == false))
+			{
+				extract = StringManip::extractField(resultItem, m_resultExtractStart, m_resultExtractEnd);
+			}
+		}
+
+		if (url.empty() == false)
+		{
+			Url urlObj(url);
+
+			// Is this URL relative to the search engine's domain ?
+			// FIXME: look for a interpret/baseurl tag, see <A HREF="https://bugzilla.mozilla.org/show_bug.cgi?id=65453">https://bugzilla.mozilla.org/show_bug.cgi?id=65453</A>
+			// FIXME: obey m_skipLocal
+			if (urlObj.getHost().empty() == true)
+			{
+				Url baseUrlObj(formattedQuery);
+
+				string tmpUrl = baseUrlObj.getProtocol();
+				tmpUrl += &quot;://&quot;;
+				tmpUrl += baseUrlObj.getHost();
+				if (url[0] != '/')
+				{
+					tmpUrl += &quot;/&quot;;
+				}
+				tmpUrl += url;
+				url = tmpUrl;
+			}
+
+			if (processResult(url) == true)
+			{
+				m_resultsList.push_back(Result(url, name, extract, &quot;&quot;, pseudoScore));
+			}
+			--pseudoScore;
+			foundResult = true;
+		}
+
+		// Next
+		endPos += m_resultItemEnd.length();
+		resultItem = StringManip::extractField(resultList, m_resultItemStart, m_resultItemEnd, endPos);
+	}
+	delete pUrlDoc;
+
+	return foundResult;
+}
+
+bool PluginWebEngine::getDetails(const string &amp;fileName, string &amp;name, string &amp;channel)
+{
+	if (fileName.empty() == true)
+	{
+		return false;
+	}
+
+	// Get the definition file
+	FileCollector fileCollect;
+	DocumentInfo docInfo(name, string(&quot;<A HREF="file://">file://</A>&quot;) + fileName,
+		&quot;text/plain&quot;, &quot;&quot;);
+	Document *pPluginDoc = fileCollect.retrieveUrl(docInfo);
+	if (pPluginDoc == NULL)
+	{
+#ifdef DEBUG
+		cerr &lt;&lt; &quot;PluginWebEngine::getDetails: couldn't load &quot; &lt;&lt; fileName &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	PluginParser parser(pPluginDoc);
+	if (parser.parse(true) == false)
+	{
+#ifdef DEBUG
+		cerr &lt;&lt; &quot;PluginWebEngine::getDetails: couldn't parse &quot; &lt;&lt; fileName &lt;&lt; endl;
+#endif
+		delete pPluginDoc;
+
+		return false;
+	}
+	PluginProperties &amp;properties = parser.getProperties();
+
+	map&lt;string, string&gt; searchParams;
+
+	LowerAndCopy lowCopy1(searchParams);
+	for_each(properties.m_searchParams.begin(), properties.m_searchParams.end(), lowCopy1);
+
+	map&lt;string, string&gt;::iterator mapIter = searchParams.find(&quot;name&quot;);
+	if (mapIter != searchParams.end())
+	{
+		name = mapIter-&gt;second;
+	}
+	mapIter = searchParams.find(&quot;routetype&quot;);
+	if (mapIter != searchParams.end())
+	{
+		channel = mapIter-&gt;second;
+	}
+
+	delete pPluginDoc;
+
+	return true;
+}
+
+//
+// Implementation of SearchEngineInterface
+//
+
+/// Runs a query; true if success.
+bool PluginWebEngine::runQuery(QueryProperties&amp; queryProps)
+{
+	string queryString = queryProps.toString(false);
+	unsigned int currentFactor = 0, count = 0;
+
+	m_resultsList.clear();
+
+	if (m_userInputTag.empty() == true)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;PluginWebEngine::runQuery: no user input tag&quot; &lt;&lt; endl;
+#endif
+		return false;
+	}
+	if (queryString.empty() == true)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;PluginWebEngine::runQuery: query is empty&quot; &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	string formattedQuery = m_baseUrl;
+	formattedQuery += &quot;?&quot;;
+	formattedQuery += m_userInputTag;
+	formattedQuery += &quot;=&quot;;
+	formattedQuery += queryString;
+	for (map&lt;string, string&gt;::iterator tagIter = m_inputTags.begin(); tagIter != m_inputTags.end(); ++tagIter)
+	{
+		formattedQuery += &quot;&amp;&quot;;
+		formattedQuery += tagIter-&gt;first;
+		formattedQuery += &quot;=&quot;;
+		formattedQuery += tagIter-&gt;second;
+	}
+
+	setHostNameFilter(queryProps.getHostNameFilter());
+	setFileNameFilter(queryProps.getFileNameFilter());
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;PluginWebEngine::runQuery: querying &quot; &lt;&lt; m_name &lt;&lt; endl;
+#endif
+	while (count &lt; m_maxResultsCount)
+	{
+		string pageQuery = formattedQuery;
+
+		if (m_nextTag.empty() == false)
+		{
+			char factorStr[64];
+
+			// Is the INPUTNEXT FACTOR set to zero ?
+			if (m_nextFactor == 0)
+			{
+				// Assume INPUTNEXT allows to specify a number of results
+				// Not sure if this is how Sherlock/Mozilla interpret this
+				pageQuery += &quot;&amp;&quot;;
+				pageQuery += m_nextTag;
+				pageQuery += &quot;=&quot;;
+				snprintf(factorStr, 64, &quot;%u&quot;, m_maxResultsCount);
+				pageQuery += factorStr;
+			}
+			else
+			{
+				pageQuery += &quot;&amp;&quot;;
+				pageQuery += m_nextTag;
+				pageQuery += &quot;=&quot;;
+				snprintf(factorStr, 64, &quot;%u&quot;, currentFactor + m_nextBase);
+				pageQuery += factorStr;
+			}
+		}
+
+		if (getPage(pageQuery) == false)
+		{
+			break;
+		}
+
+		if (m_nextFactor == 0)
+		{
+			// That one page should have all the results...
+#ifdef DEBUG
+			cout &lt;&lt; &quot;PluginWebEngine::runQuery: performed one off call&quot; &lt;&lt; endl;
+#endif
+			break;
+		}
+		else
+		{
+			if (m_resultsList.size() &lt; count + m_nextFactor)
+			{
+				// We got less than the maximum number of results per page
+				// so there's no point in requesting the next page
+#ifdef DEBUG
+				cout &lt;&lt; &quot;PluginWebEngine::runQuery: last page wasn't full&quot; &lt;&lt; endl;
+#endif
+				break;
+			}
+
+			// Increase factor
+			currentFactor += m_nextFactor;
+		}
+		count = m_resultsList.size();
+	}
+
+	return true;
+}

Added: trunk/Search/PluginWebEngine.h
===================================================================
--- trunk/Search/PluginWebEngine.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/PluginWebEngine.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,76 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XML_WEB_ENGINE_H
+#define _XML_WEB_ENGINE_H
+
+#include &lt;string&gt;
+#include &lt;set&gt;
+#include &lt;map&gt;
+
+#include &quot;WebEngine.h&quot;
+
+using namespace std;
+
+/**
+  * A class that implements the Sherlock search plugin standard.
+  * See <A HREF="http://developer.apple.com/technotes/tn/tn1141.html">http://developer.apple.com/technotes/tn/tn1141.html</A>
+  * and <A HREF="http://mycroft.mozdev.org/deepdocs/deepdocs.html">http://mycroft.mozdev.org/deepdocs/deepdocs.html</A>
+  */	  
+class PluginWebEngine : public WebEngine
+{
+	public:
+		PluginWebEngine(const string &amp;fileName);
+		virtual ~PluginWebEngine();
+
+		/// Utility method that returns a search plugin's name and channel.
+		static bool getDetails(const string &amp;fileName, string &amp;name, string &amp;channel);
+
+		/// Runs a query; true if success.
+		virtual bool runQuery(QueryProperties&amp; queryProps);
+
+	protected:
+		string m_name;
+		string m_baseUrl;
+		string m_channel;
+		map&lt;string, string&gt; m_inputTags;
+		string m_userInputTag;
+		string m_resultListStart;
+		string m_resultListEnd;
+		string m_resultItemStart;
+		string m_resultItemEnd;
+		string m_resultTitleStart;
+		string m_resultTitleEnd;
+		string m_resultLinkStart;
+		string m_resultLinkEnd;
+		string m_resultExtractStart;
+		string m_resultExtractEnd;
+		bool m_skipLocal;
+		string m_nextTag;
+		unsigned int m_nextFactor;
+		unsigned int m_nextBase;
+
+		bool load(const string &amp;fileName);
+
+		bool getPage(const string &amp;formattedQuery);
+
+	private:
+		PluginWebEngine(const PluginWebEngine &amp;other);
+		PluginWebEngine &amp;operator=(const PluginWebEngine &amp;other);
+
+};
+
+#endif // _XML_WEB_ENGINE_H

Added: trunk/Search/Plugins/A9.src
===================================================================
--- trunk/Search/Plugins/A9.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/A9.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,24 @@
+# A9 Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;A9&quot;
+	description=&quot;Amazon A9.com&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://a9.com/">http://a9.com/</A>&quot;
+	routeType=&quot;The Web&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;q&quot; USER&gt;
+&lt;INPUT NAME=&quot;p&quot; VALUE=&quot;0&quot;&gt;
+# The next line sets pw to 1 + results_count/10
+&lt;INPUTNEXT NAME=&quot;pw&quot; FACTOR=&quot;1&quot; VALUE=&quot;1&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=&quot;&quot;
+resultListEnd=&quot;&quot;
+resultItemStart='style=&quot;margin-bottom:'
+resultItemEnd='&lt;/div&gt;'
+&gt;
+
+&lt;/SEARCH&gt;

Added: trunk/Search/Plugins/Acoona.src
===================================================================
--- trunk/Search/Plugins/Acoona.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Acoona.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,31 @@
+# Acoona Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;Acoona&quot;
+	description=&quot;Acoona.com&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://www.accoona.com/search.jsp">http://www.accoona.com/search.jsp</A>&quot;
+	routeType=&quot;The Web&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;la&quot; VALUE=&quot;en&quot;&gt;
+&lt;INPUT NAME=&quot;col&quot; VALUE=&quot;&quot;&gt;
+&lt;INPUT NAME=&quot;qt&quot; USER&gt;
+&lt;INPUTNEXT NAME=&quot;st&quot; FACTOR=&quot;10&quot; VALUE=&quot;1&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=&quot;&quot;
+resultListEnd=&quot;&quot;
+resultItemStart='&lt;td class=&quot;webtitle&quot; valign=&quot;top&quot;&gt;'
+resultItemEnd='&lt;/span&gt; &lt;/td&gt;&lt;/tr&gt;'
+&gt;
+
+&lt;/SEARCH&gt;
+
+
+
+
+
+
+

Added: trunk/Search/Plugins/Altavista.src
===================================================================
--- trunk/Search/Plugins/Altavista.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Altavista.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,36 @@
+# Altavista Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;Altavista&quot;
+	description=&quot;Altavista.com&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://www.altavista.com/web/results">http://www.altavista.com/web/results</A>&quot;
+	routeType=&quot;The Web&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;pg&quot; VALUE=&quot;aq&quot;&gt;
+&lt;INPUT NAME=&quot;aqmode&quot; VALUE=&quot;s&quot;&gt;
+&lt;INPUT NAME=&quot;aqa&quot; USER&gt;
+&lt;INPUT NAME=&quot;aqb&quot; VALUE=&quot;&quot;&gt;
+&lt;INPUT NAME=&quot;kgs&quot; VALUE=&quot;1&quot;&gt;
+&lt;INPUT NAME=&quot;kls&quot; VALUE=&quot;0&quot;&gt;
+&lt;INPUT NAME=&quot;dt&quot; VALUE=&quot;tmperiod&quot;&gt;
+&lt;INPUT NAME=&quot;d2&quot; VALUE=&quot;0&quot;&gt;
+&lt;INPUT NAME=&quot;dfr%5Bd%5D&quot; VALUE=&quot;1&quot;&gt;
+&lt;INPUT NAME=&quot;dfr%5Bm%5D&quot; VALUE=&quot;1&quot;&gt;
+&lt;INPUT NAME=&quot;&amp;dfr%5By%5D&quot; VALUE=&quot;1980&quot;&gt;
+&lt;INPUT NAME=&quot;filetype&quot; VALUE=&quot;&quot;&gt;
+&lt;INPUT NAME=&quot;rc&quot; VALUE=&quot;dmn&quot;&gt;
+&lt;INPUT NAME=&quot;swd&quot; VALUE=&quot;&quot;&gt;
+&lt;INPUT NAME=&quot;lh&quot; VALUE=&quot;&quot;&gt;
+&lt;INPUTNEXT NAME=&quot;nbq&quot; FACTOR=&quot;0&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=&quot;&quot;
+resultListEnd=&quot;&quot;
+resultItemStart=&quot;&lt;br class='lb'&gt;&quot;
+resultItemEnd=&quot;&nbsp;&lt;br&gt;&lt;br&gt;&quot;
+&gt;
+
+&lt;/SEARCH&gt;

Added: trunk/Search/Plugins/AmazonAPI.src
===================================================================
--- trunk/Search/Plugins/AmazonAPI.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/AmazonAPI.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,35 @@
+# Amazon REST API Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;Amazon API&quot;
+	description=&quot;Amazon.com REST API&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://webservices.amazon.com/onca/xml">http://webservices.amazon.com/onca/xml</A>&quot;
+	routeType=&quot;Web Services&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;Service&quot; VALUE=&quot;AWSECommerceService&quot;&gt;
+# Edit this field's value to set to your subscription ID
+&lt;INPUT NAME=&quot;SubscriptionId&quot; VALUE=&quot;&quot;&gt;
+&lt;INPUT NAME=&quot;Operation&quot; VALUE=&quot;ItemSearch&quot;&gt;
+&lt;INPUT NAME=&quot;SearchIndex&quot; VALUE=&quot;Blended&quot;&gt;
+&lt;INPUT NAME=&quot;Keywords&quot; USER&gt;
+
+&lt;INTERPRET
+resultListStart=&quot;&lt;Items&gt;&quot;
+resultListEnd=&quot;&lt;/Items&gt;&quot;
+resultItemStart=&quot;&lt;Item&gt;&quot;
+resultItemEnd=&quot;&lt;/Item&gt;&quot;
+# The following attributes are specific to Pinot
+resultTitleStart=&quot;&lt;Title&gt;&quot;
+resultTitleEnd=&quot;&lt;/Title&gt;&quot;
+resultLinkStart=&quot;&lt;DetailPageURL&gt;&quot;
+resultLinkEnd=&quot;&lt;/DetailPageURL&gt;&quot;
+resultExtractStart=&quot;&lt;ProductGroup&gt;&quot;
+resultExtractEnd=&quot;&lt;/ProductGroup&gt;&quot;
+&gt;
+
+&lt;/SEARCH&gt;
+
+

Added: trunk/Search/Plugins/AskJeeves.src
===================================================================
--- trunk/Search/Plugins/AskJeeves.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/AskJeeves.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,24 @@
+# Ask Jeeves Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;Ask Jeeves&quot;
+	description=&quot;Ask.com Ask Jeeves&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://www.ask.com/web">http://www.ask.com/web</A>&quot;
+	routeType=&quot;The Web&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;q&quot; USER&gt;
+&lt;INPUT NAME=&quot;qsrc&quot; VALUE=&quot;0&quot;&gt;
+&lt;INPUT NAME=&quot;o&quot; VALUE=&quot;0&quot;&gt;
+&lt;INPUTNEXT NAME=&quot;page&quot; FACTOR=&quot;1&quot; VALUE=&quot;1&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=&quot;&quot;
+resultListEnd=&quot;&quot;
+resultItemStart='&lt;div class=&quot;m10_0_16&quot;&gt;'
+resultItemEnd='Save&lt;/a&gt;'
+&gt;
+
+&lt;/SEARCH&gt;

Added: trunk/Search/Plugins/BitTorrent.src
===================================================================
--- trunk/Search/Plugins/BitTorrent.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/BitTorrent.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,25 @@
+# BitTorrent Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;BitTorrent&quot;
+	description=&quot;bittorrent.com&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://search.bittorrent.com/search.jsp">http://search.bittorrent.com/search.jsp</A>&quot;
+	routeType=&quot;Media&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;hitsPerPage&quot; VALUE=&quot;10&quot;&gt;
+&lt;INPUT NAME=&quot;hitsPerSite&quot; VALUE=&quot;3&quot;&gt;
+&lt;INPUT NAME=&quot;query&quot; USER&gt;
+&lt;INPUT NAME=&quot;Submit2&quot; VALUE=&quot;Search&quot;&gt;
+&lt;INPUTNEXT NAME=&quot;start&quot; FACTOR=&quot;10&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=''
+resultListEnd=''
+resultItemStart='&lt;span class=&quot;titler&quot;&gt;'
+resultItemEnd='&lt;/span&gt;&lt;p&gt;&lt;p&gt;&lt;/div&gt;'
+&gt;
+
+&lt;/SEARCH&gt;

Added: trunk/Search/Plugins/Clusty.src
===================================================================
--- trunk/Search/Plugins/Clusty.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Clusty.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,22 @@
+# Clusty Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;Clusty&quot;
+	description=&quot;clusty.com&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://clusty.com/search">http://clusty.com/search</A>&quot;
+	routeType=&quot;The Web&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;query&quot; USER&gt;
+# INPUTNEXT is too complicated :-)
+
+&lt;INTERPRET
+resultListStart=&quot;&quot;
+resultListEnd=&quot;&quot;
+resultItemStart='&lt;li class=&quot;document&quot;&gt;'
+resultItemEnd='&lt;div class=&quot;document-footer&quot;&gt;'
+&gt;
+
+&lt;/SEARCH&gt;

Added: trunk/Search/Plugins/Freshmeat.src
===================================================================
--- trunk/Search/Plugins/Freshmeat.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Freshmeat.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,28 @@
+# Freshmeat Search Plugin
+# Based on the work of <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">rcoscali at rcsnet.net</A>
+
+&lt;search 
+   name=&quot;Freshmeat&quot;
+   description=&quot;Freshmeat Projects Search&quot;
+   method=&quot;GET&quot;
+   action=&quot;<A HREF="http://freshmeat.net/search/">http://freshmeat.net/search/</A>&quot;
+   update=&quot;<A HREF="http://www.rcsnet.net/mozilla/freshmeat.src">http://www.rcsnet.net/mozilla/freshmeat.src</A>&quot;
+   updateIcon=&quot;<A HREF="http://www.rcsnet.net/mozilla/freshmeat.gif">http://www.rcsnet.net/mozilla/freshmeat.gif</A>&quot;
+   updateCheckDays=7
+   routeType=&quot;Software&quot;
+&gt;
+
+&lt;input name=&quot;section&quot; value=&quot;projects&quot;&gt;
+&lt;input name=&quot;q&quot; user&gt;
+&lt;inputnext name=&quot;offset&quot; factor=&quot;25&quot;&gt;
+&lt;inputprev name=&quot;offset&quot; factor=&quot;25&quot;&gt;
+
+&lt;interpret 
+    browserResultType=&quot;result&quot; 
+    baseUrl=&quot;<A HREF="http://freshmeat.net">http://freshmeat.net</A>&quot;
+    resultListStart=&quot;&quot;
+    resultListEnd=&quot;&quot;
+    resultItemStart='&lt;td valign=&quot;top&quot;&gt;    &lt;b&gt;'
+    resultItemEnd='&lt;/small&gt;&lt;/b&gt;&lt;/td&gt;    &lt;/tr&gt;'
+&gt;
+&lt;/search&gt;

Added: trunk/Search/Plugins/Google.src
===================================================================
--- trunk/Search/Plugins/Google.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Google.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,30 @@
+# Mozilla/Google plugin based on <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">amitp+mozilla at google.com</A>'s
+
+&lt;search 
+   name=&quot;Google&quot;
+   description=&quot;Google Search&quot;
+   method=&quot;GET&quot;
+   action=&quot;<A HREF="http://www.google.com/search">http://www.google.com/search</A>&quot;
+   update=&quot;<A HREF="http://www.google.com/mozilla/google.src">http://www.google.com/mozilla/google.src</A>&quot;
+   updateCheckDays=1   
+   queryEncoding=&quot;utf-8&quot;
+   queryCharset=&quot;utf-8&quot;
+   routeType=&quot;The Web&quot;
+&gt;
+
+&lt;input name=&quot;q&quot; user&gt;
+&lt;input name=&quot;sourceid&quot; value=&quot;mozilla&quot;&gt;
+&lt;inputnext name=&quot;start&quot; factor=&quot;10&quot;&gt;
+&lt;inputprev name=&quot;start&quot; factor=&quot;10&quot;&gt;
+&lt;input name=&quot;ie&quot; value=&quot;utf-8&quot;&gt;
+&lt;input name=&quot;oe&quot; value=&quot;utf-8&quot;&gt;
+
+&lt;interpret 
+    browserResultType=&quot;result&quot; 
+    charset = &quot;UTF-8&quot;
+    resultListStart=&quot;&lt;!--a--&gt;&quot; 
+    resultListEnd=&quot;&lt;!--z--&gt;&quot; 
+    resultItemStart=&quot;&lt;!--m--&gt;&quot; 
+    resultItemEnd=&quot;&lt;!--n--&gt;&quot;
+&gt;
+&lt;/search&gt;

Added: trunk/Search/Plugins/Koders.src
===================================================================
--- trunk/Search/Plugins/Koders.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Koders.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,25 @@
+# Koders Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;Koders&quot;
+	description=&quot;Koders.com&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://koders.com/">http://koders.com/</A>&quot;
+	routeType=&quot;Source Code&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;s&quot; USER&gt;
+&lt;INPUT NAME=&quot;_%3Abtn&quot; VALUE=&quot;Search&quot;&gt;
+&lt;INPUT NAME=&quot;_%3Ala&quot; VALUE=&quot;*&quot;&gt;
+&lt;INPUT NAME=&quot;_%3Ali&quot; VALUE=&quot;*&quot;&gt;
+&lt;INPUTNEXT NAME=&quot;p&quot; FACTOR=&quot;1&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=&quot;&quot;
+resultListEnd=&quot;&quot;
+resultItemStart='class=&quot;results_header&quot;&gt;'
+resultItemEnd='&lt;/tr&gt;&lt;tr&gt;'
+&gt;
+
+&lt;/SEARCH&gt;

Added: trunk/Search/Plugins/Lycos.src
===================================================================
--- trunk/Search/Plugins/Lycos.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Lycos.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,27 @@
+# Lycos Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;Lycos&quot;
+	description=&quot;Lycos.com&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://search.lycos.com/default.asp">http://search.lycos.com/default.asp</A>&quot;
+	routeType=&quot;The Web&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;loc&quot; VALUE=&quot;searchbox&quot;&gt;
+&lt;INPUT NAME=&quot;tab&quot; VALUE=&quot;web&quot;&gt;
+&lt;INPUT NAME=&quot;adv&quot; VALUE=&quot;1&quot;&gt;
+&lt;INPUT NAME=&quot;wfc&quot; VALUE=&quot;3&quot;&gt;
+&lt;INPUT NAME=&quot;query&quot; USER&gt;
+&lt;INPUT NAME=&quot;adf&quot; VALUE=&quot;off&quot;&gt;
+&lt;INPUTNEXT NAME=&quot;first&quot; FACTOR=&quot;10&quot; VALUE=&quot;1&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=&quot;&quot;
+resultListEnd=&quot;&quot;
+resultItemStart=&quot;&lt;!-- IS --&gt;&quot;
+resultItemEnd=&quot;&lt;!-- /IS --&gt;&quot;
+&gt;
+
+&lt;/SEARCH&gt;

Added: trunk/Search/Plugins/MSN.src
===================================================================
--- trunk/Search/Plugins/MSN.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/MSN.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,25 @@
+# MSN Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;MSN&quot;
+	description=&quot;MSN Search&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://search.msn.com/results.aspx">http://search.msn.com/results.aspx</A>&quot;
+	routeType=&quot;The Web&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;q&quot; USER&gt;
+&lt;INPUT NAME=&quot;FORM&quot; VALUE=&quot;QBHP&quot;&gt;
+&lt;INPUT NAME=&quot;srch_type&quot; VALUE=&quot;0&quot;&gt;
+&lt;INPUT NAME=&quot;count&quot; VALUE=&quot;10&quot;&gt;
+&lt;INPUTNEXT NAME=&quot;first&quot; FACTOR=&quot;10&quot;&gt;
+
+&lt;INTERPRET
+resultListStart='&lt;h2&gt;Results&lt;/h2&gt;'
+resultListEnd='&lt;/html&gt;'
+resultItemStart='&gt;&lt;h3&gt;'
+resultItemEnd=' &lt;/ul&gt;&lt;/li&gt;'
+&gt;
+
+&lt;/SEARCH&gt;

Added: trunk/Search/Plugins/Omega.src
===================================================================
--- trunk/Search/Plugins/Omega.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Omega.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,35 @@
+# Xapian Omega Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;Xapian Omega&quot;
+	description=&quot;Xapian Omega&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://localhost/cgi-bin/omega">http://localhost/cgi-bin/omega</A>&quot;
+	routeType=&quot;Local Host&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;P&quot; USER&gt;
+&lt;INPUT NAME=&quot;DEFAULTOP&quot; VALUE=&quot;or&quot;&gt;
+&lt;INPUT NAME=&quot;DB&quot; VALUE=&quot;default&quot;&gt;
+&lt;INPUT NAME=&quot;FMT&quot; VALUE=&quot;query&quot;&gt;
+&lt;INPUT NAME=&quot;FILTERS&quot; VALUE=&quot;--O&quot;&gt;
+&lt;INPUTNEXT NAME=&quot;%5B&quot; FACTOR=&quot;1&quot; VALUE=&quot;1&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=&quot;&lt;hits&gt;&quot;
+resultListEnd=&quot;&lt;/hits&gt;&quot;
+resultItemStart=&quot;&lt;TD VALIGN=top&gt;&quot;
+resultItemEnd=&quot;&lt;/small&gt;&lt;P&gt;&lt;/TD&gt;&quot;
+# The following attributes are specific to Pinot
+#resultTitleStart='title=&quot;'
+#resultTitleEnd='&quot;'
+#resultLinkStart='url=&quot;'
+#resultLinkEnd='&quot;'
+#resultExtractStart='sample=&quot;'
+#resultExtractEnd='&quot;'
+&gt;
+
+&lt;/SEARCH&gt;
+
+

Added: trunk/Search/Plugins/Teoma.src
===================================================================
--- trunk/Search/Plugins/Teoma.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Teoma.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,27 @@
+# Teoma Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;Teoma&quot;
+	description=&quot;Teoma.com&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://s.teoma.com/search">http://s.teoma.com/search</A>&quot;
+	routeType=&quot;The Web&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;q&quot; USER&gt;
+&lt;INPUT NAME=&quot;qcat&quot; VALUE=&quot;1&quot;&gt;
+&lt;INPUT NAME=&quot;qsrc&quot; VALUE=&quot;0&quot;&gt;
+&lt;INPUT NAME=&quot;Search.x&quot; VALUE=&quot;45&quot;&gt;
+&lt;INPUT NAME=&quot;Search.y&quot; VALUE=&quot;13&quot;&gt;
+&lt;INPUT NAME=&quot;Search&quot; VALUE=&quot;submitve_vt&quot;&gt;
+&lt;INPUTNEXT NAME=&quot;page&quot; FACTOR=&quot;1&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=''
+resultListEnd=''
+resultItemStart='&lt;div id=&quot;result&quot;&gt;'
+resultItemEnd='&lt;br class=&quot;resultSpace&quot; /&gt;'
+&gt;
+
+&lt;/SEARCH&gt;

Added: trunk/Search/Plugins/Topix.src
===================================================================
--- trunk/Search/Plugins/Topix.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Topix.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,23 @@
+# Topix Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;Topix&quot;
+	description=&quot;Topix.net&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://www.topix.net/search/advanced">http://www.topix.net/search/advanced</A>&quot;
+	routeType=&quot;News&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;q&quot; USER&gt;
+&lt;INPUT NAME=&quot;n&quot; VALUE=&quot;search&quot;&gt;
+&lt;INPUTNEXT NAME=&quot;start&quot; FACTOR=&quot;1&quot; VALUE=&quot;0&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=&quot;&quot;
+resultListEnd=&quot;&quot;
+resultItemStart='&lt;div class=searchres&gt;'
+resultItemEnd='&lt;/div&gt; &lt;/div&gt;'
+&gt;
+
+&lt;/SEARCH&gt;

Added: trunk/Search/Plugins/Wikipedia.src
===================================================================
--- trunk/Search/Plugins/Wikipedia.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Wikipedia.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,24 @@
+# Wikipedia Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;Wikipedia&quot;
+	description=&quot;wikipedia.com&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://en.wikipedia.org/wiki/Special:Search">http://en.wikipedia.org/wiki/Special:Search</A>&quot;
+	routeType=&quot;Encyclopedia&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;search&quot; USER&gt;
+&lt;INPUT NAME=&quot;fulltext&quot; VALUE=&quot;Search&quot;&gt;
+&lt;INPUT NAME=&quot;limit&quot; VALUE=&quot;10&quot;&gt;
+&lt;INPUTNEXT NAME=&quot;offset&quot; FACTOR=&quot;1&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=&quot;&quot;
+resultListEnd=&quot;&quot;
+resultItemStart='&lt;li style=&quot;padding-bottom: 1em;&quot;&gt;'
+resultItemEnd='&lt;/span&gt;&lt;/li&gt;'
+&gt;
+
+&lt;/SEARCH&gt;

Added: trunk/Search/Plugins/WiseNut.src
===================================================================
--- trunk/Search/Plugins/WiseNut.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/WiseNut.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,23 @@
+# WiseNut Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;WiseNut&quot;
+	description=&quot;WiseNut.com&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://www.wisenut.com/search/query.dll">http://www.wisenut.com/search/query.dll</A>&quot;
+	routeType=&quot;The Web&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;q&quot; USER&gt;
+&lt;INPUT NAME=&quot;c&quot; VALUE=&quot;10&quot;&gt;
+&lt;INPUTNEXT NAME=&quot;p&quot; FACTOR=&quot;1&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=&quot;&quot;
+resultListEnd=&quot;&quot;
+resultItemStart=&quot;&lt;TD class=m1&gt; &lt;b&gt;&quot;
+resultItemEnd=&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;
+&gt;
+
+&lt;/SEARCH&gt;

Added: trunk/Search/Plugins/Yahoo.src
===================================================================
--- trunk/Search/Plugins/Yahoo.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Yahoo.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,31 @@
+# Yahoo! Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;Yahoo!&quot;
+	description=&quot;Yahoo.com&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://search.yahoo.com/search">http://search.yahoo.com/search</A>&quot;
+	routeType=&quot;The Web&quot;
+&gt;
+
+&lt;INPUT NAME=&quot;x&quot; VALUE=&quot;op&quot;&gt;
+&lt;INPUT NAME=&quot;va&quot; USER&gt;
+&lt;INPUT NAME=&quot;ve_vt&quot; VALUE=&quot;any&quot;&gt;
+&lt;INPUT NAME=&quot;vst&quot; VALUE=&quot;0&quot;&gt;
+&lt;INPUT NAME=&quot;vd&quot; VALUE=&quot;all&quot;&gt;
+&lt;INPUT NAME=&quot;fl&quot; VALUE=&quot;0&quot;&gt;
+&lt;INPUT NAME=&quot;vf&quot; VALUE=&quot;all&quot;&gt;
+&lt;INPUT NAME=&quot;ei&quot; VALUE=&quot;ISO-8859-1&quot;&gt;
+&lt;INPUT NAME=&quot;vm&quot; VALUE=&quot;p&quot;&gt;
+&lt;INPUT NAME=&quot;n&quot; VALUE=&quot;10&quot;&gt;
+&lt;INPUTNEXT NAME=&quot;b&quot; FACTOR=&quot;10&quot; VALUE=&quot;1&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=&quot;&quot;
+resultListEnd=&quot;&quot;
+resultItemStart=&quot;&lt;li&gt;&lt;div&gt;&quot;
+resultItemEnd=&quot;&lt;/em&gt; &quot;
+&gt;
+
+&lt;/SEARCH&gt;

Added: trunk/Search/Plugins/YahooAPI.src
===================================================================
--- trunk/Search/Plugins/YahooAPI.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/YahooAPI.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,33 @@
+# Yahoo! REST API Search Plugin
+
+&lt;SEARCH
+	version=&quot;1.0&quot;
+	name=&quot;Yahoo! API&quot;
+	description=&quot;Yahoo! REST API&quot;
+	method=&quot;GET&quot;
+	action=&quot;<A HREF="http://api.search.yahoo.com/WebSearchService/V1/webSearch">http://api.search.yahoo.com/WebSearchService/V1/webSearch</A>&quot;
+	routeType=&quot;Web Services&quot;
+&gt;
+
+# Edit this field's value to set to your application ID
+&lt;INPUT NAME=&quot;appid&quot; VALUE=&quot;YahooDemo&quot;&gt;
+&lt;INPUT NAME=&quot;query&quot; USER&gt;
+&lt;INPUT NAME=&quot;results&quot; VALUE=&quot;10&quot;&gt;
+
+&lt;INTERPRET
+resultListStart=&quot;&lt;ResultSet&quot;
+resultListEnd=&quot;&lt;/ResultSet&gt;&quot;
+resultItemStart=&quot;&lt;Result&gt;&quot;
+resultItemEnd=&quot;&lt;/Result&gt;&quot;
+# The following attributes are specific to Pinot
+resultTitleStart=&quot;&lt;Title&gt;&quot;
+resultTitleEnd=&quot;&lt;/Title&gt;&quot;
+resultLinkStart=&quot;&lt;Url&gt;&quot;
+resultLinkEnd=&quot;&lt;/Url&gt;&quot;
+resultExtractStart=&quot;&lt;Summary&gt;&quot;
+resultExtractEnd=&quot;&lt;/Summary&gt;&quot;
+&gt;
+
+&lt;/SEARCH&gt;
+
+

Added: trunk/Search/QueryProperties.cpp
===================================================================
--- trunk/Search/QueryProperties.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/QueryProperties.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,302 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+#include &lt;algorithm&gt;
+
+#include &quot;QueryProperties.h&quot;
+
+QueryProperties::QueryProperties()
+{
+	m_resultsCount = 10;
+	m_indexResults = false;
+}
+
+QueryProperties::QueryProperties(string name, string andWords, string phrase, string anyWords, string notWords)
+{
+	m_name = name;
+	m_andWords = andWords;
+	m_phrase = phrase;
+	m_anyWords = anyWords;
+	m_notWords = notWords;
+	m_resultsCount = 10;
+	m_indexResults = false;
+}
+
+QueryProperties::QueryProperties(const QueryProperties &amp;other) :
+	m_name(other.m_name),
+	m_andWords(other.m_andWords),
+	m_phrase(other.m_phrase),
+	m_anyWords(other.m_anyWords),
+	m_notWords(other.m_notWords),
+	m_language(other.m_language),
+	m_hostName(other.m_hostName),
+	m_fileName(other.m_fileName),
+	m_resultsCount(other.m_resultsCount),
+	m_indexResults(other.m_indexResults),
+	m_labelName(other.m_labelName)
+{
+}
+
+QueryProperties::~QueryProperties()
+{
+}
+
+QueryProperties &amp;QueryProperties::operator=(const QueryProperties &amp;other)
+{
+	m_name = other.m_name;
+	m_andWords = other.m_andWords;
+	m_phrase = other.m_phrase;
+	m_anyWords = other.m_anyWords;
+	m_notWords = other.m_notWords;
+	m_language = other.m_language;
+	m_hostName = other.m_hostName;
+	m_fileName = other.m_fileName;
+	m_resultsCount = other.m_resultsCount;
+	m_indexResults = other.m_indexResults;
+	m_labelName = other.m_labelName;
+
+	return *this;
+}
+
+bool QueryProperties::operator==(const QueryProperties &amp;other) const
+{
+	if (m_name == other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+bool QueryProperties::operator&lt;(const QueryProperties &amp;other) const
+{
+	if (m_name &lt; other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+/// Sets the name.
+void QueryProperties::setName(const string &amp;name)
+{
+	m_name = name;
+}
+
+/// Gets the name.
+string QueryProperties::getName(void) const
+{
+	return m_name;
+}
+
+/// Sets AND words.
+void QueryProperties::setAndWords(const string &amp;words)
+{
+	m_andWords = words;
+}
+
+/// Gets AND words.
+string QueryProperties::getAndWords(void) const
+{
+	return m_andWords;
+}
+
+/// Sets phrase query.
+void QueryProperties::setPhrase(const string &amp;phrase)
+{
+	m_phrase = phrase;
+}
+
+/// Gets phrase query.
+string QueryProperties::getPhrase(void) const
+{
+	return m_phrase;
+}
+
+/// Sets ANY words.
+void QueryProperties::setAnyWords(const string &amp;words)
+{
+	m_anyWords = words;
+}
+
+/// Gets ANY words.
+string QueryProperties::getAnyWords(void) const
+{
+	return m_anyWords;
+}
+
+/// Sets NOT words.
+void QueryProperties::setNotWords(const string &amp;words)
+{
+	m_notWords = words;
+}
+
+/// Gets NOT words.
+string QueryProperties::getNotWords(void) const
+{
+	return m_notWords;
+}
+
+/// Sets the query's language.
+void QueryProperties::setLanguage(const string &amp;language)
+{
+	m_language = language;
+}
+
+/// Gets the query's language.
+string QueryProperties::getLanguage(void) const
+{
+	return m_language;
+}
+
+/// Sets host name filter.
+void QueryProperties::setHostNameFilter(const string &amp;filter)
+{
+	m_hostName = filter;
+}
+
+/// Gets host name filter.
+string QueryProperties::getHostNameFilter(void) const
+{
+	return 	m_hostName;
+}
+
+/// Sets file name filter.
+void QueryProperties::setFileNameFilter(const string &amp;filter)
+{
+	m_fileName = filter;
+}
+
+/// Gets file name filter.
+string QueryProperties::getFileNameFilter(void) const
+{
+	return m_fileName;
+}
+
+/// Sets the maximum number of results.
+void QueryProperties::setMaximumResultsCount(unsigned int count)
+{
+	m_resultsCount = count;
+}
+
+/// Gets the maximum number of results.
+unsigned int QueryProperties::getMaximumResultsCount(void) const
+{
+	return m_resultsCount;
+}
+
+/// Sets whether results should be indexed.
+void QueryProperties::setIndexResults(bool index)
+{
+	m_indexResults = index;
+}
+
+/// Gets whether results should be indexed
+bool QueryProperties::getIndexResults(void) const
+{
+	return m_indexResults;
+}
+
+/// Sets the name of the label to use for indexed documents.
+void QueryProperties::setLabelName(const string &amp;labelName)
+{
+	m_labelName = labelName;
+}
+
+/// Gets the name of the label to use for indexed documents.
+string QueryProperties::getLabelName(void) const
+{
+	return m_labelName;
+}
+
+/// Returns a displayable representation of this query's properties.
+string QueryProperties::toString(bool forPresentation) const
+{
+	string queryString;
+	if (m_andWords.empty() == false)
+	{
+		string tmp = m_andWords;
+		replace(tmp.begin(), tmp.end(), ' ', '+');
+		queryString += tmp;
+	}
+	if (m_anyWords.empty() == false)
+	{
+		if (forPresentation == true)
+		{
+			string tmp = m_anyWords;
+			replace(tmp.begin(), tmp.end(), ' ', '|');
+			queryString += &quot; +(&quot;;
+			queryString += tmp;
+			queryString += &quot;)&quot;;
+		}
+		else
+		{
+			string tmp = m_anyWords;
+			// FIXME: is this good enough ?
+			replace(tmp.begin(), tmp.end(), ' ', '+');
+			if (queryString.empty() == false)
+			{
+				queryString += &quot;+&quot;;
+			}
+			queryString += tmp;
+		}
+	}
+	if (m_notWords.empty() == false)
+	{
+		string tmp = m_notWords;
+		replace(tmp.begin(), tmp.end(), ' ', '-');
+		if (queryString.empty() == false)
+		{
+			queryString += &quot;-&quot;;
+		}
+		queryString += tmp;
+		queryString += &quot; &quot;;
+	}
+	if (m_phrase.empty() == false)
+	{
+		string tmp = m_phrase;
+		replace(tmp.begin(), tmp.end(), ' ', '+');
+		if (queryString.empty() == false)
+		{
+			queryString += &quot;+&quot;;
+		}
+		queryString += &quot;\&quot;&quot;;
+		queryString += tmp;
+		queryString += &quot;\&quot;&quot;;
+	}
+	if (forPresentation == true)
+	{
+		if (m_language.empty() == false)
+		{
+			queryString += &quot; +L&quot;;
+			queryString += m_language;
+		}
+		if (m_hostName.empty() == false)
+		{
+			queryString += &quot; +H&quot;;
+			queryString += m_hostName;
+		}
+		if (m_fileName.empty() == false)
+		{
+			queryString += &quot; +F&quot;;
+			queryString += m_fileName;
+		}
+	}
+
+	return queryString;
+}

Added: trunk/Search/QueryProperties.h
===================================================================
--- trunk/Search/QueryProperties.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/QueryProperties.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,111 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _QUERY_PROPERTIES_H
+#define _QUERY_PROPERTIES_H
+
+#include &lt;string&gt;
+
+#include &quot;Result.h&quot;
+
+using namespace std;
+
+class QueryProperties
+{
+	public:
+		QueryProperties();
+		QueryProperties(string name, string andWords, string phrase, string anyWords, string notWords);
+		QueryProperties(const QueryProperties &amp;other);
+		~QueryProperties();
+
+		QueryProperties &amp;operator=(const QueryProperties &amp;other);
+		bool operator==(const QueryProperties &amp;other) const;
+		bool operator&lt;(const QueryProperties &amp;other) const;
+
+		/// Sets the name.
+		void setName(const string &amp;name);
+		/// Gets the name.
+		string getName(void) const;
+
+		/// Sets AND words.
+		void setAndWords(const string &amp;words);
+		/// Gets AND words.
+		string getAndWords(void) const;
+
+		/// Sets phrase query.
+		void setPhrase(const string &amp;phrase);
+		/// Gets phrase query.
+		string getPhrase(void) const;
+
+		/// Sets ANY words.
+		void setAnyWords(const string &amp;words);
+		/// Gets ANY words.
+		string getAnyWords(void) const;
+
+		/// Sets NOT words.
+		void setNotWords(const string &amp;words);
+		/// Gets NOT words.
+		string getNotWords(void) const;
+
+		/// Sets the query's language.
+		void setLanguage(const string &amp;language);
+		/// Gets the query's language.
+		string getLanguage(void) const;
+
+		/// Sets host name filter.
+		void setHostNameFilter(const string &amp;filter);
+		/// Gets host name filter.
+		string getHostNameFilter(void) const;
+
+		/// Sets file name filter.
+		void setFileNameFilter(const string &amp;filter);
+		/// Gets file name filter.
+		string getFileNameFilter(void) const;
+
+		/// Sets the maximum number of results.
+		void setMaximumResultsCount(unsigned int count);
+		/// Gets the maximum number of results.
+		unsigned int getMaximumResultsCount(void) const;
+
+		/// Sets whether results should be indexed.
+		void setIndexResults(bool index);
+		/// Gets whether results should be indexed
+		bool getIndexResults(void) const;
+
+		/// Sets the name of the label to use for indexed documents.
+		void setLabelName(const string &amp;labelName);
+		/// Gets the name of the label to use for indexed documents.
+		string getLabelName(void) const;
+
+		/// Returns a displayable representation of this query's properties.
+		string toString(bool forPresentation = true) const;
+
+	protected:
+		string m_name;
+		string m_andWords;
+		string m_phrase;
+		string m_anyWords;
+		string m_notWords;
+		string m_language;
+		string m_hostName;
+		string m_fileName;
+		unsigned int m_resultsCount;
+		bool m_indexResults;
+		string m_labelName;
+
+};
+
+#endif // _QUERY_PROPERTIES_H

Added: trunk/Search/SOAPEnvNS.cpp
===================================================================
--- trunk/Search/SOAPEnvNS.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/SOAPEnvNS.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1 @@
+struct Namespace *namespaces;

Added: trunk/Search/SearchEngineFactory.cpp
===================================================================
--- trunk/Search/SearchEngineFactory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/SearchEngineFactory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,83 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAS_GOOGLEAPI
+#include &quot;GoogleAPIEngine.h&quot;
+#endif
+#ifdef HAS_OSAPI
+#include &quot;ObjectsSearchAPIEngine.h&quot;
+#endif
+#include &quot;PluginWebEngine.h&quot;
+#include &quot;XapianEngine.h&quot;
+#include &quot;SearchEngineFactory.h&quot;
+
+SearchEngineFactory::SearchEngineFactory()
+{
+}
+
+SearchEngineFactory::~SearchEngineFactory()
+{
+}
+
+/// Returns a SearchEngine of the specified type; NULL if unavailable.
+SearchEngineInterface *SearchEngineFactory::getSearchEngine(const string &amp;type, const string &amp;option)
+{
+	SearchEngineInterface *myEngine = NULL;
+
+	// Choice by type
+	if (type == &quot;sherlock&quot;)
+	{
+		myEngine = new PluginWebEngine(option);
+	}
+	else if (type == &quot;xapian&quot;)
+	{
+		myEngine = new XapianEngine(option);
+	}
+#ifdef HAS_GOOGLEAPI
+	else if (type == &quot;googleapi&quot;)
+	{
+		myEngine = new GoogleAPIEngine();
+		myEngine-&gt;setKey(option);
+	}
+#endif
+#ifdef HAS_OSAPI
+	else if (type == &quot;objectssearchapi&quot;)
+	{
+		myEngine = new ObjectsSearchAPIEngine();
+	}
+#endif
+
+	return myEngine;
+}
+
+/// Indicates whether a search engine is supported or not.
+bool SearchEngineFactory::isSupported(const string &amp;type)
+{
+	if (
+#ifdef HAS_GOOGLEAPI
+		(type == &quot;googleapi&quot;) ||
+#endif
+#ifdef HAS_OSAPI
+		(type == &quot;objectssearchapi&quot;) ||
+#endif
+		(type == &quot;sherlock&quot;) ||
+		(type == &quot;xapian&quot;))
+	{
+		return true;
+	}
+
+	return false;	
+}


Property changes on: trunk/Search/SearchEngineFactory.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/SearchEngineFactory.h
===================================================================
--- trunk/Search/SearchEngineFactory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/SearchEngineFactory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,50 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _SEARCHENGINE_FACTORY_H
+#define _SEARCHENGINE_FACTORY_H
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;set&gt;
+
+#include &quot;SearchEngineInterface.h&quot;
+
+using std::string;
+using std::map;
+using std::set;
+
+class SearchEngineFactory
+{
+	public:
+		virtual ~SearchEngineFactory();
+
+		/// Returns a SearchEngine of the specified type; NULL if unavailable.
+		static SearchEngineInterface *getSearchEngine(const string &amp;type, const string &amp;option);
+
+		/// Indicates whether a search engine is supported or not.
+		static bool isSupported(const string &amp;type);
+
+	protected:
+		SearchEngineFactory();
+
+	private:
+		SearchEngineFactory(const SearchEngineFactory &amp;other);
+		SearchEngineFactory &amp;operator=(const SearchEngineFactory &amp;other);
+
+};
+
+#endif // _SEARCHENGINE_FACTORY_H


Property changes on: trunk/Search/SearchEngineFactory.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/SearchEngineInterface.cpp
===================================================================
--- trunk/Search/SearchEngineInterface.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/SearchEngineInterface.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,121 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+
+#include &quot;Url.h&quot;
+#include &quot;SearchEngineInterface.h&quot;
+
+using std::cout;
+using std::endl;
+
+SearchEngineInterface::SearchEngineInterface() :
+	m_callsCount(0),
+	m_startTime(time(NULL)),
+	m_maxResultsCount(10)
+{
+}
+
+SearchEngineInterface::~SearchEngineInterface()
+{
+}
+
+/// Indicates if the search engine is available in several languages/countries.
+bool SearchEngineInterface::isInternational(void) const
+{
+	return false;
+}
+
+/// Sets the search engine's key, if applicable.
+void SearchEngineInterface::setKey(const string &amp;key)
+{
+	m_key = key;
+}
+
+/// Sets the number of calls issued since start time.
+void SearchEngineInterface::setCallsCount(unsigned int count, time_t startTime)
+{
+	m_callsCount = count;
+	m_startTime = startTime;
+}
+
+/// Sets the maximum number of results to return.
+void SearchEngineInterface::setMaxResultsCount(unsigned int count)
+{
+	m_maxResultsCount = count;
+}
+
+/// Returns the results for the previous query.
+const vector&lt;Result&gt; &amp;SearchEngineInterface::getResults(void) const
+{
+	return m_resultsList;
+}
+
+void SearchEngineInterface::setHostNameFilter(const string &amp;filter)
+{
+	m_hostFilter = filter;
+}
+
+void SearchEngineInterface::setFileNameFilter(const string &amp;filter)
+{
+	m_fileFilter = filter;
+}
+
+bool SearchEngineInterface::processResult(string &amp;resultUrl)
+{
+	Url urlObj(resultUrl);
+
+	if ((m_hostFilter.empty() == false) &amp;&amp;
+		(urlObj.getHost() != m_hostFilter))
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;SearchEngineInterface::processResult: skipping &quot; &lt;&lt; resultUrl &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	if ((m_fileFilter.empty() == false) &amp;&amp;
+		(urlObj.getFile() != m_fileFilter))
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;SearchEngineInterface::processResult: skipping &quot; &lt;&lt; resultUrl &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	// Remove trailing spaces at the end of the URL
+	string trimmedUrl = resultUrl;
+	string::size_type pos = trimmedUrl.find_last_of(&quot; &quot;);
+	while (pos != string::npos)
+	{
+		int len = trimmedUrl.length();
+#ifdef DEBUG
+		cout &lt;&lt; &quot;SearchEngineInterface::processResult: trimming space at &quot; &lt;&lt; pos &lt;&lt; endl;
+#endif
+		if (pos == len - 1)
+		{
+			trimmedUrl.resize(pos);
+			pos = trimmedUrl.find_last_of(&quot; &quot;);
+		}
+		else
+		{
+			break;
+		}
+	}
+	resultUrl = Url::canonicalizeUrl(trimmedUrl);
+
+	return true;
+}


Property changes on: trunk/Search/SearchEngineInterface.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/SearchEngineInterface.h
===================================================================
--- trunk/Search/SearchEngineInterface.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/SearchEngineInterface.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,74 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _SEARCHENGINE_INTERFACE_H
+#define _SEARCHENGINE_INTERFACE_H
+
+#include &lt;time.h&gt;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+#include &quot;QueryProperties.h&quot;
+#include &quot;Result.h&quot;
+
+using namespace std;
+
+/**
+  * Interface implemented by search engines.
+  */
+class SearchEngineInterface
+{
+	public:
+		virtual ~SearchEngineInterface();
+
+		/// Indicates if the search engine is available in several languages/countries.
+		virtual bool isInternational(void) const;
+
+		/// Sets the search engine's key, if applicable.
+		virtual void setKey(const string &amp;key);
+
+		/// Sets the number of calls issued since start time.
+		virtual void setCallsCount(unsigned int count, time_t startTime);
+
+		/// Sets the maximum number of results to return.
+		virtual void setMaxResultsCount(unsigned int count);
+
+		/// Runs a query; true if success.
+		virtual bool runQuery(QueryProperties&amp; queryProps) = 0;
+
+		/// Returns the results for the previous query.
+		virtual const vector&lt;Result&gt; &amp;getResults(void) const;
+
+	protected:
+		string m_key;
+		unsigned int m_callsCount;
+		time_t m_startTime;
+		unsigned int m_maxResultsCount;
+		string m_hostFilter;
+		string m_fileFilter;
+		vector&lt;Result&gt; m_resultsList;
+
+		SearchEngineInterface();
+
+		void setHostNameFilter(const string &amp;filter);
+
+		void setFileNameFilter(const string &amp;filter);
+
+		virtual bool processResult(string &amp;resultUrl);
+
+};
+
+#endif // _SEARCHENGINE_INTERFACE_H


Property changes on: trunk/Search/SearchEngineInterface.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/WebEngine.cpp
===================================================================
--- trunk/Search/WebEngine.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/WebEngine.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,51 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;string.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;regex.h&gt;
+#include &lt;iostream&gt;
+#include &lt;algorithm&gt;
+
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;DownloaderFactory.h&quot;
+#include &quot;WebEngine.h&quot;
+
+WebEngine::WebEngine() :
+	SearchEngineInterface()
+{
+}
+
+WebEngine::~WebEngine()
+{
+	m_resultsList.clear();
+}
+
+Document *WebEngine::downloadPage(const DocumentInfo &amp;docInfo)
+{
+	// Any type of downloader will do...
+	DownloaderInterface *myDownloader = DownloaderFactory::getDownloader(&quot;http&quot;, &quot;&quot;);
+	if (myDownloader == NULL)
+	{
+		return NULL;
+	}
+
+	Document *urlDoc = myDownloader-&gt;retrieveUrl(docInfo);
+	delete myDownloader;
+
+	return urlDoc;
+}

Added: trunk/Search/WebEngine.h
===================================================================
--- trunk/Search/WebEngine.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/WebEngine.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,46 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _WEB_ENGINE_H
+#define _WEB_ENGINE_H
+
+#include &lt;string&gt;
+#include &lt;set&gt;
+
+#include &quot;SearchEngineInterface.h&quot;
+#include &quot;Document.h&quot;
+
+using namespace std;
+
+class WebEngine : public SearchEngineInterface
+{
+	public:
+		WebEngine();
+		virtual ~WebEngine();
+
+	protected:
+		string m_hostFilter;
+		string m_fileFilter;
+
+		Document *downloadPage(const DocumentInfo &amp;docInfo);
+
+	private:
+		WebEngine(const WebEngine &amp;other);
+		WebEngine &amp;operator=(const WebEngine &amp;other);
+
+};
+
+#endif // _WEB_ENGINE_H

Added: trunk/Search/XapianEngine.cpp
===================================================================
--- trunk/Search/XapianEngine.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/XapianEngine.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,430 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;iostream&gt;
+
+#include &quot;StringManip.h&quot;
+#include &quot;Tokenizer.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;XapianDatabaseFactory.h&quot;
+#include &quot;XapianEngine.h&quot;
+
+using std::string;
+using std::vector;
+using std::stack;
+using std::cout;
+using std::cerr;
+using std::endl;
+
+static bool extractWords(const string &amp;text, const string &amp;language, vector&lt;string&gt; &amp;wordsList)
+{
+	Xapian::Stem *pStemmer = NULL;
+
+	if (text.empty() == true)
+	{
+		return false;
+	}
+
+	if (language.empty() == false)
+	{
+		pStemmer = new Xapian::Stem(StringManip::toLowerCase(language));
+	}
+
+	Document doc;
+	doc.setData(text.c_str(), text.length());
+	Tokenizer tokens(&amp;doc);
+
+	string token;
+	while (tokens.nextToken(token) == true)
+	{
+		string term = token;
+
+		// Lower case the term
+		term = StringManip::toLowerCase(term);
+		// Stem it ?
+		if (pStemmer != NULL)
+		{
+			string stemmedTerm = pStemmer-&gt;stem_word(term);
+			wordsList.push_back(stemmedTerm);
+		}
+		else
+		{
+			wordsList.push_back(term);
+		}
+	}
+
+	if (pStemmer != NULL)
+	{
+		delete pStemmer;
+	}
+
+	return true;
+}
+
+XapianEngine::XapianEngine(const string &amp;database) :
+	SearchEngineInterface()
+{
+	// If the database name ends with a slash, remove it
+	if (database[database.length() - 1] == '/')
+	{
+		m_databaseName = database.substr(0, database.length() - 1);
+	}
+	else
+	{
+		m_databaseName = database;
+	}
+
+	// SearchEngineInterface members
+	m_maxResultsCount = 10;
+	m_resultsList.clear();
+}
+
+XapianEngine::~XapianEngine()
+{
+	m_resultsList.clear();
+}
+
+bool XapianEngine::queryDatabase(Xapian::Query &amp;query)
+{
+	bool bStatus = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, true);
+	if (pDatabase == NULL)
+	{
+		return false;
+	}
+
+	Xapian::Database *pIndex = pDatabase-&gt;readLock();
+	if (pIndex != NULL)
+	{
+		try
+		{
+			// Start an enquire session on the database
+			Xapian::Enquire enquire(*pIndex);
+
+			// Give the query object to the enquire session
+			enquire.set_query(query);
+
+			// Get the top N results of the query
+			Xapian::MSet matches = enquire.get_mset(0, m_maxResultsCount);
+
+			// Get the results
+#ifdef DEBUG
+			cout &lt;&lt; &quot;XapianEngine::queryDatabase: &quot; &lt;&lt; matches.get_matches_estimated() &lt;&lt; &quot;/&quot; &lt;&lt; m_maxResultsCount &lt;&lt; &quot; results found&quot; &lt;&lt; endl;
+#endif
+			for (Xapian::MSetIterator i = matches.begin(); i != matches.end(); ++i)
+			{
+				// Get the document data
+				string record = i.get_document().get_data();
+
+				// Get the title
+				string title = StringManip::extractField(record, &quot;caption=&quot;, &quot;\n&quot;);
+#ifdef DEBUG
+				cout &lt;&lt; &quot;XapianEngine::queryDatabase: found omindex title &quot; &lt;&lt; title &lt;&lt; endl;
+#endif
+				// Get the URL
+				string url = StringManip::extractField(record, &quot;url=&quot;, &quot;\n&quot;);
+				if (url.empty() == true)
+				{
+					// Hmmm this shouldn't be empty...
+					// Use this instead, even though the document isn't cached in the index
+					url = buildUrl(m_databaseName, *i);
+				}
+				else
+				{
+#ifdef DEBUG
+					cout &lt;&lt; &quot;XapianEngine::queryDatabase: found omindex URL &quot; &lt;&lt; url &lt;&lt; endl;
+#endif
+					url = Url::canonicalizeUrl(url);
+				}
+
+				// Get the summary and the type
+				string summary = StringManip::extractField(record, &quot;sample=&quot;, &quot;\n&quot;);
+#ifdef DEBUG
+				cout &lt;&lt; &quot;XapianEngine::queryDatabase: found omindex summary &quot; &lt;&lt; summary &lt;&lt; endl;
+#endif
+				string type = StringManip::extractField(record, &quot;type=&quot;, &quot;\n&quot;);
+				// ...and finally the language, if available
+				string language = StringManip::extractField(record, &quot;language=&quot;, &quot;\n&quot;);
+
+				// Add this result
+				Result thisResult(url, title, summary, language, (float)i.get_percent());
+				m_resultsList.push_back(thisResult);
+			}
+
+			bStatus = true;
+		}
+		catch (const Xapian::Error &amp;error)
+		{
+			cout &lt;&lt; &quot;XapianEngine::queryDatabase: couldn't run query: &quot;  &lt;&lt; error.get_msg() &lt;&lt; endl;
+		}
+	}
+	pDatabase-&gt;unlock();
+
+	return bStatus;
+}
+
+void XapianEngine::stackQuery(const QueryProperties &amp;queryProps,
+	stack&lt;Xapian::Query&gt; &amp;queryStack, bool followOperators)
+{
+	string language = queryProps.getLanguage();
+	Xapian::Query::op queryOp = Xapian::Query::OP_OR;
+	string term;
+
+	// Get the terms to AND together
+	if (queryProps.getAndWords().empty() == false)
+	{
+		vector&lt;string&gt; andTerms;
+
+		if (extractWords(queryProps.getAndWords(), language, andTerms) == true)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;XapianEngine::stackQuery: OP_AND &quot;  &lt;&lt; andTerms.size() &lt;&lt; endl;
+#endif
+			if (followOperators == true)
+			{
+				queryOp = Xapian::Query::OP_AND;
+			}
+			queryStack.push(Xapian::Query(queryOp, andTerms.begin(), andTerms.end()));
+		}
+	}
+
+	// Get the terms of the phrase
+	if (queryProps.getPhrase().empty() == false)
+	{
+		vector&lt;string&gt; phraseTerms;
+
+		if (extractWords(queryProps.getPhrase(), language, phraseTerms) == true)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;XapianEngine::stackQuery: OP_PHRASE &quot;  &lt;&lt; phraseTerms.size() &lt;&lt; endl;
+#endif
+			if (followOperators == true)
+			{
+				queryOp = Xapian::Query::OP_PHRASE;
+			}
+			queryStack.push(Xapian::Query(queryOp, phraseTerms.begin(), phraseTerms.end()));
+		}
+	}
+
+	// Get the terms to OR together
+	if (queryProps.getAnyWords().empty() == false)
+	{
+		vector&lt;string&gt; orTerms;
+
+		if (extractWords(queryProps.getAnyWords(), language, orTerms) == true)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;XapianEngine::stackQuery: OP_OR &quot;  &lt;&lt; orTerms.size() &lt;&lt; endl;
+#endif
+			if (followOperators == true)
+			{
+				queryOp = Xapian::Query::OP_OR;
+			}
+			queryStack.push(Xapian::Query(queryOp, orTerms.begin(), orTerms.end()));
+		}
+	}
+
+	// Get the terms to NOT together
+	if (queryProps.getNotWords().empty() == false)
+	{
+		vector&lt;string&gt; notTerms;
+
+		if (extractWords(queryProps.getNotWords(), language, notTerms) == true)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;XapianEngine::stackQuery: OP_AND_NOT &quot;  &lt;&lt; notTerms.size() &lt;&lt; endl;
+#endif
+			// An AND_NOT has to have two sub-queries
+			if (followOperators == true)
+			{
+				queryOp = Xapian::Query::OP_AND;
+			}
+			Xapian::Query notQuery(queryOp, notTerms.begin(), notTerms.end());
+			// We need something to AND_NOT these terms against
+			if (queryStack.empty() == false)
+			{
+				Xapian::Query topQuery = queryStack.top();
+				queryStack.pop();
+				if (followOperators == true)
+				{
+					queryOp = Xapian::Query::OP_AND_NOT;
+				}
+				queryStack.push(Xapian::Query(queryOp, topQuery, notQuery));
+			}
+		}
+	}
+
+	// Get the host name filter
+	if (queryProps.getHostNameFilter().empty() == false)
+	{
+		vector&lt;string&gt; hostTerms;
+
+		term = &quot;H&quot;;
+		term += StringManip::toLowerCase(queryProps.getHostNameFilter());
+		hostTerms.push_back(term);
+		if (followOperators == true)
+		{
+			queryOp = Xapian::Query::OP_AND;
+		}
+		queryStack.push(Xapian::Query(queryOp, hostTerms.begin(), hostTerms.end()));
+	}
+
+	// Get the file name filter
+	if (queryProps.getFileNameFilter().empty() == false)
+	{
+		vector&lt;string&gt; fileTerms;
+
+		term = &quot;F&quot;;
+		term += StringManip::toLowerCase(queryProps.getFileNameFilter());
+		fileTerms.push_back(term);
+		if (followOperators == true)
+		{
+			queryOp = Xapian::Query::OP_AND;
+		}
+		queryStack.push(Xapian::Query(queryOp, fileTerms.begin(), fileTerms.end()));
+	}
+
+	// Get the language filter
+	if (queryProps.getLanguage().empty() == false)
+	{
+		vector&lt;string&gt; languageTerms;
+
+		term = &quot;L&quot;;
+		term += StringManip::toLowerCase(queryProps.getLanguage());
+		languageTerms.push_back(term);
+		if (followOperators == true)
+		{
+			queryOp = Xapian::Query::OP_AND;
+		}
+		queryStack.push(Xapian::Query(queryOp, languageTerms.begin(), languageTerms.end()));
+	}
+}
+
+/// Returns the URL for the given document in the given index.
+string XapianEngine::buildUrl(const string &amp;database, unsigned int docId)
+{
+	// Make up a pseudo URL
+	char docIdStr[64];
+	sprintf(docIdStr, &quot;%u&quot;, docId);
+	string url = &quot;<A HREF="xapian://localhost/">xapian://localhost/</A>&quot;;
+	url += database;
+	url += &quot;/&quot;;
+	url += docIdStr;
+
+	return url;
+}
+
+/// Runs a boolean query; true if success.
+bool XapianEngine::runQuery(const string &amp;keyword)
+{
+	// Clear the results list
+	m_resultsList.clear();
+
+	try
+	{
+		vector&lt;string&gt; keywordTerms;
+		keywordTerms.push_back(keyword);
+		Xapian::Query keyworkQuery(Xapian::Query::OP_AND, keywordTerms.begin(), keywordTerms.end());
+
+		// Query the database with the full query
+		return queryDatabase(keyworkQuery);
+	}
+	catch (const Xapian::Error &amp;error)
+	{
+		cout &lt;&lt; &quot;XapianEngine::runQuery: couldn't run query: &quot;  &lt;&lt; error.get_msg() &lt;&lt; endl;
+	}
+
+	return false;
+}
+
+//
+// Implementation of SearchEngineInterface
+//
+
+/// Runs a query; true if success.
+bool XapianEngine::runQuery(QueryProperties&amp; queryProps)
+{
+	// Clear the results list
+	m_resultsList.clear();
+
+	try
+	{
+		stack&lt;Xapian::Query&gt; queryStack;
+		bool followOperators = true;
+
+		stackQuery(queryProps, queryStack, followOperators);
+		while (queryStack.empty() == false)
+		{
+			while (queryStack.size() &gt; 1)
+			{
+				Xapian::Query topQuery = queryStack.top();
+				queryStack.pop();
+#ifdef DEBUG
+				cout &lt;&lt; &quot;XapianEngine::runQuery: popped query, left &quot;  &lt;&lt; queryStack.size() &lt;&lt; endl;
+#endif
+				Xapian::Query query = Xapian::Query(Xapian::Query::OP_AND, queryStack.top(), topQuery);
+				queryStack.pop();
+#ifdef DEBUG
+				cout &lt;&lt; &quot;XapianEngine::runQuery: popped query, left &quot;  &lt;&lt; queryStack.size() &lt;&lt; endl;
+#endif
+				queryStack.push(query);
+			}
+
+			// Query the database with the full query
+			if (queryDatabase(queryStack.top()) == true)
+			{
+#if 0
+				if ((m_resultsList.empty() == true) &amp;&amp;
+					(followOperators == true))
+				{
+					// The search did succeed but didn't return anything
+					// Try again by OR'ing terms together
+					while (queryStack.empty() == false)
+					{
+						queryStack.pop();
+					}
+					followOperators = false;
+#ifdef DEBUG
+					cout &lt;&lt; &quot;XapianEngine::runQuery: trying with OR'ed terms&quot; &lt;&lt; endl;
+#endif
+					stackQuery(queryProps, queryStack, followOperators);
+					continue;
+				}
+#endif
+
+				return true;
+			}
+		}
+	}
+	catch (const Xapian::Error &amp;error)
+	{
+		cout &lt;&lt; &quot;XapianEngine::runQuery: couldn't run query: &quot;  &lt;&lt; error.get_msg() &lt;&lt; endl;
+	}
+
+	return false;
+}
+
+/// Returns the results for the previous query.
+const vector&lt;Result&gt; &amp;XapianEngine::getResults(void) const
+{
+	return m_resultsList;
+}


Property changes on: trunk/Search/XapianEngine.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/XapianEngine.h
===================================================================
--- trunk/Search/XapianEngine.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/XapianEngine.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,61 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XAPIAN_ENGINE_H
+#define _XAPIAN_ENGINE_H
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;stack&gt;
+
+#include &lt;xapian.h&gt;
+
+#include &quot;SearchEngineInterface.h&quot;
+#include &quot;DownloaderFactory.h&quot;
+
+class XapianEngine : public SearchEngineInterface
+{
+	public:
+		XapianEngine(const std::string &amp;database);
+		virtual ~XapianEngine();
+
+		/// Runs a boolean query; true if success.
+		virtual bool runQuery(const std::string &amp;keyword);
+
+		/// Runs a query; true if success.
+		virtual bool runQuery(QueryProperties&amp; queryProps);
+
+		/// Returns the results for the previous query.
+		virtual const std::vector&lt;Result&gt; &amp;getResults(void) const;
+
+		/// Returns the URL for the given document in the given index.
+		static std::string buildUrl(const std::string &amp;database, unsigned int docId);
+
+	protected:
+		std::string m_databaseName;
+
+		bool queryDatabase(Xapian::Query &amp;query);
+
+		void stackQuery(const QueryProperties &amp;queryProps,
+			std::stack&lt;Xapian::Query&gt; &amp;queryStack, bool followOperators);
+
+	private:
+		XapianEngine(const XapianEngine &amp;other);
+		XapianEngine &amp;operator=(const XapianEngine &amp;other);
+
+};
+
+#endif // _XAPIAN_ENGINE_H


Property changes on: trunk/Search/XapianEngine.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/senginetest.cpp
===================================================================
--- trunk/Search/senginetest.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/senginetest.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,198 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;cstdlib&gt;
+#include &lt;cstdio&gt;
+#include &lt;iostream&gt;
+#include &lt;string&gt;
+#include &lt;fstream&gt;
+
+#include &quot;SearchEngineFactory.h&quot;
+#ifdef HAS_GOOGLEAPI
+#include &quot;GoogleAPIEngine.h&quot;
+#endif
+#include &quot;DownloaderFactory.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;HtmlTokenizer.h&quot;
+
+using namespace std;
+
+static void fetchCachedPage(const string &amp;url, const string &amp;file, const string &amp;key)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;fetchCachedPage: attempting to save &quot; &lt;&lt; url &lt;&lt; &quot; to &quot; &lt;&lt; file &lt;&lt; endl;
+#endif
+
+#ifdef HAS_GOOGLEAPI
+	Url thisUrl(url);
+	GoogleAPIEngine googleApiEngine;
+	googleApiEngine.setKey(key);
+
+	Document *urlDoc = googleApiEngine.retrieveCachedUrl(url);
+	if (urlDoc != NULL)
+	{
+		unsigned int urlContentLen;
+		ofstream outputFile;
+		outputFile.open(file.c_str(), ofstream::out | ofstream::trunc);
+		outputFile &lt;&lt; urlDoc-&gt;getData(urlContentLen);
+		outputFile.close();
+
+		delete urlDoc;
+	}
+	else
+	{
+		cerr &lt;&lt; &quot;fetchCachedPage: couldn't get &quot; &lt;&lt; url &lt;&lt; &quot; !&quot; &lt;&lt; endl;
+	}
+#endif
+}
+
+static void fetchPage(const string &amp;url, const string &amp;file)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;fetchPage: attempting to save &quot; &lt;&lt; url &lt;&lt; &quot; to &quot; &lt;&lt; file &lt;&lt; endl;
+#endif
+
+	// Any type of downloader will do...
+	Url thisUrl(url);
+	DownloaderInterface *myDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol(), &quot;&quot;);
+	if (myDownloader == NULL)
+	{
+		cerr &lt;&lt; &quot;fetchPage: couldn't obtain downloader instance (&quot; &lt;&lt; thisUrl.getProtocol() &lt;&lt; &quot;)&quot; &lt;&lt; endl;
+		return;
+	}
+
+	DocumentInfo docInfo(&quot;Page&quot;, url, &quot;&quot;, &quot;&quot;);
+	Document *urlDoc = myDownloader-&gt;retrieveUrl(docInfo);
+	if (urlDoc != NULL)
+	{
+		unsigned int urlContentLen;
+		ofstream outputFile;
+		outputFile.open(file.c_str(), ofstream::out | ofstream::trunc);
+		outputFile &lt;&lt; urlDoc-&gt;getData(urlContentLen);
+		outputFile.close();
+
+		delete urlDoc;
+	}
+	else
+	{
+		cerr &lt;&lt; &quot;fetchPage: couldn't get &quot; &lt;&lt; url &lt;&lt; &quot; !&quot; &lt;&lt; endl;
+	}
+
+	delete myDownloader;
+}
+
+int main(int argc, char **argv)
+{
+	string type, option;
+	bool bDownloadResults = false;
+
+	if (argc &lt; 5)
+	{
+		cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;search engine name&gt; &lt;option&gt; &lt;search string&gt; &lt;max results&gt; [DOWNLOAD]&quot; &lt;&lt; endl;
+		return EXIT_FAILURE;
+	}
+	if (argc &gt; 5)
+	{
+		string flag = argv[5];
+		if (flag == &quot;DOWNLOAD&quot;)
+		{
+			bDownloadResults = true;
+		}
+	}
+
+	// Which SearchEngine ?
+	type = argv[1];
+	option = argv[2];
+	SearchEngineInterface *myEngine = SearchEngineFactory::getSearchEngine(type, option);
+	if (myEngine == NULL)
+	{
+		cerr &lt;&lt; &quot;Couldn't obtain search engine instance&quot; &lt;&lt; endl;
+		return EXIT_FAILURE;
+	}
+
+	// How many results ?
+	unsigned int count = atoi(argv[4]);
+	myEngine-&gt;setMaxResultsCount(count);
+
+	QueryProperties queryProps(&quot;senginetest&quot;, argv[3], &quot;&quot;, &quot;&quot;, &quot;&quot;);
+	bool bOK = myEngine-&gt;runQuery(queryProps);
+	if (bOK == true)
+	{
+		string resultsPage;
+
+		// Try getting a list of links
+		const vector&lt;Result&gt; resultsList = myEngine-&gt;getResults();
+		if (resultsList.empty() == false)
+		{
+			unsigned int count = 0;
+
+			cout &lt;&lt; &quot;Matching documents are :&quot; &lt;&lt; endl;
+
+			vector&lt;Result&gt;::const_iterator resultIter = resultsList.begin();
+			while (resultIter != resultsList.end())
+			{
+				string rawUrl = (*resultIter).getLocation();
+				Url thisUrl(rawUrl);
+
+				cout &lt;&lt; count &lt;&lt; &quot; Raw URL  : '&quot; &lt;&lt; rawUrl &lt;&lt; &quot;'&quot;&lt;&lt; endl;
+				cout &lt;&lt; count &lt;&lt; &quot; Protocol : &quot; &lt;&lt; thisUrl.getProtocol() &lt;&lt; endl;
+				cout &lt;&lt; count &lt;&lt; &quot; Host     : &quot; &lt;&lt; thisUrl.getHost() &lt;&lt; endl;
+				cout &lt;&lt; count &lt;&lt; &quot; Location : &quot; &lt;&lt; thisUrl.getLocation() &lt;&lt; &quot;/&quot; &lt;&lt; thisUrl.getFile() &lt;&lt; endl;
+				cout &lt;&lt; count &lt;&lt; &quot; Title    : &quot; &lt;&lt; HtmlTokenizer::stripTags((*resultIter).getTitle()) &lt;&lt; endl;
+				cout &lt;&lt; count &lt;&lt; &quot; Extract  : &quot; &lt;&lt; HtmlTokenizer::stripTags((*resultIter).getExtract()) &lt;&lt; endl;
+				cout &lt;&lt; count &lt;&lt; &quot; Score    : &quot; &lt;&lt; (*resultIter).getScore() &lt;&lt; endl;
+
+				if (bDownloadResults == true)
+				{
+					// Set the name of the file to which this page will be saved
+					char num[16];
+					sprintf(num, &quot;%d&quot;, count);
+					string url = (*resultIter).getLocation();
+					string file = num;
+					file += &quot;_&quot;;
+					file += thisUrl.getHost();
+					file += &quot;.html&quot;;
+
+					if (type == &quot;googleapi&quot;)
+					{
+						// Fetch the page from the Google cache
+						fetchCachedPage(url, file, option);
+					}
+					else
+					{
+						fetchPage(url, file);
+					}
+				}
+				count++;
+
+				// Next
+				resultIter++;
+			}
+		}
+		else
+		{
+			cerr &lt;&lt; &quot;Couldn't get a results list !&quot; &lt;&lt; endl;
+		}
+	}
+	else
+	{
+		cerr &lt;&lt; &quot;Couldn't run query on search engine &quot; &lt;&lt; argv[1] &lt;&lt; endl;
+	}
+
+	delete myEngine;
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/Search/senginetest.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/TODO
===================================================================
--- trunk/TODO	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/TODO	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,99 @@
+General
+- Fix dependencies in build system, use autoconf and friends
+- Fix the FIXMEs
+- Get rid of dead code/classes/methods...
+- Advertise service via Rendezvous with Howl (<A HREF="http://www.porchdogsoft.com/products/howl/">http://www.porchdogsoft.com/products/howl/</A>)
+- Remove hardcoded paths
+- Man page, see help2man (<A HREF="http://www.gnu.org/software/help2man/">http://www.gnu.org/software/help2man/</A>)
+- Logging should not be all (DEBUG) or nothing (release)
+- Check for leaks with valgrind (eg --tool=memcheck -v --leak-check=yes --show-reachable=yes ...)
+- Change .spec to allow building with Google and ObjectsSearch SOAP APIs support
+- Don't use system(), fork and exec, especially for the external browser
+
+Search
+- Write a Spirit-based parser for extracting results from web pages
+- Allow to use &quot;extended&quot; INTERPRET tags selectively 
+- With engines that provide a redirection URL for results (eg Acoona), it looks like
+  the query hitory is not saved/checked correctly
+- OR terms if AND search on index doesn't return anything
+- Add Creative Commons (<A HREF="http://search.yahoo.com/cc">http://search.yahoo.com/cc</A>)
+- Add <A HREF="http://beta.exalead.com/search">http://beta.exalead.com/search</A>
+- Add csourcesearch.net
+- Add <A HREF="http://www.patentcommons.org/commons/patentsearch.php">http://www.patentcommons.org/commons/patentsearch.php</A>
+- Apply Pinot specific filters (eg &quot;L&quot; for language) on internal indices only
+
+Collect
+- Comply with robot stuff defined at <A HREF="http://www.robotstxt.org/">http://www.robotstxt.org/</A>
+- Harvest mode grabs all pages on a specific site down to a certain depth
+- Make User-Agent string configurable
+- Make download timeout configurable
+- Investigate replacing neon (and gsoap ?) with libsoup
+- Support for HTML frames
+- Write a tokenizer for RFCs that breaks chapters into individual documents
+- Allow to cache documents that had to be converted ? eg PDF, MS Word
+
+Index
+- Get hold of stopwords lists for the languages supported by Xapian's stemmers and don't index stop words
+- Allow to import and use omindex-produced indexes  so that they can be used like pinot's internal indexes
+- Write a pseudo-filesystem for indexes with FUSE (<A HREF="http://fuse.sourceforge.net/">http://fuse.sourceforge.net/</A>) or gnome-vfs ?
+- Interface with libtranslate (<A HREF="http://www.nongnu.org/libtranslate/">http://www.nongnu.org/libtranslate/</A>) ? :-)
+- Xapian lock files can be deleted at startup if no other instance is running
+- Make sure terms are not longer than btree:max_key_len bytes
+- Play around with the XAPIAN_FLUSH_THRESHOLD env var
+- Catch DatabaseModifiedError exceptions, call reopen()
+- Sort index/database back-end, don't replicate what's in the configuration file, etc...
+- Switch to Xapian's new Flint back-end (set XAPIAN_PREFER_FLINT=1)
+- Write a back-end for CLucene (<A HREF="http://clucene.sourceforge.net/">http://clucene.sourceforge.net/</A>)
+- Flush the index before searching not after modification
+- Hash document data to determine on updates whether documents have changed
+- Allow to monitor imported documents for changes
+
+Browser plugin
+- Write Firefox extension that searches Pinot indexes and indexes the cache
+- Borrow code from beagle's Firefox plugin
+- Skip popups and non text documents
+- Use dbus for communication
+- Index browser history in My Web index
+
+RenderHTML
+- Sort out issues with gtk_embed_moz if possible
+- Replace Mozilla GTK embed with GTK WebCore or latest gtkhtml, or drop altogether ?
+- Is it possible to build against Firefox instead of the Mozilla suite ?
+- Highlight search terms
+- Fix crash with documents that link to images with https
+
+Mail
+- Find out what kind of locking scheme Mozilla uses (POSIX lock ?) and use that
+- Index Evolution email (Camel, might be useful for other types actually)
+- Keep track of attachments and avoid indexing the same file twice
+- Append sender to title or use as host name ?
+- Decypher and use Mozilla's mailbox scheme, eg
+  <A HREF="mailbox://mbox_file_name?number=2164959&amp;part=1.2&amp;type=text/plain&amp;filename=portability.txt">mailbox://mbox_file_name?number=2164959&amp;part=1.2&amp;type=text/plain&amp;filename=portability.txt</A>
+- When parsing email's Date field, take the timezone offset into account, eg in
+    Date: Thu, 25 Aug 2005 11:04:49 +0800
+  +0800 is basically same as SGT. At the moment the date is assumed to be GMT !
+- Mail messages with attachements are not indexed
+- Check that labels are removed when a message is unindexed (eg because it's no longer
+  in the mail account)
+
+UI
+- Switching back and forth between grouping modes messes up results rankings : check scores
+- When sorting results by host name, give better score to results that appear several times
+- Results and index trees should be sorted when clicking on columns
+- Make sure all operations (eg search engines) and threads can be stopped cleanly
+- Show which threads are running, what they are doing, and allow to stop them selectively
+- Add an history window to edit Index and ViewHistory
+- Automatic indexing of a query's results depending on type, source, size, language
+- Non modal status window to display log of operations
+- Display search engines icons (Gtk::IconSource::set_filename() and Gtk::Style::render_icon())
+- Only show documents that have the selected label
+- Replace Combobox objects with ComboboxText's (glademm support required)
+- Replace glademm with libglademm ?
+- Show extract instead of URL in index list
+- At startup, don't switch to the Index tab when listing the documents index
+- Show activity when mail is being indexed
+- Update Last Run after the query has completed
+- Add a Recent Import section that relies on documents timestamps
+- Filter documents by language, similarly to how labels are shown
+- Save query expander and extract field status in config file
+

Added: trunk/Tokenize/HtmlTokenizer.cpp
===================================================================
--- trunk/Tokenize/HtmlTokenizer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/HtmlTokenizer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,490 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;string.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;regex.h&gt;
+#include &lt;stack&gt;
+#include &lt;iostream&gt;
+#include &lt;algorithm&gt;
+
+#include &quot;StringManip.h&quot;
+#include &quot;HtmlTokenizer.h&quot;
+
+//#define DEBUG_TOKENIZER
+
+using namespace std;
+
+/// Removes double and single quotes in links or any other attribute.
+static string removeLinkQuotes(const string &amp;quotedLink)
+{
+	string link;
+
+	if (quotedLink[0] == '&quot;')
+	{
+		string::size_type closingQuotePos = quotedLink.find(&quot;\&quot;&quot;, 1);
+		if (closingQuotePos != string::npos)
+		{
+			link = quotedLink.substr(1, closingQuotePos - 1);
+		}
+	}
+	else if (quotedLink[0] == '\'')
+	{
+		string::size_type closingQuotePos = quotedLink.find(&quot;'&quot;, 1);
+		if (closingQuotePos != string::npos)
+		{
+			link = quotedLink.substr(1, closingQuotePos - 1);
+		}
+	}
+	else
+	{
+		// There are no quotes, so just look for the first space, if any
+		string::size_type spacePos = quotedLink.find(&quot; &quot;);
+		if (spacePos != string::npos)
+		{
+			link = quotedLink.substr(0, spacePos);
+		}
+		else
+		{
+			link = quotedLink;
+		}
+	}
+
+	return link;
+}
+
+HtmlTokenizer::HtmlTokenizer(const Document *pDocument, unsigned int linksStartAtPos) :
+	Tokenizer(NULL),
+	m_pHtmlDocument(NULL),
+	m_linkPos(linksStartAtPos)
+{
+	initialize(pDocument);
+}
+
+HtmlTokenizer::HtmlTokenizer() :
+	Tokenizer(NULL),
+	m_pHtmlDocument(NULL),
+	m_linkPos(0)
+{
+}
+
+HtmlTokenizer::~HtmlTokenizer()
+{
+	if (m_pDocument != NULL)
+	{
+		// This should have been set by setDocument(),
+		// called in initialize()
+		delete m_pDocument;
+	}
+}
+
+void HtmlTokenizer::initialize(const Document *pDocument)
+{
+	unsigned int length = 0;
+
+	if (pDocument == NULL)
+	{
+		return;
+	}
+
+	const char *data = pDocument-&gt;getData(length);
+	if ((data != NULL) &amp;&amp;
+		(length &gt; 0))
+	{
+		// Remove HTML tags
+		string strippedData = parseHTML(data);
+		// Append META keywords, if any were found
+		strippedData += getMetaTag(&quot;keywords&quot;);
+
+		// Pass the result to the parent class
+		Document *pStrippedDoc = new Document(pDocument-&gt;getTitle(),
+			pDocument-&gt;getLocation(), pDocument-&gt;getType(),
+			pDocument-&gt;getLanguage());
+		pStrippedDoc-&gt;setData(strippedData.c_str(), strippedData.length());
+		setDocument(pStrippedDoc);
+
+		m_pHtmlDocument = pDocument;
+	}
+}
+
+/// Parses HTML; the string without tags.
+string HtmlTokenizer::parseHTML(const string &amp;str, bool stripAllBlocks)
+{
+	stack&lt;string&gt; tagsStack;
+	string stripped, link, linkName;
+	string::size_type startPos = 0, linkOpenPos = 0;
+	regex_t linksRegex, metaRegex;
+	bool isHtml = false, skip = false, catText = stripAllBlocks;
+	bool extractLinks = true, extractMetaTags = true, getLinkName = false;
+
+#ifdef DEBUG_TOKENIZER
+	cout &lt;&lt; &quot;HtmlTokenizer::parseHTML: start&quot; &lt;&lt; endl;
+#endif
+	// Prepare the regexps
+	if (regcomp(&amp;linksRegex, &quot;a(.*)href=(.*)&quot;, REG_EXTENDED|REG_ICASE) != 0)
+	{
+#ifdef DEBUG_TOKENIZER
+		cout &lt;&lt; &quot;HtmlTokenizer::parseHTML: couldn't compile links regexp&quot; &lt;&lt; endl;
+#endif
+		extractLinks = false;
+	}
+	if (regcomp(&amp;metaRegex, &quot;meta name=(.*) content=(.*)&quot;, REG_EXTENDED|REG_ICASE) != 0)
+	{
+#ifdef DEBUG_TOKENIZER
+		cout &lt;&lt; &quot;HtmlTokenizer::parseHTML: couldn't compile meta tag regexp&quot; &lt;&lt; endl;
+#endif
+		extractMetaTags = false;
+	}
+
+	// Tag start
+	string::size_type pos = str.find(&quot;&lt;&quot;);
+	while (pos != string::npos)
+	{
+		isHtml = true;
+
+		if (skip == false)
+		{
+			string text = str.substr(startPos, pos - startPos);
+			if (catText == true)
+			{
+				stripped += replaceEscapedCharacters(text);
+			}
+
+			// Is this part of the name of the last link we found ?
+			if (getLinkName == true)
+			{
+				linkName += text;
+#ifdef DEBUG_TOKENIZER
+				cout &lt;&lt; &quot;HtmlTokenizer::parseHTML: adding to name &quot; &lt;&lt; text &lt;&lt; endl;
+#endif
+			}
+
+			startPos = pos + 1;
+			// Tag end
+			if (str[pos] == '&lt;')
+			{
+				pos = str.find(&quot;&gt;&quot;, startPos);
+			}
+			// Skip stuff in the tag
+			skip = true;
+		}
+		else
+		{
+			regmatch_t pLinksMatches[3];
+			regmatch_t pMetaMatches[3];
+			int nLinksMatches = 3, nMetaMatches = 3;
+
+			// Found a tag from startPos to pos
+			string tag = str.substr(startPos, pos - startPos);
+			// Lower case the whole thing
+			tag = StringManip::toLowerCase(tag);
+			// Push it onto the stack
+			tagsStack.push(tag);
+#ifdef DEBUG_TOKENIZER
+			cout &lt;&lt; &quot;HtmlTokenizer::parseHTML: found &quot; &lt;&lt; tag &lt;&lt; endl;
+#endif
+
+			if ((extractMetaTags == true) &amp;&amp;
+				(regexec(&amp;metaRegex, tag.c_str(), nMetaMatches, pMetaMatches, 
+					REG_NOTBOL|REG_NOTEOL) == 0) &amp;&amp;
+				(pLinksMatches[nMetaMatches - 1].rm_so != -1))
+			{
+				string tmp, metaName, metaContent;
+
+				// META tag name
+				tmp = tag.substr(pMetaMatches[1].rm_so,
+					pMetaMatches[1].rm_eo - pMetaMatches[1].rm_so);
+				// Remove quotes
+				metaName = removeLinkQuotes(tmp);
+
+				// META tag content
+				tmp = tag.substr(pMetaMatches[2].rm_so,
+					pMetaMatches[2].rm_eo - pMetaMatches[2].rm_so);
+				// Remove quotes
+				metaContent = removeLinkQuotes(tmp);
+#ifdef DEBUG_TOKENIZER
+				cout &lt;&lt; &quot;HtmlTokenizer::parseHTML: found META tag &quot; &lt;&lt; metaName &lt;&lt; &quot;: &quot; &lt;&lt; metaContent &lt;&lt; endl;
+#endif
+				m_metaTags[metaName] = metaContent;
+			}
+			// See if this tag is an anchor
+			// pLinksMatches[0] will be something like 'a href=&quot;blah&quot;', pLinksMatches[1] will be ' ' and [2] will be '&quot;blah&quot;'
+			else if ((extractLinks == true) &amp;&amp;
+				(regexec(&amp;linksRegex, tag.c_str(), nLinksMatches, pLinksMatches, REG_NOTBOL|REG_NOTEOL) == 0) &amp;&amp;
+				(pLinksMatches[nLinksMatches - 1].rm_so != -1))
+			{
+				string quotedLink = tag.substr(pLinksMatches[2].rm_so,
+					pLinksMatches[2].rm_eo - pLinksMatches[2].rm_so);
+
+#ifdef DEBUG_TOKENIZER
+				cout &lt;&lt; &quot;HtmlTokenizer::parseHTML: found link start &quot; &lt;&lt; tag &lt;&lt; endl;
+#endif
+				if (link.empty() == false)
+				{
+					// The previous link's anchor's end couldn't be found ?
+					m_links.insert(Link(stripTags(link), linkName, m_linkPos, linkOpenPos, startPos - 1));
+					m_linkPos++;
+					linkName = &quot;&quot;;
+#ifdef DEBUG_TOKENIZER
+					cout &lt;&lt; &quot;HtmlTokenizer::parseHTML: previous link wasn't closed properly&quot; &lt;&lt; endl;
+#endif
+				}
+
+				// Remove quotes
+				link = removeLinkQuotes(quotedLink);
+				linkOpenPos = startPos - 1;
+
+				// Remember to get the name of the link
+				getLinkName = true;
+			}
+			// Maybe it's the anchor's end ?
+			else if ((extractLinks == true) &amp;&amp;
+				(tag == &quot;/a&quot;))
+			{
+				if (getLinkName == true)
+				{
+#ifdef DEBUG_TOKENIZER
+					cout &lt;&lt; &quot;HtmlTokenizer::parseHTML: &quot; &lt;&lt; pos &lt;&lt; &quot; link &quot; &lt;&lt; m_linkPos &lt;&lt; &quot; is &quot; &lt;&lt; link &lt;&lt; &quot;, name &quot; &lt;&lt; linkName &lt;&lt; endl;
+#endif
+					// New link
+					m_links.insert(Link(stripTags(link), linkName, m_linkPos, linkOpenPos, pos + 1));
+					m_linkPos++;
+					getLinkName = false;
+					link = linkName = &quot;&quot;;
+				}
+			}
+			else if (stripAllBlocks == false)
+			{
+				if (textBlockStart(tag) == true)
+				{
+					catText = true;
+#ifdef DEBUG_TOKENIZER
+					cout &lt;&lt; &quot;HtmlTokenizer::parseHTML: start text cat&quot; &lt;&lt; endl;
+#endif
+				}
+				else if (textBlockEnd(tag) == true)
+				{
+					catText = false;
+#ifdef DEBUG_TOKENIZER
+					cout &lt;&lt; &quot;HtmlTokenizer::parseHTML: end text cat&quot; &lt;&lt; endl;
+#endif
+				}
+				else
+				{
+					string parentTag = tagsStack.top();
+
+					if ((tag.substr(0, 6) == &quot;script&quot;) ||
+						(tag.substr(0, 5) == &quot;style&quot;))
+					{
+#ifdef DEBUG_TOKENIZER
+						cout &lt;&lt; &quot;HtmlTokenizer::parseHTML: skip script&quot; &lt;&lt; endl;
+#endif
+						catText = false;
+					}
+					else if (((tag.substr(0, 7) == &quot;/script&quot;) ||
+						(tag.substr(0, 6) == &quot;/style&quot;)) &amp;&amp;
+						(textBlockStart(parentTag) == false))
+					{
+#ifdef DEBUG_TOKENIZER
+						cout &lt;&lt; &quot;HtmlTokenizer::parseHTML: stop skip script&quot; &lt;&lt; endl;
+#endif
+						catText = true;
+					}
+				}
+			}
+
+			startPos = pos + 1;
+			pos = str.find(&quot;&lt;&quot;, startPos);
+			skip = false;
+		}
+	}
+	if ((startPos &lt; str.length()) &amp;&amp;
+		(catText == true))
+	{
+		stripped  += replaceEscapedCharacters(str.substr(startPos));
+	}
+
+	// Free the compiled regexps
+	regfree(&amp;linksRegex);
+	regfree(&amp;metaRegex);
+
+	if (isHtml == false)
+	{
+		return str;
+	}
+
+	return stripped;
+}
+
+/// Returns true if the tag corresponds to a text block.
+bool HtmlTokenizer::textBlockStart(const string &amp;tag)
+{
+	if ((tag.substr(0, 4) == &quot;body&quot;) ||
+		(tag.substr(0, 5) == &quot;title&quot;))
+	{
+		return true;
+	}
+
+	return false;
+}
+
+/// Returns true if the tag corresponds to the end of a text block.
+bool HtmlTokenizer::textBlockEnd(const string &amp;tag)
+{
+	if ((tag.substr(0, 5) == &quot;/body&quot;) ||
+		(tag.substr(0, 6) == &quot;/title&quot;))
+	{
+		return true;
+	}
+
+	return false;
+}
+
+/// Replaces escaped characters
+string HtmlTokenizer::replaceEscapedCharacters(const string &amp;str)
+{
+	// FIXME: replace all escaped characters !
+	static const char *escapedChars[] = { &quot;quot&quot;, &quot;amp&quot;, &quot;lt&quot;, &quot;gt&quot;, &quot;nbsp&quot;, &quot;eacute&quot;, &quot;egrave&quot;, &quot;agrave&quot;, &quot;ccedil&quot;};
+	static const char *unescapedChars[] = { &quot;\&quot;&quot;, &quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot; &quot;, &quot;e&quot;, &quot;e&quot;, &quot;a&quot;, &quot;c&quot;};
+	static const unsigned int escapedCharsCount = 9;
+	string unescaped;
+	string::size_type startPos = 0, pos = 0;
+
+#ifdef DEBUG_TOKENIZER
+	cout &lt;&lt; &quot;HtmlTokenizer::replaceEscapedCharacters: input &quot; &lt;&lt; str &lt;&lt; endl;
+#endif
+	pos = str.find(&quot;&amp;&quot;);
+	while (pos != string::npos)
+	{
+		unescaped += str.substr(startPos, pos - startPos);
+
+		startPos = pos + 1;
+		pos = str.find(&quot;;&quot;, startPos);
+		if ((pos != string::npos) &amp;&amp;
+			(pos &lt; startPos + 10))
+		{
+			string escapedChar = str.substr(startPos, pos - startPos);
+			bool replacedChar = false;
+
+			// See if we can replace this with an actual character
+			for (unsigned int count = 0; count &lt; escapedCharsCount; ++count)
+			{
+				if (escapedChar == escapedChars[count])
+				{
+					unescaped += unescapedChars[count];
+					replacedChar = true;
+					break;
+				}
+			}
+
+			if (replacedChar == false)
+			{
+				// This couldn't be replaced, leave it as it is...
+				unescaped += &quot;&amp;&quot;;
+				unescaped += escapedChar;
+				unescaped += &quot;;&quot;;
+			}
+
+			startPos = pos + 1;
+		}
+
+		// Next
+		pos = str.find(&quot;&amp;&quot;, startPos);
+	}
+	if (startPos &lt; str.length())
+	{
+		unescaped  += str.substr(startPos);
+	}
+#ifdef DEBUG_TOKENIZER
+	cout &lt;&lt; &quot;HtmlTokenizer::replaceEscapedCharacters: output &quot; &lt;&lt; unescaped &lt;&lt; endl;
+#endif
+
+	return unescaped;
+}
+
+/// Gets the specified META tag content.
+string HtmlTokenizer::getMetaTag(const string &amp;name)
+{
+	if (name.empty() == true)
+	{
+		return &quot;&quot;;
+	}
+
+	map&lt;string, string&gt;::const_iterator iter = m_metaTags.find(name);
+	if (iter != m_metaTags.end())
+	{
+		return iter-&gt;second;
+	}
+
+	return &quot;&quot;;
+}
+
+/// Gets the links map.
+set&lt;Link&gt; &amp;HtmlTokenizer::getLinks(void)
+{
+	return m_links;
+}
+
+/// Utility method that strips HTML tags off; the string without tags.
+string HtmlTokenizer::stripTags(const string &amp;str)
+{
+	HtmlTokenizer tokens;
+
+	return tokens.parseHTML(str, true);
+}
+
+Link::Link(const string &amp;url, const string &amp;name, unsigned int pos, unsigned int openPos, unsigned int closePos) :
+	m_url(url),
+	m_name(name),
+	m_pos(pos),
+	m_open(openPos),
+	m_close(closePos)
+{
+}
+
+Link::Link(const Link &amp;other) :
+	m_url(other.m_url),
+	m_name(other.m_name),
+	m_pos(other.m_pos),
+	m_open(other.m_open),
+	m_close(other.m_close)
+{
+}
+
+Link::~Link()
+{
+}
+
+Link&amp; Link::operator=(const Link&amp; other)
+{
+	m_url = other.m_url;
+	m_name = other.m_name;
+	m_pos = other.m_pos;
+	m_open = other.m_open;
+	m_close = other.m_close;
+
+	return *this;
+}
+
+bool Link::operator==(const Link &amp;other) const
+{
+	return m_url == other.m_url;
+}
+
+bool Link::operator&lt;(const Link &amp;other) const
+{
+	return m_pos &lt; other.m_pos;
+}


Property changes on: trunk/Tokenize/HtmlTokenizer.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/HtmlTokenizer.h
===================================================================
--- trunk/Tokenize/HtmlTokenizer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/HtmlTokenizer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,88 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _HTML_TOKENIZER_H
+#define _HTML_TOKENIZER_H
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;utility&gt;
+#include &lt;set&gt;
+
+#include &quot;Document.h&quot;
+#include &quot;Tokenizer.h&quot;
+
+using namespace std;
+
+class Link
+{
+	public:
+		Link(const string &amp;url, const string &amp;name, unsigned int pos, unsigned int openPos, unsigned int closePos);
+		Link(const Link &amp;other);
+		~Link();
+
+		Link&amp; operator=(const Link&amp; other);
+		bool operator==(const Link &amp;other) const;
+		bool operator&lt;(const Link &amp;other) const;
+
+		string m_url;
+		string m_name;
+		unsigned int m_pos;
+		unsigned int m_open;
+		unsigned int m_close;
+
+};
+
+class HtmlTokenizer : public Tokenizer
+{
+	public:
+		HtmlTokenizer(const Document *pDocument, unsigned int linksStartAtPos = 0);
+		virtual ~HtmlTokenizer();
+
+		/// Gets the specified META tag content; an empty string if it wasn't found.
+		string getMetaTag(const string &amp;name);
+
+		/// Gets the links map.
+		set&lt;Link&gt; &amp;getLinks(void);
+
+		/// Utility method that strips HTML tags off; the string without tags.
+		static string stripTags(const string &amp;str);
+
+	protected:
+		const Document *m_pHtmlDocument;
+		unsigned int m_linkPos;
+		map&lt;string, string&gt; m_metaTags;
+		set&lt;Link&gt; m_links;
+
+		HtmlTokenizer();
+
+		void initialize(const Document *pDocument);
+
+		/// Parses HTML; the string without tags.
+		string parseHTML(const string &amp;str, bool stripAllBlocks = false);
+
+		/// Returns true if the tag corresponds to a text block.
+		static bool textBlockStart(const string &amp;tag);
+
+		/// Returns true if the tag corresponds to the end of a text block.
+		static bool textBlockEnd(const string &amp;tag);
+
+		/// Replaces escaped characters
+		static string replaceEscapedCharacters(const string &amp;str);
+
+};
+
+#endif // _HTML_TOKENIZER_H


Property changes on: trunk/Tokenize/HtmlTokenizer.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/Makefile
===================================================================
--- trunk/Tokenize/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,42 @@
+
+ROOT_DIR = ..
+
+include ${ROOT_DIR}/variables.mk
+
+TOKENIZE_SRCS = Tokenizer.cpp HtmlTokenizer.cpp UnknownTypeTokenizer.cpp \
+	TokenizerFactory.cpp
+TOKENIZE_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${TOKENIZE_SRCS})
+
+TOKENIZER_TEST = ${BIN_DIR}/tokenizertest
+PDF_TOKENIZER_DL = ${LIB_DIR}/pdf_tokenizer.so
+WORD_TOKENIZER_DL = ${LIB_DIR}/word_tokenizer.so
+
+targets : dirs ${TOKENIZE_LIB} ${TOKENIZER_TEST} \
+	${PDF_TOKENIZER_DL} ${WORD_TOKENIZER_DL}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${TOKENIZE_LIB} ${TOKENIZER_TEST} \
+	${PDF_TOKENIZER_DL} ${WORD_TOKENIZER_DL}
+
+# Tokenize tester
+
+${TOKENIZER_TEST} : ${OBJ_DIR}/tokenizertest.o ${TOKENIZE_LIB}
+	@echo Building ${TOKENIZER_TEST}
+	${LINK} -o ${TOKENIZER_TEST} ${OBJ_DIR}/tokenizertest.o ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS}
+
+# Library
+
+${TOKENIZE_LIB} : ${TOKENIZE_OBJS}
+	@echo Building ${TOKENIZE_LIB}
+	${AR} cr ${TOKENIZE_LIB} ${TOKENIZE_OBJS}
+
+# Tokenizer libraries
+
+${PDF_TOKENIZER_DL} : ${OBJ_DIR}/PdfTokenizer.o
+	@echo Building ${PDF_TOKENIZER_DL}
+	${LINK} -shared -o ${PDF_TOKENIZER_DL} ${OBJ_DIR}/PdfTokenizer.o ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS} -ldl
+
+${WORD_TOKENIZER_DL} : ${OBJ_DIR}/WordTokenizer.o
+	@echo Building ${WORD_TOKENIZER_DL}
+	${LINK} -shared -o ${WORD_TOKENIZER_DL} ${OBJ_DIR}/WordTokenizer.o ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS} -ldl
+


Property changes on: trunk/Tokenize/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/PdfTokenizer.cpp
===================================================================
--- trunk/Tokenize/PdfTokenizer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/PdfTokenizer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,123 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;PdfTokenizer.h&quot;
+
+/**
+  * This returns the MIME type supported by the library's tokenizer.
+  * The character string is allocated with new[].
+  */
+char *getTokenizerType(void)
+{
+	char *pType = new char[16];
+
+	strncpy(pType, &quot;application/pdf&quot;, 15);
+	pType[15] = '\0';
+
+	return pType;
+}
+
+/// This returns a pointer to a Tokenizer, allocated with new.
+Tokenizer *getTokenizer(const Document *pDocument)
+{
+	return new PdfTokenizer(pDocument);
+}
+
+PdfTokenizer::PdfTokenizer(const Document *pDocument) :
+	HtmlTokenizer(NULL)
+{
+	char inTemplate[15] = &quot;/tmp/tokXXXXXX&quot;;
+	char outTemplate[15] = &quot;/tmp/tokXXXXXX&quot;;
+
+	int inFd = mkstemp(inTemplate);
+	int outFd = mkstemp(outTemplate);
+	if ((inFd != -1) &amp;&amp;
+		(outFd != -1))
+	{
+		unsigned int dataLength = 0;
+		const char *pData = pDocument-&gt;getData(dataLength);
+
+		// Save the data into a temporary file
+		if (write(inFd, (const void*)pData, dataLength) != -1)
+		{
+			// Run pdftohtml to convert it
+			string cmdLine = &quot;pdftohtml -stdout &quot;;
+			cmdLine += inTemplate;
+			cmdLine += &quot; &gt;&quot;;
+			cmdLine += outTemplate;
+			cmdLine += &quot; 2&gt;/dev/null&quot;;
+
+			if (system(cmdLine.c_str()) != -1)
+			{
+				struct stat fileStat;
+
+				// Read the output
+				if ((stat(outTemplate, &amp;fileStat) != -1) &amp;&amp;
+					(S_ISREG(fileStat.st_mode)))
+				{
+					unsigned int total, bytes;
+					char *content = new char[fileStat.st_size + 1];
+
+					total = bytes = read(outFd, (void*)content, fileStat.st_size);
+					while ((bytes &gt; 0) &amp;&amp;
+						(total &lt; fileStat.st_size))
+					{
+						bytes = read(outFd, (void*)content, fileStat.st_size - total);
+						total += bytes;
+					}
+
+					// Pass the result to the parent class
+					Document *pHtmlDoc = new Document(pDocument-&gt;getTitle(),
+						pDocument-&gt;getLocation(), pDocument-&gt;getType(),
+						pDocument-&gt;getLanguage());
+					pHtmlDoc-&gt;setData(content, bytes);
+					initialize(pHtmlDoc);
+#ifdef DEBUG
+					cout &lt;&lt; &quot;PdfTokenizer::ctor: set &quot; &lt;&lt; bytes &lt;&lt; &quot; bytes of data&quot; &lt;&lt; endl;
+#endif
+
+					delete[] content;
+				}
+			}
+		}
+	}
+
+	close(outFd);
+	close(inFd);
+
+	if ((unlink(outTemplate) != 0) ||
+		(unlink(inTemplate) != 0))
+	{
+#ifdef DEBUG
+		cerr &lt;&lt; &quot;PdfTokenizer::ctor: couldn't delete temporary files&quot; &lt;&lt; endl;
+#endif
+	}
+}
+
+PdfTokenizer::PdfTokenizer() :
+	HtmlTokenizer()
+{
+}
+
+PdfTokenizer::~PdfTokenizer()
+{
+}

Added: trunk/Tokenize/PdfTokenizer.h
===================================================================
--- trunk/Tokenize/PdfTokenizer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/PdfTokenizer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,53 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _PDF_TOKENIZER_H
+#define _PDF_TOKENIZER_H
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;utility&gt;
+#include &lt;set&gt;
+
+#include &quot;Document.h&quot;
+#include &quot;HtmlTokenizer.h&quot;
+
+using namespace std;
+
+/**
+  * This returns the MIME type supported by the library's tokenizer.
+  * The character string is allocated with new[].
+  */
+char *getTokenizerType(void);
+/// This returns a pointer to a Tokenizer, allocated with new.
+Tokenizer *getTokenizer(const Document *pDocument);
+
+class PdfTokenizer : public HtmlTokenizer
+{
+	public:
+		PdfTokenizer(const Document *pDocument);
+		virtual ~PdfTokenizer();
+
+	protected:
+		PdfTokenizer();
+
+	private:
+		PdfTokenizer(const PdfTokenizer &amp;other);
+		PdfTokenizer&amp; operator=(const PdfTokenizer&amp; other);
+
+};
+
+#endif // _PDF_TOKENIZER_H

Added: trunk/Tokenize/Tokenizer.cpp
===================================================================
--- trunk/Tokenize/Tokenizer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/Tokenizer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,125 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;ctype.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+
+#include &quot;Tokenizer.h&quot;
+
+//#define DEBUG_TOKENIZER
+
+Tokenizer::Tokenizer(const Document *pDocument)
+{
+	setDocument(pDocument);
+	rewind();
+}
+
+Tokenizer::~Tokenizer()
+{
+}
+
+void Tokenizer::setDocument(const Document *pDocument)
+{
+	m_pDocument = pDocument;
+}
+
+/**
+  * Returns a pointer to the document being tokenized.
+  * This may not be the document passed to the constructor.
+  */
+const Document *Tokenizer::getDocument(void)
+{
+	return m_pDocument;
+}
+
+/// Returns the next token; false if all tokens consumed.
+bool Tokenizer::nextToken(string &amp;token)
+{
+	bool bStarted = false;
+	unsigned int dataLength;
+	unsigned int pos = m_currentPos;
+
+	if (m_pDocument == NULL)
+	{
+#ifdef DEBUG_TOKENIZER
+		cout &lt;&lt; &quot;Tokenizer::nextToken: no document&quot; &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	const char *pData = m_pDocument-&gt;getData(dataLength);
+	if ((pData == NULL) ||
+		(dataLength == 0))
+	{
+#ifdef DEBUG_TOKENIZER
+		cout &lt;&lt; &quot;Tokenizer::nextToken: no data&quot; &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+#ifdef DEBUG_TOKENIZER
+	if (pos == 0)
+	{
+		ofstream tokData(&quot;TokenizerData.txt&quot;);
+		tokData &lt;&lt; pData &lt;&lt; endl;
+		tokData.close();
+	}
+#endif
+	while (pos &lt; dataLength)
+	{
+		if (isalnum(pData[pos]) != 0)
+		{
+			if (bStarted == false)
+			{
+				// This starts the new token
+				token = pData[pos];
+				bStarted = true;
+			}
+			else
+			{
+				// Append to token
+				token += pData[pos];
+			}
+		}
+		else
+		{
+			if (bStarted == true)
+			{
+#ifdef DEBUG_TOKENIZER
+				cout &lt;&lt; &quot;Tokenizer::nextToken: returning current token &quot; &lt;&lt; token &lt;&lt; endl;
+#endif
+				// Return the current token
+				break;
+			}
+			// Else keep going until we find an alnum
+		}
+
+		// Next
+		pos++;
+	}
+	m_currentPos = pos;
+
+	return bStarted;
+}
+
+/// Rewinds the tokenizer.
+void Tokenizer::rewind(void)
+{
+	m_currentPos = 0;
+}
+


Property changes on: trunk/Tokenize/Tokenizer.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/Tokenizer.h
===================================================================
--- trunk/Tokenize/Tokenizer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/Tokenizer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,53 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TOKENIZER_H
+#define _TOKENIZER_H
+
+#include &lt;string&gt;
+
+#include &quot;Document.h&quot;
+
+using namespace std;
+
+class Tokenizer
+{
+	public:
+		Tokenizer(const Document *pDocument);
+		virtual ~Tokenizer();
+
+		/// Returns a pointer to the document being tokenized.
+		virtual const Document *getDocument(void);
+
+		/// Returns the next token; false if all tokens consumed.
+		virtual bool nextToken(string &amp;token);
+
+		/// Rewinds the tokenizer.
+		virtual void rewind(void);
+
+	protected:
+		const Document *m_pDocument;
+		unsigned int m_currentPos;
+
+		void setDocument(const Document *pDocument);
+
+	private:
+		Tokenizer(const Tokenizer &amp;other);
+		Tokenizer&amp; operator=(const Tokenizer&amp; other);
+
+};
+
+#endif // _TOKENIZER_H


Property changes on: trunk/Tokenize/Tokenizer.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/TokenizerFactory.cpp
===================================================================
--- trunk/Tokenize/TokenizerFactory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/TokenizerFactory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,295 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;ctype.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;dirent.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;strings.h&gt;
+#include &lt;dlfcn.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;MIMEScanner.h&quot;
+#include &quot;Tokenizer.h&quot;
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;UnknownTypeTokenizer.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;TokenizerFactory.h&quot;
+
+#define GETTOKENIZER		&quot;_Z12getTokenizerPK8Document&quot;
+#define GETTOKENIZERTYPE	&quot;_Z16getTokenizerTypev&quot;
+
+using std::cout;
+using std::endl;
+
+map&lt;string, string&gt; TokenizerFactory::m_types;
+map&lt;string, void *&gt; TokenizerFactory::m_handles;
+
+TokenizerFactory::TokenizerFactory()
+{
+}
+
+TokenizerFactory::~TokenizerFactory()
+{
+}
+
+Tokenizer *TokenizerFactory::getLibraryTokenizer(const string &amp;type, const Document *pDocument)
+{
+	void *pHandle = NULL;
+
+	if (m_handles.empty() == true)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;TokenizerFactory::getLibraryTokenizer: no libraries&quot; &lt;&lt; endl;
+#endif
+		return NULL;
+	}
+
+	map&lt;string, string&gt;::iterator typeIter = m_types.find(type);
+	if (typeIter == m_types.end())
+	{
+		// We don't know about this type
+		return NULL;
+	}
+	map&lt;string, void *&gt;::iterator handleIter = m_handles.find(typeIter-&gt;second);
+	if (handleIter == m_handles.end())
+	{
+		// We don't know about this library
+		return NULL;
+	}
+	pHandle = handleIter-&gt;second;
+	if (pHandle == NULL)
+	{
+		return NULL;
+	}
+
+	// Get a tokenizer object then
+	getTokenizerFunc *pFunc = (getTokenizerFunc *)dlsym(pHandle,
+		GETTOKENIZER);
+	if (pFunc != NULL)
+	{
+		return (*pFunc)(pDocument);
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;TokenizerFactory::getLibraryTokenizer: couldn't find export getTokenizer&quot; &lt;&lt; endl;
+#endif
+
+	return NULL;
+}
+
+/// Loads the tokenizer libraries in the given directory.
+unsigned int TokenizerFactory::loadTokenizers(const string &amp;dirName)
+{
+	struct stat fileStat;
+	unsigned int count = 0;
+
+	if (dirName.empty() == true)
+	{
+		return 0;
+	}
+
+	if (stat(dirName.c_str(), &amp;fileStat) == -1)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;TokenizerFactory::loadTokenizers: &quot;
+			&lt;&lt; dirName &lt;&lt; &quot; doesn't exist&quot; &lt;&lt; endl;
+#endif
+		return 0;
+	}
+
+	// Is it a file or a directory ?
+	if (S_ISDIR(fileStat.st_mode))
+	{
+		// A directory : scan it
+		DIR *pDir = opendir(dirName.c_str());
+		if (pDir == NULL)
+		{
+			return 0;
+		}
+
+		// Iterate through this directory's entries
+		struct dirent *pDirEntry = readdir(pDir);
+		while (pDirEntry != NULL)
+		{
+			char *pEntryName = pDirEntry-&gt;d_name;
+			if (pEntryName != NULL)
+			{
+				string fileName = pEntryName;
+				string::size_type extPos = fileName.find_last_of(&quot;.&quot;);
+
+				if ((extPos == string::npos) ||
+					(fileName.substr(extPos) != &quot;.so&quot;))
+				{
+					// Next entry
+					pDirEntry = readdir(pDir);
+					continue;
+				}
+
+				fileName = dirName;
+				fileName += &quot;/&quot;;
+				fileName += pEntryName;
+
+				// Check this entry
+				if ((stat(fileName.c_str(), &amp;fileStat) == 0) &amp;&amp;
+					(S_ISREG(fileStat.st_mode)))
+				{
+					void *pHandle = dlopen(fileName.c_str(), RTLD_LAZY);
+					if (pHandle != NULL)
+					{
+						// What type does this support ?
+						getTokenizerTypeFunc *pFunc = (getTokenizerTypeFunc *)dlsym(pHandle,
+								GETTOKENIZERTYPE);
+						if (pFunc != NULL)
+						{
+							char *pSupportedType = (*pFunc)();
+							if (pSupportedType != NULL)
+							{
+								// Add records for this tokenizer
+								m_types[pSupportedType] = fileName;
+								m_handles[fileName] = pHandle;
+								++count;
+
+#ifdef DEBUG
+								cout &lt;&lt; &quot;TokenizerFactory::loadTokenizers: type &quot;
+									&lt;&lt; pSupportedType &lt;&lt; &quot; supported by &quot; &lt;&lt; pEntryName &lt;&lt; endl;
+#endif
+
+								// It's supposed to have been allocated with new[]
+								delete[] pSupportedType;
+							}
+						}
+#ifdef DEBUG
+						else cout &lt;&lt; &quot;TokenizerFactory::loadTokenizers: couldn't find export getTokenizerType&quot; &lt;&lt; endl;
+#endif
+					}
+				}
+#ifdef DEBUG
+				else cout &lt;&lt; &quot;TokenizerFactory::loadTokenizers: &quot;
+					&lt;&lt; pEntryName &lt;&lt; &quot; is not a file&quot; &lt;&lt; endl;
+#endif
+			}
+
+			// Next entry
+			pDirEntry = readdir(pDir);
+		}
+
+		closedir(pDir);
+	}
+#ifdef DEBUG
+	else cout &lt;&lt; &quot;TokenizerFactory::loadTokenizers: &quot;
+		&lt;&lt; dirName &lt;&lt; &quot; is not a directory&quot; &lt;&lt; endl;
+#endif
+
+	return count;
+}
+
+/// Unloads all tokenizer libraries.
+void TokenizerFactory::unloadTokenizers(void)
+{
+	for (map&lt;string, void*&gt;::iterator iter = m_handles.begin(); iter != m_handles.end(); ++iter)
+	{
+		if (dlclose(iter-&gt;second) != 0)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;TokenizerFactory::unloadTokenizers: failed on &quot; &lt;&lt; iter-&gt;first &lt;&lt; endl;
+#endif
+		}
+	}
+
+	m_types.clear();
+	m_handles.clear();
+}
+
+/// Returns a Tokenizer that handles the given file's type; NULL if unavailable.
+Tokenizer *TokenizerFactory::getTokenizer(const string &amp;fileName, const Document *pDocument)
+{
+	string type = MIMEScanner::scanFile(fileName);
+
+	return getTokenizerByType(type, pDocument);
+}
+
+/// Returns a Tokenizer that handles the given MIME type; NULL if unavailable.
+Tokenizer *TokenizerFactory::getTokenizerByType(const string &amp;type, const Document *pDocument)
+{
+	string typeOnly = type;
+	string::size_type semiColonPos = type.find(&quot;;&quot;);
+
+	// Remove the charset, if any
+	if (semiColonPos != string::npos)
+	{
+		typeOnly = type.substr(0, semiColonPos);
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;TokenizerFactory::getTokenizerByType: file type is &quot; &lt;&lt; typeOnly &lt;&lt; endl;
+#endif
+
+	if (typeOnly == &quot;text/html&quot;)
+	{
+		return new HtmlTokenizer(pDocument);
+	}
+	else if (typeOnly == &quot;text/plain&quot;)
+	{
+		return new Tokenizer(pDocument);
+	}
+
+	Tokenizer *pTokenizer = getLibraryTokenizer(typeOnly, pDocument);
+	if (pTokenizer == NULL)
+	{
+		if (strncasecmp(typeOnly.c_str(), &quot;text&quot;, 4) == 0)
+		{
+			// Use this by default for text documents
+			return new Tokenizer(pDocument);
+		}
+
+		return new UnknownTypeTokenizer(pDocument);
+	}
+
+	return pTokenizer;
+}
+
+bool TokenizerFactory::isSupportedType(const string &amp;type)
+{
+	string typeOnly = type;
+	string::size_type semiColonPos = type.find(&quot;;&quot;);
+
+	// Remove the charset, if any
+	if (semiColonPos != string::npos)
+	{
+		typeOnly = type.substr(0, semiColonPos);
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;TokenizerFactory::isSupportedType: file type is &quot; &lt;&lt; typeOnly &lt;&lt; endl;
+#endif
+
+	// Is it a built-in type ?
+	if ((typeOnly == &quot;text/html&quot;) ||
+		(strncasecmp(typeOnly.c_str(), &quot;text&quot;, 4) == 0))
+	{
+		return true;
+	}
+
+	// Is it a type supported by a library ?
+	map&lt;string, string&gt;::iterator typeIter = m_types.find(typeOnly);
+	if (typeIter != m_types.end())
+	{
+		return true;
+	}
+
+	return false;
+}
+


Property changes on: trunk/Tokenize/TokenizerFactory.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/TokenizerFactory.h
===================================================================
--- trunk/Tokenize/TokenizerFactory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/TokenizerFactory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,70 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TOKENIZER_FACTORY_H
+#define _TOKENIZER_FACTORY_H
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+
+#include &quot;Tokenizer.h&quot;
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+
+class TokenizerFactory
+{
+	public:
+		virtual ~TokenizerFactory();
+
+		/**
+		  * This returns the MIME type supported by the library's tokenizer.
+		  * The character string is allocated with new[].
+		  */
+		typedef char *(getTokenizerTypeFunc)(void);
+		/// This returns a pointer to a Tokenizer, allocated with new.
+		typedef Tokenizer *(getTokenizerFunc)(const Document *);
+
+		/// Loads the tokenizer libraries in the given directory.
+		static unsigned int loadTokenizers(const string &amp;dirName);
+
+		/// Returns a Tokenizer that handles the given file's type; NULL if unavailable.
+		static Tokenizer *getTokenizer(const string &amp;fileName, const Document *pDocument);
+
+		/// Returns a Tokenizer that handles the given MIME type; NULL if unavailable.
+		static Tokenizer *getTokenizerByType(const string &amp;type, const Document *pDocument);
+
+		/// Indicates whether a MIME type is supported or not.
+		static bool isSupportedType(const string &amp;type);
+
+		/// Unloads all tokenizer libraries.
+		static void unloadTokenizers(void);
+
+	protected:
+		static map&lt;string, string&gt; m_types;
+		static map&lt;string, void *&gt; m_handles;
+
+		TokenizerFactory();
+
+		static Tokenizer *getLibraryTokenizer(const string &amp;type, const Document *pDocument);
+
+	private:
+		TokenizerFactory(const TokenizerFactory &amp;other);
+		TokenizerFactory&amp; operator=(const TokenizerFactory&amp; other);
+
+};
+
+#endif // _TOKENIZER_FACTORY_H


Property changes on: trunk/Tokenize/TokenizerFactory.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/UnknownTypeTokenizer.cpp
===================================================================
--- trunk/Tokenize/UnknownTypeTokenizer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/UnknownTypeTokenizer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,105 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;UnknownTypeTokenizer.h&quot;
+
+using namespace std;
+
+UnknownTypeTokenizer::UnknownTypeTokenizer(const Document *pDocument) :
+	Tokenizer(NULL)
+{
+	char inTemplate[15] = &quot;/tmp/tokXXXXXX&quot;;
+	char outTemplate[15] = &quot;/tmp/tokXXXXXX&quot;;
+
+	int inFd = mkstemp(inTemplate);
+	int outFd = mkstemp(outTemplate);
+	if ((inFd != -1) &amp;&amp;
+		(outFd != -1))
+	{
+		unsigned int dataLength = 0;
+		const char *pData = pDocument-&gt;getData(dataLength);
+
+		// Save the data into a temporary file
+		if (write(inFd, (const void*)pData, dataLength) != -1)
+		{
+			// Run strings against it to extract printable characters
+			string cmdLine = &quot;strings --bytes=6 &quot;;
+			cmdLine += inTemplate;
+			cmdLine += &quot;&gt;&quot;;
+			cmdLine += outTemplate;
+			
+			if (system(cmdLine.c_str()) != -1)
+			{
+				struct stat fileStat;
+
+				// Read the output
+				if ((stat(outTemplate, &amp;fileStat) != -1) &amp;&amp;
+					(S_ISREG(fileStat.st_mode)))
+				{
+					unsigned int total, bytes;
+					char *content = new char[fileStat.st_size + 1];
+
+					total = bytes = read(outFd, (void*)content, fileStat.st_size);
+					while ((bytes &gt; 0) &amp;&amp;
+						(total &lt; fileStat.st_size))
+					{
+						bytes = read(outFd, (void*)content, fileStat.st_size - total);
+						total += bytes;
+					}
+
+					// Pass the result to the parent class
+					Document *pStrippedDoc = new Document(pDocument-&gt;getTitle(),
+						pDocument-&gt;getLocation(), pDocument-&gt;getType(),
+						pDocument-&gt;getLanguage());
+					pStrippedDoc-&gt;setData(content, bytes);
+					setDocument(pStrippedDoc);
+#ifdef DEBUG
+					cout &lt;&lt; &quot;UnknownTypeTokenizer::ctor: set &quot; &lt;&lt; bytes &lt;&lt; &quot; bytes of data&quot; &lt;&lt; endl;
+#endif
+
+					delete[] content;
+				}
+			}
+		}
+	}
+
+	close(outFd);
+	close(inFd);
+
+	if ((unlink(outTemplate) != 0) ||
+		(unlink(inTemplate) != 0))
+	{
+#ifdef DEBUG
+		cerr &lt;&lt; &quot;UnknownTypeTokenizer::ctor: couldn't delete temporary files&quot; &lt;&lt; endl;
+#endif
+	}
+}
+
+UnknownTypeTokenizer::~UnknownTypeTokenizer()
+{
+	if (m_pDocument != NULL)
+	{
+		// This should have been set by setDocument(),
+		// called by the constructor
+		delete m_pDocument;
+	}
+}


Property changes on: trunk/Tokenize/UnknownTypeTokenizer.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/UnknownTypeTokenizer.h
===================================================================
--- trunk/Tokenize/UnknownTypeTokenizer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/UnknownTypeTokenizer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,36 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _UNKNOWN_TYPE_TOKENIZER_H
+#define _UNKNOWN_TYPE_TOKENIZER_H
+
+#include &quot;Tokenizer.h&quot;
+
+using namespace std;
+
+class UnknownTypeTokenizer : public Tokenizer
+{
+	public:
+		UnknownTypeTokenizer(const Document *pDocument);
+		virtual ~UnknownTypeTokenizer();
+
+	private:
+		UnknownTypeTokenizer(const UnknownTypeTokenizer &amp;other);
+		UnknownTypeTokenizer&amp; operator=(const UnknownTypeTokenizer&amp; other);
+
+};
+
+#endif // _UNKNOWN_TYPE_TOKENIZER_H


Property changes on: trunk/Tokenize/UnknownTypeTokenizer.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/WordTokenizer.cpp
===================================================================
--- trunk/Tokenize/WordTokenizer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/WordTokenizer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,123 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;WordTokenizer.h&quot;
+
+/**
+  * This returns the MIME type supported by the library's tokenizer.
+  * The character string is allocated with new[].
+  */
+char *getTokenizerType(void)
+{
+	char *pType = new char[16];
+
+	strncpy(pType, &quot;application/msword&quot;, 18);
+	pType[18] = '\0';
+
+	return pType;
+}
+
+/// This returns a pointer to a Tokenizer, allocated with new.
+Tokenizer *getTokenizer(const Document *pDocument)
+{
+	return new WordTokenizer(pDocument);
+}
+
+WordTokenizer::WordTokenizer(const Document *pDocument) :
+	Tokenizer(NULL)
+{
+	char inTemplate[15] = &quot;/tmp/tokXXXXXX&quot;;
+	char outTemplate[15] = &quot;/tmp/tokXXXXXX&quot;;
+
+	int inFd = mkstemp(inTemplate);
+	int outFd = mkstemp(outTemplate);
+	if ((inFd != -1) &amp;&amp;
+		(outFd != -1))
+	{
+		unsigned int dataLength = 0;
+		const char *pData = pDocument-&gt;getData(dataLength);
+
+		// Save the data into a temporary file
+		if (write(inFd, (const void*)pData, dataLength) != -1)
+		{
+			// Run antiword to convert it
+			string cmdLine = &quot;antiword &quot;;
+			cmdLine += inTemplate;
+			cmdLine += &quot; &gt;&quot;;
+			cmdLine += outTemplate;
+			cmdLine += &quot; 2&gt;/dev/null&quot;;
+			
+			if (system(cmdLine.c_str()) != -1)
+			{
+				struct stat fileStat;
+
+				// Read the output
+				if ((stat(outTemplate, &amp;fileStat) != -1) &amp;&amp;
+					(S_ISREG(fileStat.st_mode)))
+				{
+					unsigned int total, bytes;
+					char *content = new char[fileStat.st_size + 1];
+
+					total = bytes = read(outFd, (void*)content, fileStat.st_size);
+					while ((bytes &gt; 0) &amp;&amp;
+						(total &lt; fileStat.st_size))
+					{
+						bytes = read(outFd, (void*)content, fileStat.st_size - total);
+						total += bytes;
+					}
+
+					// Pass the result to the parent class
+					Document *pDoc = new Document(pDocument-&gt;getTitle(),
+						pDocument-&gt;getLocation(), pDocument-&gt;getType(),
+						pDocument-&gt;getLanguage());
+					pDoc-&gt;setData(content, bytes);
+					setDocument(pDoc);
+#ifdef DEBUG
+					cout &lt;&lt; &quot;WordTokenizer::ctor: set &quot; &lt;&lt; bytes &lt;&lt; &quot; bytes of data&quot; &lt;&lt; endl;
+#endif
+
+					delete[] content;
+				}
+			}
+		}
+	}
+
+	close(outFd);
+	close(inFd);
+
+	if ((unlink(outTemplate) != 0) ||
+		(unlink(inTemplate) != 0))
+	{
+#ifdef DEBUG
+		cerr &lt;&lt; &quot;WordTokenizer::ctor: couldn't delete temporary files&quot; &lt;&lt; endl;
+#endif
+	}
+}
+
+WordTokenizer::~WordTokenizer()
+{
+	if (m_pDocument != NULL)
+	{
+		// This should have been set by setDocument()
+		delete m_pDocument;
+	}
+}

Added: trunk/Tokenize/WordTokenizer.h
===================================================================
--- trunk/Tokenize/WordTokenizer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/WordTokenizer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,50 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _WORD_TOKENIZER_H
+#define _WORD_TOKENIZER_H
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;utility&gt;
+#include &lt;set&gt;
+
+#include &quot;Document.h&quot;
+#include &quot;Tokenizer.h&quot;
+
+using namespace std;
+
+/**
+  * This returns the MIME type supported by the library's tokenizer.
+  * The character string is allocated with new[].
+  */
+char *getTokenizerType(void);
+/// This returns a pointer to a Tokenizer, allocated with new.
+Tokenizer *getTokenizer(const Document *pDocument);
+
+class WordTokenizer : public Tokenizer
+{
+	public:
+		WordTokenizer(const Document *pDocument);
+		virtual ~WordTokenizer();
+
+	private:
+		WordTokenizer(const WordTokenizer &amp;other);
+		WordTokenizer&amp; operator=(const WordTokenizer&amp; other);
+
+};
+
+#endif // _WORD_TOKENIZER_H

Added: trunk/Tokenize/tokenizertest.cpp
===================================================================
--- trunk/Tokenize/tokenizertest.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/tokenizertest.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,136 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+#include &lt;string&gt;
+
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;UnknownTypeTokenizer.h&quot;
+#include &quot;TokenizerFactory.h&quot;
+#include &quot;StringManip.h&quot;
+
+using namespace std;
+
+int main(int argc, char **argv)
+{
+	if (argc &lt; 3)
+	{
+		cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;file name&gt; RAWDATA|STRIP|LISTLINKS|LISTTOKENS|META=&lt;meta tag name&gt;|SUBSTR=&lt;sub-string&gt; [TYPE=&lt;type&gt;]&quot; &lt;&lt; endl;
+		return EXIT_FAILURE;
+	}
+
+	Document doc;
+	if (doc.setDataFromFile(argv[1]) == false)
+	{
+		cerr &lt;&lt; &quot;Couldn't load &quot; &lt;&lt; argv[1] &lt;&lt; &quot; !&quot; &lt;&lt; endl;
+		return EXIT_FAILURE;
+	}
+
+	Tokenizer *pTokens = NULL;
+	// How shall we get the tokenizer ?
+	if ((argc &gt;= 4) &amp;&amp;
+		(strncmp(argv[3], &quot;TYPE=&quot;, 5) == 0))
+	{
+		// By type
+		pTokens = TokenizerFactory::getTokenizerByType(argv[3] + 5, &amp;doc);
+	}
+	else
+	{
+		pTokens = TokenizerFactory::getTokenizer(argv[1], &amp;doc);
+	}
+
+	if (pTokens == NULL)
+	{
+		cerr &lt;&lt; &quot;Couldn't obtain tokenizer for &quot; &lt;&lt; argv[1] &lt;&lt; &quot; !&quot; &lt;&lt; endl;
+		return EXIT_FAILURE;
+	}
+
+	HtmlTokenizer *pHtmlTokens = dynamic_cast&lt;HtmlTokenizer*&gt;(pTokens);
+
+	const Document *pDoc = NULL;
+	unsigned int length = 0;
+
+	if (strncmp(argv[2], &quot;RAWDATA&quot;, 5) == 0)
+	{
+		// Call the base class's method
+		pDoc = pTokens-&gt;Tokenizer::getDocument();
+		if (pDoc != NULL)
+		{
+			cout &lt;&lt; &quot;Raw text is :&quot; &lt;&lt; endl;
+			cout &lt;&lt; pDoc-&gt;getData(length) &lt;&lt; endl;
+		}
+	}
+	else if (strncmp(argv[2], &quot;STRIP&quot;, 5) == 0)
+	{
+		const char *pData = doc.getData(length);
+
+		cout &lt;&lt; &quot;Stripped text is :&quot; &lt;&lt; endl;
+		cout &lt;&lt; HtmlTokenizer::stripTags(string(pData, length)) &lt;&lt; endl;
+	}
+	else if ((strncmp(argv[2], &quot;LISTLINKS&quot;, 9) == 0) &amp;&amp;
+		(pHtmlTokens != NULL))
+	{
+		// Get a list of links
+		set&lt;Link&gt; &amp;links = pHtmlTokens-&gt;getLinks();
+		if (links.empty() == false)
+		{
+			set&lt;Link&gt;::iterator iter;
+			for(iter = links.begin(); iter != links.end(); iter++)
+			{
+				cout &lt;&lt; &quot;Found link \&quot;&quot; &lt;&lt; iter-&gt;m_name &lt;&lt; &quot;\&quot; to &quot; &lt;&lt; iter-&gt;m_url &lt;&lt; endl;
+			}
+		}
+		else
+		{
+			cout &lt;&lt; &quot;No links were found in &quot; &lt;&lt; argv[1] &lt;&lt; endl;
+		}
+	}
+	else if (strncmp(argv[2], &quot;LISTTOKENS&quot;, 10) == 0)
+	{
+		string token;
+		cout &lt;&lt; &quot;Tokens are :&quot; &lt;&lt; endl;
+		while (pTokens-&gt;nextToken(token) == true)
+		{
+			cout &lt;&lt; token &lt;&lt; endl;
+		}
+	}
+	else if ((strncmp(argv[2], &quot;META=&quot;, 5) == 0) &amp;&amp;
+		(pHtmlTokens != NULL))
+	{
+		string metaTag = argv[2] + 5;
+		cout &lt;&lt; &quot;Meta tag &quot; &lt;&lt; metaTag &lt;&lt; &quot; was set to &quot; &lt;&lt; pHtmlTokens-&gt;getMetaTag(metaTag) &lt;&lt; endl;
+	}
+	else if ((strncmp(argv[2], &quot;SUBSTR=&quot;, 7) == 0) &amp;&amp;
+		(pHtmlTokens != NULL))
+	{
+		string subString = argv[2] + 7;
+
+		pDoc = pTokens-&gt;getDocument();
+		if (pDoc != NULL)
+		{
+			cout &lt;&lt; &quot;Replaced sub-string &quot; &lt;&lt; subString &lt;&lt; &quot; with 'Hello'&quot; &lt;&lt; endl;
+			cout &lt;&lt; StringManip::replaceSubString(pDoc-&gt;getData(length), subString, &quot;Hello&quot;) &lt;&lt; endl;
+		}
+	}
+
+	delete pTokens;
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/Tokenize/tokenizertest.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/config.h
===================================================================
--- trunk/UI/GTK2/config.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/config.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,91 @@
+/* config.h.  Generated by configure.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
+// generated 2003/5/18 21:15:37 BST by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.0.0
+
+/* acconfig.h
+ * This file is in the public domain.
+ *
+ * Descriptive text for the C preprocessor macros that
+ * the distributed Autoconf macros can define.
+ * These entries are sometimes used by macros
+ * which glade-- uses.
+ */
+#define PACKAGE &quot;pinot&quot;
+#define ENABLE_NLS 1
+/* #undef HAVE_CATGETS */
+#define HAVE_GETTEXT 1
+#define HAVE_LC_MESSAGES 1
+/* #undef HAVE_STPCPY */
+/* #undef HAVE_LIBSM */
+#define PACKAGE_LOCALE_DIR &quot;/usr/share/locale&quot;
+#define GETTEXT_PACKAGE &quot;pinot&quot;
+
+/* always defined to indicate that i18n is enabled */
+#define ENABLE_NLS 1
+
+/* Define to 1 if you have the `bind_textdomain_codeset' function. */
+#define HAVE_BIND_TEXTDOMAIN_CODESET 1
+
+/* Define to 1 if you have the `dcgettext' function. */
+#define HAVE_DCGETTEXT 1
+
+/* Define to 1 if you have the &lt;dlfcn.h&gt; header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+#define HAVE_GETTEXT 1
+
+/* Define to 1 if you have the &lt;inttypes.h&gt; header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define if your &lt;locale.h&gt; file defines LC_MESSAGES. */
+#define HAVE_LC_MESSAGES 1
+
+/* Define to 1 if you have the &lt;locale.h&gt; header file. */
+#define HAVE_LOCALE_H 1
+
+/* Define to 1 if you have the &lt;memory.h&gt; header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the &lt;stdint.h&gt; header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the &lt;stdlib.h&gt; header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the &lt;strings.h&gt; header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the &lt;string.h&gt; header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the &lt;sys/stat.h&gt; header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the &lt;sys/types.h&gt; header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the &lt;unistd.h&gt; header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT &quot;&quot;
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME &quot;Pinot&quot;
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING &quot;Pinot v0.30&quot;
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME &quot;pinot-0.30.tar.gz&quot;
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION &quot;0.30&quot;
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION &quot;0.30&quot;

Added: trunk/UI/GTK2/metase-gtk2.glade
===================================================================
--- trunk/UI/GTK2/metase-gtk2.glade	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/metase-gtk2.glade	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,4086 @@
+&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt; &lt;!--*- mode: xml -*--&gt;
+&lt;!DOCTYPE glade-interface SYSTEM &quot;<A HREF="http://glade.gnome.org/glade-2.0.dtd">http://glade.gnome.org/glade-2.0.dtd</A>&quot;&gt;
+
+&lt;glade-interface&gt;
+
+&lt;widget class=&quot;GtkWindow&quot; id=&quot;mainWindow&quot;&gt;
+  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;public&lt;/property&gt;
+  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;events&quot;&gt;GDK_BUTTON_PRESS_MASK&lt;/property&gt;
+  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;Pinot&lt;/property&gt;
+  &lt;property name=&quot;type&quot;&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
+  &lt;property name=&quot;window_position&quot;&gt;GTK_WIN_POS_NONE&lt;/property&gt;
+  &lt;property name=&quot;modal&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;default_width&quot;&gt;400&lt;/property&gt;
+  &lt;property name=&quot;resizable&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;destroy_with_parent&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;decorated&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;skip_taskbar_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;skip_pager_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;type_hint&quot;&gt;GDK_WINDOW_TYPE_HINT_NORMAL&lt;/property&gt;
+  &lt;property name=&quot;gravity&quot;&gt;GDK_GRAVITY_NORTH_WEST&lt;/property&gt;
+  &lt;property name=&quot;focus_on_map&quot;&gt;True&lt;/property&gt;
+  &lt;signal name=&quot;delete_event&quot; handler=&quot;on_mainWindow_delete_event&quot; last_modification_time=&quot;Sat, 17 May 2003 11:06:56 GMT&quot;/&gt;
+
+  &lt;child&gt;
+    &lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox1&quot;&gt;
+      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkMenuBar&quot; id=&quot;mainMenubar&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;sessionMenuitem&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Session&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkMenu&quot; id=&quot;sessionMenuitem_menu&quot;&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkImageMenuItem&quot; id=&quot;configure1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot;&gt;gtk-preferences&lt;/property&gt;
+		      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_configure_activate&quot; last_modification_time=&quot;Fri, 20 Feb 2004 18:58:55 GMT&quot;/&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkSeparatorMenuItem&quot; id=&quot;separatormenuitem1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkImageMenuItem&quot; id=&quot;quit1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot;&gt;gtk-quit&lt;/property&gt;
+		      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_quit_activate&quot; last_modification_time=&quot;Fri, 20 Feb 2004 18:57:09 GMT&quot;/&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;editMenuitem&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Edit&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkMenu&quot; id=&quot;editMenuitem_menu&quot;&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkImageMenuItem&quot; id=&quot;cut1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot;&gt;gtk-cut&lt;/property&gt;
+		      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_cut_activate&quot; last_modification_time=&quot;Mon, 12 Apr 2004 09:32:03 GMT&quot;/&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkImageMenuItem&quot; id=&quot;copy1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot;&gt;gtk-copy&lt;/property&gt;
+		      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_copy_activate&quot; last_modification_time=&quot;Fri, 20 Feb 2004 18:57:09 GMT&quot;/&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkImageMenuItem&quot; id=&quot;paste1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot;&gt;gtk-paste&lt;/property&gt;
+		      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_paste_activate&quot; last_modification_time=&quot;Fri, 20 Feb 2004 18:57:09 GMT&quot;/&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkImageMenuItem&quot; id=&quot;delete1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot;&gt;gtk-delete&lt;/property&gt;
+		      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_delete_activate&quot; last_modification_time=&quot;Mon, 12 Apr 2004 09:32:03 GMT&quot;/&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;resultsMenuitem&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Results&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkMenu&quot; id=&quot;resultsMenuitem_menu&quot;&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkImageMenuItem&quot; id=&quot;clearresults1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Clear List&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_clearresults_activate&quot; last_modification_time=&quot;Wed, 03 Mar 2004 19:51:48 GMT&quot;/&gt;
+
+		      &lt;child internal-child=&quot;image&quot;&gt;
+			&lt;widget class=&quot;GtkImage&quot; id=&quot;image514&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;stock&quot;&gt;gtk-clear&lt;/property&gt;
+			  &lt;property name=&quot;icon_size&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkCheckMenuItem&quot; id=&quot;showextract1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Show Extract&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;active&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_showextract_activate&quot; last_modification_time=&quot;Thu, 03 Jun 2004 17:22:31 GMT&quot;/&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;groupresults1&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Group By&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkMenu&quot; id=&quot;groupresults1_menu&quot;&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkRadioMenuItem&quot; id=&quot;searchenginegroup1&quot;&gt;
+			      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Search Engine&lt;/property&gt;
+			      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;active&quot;&gt;True&lt;/property&gt;
+			      &lt;signal name=&quot;activate&quot; handler=&quot;on_groupresults_activate&quot; last_modification_time=&quot;Sat, 28 Feb 2004 17:56:26 GMT&quot;/&gt;
+			    &lt;/widget&gt;
+			  &lt;/child&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkRadioMenuItem&quot; id=&quot;hostnamegroup1&quot;&gt;
+			      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Host Name&lt;/property&gt;
+			      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;group&quot;&gt;searchenginegroup1&lt;/property&gt;
+			    &lt;/widget&gt;
+			  &lt;/child&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkSeparatorMenuItem&quot; id=&quot;separator1&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;viewresults1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Vie_w&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_viewresults_activate&quot; last_modification_time=&quot;Tue, 24 Jun 2003 18:19:21 GMT&quot;/&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;viewcache1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;View Cache&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_viewcache_activate&quot; last_modification_time=&quot;Fri, 18 Mar 2005 19:14:33 GMT&quot;/&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;indexresults1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Index&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_indexresults_activate&quot; last_modification_time=&quot;Tue, 17 Jun 2003 19:16:56 GMT&quot;/&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;indexMenuitem&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Index&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkMenu&quot; id=&quot;indexMenuitem_menu&quot;&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;showlabels1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Show Label&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkImageMenuItem&quot; id=&quot;import1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Import&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_import_activate&quot; last_modification_time=&quot;Tue, 02 Mar 2004 22:13:44 GMT&quot;/&gt;
+
+		      &lt;child internal-child=&quot;image&quot;&gt;
+			&lt;widget class=&quot;GtkImage&quot; id=&quot;image515&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;stock&quot;&gt;gtk-open&lt;/property&gt;
+			  &lt;property name=&quot;icon_size&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkSeparatorMenuItem&quot; id=&quot;separator3&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;viewfromindex1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;View&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_viewfromindex_activate&quot; last_modification_time=&quot;Sat, 21 Feb 2004 13:47:40 GMT&quot;/&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkImageMenuItem&quot; id=&quot;refreshindex1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Update&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_refreshindex_activate&quot; last_modification_time=&quot;Fri, 20 Feb 2004 18:57:09 GMT&quot;/&gt;
+
+		      &lt;child internal-child=&quot;image&quot;&gt;
+			&lt;widget class=&quot;GtkImage&quot; id=&quot;image516&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;stock&quot;&gt;gtk-refresh&lt;/property&gt;
+			  &lt;property name=&quot;icon_size&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkImageMenuItem&quot; id=&quot;unindex1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Unindex&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_unindex_activate&quot; last_modification_time=&quot;Thu, 28 Jul 2005 12:42:23 GMT&quot;/&gt;
+
+		      &lt;child internal-child=&quot;image&quot;&gt;
+			&lt;widget class=&quot;GtkImage&quot; id=&quot;image517&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;stock&quot;&gt;gtk-delete&lt;/property&gt;
+			  &lt;property name=&quot;icon_size&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkImageMenuItem&quot; id=&quot;showfromindex1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Properties&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_showfromindex_activate&quot; last_modification_time=&quot;Sun, 06 Nov 2005 08:43:05 GMT&quot;/&gt;
+
+		      &lt;child internal-child=&quot;image&quot;&gt;
+			&lt;widget class=&quot;GtkImage&quot; id=&quot;image518&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;stock&quot;&gt;gtk-properties&lt;/property&gt;
+			  &lt;property name=&quot;icon_size&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;helpMenuitem&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Help&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkMenu&quot; id=&quot;helpMenuitem_menu&quot;&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;about1&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_About&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;activate&quot; handler=&quot;on_about_activate&quot; last_modification_time=&quot;Sat, 21 Jun 2003 15:19:32 GMT&quot;/&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkHPaned&quot; id=&quot;mainHpaned&quot;&gt;
+	  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;position&quot;&gt;105&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkVBox&quot; id=&quot;leftVbox&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkVBox&quot; id=&quot;enginesVbox&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;placeholder/&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkHBox&quot; id=&quot;indexHbox&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;4&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkButton&quot; id=&quot;addIndexButton&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;clicked&quot; handler=&quot;on_addIndexButton_clicked&quot; last_modification_time=&quot;Mon, 14 Feb 2005 18:15:10 GMT&quot;/&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkImage&quot; id=&quot;image439&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;stock&quot;&gt;gtk-add&lt;/property&gt;
+			  &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkButton&quot; id=&quot;removeIndexButton&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;clicked&quot; handler=&quot;on_removeIndexButton_clicked&quot; last_modification_time=&quot;Mon, 14 Feb 2005 18:15:15 GMT&quot;/&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkImage&quot; id=&quot;image438&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;stock&quot;&gt;gtk-remove&lt;/property&gt;
+			  &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;shrink&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;resize&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkVBox&quot; id=&quot;rightVbox&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkHBox&quot; id=&quot;liveQueryHbox&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;liveQueryLabel&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Query:&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;liveQueryEntry&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkVButtonBox&quot; id=&quot;findVbuttonbox&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;layout_style&quot;&gt;GTK_BUTTONBOX_DEFAULT_STYLE&lt;/property&gt;
+		      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkButton&quot; id=&quot;findButton&quot;&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot;&gt;gtk-find&lt;/property&gt;
+			  &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			  &lt;signal name=&quot;clicked&quot; handler=&quot;on_findButton_clicked&quot; last_modification_time=&quot;Fri, 25 Feb 2005 23:31:00 GMT&quot;/&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkExpander&quot; id=&quot;queryExpander&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;expanded&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkHBox&quot; id=&quot;queryHbox&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkScrolledWindow&quot; id=&quot;queryScrolledwindow&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;hscrollbar_policy&quot;&gt;GTK_POLICY_AUTOMATIC&lt;/property&gt;
+			  &lt;property name=&quot;vscrollbar_policy&quot;&gt;GTK_POLICY_AUTOMATIC&lt;/property&gt;
+			  &lt;property name=&quot;shadow_type&quot;&gt;GTK_SHADOW_NONE&lt;/property&gt;
+			  &lt;property name=&quot;window_placement&quot;&gt;GTK_CORNER_TOP_LEFT&lt;/property&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkTreeView&quot; id=&quot;queryTreeview&quot;&gt;
+			      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;events&quot;&gt;GDK_BUTTON_PRESS_MASK&lt;/property&gt;
+			      &lt;property name=&quot;headers_visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;rules_hint&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;reorderable&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;enable_search&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;fixed_height_mode&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;hover_selection&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;hover_expand&quot;&gt;False&lt;/property&gt;
+			      &lt;signal name=&quot;button_press_event&quot; handler=&quot;on_queryTreeview_button_press_event&quot; last_modification_time=&quot;Sat, 19 Mar 2005 10:05:13 GMT&quot;/&gt;
+			    &lt;/widget&gt;
+			  &lt;/child&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkVButtonBox&quot; id=&quot;queryVbuttonbox&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;layout_style&quot;&gt;GTK_BUTTONBOX_START&lt;/property&gt;
+			  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkButton&quot; id=&quot;addQueryButton&quot;&gt;
+			      &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+			      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;label&quot;&gt;gtk-add&lt;/property&gt;
+			      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			      &lt;signal name=&quot;clicked&quot; handler=&quot;on_addQueryButton_clicked&quot; last_modification_time=&quot;Fri, 25 Feb 2005 23:22:27 GMT&quot;/&gt;
+			    &lt;/widget&gt;
+			  &lt;/child&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkButton&quot; id=&quot;editQueryButton&quot;&gt;
+			      &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+			      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			      &lt;signal name=&quot;clicked&quot; handler=&quot;on_editQueryButton_clicked&quot; last_modification_time=&quot;Fri, 25 Feb 2005 23:22:37 GMT&quot;/&gt;
+
+			      &lt;child&gt;
+				&lt;widget class=&quot;GtkAlignment&quot; id=&quot;alignment26&quot;&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				  &lt;property name=&quot;xscale&quot;&gt;0&lt;/property&gt;
+				  &lt;property name=&quot;yscale&quot;&gt;0&lt;/property&gt;
+				  &lt;property name=&quot;top_padding&quot;&gt;0&lt;/property&gt;
+				  &lt;property name=&quot;bottom_padding&quot;&gt;0&lt;/property&gt;
+				  &lt;property name=&quot;left_padding&quot;&gt;0&lt;/property&gt;
+				  &lt;property name=&quot;right_padding&quot;&gt;0&lt;/property&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox40&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;spacing&quot;&gt;2&lt;/property&gt;
+
+				      &lt;child&gt;
+					&lt;widget class=&quot;GtkImage&quot; id=&quot;image400&quot;&gt;
+					  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+					  &lt;property name=&quot;stock&quot;&gt;gtk-open&lt;/property&gt;
+					  &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
+					  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+					  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+					  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+					  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+					&lt;/widget&gt;
+					&lt;packing&gt;
+					  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+					  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+					  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+					&lt;/packing&gt;
+				      &lt;/child&gt;
+
+				      &lt;child&gt;
+					&lt;widget class=&quot;GtkLabel&quot; id=&quot;label47&quot;&gt;
+					  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+					  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Edit&lt;/property&gt;
+					  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+					  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+					  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+					  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+					  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+					  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+					  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+					  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+					  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+					  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+					  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+					  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+					  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+					&lt;/widget&gt;
+					&lt;packing&gt;
+					  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+					  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+					  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+					&lt;/packing&gt;
+				      &lt;/child&gt;
+				    &lt;/widget&gt;
+				  &lt;/child&gt;
+				&lt;/widget&gt;
+			      &lt;/child&gt;
+			    &lt;/widget&gt;
+			  &lt;/child&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkButton&quot; id=&quot;removeQueryButton&quot;&gt;
+			      &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+			      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;label&quot;&gt;gtk-remove&lt;/property&gt;
+			      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			      &lt;signal name=&quot;clicked&quot; handler=&quot;on_removeQueryButton_clicked&quot; last_modification_time=&quot;Fri, 25 Feb 2005 23:38:42 GMT&quot;/&gt;
+			    &lt;/widget&gt;
+			  &lt;/child&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkButton&quot; id=&quot;findQueryButton&quot;&gt;
+			      &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+			      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;label&quot;&gt;gtk-find&lt;/property&gt;
+			      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			      &lt;signal name=&quot;clicked&quot; handler=&quot;on_findQueryButton_clicked&quot; last_modification_time=&quot;Sat, 26 Feb 2005 13:31:59 GMT&quot;/&gt;
+			    &lt;/widget&gt;
+			  &lt;/child&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;queryLabel&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Stored queries&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;type&quot;&gt;label_item&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkNotebook&quot; id=&quot;mainNotebook&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;show_tabs&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;show_border&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;tab_pos&quot;&gt;GTK_POS_TOP&lt;/property&gt;
+		  &lt;property name=&quot;scrollable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;enable_popup&quot;&gt;False&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkVBox&quot; id=&quot;resultsVbox&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;placeholder/&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;placeholder/&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;tab_expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;tab_fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;resultsLabel&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Results&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;type&quot;&gt;tab&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkVBox&quot; id=&quot;indexVbox&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkHBox&quot; id=&quot;indexButtonsHbox&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkComboBox&quot; id=&quot;indexCombobox&quot;&gt;
+			      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;items&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			      &lt;property name=&quot;add_tearoffs&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			      &lt;signal name=&quot;changed&quot; handler=&quot;on_indexCombobox_changed&quot; last_modification_time=&quot;Mon, 18 Jul 2005 12:49:12 GMT&quot;/&gt;
+			    &lt;/widget&gt;
+			    &lt;packing&gt;
+			      &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+			      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+			    &lt;/packing&gt;
+			  &lt;/child&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkHButtonBox&quot; id=&quot;indexHbuttonbox&quot;&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;layout_style&quot;&gt;GTK_BUTTONBOX_SPREAD&lt;/property&gt;
+			      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+			      &lt;child&gt;
+				&lt;widget class=&quot;GtkButton&quot; id=&quot;indexFirstButton&quot;&gt;
+				  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+				  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+				  &lt;signal name=&quot;clicked&quot; handler=&quot;on_indexFirstButton_clicked&quot; last_modification_time=&quot;Tue, 05 Jul 2005 13:26:37 GMT&quot;/&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkImage&quot; id=&quot;image478&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;stock&quot;&gt;gtk-goto-first&lt;/property&gt;
+				      &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				  &lt;/child&gt;
+				&lt;/widget&gt;
+			      &lt;/child&gt;
+
+			      &lt;child&gt;
+				&lt;widget class=&quot;GtkButton&quot; id=&quot;indexBackButton&quot;&gt;
+				  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+				  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+				  &lt;signal name=&quot;clicked&quot; handler=&quot;on_indexBackButton_clicked&quot; last_modification_time=&quot;Tue, 05 Jul 2005 13:26:43 GMT&quot;/&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkImage&quot; id=&quot;image479&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;stock&quot;&gt;gtk-go-back&lt;/property&gt;
+				      &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				  &lt;/child&gt;
+				&lt;/widget&gt;
+			      &lt;/child&gt;
+
+			      &lt;child&gt;
+				&lt;widget class=&quot;GtkButton&quot; id=&quot;indexForwardButton&quot;&gt;
+				  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+				  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+				  &lt;signal name=&quot;clicked&quot; handler=&quot;on_indexForwardButton_clicked&quot; last_modification_time=&quot;Tue, 05 Jul 2005 13:26:48 GMT&quot;/&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkImage&quot; id=&quot;image480&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;stock&quot;&gt;gtk-go-forward&lt;/property&gt;
+				      &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				  &lt;/child&gt;
+				&lt;/widget&gt;
+			      &lt;/child&gt;
+
+			      &lt;child&gt;
+				&lt;widget class=&quot;GtkButton&quot; id=&quot;indexLastButton&quot;&gt;
+				  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+				  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+				  &lt;signal name=&quot;clicked&quot; handler=&quot;on_indexLastButton_clicked&quot; last_modification_time=&quot;Tue, 05 Jul 2005 13:26:54 GMT&quot;/&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkImage&quot; id=&quot;image481&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;stock&quot;&gt;gtk-goto-last&lt;/property&gt;
+				      &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				  &lt;/child&gt;
+				&lt;/widget&gt;
+			      &lt;/child&gt;
+			    &lt;/widget&gt;
+			    &lt;packing&gt;
+			      &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+			      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+			    &lt;/packing&gt;
+			  &lt;/child&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;placeholder/&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;tab_expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;tab_fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;indexLabel&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Index&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;type&quot;&gt;tab&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkVBox&quot; id=&quot;viewVbox&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;placeholder/&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;tab_expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;tab_fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;viewLabel&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;View&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;type&quot;&gt;tab&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;shrink&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;resize&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkHBox&quot; id=&quot;mainHbox&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkProgressBar&quot; id=&quot;mainProgressbar&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;orientation&quot;&gt;GTK_PROGRESS_LEFT_TO_RIGHT&lt;/property&gt;
+	      &lt;property name=&quot;fraction&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;pulse_step&quot;&gt;0.10000000149&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkStatusbar&quot; id=&quot;mainStatusbar&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;has_resize_grip&quot;&gt;True&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+    &lt;/widget&gt;
+  &lt;/child&gt;
+&lt;/widget&gt;
+
+&lt;widget class=&quot;GtkDialog&quot; id=&quot;aboutDialog&quot;&gt;
+  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;public&lt;/property&gt;
+  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;About Pinot&lt;/property&gt;
+  &lt;property name=&quot;type&quot;&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
+  &lt;property name=&quot;window_position&quot;&gt;GTK_WIN_POS_NONE&lt;/property&gt;
+  &lt;property name=&quot;modal&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;resizable&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;destroy_with_parent&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;decorated&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;skip_taskbar_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;skip_pager_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;type_hint&quot;&gt;GDK_WINDOW_TYPE_HINT_NORMAL&lt;/property&gt;
+  &lt;property name=&quot;gravity&quot;&gt;GDK_GRAVITY_NORTH_WEST&lt;/property&gt;
+  &lt;property name=&quot;focus_on_map&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;has_separator&quot;&gt;True&lt;/property&gt;
+
+  &lt;child internal-child=&quot;vbox&quot;&gt;
+    &lt;widget class=&quot;GtkVBox&quot; id=&quot;dialog-vbox1&quot;&gt;
+      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+      &lt;child internal-child=&quot;action_area&quot;&gt;
+	&lt;widget class=&quot;GtkHButtonBox&quot; id=&quot;dialog-action_area1&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;layout_style&quot;&gt;GTK_BUTTONBOX_END&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkButton&quot; id=&quot;closebutton1&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot;&gt;gtk-close&lt;/property&gt;
+	      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+	      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;response_id&quot;&gt;-7&lt;/property&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;pack_type&quot;&gt;GTK_PACK_END&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkVBox&quot; id=&quot;aboutVbox&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkImage&quot; id=&quot;pinotImage&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;pixbuf&quot;&gt;pinot.png&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;nameLabel&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Pinot&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;descriptionLabel&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;A metasearch tool for the Free Desktop.&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_CENTER&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;copyrightLabel&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Copyright (C) 2005 Fabrice Colin&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_CENTER&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkImage&quot; id=&quot;xapianImage&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;pixbuf&quot;&gt;xapian-powered.png&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+    &lt;/widget&gt;
+  &lt;/child&gt;
+&lt;/widget&gt;
+
+&lt;widget class=&quot;GtkDialog&quot; id=&quot;prefsDialog&quot;&gt;
+  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;public&lt;/property&gt;
+  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;Preferences&lt;/property&gt;
+  &lt;property name=&quot;type&quot;&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
+  &lt;property name=&quot;window_position&quot;&gt;GTK_WIN_POS_NONE&lt;/property&gt;
+  &lt;property name=&quot;modal&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;resizable&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;destroy_with_parent&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;decorated&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;skip_taskbar_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;skip_pager_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;type_hint&quot;&gt;GDK_WINDOW_TYPE_HINT_NORMAL&lt;/property&gt;
+  &lt;property name=&quot;gravity&quot;&gt;GDK_GRAVITY_NORTH_WEST&lt;/property&gt;
+  &lt;property name=&quot;focus_on_map&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;has_separator&quot;&gt;True&lt;/property&gt;
+
+  &lt;child internal-child=&quot;vbox&quot;&gt;
+    &lt;widget class=&quot;GtkVBox&quot; id=&quot;dialog-vbox2&quot;&gt;
+      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+      &lt;child internal-child=&quot;action_area&quot;&gt;
+	&lt;widget class=&quot;GtkHButtonBox&quot; id=&quot;dialog-action_area2&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;layout_style&quot;&gt;GTK_BUTTONBOX_END&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkButton&quot; id=&quot;prefsCancelbutton&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot;&gt;gtk-cancel&lt;/property&gt;
+	      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+	      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;response_id&quot;&gt;-6&lt;/property&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkButton&quot; id=&quot;prefsOkbutton&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot;&gt;gtk-ok&lt;/property&gt;
+	      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+	      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;response_id&quot;&gt;-5&lt;/property&gt;
+	      &lt;signal name=&quot;clicked&quot; handler=&quot;on_prefsOkbutton_clicked&quot; last_modification_time=&quot;Sun, 22 Jun 2003 17:37:34 GMT&quot;/&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;pack_type&quot;&gt;GTK_PACK_END&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkNotebook&quot; id=&quot;prefsNotebook&quot;&gt;
+	  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;show_tabs&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;show_border&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;tab_pos&quot;&gt;GTK_POS_TOP&lt;/property&gt;
+	  &lt;property name=&quot;scrollable&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;enable_popup&quot;&gt;False&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkTable&quot; id=&quot;generalTable&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;n_rows&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;n_columns&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;row_spacing&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;column_spacing&quot;&gt;0&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;robotsLabel&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;HTTP crawling:&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;viewLabel&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;View documents:&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;browserLabel&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Browser:&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;apiKeyLabel&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Google API Key:&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkEntry&quot; id=&quot;apiKeyEntry&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+		  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkComboBox&quot; id=&quot;viewCombobox&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;add_tearoffs&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+		  &lt;signal name=&quot;changed&quot; handler=&quot;on_viewCombobox_changed&quot; last_modification_time=&quot;Sun, 17 Apr 2005 05:53:46 GMT&quot;/&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkCheckButton&quot; id=&quot;ignoreRobotsCheckbutton&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Ignore robots.txt and Robots META tag&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkHBox&quot; id=&quot;browserHbox&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkEntry&quot; id=&quot;browserEntry&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+		      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkButton&quot; id=&quot;browserButton&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+		      &lt;signal name=&quot;clicked&quot; handler=&quot;on_browserButton_clicked&quot; last_modification_time=&quot;Sun, 10 Aug 2003 10:20:18 GMT&quot;/&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;tab_expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;tab_fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;generalLabel&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;General&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;type&quot;&gt;tab&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkVBox&quot; id=&quot;labelsVbox&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;indexLabelsLabel&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Labels are used to classify indexed documents:&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkHBox&quot; id=&quot;labelsHbox&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkScrolledWindow&quot; id=&quot;labelsScrolledwindow&quot;&gt;
+		      &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;hscrollbar_policy&quot;&gt;GTK_POLICY_AUTOMATIC&lt;/property&gt;
+		      &lt;property name=&quot;vscrollbar_policy&quot;&gt;GTK_POLICY_AUTOMATIC&lt;/property&gt;
+		      &lt;property name=&quot;shadow_type&quot;&gt;GTK_SHADOW_NONE&lt;/property&gt;
+		      &lt;property name=&quot;window_placement&quot;&gt;GTK_CORNER_TOP_LEFT&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkTreeView&quot; id=&quot;labelsTreeview&quot;&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;headers_visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;rules_hint&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;reorderable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;enable_search&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;fixed_height_mode&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;hover_selection&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;hover_expand&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkVButtonBox&quot; id=&quot;labelsVbuttonbox&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;layout_style&quot;&gt;GTK_BUTTONBOX_START&lt;/property&gt;
+		      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkButton&quot; id=&quot;addLabelButton&quot;&gt;
+			  &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			  &lt;signal name=&quot;clicked&quot; handler=&quot;on_addLabelButton_clicked&quot; last_modification_time=&quot;Wed, 28 Apr 2004 17:31:55 GMT&quot;/&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkAlignment&quot; id=&quot;alignment17&quot;&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;xscale&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;yscale&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;top_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;bottom_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;left_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;right_padding&quot;&gt;0&lt;/property&gt;
+
+			      &lt;child&gt;
+				&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox29&quot;&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;spacing&quot;&gt;2&lt;/property&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkImage&quot; id=&quot;image235&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;stock&quot;&gt;gtk-add&lt;/property&gt;
+				      &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				    &lt;packing&gt;
+				      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+				    &lt;/packing&gt;
+				  &lt;/child&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label35&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Add&lt;/property&gt;
+				      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+				      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+				      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+				      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				    &lt;packing&gt;
+				      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+				    &lt;/packing&gt;
+				  &lt;/child&gt;
+				&lt;/widget&gt;
+			      &lt;/child&gt;
+			    &lt;/widget&gt;
+			  &lt;/child&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkButton&quot; id=&quot;editLabelButton&quot;&gt;
+			  &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			  &lt;signal name=&quot;clicked&quot; handler=&quot;on_editLabelButton_clicked&quot; last_modification_time=&quot;Wed, 28 Apr 2004 17:31:45 GMT&quot;/&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkAlignment&quot; id=&quot;alignment19&quot;&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;xscale&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;yscale&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;top_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;bottom_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;left_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;right_padding&quot;&gt;0&lt;/property&gt;
+
+			      &lt;child&gt;
+				&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox31&quot;&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;spacing&quot;&gt;2&lt;/property&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkImage&quot; id=&quot;image237&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;stock&quot;&gt;gtk-select-color&lt;/property&gt;
+				      &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				    &lt;packing&gt;
+				      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+				    &lt;/packing&gt;
+				  &lt;/child&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label37&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Edit&lt;/property&gt;
+				      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+				      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+				      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+				      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				    &lt;packing&gt;
+				      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+				    &lt;/packing&gt;
+				  &lt;/child&gt;
+				&lt;/widget&gt;
+			      &lt;/child&gt;
+			    &lt;/widget&gt;
+			  &lt;/child&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkButton&quot; id=&quot;removeLabelButton&quot;&gt;
+			  &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			  &lt;signal name=&quot;clicked&quot; handler=&quot;on_removeLabelButton_clicked&quot; last_modification_time=&quot;Wed, 28 Apr 2004 17:32:01 GMT&quot;/&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkAlignment&quot; id=&quot;alignment18&quot;&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;xscale&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;yscale&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;top_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;bottom_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;left_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;right_padding&quot;&gt;0&lt;/property&gt;
+
+			      &lt;child&gt;
+				&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox30&quot;&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;spacing&quot;&gt;2&lt;/property&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkImage&quot; id=&quot;image236&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;stock&quot;&gt;gtk-remove&lt;/property&gt;
+				      &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				    &lt;packing&gt;
+				      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+				    &lt;/packing&gt;
+				  &lt;/child&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label36&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Remove&lt;/property&gt;
+				      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+				      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+				      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+				      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				    &lt;packing&gt;
+				      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+				    &lt;/packing&gt;
+				  &lt;/child&gt;
+				&lt;/widget&gt;
+			      &lt;/child&gt;
+			    &lt;/widget&gt;
+			  &lt;/child&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;tab_expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;tab_fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;labelsLabel&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Labels&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;type&quot;&gt;tab&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkVBox&quot; id=&quot;mailVbox&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;mailAccountsLabel&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Mail boxes of type mbox can be monitored and indexed:&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkHBox&quot; id=&quot;mailHbox&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkScrolledWindow&quot; id=&quot;mailScrolledwindow&quot;&gt;
+		      &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;hscrollbar_policy&quot;&gt;GTK_POLICY_AUTOMATIC&lt;/property&gt;
+		      &lt;property name=&quot;vscrollbar_policy&quot;&gt;GTK_POLICY_AUTOMATIC&lt;/property&gt;
+		      &lt;property name=&quot;shadow_type&quot;&gt;GTK_SHADOW_NONE&lt;/property&gt;
+		      &lt;property name=&quot;window_placement&quot;&gt;GTK_CORNER_TOP_LEFT&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkTreeView&quot; id=&quot;mailTreeview&quot;&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;headers_visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;rules_hint&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;reorderable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;enable_search&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;fixed_height_mode&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;hover_selection&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;hover_expand&quot;&gt;False&lt;/property&gt;
+			  &lt;signal name=&quot;button_press_event&quot; handler=&quot;on_mailTreeview_button_press_event&quot; last_modification_time=&quot;Sat, 19 Mar 2005 10:05:34 GMT&quot;/&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkVButtonBox&quot; id=&quot;mailVbuttonbox&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;layout_style&quot;&gt;GTK_BUTTONBOX_START&lt;/property&gt;
+		      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkButton&quot; id=&quot;addAccountButton&quot;&gt;
+			  &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			  &lt;signal name=&quot;clicked&quot; handler=&quot;on_addAccountButton_clicked&quot; last_modification_time=&quot;Tue, 20 Sep 2005 13:19:44 GMT&quot;/&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkAlignment&quot; id=&quot;alignment28&quot;&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;xscale&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;yscale&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;top_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;bottom_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;left_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;right_padding&quot;&gt;0&lt;/property&gt;
+
+			      &lt;child&gt;
+				&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox42&quot;&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;spacing&quot;&gt;2&lt;/property&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkImage&quot; id=&quot;image497&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;stock&quot;&gt;gtk-add&lt;/property&gt;
+				      &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				    &lt;packing&gt;
+				      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+				    &lt;/packing&gt;
+				  &lt;/child&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label49&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Add&lt;/property&gt;
+				      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+				      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+				      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+				      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				    &lt;packing&gt;
+				      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+				    &lt;/packing&gt;
+				  &lt;/child&gt;
+				&lt;/widget&gt;
+			      &lt;/child&gt;
+			    &lt;/widget&gt;
+			  &lt;/child&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkButton&quot; id=&quot;editAccountButton&quot;&gt;
+			  &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot;&gt;gtk-edit&lt;/property&gt;
+			  &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			  &lt;signal name=&quot;clicked&quot; handler=&quot;on_editAccountButton_clicked&quot; last_modification_time=&quot;Fri, 02 Sep 2005 21:58:38 GMT&quot;/&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkButton&quot; id=&quot;removeAccountButton&quot;&gt;
+			  &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot;&gt;gtk-remove&lt;/property&gt;
+			  &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			  &lt;signal name=&quot;clicked&quot; handler=&quot;on_removeAccountButton_clicked&quot; last_modification_time=&quot;Fri, 02 Sep 2005 21:58:06 GMT&quot;/&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;tab_expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;tab_fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;mailLabel&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;My Email&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;type&quot;&gt;tab&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+    &lt;/widget&gt;
+  &lt;/child&gt;
+&lt;/widget&gt;
+
+&lt;widget class=&quot;GtkDialog&quot; id=&quot;queryDialog&quot;&gt;
+  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;public&lt;/property&gt;
+  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;Query properties&lt;/property&gt;
+  &lt;property name=&quot;type&quot;&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
+  &lt;property name=&quot;window_position&quot;&gt;GTK_WIN_POS_NONE&lt;/property&gt;
+  &lt;property name=&quot;modal&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;resizable&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;destroy_with_parent&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;decorated&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;skip_taskbar_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;skip_pager_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;type_hint&quot;&gt;GDK_WINDOW_TYPE_HINT_NORMAL&lt;/property&gt;
+  &lt;property name=&quot;gravity&quot;&gt;GDK_GRAVITY_NORTH_WEST&lt;/property&gt;
+  &lt;property name=&quot;focus_on_map&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;has_separator&quot;&gt;True&lt;/property&gt;
+
+  &lt;child internal-child=&quot;vbox&quot;&gt;
+    &lt;widget class=&quot;GtkVBox&quot; id=&quot;dialog-vbox3&quot;&gt;
+      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+      &lt;child internal-child=&quot;action_area&quot;&gt;
+	&lt;widget class=&quot;GtkHButtonBox&quot; id=&quot;dialog-action_area3&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;layout_style&quot;&gt;GTK_BUTTONBOX_END&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkButton&quot; id=&quot;queryCancelbutton&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot;&gt;gtk-cancel&lt;/property&gt;
+	      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+	      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;response_id&quot;&gt;-6&lt;/property&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkButton&quot; id=&quot;queryOkbutton&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot;&gt;gtk-ok&lt;/property&gt;
+	      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+	      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;response_id&quot;&gt;-5&lt;/property&gt;
+	      &lt;signal name=&quot;clicked&quot; handler=&quot;on_queryOkbutton_clicked&quot; last_modification_time=&quot;Sat, 14 Jun 2003 10:48:48 GMT&quot;/&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;pack_type&quot;&gt;GTK_PACK_END&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkVBox&quot; id=&quot;queryVbox&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkTable&quot; id=&quot;table1&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;n_rows&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;n_columns&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;row_spacing&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;column_spacing&quot;&gt;0&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;nameLabel&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Name:&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkEntry&quot; id=&quot;nameEntry&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+		  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		  &lt;signal name=&quot;changed&quot; handler=&quot;on_nameEntry_changed&quot; last_modification_time=&quot;Fri, 18 Feb 2005 18:20:44 GMT&quot;/&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkNotebook&quot; id=&quot;queryNotebook&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;show_tabs&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;show_border&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;tab_pos&quot;&gt;GTK_POS_TOP&lt;/property&gt;
+	      &lt;property name=&quot;scrollable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;enable_popup&quot;&gt;False&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkVBox&quot; id=&quot;termsVbox&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkTable&quot; id=&quot;tersmTable&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;n_rows&quot;&gt;5&lt;/property&gt;
+		      &lt;property name=&quot;n_columns&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;row_spacing&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;column_spacing&quot;&gt;0&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;anyEntry&quot;&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;hostNameEntry&quot;&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;fileNameEntry&quot;&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkSpinButton&quot; id=&quot;resultsCountSpinbutton&quot;&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;climb_rate&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;digits&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;numeric&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;update_policy&quot;&gt;GTK_UPDATE_ALWAYS&lt;/property&gt;
+			  &lt;property name=&quot;snap_to_ticks&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;adjustment&quot;&gt;10 10 100 10 20 20&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkCheckButton&quot; id=&quot;indexCheckbutton&quot;&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Index all results with label&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;active&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;inconsistent&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;draw_indicator&quot;&gt;True&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;5&lt;/property&gt;
+			  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;anyLabel&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Any of the words:&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+			  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+			  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;hostLabel&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Host name:&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+			  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+			  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;fileNameLabel&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;File name:&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+			  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+			  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;resultsCountLabel&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Number of results:&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+			  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+			  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkComboBox&quot; id=&quot;labelCombobox&quot;&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;add_tearoffs&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;5&lt;/property&gt;
+			  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;tab_expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;tab_fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;propertiesLabel&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Properties&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;type&quot;&gt;tab&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkVBox&quot; id=&quot;advancedVbox&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;filtersLabel&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Limit to documents that match&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+		      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkTable&quot; id=&quot;advancedTable&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;n_rows&quot;&gt;4&lt;/property&gt;
+		      &lt;property name=&quot;n_columns&quot;&gt;2&lt;/property&gt;
+		      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;row_spacing&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;column_spacing&quot;&gt;0&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;phraseEntry&quot;&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;notEntry&quot;&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;phraseLabel&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;the exact phrase:&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+			  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+			  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;notLabel&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;none of the words:&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+			  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+			  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;label14&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;the language:&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+			  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+			  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkComboBox&quot; id=&quot;languageCombobox&quot;&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;add_tearoffs&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;3&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkEntry&quot; id=&quot;andEntry&quot;&gt;
+			  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+			  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;andLabel&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;all the words:&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+			  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+			  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+			  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+			  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+			  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;tab_expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;tab_fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;advancedLabel&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Advanced&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;type&quot;&gt;tab&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+    &lt;/widget&gt;
+  &lt;/child&gt;
+&lt;/widget&gt;
+
+&lt;widget class=&quot;GtkDialog&quot; id=&quot;importDialog&quot;&gt;
+  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;public&lt;/property&gt;
+  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;Import document&lt;/property&gt;
+  &lt;property name=&quot;type&quot;&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
+  &lt;property name=&quot;window_position&quot;&gt;GTK_WIN_POS_NONE&lt;/property&gt;
+  &lt;property name=&quot;modal&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;resizable&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;destroy_with_parent&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;decorated&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;skip_taskbar_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;skip_pager_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;type_hint&quot;&gt;GDK_WINDOW_TYPE_HINT_NORMAL&lt;/property&gt;
+  &lt;property name=&quot;gravity&quot;&gt;GDK_GRAVITY_NORTH_WEST&lt;/property&gt;
+  &lt;property name=&quot;focus_on_map&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;has_separator&quot;&gt;True&lt;/property&gt;
+
+  &lt;child internal-child=&quot;vbox&quot;&gt;
+    &lt;widget class=&quot;GtkVBox&quot; id=&quot;dialog-vbox4&quot;&gt;
+      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+      &lt;child internal-child=&quot;action_area&quot;&gt;
+	&lt;widget class=&quot;GtkHButtonBox&quot; id=&quot;dialog-action_area4&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;layout_style&quot;&gt;GTK_BUTTONBOX_END&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkButton&quot; id=&quot;cancelbutton1&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot;&gt;gtk-cancel&lt;/property&gt;
+	      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+	      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;response_id&quot;&gt;-6&lt;/property&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkButton&quot; id=&quot;importOkButton&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot;&gt;gtk-ok&lt;/property&gt;
+	      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+	      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;response_id&quot;&gt;-5&lt;/property&gt;
+	      &lt;signal name=&quot;clicked&quot; handler=&quot;on_importOkButton_clicked&quot; last_modification_time=&quot;Sun, 18 Sep 2005 05:13:29 GMT&quot;/&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;pack_type&quot;&gt;GTK_PACK_END&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkTable&quot; id=&quot;docTable&quot;&gt;
+	  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;n_rows&quot;&gt;4&lt;/property&gt;
+	  &lt;property name=&quot;n_columns&quot;&gt;3&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;row_spacing&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;column_spacing&quot;&gt;0&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkHButtonBox&quot; id=&quot;hbuttonbox3&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;layout_style&quot;&gt;GTK_BUTTONBOX_DEFAULT_STYLE&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkButton&quot; id=&quot;selectButton&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+		  &lt;signal name=&quot;clicked&quot; handler=&quot;on_selectButton_clicked&quot; last_modification_time=&quot;Tue, 09 Mar 2004 19:27:45 GMT&quot;/&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkAlignment&quot; id=&quot;alignment9&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xscale&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;yscale&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;top_padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;bottom_padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;left_padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;right_padding&quot;&gt;0&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox14&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;spacing&quot;&gt;2&lt;/property&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkImage&quot; id=&quot;image180&quot;&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;stock&quot;&gt;gtk-open&lt;/property&gt;
+			      &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
+			      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			    &lt;/widget&gt;
+			    &lt;packing&gt;
+			      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+			    &lt;/packing&gt;
+			  &lt;/child&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label17&quot;&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Select&lt;/property&gt;
+			      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+			      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+			      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+			    &lt;/widget&gt;
+			    &lt;packing&gt;
+			      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+			    &lt;/packing&gt;
+			  &lt;/child&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;3&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;3&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkEntry&quot; id=&quot;locationEntry&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+	      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+	      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+	      &lt;signal name=&quot;changed&quot; handler=&quot;on_locationEntry_changed&quot; last_modification_time=&quot;Sun, 18 Sep 2005 03:55:37 GMT&quot;/&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;3&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkEntry&quot; id=&quot;titleEntry&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+	      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+	      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;locationLabel&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Location:&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;3&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;titleLabel&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Title:&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;depthLabel&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Maximum depth:&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+	      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkSpinButton&quot; id=&quot;depthSpinbutton&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;climb_rate&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;digits&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;numeric&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;update_policy&quot;&gt;GTK_UPDATE_ALWAYS&lt;/property&gt;
+	      &lt;property name=&quot;snap_to_ticks&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;adjustment&quot;&gt;0 0 100 1 5 5&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+	      &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkComboBox&quot; id=&quot;typeCombobox&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;items&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+	      &lt;property name=&quot;add_tearoffs&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+	      &lt;signal name=&quot;changed&quot; handler=&quot;on_typeCombobox_changed&quot; last_modification_time=&quot;Sun, 18 Sep 2005 04:09:29 GMT&quot;/&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;typeLabel&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Type:&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+    &lt;/widget&gt;
+  &lt;/child&gt;
+&lt;/widget&gt;
+
+&lt;widget class=&quot;GtkDialog&quot; id=&quot;propertiesDialog&quot;&gt;
+  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;public&lt;/property&gt;
+  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;Properties&lt;/property&gt;
+  &lt;property name=&quot;type&quot;&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
+  &lt;property name=&quot;window_position&quot;&gt;GTK_WIN_POS_NONE&lt;/property&gt;
+  &lt;property name=&quot;modal&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;resizable&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;destroy_with_parent&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;decorated&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;skip_taskbar_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;skip_pager_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;type_hint&quot;&gt;GDK_WINDOW_TYPE_HINT_NORMAL&lt;/property&gt;
+  &lt;property name=&quot;gravity&quot;&gt;GDK_GRAVITY_NORTH_WEST&lt;/property&gt;
+  &lt;property name=&quot;focus_on_map&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;has_separator&quot;&gt;True&lt;/property&gt;
+
+  &lt;child internal-child=&quot;vbox&quot;&gt;
+    &lt;widget class=&quot;GtkVBox&quot; id=&quot;dialog-vbox5&quot;&gt;
+      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+      &lt;child internal-child=&quot;action_area&quot;&gt;
+	&lt;widget class=&quot;GtkHButtonBox&quot; id=&quot;dialog-action_area5&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;layout_style&quot;&gt;GTK_BUTTONBOX_END&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkButton&quot; id=&quot;cancelbutton2&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot;&gt;gtk-cancel&lt;/property&gt;
+	      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+	      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;response_id&quot;&gt;-6&lt;/property&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkButton&quot; id=&quot;labelOkButton&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot;&gt;gtk-ok&lt;/property&gt;
+	      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+	      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;response_id&quot;&gt;-5&lt;/property&gt;
+	      &lt;signal name=&quot;clicked&quot; handler=&quot;on_labelOkButton_clicked&quot; last_modification_time=&quot;Sun, 05 Sep 2004 10:29:09 GMT&quot;/&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;pack_type&quot;&gt;GTK_PACK_END&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkVBox&quot; id=&quot;propertiesVbox&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkTable&quot; id=&quot;propertiesTable&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;n_rows&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;n_columns&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;row_spacing&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;column_spacing&quot;&gt;0&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkEntry&quot; id=&quot;titleEntry&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+		  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkScrolledWindow&quot; id=&quot;extractScrolledwindow&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;hscrollbar_policy&quot;&gt;GTK_POLICY_AUTOMATIC&lt;/property&gt;
+		  &lt;property name=&quot;vscrollbar_policy&quot;&gt;GTK_POLICY_AUTOMATIC&lt;/property&gt;
+		  &lt;property name=&quot;shadow_type&quot;&gt;GTK_SHADOW_IN&lt;/property&gt;
+		  &lt;property name=&quot;window_placement&quot;&gt;GTK_CORNER_TOP_LEFT&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkTextView&quot; id=&quot;extractTextview&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;overwrite&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;accepts_tab&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;justification&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap_mode&quot;&gt;GTK_WRAP_NONE&lt;/property&gt;
+		      &lt;property name=&quot;cursor_visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;pixels_above_lines&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;pixels_below_lines&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;pixels_inside_wrap&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;left_margin&quot;&gt;3&lt;/property&gt;
+		      &lt;property name=&quot;right_margin&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;indent&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;titleLabel&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Title:&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;extractLabel&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Extract:&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;languageLabel&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Language:&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkEntry&quot; id=&quot;languageEntry&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;editable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+		  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkLabel&quot; id=&quot;typeLabel&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Type:&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		  &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+		  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+		  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkEntry&quot; id=&quot;typeEntry&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;editable&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+		  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+		  &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+		  &lt;property name=&quot;top_attach&quot;&gt;3&lt;/property&gt;
+		  &lt;property name=&quot;bottom_attach&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkScrolledWindow&quot; id=&quot;labelsScrolledwindow&quot;&gt;
+	      &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;hscrollbar_policy&quot;&gt;GTK_POLICY_AUTOMATIC&lt;/property&gt;
+	      &lt;property name=&quot;vscrollbar_policy&quot;&gt;GTK_POLICY_AUTOMATIC&lt;/property&gt;
+	      &lt;property name=&quot;shadow_type&quot;&gt;GTK_SHADOW_NONE&lt;/property&gt;
+	      &lt;property name=&quot;window_placement&quot;&gt;GTK_CORNER_TOP_LEFT&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkViewport&quot; id=&quot;viewport1&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;shadow_type&quot;&gt;GTK_SHADOW_IN&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkTreeView&quot; id=&quot;labelsTreeview&quot;&gt;
+		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;headers_visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;rules_hint&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;reorderable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;enable_search&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;fixed_height_mode&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;hover_selection&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;hover_expand&quot;&gt;False&lt;/property&gt;
+		    &lt;/widget&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+    &lt;/widget&gt;
+  &lt;/child&gt;
+&lt;/widget&gt;
+
+&lt;widget class=&quot;GtkDialog&quot; id=&quot;indexDialog&quot;&gt;
+  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;External index&lt;/property&gt;
+  &lt;property name=&quot;type&quot;&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
+  &lt;property name=&quot;window_position&quot;&gt;GTK_WIN_POS_NONE&lt;/property&gt;
+  &lt;property name=&quot;modal&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;resizable&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;destroy_with_parent&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;decorated&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;skip_taskbar_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;skip_pager_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;type_hint&quot;&gt;GDK_WINDOW_TYPE_HINT_DIALOG&lt;/property&gt;
+  &lt;property name=&quot;gravity&quot;&gt;GDK_GRAVITY_NORTH_WEST&lt;/property&gt;
+  &lt;property name=&quot;focus_on_map&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;has_separator&quot;&gt;True&lt;/property&gt;
+
+  &lt;child internal-child=&quot;vbox&quot;&gt;
+    &lt;widget class=&quot;GtkVBox&quot; id=&quot;dialog-vbox6&quot;&gt;
+      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+      &lt;child internal-child=&quot;action_area&quot;&gt;
+	&lt;widget class=&quot;GtkHButtonBox&quot; id=&quot;dialog-action_area6&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;layout_style&quot;&gt;GTK_BUTTONBOX_END&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkButton&quot; id=&quot;indexCancelbutton&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot;&gt;gtk-cancel&lt;/property&gt;
+	      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+	      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;response_id&quot;&gt;-6&lt;/property&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkButton&quot; id=&quot;indexOkbutton&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot;&gt;gtk-ok&lt;/property&gt;
+	      &lt;property name=&quot;use_stock&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+	      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;response_id&quot;&gt;-5&lt;/property&gt;
+	      &lt;signal name=&quot;clicked&quot; handler=&quot;on_indexOkbutton_clicked&quot; last_modification_time=&quot;Tue, 15 Feb 2005 18:12:56 GMT&quot;/&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;pack_type&quot;&gt;GTK_PACK_END&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GtkTable&quot; id=&quot;indexTable&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;n_rows&quot;&gt;4&lt;/property&gt;
+	  &lt;property name=&quot;n_columns&quot;&gt;2&lt;/property&gt;
+	  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	  &lt;property name=&quot;row_spacing&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;column_spacing&quot;&gt;0&lt;/property&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;nameLabel&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Name:&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkHBox&quot; id=&quot;locationHbox&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkEntry&quot; id=&quot;locationEntry&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		  &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+		  &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+		  &lt;signal name=&quot;changed&quot; handler=&quot;on_locationEntry_changed&quot; last_modification_time=&quot;Tue, 15 Feb 2005 18:12:43 GMT&quot;/&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkButton&quot; id=&quot;locationButton&quot;&gt;
+		  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;...&lt;/property&gt;
+		  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+		  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+		  &lt;signal name=&quot;clicked&quot; handler=&quot;on_locationButton_clicked&quot; last_modification_time=&quot;Tue, 15 Feb 2005 18:12:48 GMT&quot;/&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+	      &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;typeLabel&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Type:&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;locationLabel&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Location:&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;3&lt;/property&gt;
+	      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkLabel&quot; id=&quot;portLabel&quot;&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Port:&lt;/property&gt;
+	      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;xalign&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+	      &lt;property name=&quot;xpad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ypad&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+	      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+	      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;3&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;x_options&quot;&gt;fill&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;fill&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkEntry&quot; id=&quot;nameEntry&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;visibility&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;max_length&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+	      &lt;property name=&quot;has_frame&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;invisible_char&quot;&gt;*&lt;/property&gt;
+	      &lt;property name=&quot;activates_default&quot;&gt;False&lt;/property&gt;
+	      &lt;signal name=&quot;changed&quot; handler=&quot;on_nameEntry_changed&quot; last_modification_time=&quot;Tue, 15 Feb 2005 18:12:34 GMT&quot;/&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkSpinButton&quot; id=&quot;portSpinbutton&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;climb_rate&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;digits&quot;&gt;0&lt;/property&gt;
+	      &lt;property name=&quot;numeric&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;update_policy&quot;&gt;GTK_UPDATE_ALWAYS&lt;/property&gt;
+	      &lt;property name=&quot;snap_to_ticks&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;adjustment&quot;&gt;1024 0 65535 1 10 10&lt;/property&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;3&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+
+	  &lt;child&gt;
+	    &lt;widget class=&quot;GtkComboBox&quot; id=&quot;typeCombobox&quot;&gt;
+	      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;items&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+	      &lt;property name=&quot;add_tearoffs&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+	      &lt;signal name=&quot;changed&quot; handler=&quot;on_typeCombobox_changed&quot; last_modification_time=&quot;Sun, 17 Apr 2005 04:13:55 GMT&quot;/&gt;
+	    &lt;/widget&gt;
+	    &lt;packing&gt;
+	      &lt;property name=&quot;left_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;right_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;top_attach&quot;&gt;1&lt;/property&gt;
+	      &lt;property name=&quot;bottom_attach&quot;&gt;2&lt;/property&gt;
+	      &lt;property name=&quot;x_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_padding&quot;&gt;4&lt;/property&gt;
+	      &lt;property name=&quot;y_options&quot;&gt;&lt;/property&gt;
+	    &lt;/packing&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+	&lt;packing&gt;
+	  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+	  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+	&lt;/packing&gt;
+      &lt;/child&gt;
+    &lt;/widget&gt;
+  &lt;/child&gt;
+&lt;/widget&gt;
+
+&lt;/glade-interface&gt;


Property changes on: trunk/UI/GTK2/metase-gtk2.glade
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/metase-gtk2.gladep
===================================================================
--- trunk/UI/GTK2/metase-gtk2.gladep	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/metase-gtk2.gladep	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,10 @@
+&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt; &lt;!--*- mode: xml -*--&gt;
+&lt;!DOCTYPE glade-project SYSTEM &quot;<A HREF="http://glade.gnome.org/glade-project-2.0.dtd">http://glade.gnome.org/glade-project-2.0.dtd</A>&quot;&gt;
+
+&lt;glade-project&gt;
+  &lt;name&gt;metase-gtk2&lt;/name&gt;
+  &lt;program_name&gt;pinot&lt;/program_name&gt;
+  &lt;language&gt;C++&lt;/language&gt;
+  &lt;gnome_support&gt;FALSE&lt;/gnome_support&gt;
+  &lt;output_build_files&gt;FALSE&lt;/output_build_files&gt;
+&lt;/glade-project&gt;


Property changes on: trunk/UI/GTK2/metase-gtk2.gladep
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/pinot.png
===================================================================
(Binary files differ)


Property changes on: trunk/UI/GTK2/pinot.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/UI/GTK2/pinot.xcf
===================================================================
(Binary files differ)


Property changes on: trunk/UI/GTK2/pinot.xcf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/UI/GTK2/src/EnginesTree.cpp
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/EnginesTree.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,355 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+#include &lt;gtkmm/alignment.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/buttonbox.h&gt;
+#include &lt;gtkmm/image.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/stock.h&gt;
+#include &lt;gtkmm/textbuffer.h&gt;
+
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;QueryHistory.h&quot;
+#include &quot;ViewHistory.h&quot;
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;EnginesTree.h&quot;
+
+using namespace std;
+using namespace SigC;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+EnginesTree::EnginesTree(VBox *enginesVbox, PinotSettings &amp;settings) :
+	TreeView(),
+	m_settings(settings)
+{
+	ScrolledWindow *enginesScrolledwindow = manage(new ScrolledWindow());
+
+	// This is the actual engines tree
+	set_events(Gdk::BUTTON_PRESS_MASK);
+	set_flags(CAN_FOCUS);
+	set_headers_visible(true);
+	set_reorderable(false);
+	set_enable_search(false);
+	enginesScrolledwindow-&gt;set_flags(CAN_FOCUS);
+	enginesScrolledwindow-&gt;set_shadow_type(SHADOW_NONE);
+	enginesScrolledwindow-&gt;set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
+	enginesScrolledwindow-&gt;property_window_placement().set_value(CORNER_TOP_LEFT);
+	enginesScrolledwindow-&gt;add(*this);
+
+	// Position the scrolled window
+	enginesVbox-&gt;pack_start(*enginesScrolledwindow, Gtk::PACK_EXPAND_WIDGET, 0);
+
+	// Associate the columns model to the engines tree
+	m_refStore = TreeStore::create(m_enginesColumns);
+	set_model(m_refStore);
+
+	TreeViewColumn *treeColumn = new TreeViewColumn(_(&quot;Search Engines&quot;));
+	// Pack an icon renderer for engines icons
+	CellRendererPixbuf *iconRenderer = new CellRendererPixbuf();
+	treeColumn-&gt;pack_start(*manage(iconRenderer), false);
+	treeColumn-&gt;set_cell_data_func(*iconRenderer, SigC::slot(*this, &amp;EnginesTree::renderEngineIcon));
+	treeColumn-&gt;pack_end(m_enginesColumns.m_name, false);
+	append_column(*manage(treeColumn));
+
+	// Make headers clickable
+	set_headers_clickable(true);
+	// Allow multiple selection
+	get_selection()-&gt;set_mode(SELECTION_MULTIPLE);
+
+	// Handle button presses
+	signal_button_press_event().connect_notify(SigC::slot(*this, &amp;EnginesTree::onButtonPressEvent));
+	// Control which rows can be selected
+	get_selection()-&gt;set_select_function(SigC::slot(*this, &amp;EnginesTree::onSelectionSelect));
+	// Listen for style changes
+	signal_style_changed().connect_notify(SigC::slot(*this, &amp;EnginesTree::onStyleChanged));
+
+	// Render the icons
+	m_engineFolderIconPixbuf = render_icon(Stock::DIRECTORY, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+
+	// Populate
+	populate();
+
+	// Show all
+	show();
+	enginesScrolledwindow-&gt;show();
+}
+
+EnginesTree::~EnginesTree()
+{
+}
+
+void EnginesTree::renderEngineIcon(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &amp;iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (renderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *iconRenderer = dynamic_cast&lt;CellRendererPixbuf*&gt;(renderer);
+	if (iconRenderer != NULL)
+	{
+		// Is this an engine folder ?
+		if (row[m_enginesColumns.m_type] == EnginesModelColumns::ENGINE_FOLDER)
+		{
+			iconRenderer-&gt;property_pixbuf() = m_engineFolderIconPixbuf;
+		}
+		else
+		{
+			iconRenderer-&gt;property_pixbuf().reset_value();
+		}
+	}
+}
+
+//
+// Handles button presses.
+//
+void EnginesTree::onButtonPressEvent(GdkEventButton *ev)
+{
+	list&lt;TreeModel::Path&gt; selectedEngines = get_selection()-&gt;get_selected_rows();
+	// If there are more than one row selected, don't bother
+	if (selectedEngines.size() != 1)
+	{
+		return;
+	}
+
+	list&lt;TreeModel::Path&gt;::iterator enginePath = selectedEngines.begin();
+	if (enginePath == selectedEngines.end())
+	{
+		return;
+	}
+
+	TreeModel::iterator engineIter = m_refStore-&gt;get_iter(*enginePath);
+	TreeModel::Row engineRow = *engineIter;
+
+	// Check for double clicks
+	if (ev-&gt;type == GDK_2BUTTON_PRESS)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;EnginesTree::onButtonPressEvent: double click on button &quot; &lt;&lt; ev-&gt;button &lt;&lt; endl;
+#endif
+		// Make sure the engine is an external index
+		EnginesModelColumns::EngineType engineType = engineRow[m_enginesColumns.m_type];
+		if (engineType == EnginesModelColumns::INDEX_ENGINE)
+		{
+			ustring name = engineRow[m_enginesColumns.m_name];
+			ustring location = engineRow[m_enginesColumns.m_option];
+
+			m_signalEdit(name, location);
+		}
+		else
+		{
+			// Is the row already expanded ?
+			if (row_expanded(*enginePath) == false)
+			{
+				// Expand it
+				expand_row(*enginePath, true);
+			}
+			else
+			{
+				// Collapse it
+				collapse_row(*enginePath);
+			}
+		}
+	}
+}
+
+//
+// Handles attempts to select rows.
+//
+bool EnginesTree::onSelectionSelect(const RefPtr&lt;TreeModel&gt;&amp; model,
+		const TreeModel::Path&amp; path, bool path_currently_selected)
+{
+	// All nodes can be selected
+	return true;
+}
+
+//
+// Handles GTK style changes.
+//
+void EnginesTree::onStyleChanged(const RefPtr&lt;Style&gt; &amp;previous_style)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;EnginesTree::onStyleChanged: called&quot; &lt;&lt; endl;
+#endif
+	// FIXME: find better icons :-)
+	m_engineFolderIconPixbuf = render_icon(Stock::DIRECTORY, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+}
+
+//
+// Gets a list of selected items.
+//
+list&lt;TreeModel::Path&gt; EnginesTree::getSelection(void)
+{
+	return get_selection()-&gt;get_selected_rows();
+}
+
+/// Gets an iterator.
+TreeModel::iterator EnginesTree::getIter(TreeModel::Path enginePath)
+{
+	return m_refStore-&gt;get_iter(enginePath);
+}
+
+/// Gets the column record.
+EnginesModelColumns &amp;EnginesTree::getColumnRecord(void)
+{
+	return m_enginesColumns;
+}
+
+//
+// Populate the tree.
+//
+void EnginesTree::populate(bool indexesOnly)
+{
+	set&lt;PinotSettings::Engine&gt; engines;
+	TreeModel::Row row;
+
+	// Reset the whole tree
+	get_selection()-&gt;unselect_all();
+	m_refStore-&gt;clear();
+
+	// Populate the tree with search engines
+	const set&lt;string&gt; &amp;channels = m_settings.getSearchEnginesChannels();
+	for (set&lt;string&gt;::const_iterator channelIter = channels.begin();
+		channelIter != channels.end(); ++channelIter)
+	{
+		string channelName = *channelIter;
+
+		// Enumerate search engines for this channel
+		engines.clear();
+		m_settings.getSearchEngines(engines, channelName);
+
+		if (engines.empty() == true)
+		{
+			continue;
+		}
+
+		TreeModel::iterator folderIter = m_refStore-&gt;append();
+		row = *folderIter;
+
+		row[m_enginesColumns.m_name] = to_utf8(channelName);
+		row[m_enginesColumns.m_engineName] = &quot;internal-folder&quot;;
+		row[m_enginesColumns.m_option] = &quot;&quot;;
+		row[m_enginesColumns.m_type] = EnginesModelColumns::ENGINE_FOLDER;
+
+		// FIXME: for some reason, without &quot;std::&quot;'s the compiler fails with a parse error before the comma
+		std::set&lt;PinotSettings::Engine&gt;::const_iterator engineIter = engines.begin();
+		for (; engineIter != engines.end(); ++engineIter)
+		{
+			string engineName = engineIter-&gt;m_name;
+			string engineType = engineIter-&gt;m_type;
+
+			if (engineType == &quot;xapian&quot;)
+			{
+				// Skip Xapian, it's only usable through a local engine
+				continue;
+			}
+
+			TreeModel::iterator iter = m_refStore-&gt;append(folderIter-&gt;children());
+			row = *iter;
+
+			row[m_enginesColumns.m_name] = to_utf8(engineName);
+			row[m_enginesColumns.m_engineName] = to_utf8(engineType);
+			// Is this a Sherlock engine ?
+			if (engineType == &quot;sherlock&quot;)
+			{
+				row[m_enginesColumns.m_option] = engineIter-&gt;m_option;
+			}
+			else
+			{
+				row[m_enginesColumns.m_option] = &quot;&quot;;
+			}
+			row[m_enginesColumns.m_type] = EnginesModelColumns::WEB_ENGINE;
+		}
+	}
+
+	// Local engines
+	TreeModel::iterator localIter = m_refStore-&gt;append();
+	row = *localIter;
+	row[m_enginesColumns.m_name] = _(&quot;Current User&quot;);
+	row[m_enginesColumns.m_engineName] = &quot;internal-folder&quot;;
+	row[m_enginesColumns.m_option] = &quot;&quot;;
+	row[m_enginesColumns.m_type] = EnginesModelColumns::ENGINE_FOLDER;
+
+	// FIXME: for some reason, without &quot;std::&quot;'s the compiler fails with a parse error before the comma
+	std::map&lt;std::string, std::string&gt;::const_iterator indexIter = m_settings.getIndexes().begin();
+	for (; indexIter != m_settings.getIndexes().end(); ++indexIter)
+	{
+		ustring indexName = to_utf8(indexIter-&gt;first);
+		EnginesModelColumns::EngineType indexType = EnginesModelColumns::INDEX_ENGINE;
+
+		if (indexName == _(&quot;My Documents&quot;))
+		{
+			indexType = EnginesModelColumns::INTERNAL_INDEX_ENGINE;
+		}
+		else if (indexName == _(&quot;My Email&quot;))
+		{
+			indexType = EnginesModelColumns::INTERNAL_INDEX_ENGINE;
+		}
+
+		TreeModel::iterator iter = m_refStore-&gt;append(localIter-&gt;children());
+		TreeModel::Row row = *iter;
+		row[m_enginesColumns.m_name] = indexName;
+		row[m_enginesColumns.m_engineName] = &quot;xapian&quot;;
+		row[m_enginesColumns.m_option] = to_utf8(indexIter-&gt;second);
+		row[m_enginesColumns.m_type] = indexType;
+	}
+
+	expand_all();
+}
+
+//
+// Clear the tree.
+//
+void EnginesTree::clear(void)
+{
+	// Unselect engines
+	get_selection()-&gt;unselect_all();
+
+	// Remove existing rows in the tree
+	TreeModel::Children children = m_refStore-&gt;children();
+	if (children.empty() == false)
+	{
+		TreeModel::Children::iterator iter = children.begin();
+		while (iter != children.end())
+		{
+			// Erase this row
+			m_refStore-&gt;erase(*iter);
+
+			// Get the new first row
+			children = m_refStore-&gt;children();
+			iter = children.begin();
+		}
+		m_refStore-&gt;clear();
+	}
+}
+
+//
+// Returns the edit index signal.
+//
+Signal2&lt;void, string, string&gt;&amp; EnginesTree::getEditIndexSignal(void)
+{
+	return m_signalEdit;
+}

Added: trunk/UI/GTK2/src/EnginesTree.h
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/EnginesTree.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,90 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _ENGINESTREE_HH
+#define _ENGINESTREE_HH
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;set&gt;
+#include &lt;map&gt;
+#include &lt;sigc++/slot.h&gt;
+#include &lt;glibmm/refptr.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gdkmm/pixbuf.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/menu.h&gt;
+#include &lt;gtkmm/scrolledwindow.h&gt;
+#include &lt;gtkmm/textview.h&gt;
+#include &lt;gtkmm/treestore.h&gt;
+#include &lt;gtkmm/treeview.h&gt;
+#include &lt;gtkmm/treeselection.h&gt;
+
+#include &quot;QueryProperties.h&quot;
+#include &quot;ModelColumns.h&quot;
+#include &quot;PinotSettings.h&quot;
+
+class EnginesTree : public Gtk::TreeView
+{
+	public:
+		EnginesTree(Gtk::VBox *enginesVbox, PinotSettings &amp;settings);
+		virtual ~EnginesTree();
+
+		/// Gets a list of selected items.
+		std::list&lt;Gtk::TreeModel::Path&gt; getSelection(void);
+
+		/// Gets an iterator.
+		Gtk::TreeModel::iterator getIter(Gtk::TreeModel::Path enginePath);
+
+		/// Gets the column record.
+		EnginesModelColumns &amp;getColumnRecord(void);
+
+		/// Populate the tree.
+		void populate(bool indexesOnly = false);
+
+		/// Clear the tree.
+		void clear(void);
+
+		/// Returns the index edit signal.
+		SigC::Signal2&lt;void, std::string, std::string&gt;&amp; getEditIndexSignal(void);
+
+	protected:
+		Glib::RefPtr&lt;Gtk::TreeStore&gt; m_refStore;
+		PinotSettings &amp;m_settings;
+		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_engineFolderIconPixbuf;
+		EnginesModelColumns m_enginesColumns;
+		SigC::Signal2&lt;void, std::string, std::string&gt; m_signalEdit;
+
+		void renderEngineIcon(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &amp;iter);
+
+		/// Handles button presses.
+		void onButtonPressEvent(GdkEventButton *ev);
+
+		/// Handles attempts to select rows.
+		bool onSelectionSelect(const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,
+			const Gtk::TreeModel::Path&amp; path, bool path_currently_selected);
+
+		/// Handles GTK style changes.
+		void onStyleChanged(const Glib::RefPtr&lt;Gtk::Style&gt; &amp;previous_style);
+
+	private:
+		EnginesTree(const EnginesTree &amp;other);
+		EnginesTree &amp;operator=(const EnginesTree &amp;other);
+
+};
+
+#endif // _ENGINESTREE_HH

Added: trunk/UI/GTK2/src/HtmlView.cpp
===================================================================
--- trunk/UI/GTK2/src/HtmlView.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/HtmlView.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,73 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+
+#include &lt;glibmm/wrap.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;HtmlView.h&quot;
+#include &quot;PinotUtils.h&quot;
+
+using namespace Glib;
+using namespace Gtk;
+
+HtmlView::HtmlView(VBox *viewVbox, Menu *pPopupMenu) :
+	MozillaRenderer(),
+	m_pPopupMenu(pPopupMenu)
+{
+	GtkWidget *view = getWidget();
+	if (view != NULL)
+	{
+		// Wrap this into a gtkmm Widget object
+		// FIXME: need manage(wrap()) ?
+		Widget *pDocHtmlView = wrap(view);
+		if ((pDocHtmlView != NULL) &amp;&amp;
+			(viewVbox != NULL))
+		{
+			viewVbox-&gt;pack_start(*pDocHtmlView);
+
+			// Handle button presses
+			pDocHtmlView-&gt;signal_button_press_event().connect_notify(SigC::slot(*this, &amp;HtmlView::onButtonPressEvent));
+
+			pDocHtmlView-&gt;show();
+		}
+	}
+}
+
+HtmlView::~HtmlView()
+{
+}
+
+//
+// Handles button presses.
+//
+void HtmlView::onButtonPressEvent(GdkEventButton *ev)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;HtmlView::onButtonPressEvent: click on button &quot; &lt;&lt; ev-&gt;button &lt;&lt; endl;
+#endif
+	// Check for popup click
+	if ((ev-&gt;type == GDK_BUTTON_PRESS) &amp;&amp;
+		(ev-&gt;button == 3) )
+	{
+		if (m_pPopupMenu != NULL)
+		{
+			m_pPopupMenu-&gt;popup(ev-&gt;button, ev-&gt;time);
+		}
+	}
+}

Added: trunk/UI/GTK2/src/HtmlView.h
===================================================================
--- trunk/UI/GTK2/src/HtmlView.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/HtmlView.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,44 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _HTMLVIEW_HH
+#define _HTMLVIEW_HH
+
+#include &lt;sigc++/object.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/menu.h&gt;
+
+#include &quot;MozillaRenderer.h&quot;
+
+class HtmlView : public MozillaRenderer, public SigC::Object
+{
+	public:
+		HtmlView(Gtk::VBox *viewVbox, Gtk::Menu *pPopupMenu);
+		virtual ~HtmlView();
+
+	protected:
+		Gtk::Menu *m_pPopupMenu;
+
+		/// Handles button presses.
+		void onButtonPressEvent(GdkEventButton *ev);
+
+	private:
+		HtmlView(const HtmlView &amp;other);
+		HtmlView &amp;operator=(const HtmlView &amp;other);
+
+};
+
+#endif // _HTMLVIEW_HH

Added: trunk/UI/GTK2/src/IndexTree.cpp
===================================================================
--- trunk/UI/GTK2/src/IndexTree.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/IndexTree.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,534 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+#include &lt;gtkmm/stock.h&gt;
+#include &lt;gtkmm/textbuffer.h&gt;
+
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;QueryHistory.h&quot;
+#include &quot;ViewHistory.h&quot;
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;IndexTree.h&quot;
+
+using namespace std;
+using namespace SigC;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+IndexTree::IndexTree(VBox *indexVbox, Menu *pPopupMenu, PinotSettings &amp;settings) :
+	TreeView(),
+	m_pPopupMenu(pPopupMenu),
+	m_settings(settings)
+{
+	ScrolledWindow *indexScrolledwindow = manage(new ScrolledWindow());
+
+	// This is the actual index tree
+	set_events(Gdk::BUTTON_PRESS_MASK);
+	set_flags(CAN_FOCUS);
+	set_headers_visible(true);
+	set_rules_hint(true);
+	set_reorderable(false);
+	set_enable_search(true);
+	indexScrolledwindow-&gt;set_flags(Gtk::CAN_FOCUS);
+	indexScrolledwindow-&gt;set_border_width(4);
+	indexScrolledwindow-&gt;set_shadow_type(Gtk::SHADOW_NONE);
+	indexScrolledwindow-&gt;set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_ALWAYS);
+	indexScrolledwindow-&gt;property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+	indexScrolledwindow-&gt;add(*this);
+
+	// Position the scrolled window
+	indexVbox-&gt;pack_start(*indexScrolledwindow);
+	
+	// Associate the columns model to the index tree
+	m_refStore = ListStore::create(m_indexColumns);
+	set_model(m_refStore);
+
+	// The score column is used for status icons
+	TreeViewColumn *treeColumn = create_resizable_column_with_icon(_(&quot;Title&quot;), m_indexColumns.m_text,
+		SigC::slot(*this, &amp;IndexTree::renderLabel));
+	if (treeColumn != NULL)
+	{
+		append_column(*manage(treeColumn));
+	}
+	treeColumn = create_resizable_column(_(&quot;URL&quot;), m_indexColumns.m_liveUrl);
+	if (treeColumn != NULL)
+	{
+		append_column(*manage(treeColumn));
+	}
+	append_column(_(&quot;Timestamp&quot;), m_indexColumns.m_timestamp);
+
+	// Make headers clickable
+	set_headers_clickable(true);
+	// Allow multiple selection
+	get_selection()-&gt;set_mode(SELECTION_MULTIPLE);
+
+	// Handle button presses
+	signal_button_press_event().connect_notify(SigC::slot(*this, &amp;IndexTree::onButtonPressEvent));
+	// Enable interactive search
+	set_search_column(m_indexColumns.m_text.index());
+	set_search_equal_func(SigC::slot(*this, &amp;IndexTree::onSearchEqual));
+	// Control which rows can be selected
+	get_selection()-&gt;set_select_function(SigC::slot(*this, &amp;IndexTree::onSelectionSelect));
+
+	// Initially, don't display the list of indexed documents
+	m_listingIndex = false;
+
+	// By default, no particular label is selected
+	setCurrentLabelColour(0, 0, 0, false);
+
+	// Show all
+	show();
+	indexScrolledwindow-&gt;show();
+}
+
+IndexTree::~IndexTree()
+{
+}
+
+void IndexTree::renderLabel(CellRenderer *renderer, const TreeModel::iterator &amp;iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (renderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererText *textRenderer = dynamic_cast&lt;CellRendererText*&gt;(renderer);
+	if (textRenderer != NULL)
+	{
+		if ((m_showingLabel == false) &amp;&amp;
+			(row[m_indexColumns.m_labeled] == true))
+		{
+			// Reset this
+			row[m_indexColumns.m_labeled] = false;
+		}
+		else if (row[m_indexColumns.m_labeled] == true)
+		{
+			// Change the row's background
+			textRenderer-&gt;property_background_gdk() = m_currentLabelColour;
+		}
+		else
+		{
+			textRenderer-&gt;property_background_gdk().reset_value();
+		}
+	}
+}
+
+//
+// Interactive search equal function.
+//
+bool IndexTree::onSearchEqual(const RefPtr&lt;TreeModel&gt;&amp; model, int column,
+	const ustring&amp; key, const TreeModel::iterator&amp; iter)
+{
+}
+
+//
+// Handles button presses.
+//
+void IndexTree::onButtonPressEvent(GdkEventButton *ev)
+{
+	// Check for popup click
+	if ((ev-&gt;type == GDK_BUTTON_PRESS) &amp;&amp;
+		(ev-&gt;button == 3) )
+	{
+		if (m_pPopupMenu != NULL)
+		{
+			m_pPopupMenu-&gt;popup(ev-&gt;button, ev-&gt;time);
+		}
+	}
+	// Check for double clicks
+	else if (ev-&gt;type == GDK_2BUTTON_PRESS)
+	{
+		m_signalEdit();
+	}
+}
+
+//
+// Handles selection changes.
+//
+bool IndexTree::onSelectionChanged(void)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;IndexTree::onSelectionChanged: called&quot; &lt;&lt; endl;
+#endif
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+//
+// Handles attempts to select rows.
+//
+bool IndexTree::onSelectionSelect(const RefPtr&lt;TreeModel&gt;&amp; model,
+		const TreeModel::Path&amp; path, bool path_currently_selected)
+{
+	const TreeModel::iterator iter = model-&gt;get_iter(path);
+	const TreeModel::Row row = *iter;
+
+	if (path_currently_selected == true)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;IndexTree::onSelectionSelect: unselected entry &quot; &lt;&lt; row[m_indexColumns.m_url] &lt;&lt; endl;
+#endif
+	}
+	else
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;IndexTree::onSelectionSelect: selected entry &quot; &lt;&lt; row[m_indexColumns.m_url] &lt;&lt; endl;
+#endif
+	}
+
+	return true;
+}
+
+//
+// Appends a new row in the index tree.
+//
+bool IndexTree::appendDocument(const IndexedDocument &amp;docInfo, bool labeled)
+{
+	TreeModel::iterator newRowIter = m_refStore-&gt;append();
+	TreeModel::Row childRow = *newRowIter;
+	string title = docInfo.getTitle();
+
+	if (title.empty() == true)
+	{
+		title = _(&quot;No title&quot;);
+	}
+	else if (title.length() &gt; 50)
+	{
+		string truncatedTitle = title.substr(0, 47);
+		truncatedTitle += &quot;...&quot;;
+		title = truncatedTitle;
+	}
+
+	childRow[m_indexColumns.m_text] = to_utf8(title);
+	childRow[m_indexColumns.m_url] = to_utf8(docInfo.getLocation());
+	childRow[m_indexColumns.m_liveUrl] = to_utf8(docInfo.getOriginalLocation());
+	childRow[m_indexColumns.m_type] = to_utf8(docInfo.getType());
+	childRow[m_indexColumns.m_language] = to_utf8(docInfo.getLanguage());
+	childRow[m_indexColumns.m_timestamp] = to_utf8(docInfo.getTimestamp());
+	childRow[m_indexColumns.m_labeled] = labeled;
+	childRow[m_indexColumns.m_id] = docInfo.getID();
+
+	// If the tree was empty, it is no longer
+	m_listingIndex = true;
+
+	return true;
+}
+
+
+//
+// Adds a set of documents.
+//
+bool IndexTree::addDocuments(const vector&lt;IndexedDocument&gt; &amp;documentsList)
+{
+	unsigned int count = 0;
+
+	// Unselect all
+	get_selection()-&gt;unselect_all();
+
+	// FIXME: clear the tree ?
+
+	// Get the list of indexed documents
+	for (vector&lt;IndexedDocument&gt;::const_iterator docIter = documentsList.begin();
+		docIter != documentsList.end(); ++docIter)
+	{
+		// Add a row
+		if (appendDocument(*docIter, false) == true)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;IndexTree::addDocuments: added row for document &quot; &lt;&lt; count &lt;&lt; endl;
+#endif
+			count++;
+		}
+	}
+
+	// Now we are listing the index contents
+	m_listingIndex = true;
+
+	return true;
+}
+
+//
+// Gets the first selected item's URL.
+//
+ustring IndexTree::getFirstSelectionURL(void)
+{
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return &quot;&quot;;
+	}
+
+	list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
+	TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
+	TreeModel::Row row = *iter;
+	return row[m_indexColumns.m_url];
+}
+
+//
+// Gets the first selected item's URL.
+//
+ustring IndexTree::getFirstSelectionLiveURL(void)
+{
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return &quot;&quot;;
+	}
+
+	list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
+	TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
+	TreeModel::Row row = *iter;
+	return row[m_indexColumns.m_liveUrl];
+}
+
+//
+// Gets a list of selected items.
+//
+bool IndexTree::getSelection(std::vector&lt;IndexedDocument&gt; &amp;documentsList)
+{
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return false;
+	}
+
+	// Go through selected items
+	for (list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
+		itemPath != selectedItems.end(); ++itemPath)
+	{
+		TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+
+		documentsList.push_back(IndexedDocument(locale_from_utf8(row[m_indexColumns.m_text]),
+			locale_from_utf8(row[m_indexColumns.m_url]),
+			locale_from_utf8(row[m_indexColumns.m_liveUrl]),
+			locale_from_utf8(row[m_indexColumns.m_type]),
+			locale_from_utf8(row[m_indexColumns.m_language])));
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;IndexTree::getSelection: &quot; &lt;&lt; documentsList.size() &lt;&lt; &quot; documents selected&quot; &lt;&lt; endl;
+#endif
+
+	return true;
+}
+
+//
+// Sets the current label colour.
+//
+void IndexTree::setCurrentLabelColour(unsigned short red, unsigned short green, unsigned short blue,
+	bool showingLabel)
+{
+	m_currentLabelColour.set_rgb(red, green, blue);
+	m_showingLabel = showingLabel;
+}
+
+//
+// Sets the documents that match the current label.
+//
+void IndexTree::setLabel(const set&lt;unsigned int&gt; &amp;documentsList)
+{
+	// Unselect all
+	get_selection()-&gt;unselect_all();
+
+	// Go through the list of indexed documents
+	TreeModel::Children children = m_refStore-&gt;children();
+	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
+	{
+		// Does this document match the label ?
+		TreeModel::Row row = *iter;
+		unsigned int docId = row[m_indexColumns.m_id];
+
+		set&lt;unsigned int&gt;::iterator docIter = documentsList.find(docId);
+		if (docIter != documentsList.end())
+		{
+			// Yes, it does !
+#ifdef DEBUG
+			cout &lt;&lt; &quot;IndexTree::setLabel: label is in document &quot; &lt;&lt; docId &lt;&lt; endl;
+#endif
+			row[m_indexColumns.m_labeled] = true;
+		}
+		else
+		{
+			row[m_indexColumns.m_labeled] = false;
+		}
+	}
+}
+
+//
+// Sets a document's title.
+//
+void IndexTree::setDocumentTitle(unsigned int docId, const string &amp;text)
+{
+	if (docId == 0)
+	{
+		return;
+	}
+
+	// Go through the list of indexed documents
+	TreeModel::Children children = m_refStore-&gt;children();
+	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
+	{
+		TreeModel::Row row = *iter;
+
+		if (docId == row[m_indexColumns.m_id])
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;IndexTree::setLabel: updating title of document &quot; &lt;&lt; docId &lt;&lt; endl;
+#endif
+			row[m_indexColumns.m_text] = to_utf8(text);
+			break;
+		}
+	}
+}
+
+//
+// Marks a document as labeled.
+//
+void IndexTree::setDocumentLabeledState(unsigned int docId, bool labeled)
+{
+	if (docId == 0)
+	{
+		return;
+	}
+
+	// Go through the list of indexed documents
+	TreeModel::Children children = m_refStore-&gt;children();
+	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
+	{
+		TreeModel::Row row = *iter;
+
+		if (docId == row[m_indexColumns.m_id])
+		{
+			row[m_indexColumns.m_labeled] = labeled;
+			break;
+		}
+	}
+}
+
+//
+// Deletes the current selection.
+//
+bool IndexTree::deleteSelection(void)
+{
+	bool empty = false;
+
+	// Go through selected items
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
+	while (itemPath != selectedItems.end())
+	{
+		TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+
+		// Unselect and erase
+		get_selection()-&gt;unselect(iter);
+		m_refStore-&gt;erase(row);
+
+		selectedItems = get_selection()-&gt;get_selected_rows();
+		itemPath = selectedItems.begin();
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;IndexTree::setLabel: deleted &quot; &lt;&lt; selectedItems.size() &lt;&lt; &quot; documents&quot; &lt;&lt; endl;
+#endif
+
+	TreeModel::Children children = m_refStore-&gt;children();
+	if (children.empty() == true)
+	{
+		// The index tree is now empty
+		m_listingIndex = false;
+		empty = true;
+	}
+
+	columns_autosize();
+
+	return empty;
+}
+
+//
+// Returns the number of rows.
+//
+unsigned int IndexTree::getRowsCount(void)
+{
+	if (m_listingIndex == false)
+	{
+		return 0;
+	}
+
+	// FIXME: cache this value ?
+	return m_refStore-&gt;children().size();
+}
+
+//
+// Returns true if the tree is empty.
+//
+bool IndexTree::isEmpty(void)
+{
+	if (m_listingIndex == true)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+//
+// Clear the tree.
+//
+void IndexTree::clear(void)
+{
+	// Unselect all
+	get_selection()-&gt;unselect_all();
+
+	// Remove existing rows in the tree
+	TreeModel::Children children = m_refStore-&gt;children();
+	if (children.empty() == false)
+	{
+		TreeModel::Children::iterator iter = children.begin();
+		while (iter != children.end())
+		{
+			// Erase this row
+			m_refStore-&gt;erase(*iter);
+
+			// Get the new first row
+			children = m_refStore-&gt;children();
+			iter = children.begin();
+		}
+		m_refStore-&gt;clear();
+
+		onSelectionChanged();
+	}
+}
+
+//
+// Returns the edit document signal.
+//
+Signal0&lt;void&gt;&amp; IndexTree::getEditDocumentSignal(void)
+{
+	return m_signalEdit;
+}

Added: trunk/UI/GTK2/src/IndexTree.h
===================================================================
--- trunk/UI/GTK2/src/IndexTree.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/IndexTree.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,126 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _INDEXTREE_HH
+#define _INDEXTREE_HH
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;sigc++/slot.h&gt;
+#include &lt;glibmm/refptr.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/menu.h&gt;
+#include &lt;gdkmm/pixbuf.h&gt;
+#include &lt;gtkmm/scrolledwindow.h&gt;
+#include &lt;gtkmm/textview.h&gt;
+#include &lt;gtkmm/liststore.h&gt;
+#include &lt;gtkmm/treeview.h&gt;
+#include &lt;gtkmm/treeselection.h&gt;
+
+#include &quot;QueryProperties.h&quot;
+#include &quot;IndexedDocument.h&quot;
+#include &quot;ModelColumns.h&quot;
+#include &quot;PinotSettings.h&quot;
+
+class IndexTree : public Gtk::TreeView
+{
+	public:
+		IndexTree(Gtk::VBox *indexVbox, Gtk::Menu *pPopupMenu, PinotSettings &amp;settings);
+		virtual ~IndexTree();
+
+		/**
+		  * Handles selection changes.
+		  * Returns true if a result is selected.
+		  */
+		bool onSelectionChanged(void);
+
+		/// Adds a set of documents.
+		bool addDocuments(const std::vector&lt;IndexedDocument&gt; &amp;documentsList);
+
+		/// Appends a new row in the index tree.
+		bool appendDocument(const IndexedDocument &amp;docInfo, bool labeled);
+
+		/// Gets the first selected item's URL.
+		Glib::ustring getFirstSelectionURL(void);
+
+		/// Gets the first selected item's URL.
+		Glib::ustring getFirstSelectionLiveURL(void);
+
+		/// Gets a list of selected items.
+		bool getSelection(std::vector&lt;IndexedDocument&gt; &amp;documentsList);
+
+		/// Sets the current label colour.
+		void setCurrentLabelColour(unsigned short red, unsigned short green, unsigned short blue,
+			bool showingLabel = true);
+
+		/// Sets the documents that match the current label.
+		void setLabel(const std::set&lt;unsigned int&gt; &amp;documentsList);
+
+		/// Sets a document's title.
+		void setDocumentTitle(unsigned int docId, const std::string &amp;text);
+
+		/// Marks a document as labeled.
+		void setDocumentLabeledState(unsigned int docId, bool labeled);
+
+		/**
+		  * Deletes the current selection.
+		  * Returns true if the tree is then empty.
+		  */
+		bool deleteSelection(void);
+
+		/// Returns the number of rows.
+		unsigned int getRowsCount(void);
+
+		/// Returns true if the tree is empty.
+		bool isEmpty(void);
+
+		/// Clear the tree.
+		void clear(void);
+
+		/// Returns the document edit signal.
+		SigC::Signal0&lt;void&gt;&amp; getEditDocumentSignal(void);
+
+	protected:
+		Glib::RefPtr&lt;Gtk::ListStore&gt; m_refStore;
+		Gtk::Menu *m_pPopupMenu;
+		SigC::Signal0&lt;void&gt; m_signalEdit;
+		PinotSettings &amp;m_settings;
+		IndexModelColumns m_indexColumns;
+		Gdk::Color m_currentLabelColour;
+		bool m_showingLabel;
+		bool m_listingIndex;
+
+		void renderLabel(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &amp;iter);
+
+		/// Interactive search equal function.
+		bool onSearchEqual(const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model, int column,
+			const Glib::ustring&amp; key, const Gtk::TreeModel::iterator&amp; iter);
+
+		/// Handles button presses.
+		void onButtonPressEvent(GdkEventButton *ev);
+
+		/// Handles attempts to select rows.
+		bool onSelectionSelect(const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,
+			const Gtk::TreeModel::Path&amp; path, bool path_currently_selected);
+
+	private:
+		IndexTree(const IndexTree &amp;other);
+		IndexTree &amp;operator=(const IndexTree &amp;other);
+
+};
+
+#endif // _INDEXTREE_HH

Added: trunk/UI/GTK2/src/Makefile
===================================================================
--- trunk/UI/GTK2/src/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,33 @@
+
+ROOT_DIR = ../../..
+include ${ROOT_DIR}/variables.mk
+
+CXXFLAGS += -DHAVE_CONFIG_H -I. -I.. ${LIBXML_CXXFLAGS} ${GTKMOZ_CXXFLAGS} ${GTKMM_CXXFLAGS}
+
+LIBS += ${LIBXML_LIBS} ${GTKMOZ_LIBS} ${GTKMM_LIBS} -lgthread-2.0 -lfam
+
+UI_GTK2_SRCS = aboutDialog.cc aboutDialog_glade.cc \
+	importDialog.cc importDialog_glade.cc \
+	indexDialog.cc indexDialog_glade.cc \
+	prefsDialog.cc prefsDialog_glade.cc \
+	propertiesDialog.cc propertiesDialog_glade.cc \
+	queryDialog.cc queryDialog_glade.cc \
+	mainWindow.cc mainWindow_glade.cc
+UI_SRCS = pinot.cpp EnginesTree.cpp IndexTree.cpp \
+	HtmlView.cpp ModelColumns.cpp MonitorHandler.cpp \
+	PinotSettings.cpp PinotUtils.cpp ResultsTree.cpp \
+	WorkerThreads.cpp
+UI_GTK2_OBJS := $(patsubst %.cc,${OBJ_DIR}/%.o,${UI_GTK2_SRCS})
+UI_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${UI_SRCS})
+UI_GTK2_BIN = ${BIN_DIR}/pinot
+
+targets : dirs ${UI_GTK2_BIN}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${UI_GTK2_BIN}
+
+# GTK+ user interface
+
+${UI_GTK2_BIN} : ${UI_GTK2_OBJS} ${UI_OBJS} ${HTML_LIB} ${IDX_LIB} ${SE_LIBS} ${DL_LIB} ${SQL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB}
+	@echo Building ${UI_GTK2_BIN}
+	${LINK} -o $@ ${UI_GTK2_OBJS} ${UI_OBJS} ${HTML_LIB} ${IDX_LIB} ${SE_LIBS} ${DL_LIB} ${SQL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS}


Property changes on: trunk/UI/GTK2/src/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/ModelColumns.cpp
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/ModelColumns.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,121 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;ModelColumns.h&quot;
+
+ComboModelColumns::ComboModelColumns()
+{
+	add(m_name);
+}
+
+ComboModelColumns::~ComboModelColumns()
+{
+}
+
+EnginesModelColumns::EnginesModelColumns()
+{
+	add(m_name);
+	add(m_engineName);
+	add(m_option);
+	add(m_type);
+}
+
+EnginesModelColumns::~EnginesModelColumns()
+{
+}
+
+QueryModelColumns::QueryModelColumns()
+{
+	add(m_name);
+	add(m_lastRun);
+	add(m_summary);
+	add(m_properties);
+}
+
+QueryModelColumns::~QueryModelColumns()
+{
+}
+
+ResultsModelColumns::ResultsModelColumns()
+{
+	add(m_text);
+	add(m_url);
+	add(m_indexed);
+	add(m_viewed);
+	add(m_rankDiff);
+	add(m_score);
+	add(m_language);
+	add(m_queryName);
+	add(m_engines);
+	add(m_indexes);
+	add(m_type);
+}
+
+ResultsModelColumns::~ResultsModelColumns()
+{
+}
+
+IndexModelColumns::IndexModelColumns()
+{
+	add(m_text);
+	add(m_url);
+	add(m_liveUrl);
+	add(m_type);
+	add(m_language);
+	add(m_id);
+	add(m_timestamp);
+	add(m_labeled);
+}
+
+IndexModelColumns::~IndexModelColumns()
+{
+}
+
+OtherIndexModelColumns::OtherIndexModelColumns()
+{
+	add(m_name);
+	add(m_location);
+}
+
+OtherIndexModelColumns::~OtherIndexModelColumns()
+{
+}
+
+LabelModelColumns::LabelModelColumns()
+{
+	add(m_enabled);
+	add(m_name);
+	add(m_oldName);
+	add(m_colour);
+}
+
+LabelModelColumns::~LabelModelColumns()
+{
+}
+
+MailAccountModelColumns::MailAccountModelColumns()
+{
+	add(m_location);
+	add(m_type);
+	add(m_mTime);
+	add(m_minDate);
+}
+
+MailAccountModelColumns::~MailAccountModelColumns()
+{
+}

Added: trunk/UI/GTK2/src/ModelColumns.h
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/ModelColumns.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,153 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MODELCOLUMNS_HH
+#define _MODELCOLUMNS_HH
+
+#include &lt;time.h&gt;
+#include &lt;glibmm/refptr.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gdkmm/color.h&gt;
+#include &lt;gdkmm/event.h&gt;
+#include &lt;gtkmm/treemodel.h&gt;
+#include &lt;gtkmm/treemodelcolumn.h&gt;
+#include &lt;gtkmm/optionmenu.h&gt;
+
+#include &quot;QueryProperties.h&quot;
+
+/// Model column for text combo boxes.
+class ComboModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+	public:
+		ComboModelColumns();
+		virtual ~ComboModelColumns();
+
+		Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_name;
+
+};
+
+/// Main window, model column for the search engines tree.
+class EnginesModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+	public:
+		EnginesModelColumns();
+		virtual ~EnginesModelColumns();
+
+		Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_name;
+		Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_engineName;
+		Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_option;
+		typedef enum { ENGINE_SEPARATOR = 0, ENGINE_FOLDER,
+			WEB_ENGINE, INTERNAL_INDEX_ENGINE, INDEX_ENGINE } EngineType;
+		Gtk::TreeModelColumn&lt;EngineType&gt; m_type;
+
+};
+
+/// Main window, model column for the queries tree.
+class QueryModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+public:
+	QueryModelColumns();
+	virtual ~QueryModelColumns();
+
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_name;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_lastRun;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_summary;
+	Gtk::TreeModelColumn&lt;QueryProperties&gt; m_properties;
+
+};
+
+/// Main window, model column for the search results tree.
+class ResultsModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+public:
+	ResultsModelColumns();
+	virtual ~ResultsModelColumns();
+
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_text;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_url;
+	Gtk::TreeModelColumn&lt;bool&gt; m_indexed;
+	Gtk::TreeModelColumn&lt;bool&gt; m_viewed;
+	Gtk::TreeModelColumn&lt;int&gt; m_rankDiff;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_score;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_language;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_queryName;
+	Gtk::TreeModelColumn&lt;unsigned int&gt; m_engines;
+	Gtk::TreeModelColumn&lt;unsigned int&gt; m_indexes;
+	typedef enum { RESULT_ROOT = 0, RESULT_TITLE, RESULT_HOST, RESULT_OTHER } ResultType;
+	Gtk::TreeModelColumn&lt;ResultType&gt; m_type;
+
+};
+
+/// Main window, model column for the index tree.
+class IndexModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+public:
+	IndexModelColumns();
+	virtual ~IndexModelColumns();
+
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_text;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_url;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_liveUrl;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_type;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_language;
+	Gtk::TreeModelColumn&lt;unsigned int&gt; m_id;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_timestamp;
+	Gtk::TreeModelColumn&lt;bool&gt; m_labeled;
+
+};
+
+/// Preferences window, model column for the Xapian indexes tree.
+class OtherIndexModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+public:
+	OtherIndexModelColumns();
+	virtual ~OtherIndexModelColumns();
+
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_name;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_location;
+
+};
+
+/// Preferences window, model column for the labels tree.
+/// Export/import window, model column for the labels tree.
+class LabelModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+public:
+	LabelModelColumns();
+	virtual ~LabelModelColumns();
+
+	Gtk::TreeModelColumn&lt;bool&gt; m_enabled;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_name;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_oldName;
+	Gtk::TreeModelColumn&lt;Gdk::Color&gt; m_colour;
+
+};
+
+/// Preferences window, model column for the mail accounts tree.
+class MailAccountModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+public:
+	MailAccountModelColumns();
+	virtual ~MailAccountModelColumns();
+
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_location;
+	Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_type;
+	Gtk::TreeModelColumn&lt;time_t&gt; m_mTime;
+	Gtk::TreeModelColumn&lt;time_t&gt; m_minDate;
+
+};
+
+#endif // _MODELCOLUMNS_HH

Added: trunk/UI/GTK2/src/MonitorHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/MonitorHandler.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/MonitorHandler.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,486 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;StringManip.h&quot;
+#include &quot;Timer.h&quot;
+#include &quot;TimeConverter.h&quot;
+#include &quot;TokenizerFactory.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;FileCollector.h&quot;
+#include &quot;XapianIndex.h&quot;
+#include &quot;XapianEngine.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;MonitorHandler.h&quot;
+
+using namespace std;
+using namespace SigC;
+
+MonitorHandler::MonitorHandler()
+{
+}
+
+MonitorHandler::~MonitorHandler()
+{
+}
+
+Signal3&lt;void, IndexedDocument, unsigned int, string&gt;&amp; MonitorHandler::getUpdateSignal(void)
+{
+	return m_signalUpdate;
+}
+
+MboxHandler::MboxHandler() :
+	MonitorHandler()
+{
+	m_locationsCount = 0;
+	m_hasNewLocations = false;
+}
+
+MboxHandler::~MboxHandler()
+{
+}
+
+bool MboxHandler::checkMailAccount(const string &amp;fileName, PinotSettings::MailAccount &amp;mailAccount,
+		off_t &amp;previousSize)
+{
+	struct stat fileStat;
+
+	mailAccount.m_name = to_utf8(fileName);
+
+	// Ensure it's one of our mail accounts
+	set&lt;PinotSettings::MailAccount&gt; &amp;mailAccounts = PinotSettings::getInstance().m_mailAccounts;
+	set&lt;PinotSettings::MailAccount&gt;::iterator mailIter = mailAccounts.find(mailAccount);
+	if (mailIter == mailAccounts.end())
+	{
+		// It doesn't seem to be
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxHandler::checkMailAccount: not one of &quot; &lt;&lt; mailAccounts.size() &lt;&lt; &quot; accounts&quot; &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	// Find out when it was last modified
+	if ((stat(fileName.c_str(), &amp;fileStat) == 0) &amp;&amp;
+		(!S_ISREG(fileStat.st_mode)))
+	{
+		// This is not a file !
+		return false;
+	}
+
+	if (fileStat.st_mtime &lt;= mailIter-&gt;m_modTime)
+	{
+		// No change since last time...
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxHandler::checkMailAccount: not modified since last time (&quot;
+			&lt;&lt; mailIter-&gt;m_modTime &lt;&lt; &quot;&gt;&quot; &lt;&lt; fileStat.st_mtime &lt;&lt; &quot;)&quot; &lt;&lt; endl;
+#endif
+		return false;
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;MboxHandler::checkMailAccount: modified since last time (&quot;
+		&lt;&lt; mailIter-&gt;m_modTime &lt;&lt; &quot;&lt;&quot; &lt;&lt; fileStat.st_mtime &lt;&lt; &quot;)&quot; &lt;&lt; endl;
+#endif
+
+	// Update this mail account's properties
+	mailAccount = (*mailIter);
+	mailAccount.m_modTime = fileStat.st_mtime;
+	previousSize = mailAccount.m_size;
+	mailAccount.m_size = fileStat.st_size;
+
+	return true;
+}
+
+bool MboxHandler::parseMailAccount(MboxParser &amp;boxParser, IndexInterface *pIndex,
+	LabelManager &amp;labelMan, time_t &amp;lastMessageTime,
+	const string &amp;tempSourceLabel, const string &amp;sourceLabel)
+{
+	bool indexedFile = false;
+
+	if (pIndex == NULL)
+	{
+		return false;
+	}
+
+	// Parse the mbox file
+#ifdef DEBUG
+	Timer timer;
+	timer.start();
+#endif
+	const Document *pMessage = boxParser.getDocument();
+	unsigned int docNum = 0;
+
+	while (pMessage != NULL)
+	{
+		// Has this message already been indexed ?
+		unsigned int docId = pIndex-&gt;hasDocument(*pMessage);
+		if (docId == 0)
+		{
+			pIndex-&gt;setStemmingMode(IndexInterface::STORE_BOTH);
+
+			// Get an ad hoc tokenizer for the message
+			Tokenizer *pTokenizer = TokenizerFactory::getTokenizerByType(pMessage-&gt;getType(), pMessage);
+			if (pTokenizer == NULL)
+			{
+#ifdef DEBUG
+				cout &lt;&lt; &quot;MboxHandler::parseMailAccount: no tokenizer for message &quot; &lt;&lt; docNum &lt;&lt; endl;
+#endif
+				break;	
+			}
+
+			unsigned int docId = 0;
+			indexedFile = pIndex-&gt;indexDocument(*pTokenizer, docId);
+			if (indexedFile == true)
+			{
+				time_t messageDate = boxParser.getDate();
+
+				if (messageDate &gt; lastMessageTime)
+				{
+					// This is the latest message so far
+					lastMessageTime = messageDate;
+				}
+
+				set&lt;string&gt; labels;
+				labels.insert(tempSourceLabel);
+				labelMan.setLabels(docId, pIndex-&gt;getLocation(), labels);
+
+				IndexedDocument docInfo(pMessage-&gt;getTitle(),
+					XapianEngine::buildUrl(PinotSettings::getInstance().m_mailIndexLocation, docId),
+					pMessage-&gt;getLocation(), pMessage-&gt;getType(), pMessage-&gt;getLanguage());
+				docInfo.setTimestamp(TimeConverter::toTimestamp(messageDate));
+
+				// Signal
+				m_signalUpdate(docInfo, docId, _(&quot;My Email&quot;));
+			}
+#ifdef DEBUG
+			else cout &lt;&lt; &quot;MboxHandler::parseMailAccount: couldn't index message &quot; &lt;&lt; docNum &lt;&lt; endl;
+#endif
+
+			delete pTokenizer;
+		}
+		else
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;MboxHandler::parseMailAccount: already indexed message &quot;
+				&lt;&lt; docNum &lt;&lt; &quot;, document ID &quot; &lt;&lt; docId &lt;&lt; endl;
+#endif
+			if (sourceLabel.empty() == false)
+			{
+				set&lt;string&gt; labels;
+
+				// Get the message's labels
+				labelMan.getLabels(docId, pIndex-&gt;getLocation(), labels);
+				// The source label must have been applied to the message when originally indexed
+				set&lt;string&gt;::iterator labelIter = labels.find(sourceLabel.c_str());
+				if (labelIter != labels.end())
+				{
+					// Erase it
+					labels.erase(labelIter);
+					// Add the temporary label
+					labels.insert(tempSourceLabel);
+					labelMan.setLabels(docId, pIndex-&gt;getLocation(), labels);
+				}
+			}
+		}
+
+		// More messages ?
+		if (boxParser.nextMessage() == false)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;MboxHandler::parseMailAccount: no more messages from parser&quot; &lt;&lt; endl;
+#endif
+			break;
+		}
+		pMessage = boxParser.getDocument();
+		++docNum;
+	}
+#ifdef DEBUG
+	long microsecs = timer.stop();
+	cout &lt;&lt; &quot;MboxHandler::parseMailAccount: parsed &quot; &lt;&lt; docNum &lt;&lt; &quot; documents in &quot;
+		&lt;&lt; microsecs/1000000 &lt;&lt; &quot; seconds (&quot; &lt;&lt; microsecs &lt;&lt; &quot;)&quot; &lt;&lt; endl;
+#endif
+
+	return indexedFile;
+}
+
+bool MboxHandler::deleteMessages(IndexInterface *pIndex,  LabelManager &amp;labelMan,
+	const string &amp;sourceLabel)
+{
+	set&lt;unsigned int&gt; docIdList;
+	bool unindexedMsgs = false;
+
+	if (pIndex == NULL)
+	{
+		return false;
+	}
+
+	// Unindex all documents labeled with this source label
+	if ((labelMan.getDocumentsWithLabel(sourceLabel, pIndex-&gt;getLocation(), docIdList) == true) &amp;&amp;
+		(docIdList.empty() == false))
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxHandler::deleteMessages: &quot; &lt;&lt; docIdList.size() &lt;&lt; &quot; message(s) to unindex&quot; &lt;&lt; endl;
+#endif
+		for (set&lt;unsigned int&gt;::iterator docIter = docIdList.begin();
+			docIter != docIdList.end(); ++docIter)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;MboxHandler::deleteMessages: unindexing document ID &quot; &lt;&lt; *docIter &lt;&lt; endl;
+#endif
+			if (pIndex-&gt;unindexDocument(*docIter) == true)
+			{
+				unindexedMsgs = true;
+			}
+		}
+	}
+
+	return unindexedMsgs;
+}
+
+unsigned int MboxHandler::getFileSystemLocations(map&lt;unsigned long, string&gt; &amp;fsLocations)
+{
+	// Reset
+	m_hasNewLocations = false;
+
+	// Get the map of mail accounts
+	set&lt;PinotSettings::MailAccount&gt; &amp;mailAccounts = PinotSettings::getInstance().m_mailAccounts;
+
+	if (fsLocations.empty() == true)
+	{
+		m_hasNewLocations = true;
+	}
+	else
+	{
+		unsigned long fileNum = 0;
+
+		// Do a first pass and look for new accounts
+		for (set&lt;PinotSettings::MailAccount&gt;::iterator mailIter = mailAccounts.begin();
+			mailIter != mailAccounts.end(); ++mailIter)
+		{
+			map&lt;unsigned long, string&gt;::iterator fsIter = fsLocations.find(fileNum);
+			if ((fsIter == fsLocations.end()) ||
+				(fsIter-&gt;second != mailIter-&gt;m_name))
+			{
+				// The mail accounts map has changed
+				m_hasNewLocations = true;
+			}
+
+			++fileNum;
+		}
+
+		fsLocations.clear();
+	}
+
+	// Update the map
+	unsigned long fileNum = 0;
+	for (set&lt;PinotSettings::MailAccount&gt;::iterator mailIter = mailAccounts.begin();
+		mailIter != mailAccounts.end(); ++mailIter)
+	{
+		fsLocations[fileNum] = mailIter-&gt;m_name;
+
+		++fileNum;
+	}
+
+	m_locationsCount = fsLocations.size();
+
+	return fileNum;
+}
+
+bool MboxHandler::hasNewLocations(void) const
+{
+	return m_hasNewLocations;
+}
+
+bool MboxHandler::fileExists(const string &amp;fileName, bool end)
+{
+	LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
+	PinotSettings::MailAccount mailAccount;
+	off_t previousSize = 0;
+
+	if (end == true)
+	{
+		return false;
+	}
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;MboxHandler::fileExists: &quot; &lt;&lt; fileName &lt;&lt; &quot; exists&quot; &lt;&lt; endl;
+#endif
+	if (checkMailAccount(fileName, mailAccount, previousSize) == false)
+	{
+		return false;
+	}
+
+	// Come up with a label for this mbox file's messages
+	string sourceLabel = &quot;<A HREF="mailbox://">mailbox://</A>&quot;;
+	sourceLabel += fileName;
+	string tempSourceLabel = &quot;Temp&quot;;
+	tempSourceLabel += sourceLabel;
+
+	// Get the mail index
+	string indexLocation = PinotSettings::getInstance().m_mailIndexLocation;
+	XapianIndex index(indexLocation);
+	if (index.isGood() == false)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxHandler::fileExists: couldn't get mail index&quot; &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	// Get a parser
+	MboxParser boxParser(fileName);
+
+	bool indexedFile = parseMailAccount(boxParser, &amp;index, labelMan,
+		mailAccount.m_lastMessageTime, tempSourceLabel, sourceLabel);
+
+	// Any document still labeled with this source label wasn't found
+	// this time around and should be unindexed
+	if (deleteMessages(&amp;index, labelMan, sourceLabel) == true)
+	{
+		indexedFile = true;
+	}
+
+	// Rename the temporary label for next time the mbox is parsed
+	labelMan.deleteLabel(sourceLabel);
+	labelMan.renameLabel(tempSourceLabel, sourceLabel);
+
+	// Flush the index
+	index.flush();
+
+	// Update this mail account in the list
+	set&lt;PinotSettings::MailAccount&gt; &amp;mailAccounts = PinotSettings::getInstance().m_mailAccounts;
+	set&lt;PinotSettings::MailAccount&gt;::iterator mailIter = mailAccounts.find(mailAccount);
+	if (mailIter != mailAccounts.end())
+	{
+		mailAccounts.erase(mailIter);
+	}
+	mailAccounts.insert(mailAccount);
+
+	return indexedFile;
+}
+
+void MboxHandler::fileCreated(const string &amp;fileName)
+{
+	// FIXME: if monitoring a directory, index this file
+}
+
+bool MboxHandler::fileChanged(const string &amp;fileName)
+{
+	LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
+	PinotSettings::MailAccount mailAccount;
+	off_t previousSize = 0, mboxOffset = 0;
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;MboxHandler::fileChanged: &quot; &lt;&lt; fileName &lt;&lt; &quot; changed&quot; &lt;&lt; endl;
+#endif
+	if (checkMailAccount(fileName, mailAccount, previousSize) == false)
+	{
+		return false;
+	}
+
+	if (mailAccount.m_size &lt;= previousSize)
+	{
+		// Parse the file from the beginning...
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxHandler::fileChanged: file smaller or same size&quot; &lt;&lt; endl;
+#endif
+		return fileExists(fileName, false);
+	}
+#ifdef DEBUG
+	else cout &lt;&lt; &quot;MboxHandler::fileChanged: file now larger than &quot; &lt;&lt; previousSize &lt;&lt; endl;
+#endif
+
+	// Chances are new messages were added but none removed
+	mboxOffset = previousSize;
+
+	// Come up with a label for this mbox file's messages
+	string sourceLabel = &quot;<A HREF="mailbox://">mailbox://</A>&quot;;
+	sourceLabel += fileName;
+
+	// Get the mail index
+	string indexLocation = PinotSettings::getInstance().m_mailIndexLocation;
+	XapianIndex index(indexLocation);
+	if (index.isGood() == false)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxHandler::fileChanged: couldn't get mail index&quot; &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	// Get a parser
+	MboxParser boxParser(fileName, mboxOffset);
+
+	bool indexedFile = parseMailAccount(boxParser, &amp;index, labelMan,
+		mailAccount.m_lastMessageTime, sourceLabel, &quot;&quot;);
+	if (indexedFile == true)
+	{
+		// Do not attempt to find out if some of the messages were removed
+		// Some messages may also be indexed twice now, eg if another message
+		// was inserted and changed offsets
+		// Let the next fileExists() deal with it and clean up the whole thing
+
+		// Flush the index
+		index.flush();
+	}
+
+	// Update this mail account in the list
+	set&lt;PinotSettings::MailAccount&gt; &amp;mailAccounts = PinotSettings::getInstance().m_mailAccounts;
+	set&lt;PinotSettings::MailAccount&gt;::iterator mailIter = mailAccounts.find(mailAccount);
+	if (mailIter != mailAccounts.end())
+	{
+		mailAccounts.erase(mailIter);
+	}
+	mailAccounts.insert(mailAccount);
+
+	return indexedFile;
+}
+
+bool MboxHandler::fileDeleted(const string &amp;fileName)
+{
+	LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
+	string sourceLabel = string(&quot;<A HREF="mailbox://">mailbox://</A>&quot;) + fileName;
+	bool unindexedFile = false;
+
+	// Get the mail index
+	string indexLocation = PinotSettings::getInstance().m_mailIndexLocation;
+	XapianIndex index(indexLocation);
+	if (index.isGood() == false)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxHandler::fileDeleted: couldn't get mail index&quot; &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	// Unindex all documents labeled with this source label
+	if (deleteMessages(&amp;index, labelMan, sourceLabel) == true)
+	{
+		// Delete the label
+		labelMan.deleteLabel(sourceLabel);
+
+		return true;
+	}
+
+	return false;
+}

Added: trunk/UI/GTK2/src/MonitorHandler.h
===================================================================
--- trunk/UI/GTK2/src/MonitorHandler.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/MonitorHandler.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,106 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#ifndef _MONITORHANDLER_HH
+#define _MONITORHANDLER_HH
+
+#include &lt;time.h&gt;
+#include &lt;string&gt;
+#include &lt;set&gt;
+#include &lt;map&gt;
+#include &lt;sigc++/slot.h&gt;
+
+#include &quot;DocumentInfo.h&quot;
+#include &quot;IndexedDocument.h&quot;
+#include &quot;MboxParser.h&quot;
+#include &quot;LabelManager.h&quot;
+#include &quot;IndexInterface.h&quot;
+#include &quot;PinotSettings.h&quot;
+
+class MonitorHandler
+{
+	public:
+		MonitorHandler();
+		virtual ~MonitorHandler();
+
+		/// Returns a map of locations to monitor.
+		virtual unsigned int getFileSystemLocations(std::map&lt;unsigned long, std::string&gt; &amp;fsLocations) = 0;
+
+		/// Returns true if the locations map has changed since last time.
+		virtual bool hasNewLocations(void) const = 0;
+
+		/// Handles file exists events.
+		virtual bool fileExists(const std::string &amp;fileName, bool end = false) = 0;
+
+		/// Handles file creation events.
+		virtual void fileCreated(const std::string &amp;fileName) = 0;
+
+		/// Handles file changed events.
+		virtual bool fileChanged(const std::string &amp;fileName) = 0;
+
+		/// Handles file deleted events.
+		virtual bool fileDeleted(const std::string &amp;fileName) = 0;
+
+		SigC::Signal3&lt;void, IndexedDocument, unsigned int, std::string&gt;&amp; getUpdateSignal(void);
+
+	protected:
+		SigC::Signal3&lt;void, IndexedDocument, unsigned int, std::string&gt; m_signalUpdate;
+
+	private:
+		MonitorHandler(const MonitorHandler &amp;other);
+		MonitorHandler &amp;operator=(const MonitorHandler &amp;other);
+
+};
+
+class MboxHandler : public MonitorHandler
+{
+	public:
+		MboxHandler();
+		virtual ~MboxHandler();
+
+		virtual unsigned int getFileSystemLocations(std::map&lt;unsigned long, std::string&gt; &amp;fsLocations);
+
+		virtual bool hasNewLocations(void) const;
+
+		virtual bool fileExists(const std::string &amp;fileName, bool end = false);
+
+		virtual void fileCreated(const std::string &amp;fileName);
+
+		virtual bool fileChanged(const std::string &amp;fileName);
+
+		virtual bool fileDeleted(const std::string &amp;fileName);
+
+	protected:
+		unsigned int m_locationsCount;
+		bool m_hasNewLocations;
+
+		bool checkMailAccount(const std::string &amp;fileName, PinotSettings::MailAccount &amp;mailAccount,
+			off_t &amp;previousSize);
+
+		bool parseMailAccount(MboxParser &amp;boxParser, IndexInterface *pIndex,
+			LabelManager &amp;labelMan, time_t &amp;lastMessageTime,
+			const std::string &amp;tempSourceLabel, const std::string &amp;sourceLabel);
+
+		bool deleteMessages(IndexInterface *pIndex, LabelManager &amp;labelMan,
+			const std::string &amp;sourceLabel);
+
+	private:
+		MboxHandler(const MboxHandler &amp;other);
+		MboxHandler &amp;operator=(const MboxHandler &amp;other);
+
+};
+
+#endif	// _MONITORHANDLER_HH

Added: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,1201 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;dirent.h&gt;
+#include &lt;pwd.h&gt;
+#include &lt;algorithm&gt;
+#include &lt;iostream&gt;
+
+#include &lt;glibmm/convert.h&gt;
+#include &lt;libxml++/parsers/domparser.h&gt;
+#include &lt;libxml++/nodes/node.h&gt;
+#include &lt;libxml++/nodes/textnode.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PluginWebEngine.h&quot;
+#include &quot;PinotSettings.h&quot;
+
+using namespace std;
+using namespace Glib;
+using namespace xmlpp;
+
+static string getElementContent(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return &quot;&quot;;
+	}
+
+#ifdef HAS_LIBXMLPP026
+	const TextNode *pText = pElem-&gt;get_child_content();
+#else
+	const TextNode *pText = pElem-&gt;get_child_text();
+#endif
+	if (pText == NULL)
+	{
+		return &quot;&quot;;
+	}
+
+	return pText-&gt;get_content();
+}
+
+static Element *addChildElement(Element *pElem, const string &amp;nodeName, const string &amp;nodeContent)
+{
+	if (pElem == NULL)
+	{
+		return NULL;
+	}
+
+	Element *pSubElem = pElem-&gt;add_child(nodeName);
+	if (pSubElem != NULL)
+	{
+#ifdef HAS_LIBXMLPP026
+		pSubElem-&gt;set_child_content(nodeContent);
+#else
+		pSubElem-&gt;set_child_text(nodeContent);
+#endif
+	}
+
+	return pSubElem;
+}
+
+PinotSettings PinotSettings::m_instance;
+
+PinotSettings::PinotSettings() :
+	m_browseResults(false),
+	m_xPos(0),
+	m_yPos(0),
+	m_width(0),
+	m_height(0),
+	m_panePos(-1),
+	m_ignoreRobotsDirectives(false),
+	m_firstRun(false)
+{
+	// Find out if there is a .pinot directory
+	struct stat fileStat;
+	string directoryName = getConfigurationDirectory();
+	if (stat(directoryName.c_str(), &amp;fileStat) != 0)
+	{
+		// No, create it then
+		if (mkdir(directoryName.c_str(), (mode_t)S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IWGRP|S_IXGRP|S_IROTH|S_IXOTH) == 0)
+		{
+			m_firstRun = true;
+		}
+		else
+		{
+			cerr &lt;&lt; _(&quot;Couldn't create pinot directory at&quot;) &lt;&lt; &quot; &quot;
+				&lt;&lt; directoryName &lt;&lt; endl;
+		}
+	}
+
+	// This is where the internal indices live
+	m_indexLocation = directoryName;
+	m_indexLocation += &quot;/index&quot;;
+	m_mailIndexLocation = directoryName;
+	m_mailIndexLocation += &quot;/mail&quot;;
+
+	// The location of the history database is not configurable
+	m_historyDatabase = directoryName;
+	m_historyDatabase += &quot;/history&quot;;
+}
+
+PinotSettings::~PinotSettings()
+{
+}
+
+PinotSettings &amp;PinotSettings::getInstance(void)
+{
+	return m_instance;
+}
+
+string PinotSettings::getConfigurationDirectory(void)
+{
+	struct passwd *pPasswd = getpwuid(geteuid());
+	string directoryName;
+
+	if ((pPasswd != NULL) &amp;&amp;
+		(pPasswd-&gt;pw_dir != NULL))
+	{
+		directoryName = pPasswd-&gt;pw_dir;
+	}
+	else
+	{
+		char *homeDir = getenv(&quot;HOME&quot;);
+		if (homeDir != NULL)
+		{
+			directoryName = homeDir;
+		}
+		else
+		{
+			return &quot;~/.pinot&quot;;
+		}
+	}
+	directoryName += &quot;/.pinot&quot;;
+
+	return directoryName;
+}
+
+string PinotSettings::getConfigurationFileName(void)
+{
+	string configFileName = getConfigurationDirectory();
+	configFileName += &quot;/config.xml&quot;;
+
+	return configFileName;
+}
+
+string PinotSettings::getCurrentUserName(void)
+{
+	struct passwd *pPasswd = getpwuid(geteuid());
+
+	if ((pPasswd != NULL) &amp;&amp;
+		(pPasswd-&gt;pw_name != NULL))
+	{
+		return pPasswd-&gt;pw_name;
+	}
+
+	return &quot;&quot;;
+}
+
+bool PinotSettings::load(void)
+{
+	// Clear lists
+	m_indexNames.clear();
+	m_indexIds.clear();
+	m_engines.clear();
+	m_engineIds.clear();
+	m_queries.clear();
+	m_labels.clear();
+	m_mailAccounts.clear();
+
+	// Load the configuration file
+	string fileName = getConfigurationFileName();
+	if ((m_firstRun == false) &amp;&amp;
+		(loadConfiguration(fileName) == false))
+	{
+		cerr &lt;&lt; _(&quot;Failed to parse configuration file&quot;) &lt;&lt; &quot; &quot;
+			&lt;&lt; fileName &lt;&lt; endl;
+	}
+	// Internal indices
+	addIndex(_(&quot;My Documents&quot;), m_indexLocation);
+	addIndex(_(&quot;My Email&quot;), m_mailIndexLocation);
+	// Add default labels on the first run
+	if (m_firstRun == true)
+	{
+		ustring labelName =_(&quot;Red&quot;);
+		m_labels.insert(Label(labelName, 65535, 0, 0));
+		labelName =_(&quot;Blue&quot;);
+		m_labels.insert(Label(labelName, 0, 65535, 0));
+		labelName =_(&quot;Green&quot;);
+		m_labels.insert(Label(labelName, 0, 0, 65535));
+	}
+
+	// Some search engines are hardcoded
+#ifdef HAS_GOOGLEAPI
+	m_engineIds[1 &lt;&lt; m_engines.size()] = &quot;Google API&quot;;
+	m_engines.insert(Engine(&quot;Google API&quot;, &quot;googleapi&quot;, &quot;&quot;, &quot;Web Services&quot;));
+	m_engineChannels.insert(&quot;Web Services&quot;);
+#endif
+#ifdef HAS_OSAPI
+	m_engineIds[1 &lt;&lt; m_engines.size()] = &quot;ObjectsSearch API&quot;;
+	m_engines.insert(Engine(&quot;ObjectsSearch API&quot;, &quot;objectssearchapi&quot;, &quot;&quot;, &quot;Web Services&quot;));
+	m_engineChannels.insert(&quot;Web Services&quot;);
+#endif
+	m_engineIds[1 &lt;&lt; m_engines.size()] = &quot;Xapian&quot;;
+	m_engines.insert(Engine(&quot;Xapian&quot;, &quot;xapian&quot;, &quot;&quot;, &quot;&quot;));
+
+	return true;
+}
+
+bool PinotSettings::loadConfiguration(const std::string &amp;fileName)
+{
+	struct stat fileStat;
+
+	if ((stat(fileName.c_str(), &amp;fileStat) != 0) ||
+		(!S_ISREG(fileStat.st_mode)))
+	{
+		return false;
+	}
+
+	// Parse the configuration file
+	DomParser parser;
+	parser.parse_file(fileName);
+	xmlpp::Document *pDocument = parser.get_document();
+	if (pDocument == NULL)
+	{
+		return false;
+	}
+
+	Element *pRootElem = pDocument-&gt;get_root_node();
+	if (pRootElem == NULL)
+	{
+		return false;
+	}
+	string rootNodeName = getElementContent(pRootElem);
+	// FIXME: check the top-level element is okay
+
+	// Go through the subnodes
+	Node::NodeList childNodes = pRootElem-&gt;get_children();
+	if (childNodes.empty() == false)
+	{
+		for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+		{
+			Node *pNode = (*iter);
+			// All nodes should be elements
+			Element *pElem = dynamic_cast&lt;Element*&gt;(pNode);
+			if (pElem == NULL)
+			{
+				continue;
+			}
+
+			string nodeName = pElem-&gt;get_name();
+			string nodeContent = getElementContent(pElem);
+			if (nodeName == &quot;googleapikey&quot;)
+			{
+				m_googleAPIKey = nodeContent;
+			}
+			else if (nodeName == &quot;ui&quot;)
+			{
+				if (loadUi(pElem) == false)
+				{
+					cerr &lt;&lt; _(&quot;Couldn't load ui block&quot;) &lt;&lt; endl;
+				}
+			}
+			else if (nodeName == &quot;extraindex&quot;)
+			{
+				if (loadIndexes(pElem) == false)
+				{
+					cerr &lt;&lt; _(&quot;Couldn't load extraindex block&quot;) &lt;&lt; endl;
+				}
+			}
+			else if (nodeName == &quot;storedquery&quot;)
+			{
+				if (loadQueries(pElem) == false)
+				{
+					cerr &lt;&lt; _(&quot;Couldn't load storedquery block&quot;) &lt;&lt; endl;
+				}
+			}
+			else if (nodeName == &quot;results&quot;)
+			{
+				if (loadResults(pElem) == false)
+				{
+					cerr &lt;&lt; _(&quot;Couldn't load results block&quot;) &lt;&lt; endl;
+				}
+			}
+			else if (nodeName == &quot;label&quot;)
+			{
+				if (loadLabels(pElem) == false)
+				{
+					cerr &lt;&lt; _(&quot;Couldn't load label block&quot;) &lt;&lt; endl;
+				}
+			}
+			else if (nodeName == &quot;robots&quot;)
+			{
+				if (nodeContent == &quot;IGNORE&quot;)
+				{
+					m_ignoreRobotsDirectives = true;
+				}
+				else
+				{
+					m_ignoreRobotsDirectives = false;
+				}
+			}
+			else if (nodeName == &quot;mailaccount&quot;)
+			{
+				if (loadMailAccounts(pElem) == false)
+				{
+					cerr &lt;&lt; _(&quot;Couldn't load mailaccount block&quot;) &lt;&lt; endl;
+				}
+			}
+		}
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadUi(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return false;
+	}
+
+	Node::NodeList childNodes = pElem-&gt;get_children();
+	if (childNodes.empty() == true)
+	{
+		return false;
+	}
+
+	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+	{
+		Node *pNode = (*iter);
+		Element *pElem = dynamic_cast&lt;Element*&gt;(pNode);
+		if (pElem == NULL)
+		{
+			continue;
+		}
+
+		string nodeName = pElem-&gt;get_name();
+		string nodeContent = getElementContent(pElem);
+		if (nodeName == &quot;xpos&quot;)
+		{
+			m_xPos = atoi(nodeContent.c_str());
+		}
+		else if (nodeName == &quot;ypos&quot;)
+		{
+			m_yPos = atoi(nodeContent.c_str());
+		}
+		else if (nodeName == &quot;width&quot;)
+		{
+			m_width = atoi(nodeContent.c_str());
+		}
+		else if (nodeName == &quot;height&quot;)
+		{
+			m_height = atoi(nodeContent.c_str());
+		}
+		else if (nodeName == &quot;panepos&quot;)
+		{
+			m_panePos = atoi(nodeContent.c_str());
+		}
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadIndexes(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return false;
+	}
+
+	Node::NodeList childNodes = pElem-&gt;get_children();
+	if (childNodes.empty() == true)
+	{
+		return false;
+	}
+
+	string indexName, indexLocation;
+
+	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+	{
+		Node *pNode = (*iter);
+		Element *pElem = dynamic_cast&lt;Element*&gt;(pNode);
+		if (pElem == NULL)
+		{
+			continue;
+		}
+
+		string nodeName = pElem-&gt;get_name();
+		string nodeContent = getElementContent(pElem);
+		if (nodeName == &quot;name&quot;)
+		{
+			indexName = nodeContent;
+		}
+		else if (nodeName == &quot;location&quot;)
+		{
+			indexLocation = nodeContent;
+		}
+	}
+
+	if ((indexName.empty() == false) &amp;&amp;
+		(indexLocation.empty() == false))
+	{
+		addIndex(indexName, indexLocation);
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadQueries(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return false;
+	}
+
+	Node::NodeList childNodes = pElem-&gt;get_children();
+	if (childNodes.empty() == true)
+	{
+		return false;
+	}
+
+	QueryProperties queryProps;
+
+	// Load the query's properties
+	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+	{
+		Node *pNode = (*iter);
+		Element *pElem = dynamic_cast&lt;Element*&gt;(pNode);
+		if (pElem == NULL)
+		{
+			continue;
+		}
+
+		string nodeName = pElem-&gt;get_name();
+		string nodeContent = getElementContent(pElem);
+		if (nodeName == &quot;name&quot;)
+		{
+			queryProps.setName(nodeContent);
+		}
+		else if (nodeName == &quot;and&quot;)
+		{
+			queryProps.setAndWords(nodeContent);
+		}
+		else if (nodeName == &quot;phrase&quot;)
+		{
+			queryProps.setPhrase(nodeContent);
+		}
+		else if (nodeName == &quot;any&quot;)
+		{
+			queryProps.setAnyWords(nodeContent);
+		}
+		else if (nodeName == &quot;not&quot;)
+		{
+			queryProps.setNotWords(nodeContent);
+		}
+		else if (nodeName == &quot;language&quot;)
+		{
+			queryProps.setLanguage(nodeContent);
+		}
+		else if (nodeName == &quot;hostname&quot;)
+		{
+			queryProps.setHostNameFilter(nodeContent);
+		}
+		else if (nodeName == &quot;filename&quot;)
+		{
+			queryProps.setFileNameFilter(nodeContent);
+		}
+		else if (nodeName == &quot;maxresults&quot;)
+		{
+			int count = atoi(nodeContent.c_str());
+			queryProps.setMaximumResultsCount((unsigned int)max(count, 10));
+		}
+		else if (nodeName == &quot;index&quot;)
+		{
+			if (nodeContent == &quot;ALL&quot;)
+			{
+				queryProps.setIndexResults(true);
+			}
+			else
+			{
+				queryProps.setIndexResults(false);
+			}
+		}
+		else if (nodeName == &quot;label&quot;)
+		{
+			queryProps.setLabelName(nodeContent);
+		}
+	}
+
+	// We need at least a name
+	if (queryProps.getName().empty() == false)
+	{
+		m_queries[queryProps.getName()] = queryProps;
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadResults(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return false;
+	}
+
+	Node::NodeList childNodes = pElem-&gt;get_children();
+	if (childNodes.empty() == true)
+	{
+		return false;
+	}
+
+	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+	{
+		Node *pNode = (*iter);
+		Element *pElem = dynamic_cast&lt;Element*&gt;(pNode);
+		if (pElem == NULL)
+		{
+			continue;
+		}
+
+		string nodeName = pElem-&gt;get_name();
+		string nodeContent = getElementContent(pElem);
+		if (nodeName == &quot;viewmode&quot;)
+		{
+			if (nodeContent == &quot;SOURCE&quot;)
+			{
+				m_browseResults = false;
+			}
+			else
+			{
+				m_browseResults = true;
+			}
+		}
+		else if (nodeName == &quot;browser&quot;)
+		{
+			m_browserCommand = nodeContent;
+		}
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadLabels(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return false;
+	}
+
+	Node::NodeList childNodes = pElem-&gt;get_children();
+	if (childNodes.empty() == true)
+	{
+		return false;
+	}
+
+	Label label;
+
+	// Load the label's properties
+	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+	{
+		Node *pNode = (*iter);
+		Element *pElem = dynamic_cast&lt;Element*&gt;(pNode);
+		if (pElem == NULL)
+		{
+			continue;
+		}
+
+		string nodeName = pElem-&gt;get_name();
+		string nodeContent = getElementContent(pElem);
+
+		if (nodeName == &quot;name&quot;)
+		{
+			label.m_name = nodeContent;
+		}
+		else if (nodeName == &quot;red&quot;)
+		{
+			label.m_red = (unsigned short)atoi(nodeContent.c_str());
+		}
+		else if (nodeName == &quot;green&quot;)
+		{
+			label.m_green = (unsigned short)atoi(nodeContent.c_str());
+		}
+		else if (nodeName == &quot;blue&quot;)
+		{
+			label.m_blue = (unsigned short)atoi(nodeContent.c_str());
+		}
+	}
+
+	if (label.m_name.empty() == false)
+	{
+		m_labels.insert(label);
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadMailAccounts(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return false;
+	}
+
+	Node::NodeList childNodes = pElem-&gt;get_children();
+	if (childNodes.empty() == true)
+	{
+		return false;
+	}
+
+	MailAccount mailAccount;
+
+	// Load the mail account's properties
+	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+	{
+		Node *pNode = (*iter);
+		Element *pElem = dynamic_cast&lt;Element*&gt;(pNode);
+		if (pElem == NULL)
+		{
+			continue;
+		}
+
+		string nodeName = pElem-&gt;get_name();
+		string nodeContent = getElementContent(pElem);
+
+		if (nodeName == &quot;name&quot;)
+		{
+			mailAccount.m_name = nodeContent;
+		}
+		else if (nodeName == &quot;type&quot;)
+		{
+			mailAccount.m_type = nodeContent;
+		}
+		else if (nodeName == &quot;mtime&quot;)
+		{
+			mailAccount.m_modTime = (time_t)atoi(nodeContent.c_str());
+		}
+		else if (nodeName == &quot;mindate&quot;)
+		{
+			mailAccount.m_lastMessageTime = (time_t)atoi(nodeContent.c_str());
+		}
+		else if (nodeName == &quot;size&quot;)
+		{
+			mailAccount.m_size = (off_t)atoi(nodeContent.c_str());
+		}
+	}
+
+	if (mailAccount.m_name.empty() == false)
+	{
+		m_mailAccounts.insert(mailAccount);
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadSearchEngines(const string &amp;directoryName)
+{
+	if (directoryName.empty() == true)
+	{
+		return true;
+	}
+
+	DIR *pDir = opendir(directoryName.c_str());
+	if (pDir == NULL)
+	{
+		return false;
+	}
+
+	// Iterate through this directory's entries
+	struct dirent *pDirEntry = readdir(pDir);
+	while (pDirEntry != NULL)
+	{
+		char *pEntryName = pDirEntry-&gt;d_name;
+		if (pEntryName != NULL)
+		{
+			struct stat fileStat;
+			string location = directoryName;
+			location += &quot;/&quot;;
+			location += pEntryName;
+
+			// Is that a file ?
+			if ((stat(location.c_str(), &amp;fileStat) == 0) &amp;&amp;
+				(S_ISREG(fileStat.st_mode)))
+			{
+				string engineName, engineChannel;
+
+				if ((PluginWebEngine::getDetails(location, engineName, engineChannel) == true) &amp;&amp;
+					(engineName.empty() == false))
+				{
+					m_engineIds[1 &lt;&lt; m_engines.size()] = engineName;
+					if (engineChannel.empty() == true)
+					{
+						engineChannel = _(&quot;Unclassified&quot;);
+					}
+					m_engines.insert(Engine(engineName, &quot;sherlock&quot;, location, engineChannel));
+					m_engineChannels.insert(engineChannel);
+				}
+			}
+		}
+
+		// Next entry
+		pDirEntry = readdir(pDir);
+	}
+	closedir(pDir);
+
+	return true;
+}
+
+bool PinotSettings::save(void)
+{
+	Element *pRootElem = NULL;
+	Element *pElem = NULL;
+	char numStr[64];
+
+	xmlpp::Document doc(&quot;1.0&quot;);
+
+	// Create a new node
+	pRootElem = doc.create_root_node(&quot;pinot&quot;);
+	if (pRootElem == NULL)
+	{
+		return false;
+	}
+	// ...with text children nodes
+	addChildElement(pRootElem, &quot;googleapikey&quot;, m_googleAPIKey);
+	// User interface position and size
+	pElem = pRootElem-&gt;add_child(&quot;ui&quot;);
+	if (pElem == NULL)
+	{
+		return false;
+	}
+	sprintf(numStr, &quot;%d&quot;, m_xPos);
+	addChildElement(pElem, &quot;xpos&quot;, numStr);
+	sprintf(numStr, &quot;%d&quot;, m_yPos);
+	addChildElement(pElem, &quot;ypos&quot;, numStr);
+	sprintf(numStr, &quot;%d&quot;, m_width);
+	addChildElement(pElem, &quot;width&quot;, numStr);
+	sprintf(numStr, &quot;%d&quot;, m_height);
+	addChildElement(pElem, &quot;height&quot;, numStr);
+	sprintf(numStr, &quot;%d&quot;, m_panePos);
+	addChildElement(pElem, &quot;panepos&quot;, numStr);
+	// User-defined indexes
+	for (map&lt;string, string&gt;::iterator indexIter = m_indexNames.begin(); indexIter != m_indexNames.end(); ++indexIter)
+	{
+		string indexName = indexIter-&gt;first;
+
+		if (isInternalIndex(indexName) == true)
+		{
+			continue;
+		}
+
+		pElem = pRootElem-&gt;add_child(&quot;extraindex&quot;);
+		if (pElem == NULL)
+		{
+			return false;
+		}
+		addChildElement(pElem, &quot;name&quot;, indexIter-&gt;first);
+		addChildElement(pElem, &quot;location&quot;, indexIter-&gt;second);
+	}
+	// User-defined queries
+	for (map&lt;string, QueryProperties&gt;::iterator queryIter = m_queries.begin();
+		queryIter != m_queries.end(); ++queryIter)
+	{
+		pElem = pRootElem-&gt;add_child(&quot;storedquery&quot;);
+		if (pElem == NULL)
+		{
+			return false;
+		}
+		addChildElement(pElem, &quot;name&quot;, queryIter-&gt;first);
+		addChildElement(pElem, &quot;type&quot;, &quot;FIXED&quot;);
+		addChildElement(pElem, &quot;and&quot;, queryIter-&gt;second.getAndWords());
+		addChildElement(pElem, &quot;phrase&quot;, queryIter-&gt;second.getPhrase());
+		addChildElement(pElem, &quot;any&quot;, queryIter-&gt;second.getAnyWords());
+		addChildElement(pElem, &quot;not&quot;, queryIter-&gt;second.getNotWords());
+		addChildElement(pElem, &quot;hostname&quot;, queryIter-&gt;second.getHostNameFilter());
+		addChildElement(pElem, &quot;filename&quot;, queryIter-&gt;second.getFileNameFilter());
+		addChildElement(pElem, &quot;language&quot;, queryIter-&gt;second.getLanguage());
+		sprintf(numStr, &quot;%u&quot;, queryIter-&gt;second.getMaximumResultsCount());
+		addChildElement(pElem, &quot;maxresults&quot;, numStr);
+		addChildElement(pElem, &quot;index&quot;, (queryIter-&gt;second.getIndexResults() ? &quot;ALL&quot; : &quot;NONE&quot;));
+		addChildElement(pElem, &quot;label&quot;, queryIter-&gt;second.getLabelName());
+	}
+	pElem = pRootElem-&gt;add_child(&quot;results&quot;);
+	if (pElem == NULL)
+	{
+		return false;
+	}
+	// Results view options
+	addChildElement(pElem, &quot;viewmode&quot;, (m_browseResults ? &quot;BROWSE&quot; : &quot;SOURCE&quot;));
+	addChildElement(pElem, &quot;browser&quot;, m_browserCommand);
+	// Labels
+	for (set&lt;Label&gt;::iterator labelIter = m_labels.begin(); labelIter != m_labels.end(); ++labelIter)
+	{
+		pElem = pRootElem-&gt;add_child(&quot;label&quot;);
+		if (pElem == NULL)
+		{
+			return false;
+		}
+		addChildElement(pElem, &quot;name&quot;, labelIter-&gt;m_name);
+		sprintf(numStr, &quot;%u&quot;, labelIter-&gt;m_red);
+		addChildElement(pElem, &quot;red&quot;, numStr);
+		sprintf(numStr, &quot;%u&quot;, labelIter-&gt;m_green);
+		addChildElement(pElem, &quot;green&quot;, numStr);
+		sprintf(numStr, &quot;%u&quot;, labelIter-&gt;m_blue);
+		addChildElement(pElem, &quot;blue&quot;, numStr);
+	}
+	// Ignore robots directives
+	addChildElement(pRootElem, &quot;robots&quot;, (m_ignoreRobotsDirectives ? &quot;IGNORE&quot; : &quot;OBEY&quot;));
+	// Mail accounts
+	for (set&lt;MailAccount&gt;::iterator mailIter = m_mailAccounts.begin(); mailIter != m_mailAccounts.end(); ++mailIter)
+	{
+		pElem = pRootElem-&gt;add_child(&quot;mailaccount&quot;);
+		if (pElem == NULL)
+		{
+			return false;
+		}
+		addChildElement(pElem, &quot;name&quot;, mailIter-&gt;m_name);
+		addChildElement(pElem, &quot;type&quot;, mailIter-&gt;m_type);
+		sprintf(numStr, &quot;%u&quot;, mailIter-&gt;m_modTime);
+		addChildElement(pElem, &quot;mtime&quot;, numStr);
+		sprintf(numStr, &quot;%u&quot;, mailIter-&gt;m_lastMessageTime);
+		addChildElement(pElem, &quot;mindate&quot;, numStr);
+		sprintf(numStr, &quot;%u&quot;, mailIter-&gt;m_size);
+		addChildElement(pElem, &quot;size&quot;, numStr);
+	}
+
+	// Save to file
+	doc.write_to_file_formatted(getConfigurationFileName());
+
+	return true;
+}
+
+/// Returns the indexes map, keyed by name.
+const map&lt;string, string&gt; &amp;PinotSettings::getIndexes(void) const
+{
+	return m_indexNames;
+}
+
+/// Returns true if the given index is internal.
+bool PinotSettings::isInternalIndex(const string &amp;indexName) const
+{
+	if ((indexName == _(&quot;My Documents&quot;)) ||
+		(indexName == _(&quot;My Email&quot;)))
+	{
+		return true;
+	}
+
+	return false;		
+}
+
+/// Adds a new index.
+bool PinotSettings::addIndex(const string &amp;name, const string &amp;location)
+{
+	map&lt;string, string&gt;::iterator namesMapIter = m_indexNames.find(name);
+	if (namesMapIter == m_indexNames.end())
+	{
+		// Okay, no such index exists
+		m_indexIds[1 &lt;&lt; m_indexNames.size()] = name;
+		m_indexNames[name] = location;
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Removes an index.
+bool PinotSettings::removeIndex(const string &amp;name)
+{
+	// Remove from the names map
+	map&lt;string, string&gt;::iterator namesMapIter = m_indexNames.find(name);
+	if (namesMapIter != m_indexNames.end())
+	{
+		m_indexNames.erase(namesMapIter);
+
+		// Remove from the IDs map
+		for (map&lt;unsigned int, string&gt;::iterator idsMapIter = m_indexIds.begin();
+			idsMapIter != m_indexIds.end(); ++idsMapIter)
+		{
+			if (idsMapIter-&gt;second == name)
+			{
+				m_indexIds.erase(idsMapIter);
+			}
+		}
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Clears the indexes map.
+void PinotSettings::clearIndexes(void)
+{
+	// Clear both maps, reinsert the internal index
+	m_indexNames.clear();
+	m_indexIds.clear();
+	addIndex(_(&quot;My Documents&quot;), m_indexLocation);
+	addIndex(_(&quot;My Email&quot;), m_mailIndexLocation);
+}
+
+/// Returns an ID that identifies the given index.
+unsigned int PinotSettings::getIndexId(const std::string &amp;name)
+{
+	unsigned int indexId = 0;
+	for (map&lt;unsigned int, string&gt;::iterator mapIter = m_indexIds.begin();
+		mapIter != m_indexIds.end(); ++mapIter)
+	{
+		if (mapIter-&gt;second == name)
+		{
+			indexId = mapIter-&gt;first;
+			break;
+		}
+	}
+
+	return indexId;
+}
+
+/// Returns the name(s) for the given ID.
+void PinotSettings::getIndexNames(unsigned int id, std::set&lt;std::string&gt; &amp;names)
+{
+	names.clear();
+
+	// Make sure there are indexes defined
+	if (m_indexNames.empty() == true)
+	{
+		return;
+	}
+
+	unsigned indexId = 1 &lt;&lt; (m_indexNames.size() - 1);
+	do
+	{
+		if (id &amp; indexId)
+		{
+			map&lt;unsigned int, string&gt;::iterator mapIter = m_indexIds.find(indexId);
+			if (mapIter != m_indexIds.end())
+			{
+				// Get the associated name
+				names.insert(mapIter-&gt;second);
+			}
+		}
+		// Shift to the right
+		indexId = indexId &gt;&gt; 1;
+	} while (indexId &gt; 0);
+}
+
+/// Returns the search engines set.
+bool PinotSettings::getSearchEngines(set&lt;PinotSettings::Engine&gt; &amp;engines, string channelName) const
+{
+	if (channelName.empty() == true)
+	{
+		// Copy the whole list of search engines
+		copy(m_engines.begin(), m_engines.end(), inserter(engines, engines.begin()));
+	}
+	else
+	{
+		if (m_engineChannels.find(channelName) == m_engineChannels.end())
+		{
+			// Unknown channel name
+			return false;
+		}
+
+		// Copy channels that belong to the given channel
+		for (set&lt;Engine&gt;::iterator engineIter = m_engines.begin(); engineIter != m_engines.end(); ++engineIter)
+		{
+			if (engineIter-&gt;m_channel == channelName)
+			{
+				engines.insert(*engineIter);
+			}
+		}
+	}
+
+	return true;
+}
+
+/// Returns an ID that identifies the given engine name.
+unsigned int PinotSettings::getEngineId(const string &amp;name)
+{
+	unsigned int engineId = 0;
+	for (map&lt;unsigned int, string&gt;::iterator mapIter = m_engineIds.begin();
+		mapIter != m_engineIds.end(); ++mapIter)
+	{
+		if (mapIter-&gt;second == name)
+		{
+			engineId = mapIter-&gt;first;
+			break;
+		}
+	}
+
+	return engineId;
+}
+
+/// Returns the name for the given ID.
+void PinotSettings::getEngineNames(unsigned int id, set&lt;string&gt; &amp;names)
+{
+	names.clear();
+
+	// Make sure there are search engines defined
+	if (m_engines.empty() == true)
+	{
+		return;
+	}
+
+	unsigned engineId = 1 &lt;&lt; (m_engines.size() - 1);
+	do
+	{
+		if (id &amp; engineId)
+		{
+			map&lt;unsigned int, string&gt;::iterator mapIter = m_engineIds.find(engineId);
+			if (mapIter != m_engineIds.end())
+			{
+				// Get the associated name
+				names.insert(mapIter-&gt;second);
+			}
+		}
+		// Shift to the right
+		engineId = engineId &gt;&gt; 1;
+	} while (engineId &gt; 0);
+}
+
+/// Returns the search engines channels.
+const set&lt;string&gt; &amp;PinotSettings::getSearchEnginesChannels(void) const
+{
+	return m_engineChannels;
+}
+
+/// Returns the queries map, keyed by name.
+const map&lt;string, QueryProperties&gt; &amp;PinotSettings::getQueries(void) const
+{
+	return m_queries;
+}
+
+/// Adds a new query.
+bool PinotSettings::addQuery(const QueryProperties &amp;properties)
+{
+	string name = properties.getName();
+
+	map&lt;string, QueryProperties&gt;::iterator queryIter = m_queries.find(name);
+	if (queryIter == m_queries.end())
+	{
+		// Okay, no such query exists
+		m_queries[name] = properties;
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Removes a query.
+bool PinotSettings::removeQuery(const string &amp;name)
+{
+	// Remove from the map
+	map&lt;string, QueryProperties&gt;::iterator queryIter = m_queries.find(name);
+	if (queryIter != m_queries.end())
+	{
+		m_queries.erase(queryIter);
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Clears the queries map.
+void PinotSettings::clearQueries(void)
+{
+	m_queries.clear();
+}
+
+PinotSettings::Engine::Engine()
+{
+}
+
+PinotSettings::Engine::Engine(string name, string type, string option, string channel)
+{
+	m_name = name;
+	m_type = type;
+	m_option = option;
+	m_channel = channel;
+}
+
+PinotSettings::Engine::~Engine()
+{
+}
+
+bool PinotSettings::Engine::operator&lt;(const PinotSettings::Engine &amp;other) const
+{
+	if (m_name &lt; other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+bool PinotSettings::Engine::operator==(const Engine &amp;other) const
+{
+	if (m_name == other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+PinotSettings::Label::Label() :
+	m_red(0),
+	m_green(0),
+	m_blue(0)
+{
+}
+
+PinotSettings::Label::Label(ustring &amp;name, unsigned short red,
+	unsigned short green, unsigned short blue) :
+	m_name(name),
+	m_red(red),
+	m_green(blue),
+	m_blue(green)
+{
+}
+
+PinotSettings::Label::~Label()
+{
+}
+
+bool PinotSettings::Label::operator&lt;(const PinotSettings::Label &amp;other) const
+{
+	if (m_name &lt; other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+bool PinotSettings::Label::operator==(const Label &amp;other) const
+{
+	if (m_name == other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+PinotSettings::MailAccount::MailAccount()
+{
+	m_modTime = m_lastMessageTime = (time_t)0;
+	m_size = 0;
+}
+
+PinotSettings::MailAccount::MailAccount(const MailAccount &amp;other)
+{
+	m_name = other.m_name;
+	m_type = other.m_type;
+	m_modTime = other.m_modTime;
+	m_lastMessageTime = other.m_lastMessageTime;
+	m_size = other.m_size;
+}
+
+PinotSettings::MailAccount::~MailAccount()
+{
+}
+
+bool PinotSettings::MailAccount::operator&lt;(const MailAccount &amp;other) const
+{
+	if (m_name &lt; other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+bool PinotSettings::MailAccount::operator==(const MailAccount &amp;other) const
+{
+	if (m_name == other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}


Property changes on: trunk/UI/GTK2/src/PinotSettings.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/PinotSettings.h
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/PinotSettings.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,184 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _PINOTSETTINGS_HH
+#define _PINOTSETTINGS_HH
+
+#include &lt;sys/types.h&gt;
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;set&gt;
+#include &lt;vector&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;libxml++/nodes/element.h&gt;
+
+#include &quot;QueryProperties.h&quot;
+
+class PinotSettings
+{
+	public:
+		~PinotSettings();
+
+		static PinotSettings &amp;getInstance(void);
+
+		static std::string getConfigurationDirectory(void);
+
+		static std::string getConfigurationFileName(void);
+
+		static std::string getCurrentUserName(void);
+
+		bool load(void);
+
+		bool loadSearchEngines(const std::string &amp;directoryName);
+
+		bool save(void);
+
+		/// Returns the indexes map, keyed by name.
+		const std::map&lt;std::string, std::string&gt; &amp;getIndexes(void) const;
+
+		/// Returns true if the given index is internal.
+		bool isInternalIndex(const string &amp;indexName) const;
+
+		/// Adds a new index.
+		bool addIndex(const std::string &amp;name, const std::string &amp;location);
+
+		/// Removes an index.
+		bool removeIndex(const std::string &amp;name);
+
+		/// Clears the indexes map.
+		void clearIndexes(void);
+
+		/// Returns an ID that identifies the given index.
+		unsigned int getIndexId(const std::string &amp;name);
+
+		/// Returns the name(s) for the given ID.
+		void getIndexNames(unsigned int id, std::set&lt;std::string&gt; &amp;names);
+
+		class Engine
+		{
+			public:
+				Engine();
+				Engine(std::string name, std::string type, std::string option, std::string channel);
+				~Engine();
+
+				bool operator&lt;(const Engine &amp;other) const;
+				bool operator==(const Engine &amp;other) const;
+
+				std::string m_name;
+				std::string m_type;
+				std::string m_option;
+				std::string m_channel;
+		};
+
+		/// Returns the search engines set.
+		bool getSearchEngines(std::set&lt;Engine&gt; &amp;engines, std::string channelName = &quot;&quot;) const;
+
+		/// Returns an ID that identifies the given engine name.
+		unsigned int getEngineId(const std::string &amp;name);
+
+		/// Returns the name(s) for the given ID.
+		void getEngineNames(unsigned int id, std::set&lt;std::string&gt; &amp;names);
+
+		/// Returns the search engines channels.
+		const std::set&lt;std::string&gt; &amp;getSearchEnginesChannels(void) const;
+
+		/// Returns the queries map, keyed by name.
+		const std::map&lt;std::string, QueryProperties&gt; &amp;getQueries(void) const;
+
+		/// Adds a new query.
+		bool addQuery(const QueryProperties &amp;properties);
+
+		/// Removes a query.
+		bool removeQuery(const std::string &amp;name);
+
+		/// Clears the queries map.
+		void clearQueries(void);
+
+		class Label
+		{
+			public:
+				Label();
+				Label(Glib::ustring &amp;name, unsigned short red,
+					unsigned short green, unsigned short blue);
+				~Label();
+
+				bool operator&lt;(const Label &amp;other) const;
+				bool operator==(const Label &amp;other) const;
+
+				Glib::ustring m_name;
+				unsigned short m_red;
+				unsigned short m_green;
+				unsigned short m_blue;
+		};
+
+		class MailAccount
+		{
+			public:
+				MailAccount();
+				MailAccount(const MailAccount &amp;other);
+				~MailAccount();
+
+				bool operator&lt;(const MailAccount &amp;other) const;
+				bool operator==(const MailAccount &amp;other) const;
+
+				Glib::ustring m_name;
+				Glib::ustring m_type;
+				time_t m_modTime;
+				time_t m_lastMessageTime;
+				off_t m_size;
+		};
+
+		Glib::ustring m_googleAPIKey;
+		Glib::ustring m_indexLocation;
+		Glib::ustring m_mailIndexLocation;
+		Glib::ustring m_historyDatabase;
+		bool m_browseResults;
+		Glib::ustring m_browserCommand;
+		int m_xPos;
+		int m_yPos;
+		int m_width;
+		int m_height;
+		int m_panePos;
+		std::set&lt;Label&gt; m_labels;
+		bool m_ignoreRobotsDirectives;
+		std::set&lt;MailAccount&gt; m_mailAccounts;
+
+	protected:
+		static PinotSettings m_instance;
+		bool m_firstRun;
+		std::map&lt;std::string, std::string&gt; m_indexNames;
+		std::map&lt;unsigned int, std::string&gt; m_indexIds;
+		std::set&lt;Engine&gt; m_engines;
+		std::map&lt;unsigned int, std::string&gt; m_engineIds;
+		std::set&lt;std::string&gt; m_engineChannels;
+		std::map&lt;std::string, QueryProperties&gt; m_queries;
+
+		PinotSettings();
+		bool loadConfiguration(const std::string &amp;fileName);
+		bool loadUi(const xmlpp::Element *pElem);
+		bool loadIndexes(const xmlpp::Element *pElem);
+		bool loadQueries(const xmlpp::Element *pElem);
+		bool loadResults(const xmlpp::Element *pElem);
+		bool loadLabels(const xmlpp::Element *pElem);
+		bool loadMailAccounts(const xmlpp::Element *pElem);
+
+	private:
+		PinotSettings(const PinotSettings &amp;other);
+		PinotSettings &amp;operator=(const PinotSettings &amp;other);
+
+};
+
+#endif // _PINOTSETTINGS_HH


Property changes on: trunk/UI/GTK2/src/PinotSettings.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/PinotUtils.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/PinotUtils.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,169 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+#include &lt;gtkmm/stock.h&gt;
+#include &lt;gtkmm/filechooserdialog.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PinotUtils.h&quot;
+
+using namespace std;
+using namespace Glib;
+using namespace Gtk;
+
+bool select_file_name(Window &amp;parentWindow, const ustring &amp;title,
+	ustring &amp;location, bool openOrCreate, bool directoriesOnly)
+{
+	FileChooserAction chooserAction = FILE_CHOOSER_ACTION_OPEN;
+	StockID okButtonStockId = Stock::OPEN;
+
+	if (title.empty() == true)
+	{
+		return false;
+	}
+
+	// Have we been provided with an initial location ?
+	if (location.empty() == true)
+	{
+		// No, get the location of the home directory then
+		char *homeDir = getenv(&quot;HOME&quot;);
+		if (homeDir != NULL)
+		{
+			location = homeDir;
+			location += &quot;/&quot;;
+		}
+	}
+
+	if (directoriesOnly == false)
+	{
+		if (openOrCreate == true)
+		{
+			chooserAction = FILE_CHOOSER_ACTION_OPEN;
+		}
+		else
+		{
+			chooserAction = FILE_CHOOSER_ACTION_SAVE;
+			okButtonStockId = Stock::SAVE;
+		}
+	}
+	else
+	{
+		if (openOrCreate == true)
+		{
+			chooserAction = FILE_CHOOSER_ACTION_SELECT_FOLDER;
+		}
+		else
+		{
+			chooserAction = FILE_CHOOSER_ACTION_CREATE_FOLDER;
+			okButtonStockId = Stock::SAVE;
+		}
+	}
+
+	FileChooserDialog fileChooser(title, chooserAction);
+	fileChooser.set_filename(filename_from_utf8(location));
+	fileChooser.set_local_only();
+	fileChooser.set_select_multiple(false);
+	fileChooser.set_transient_for(parentWindow);
+	// Add response buttons
+	fileChooser.add_button(Stock::CANCEL, Gtk::RESPONSE_CANCEL);
+	fileChooser.add_button(okButtonStockId, Gtk::RESPONSE_OK);
+	// FIXME: add FileFilter's
+	fileChooser.show();
+	int result = fileChooser.run();
+	if (result == RESPONSE_OK)
+	{
+		// Retrieve the chosen location
+		if (directoriesOnly == false)
+		{
+			location = filename_to_utf8(fileChooser.get_filename());
+		}
+		else
+		{
+			location = filename_to_utf8(fileChooser.get_current_folder());
+		}
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Create a resizable text column.
+TreeViewColumn *create_resizable_column(const ustring &amp;title, const TreeModelColumnBase&amp; modelColumn)
+{
+	TreeViewColumn *treeColumn = new TreeViewColumn(title);
+
+	CellRendererText *textCellRenderer = new CellRendererText();
+	treeColumn-&gt;pack_start(*manage(textCellRenderer));
+	treeColumn-&gt;add_attribute(textCellRenderer-&gt;property_text(), modelColumn);
+	treeColumn-&gt;set_resizable(true);
+
+	return treeColumn;
+}
+
+/// Create a resizable text column, rendered by renderTextCell.
+TreeViewColumn *create_resizable_column(const ustring &amp;title, const TreeModelColumnBase&amp; modelColumn,
+	const TreeViewColumn::SlotCellData &amp;renderTextCell)
+{
+	TreeViewColumn *treeColumn = new TreeViewColumn(title);
+
+	CellRendererText *textCellRenderer = new CellRendererText();
+	treeColumn-&gt;pack_start(*manage(textCellRenderer));
+	// This will be called to render the text
+	treeColumn-&gt;set_cell_data_func(*textCellRenderer, renderTextCell);
+
+	treeColumn-&gt;add_attribute(textCellRenderer-&gt;property_text(), modelColumn);
+	treeColumn-&gt;set_resizable(true);
+
+	return treeColumn;
+}
+
+/// Create a resizable icon and text column, rendered by renderTextAndIconCell.
+TreeViewColumn *create_resizable_column_with_icon(const ustring &amp;title,
+	const TreeModelColumnBase&amp; modelColumn, const TreeViewColumn::SlotCellData &amp;renderTextAndIconCell)
+{
+	TreeViewColumn *treeColumn = new TreeViewColumn(title);
+
+	// Pack an icon renderer in the column
+	CellRendererPixbuf *iconRenderer = new CellRendererPixbuf();
+	treeColumn-&gt;pack_start(*manage(iconRenderer), false);
+	treeColumn-&gt;set_cell_data_func(*iconRenderer, renderTextAndIconCell);
+	// ...followed by a text renderer
+	CellRendererText *textCellRenderer = new CellRendererText();
+	treeColumn-&gt;pack_start(*manage(textCellRenderer));
+	treeColumn-&gt;set_cell_data_func(*textCellRenderer, renderTextAndIconCell);
+
+	treeColumn-&gt;add_attribute(textCellRenderer-&gt;property_text(), modelColumn);
+	treeColumn-&gt;set_resizable(true);
+
+	return treeColumn;
+}
+
+/// Converts to UTF-8, catches conversion errors
+ustring to_utf8(string text, ustring fallback)
+{
+	try
+	{
+		return locale_to_utf8(text);
+	}
+	catch (ConvertError &amp;ce)
+	{
+	}
+
+	return fallback;
+}

Added: trunk/UI/GTK2/src/PinotUtils.h
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/PinotUtils.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,82 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#ifndef _PINOTUTILS_HH
+#define _PINOTUTILS_HH
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
+#include &lt;sigc++/compatibility.h&gt;
+#endif
+#include &lt;sigc++/signal.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gtkmm/window.h&gt;
+#include &lt;gtkmm/treeview.h&gt;
+#include &lt;gtkmm/treemodel.h&gt;
+
+/**
+  * DCTreeView subclasses TreeView and handles double clicks.
+  * Handling double-clicks on tree views is not straight-forward, see :
+  * <A HREF="http://bugzilla.gnome.org/show_bug.cgi?id=89780">http://bugzilla.gnome.org/show_bug.cgi?id=89780</A>
+  * <A HREF="http://www.gtkmm.org/gtkmm2/docs/tutorial/html/ch08s07.html">http://www.gtkmm.org/gtkmm2/docs/tutorial/html/ch08s07.html</A>
+  */
+class DCTreeView : public Gtk::TreeView
+{
+	public:
+		DCTreeView() : Gtk::TreeView() {}
+		virtual ~DCTreeView() {}
+
+		SigC::Signal0&lt;void&gt; signal_double_click_event;
+
+	protected:
+		bool on_button_press_event(GdkEventButton* event)
+		{
+			// Check for double clicks
+			if (event-&gt;type == GDK_2BUTTON_PRESS)
+			{
+				signal_double_click_event();
+				return true;
+			}
+
+			// Not handled
+			return TreeView::on_button_press_event(event);
+		}
+
+};
+
+/// Open a FileSelector and request a file. Location can be initialized.
+bool select_file_name(Gtk::Window &amp;parentWindow, const Glib::ustring &amp;title,
+	Glib::ustring &amp;location, bool openOrCreate = true, bool directoriesOnly = false);
+
+/// Create a resizable text column.
+Gtk::TreeViewColumn *create_resizable_column(const Glib::ustring &amp;title,
+	const Gtk::TreeModelColumnBase&amp; modelColumn);
+
+/// Create a resizable text column, rendered by renderTextCell.
+Gtk::TreeViewColumn *create_resizable_column(const Glib::ustring &amp;title,
+	const Gtk::TreeModelColumnBase&amp; modelColumn,
+	const  Gtk::TreeViewColumn::SlotCellData &amp;renderTextCell);
+
+/// Create a resizable icon and text column, rendered by renderTextAndIconCell.
+Gtk::TreeViewColumn *create_resizable_column_with_icon(const Glib::ustring &amp;title,
+	const Gtk::TreeModelColumnBase&amp; modelColumn,
+	const  Gtk::TreeViewColumn::SlotCellData &amp;renderTextAndIconCell);
+
+/// Converts to UTF-8, catches conversion errors
+Glib::ustring to_utf8(std::string text, Glib::ustring fallback = Glib::ustring(&quot;&quot;));
+
+#endif // _PINOTUTILS_HH

Added: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,1122 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+#include &lt;gtkmm/alignment.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/buttonbox.h&gt;
+#include &lt;gtkmm/image.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/stock.h&gt;
+#include &lt;gtkmm/textbuffer.h&gt;
+
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;QueryHistory.h&quot;
+#include &quot;ViewHistory.h&quot;
+#include &quot;XapianIndex.h&quot;
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;ResultsTree.h&quot;
+
+using namespace std;
+using namespace SigC;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+ResultsTree::ResultsTree(VBox *resultsVbox, Menu *pPopupMenu, PinotSettings &amp;settings) :
+	TreeView(),
+	m_pPopupMenu(pPopupMenu),
+	m_settings(settings),
+	m_extractScrolledwindow(NULL),
+	m_extractTextview(NULL),
+	m_showExtract(true)
+{
+	HBox *extractHbox = manage(new class Gtk::HBox(false, 0));
+	ScrolledWindow *resultsScrolledwindow = manage(new ScrolledWindow());
+	m_extractScrolledwindow = manage(new ScrolledWindow());
+	m_extractTextview = manage(new TextView());
+
+	// This is the actual results tree
+	set_events(Gdk::BUTTON_PRESS_MASK);
+	set_flags(CAN_FOCUS);
+	set_headers_visible(true);
+	set_rules_hint(true);
+	set_reorderable(false);
+	set_enable_search(true);
+	resultsScrolledwindow-&gt;set_flags(CAN_FOCUS);
+	resultsScrolledwindow-&gt;set_border_width(4);
+	resultsScrolledwindow-&gt;set_shadow_type(SHADOW_NONE);
+	resultsScrolledwindow-&gt;set_policy(POLICY_AUTOMATIC, POLICY_ALWAYS);
+	resultsScrolledwindow-&gt;property_window_placement().set_value(CORNER_TOP_LEFT);
+	resultsScrolledwindow-&gt;add(*this);
+
+	// That's for the extract view
+	m_extractTextview-&gt;set_flags(CAN_FOCUS);
+	m_extractTextview-&gt;set_editable(false);
+	m_extractTextview-&gt;set_cursor_visible(false);
+	m_extractTextview-&gt;set_pixels_above_lines(0);
+	m_extractTextview-&gt;set_pixels_below_lines(0);
+	m_extractTextview-&gt;set_pixels_inside_wrap(0);
+	m_extractTextview-&gt;set_left_margin(0);
+	m_extractTextview-&gt;set_right_margin(0);
+	m_extractTextview-&gt;set_indent(0);
+	m_extractTextview-&gt;set_wrap_mode(WRAP_WORD);
+	m_extractTextview-&gt;set_justification(JUSTIFY_LEFT);
+	m_extractScrolledwindow-&gt;set_flags(CAN_FOCUS);
+	m_extractScrolledwindow-&gt;set_border_width(4);
+	m_extractScrolledwindow-&gt;set_shadow_type(SHADOW_NONE);
+	m_extractScrolledwindow-&gt;set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
+	m_extractScrolledwindow-&gt;property_window_placement().set_value(CORNER_TOP_LEFT);
+	m_extractScrolledwindow-&gt;add(*m_extractTextview);
+
+	// Position the scrolled windows
+	resultsVbox-&gt;pack_start(*resultsScrolledwindow, Gtk::PACK_EXPAND_WIDGET, 0);
+	resultsVbox-&gt;pack_start(*m_extractScrolledwindow, Gtk::PACK_SHRINK, 0);
+
+	// Associate the columns model to the results tree
+	m_refStore = TreeStore::create(m_resultsColumns);
+	set_model(m_refStore);
+
+	// The title column is also used for status icons
+	TreeViewColumn *treeColumn = new TreeViewColumn(_(&quot;Title&quot;));
+	// Pack an icon renderer for the viewed status
+	CellRendererPixbuf *iconRenderer = new CellRendererPixbuf();
+	treeColumn-&gt;pack_start(*manage(iconRenderer), false);
+	treeColumn-&gt;set_cell_data_func(*iconRenderer, SigC::slot(*this, &amp;ResultsTree::renderViewStatus));
+	// Pack a second icon renderer for the indexed status
+	iconRenderer = new CellRendererPixbuf();
+	treeColumn-&gt;pack_start(*manage(iconRenderer), false);
+	treeColumn-&gt;set_cell_data_func(*iconRenderer, SigC::slot(*this, &amp;ResultsTree::renderIndexStatus));
+	// And a third one for the ranking
+	iconRenderer = new CellRendererPixbuf();
+	treeColumn-&gt;pack_start(*manage(iconRenderer), false);
+	treeColumn-&gt;set_cell_data_func(*iconRenderer, SigC::slot(*this, &amp;ResultsTree::renderRanking));
+	treeColumn-&gt;pack_end(m_resultsColumns.m_text, false);
+	treeColumn-&gt;set_resizable(true);
+	append_column(*manage(treeColumn));
+
+	// The last column is for the URL
+	append_column(_(&quot;URL&quot;), m_resultsColumns.m_url);
+
+	// Make headers clickable
+	set_headers_clickable(true);
+	// Allow multiple selection
+	get_selection()-&gt;set_mode(SELECTION_MULTIPLE);
+
+	// Handle button presses
+	signal_button_press_event().connect_notify(SigC::slot(*this, &amp;ResultsTree::onButtonPressEvent));
+	// Enable interactive search
+	set_search_column(m_resultsColumns.m_text.index());
+	set_search_equal_func(SigC::slot(*this, &amp;ResultsTree::onSearchEqual));
+	// Control which rows can be selected
+	get_selection()-&gt;set_select_function(SigC::slot(*this, &amp;ResultsTree::onSelectionSelect));
+	// Listen for style changes
+	signal_style_changed().connect_notify(SigC::slot(*this, &amp;ResultsTree::onStyleChanged));
+
+	// Render the icons
+	m_indexedIconPixbuf = render_icon(Stock::INDEX, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_viewededIconPixbuf = render_icon(Stock::YES, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_newIconPixbuf = render_icon(Stock::NEW, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_upIconPixbuf = render_icon(Stock::GO_UP, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_downIconPixbuf = render_icon(Stock::GO_DOWN, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+
+	// Show all
+	show();
+	resultsScrolledwindow-&gt;show();
+	m_extractTextview-&gt;show();
+	m_extractScrolledwindow-&gt;show();
+	extractHbox-&gt;show();
+}
+
+ResultsTree::~ResultsTree()
+{
+}
+
+void ResultsTree::renderViewStatus(CellRenderer *renderer, const TreeModel::iterator &amp;iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (renderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *iconRenderer = dynamic_cast&lt;CellRendererPixbuf*&gt;(renderer);
+	if (iconRenderer != NULL)
+	{
+		// Has this result been already viewed ?
+		if ((row[m_resultsColumns.m_viewed] == true) &amp;&amp;
+			(m_viewededIconPixbuf))
+		{
+			iconRenderer-&gt;property_pixbuf() = m_viewededIconPixbuf;
+		}
+		else
+		{
+			iconRenderer-&gt;property_pixbuf().reset_value();
+		}
+	}
+}
+
+void ResultsTree::renderIndexStatus(CellRenderer *renderer, const TreeModel::iterator &amp;iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (renderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *iconRenderer = dynamic_cast&lt;CellRendererPixbuf*&gt;(renderer);
+	if (iconRenderer != NULL)
+	{
+		// Is this result indexed ?
+		if ((row[m_resultsColumns.m_indexed] == true) &amp;&amp;
+			(m_indexedIconPixbuf))
+		{
+			iconRenderer-&gt;property_pixbuf() = m_indexedIconPixbuf;
+		}
+		else
+		{
+			iconRenderer-&gt;property_pixbuf().reset_value();
+		}
+	}
+}
+
+void ResultsTree::renderRanking(CellRenderer *renderer, const TreeModel::iterator &amp;iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (renderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *iconRenderer = dynamic_cast&lt;CellRendererPixbuf*&gt;(renderer);
+	if (iconRenderer != NULL)
+	{
+		// Is this result new ?
+		if (row[m_resultsColumns.m_rankDiff] == 666)
+		{
+			iconRenderer-&gt;property_pixbuf() = m_newIconPixbuf;
+		}
+		// Has its score changed ?
+		else if (row[m_resultsColumns.m_rankDiff] &gt; 0)
+		{
+			iconRenderer-&gt;property_pixbuf() = m_upIconPixbuf;
+		}
+		else if (row[m_resultsColumns.m_rankDiff] &lt; 0)
+		{
+			iconRenderer-&gt;property_pixbuf() = m_downIconPixbuf;
+		}
+		else
+		{
+			iconRenderer-&gt;property_pixbuf().reset_value();
+		}
+	}
+}
+
+//
+// Interactive search equal function.
+//
+bool ResultsTree::onSearchEqual(const RefPtr&lt;TreeModel&gt;&amp; model, int column,
+	const ustring&amp; key, const TreeModel::iterator&amp; iter)
+{
+}
+
+//
+// Handles button presses.
+//
+void ResultsTree::onButtonPressEvent(GdkEventButton *ev)
+{
+	// Check for popup click
+	if ((ev-&gt;type == GDK_BUTTON_PRESS) &amp;&amp;
+		(ev-&gt;button == 3) )
+	{
+		if (m_pPopupMenu != NULL)
+		{
+			m_pPopupMenu-&gt;popup(ev-&gt;button, ev-&gt;time);
+		}
+	}
+	// Check for double clicks
+	else if (ev-&gt;type == GDK_2BUTTON_PRESS)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::onButtonPressEvent: double click on button &quot; &lt;&lt; ev-&gt;button &lt;&lt; endl;
+#endif
+		// Get the selected result, if any
+		TreeModel::iterator iter = get_selection()-&gt;get_selected();
+		if (iter)
+		{
+			TreeModel::Path resultPath = m_refStore-&gt;get_path(iter);
+			// Is the row already expanded ?
+			if (row_expanded(resultPath) == false)
+			{
+				// Expand it
+				expand_row(resultPath, true);
+			}
+			else
+			{
+				// Collapse it
+				collapse_row(resultPath);
+			}
+		}
+	}
+}
+
+//
+// Handles selection changes.
+//
+bool ResultsTree::onSelectionChanged(void)
+{
+	bool goodSel = true;
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;ResultsTree::onSelectionChanged: called&quot; &lt;&lt; endl;
+#endif
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return false;
+	}
+
+	// Go through selected items
+	for (list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
+		itemPath != selectedItems.end(); ++itemPath)
+	{
+		TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+
+		// Check only results are selected
+		ResultsModelColumns::ResultType type = row[m_resultsColumns.m_type];
+		if (type != ResultsModelColumns::RESULT_TITLE)
+		{
+			goodSel = false;
+		}
+	}
+
+	return goodSel;
+}
+
+//
+// Handles attempts to select rows.
+//
+bool ResultsTree::onSelectionSelect(const RefPtr&lt;TreeModel&gt;&amp; model,
+		const TreeModel::Path&amp; path, bool path_currently_selected)
+{
+	const TreeModel::iterator iter = model-&gt;get_iter(path);
+	const TreeModel::Row row = *iter;
+
+	m_indexNames.clear();
+
+	if (path_currently_selected == true)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::onSelectionSelect: unselected entry &quot; &lt;&lt; row[m_resultsColumns.m_text] &lt;&lt; endl;
+#endif
+	}
+	else
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::onSelectionSelect: selected entry &quot; &lt;&lt; row[m_resultsColumns.m_text] &lt;&lt; endl;
+#endif
+
+		// Is this an actual result ?
+		ResultsModelColumns::ResultType type = row[m_resultsColumns.m_type];
+		if (type == ResultsModelColumns::RESULT_TITLE)
+		{
+			QueryHistory history(m_settings.m_historyDatabase);
+			set&lt;string&gt; engineNames, indexNames;
+			string extract;
+
+			m_queryName = locale_from_utf8(row[m_resultsColumns.m_queryName]);
+			string url = locale_from_utf8(row[m_resultsColumns.m_url]);
+			unsigned int engineIds = row[m_resultsColumns.m_engines];
+			unsigned int indexIds = row[m_resultsColumns.m_indexes];
+
+#ifdef DEBUG
+			cout &lt;&lt; &quot;ResultsTree::onSelectionSelect: selected result (&quot; &lt;&lt; engineIds &lt;&lt; &quot;,&quot; &lt;&lt; indexIds &lt;&lt; &quot;)&quot; &lt;&lt; endl;
+#endif
+			m_settings.getEngineNames(engineIds, engineNames);
+			if (engineNames.empty() == false)
+			{
+				// Get the first engine this result was obtained from
+				string engineName = (*engineNames.begin());
+				if (engineName == &quot;Xapian&quot;)
+				{
+					m_settings.getIndexNames(indexIds, indexNames);
+					if (indexNames.empty() == false)
+					{
+						// Use the name of the first index as engine name
+						engineName = (*indexNames.begin());
+
+						// Any internal index in there ?
+						for (set&lt;string&gt;::iterator indexIter = indexNames.begin(); indexIter != indexNames.end(); ++indexIter)
+						{
+							if  (m_settings.isInternalIndex(*indexIter) == true)
+							{
+								m_indexNames.insert(*indexIter);
+							}
+						}
+					}
+				}
+
+#ifdef DEBUG
+				cout &lt;&lt; &quot;ResultsTree::onSelectionSelect: first engine for &quot; &lt;&lt; url &lt;&lt; &quot; was &quot; &lt;&lt; engineName &lt;&lt; endl;
+#endif
+				extract = history.getItemExtract(m_queryName, engineName, url);
+			}
+
+			RefPtr&lt;TextBuffer&gt; refBuffer = m_extractTextview-&gt;get_buffer();
+			refBuffer-&gt;set_text(to_utf8(extract));
+			// The extract is not editable
+			m_extractTextview-&gt;set_editable(false);
+			m_extractTextview-&gt;set_cursor_visible(false);
+		}
+	}
+
+	return true;
+}
+
+//
+// Handles GTK style changes.
+//
+void ResultsTree::onStyleChanged(const RefPtr&lt;Style&gt; &amp;previous_style)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;ResultsTree::onStyleChanged: called&quot; &lt;&lt; endl;
+#endif
+	// FIXME: find better icons :-)
+	m_indexedIconPixbuf = render_icon(Stock::INDEX, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_viewededIconPixbuf = render_icon(Stock::YES, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_newIconPixbuf = render_icon(Stock::NEW, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_upIconPixbuf = render_icon(Stock::GO_UP, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+	m_downIconPixbuf = render_icon(Stock::GO_DOWN, ICON_SIZE_MENU, &quot;MetaSE-pinot&quot;);
+}
+
+//
+// Adds a set of results.
+// Returns true if something was added to the tree.
+//
+bool ResultsTree::addResults(QueryProperties &amp;queryProps, const string &amp;engineName,
+	const vector&lt;Result&gt; &amp;resultsList, bool groupBySearchEngine)
+{
+	std::map&lt;string, TreeModel::iterator&gt; updatedGroups;
+	string registeredEngineName = engineName;
+	unsigned int count = 0;
+	ResultsModelColumns::ResultType rootType;
+
+	string queryName = queryProps.getName();
+	string language = queryProps.getLanguage();
+	string labelName = queryProps.getLabelName();
+
+	// Unselect all
+	get_selection()-&gt;unselect_all();
+
+	// This describes the query
+	string queryDetails = &quot;\&quot;&quot;;
+	queryDetails += queryName;
+	queryDetails += &quot;\&quot; &quot;;
+	queryDetails += _(&quot;on&quot;);
+	queryDetails += &quot; &quot;;
+	queryDetails += registeredEngineName;
+
+	// What's the grouping criteria ?
+	if (groupBySearchEngine == true)
+	{
+		// By search engine
+		rootType = ResultsModelColumns::RESULT_ROOT;
+	}
+	else
+	{
+		// By host
+		rootType = ResultsModelColumns::RESULT_HOST;
+	}
+
+	// Find out what the search engine ID is
+	unsigned int indexId = 0;
+	unsigned int engineId = m_settings.getEngineId(registeredEngineName);
+	if (engineId == 0)
+	{
+		// Chances are this engine is an index
+		std::map&lt;string, string&gt;::const_iterator mapIter = m_settings.getIndexes().find(registeredEngineName);
+		if (mapIter != m_settings.getIndexes().end())
+		{
+			// Yes, it is
+			indexId = m_settings.getIndexId(registeredEngineName);
+			engineId = m_settings.getEngineId(&quot;Xapian&quot;);
+#ifdef DEBUG
+			cout &lt;&lt; &quot;ResultsTree::addResults: engine is index &quot; &lt;&lt; registeredEngineName &lt;&lt; endl;
+#endif
+		}
+#ifdef DEBUG
+		else cout &lt;&lt; &quot;ResultsTree::addResults: &quot; &lt;&lt; registeredEngineName &lt;&lt; &quot; is not an index&quot; &lt;&lt;  endl;
+#endif
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;ResultsTree::addResults: ID for engine &quot; &lt;&lt; registeredEngineName &lt;&lt; &quot; is &quot; &lt;&lt; engineId &lt;&lt;  endl;
+#endif
+
+	QueryHistory history(m_settings.m_historyDatabase);
+	bool isNewQuery = false;
+	if (history.getLastRun(queryName, engineName).empty() == true)
+	{
+		isNewQuery = true;
+	}
+
+	// Look at the results list
+#ifdef DEBUG
+	cout &lt;&lt; &quot;ResultsTree::addResults: &quot; &lt;&lt; resultsList.size() &lt;&lt; &quot; results to display&quot; &lt;&lt; endl;
+#endif
+	for (vector&lt;Result&gt;::const_iterator resultIter = resultsList.begin();
+		resultIter != resultsList.end(); ++resultIter)
+	{
+		string title = resultIter-&gt;getTitle();
+		string location = resultIter-&gt;getLocation();
+		string extract = resultIter-&gt;getExtract();
+		float currentScore = resultIter-&gt;getScore();
+		string score;
+		int rankDiff = 0;
+
+		// What group should the result go to ?
+		string groupName;
+		if (rootType == ResultsModelColumns::RESULT_HOST)
+		{
+			Url urlObj(location);
+			groupName = urlObj.getHost();
+		}
+		else
+		{
+			groupName = queryDetails;
+		}
+
+		// Add the group or get its position if it's already in
+		TreeModel::iterator groupIter;
+		if (appendGroup(groupName, rootType, groupIter) == true)
+		{
+			// OK, add a row for this result within the group
+			TreeModel::iterator titleIter;
+
+			// Has the result's ranking changed ?
+			float oldestScore = 0;
+			float previousScore = history.hasItem(queryName, registeredEngineName, location, oldestScore);
+			if (previousScore &gt; 0)
+			{
+				// Update this result whatever the current and previous rankings were
+				history.updateItem(queryName, registeredEngineName, location, title, extract, language, currentScore);
+				rankDiff = (int)(currentScore - previousScore);
+			}
+			else
+			{
+				// No, this is a new result
+				history.insertItem(queryName, registeredEngineName, location, resultIter-&gt;getTitle(), extract, language, currentScore);
+				// New results are displayed as such only if the query has already been run on the engine
+				if (isNewQuery == false)
+				{
+					// This is a magic value :-)
+					rankDiff = 666;
+				}
+			}
+
+			++count;
+			if (appendResult(title, location, currentScore, language, rankDiff,
+				queryName, engineId, indexId, titleIter, &amp;(*groupIter), true) == true)
+			{
+#ifdef DEBUG
+				cout &lt;&lt; &quot;ResultsTree::addResults: added row for result &quot; &lt;&lt; count &lt;&lt; endl;
+#endif
+
+				// Update this map, so that we know which groups need updating
+				updatedGroups[groupName] = groupIter;
+			}
+		}
+	}
+
+	if (count &gt; 0)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::addResults: &quot; &lt;&lt; updatedGroups.size() &lt;&lt; &quot; groups to update&quot; &lt;&lt; endl;
+#endif
+		// Update the groups to which we have added results
+		for (std::map&lt;string, TreeModel::iterator&gt;::iterator mapIter = updatedGroups.begin();
+			mapIter != updatedGroups.end(); mapIter++)
+		{
+			TreeModel::iterator groupIter = mapIter-&gt;second;
+			updateGroup(groupIter);
+		}
+
+		return true;
+	}
+	else
+	{
+		if (rootType == ResultsModelColumns::RESULT_ROOT)
+		{
+			// If this didn't return any result, add an empty group
+			TreeModel::iterator groupIter;
+			appendGroup(queryDetails, rootType, groupIter);
+			updateGroup(groupIter);
+
+			return true;
+		}
+	}
+
+	return false;
+}
+
+//
+// Groups results.
+//
+void ResultsTree::regroupResults(bool groupBySearchEngine)
+{
+	ResultsModelColumns::ResultType currentType, newType;
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;ResultsTree::regroupResults: called&quot; &lt;&lt; endl;
+#endif
+	// What's the new grouping criteria ?
+	if (groupBySearchEngine == true)
+	{
+		// By search engine
+		currentType = ResultsModelColumns::RESULT_HOST;
+		newType = ResultsModelColumns::RESULT_ROOT;
+	}
+	else
+	{
+		// By host
+		currentType = ResultsModelColumns::RESULT_ROOT;
+		newType = ResultsModelColumns::RESULT_HOST;
+	}
+
+	// Go through tree rows
+	TreeModel::Children children = m_refStore-&gt;children();
+	if (children.empty() == true)
+	{
+		return;
+	}
+
+	// Clear the map
+	m_resultsGroups.clear();
+
+	// Unselect results
+	get_selection()-&gt;unselect_all();
+
+	TreeModel::Children::iterator iter = children.begin();
+	while (iter != children.end())
+	{
+		TreeModel::Row row = *iter;
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::groupBySearchEngine: looking at &quot; &lt;&lt; row[m_resultsColumns.m_text] &lt;&lt; endl;
+#endif
+		ResultsModelColumns::ResultType type = row[m_resultsColumns.m_type];
+		// Skip new type rows
+		if (type == newType)
+		{
+			iter++;
+			continue;
+		}
+
+		TreeModel::Children child = iter-&gt;children();
+		if (child.empty() == false)
+		{
+			TreeModel::Children::iterator childIter = child.begin();
+			// Type RESULT_TITLE
+			while (childIter != child.end())
+			{
+				TreeModel::Row childRow = *childIter;
+				TreeModel::iterator groupIter, newIter;
+				bool success = false;
+
+				// We will need the URL and engines columns in all cases
+				string url = locale_from_utf8(childRow[m_resultsColumns.m_url]);
+				unsigned int engineIds = childRow[m_resultsColumns.m_engines];
+				unsigned int indexIds = childRow[m_resultsColumns.m_indexes];
+
+				// Get the name of the group this should go into
+				if (newType == ResultsModelColumns::RESULT_HOST)
+				{
+					Url urlObj(url);
+#ifdef DEBUG
+					cout &lt;&lt; &quot;ResultsTree::groupBySearchEngine: row &quot; &lt;&lt; url &lt;&lt; endl;
+#endif
+					string groupName = urlObj.getHost();
+					// Add group
+					if (appendGroup(groupName, newType, groupIter) == true)
+					{
+						// Add result
+						success = appendResult(locale_from_utf8(childRow[m_resultsColumns.m_text]), url,
+							(float)atof(locale_from_utf8(childRow[m_resultsColumns.m_score]).c_str()),
+							locale_from_utf8(childRow[m_resultsColumns.m_language]),
+							childRow[m_resultsColumns.m_rankDiff],
+							locale_from_utf8(childRow[m_resultsColumns.m_queryName]),
+							engineIds, indexIds, newIter, &amp;(*groupIter), true);
+					}
+				}
+				else
+				{
+					// Look at the engines column and see which engines this result is for
+					set&lt;string&gt; engineNames;
+					m_settings.getEngineNames(engineIds, engineNames);
+					if (engineNames.empty() == false)
+					{
+#ifdef DEBUG
+						cout &lt;&lt; &quot;ResultsTree::groupBySearchEngine: row is for &quot; &lt;&lt; engineNames.size() &lt;&lt; endl;
+#endif
+						// Are there indexes in the list ?
+						set&lt;string&gt;::iterator xapianIter = engineNames.find(&quot;Xapian&quot;);
+						if ((xapianIter != engineNames.end()) &amp;&amp;
+							(indexIds &gt; 0))
+						{
+							// Erase this
+							engineNames.erase(xapianIter);
+
+							// Add entries for each index name so that we can loop once on engine names
+							set&lt;string&gt; indexNames;
+							m_settings.getIndexNames(indexIds, indexNames);
+							for (set&lt;string&gt;::iterator iter = indexNames.begin(); iter != indexNames.end(); ++iter)
+							{
+								string indexName = (*iter);
+								engineNames.insert(indexName);
+#ifdef DEBUG
+								cout &lt;&lt; &quot;ResultsTree::groupBySearchEngine: row is for index &quot; &lt;&lt; indexName &lt;&lt; endl;
+#endif
+							}
+						}
+
+						for (set&lt;string&gt;::iterator iter = engineNames.begin(); iter != engineNames.end(); ++iter)
+						{
+							string engineName = (*iter);
+
+							string groupName = &quot;\&quot;&quot;;
+							groupName += locale_from_utf8(childRow[m_resultsColumns.m_queryName]);
+							groupName += &quot;\&quot; &quot;;
+							groupName += _(&quot;on&quot;);
+							groupName += &quot; &quot;;
+							groupName += engineName;
+
+							unsigned int indexId = 0;
+							unsigned int engineId = m_settings.getEngineId(engineName);
+							if (engineId == 0)
+							{
+								// This is actually an index, not an engine...
+								indexId = m_settings.getIndexId(engineName);
+								if (indexId &gt; 0)
+								{
+									engineId = m_settings.getEngineId(&quot;Xapian&quot;);
+								}
+							}
+
+							// Add group
+							if (appendGroup(groupName, newType, groupIter) == true)
+							{
+								// Add result
+								appendResult(locale_from_utf8(childRow[m_resultsColumns.m_text]), url,
+									(float)atof(locale_from_utf8(childRow[m_resultsColumns.m_score]).c_str()),
+									locale_from_utf8(childRow[m_resultsColumns.m_language]),
+									childRow[m_resultsColumns.m_rankDiff],
+									locale_from_utf8(childRow[m_resultsColumns.m_queryName]),
+									engineId, indexId,
+									newIter, &amp;(*groupIter), true);
+#ifdef DEBUG
+								cout &lt;&lt; &quot;ResultsTree::groupBySearchEngine: row for &quot; &lt;&lt; *iter &lt;&lt; endl;
+#endif
+							}
+						}
+
+						// FIXME: make sure at least one row was added
+						success = true;
+					}
+				}
+
+				if (success == true)
+				{
+					// Delete it
+					m_refStore-&gt;erase(*childIter);
+					childIter = child.begin();
+				}
+				else
+				{
+					// Don't delete anything then, just go to the next child
+					childIter++;
+				}
+			}
+		}
+
+		// Erase this row
+		m_refStore-&gt;erase(*iter);
+
+		// Get the new first row, that way we don't have to worry about iterators validity
+		iter = children.begin();
+	}
+
+	for (std::map&lt;string, TreeModel::iterator&gt;::iterator mapIter = m_resultsGroups.begin();
+		mapIter != m_resultsGroups.end(); mapIter++)
+	{
+		TreeModel::iterator groupIter = mapIter-&gt;second;
+		updateGroup(groupIter);
+	}
+
+	onSelectionChanged();
+}
+
+//
+// Gets the first selected item's URL.
+//
+ustring ResultsTree::getFirstSelectionURL(void)
+{
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return &quot;&quot;;
+	}
+
+	list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
+	TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
+	TreeModel::Row row = *iter;
+	return row[m_resultsColumns.m_url];
+}
+
+//
+// Gets a list of selected items.
+//
+bool ResultsTree::getSelection(vector&lt;Result&gt; &amp;resultsList)
+{
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return false;
+	}
+
+	// Go through selected items
+	for (list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
+		itemPath != selectedItems.end(); ++itemPath)
+	{
+		TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+
+		resultsList.push_back(Result(locale_from_utf8(row[m_resultsColumns.m_url]),
+			locale_from_utf8(row[m_resultsColumns.m_text]),
+			&quot;&quot;, locale_from_utf8(row[m_resultsColumns.m_language])));
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;ResultsTree::getSelection: &quot; &lt;&lt; resultsList.size() &lt;&lt; &quot; results selected&quot; &lt;&lt; endl;
+#endif
+
+	return true;
+}
+
+//
+// Sets the first selected item's viewed state.
+//
+void ResultsTree::setFirstSelectionViewedState(bool viewed)
+{
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return;
+	}
+
+	list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
+	TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
+	TreeModel::Row row = *iter;
+	row[m_resultsColumns.m_viewed] = viewed;
+}
+
+//
+// Deletes the current selection.
+//
+bool ResultsTree::deleteSelection(void)
+{
+	bool empty = false;
+
+	// Go through selected items
+	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
+	list&lt;TreeModel::Path&gt;::iterator itemPath = selectedItems.begin();
+	while (itemPath != selectedItems.end())
+	{
+		TreeModel::iterator iter = m_refStore-&gt;get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+		TreeModel::iterator parentIter;
+		bool updateParent = false;
+
+		// This could be a group that's in the map and should be removed first
+		if (row[m_resultsColumns.m_type] != ResultsModelColumns::RESULT_TITLE)
+		{
+			string groupName = locale_from_utf8(row[m_resultsColumns.m_text]);
+			std::map&lt;string, TreeModel::iterator&gt;::iterator mapIter = m_resultsGroups.find(groupName);
+			if (mapIter != m_resultsGroups.end())
+			{
+				m_resultsGroups.erase(mapIter);
+#ifdef DEBUG
+				cout &lt;&lt; &quot;ResultsTree::deleteResults: erased group &quot; &lt;&lt; groupName &lt;&lt; endl;
+#endif
+			}
+		}
+		else
+		{
+			// This item is a result
+			parentIter = row.parent();
+			updateParent = true;
+		}
+
+		// Unselect and erase
+		get_selection()-&gt;unselect(iter);
+		m_refStore-&gt;erase(row);
+
+		// Update group ?
+		if (updateParent == true)
+		{
+			// Update the group this result belongs to
+			updateGroup(parentIter);
+		}
+
+		selectedItems = get_selection()-&gt;get_selected_rows();
+		itemPath = selectedItems.begin();
+	}
+
+	TreeModel::Children children = m_refStore-&gt;children();
+	empty = children.empty();
+
+	columns_autosize();
+
+	return empty;
+}
+
+//
+// Clear the tree.
+//
+void ResultsTree::clear(void)
+{
+	// Unselect results
+	get_selection()-&gt;unselect_all();
+
+	// Remove existing rows in the tree
+	TreeModel::Children children = m_refStore-&gt;children();
+	if (children.empty() == false)
+	{
+		// Clear the groups map
+		m_resultsGroups.clear();
+
+		TreeModel::Children::iterator iter = children.begin();
+		while (iter != children.end())
+		{
+			// Erase this row
+			m_refStore-&gt;erase(*iter);
+
+			// Get the new first row
+			children = m_refStore-&gt;children();
+			iter = children.begin();
+		}
+		m_refStore-&gt;clear();
+
+		// Clear the extract field
+		RefPtr&lt;TextBuffer&gt; refBuffer = m_extractTextview-&gt;get_buffer();
+		refBuffer-&gt;set_text(&quot;&quot;);
+		m_extractTextview-&gt;set_editable(false);
+		m_extractTextview-&gt;set_cursor_visible(false);
+
+		onSelectionChanged();
+	}
+}
+
+//
+// Shows or hides the extract field.
+//
+void ResultsTree::showExtract(bool show)
+{
+	m_showExtract = show;
+	if (m_showExtract == true)
+	{
+		// Show the extract
+		m_extractScrolledwindow-&gt;show();
+	}
+	else
+	{
+		// Hide
+		m_extractScrolledwindow-&gt;hide();
+	}
+}
+
+//
+// Adds a new row in the results tree.
+//
+bool ResultsTree::appendResult(const string &amp;text, const string &amp;url,
+	float score, const string &amp;language, int rankDiff,
+	const string &amp;queryName, unsigned int engineId, unsigned int indexId,
+	TreeModel::iterator &amp;newRowIter, const TreeModel::Row *parentRow, bool noDuplicates)
+{
+	if (parentRow == NULL)
+	{
+		newRowIter = m_refStore-&gt;append();
+	}
+	else
+	{
+		// Merge duplicates within groups ?
+		if (noDuplicates == true)
+		{
+			// Look for a row with the same URL and query. For instance, in group
+			// by host mode, if a page is returned by several search engines, it
+			// should appear only once
+			TreeModel::Children children = parentRow-&gt;children();
+			if (children.empty() == false)
+			{
+				TreeModel::Children::iterator childIter = children.begin();
+				for (; childIter != children.end(); ++childIter)
+				{
+					TreeModel::Row row = *childIter;
+					if ((row[m_resultsColumns.m_url] == to_utf8(url)) &amp;&amp;
+						(row[m_resultsColumns.m_queryName] == to_utf8(queryName)))
+					{
+						// Update the engines column...
+						row[m_resultsColumns.m_engines] = row[m_resultsColumns.m_engines] | engineId;
+						// ...and the indexes column too
+						row[m_resultsColumns.m_indexes] = row[m_resultsColumns.m_indexes] | engineId;
+#ifdef DEBUG
+						cout &lt;&lt; &quot;ResultsTree::appendResult: merged &quot; &lt;&lt; text &lt;&lt; &quot; &quot; &lt;&lt; engineId &lt;&lt; &quot; (&quot; &lt;&lt; row[m_resultsColumns.m_engines] &lt;&lt; &quot;,&quot; &lt;&lt; row[m_resultsColumns.m_indexes] &lt;&lt; &quot;)&quot; &lt;&lt; endl;
+#endif
+
+						newRowIter = childIter;
+						return true;
+					}
+				}
+			}
+		}
+
+		newRowIter = m_refStore-&gt;append(parentRow-&gt;children());
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::appendResult: added &quot; &lt;&lt; text &lt;&lt; &quot;, &quot; &lt;&lt; score &lt;&lt; &quot; to &quot;
+			&lt;&lt; (*parentRow)[m_resultsColumns.m_text] &lt;&lt; endl;
+#endif
+	}
+
+	string strippedText = HtmlTokenizer::stripTags(text);
+	XapianIndex index(m_settings.m_indexLocation);
+	ViewHistory viewHistory(m_settings.m_historyDatabase);
+	DocumentInfo docInfo(text, url, &quot;&quot;, language);
+	bool isIndexed = false;
+
+	// Is this document indexed ?
+	if ((index.isGood() == true) &amp;&amp;
+		(index.hasDocument(docInfo) &gt; 0))
+	{
+		isIndexed = true;
+	}
+
+	// Has it been already viewed ?
+	bool wasViewed = viewHistory.hasItem(url);
+
+	char scoreStr[128];
+	snprintf(scoreStr, 128, &quot;%.f&quot;, score);
+
+	TreeModel::Row childRow = *newRowIter;
+	updateRow(childRow, to_utf8(strippedText, &quot;???&quot;),
+		to_utf8(url), scoreStr,
+		to_utf8(language), to_utf8(queryName), engineId, indexId,
+		ResultsModelColumns::RESULT_TITLE, isIndexed,
+		wasViewed, rankDiff);
+
+	return true;
+}
+
+//
+// Adds a results group
+//
+bool ResultsTree::appendGroup(const string &amp;groupName,
+	ResultsModelColumns::ResultType groupType, TreeModel::iterator &amp;groupIter)
+{
+	bool success = false;
+
+	// Is this group already in ?
+	std::map&lt;string, TreeModel::iterator&gt;::iterator mapIter = m_resultsGroups.find(groupName);
+	if (mapIter == m_resultsGroups.end())
+	{
+		// No, it isn't: insert a new group in the tree
+		groupIter = m_refStore-&gt;append();
+		TreeModel::Row groupRow = *groupIter;
+		updateRow(groupRow, to_utf8(groupName, &quot;???&quot;),
+				&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, 0, 0, groupType,
+				false, false, false);
+
+		// Update the map
+		m_resultsGroups[groupName] = groupIter;
+		success = true;
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::appendGroup: updated map with &quot; &lt;&lt; groupName &lt;&lt; endl;
+#endif
+	}
+	else
+	{
+		// Yes, it is
+		groupIter = mapIter-&gt;second;
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ResultsTree::appendGroup: found &quot; &lt;&lt; groupName &lt;&lt; &quot; in map&quot; &lt;&lt; endl;
+#endif
+		success = true;
+	}
+
+	return success;
+}
+
+//
+// Updates a results group.
+//
+void ResultsTree::updateGroup(TreeModel::iterator &amp;groupIter)
+{
+	TreeModel::Row groupRow = (*groupIter);
+
+	// Check the iterator doesn't point to a result
+	if (groupRow[m_resultsColumns.m_type] == ResultsModelColumns::RESULT_TITLE)
+	{
+		return;
+	}
+
+	// Modify the &quot;score&quot; column to indicate the number of results in that group
+	TreeModel::Children groupChildren = groupIter-&gt;children();
+	char scoreStr[64];
+	snprintf(scoreStr, 64, &quot;%u&quot;, groupChildren.size());
+	groupRow[m_resultsColumns.m_score] = scoreStr;
+#ifdef DEBUG
+	cout &lt;&lt; &quot;ResultsTree::updateGroup: group &quot; &lt;&lt; groupRow[m_resultsColumns.m_text] &lt;&lt; &quot; has &quot; &lt;&lt; groupChildren.size() &lt;&lt; &quot; children&quot; &lt;&lt; endl;
+#endif
+
+	// Expand this group
+	TreeModel::Path groupPath = m_refStore-&gt;get_path(groupIter);
+	expand_row(groupPath, true);
+}
+
+//
+// Updates a row.
+//
+void ResultsTree::updateRow(TreeModel::Row &amp;row, const ustring &amp;text,
+	const ustring &amp;url, const ustring &amp;score, const ustring &amp;language,
+	const ustring &amp;queryName, unsigned int engineId,  unsigned int indexId,
+	ResultsModelColumns::ResultType type, bool indexed, bool viewed, int rankDiff)
+{
+	row[m_resultsColumns.m_text] = text;
+	row[m_resultsColumns.m_url] = url;
+	row[m_resultsColumns.m_score] = score;
+	row[m_resultsColumns.m_language] = language;
+	row[m_resultsColumns.m_queryName] = queryName;
+	row[m_resultsColumns.m_engines] = engineId;
+	row[m_resultsColumns.m_indexes] = indexId;
+	row[m_resultsColumns.m_type] = type;
+
+	row[m_resultsColumns.m_indexed] = indexed;
+	row[m_resultsColumns.m_viewed] = viewed;
+	row[m_resultsColumns.m_rankDiff] = rankDiff;
+}

Added: trunk/UI/GTK2/src/ResultsTree.h
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/ResultsTree.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,148 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _RESULTSTREE_HH
+#define _RESULTSTREE_HH
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;set&gt;
+#include &lt;map&gt;
+#include &lt;sigc++/slot.h&gt;
+#include &lt;glibmm/refptr.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gdkmm/pixbuf.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/menu.h&gt;
+#include &lt;gtkmm/scrolledwindow.h&gt;
+#include &lt;gtkmm/textview.h&gt;
+#include &lt;gtkmm/treestore.h&gt;
+#include &lt;gtkmm/treeview.h&gt;
+#include &lt;gtkmm/treeselection.h&gt;
+
+#include &quot;QueryProperties.h&quot;
+#include &quot;Result.h&quot;
+#include &quot;ModelColumns.h&quot;
+#include &quot;PinotSettings.h&quot;
+
+class ResultsTree : public Gtk::TreeView
+{
+	public:
+		ResultsTree(Gtk::VBox *resultsVbox, Gtk::Menu *pPopupMenu, PinotSettings &amp;settings);
+		virtual ~ResultsTree();
+
+		/**
+		  * Handles selection changes.
+		  * Returns true if a result is selected.
+		  */
+		bool onSelectionChanged(void);
+
+		/**
+		  * Adds a set of results.
+		  * Returns true if something was added to the tree.
+		  */
+		bool addResults(QueryProperties &amp;queryProps, const std::string &amp;engineName,
+			const std::vector&lt;Result&gt; &amp;resultsList, bool groupBySearchEngine);
+
+		/// Groups results.
+		void regroupResults(bool groupBySearchEngine);
+
+		/// Gets the first selected item's URL.
+		Glib::ustring getFirstSelectionURL(void);
+
+		/// Gets a list of selected items.
+		bool getSelection(std::vector&lt;Result&gt; &amp;resultsList);
+
+		/// Sets the first selected item's viewed state.
+		void setFirstSelectionViewedState(bool viewed);
+
+		/**
+		  * Deletes the current selection.
+		  * Returns true if the tree is then empty.
+		  */
+		bool deleteSelection(void);
+
+		/// Clear the tree.
+		void clear(void);
+
+		/// Shows or hides the extract field.
+		void showExtract(bool show = true);
+
+	protected:
+		Glib::RefPtr&lt;Gtk::TreeStore&gt; m_refStore;
+		Gtk::Menu *m_pPopupMenu;
+		PinotSettings &amp;m_settings;
+		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_indexedIconPixbuf;
+		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_viewededIconPixbuf;
+		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_newIconPixbuf;
+		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_upIconPixbuf;
+		Glib::RefPtr&lt;Gdk::Pixbuf&gt; m_downIconPixbuf;
+		std::map&lt;std::string, Gtk::TreeModel::iterator&gt; m_resultsGroups;
+		ResultsModelColumns m_resultsColumns;
+		Gtk::ScrolledWindow *m_extractScrolledwindow;
+		Gtk::TextView *m_extractTextview;
+		std::set&lt;std::string&gt; m_indexNames;
+		bool m_showExtract;
+		std::string m_queryName;
+
+		void renderViewStatus(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &amp;iter);
+
+		void renderIndexStatus(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &amp;iter);
+
+		void renderRanking(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &amp;iter);
+
+		/// Interactive search equal function.
+		bool onSearchEqual(const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model, int column,
+			const Glib::ustring&amp; key, const Gtk::TreeModel::iterator&amp; iter);
+
+		/// Handles button presses.
+		void onButtonPressEvent(GdkEventButton *ev);
+
+		/// Handles attempts to select rows.
+		bool onSelectionSelect(const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,
+			const Gtk::TreeModel::Path&amp; path, bool path_currently_selected);
+
+		/// Handles GTK style changes.
+		void onStyleChanged(const Glib::RefPtr&lt;Gtk::Style&gt; &amp;previous_style);
+
+		/// Adds a results group.
+		bool appendGroup(const std::string &amp;groupName, ResultsModelColumns::ResultType groupType,
+			Gtk::TreeModel::iterator &amp;groupIter);
+
+		/// Adds a new row in the results tree.
+		bool appendResult(const std::string &amp;text, const std::string &amp;url,
+			float score, const std::string &amp;language, int rankDiff,
+			const std::string &amp;queryName, unsigned int engineId, unsigned int indexId,
+			Gtk::TreeModel::iterator &amp;newRowIter,
+			const Gtk::TreeModel::Row *parentRow = NULL, bool noDuplicates = false);
+
+		/// Updates a results group.
+		void updateGroup(Gtk::TreeModel::iterator &amp;groupIter);
+
+		/// Updates a row.
+		void updateRow(Gtk::TreeModel::Row &amp;row, const Glib::ustring &amp;text,
+			const Glib::ustring &amp;url, const Glib::ustring &amp;score, const Glib::ustring &amp;language,
+			const Glib::ustring &amp;queryName, unsigned int engineId, unsigned int indexId,
+			ResultsModelColumns::ResultType type, bool indexed, bool viewed, int rankDiff);
+
+	private:
+		ResultsTree(const ResultsTree &amp;other);
+		ResultsTree &amp;operator=(const ResultsTree &amp;other);
+
+};
+
+#endif // _RESULTSTREE_HH

Added: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,1366 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;string.h&gt;
+#include &lt;signal.h&gt;
+#include &lt;fam.h&gt;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+#include &lt;sigc++/class_slot.h&gt;
+#include &lt;glibmm/thread.h&gt;
+
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;MIMEScanner.h&quot;
+#include &quot;TokenizerFactory.h&quot;
+#include &quot;StringManip.h&quot;
+#include &quot;TimeConverter.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;LabelManager.h&quot;
+#include &quot;QueryHistory.h&quot;
+#include &quot;IndexedDocument.h&quot;
+#include &quot;DownloaderFactory.h&quot;
+#include &quot;SearchEngineFactory.h&quot;
+#ifdef HAS_GOOGLEAPI
+#include &quot;GoogleAPIEngine.h&quot;
+#endif
+#include &quot;XapianIndex.h&quot;
+#include &quot;XapianEngine.h&quot;
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;WorkerThreads.h&quot;
+
+using namespace SigC;
+using namespace Glib;
+using namespace std;
+
+// The Dispatcher object used to signal the UI thread
+Dispatcher WorkerThread::m_signalFinished;
+
+WorkerThread::WorkerThread()
+{
+	m_id = 0;
+	m_background = m_done = false;
+	m_status = &quot;&quot;;
+}
+
+WorkerThread::~WorkerThread()
+{
+}
+
+void WorkerThread::setId(unsigned int id)
+{
+	m_id = id;
+}
+
+unsigned int WorkerThread::getId(void)
+{
+	return m_id;
+}
+
+void WorkerThread::inBackground(void)
+{
+	m_background = true;
+}
+
+bool WorkerThread::isBackground(void)
+{
+	return m_background;
+}
+
+bool WorkerThread::operator&lt;(const WorkerThread &amp;other) const
+{
+	return m_id &lt; other.m_id;
+}
+
+Dispatcher&amp; WorkerThread::getFinishedSignal()
+{
+	return m_signalFinished;
+}
+
+bool WorkerThread::isDone(void) const
+{
+	return m_done;
+}
+
+void WorkerThread::reset(void)
+{
+	m_done = false;
+}
+
+string WorkerThread::getStatus(void) const
+{
+	return m_status;
+}
+
+void WorkerThread::emitSignal(void)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;WorkerThread::emitSignal: end of thread &quot; &lt;&lt; m_id &lt;&lt; endl;
+#endif
+	m_done = true;
+	m_signalFinished();
+}
+
+IndexBrowserThread::IndexBrowserThread(const string &amp;indexName,
+	unsigned int maxDocsCount, unsigned int startDoc) :
+	WorkerThread()
+{
+	m_indexName = indexName;
+	m_indexDocsCount = 0;
+	m_maxDocsCount = maxDocsCount;
+	m_startDoc = startDoc;
+}
+
+IndexBrowserThread::~IndexBrowserThread()
+{
+}
+
+bool IndexBrowserThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &amp;IndexBrowserThread::do_browsing), false);
+
+	return true;
+}
+
+string IndexBrowserThread::getType(void) const
+{
+	return &quot;IndexBrowserThread&quot;;
+}
+
+string IndexBrowserThread::getIndexName(void) const
+{
+	return m_indexName;
+}
+
+unsigned int IndexBrowserThread::getDocumentsCount(void) const
+{
+	return m_indexDocsCount;
+}
+
+bool IndexBrowserThread::stop(void)
+{
+	m_done = true;
+	m_status = _(&quot;Stopped browsing&quot;);
+	m_status += &quot; &quot;;
+	m_status += m_indexName;
+	return true;
+}
+
+SigC::Signal3&lt;void, IndexedDocument, unsigned int, std::string&gt;&amp; IndexBrowserThread::getUpdateSignal(void)
+{
+	return m_signalUpdate;
+}
+
+void IndexBrowserThread::do_browsing()
+{
+	set&lt;unsigned int&gt; docIDList;
+	set&lt;string&gt; docLabels;
+	unsigned int numDocs = 0;
+
+	const map&lt;string, string&gt; &amp;indexesMap = PinotSettings::getInstance().getIndexes();
+	map&lt;string, string&gt;::const_iterator mapIter = indexesMap.find(m_indexName);
+	if (mapIter == indexesMap.end())
+	{
+		m_status = _(&quot;Index&quot;);
+		m_status += &quot; &quot;;
+		m_status += m_indexName;
+		m_status += &quot; &quot;;
+		m_status += _(&quot;doesn't exist&quot;);
+		emitSignal();
+		return;
+	}
+
+	// Get the index at that location
+	XapianIndex index(mapIter-&gt;second);
+	if (index.isGood() == false)
+	{
+		m_status = _(&quot;Index error on&quot;);
+		m_status += &quot; &quot;;
+		m_status += mapIter-&gt;second;
+		emitSignal();
+		return;
+	}
+
+	m_indexDocsCount = index.getDocumentsCount();
+	if (m_indexDocsCount == 0)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;IndexBrowserThread::do_browsing: no documents&quot; &lt;&lt; endl;
+#endif
+		emitSignal();
+		return;
+	}
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;IndexBrowserThread::do_browsing: &quot; &lt;&lt; m_maxDocsCount &lt;&lt; &quot; off &quot; &lt;&lt; m_indexDocsCount
+		&lt;&lt; &quot; documents to browse, starting at &quot; &lt;&lt; m_startDoc &lt;&lt; endl;
+#endif
+	index.getDocumentIDs(docIDList, m_maxDocsCount, m_startDoc);
+	for (set&lt;unsigned int&gt;::iterator iter = docIDList.begin(); iter != docIDList.end(); iter++)
+	{
+		if (m_done == true)
+		{
+			break;
+		}
+
+		// Get the document ID
+		unsigned int docId = (*iter);
+		// ...and the document URL
+		string url = XapianEngine::buildUrl(mapIter-&gt;second, docId);
+
+		DocumentInfo docInfo;
+		if (index.getDocumentInfo(docId, docInfo) == true)
+		{
+			string type = docInfo.getType();
+			if (type.empty() == true)
+			{
+				type = &quot;text/html&quot;;
+			}
+
+			string date = docInfo.getTimestamp();
+			IndexedDocument indexedDoc(docInfo.getTitle(), url, docInfo.getLocation(),
+				type, docInfo.getLanguage());
+			indexedDoc.setTimestamp(date);
+#ifdef DEBUG
+			cout &lt;&lt; &quot;IndexBrowserThread::do_browsing: timestamp for &quot; &lt;&lt; docId &lt;&lt; &quot; is &quot; &lt;&lt; date &lt;&lt; endl;
+#endif
+			// Signal
+			m_signalUpdate(indexedDoc, docId, m_indexName);
+			++numDocs;
+		}
+#ifdef DEBUG
+		else cout &lt;&lt; &quot;IndexBrowserThread::do_browsing: couldn't retrieve document &quot; &lt;&lt; docId &lt;&lt; endl;
+#endif
+	}
+
+	emitSignal();
+}
+
+QueryingThread::QueryingThread(const string &amp;engineName, const string &amp;engineDisplayableName,
+	const string &amp;engineOption, const QueryProperties &amp;queryProps) :
+	m_queryProps(queryProps), WorkerThread()
+{
+	m_engineName = engineName;
+	m_engineDisplayableName = engineDisplayableName;
+	m_engineOption = engineOption;
+}
+
+QueryingThread::~QueryingThread()
+{
+}
+
+bool QueryingThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &amp;QueryingThread::do_querying), false);
+
+	return true;
+}
+
+string QueryingThread::getType(void) const
+{
+	return &quot;QueryingThread&quot;;
+}
+
+string QueryingThread::getEngineName(void) const
+{
+	return m_engineDisplayableName;
+}
+
+QueryProperties QueryingThread::getQuery(void) const
+{
+	return m_queryProps;
+}
+
+const vector&lt;Result&gt; &amp;QueryingThread::getResults(void) const
+{
+	return m_resultsList;
+}
+
+bool QueryingThread::stop(void)
+{
+	m_done = true;
+	m_status = _(&quot;Stopped querying&quot;);
+	m_status += &quot; &quot;;
+	m_status += m_engineDisplayableName;
+	return true;
+}
+
+void QueryingThread::do_querying()
+{
+	// Get the SearchEngine
+	SearchEngineInterface *engine = SearchEngineFactory::getSearchEngine(m_engineName, m_engineOption);
+	if (engine == NULL)
+	{
+		m_status = _(&quot;Couldn't create search engine&quot;);
+		m_status += &quot; &quot;;
+		m_status += m_engineDisplayableName;
+		emitSignal();
+		return;
+	}
+	// Set the maximum number of results
+	engine-&gt;setMaxResultsCount(m_queryProps.getMaximumResultsCount());
+
+	// Run the query
+	if (engine-&gt;runQuery(m_queryProps) == false)
+	{
+		m_status = _(&quot;Couldn't run query on search engine&quot;);
+		m_status += &quot; &quot;;
+		m_status += m_engineDisplayableName;
+	}
+	else
+	{
+		const vector&lt;Result&gt; &amp;resultsList = engine-&gt;getResults();
+
+		// Copy the results list
+		m_resultsList.clear();
+		m_resultsList.reserve(resultsList.size());
+		for (vector&lt;Result&gt;::const_iterator resultIter = resultsList.begin();
+			resultIter != resultsList.end(); ++resultIter)
+		{
+			string title = _(&quot;No title&quot;);
+			string extract = HtmlTokenizer::stripTags(resultIter-&gt;getExtract());
+
+			// The title may contain formatting
+			if (resultIter-&gt;getTitle().empty() == false)
+			{
+				title = HtmlTokenizer::stripTags(resultIter-&gt;getTitle());
+			}
+
+			string language = resultIter-&gt;getLanguage();
+			if (language.empty() == true)
+			{
+				// Use the query's language
+				language = m_queryProps.getLanguage();
+			}
+
+			m_resultsList.push_back(Result(resultIter-&gt;getLocation(),
+				title,
+				extract,
+				language,
+				resultIter-&gt;getScore()));
+		}
+	}
+	delete engine;
+
+	emitSignal();
+}
+
+LabelQueryThread::LabelQueryThread(const string &amp;indexName, const string &amp;labelName) :
+	WorkerThread()
+{
+	m_indexName = indexName;
+	m_labelName = labelName;
+}
+
+LabelQueryThread::~LabelQueryThread()
+{
+}
+
+bool LabelQueryThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &amp;LabelQueryThread::do_querying), false);
+
+	return true;
+}
+
+string LabelQueryThread::getType(void) const
+{
+	return &quot;LabelQueryThread&quot;;
+}
+
+string LabelQueryThread::getLabelName(void) const
+{
+	return m_labelName;
+}
+
+bool LabelQueryThread::stop(void)
+{
+	m_done = true;
+	m_status = _(&quot;Stopped querying index labels&quot;);
+	return true;
+}
+
+const set&lt;unsigned int&gt; &amp;LabelQueryThread::getDocumentsList(void) const
+{
+	return m_documentsList;
+}
+
+void LabelQueryThread::do_querying()
+{
+	LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
+	const map&lt;string, string&gt; &amp;indexesMap = PinotSettings::getInstance().getIndexes();
+	map&lt;string, string&gt;::const_iterator mapIter = indexesMap.find(m_indexName);
+	if (mapIter == indexesMap.end())
+	{
+		m_status = _(&quot;Index&quot;);
+		m_status += &quot; &quot;;
+		m_status += m_indexName;
+		m_status += &quot; &quot;;
+		m_status += _(&quot;doesn't exist&quot;);
+		emitSignal();
+		return;
+	}
+
+	labelMan.getDocumentsWithLabel(m_labelName, mapIter-&gt;second, m_documentsList);
+
+	emitSignal();
+}
+
+DownloadingThread::DownloadingThread(const string url, bool fromCache) :
+	WorkerThread()
+{
+	m_url = url;
+	m_fromCache = fromCache;
+	m_pDoc = NULL;
+	// This is for sub-classes that need to things after the document has been downloaded
+	m_signalAfterDownload = true;
+	m_downloader = NULL;
+}
+
+DownloadingThread::~DownloadingThread()
+{
+	if (m_pDoc != NULL)
+	{
+		delete m_pDoc;
+	}
+	if (m_downloader != NULL)
+	{
+		delete m_downloader;
+	}
+}
+
+bool DownloadingThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &amp;DownloadingThread::do_downloading), false);
+
+	return true;
+}
+
+string DownloadingThread::getType(void) const
+{
+	return &quot;DownloadingThread&quot;;
+}
+
+string DownloadingThread::getURL(void) const
+{
+	return m_url;
+}
+
+const Document *DownloadingThread::getDocument(void) const
+{
+	return m_pDoc;
+}
+
+bool DownloadingThread::stop(void)
+{
+	if (m_downloader-&gt;stop() == true)
+	{
+		m_done = true;
+		m_status = _(&quot;Stopped retrieval of&quot;);
+		m_status += &quot; &quot;;
+		m_status += m_url;
+		return true;
+	}
+
+	return false;
+}
+
+void DownloadingThread::do_downloading()
+{
+	if (m_downloader != NULL)
+	{
+		delete m_downloader;
+		m_downloader = NULL;
+	}
+
+	Url thisUrl(m_url);
+
+	if (m_fromCache == true)
+	{
+#ifdef HAS_GOOGLEAPI
+		GoogleAPIEngine googleApiEngine;
+		googleApiEngine.setKey(PinotSettings::getInstance().m_googleAPIKey);
+		m_pDoc = googleApiEngine.retrieveCachedUrl(m_url);
+#endif
+#ifdef DEBUG
+		cout &lt;&lt; &quot;DownloadingThread::do_downloading: got cached page&quot; &lt;&lt; endl;
+#endif
+	}
+	else
+	{
+		// Get a Downloader, the default one will do
+		m_downloader = DownloaderFactory::getDownloader(thisUrl.getProtocol(), &quot;&quot;);
+		if (m_downloader == NULL)
+		{
+			m_status = _(&quot;Couldn't obtain downloader for protocol&quot;);
+			m_status += &quot; &quot;;
+			m_status += thisUrl.getProtocol();
+		}
+		else if (m_done == false)
+		{
+			DocumentInfo docInfo(&quot;Document&quot;, m_url, &quot;&quot;, &quot;&quot;);
+
+			m_pDoc = m_downloader-&gt;retrieveUrl(docInfo);
+		}
+	}
+
+	if (m_pDoc == NULL)
+	{
+		m_status = _(&quot;Couldn't retrieve&quot;);
+		m_status += &quot; &quot;;
+		m_status += m_url;
+	}
+
+	// Signal ?
+	if (m_signalAfterDownload == true)
+	{
+		emitSignal();
+	}
+}
+
+IndexingThread::IndexingThread(const DocumentInfo &amp;docInfo, const string &amp;labelName) :
+	DownloadingThread(docInfo.getLocation(), false)
+{
+	m_docInfo = docInfo;
+	m_indexLocation = PinotSettings::getInstance().m_indexLocation;
+	m_ignoreRobotsDirectives = PinotSettings::getInstance().m_ignoreRobotsDirectives;
+	m_labelName = labelName;
+	// This is not an update
+	m_update = false;
+	// Don't trigger signal after the document has been downloaded
+	m_signalAfterDownload = false;
+}
+
+IndexingThread::IndexingThread(const DocumentInfo &amp;docInfo, unsigned int docId) :
+	DownloadingThread(docInfo.getLocation(), false)
+{
+	m_docInfo = docInfo;
+	m_indexLocation = PinotSettings::getInstance().m_indexLocation;
+	// Ignore robots directives on updates
+	m_ignoreRobotsDirectives = true;
+	m_docIdList.insert(docId);
+	m_update = true;
+	// Don't trigger signal after the document has been downloaded
+	m_signalAfterDownload = false;
+}
+
+IndexingThread::~IndexingThread()
+{
+}
+
+bool IndexingThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &amp;IndexingThread::do_indexing), false);
+
+	return true;
+}
+
+string IndexingThread::getType(void) const
+{
+	return &quot;IndexingThread&quot;;
+}
+
+const DocumentInfo &amp;IndexingThread::getDocumentInfo(void) const
+{
+	return m_docInfo;
+}
+
+string IndexingThread::getLabelName(void) const
+{
+	return m_labelName;
+}
+
+const std::set&lt;unsigned int&gt; &amp;IndexingThread::getDocumentIDs(void) const
+{
+	return m_docIdList;
+}
+
+bool IndexingThread::isNewDocument(void) const
+{
+	// If the thread is set to perform an update, the document isn't new
+	if (m_update == true)
+	{
+		return false;
+	}
+	return true;
+}
+
+bool IndexingThread::stop(void)
+{
+	if (DownloadingThread::stop() == true)
+	{
+		m_done = true;
+		m_status = _(&quot;Stopped indexing&quot;);
+		m_status += &quot; &quot;;
+		m_status += m_url;
+		return true;
+	}
+
+	return false;
+}
+
+void IndexingThread::do_indexing()
+{
+	// First things first, get the index
+	XapianIndex index(m_indexLocation);
+	if (index.isGood() == false)
+	{
+		m_status = _(&quot;Index error on&quot;);
+		m_status += &quot; &quot;;
+		m_status += m_indexLocation;
+		emitSignal();
+		return;
+	}
+
+	do_downloading();
+#ifdef DEBUG
+	cout &lt;&lt; &quot;IndexingThread::do_indexing: downloaded !&quot; &lt;&lt; endl;
+#endif
+
+	if (m_pDoc == NULL)
+	{
+		m_status = _(&quot;Couldn't retrieve&quot;);
+		m_status += &quot; &quot;;
+		m_status += m_url;
+	}
+	else
+	{
+		Url urlObj(m_url);
+		unsigned int urlContentLen;
+		string docType = m_pDoc-&gt;getType();
+		const char *urlContent = m_pDoc-&gt;getData(urlContentLen);
+		bool success = false;
+
+		// The type may have been obtained when downloading
+		if (docType.empty() == false)
+		{
+			m_docInfo.setType(docType);
+		}
+		else
+		{
+			m_pDoc-&gt;setType(m_docInfo.getType());
+		}
+
+		// Skip unsupported types
+		if (TokenizerFactory::isSupportedType(m_docInfo.getType()) == false)
+		{
+			m_status = _(&quot;Cannot index document type&quot;);
+			m_status += &quot; &quot;;
+			m_status += m_docInfo.getType();
+			m_status += &quot; &quot;;
+			m_status += _(&quot;at&quot;);
+			m_status += &quot; &quot;;
+			m_status += m_url;
+			emitSignal();
+			return;
+		}
+
+		// Use the title we were supplied with ?
+		if ((m_docInfo.getTitle().empty() == false) ||
+			(urlObj.getProtocol() == &quot;file&quot;))
+		{
+			m_pDoc-&gt;setTitle(m_docInfo.getTitle());
+		}
+
+		// Tokenize this document
+		Tokenizer *pTokens = TokenizerFactory::getTokenizerByType(m_docInfo.getType(), m_pDoc);
+		if (pTokens == NULL)
+		{
+			m_status = _(&quot;Couln't tokenize&quot;);
+			m_status += &quot; &quot;;
+			m_status += m_url;
+			emitSignal();
+			return;
+		}
+
+		// Is indexing allowed ?
+		HtmlTokenizer *pHtmlTokens = dynamic_cast&lt;HtmlTokenizer*&gt;(pTokens);
+		if ((m_ignoreRobotsDirectives == false) &amp;&amp;
+			(pHtmlTokens != NULL))
+		{
+			// See if the document has a ROBOTS META tag
+			string robotsDirectives = pHtmlTokens-&gt;getMetaTag(&quot;robots&quot;);
+			string::size_type pos1 = robotsDirectives.find(&quot;none&quot;);
+			string::size_type pos2 = robotsDirectives.find(&quot;noindex&quot;);
+			if ((pos1 != string::npos) ||
+				(pos2 != string::npos))
+			{
+				// No, it's not
+				delete pTokens;
+				m_status = _(&quot;Robots META tag forbids indexing&quot;);
+				m_status += &quot; &quot;;
+				m_status += m_url;
+				emitSignal();
+				return;
+			}
+		}
+
+		if (m_done == false)
+		{
+			index.setStemmingMode(IndexInterface::STORE_BOTH);
+
+			// Update an existing document or add to the index ?
+			if ((m_update == true) &amp;&amp;
+				(m_docIdList.size() == 1))
+			{
+				set&lt;unsigned int&gt;::iterator idIter = m_docIdList.begin();
+				if (idIter != m_docIdList.end())
+				{
+					unsigned int docId = *idIter;
+					success = index.updateDocument(docId, *pTokens);
+#ifdef DEBUG
+					cout &lt;&lt; &quot;IndexingThread::do_indexing: updated &quot; &lt;&lt; docId &lt;&lt; endl;
+#endif
+				}
+			}
+			else
+			{
+				unsigned int docId = 0;
+
+				// Save the new document ID
+				success = index.indexDocument(*pTokens, docId);
+				if (success == true)
+				{
+					LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
+
+					set&lt;string&gt; labels;
+					labels.insert(m_labelName);
+					labelMan.setLabels(docId, index.getLocation(), labels);
+
+					m_docIdList.insert(docId);
+				}
+			}
+
+			if (success == false)
+			{
+				m_status = _(&quot;Couldn't index&quot;);
+				m_status += &quot; &quot;;
+				m_status += m_url;
+			}
+			else
+			{
+				// Flush the index
+				index.flush();
+			}
+		}
+
+		delete pTokens;
+	}
+
+	emitSignal();
+}
+
+UnindexingThread::UnindexingThread(const set&lt;unsigned int&gt; &amp;docIdList) :
+	WorkerThread(),
+	m_docsCount(0)
+{
+	copy(docIdList.begin(), docIdList.end(), inserter(m_docIdList, m_docIdList.begin()));
+	m_indexLocation = PinotSettings::getInstance().m_indexLocation;
+}
+
+UnindexingThread::UnindexingThread(const set&lt;string&gt; &amp;labelNames, const string &amp;indexLocation) :
+	WorkerThread(),
+	m_docsCount(0)
+{
+	copy(labelNames.begin(), labelNames.end(), inserter(m_labelNames, m_labelNames.begin()));
+	if (indexLocation.empty() == true)
+	{
+		m_indexLocation = PinotSettings::getInstance().m_indexLocation;
+	}
+	else
+	{
+		m_indexLocation = indexLocation;
+	}
+}
+
+UnindexingThread::~UnindexingThread()
+{
+}
+
+bool UnindexingThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &amp;UnindexingThread::do_unindexing), false);
+
+	return true;
+}
+
+string UnindexingThread::getType(void) const
+{
+	return &quot;UnindexingThread&quot;;
+}
+
+unsigned int UnindexingThread::getDocumentsCount(void) const
+{
+	return m_docsCount;
+}
+
+bool UnindexingThread::stop(void)
+{
+	m_done = true;
+	m_status = _(&quot;Stopped unindexing document(s)&quot;);
+	return true;
+}
+
+void UnindexingThread::do_unindexing()
+{
+	if (m_done == false)
+	{
+		LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
+		XapianIndex index(m_indexLocation);
+
+		if (index.isGood() == false)
+		{
+			m_status = _(&quot;Index error on&quot;);
+			m_status += &quot; &quot;;
+			m_status += m_indexLocation;
+			emitSignal();
+			return;
+		}
+
+		// Be pessimistic and assume something will go wrong ;-)
+		m_status = _(&quot;Couldn't unindex document(s)&quot;);
+
+		// Are we supposed to remove documents based on labels ?
+		if (m_docIdList.empty() == true)
+		{
+			// Yep
+			// FIXME: better delete documents one label at a time
+			for (set&lt;string&gt;::iterator iter = m_labelNames.begin(); iter != m_labelNames.end(); iter++)
+			{
+				string labelName = (*iter);
+				labelMan.getDocumentsWithLabel(labelName, m_indexLocation, m_docIdList);
+				labelMan.deleteLabel(labelName);
+			}
+#ifdef DEBUG
+			cout &lt;&lt; &quot;UnindexingThread::do_unindexing: &quot; &lt;&lt; m_docIdList.size() &lt;&lt; &quot; documents have one of the labels&quot; &lt;&lt; endl;
+#endif
+		}
+
+		for (set&lt;unsigned int&gt;::iterator iter = m_docIdList.begin(); iter != m_docIdList.end(); iter++)
+		{
+			unsigned int docId = (*iter);
+
+			if (index.unindexDocument(docId) == true)
+			{
+				// Delete any label this document may have had
+				if (labelMan.deleteItem(docId, m_indexLocation) == false)
+				{
+#ifdef DEBUG
+					cout &lt;&lt; &quot;UnindexingThread::do_unindexing: &quot; &lt;&lt; docId
+						&lt;&lt; &quot; may not have had labels&quot; &lt;&lt; endl;
+#endif
+				}
+
+				// OK
+				m_status = &quot;&quot;;
+				++m_docsCount;
+			}
+#ifdef DEBUG
+			else cout &lt;&lt; &quot;UnindexingThread::do_unindexing: couldn't remove &quot; &lt;&lt; docId &lt;&lt; endl;
+#endif
+		}
+
+		if (m_docIdList.empty() == false)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;UnindexingThread::do_unindexing: removed &quot; &lt;&lt; m_docIdList.size() &lt;&lt; &quot; documents&quot; &lt;&lt; endl;
+#endif
+			// Flush the index
+			index.flush();
+		}
+		else
+		{
+			// Nothing to report
+			m_status = &quot;&quot;;
+		}
+	}
+
+	emitSignal();
+}
+
+UpdateDocumentThread::UpdateDocumentThread(const string &amp;indexName,
+	unsigned int docId, const DocumentInfo &amp;docInfo) :
+	WorkerThread()
+{
+	m_indexName = indexName;
+	m_docId = docId;
+	m_docInfo = docInfo;
+}
+
+UpdateDocumentThread::~UpdateDocumentThread()
+{
+}
+
+bool UpdateDocumentThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &amp;UpdateDocumentThread::do_update), false);
+
+	return true;
+}
+
+string UpdateDocumentThread::getType(void) const
+{
+	return &quot;UpdateDocumentThread&quot;;
+}
+
+unsigned int UpdateDocumentThread::getDocumentID(void) const
+{
+	return m_docId;
+}
+
+const DocumentInfo &amp;UpdateDocumentThread::getDocumentInfo(void) const
+{
+	return m_docInfo;
+}
+
+bool UpdateDocumentThread::stop(void)
+{
+	m_done = true;
+	m_status = _(&quot;Stopped document update for &quot;);
+	m_status += &quot; &quot;;
+	m_status += m_docId;
+
+	return true;
+}
+
+void UpdateDocumentThread::do_update()
+{
+	if (m_done == false)
+	{
+		const map&lt;string, string&gt; &amp;indexesMap = PinotSettings::getInstance().getIndexes();
+		map&lt;string, string&gt;::const_iterator mapIter = indexesMap.find(m_indexName);
+		if (mapIter == indexesMap.end())
+		{
+			m_status = _(&quot;Index&quot;);
+			m_status += &quot; &quot;;
+			m_status += m_indexName;
+			m_status += &quot; &quot;;
+			m_status += _(&quot;doesn't exist&quot;);
+			emitSignal();
+			return;
+		}
+
+		// Get the index at that location
+		XapianIndex index(mapIter-&gt;second);
+		if (index.isGood() == false)
+		{
+			m_status = _(&quot;Index error on&quot;);
+			m_status += &quot; &quot;;
+			m_status += mapIter-&gt;second;
+			emitSignal();
+			return;
+		}
+
+		if (index.updateDocumentInfo(m_docId, m_docInfo) == false)
+		{
+			m_status = _(&quot;Couldn't update document&quot;);
+		}
+		else
+		{
+			// OK
+			m_status = &quot;&quot;;
+			// Flush the index
+			index.flush();
+		}
+	}
+
+	emitSignal();
+}
+
+ListenerThread::ListenerThread(const string &amp;fifoFileName) :
+	WorkerThread()
+{
+	m_fifoFileName = fifoFileName;
+}
+
+ListenerThread::~ListenerThread()
+{
+}
+
+bool ListenerThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &amp;ListenerThread::do_listening), false);
+
+	return true;
+}
+
+string ListenerThread::getType(void) const
+{
+	return &quot;ListenerThread&quot;;
+}
+
+bool ListenerThread::stop(void)
+{
+	m_done = true;
+	m_status = _(&quot;Stopped listening on&quot;);
+	m_status += &quot; &quot;;
+	m_status += m_fifoFileName;
+
+	return true;
+}
+
+Signal2&lt;void, DocumentInfo, string&gt;&amp; ListenerThread::getReceptionSignal(void)
+{
+	return m_signalReception;
+}
+
+void ListenerThread::do_listening()
+{
+	if (unlink(m_fifoFileName.c_str()) != 0)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ListenerThread::do_listening: couldn't delete FIFO at &quot; &lt;&lt; m_fifoFileName &lt;&lt; endl;
+#endif
+	}
+
+	if (mkfifo(m_fifoFileName.c_str(), S_IRUSR|S_IWUSR) != 0)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ListenerThread::do_listening: couldn't create FIFO at &quot; &lt;&lt; m_fifoFileName &lt;&lt; endl;
+#endif
+	}
+
+	// Ignore SIGPIPE
+	if (sigset(SIGPIPE, SIG_IGN) == SIG_ERR)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;ListenerThread::do_listening: couldn't ignore SIGPIPE&quot; &lt;&lt; endl;
+#endif
+	}
+
+	// Open the FIFO
+	int fd = open(m_fifoFileName.c_str(), O_RDWR);
+	if (fd != -1)
+	{
+		// Set the file in non-blocking mode
+		int flags = fcntl(fd, F_GETFL);
+		flags |= O_NONBLOCK;
+		fcntl(fd, F_SETFL, (long)flags);
+
+		fd_set listenSet;
+		FD_ZERO(&amp;listenSet);
+		FD_SET(fd, &amp;listenSet);
+
+		// Listen and wait for something to read
+		while (m_done == false)
+		{
+			int fdCount = select(fd + 1, &amp;listenSet, NULL, NULL, NULL);
+			if ((fdCount &gt; 0) &amp;&amp;
+				(FD_ISSET(fd, &amp;listenSet)))
+			{
+				string xmlMsg;
+				char buffer[1024];
+
+#ifdef DEBUG
+				cout &lt;&lt; &quot;ListenerThread::do_listening: reading...&quot; &lt;&lt; endl;
+#endif
+				ssize_t bytes = read(fd, buffer, 1024);
+				while (bytes &gt; 0)
+				{
+					xmlMsg += string(buffer, bytes);
+#ifdef DEBUG
+					cout &lt;&lt; &quot;ListenerThread::do_listening: read &quot; &lt;&lt; bytes &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;
+#endif
+					bytes = read(fd, buffer, 1024);
+				}
+
+				// FIXME: ensure the XML is valid, use libxml++ parser
+				string location = StringManip::extractField(xmlMsg, &quot;&lt;location&gt;&quot;, &quot;&lt;/location&gt;&quot;);
+				Url urlObj(location);
+				DocumentInfo docInfo(StringManip::extractField(xmlMsg, &quot;&lt;title&gt;&quot;, &quot;&lt;/title&gt;&quot;),
+					location, MIMEScanner::scanUrl(urlObj), &quot;&quot;);
+				string labelName = StringManip::extractField(xmlMsg, &quot;&lt;label&gt;&quot;, &quot;&lt;/label&gt;&quot;);
+				string content = StringManip::extractField(xmlMsg, &quot;&lt;content&gt;&quot;, &quot;&lt;/content&gt;&quot;);
+#ifdef DEBUG
+				cout &lt;&lt; &quot;ListenerThread::do_listening: &quot; &lt;&lt; content.length() &lt;&lt; &quot; bytes of content&quot; &lt;&lt; endl;
+#endif
+
+				// Signal
+				m_signalReception(docInfo, labelName);
+			}
+		}
+
+		close(fd);
+	}
+	else
+	{
+		m_status = _(&quot;Couldn't read FIFO at&quot;);
+		m_status += &quot; &quot;;
+		m_status += m_fifoFileName;
+	}
+
+	emitSignal();
+}
+
+MonitorThread::MonitorThread(MonitorHandler *pHandler) :
+	WorkerThread()
+{
+	m_pHandler = pHandler;
+	m_numCPUs = sysconf(_SC_NPROCESSORS_ONLN);
+}
+
+MonitorThread::~MonitorThread()
+{
+	// It's our responsability to delete the MonitorHandler object
+	if (m_pHandler != NULL)
+	{
+		delete m_pHandler;
+	}
+}
+
+bool MonitorThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &amp;MonitorThread::do_monitoring), false);
+
+	return true;
+}
+
+string MonitorThread::getType(void) const
+{
+	return &quot;MonitorThread&quot;;
+}
+
+bool MonitorThread::stop(void)
+{
+	m_done = true;
+	m_status = _(&quot;Stopped monitoring&quot;);
+
+	return true;
+}
+
+void MonitorThread::do_monitoring()
+{
+	FAMConnection famConn;
+	FAMRequest famReq;
+	map&lt;unsigned long, string&gt; fsLocations;
+	struct stat fileStat;
+	bool setLocationsToMonitor = true;
+	bool firstTime = true;
+	bool resumeMonitor = false;
+	int famStatus = -1;
+
+	if (m_pHandler == NULL)
+	{
+		m_status = _(&quot;No monitoring handler&quot;);
+		emitSignal();
+		return;
+	}
+
+	// Wait for something to happen
+	while (m_done == false)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MonitorThread::do_monitoring: checking locations&quot; &lt;&lt; endl;
+#endif
+		if ((setLocationsToMonitor == true) &amp;&amp;
+			(m_pHandler-&gt;getFileSystemLocations(fsLocations) &gt; 0) &amp;&amp;
+			(m_pHandler-&gt;hasNewLocations() == true))
+		{
+			// Tell FAM what we want to monitor
+#ifdef DEBUG
+			cout &lt;&lt; &quot;MonitorThread::do_monitoring: change detected&quot; &lt;&lt; endl;
+#endif
+			if (firstTime == false)
+			{
+				// Cancel
+				FAMCancelMonitor(&amp;famConn, &amp;famReq);
+				FAMClose(&amp;famConn);
+			}
+			else
+			{
+				firstTime = false;
+			}
+			resumeMonitor = false;
+
+			// FIXME: opening a new connection every time might be overkill
+			if (FAMOpen(&amp;famConn) != 0)
+			{
+				m_status = _(&quot;Couldn't open FAM connection&quot;);
+				emitSignal();
+				return;
+			}
+
+			// Go through the locations map
+			for (map&lt;unsigned long, std::string&gt;::const_iterator fsIter = fsLocations.begin(); fsIter != fsLocations.end(); ++fsIter)
+			{
+				string fsLocation = fsIter-&gt;second;
+				struct stat fileStat;
+
+				if (stat(fsLocation.c_str(), &amp;fileStat) == -1)
+				{
+					continue;
+				}
+
+				// Is that a file or a directory ?
+				if (S_ISREG(fileStat.st_mode))
+				{
+					famStatus = FAMMonitorFile(&amp;famConn, fsLocation.c_str(), &amp;famReq, NULL);
+				}
+				else if (S_ISDIR(fileStat.st_mode))
+				{
+					// FIXME: FAM works one level deep only: monitor sub-directories if there are any...
+					famStatus = FAMMonitorDirectory(&amp;famConn, fsLocation.c_str(), &amp;famReq, (void*)(fsIter-&gt;first + 1));
+				}
+#ifdef DEBUG
+				cout &lt;&lt; &quot;MonitorThread::do_monitoring: added &quot; &lt;&lt; fsLocation &lt;&lt; &quot;, &quot; &lt;&lt; famStatus &lt;&lt; endl;
+#endif
+			}
+		}
+		setLocationsToMonitor = false;
+
+		int fd = FAMCONNECTION_GETFD(&amp;famConn);
+
+		fd_set listenSet;
+		FD_ZERO(&amp;listenSet);
+		FD_SET(fd, &amp;listenSet);
+
+		struct timeval selectTimeout;
+		selectTimeout.tv_sec = 60;
+		selectTimeout.tv_usec = 0;
+
+		int fdCount = select(fd + 1, &amp;listenSet, NULL, NULL, &amp;selectTimeout);
+		if ((fdCount &gt; 0) &amp;&amp;
+			(FD_ISSET(fd, &amp;listenSet)))
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;MonitorThread::do_monitoring: select() returned&quot; &lt;&lt; endl;
+#endif
+			// There might be more than one event waiting...
+			while ((FAMPending(&amp;famConn) &gt;= 1) &amp;&amp;
+				(m_done == false))
+			{
+				double averageLoad[3];
+
+				// Get the load averaged over the last minute
+				if (getloadavg(averageLoad, 3) != -1)
+				{
+					// FIXME: is LOADAVG_1MIN Solaris specific ?
+					if (averageLoad[0] &gt;= (double)m_numCPUs * 4)
+					{
+						// Ignore pending events if the load has become too high
+#ifdef DEBUG
+						cout &lt;&lt; &quot;MonitorThread::do_monitoring: cancelling monitoring because of load (&quot; &lt;&lt; averageLoad[0] &lt;&lt; &quot;)&quot; &lt;&lt; endl;
+#endif
+						FAMCancelMonitor(&amp;famConn, &amp;famReq);
+						resumeMonitor = true;
+						break;
+					}
+				}
+
+				FAMEvent famEvent;
+				if ((FAMNextEvent(&amp;famConn, &amp;famEvent) == 1) &amp;&amp;
+					(famEvent.filename != NULL) &amp;&amp;
+					(strlen(famEvent.filename) &gt; 0))
+				{
+					string fileName;
+					bool updatedIndex = false;
+
+#ifdef DEBUG
+					cout &lt;&lt; &quot;MonitorThread::do_monitoring: event &quot; &lt;&lt; famEvent.code
+						&lt;&lt; &quot; on &quot; &lt;&lt; famEvent.filename &lt;&lt; endl;
+#endif
+					if (famEvent.code == FAMEndExist)
+					{
+						updatedIndex = m_pHandler-&gt;fileExists(famEvent.filename, true);
+						// FIXME: accounts for which we didn't receive a FAMExists should
+						// be removed
+					}
+					else
+					{
+						// Are we monitoring a file or a directory ?
+						if (famEvent.userdata != NULL)
+						{
+							// A directory...
+							if (famEvent.filename[0] == '/')
+							{
+								// Not interested in monitored directories...
+								continue;
+							}
+
+							// The event is on a file in that directory
+							map&lt;unsigned long, string&gt;::const_iterator fsIter = fsLocations.find((unsigned long)famEvent.userdata);
+							if (fsIter == fsLocations.end())
+							{
+								continue;
+							}
+							fileName += fsIter-&gt;second;
+							fileName += &quot;/&quot;;
+						}
+						fileName += famEvent.filename;
+
+						// What's the event code ?
+						if (famEvent.code == FAMExists)
+						{
+							updatedIndex = m_pHandler-&gt;fileExists(fileName);
+						}
+						else if (famEvent.code == FAMCreated)
+						{
+							m_pHandler-&gt;fileCreated(fileName);
+						}
+						else if (famEvent.code == FAMChanged)
+						{
+							updatedIndex = m_pHandler-&gt;fileChanged(fileName);
+						}
+						else if (famEvent.code == FAMDeleted)
+						{
+							updatedIndex = m_pHandler-&gt;fileDeleted(fileName);
+						}
+					}
+				}
+			}
+		}
+		else
+		{
+			if (resumeMonitor == true)
+			{
+				// Resume
+#ifdef DEBUG
+				cout &lt;&lt; &quot;MonitorThread::do_monitoring: resuming monitoring&quot; &lt;&lt; endl;
+#endif
+				FAMResumeMonitor(&amp;famConn, &amp;famReq);
+				resumeMonitor = false;
+			}
+
+			// Chances are the timeout expired
+			// See if the locations to monitor have changed
+			setLocationsToMonitor = true;
+		}
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;MonitorThread::do_monitoring: quitting...&quot; &lt;&lt; endl;
+#endif
+
+	// Stop monitoring and close the connection
+	FAMCancelMonitor(&amp;famConn, &amp;famReq);
+	FAMClose(&amp;famConn);
+
+	emitSignal();
+}

Added: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,362 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _WORKERTHREADS_HH
+#define _WORKERTHREADS_HH
+
+#include &lt;time.h&gt;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;set&gt;
+#include &lt;map&gt;
+#include &lt;sigc++/slot.h&gt;
+#include &lt;glibmm/dispatcher.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+
+#include &quot;Document.h&quot;
+#include &quot;IndexedDocument.h&quot;
+#include &quot;DownloaderInterface.h&quot;
+#include &quot;QueryProperties.h&quot;
+#include &quot;Result.h&quot;
+#include &quot;MonitorHandler.h&quot;
+
+class WorkerThread
+{
+	public:
+		WorkerThread();
+		virtual ~WorkerThread();
+
+		void setId(unsigned int id);
+
+		unsigned int getId(void);
+
+		void inBackground(void);
+
+		bool isBackground(void);
+
+		bool operator&lt;(const WorkerThread &amp;other) const;
+
+		virtual bool start(void) = 0;
+
+		virtual std::string getType(void) const = 0;
+
+		virtual bool stop(void) = 0;
+
+		/// Only one thread (the GUI thread) should connect to this, before calling start().
+		static Glib::Dispatcher&amp; getFinishedSignal();
+
+		bool isDone(void) const;
+
+		void reset(void);
+
+		std::string getStatus(void) const;
+
+	protected:
+		/// Use a Dispatcher, not a Signal, for thread safety
+		static Glib::Dispatcher m_signalFinished;
+		unsigned int m_id;
+		bool m_background;
+		bool m_done;
+		std::string m_status;
+
+		void emitSignal(void);
+
+	private:
+		WorkerThread(const WorkerThread &amp;other);
+		WorkerThread &amp;operator=(const WorkerThread &amp;other);
+
+};
+
+class IndexBrowserThread : public WorkerThread
+{
+	public:
+		IndexBrowserThread(const std::string &amp;indexName,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0);
+		~IndexBrowserThread();
+
+		virtual bool start(void);
+
+		std::string getType(void) const;
+
+		std::string getIndexName(void) const;
+
+		unsigned int getDocumentsCount(void) const;
+
+		virtual bool stop(void);
+
+		SigC::Signal3&lt;void, IndexedDocument, unsigned int, std::string&gt;&amp; getUpdateSignal(void);
+
+	protected:
+		std::string m_indexName;
+		unsigned int m_indexDocsCount;
+		unsigned int m_maxDocsCount;
+		unsigned int m_startDoc;
+		SigC::Signal3&lt;void, IndexedDocument, unsigned int, std::string&gt; m_signalUpdate;
+
+		void do_browsing();
+
+	private:
+		IndexBrowserThread(const IndexBrowserThread &amp;other);
+		IndexBrowserThread &amp;operator=(const IndexBrowserThread &amp;other);
+
+};
+
+class QueryingThread : public WorkerThread
+{
+	public:
+		QueryingThread(const std::string &amp;engineName, const std::string &amp;engineDisplayableName,
+			const std::string &amp;engineOption, const QueryProperties &amp;queryProps);
+		virtual ~QueryingThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		virtual std::string getEngineName(void) const;
+
+		virtual QueryProperties getQuery(void) const;
+
+		virtual const std::vector&lt;Result&gt; &amp;getResults(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		std::string m_engineName;
+		std::string m_engineDisplayableName;
+		std::string m_engineOption;
+		QueryProperties m_queryProps;
+		std::vector&lt;Result&gt; m_resultsList;
+
+		void do_querying();
+
+	private:
+		QueryingThread(const QueryingThread &amp;other);
+		QueryingThread &amp;operator=(const QueryingThread &amp;other);
+
+};
+
+class LabelQueryThread : public WorkerThread
+{
+	public:
+		LabelQueryThread(const std::string &amp;indexName, const std::string &amp;labelName);
+		virtual ~LabelQueryThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		virtual std::string getLabelName(void) const;
+
+		virtual bool stop(void);
+
+		virtual const std::set&lt;unsigned int&gt; &amp;getDocumentsList(void) const;
+
+	protected:
+		std::string m_indexName;
+		std::string m_labelName;
+		std::set&lt;unsigned int&gt; m_documentsList;
+
+		void do_querying();
+
+	private:
+		LabelQueryThread(const LabelQueryThread &amp;other);
+		LabelQueryThread &amp;operator=(const LabelQueryThread &amp;other);
+
+};
+
+class DownloadingThread : public WorkerThread
+{
+	public:
+		DownloadingThread(const std::string url, bool fromCache);
+		virtual ~DownloadingThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		virtual std::string getURL(void) const;
+
+		virtual const Document *getDocument(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		std::string m_url;
+		bool m_fromCache;
+		Document *m_pDoc;
+		bool m_signalAfterDownload;
+		DownloaderInterface *m_downloader;
+
+		void do_downloading();
+
+	private:
+		DownloadingThread(const DownloadingThread &amp;other);
+		DownloadingThread &amp;operator=(const DownloadingThread &amp;other);
+
+};
+
+class IndexingThread : public DownloadingThread
+{
+	public:
+		/// Index a document.
+		IndexingThread(const DocumentInfo &amp;docInfo, const std::string &amp;labelName);
+		/// Update a document.
+		IndexingThread(const DocumentInfo &amp;docInfo, unsigned int docId);
+		virtual ~IndexingThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		const DocumentInfo &amp;getDocumentInfo(void) const;
+
+		std::string getLabelName(void) const;
+
+		const std::set&lt;unsigned int&gt; &amp;getDocumentIDs(void) const;
+
+		bool isNewDocument(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		DocumentInfo m_docInfo;
+		std::string m_indexLocation;
+		bool m_ignoreRobotsDirectives;
+		std::string m_labelName;
+		std::set&lt;unsigned int&gt; m_docIdList;
+		bool m_update;
+
+		void do_indexing();
+
+	private:
+		IndexingThread(const IndexingThread &amp;other);
+		IndexingThread &amp;operator=(const IndexingThread &amp;other);
+
+};
+
+class UnindexingThread : public WorkerThread
+{
+	public:
+		// Unindex documents from the internal index
+		UnindexingThread(const std::set&lt;unsigned int&gt; &amp;docIdList);
+		// Unindex from the given index documents that have one of the labels
+		UnindexingThread(const std::set&lt;std::string&gt; &amp;labelNames, const std::string &amp;indexLocation);
+		virtual ~UnindexingThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		unsigned int getDocumentsCount(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		std::set&lt;unsigned int&gt; m_docIdList;
+		std::set&lt;std::string&gt; m_labelNames;
+		std::string m_indexLocation;
+		unsigned int m_docsCount;
+
+		void do_unindexing();
+
+	private:
+		UnindexingThread(const UnindexingThread &amp;other);
+		UnindexingThread &amp;operator=(const UnindexingThread &amp;other);
+
+};
+
+class UpdateDocumentThread : public WorkerThread
+{
+	public:
+		// Update a document's properties
+		UpdateDocumentThread(const std::string &amp;indexName,
+			unsigned int docId, const DocumentInfo &amp;docInfo);
+		virtual ~UpdateDocumentThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		unsigned int getDocumentID(void) const;
+
+		const DocumentInfo &amp;getDocumentInfo(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		std::string m_indexName;
+		unsigned int m_docId;
+		DocumentInfo m_docInfo;
+
+		void do_update();
+
+	private:
+		UpdateDocumentThread(const UpdateDocumentThread &amp;other);
+		UpdateDocumentThread &amp;operator=(const UpdateDocumentThread &amp;other);
+
+};
+
+class ListenerThread : public WorkerThread
+{
+	public:
+		ListenerThread(const std::string &amp;fifoFileName);
+		virtual ~ListenerThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		virtual bool stop(void);
+
+		SigC::Signal2&lt;void, DocumentInfo, std::string&gt;&amp; getReceptionSignal(void);
+
+	protected:
+		std::string m_fifoFileName;
+		SigC::Signal2&lt;void, DocumentInfo, std::string&gt; m_signalReception;
+
+		void do_listening();
+
+	private:
+		ListenerThread(const ListenerThread &amp;other);
+		ListenerThread &amp;operator=(const ListenerThread &amp;other);
+
+};
+
+class MonitorThread : public WorkerThread
+{
+	public:
+		MonitorThread(MonitorHandler *pHandler);
+		virtual ~MonitorThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		MonitorHandler *m_pHandler;
+		long m_numCPUs;
+
+		void do_monitoring();
+
+	private:
+		MonitorThread(const MonitorThread &amp;other);
+		MonitorThread &amp;operator=(const MonitorThread &amp;other);
+
+};
+
+#endif // _WORKERTHREADS_HH

Added: trunk/UI/GTK2/src/aboutDialog.cc
===================================================================
--- trunk/UI/GTK2/src/aboutDialog.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/aboutDialog.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,28 @@
+// generated 2003/5/18 11:20:09 BST by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to aboutDialog.cc_new
+
+// This file is for your program, I won't touch it again!
+
+#include &lt;glibmm/ustring.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;aboutDialog.hh&quot;
+
+using namespace Glib;
+
+aboutDialog::aboutDialog()
+{
+#ifdef VERSION
+	ustring name = nameLabel-&gt;get_text();
+	name += &quot; v&quot;;
+	name += VERSION;
+	nameLabel-&gt;set_text(name);
+#endif
+}
+
+aboutDialog::~aboutDialog()
+{
+}


Property changes on: trunk/UI/GTK2/src/aboutDialog.cc
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/aboutDialog.hh
===================================================================
--- trunk/UI/GTK2/src/aboutDialog.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/aboutDialog.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,22 @@
+// generated 2003/5/18 11:20:09 BST by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to aboutDialog.hh_new
+
+// you might replace
+//    class foo : public foo_glade { ... };
+// by
+//    typedef foo_glade foo;
+// if you didn't make any modifications to the widget
+
+#ifndef _ABOUTDIALOG_HH
+#  include &quot;aboutDialog_glade.hh&quot;
+#  define _ABOUTDIALOG_HH
+class aboutDialog : public aboutDialog_glade
+{
+public:
+	aboutDialog();
+	virtual ~aboutDialog();
+
+};
+#endif


Property changes on: trunk/UI/GTK2/src/aboutDialog.hh
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/aboutDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/aboutDialog_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/aboutDialog_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,407 @@
+// generated 2005/12/1 23:54:57 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/aboutDialog.cc
+
+
+#if defined __GNUC__ &amp;&amp; __GNUC__ &lt; 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include &quot;config.h&quot;
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include &lt;libintl.h&gt;
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include &lt;gtkmmconfig.h&gt;
+#if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
+#include &lt;sigc++/compatibility.h&gt;
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include &quot;aboutDialog_glade.hh&quot;
+#include &lt;gdk/gdkkeysyms.h&gt;
+#include &lt;gtkmm/accelgroup.h&gt;
+#include &lt;gtkmm/buttonbox.h&gt;
+#include &lt;gtkmm/image.h&gt;
+#include &lt;gdkmm/pixbufloader.h&gt;
+
+static const unsigned char pinot_png_data[] = 
+{       	137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,
+	0,0,0,48,0,0,0,48,8,6,0,0,0,87,2,249,
+	135,0,0,0,6,98,75,71,68,0,255,0,255,0,255,160,
+	189,167,147,0,0,0,9,112,72,89,115,0,0,11,19,0,
+	0,11,19,1,0,154,156,24,0,0,0,7,116,73,77,69,
+	7,213,2,11,16,54,2,88,210,160,116,0,0,7,95,73,
+	68,65,84,104,222,237,153,107,108,20,215,21,199,127,243,216,
+	245,218,222,101,109,99,131,29,136,13,133,64,168,11,196,6,
+	213,41,52,136,66,77,243,52,16,68,40,9,81,212,70,137,
+	72,138,210,32,62,244,173,86,106,66,63,68,170,170,180,169,
+	20,169,106,161,161,84,74,210,36,53,45,15,5,66,11,229,
+	17,234,212,70,24,240,3,140,95,187,241,99,119,189,175,217,
+	217,157,217,153,233,7,108,176,193,27,239,218,86,104,37,31,
+	105,62,220,253,159,185,115,254,115,207,252,239,57,119,97,202,
+	166,108,202,166,108,202,166,236,255,216,132,76,156,107,115,16,
+	128,16,224,26,195,53,6,248,129,6,224,16,240,86,77,140,
+	232,255,2,129,5,64,115,166,15,73,88,68,34,22,207,124,
+	59,206,251,147,77,64,204,208,191,98,248,192,180,192,184,229,
+	50,173,219,111,202,18,112,229,9,188,247,45,27,223,155,108,
+	2,242,68,8,188,146,128,58,19,19,24,17,246,52,16,238,
+	147,16,159,180,193,93,131,175,72,22,160,74,226,23,251,117,
+	234,18,112,236,78,173,64,229,240,65,219,245,176,107,6,95,
+	196,141,43,12,242,9,131,25,175,38,120,190,199,68,31,242,
+	191,75,68,88,44,178,7,144,238,248,10,132,44,8,92,39,
+	208,48,138,159,5,244,119,89,236,253,143,96,171,124,24,125,
+	251,16,48,95,100,118,157,96,255,25,134,246,115,128,108,151,
+	123,227,252,170,117,155,165,156,194,47,5,21,131,80,175,167,
+	49,212,122,226,29,51,17,249,123,182,203,253,72,10,236,125,
+	64,203,136,64,109,14,179,129,194,161,241,53,19,128,126,192,
+	147,226,150,210,7,54,172,223,51,111,243,51,171,120,238,241,
+	27,63,22,8,224,94,244,232,15,212,222,182,175,46,175,154,
+	109,175,121,126,103,213,236,5,21,146,79,137,211,242,169,68,
+	227,21,107,97,219,241,183,215,207,80,14,135,158,120,105,87,
+	222,173,88,231,185,143,106,122,254,241,235,163,113,207,153,231,
+	0,143,60,222,252,31,36,112,62,133,175,115,197,227,15,253,
+	233,251,175,238,88,233,206,113,10,129,225,57,43,128,40,137,
+	82,249,138,37,171,127,184,123,27,249,121,211,80,141,139,40,
+	122,27,179,138,20,122,252,85,36,156,205,242,79,118,191,60,
+	253,86,204,175,172,33,52,239,203,182,88,248,197,7,245,184,
+	254,123,195,95,247,152,56,238,252,55,83,166,15,121,37,101,
+	79,63,244,236,119,191,82,88,48,93,112,196,212,17,88,216,
+	2,35,236,97,195,179,91,41,154,94,72,142,205,78,220,80,
+	176,139,160,91,6,253,13,135,121,228,155,143,141,138,217,179,
+	20,236,217,14,108,206,2,65,44,249,198,90,100,215,54,113,
+	130,43,48,42,129,178,229,15,110,43,43,115,72,150,149,36,
+	214,120,105,4,214,107,129,35,75,102,238,220,108,44,43,137,
+	102,104,228,202,14,166,217,93,8,166,130,22,140,49,103,142,
+	99,84,44,161,135,177,76,19,203,178,16,178,102,74,66,222,
+	242,45,227,74,33,205,130,110,43,117,10,37,109,249,203,18,
+	70,63,97,45,15,253,224,161,17,216,121,3,36,135,147,33,
+	28,64,77,170,116,6,7,80,226,171,137,134,15,164,196,18,
+	234,60,226,138,31,61,166,34,103,217,48,178,75,42,229,52,
+	63,224,2,160,116,104,220,105,129,9,113,160,105,52,255,112,
+	84,151,154,188,65,28,237,45,184,222,59,114,67,171,175,154,
+	208,99,65,73,238,44,154,188,65,108,114,12,127,4,52,67,
+	193,167,44,195,31,93,74,56,242,110,74,172,175,55,136,226,
+	235,39,30,10,33,231,218,209,68,187,67,158,64,254,95,4,
+	146,163,22,66,193,64,107,203,17,115,81,213,7,175,33,234,
+	55,93,246,105,144,85,180,16,205,112,112,170,190,20,217,126,
+	142,128,50,151,96,176,15,213,240,227,243,117,17,87,141,148,
+	152,191,115,128,176,215,67,82,75,144,147,151,143,97,36,154,
+	228,201,202,255,218,28,68,160,0,168,104,188,248,103,117,225,
+	165,183,176,153,55,131,63,168,195,39,38,184,230,60,74,164,
+	215,67,247,5,133,99,177,34,230,150,255,139,206,222,92,148,
+	240,105,162,129,38,98,3,129,148,88,164,163,8,165,63,76,
+	110,177,11,93,21,77,203,127,242,29,33,205,20,218,15,108,
+	29,94,3,9,96,10,194,136,18,66,76,85,28,30,77,194,
+	111,52,112,84,185,177,47,89,130,216,115,63,177,150,110,178,
+	75,171,177,79,83,112,221,251,33,148,116,161,132,21,148,139,
+	249,104,117,119,147,93,250,240,109,152,122,109,38,114,168,26,
+	193,156,143,255,220,223,154,204,206,253,43,211,218,210,183,218,
+	120,101,248,38,38,8,32,8,8,131,65,139,169,130,247,154,
+	240,166,6,111,39,193,94,145,69,193,122,55,238,233,58,134,
+	120,9,169,91,39,25,236,34,28,186,27,221,125,129,164,163,
+	21,25,139,188,153,6,201,228,53,162,13,62,98,241,210,17,
+	152,187,64,67,55,234,241,159,104,236,51,59,14,213,0,237,
+	66,26,111,63,23,8,127,86,221,100,89,160,2,138,117,93,
+	38,91,76,104,48,160,193,4,4,41,104,43,203,117,74,247,
+	104,178,36,200,56,77,39,107,151,173,101,205,134,53,92,252,
+	180,133,3,127,12,226,233,253,8,203,217,133,36,200,24,1,
+	129,45,213,155,184,127,101,21,181,31,124,204,217,214,163,168,
+	118,31,146,32,163,13,100,99,4,238,195,12,68,254,201,192,
+	217,213,233,150,18,75,135,7,127,88,135,223,234,163,243,0,
+	162,64,16,184,6,124,12,28,197,50,62,92,80,249,162,250,
+	242,79,151,201,101,249,55,165,177,45,208,143,45,127,35,229,
+	155,230,225,184,236,167,183,241,2,138,207,71,118,252,28,79,
+	189,240,36,106,82,101,93,241,3,44,142,108,167,185,123,30,
+	87,135,124,108,62,18,218,201,114,99,224,108,218,197,92,197,
+	40,21,232,155,192,246,116,55,144,33,89,77,75,26,253,34,
+	23,188,222,49,229,51,147,106,52,237,29,56,101,127,25,12,
+	180,158,170,47,93,148,142,52,230,22,153,52,245,73,99,202,
+	103,38,4,42,135,171,79,251,56,8,132,91,142,255,197,211,
+	88,243,163,99,177,34,97,12,105,196,145,99,16,84,198,150,
+	207,161,185,165,49,62,96,27,240,171,33,63,175,5,127,77,
+	98,2,59,1,61,93,2,102,60,120,57,17,85,55,69,213,
+	242,252,238,171,121,24,206,127,147,44,174,67,205,58,131,150,
+	108,198,225,40,65,20,11,137,54,214,98,185,170,240,180,207,
+	72,233,19,58,127,160,217,242,159,218,193,117,221,248,108,2,
+	91,109,44,1,190,51,188,142,57,109,208,10,252,50,195,70,
+	40,106,132,219,235,52,69,93,19,215,202,220,186,251,130,48,
+	92,26,147,102,61,182,43,94,190,182,222,198,149,186,46,34,
+	161,226,219,228,51,105,214,91,129,147,151,219,140,246,131,155,
+	129,246,116,83,104,68,254,143,39,125,110,46,67,226,148,217,
+	115,104,181,25,109,219,149,176,69,118,36,58,20,65,18,18,
+	104,134,206,170,138,85,44,249,241,10,148,172,21,68,11,236,
+	124,242,238,62,162,245,237,36,58,20,36,33,65,143,175,215,
+	107,116,39,247,210,119,245,117,160,39,147,150,114,180,26,232,
+	252,4,90,216,14,162,205,47,21,21,236,122,225,137,157,247,
+	202,139,75,237,35,85,105,96,41,81,35,136,187,124,35,122,
+	243,23,17,16,136,53,159,140,26,29,123,102,141,183,39,30,
+	169,64,214,4,86,96,156,170,52,92,113,50,58,149,24,60,
+	133,91,154,102,19,79,230,170,20,179,142,29,47,26,84,156,
+	8,237,109,167,233,105,63,64,224,90,51,74,191,159,156,25,
+	183,43,78,166,43,112,15,224,28,165,137,247,78,148,128,30,
+	108,127,163,239,204,31,158,138,246,111,152,219,117,185,252,70,
+	193,150,200,86,48,180,153,56,115,170,17,204,124,162,245,181,
+	45,168,221,191,27,47,129,76,154,248,76,173,39,209,113,228,
+	105,93,213,247,137,51,191,94,22,207,15,11,246,236,78,236,
+	130,131,194,47,244,18,245,236,181,124,135,138,219,204,206,83,
+	91,128,192,68,30,180,101,176,198,25,186,94,155,228,147,193,
+	50,156,11,95,183,85,228,123,29,213,14,43,119,157,211,146,
+	42,101,15,51,216,13,20,127,222,167,220,2,119,192,196,73,
+	156,203,118,39,72,76,22,1,107,48,120,241,243,38,33,77,
+	242,124,214,212,127,70,83,54,101,83,150,145,253,23,118,236,
+	95,208,24,43,190,110,0,0,0,0,73,69,78,68,174,66,
+	96,130,
+
+};
+
+#include &lt;gtkmm/label.h&gt;
+
+static const unsigned char xapian_powered_png_data[] = 
+{       	137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,
+	0,0,0,208,0,0,0,30,8,3,0,0,0,106,152,96,
+	130,0,0,0,4,103,65,77,65,0,0,175,200,55,5,138,
+	233,0,0,0,25,116,69,88,116,83,111,102,116,119,97,114,
+	101,0,65,100,111,98,101,32,73,109,97,103,101,82,101,97,
+	100,121,113,201,101,60,0,0,1,128,80,76,84,69,205,205,
+	205,226,124,52,255,56,7,51,51,177,255,115,101,166,230,102,
+	250,213,180,171,171,171,71,71,157,255,102,82,233,130,54,255,
+	153,56,51,51,202,185,243,102,250,174,121,147,217,102,190,190,
+	190,255,181,115,148,148,214,255,245,22,255,245,179,255,210,118,
+	201,254,102,255,86,56,255,74,39,255,154,155,255,217,56,218,
+	116,51,255,199,85,150,214,124,197,251,102,255,137,134,255,223,
+	46,255,185,104,255,210,146,236,183,148,52,52,154,255,66,24,
+	148,147,183,216,218,228,255,215,213,255,166,133,255,236,233,250,
+	148,74,203,101,51,204,255,103,255,165,167,241,139,55,138,211,
+	102,255,250,245,255,211,69,255,226,220,176,237,102,251,149,66,
+	202,202,218,255,152,66,255,246,236,255,128,122,210,108,51,233,
+	189,165,255,179,172,255,197,197,255,252,250,68,68,191,255,252,
+	13,243,141,66,255,238,28,255,233,34,172,229,124,210,211,218,
+	255,94,68,255,167,156,255,251,248,255,80,43,160,221,124,255,
+	245,244,157,224,102,255,204,78,255,255,255,130,206,102,255,228,
+	39,237,135,62,102,102,102,178,178,178,217,217,217,153,153,153,
+	236,236,236,159,159,159,140,140,140,197,197,197,229,229,229,245,
+	245,245,249,249,249,226,226,226,111,111,111,165,165,165,223,223,
+	223,242,242,242,121,121,121,185,185,185,210,210,210,130,130,130,
+	254,255,254,149,149,149,183,237,124,255,150,139,255,190,182,255,
+	255,250,255,255,254,255,226,65,255,255,157,178,177,198,253,151,
+	73,242,182,134,191,247,102,255,249,218,196,249,103,255,191,96,
+	255,216,95,255,236,42,124,202,102,255,175,175,255,255,127,75,
+	75,130,255,143,143,255,255,193,247,145,60,247,145,71,7,225,
+	45,180,0,0,6,205,73,68,65,84,120,218,98,240,27,102,
+	0,32,128,24,232,105,153,51,16,56,57,9,11,11,59,0,
+	65,30,109,236,0,8,32,26,123,72,23,6,196,74,120,253,
+	252,2,20,20,2,2,160,94,170,202,166,141,141,0,1,68,
+	39,15,137,201,21,153,248,249,41,72,73,73,1,253,4,242,
+	82,94,142,29,109,108,4,8,32,250,120,72,12,24,65,64,
+	15,201,24,1,1,208,79,1,229,181,126,118,130,180,177,17,
+	32,128,104,237,33,49,8,144,43,226,101,245,243,43,149,145,
+	145,241,5,122,41,183,54,219,80,144,59,135,38,54,2,4,
+	16,205,61,36,7,2,37,69,188,38,172,126,57,130,165,165,
+	64,63,249,150,21,251,121,8,114,115,211,198,70,128,0,162,
+	181,135,74,74,138,138,138,120,121,129,254,241,241,243,19,84,
+	4,130,82,81,139,28,67,65,115,90,121,8,32,128,104,237,
+	33,176,103,128,128,213,135,31,24,67,32,32,106,232,7,244,
+	143,185,57,141,60,4,16,64,52,246,80,6,208,55,172,64,
+	224,227,195,111,224,231,167,201,199,199,167,148,3,244,79,65,
+	65,129,185,57,109,108,4,8,32,90,123,8,24,53,64,192,
+	207,207,111,224,15,246,16,155,159,159,29,95,189,54,237,60,
+	4,16,64,52,247,16,196,55,6,6,254,21,64,15,105,178,
+	249,229,120,240,57,214,107,131,124,148,70,19,27,1,2,136,
+	214,30,202,112,113,241,2,2,89,32,240,203,209,20,241,75,
+	179,227,11,12,4,249,200,212,20,162,34,141,61,40,34,34,
+	34,41,60,54,14,68,197,197,226,55,47,154,160,141,0,1,
+	68,99,15,229,164,229,0,65,26,4,128,4,236,248,184,184,
+	64,62,50,53,173,131,42,137,140,8,10,10,138,96,15,139,
+	72,10,10,74,74,199,239,226,72,66,30,246,243,3,8,32,
+	186,54,78,253,114,98,248,184,24,25,65,62,170,171,171,131,
+	139,198,38,5,5,3,3,63,41,40,156,80,4,16,225,33,
+	128,0,162,169,135,132,64,64,13,10,242,65,45,3,187,66,
+	70,70,144,143,244,129,0,161,46,54,46,40,196,47,61,40,
+	28,150,174,34,131,131,131,195,32,50,33,33,209,97,193,17,
+	193,33,96,94,72,72,8,134,138,232,144,144,48,191,216,224,
+	96,152,71,0,2,136,34,15,37,6,7,39,160,50,80,1,
+	15,15,51,16,168,64,128,43,36,142,148,25,165,129,62,226,
+	66,241,144,31,67,80,28,123,80,42,52,126,194,226,130,146,
+	82,131,130,64,113,17,29,7,76,134,64,28,20,20,9,86,
+	21,20,36,0,86,145,4,86,1,246,93,56,80,69,56,72,
+	5,84,59,64,0,81,22,67,41,161,80,253,33,161,12,184,
+	60,4,241,14,71,8,48,130,140,179,188,129,62,146,150,6,
+	123,137,11,185,45,23,28,20,4,79,77,193,65,236,105,126,
+	145,208,248,138,13,2,37,196,144,56,136,235,5,64,105,19,
+	170,130,1,170,34,4,168,53,196,47,58,60,72,0,156,73,
+	1,2,8,230,142,196,168,132,152,20,6,80,44,2,41,134,
+	68,32,25,149,16,21,147,0,162,128,97,31,2,18,242,139,
+	10,137,9,97,136,1,170,101,96,0,25,31,3,20,100,135,
+	233,15,102,136,98,72,137,241,75,72,0,170,79,72,128,68,
+	87,14,15,15,200,75,32,255,84,171,3,249,198,54,54,54,
+	222,126,126,202,86,96,47,49,34,123,61,44,40,40,29,158,
+	0,131,216,129,113,19,20,1,225,5,197,129,51,15,196,245,
+	33,16,15,197,198,33,171,136,0,71,95,24,148,11,16,128,
+	138,50,214,65,16,138,161,104,55,86,86,255,128,201,15,240,
+	7,28,76,186,148,114,237,139,166,194,195,73,126,128,248,243,
+	60,177,16,157,154,52,119,184,39,61,233,86,104,132,186,137,
+	38,238,225,36,72,93,165,78,89,31,162,48,174,97,130,174,
+	23,245,26,153,147,102,43,203,155,59,57,118,32,23,131,148,
+	36,168,133,218,118,161,144,238,221,190,38,110,230,249,120,56,
+	95,166,66,116,250,48,253,126,227,103,88,245,37,186,147,12,
+	59,208,58,163,125,0,253,39,174,171,157,17,228,69,0,193,
+	83,74,8,208,51,126,193,201,126,145,241,192,56,72,78,246,
+	243,99,143,244,11,15,13,73,4,10,135,129,164,216,5,252,
+	98,128,190,97,79,6,75,134,132,2,147,91,12,80,4,238,
+	33,160,77,81,161,97,64,137,24,191,120,6,63,132,135,64,
+	81,196,1,138,31,13,61,61,201,204,26,249,76,45,63,59,
+	107,43,29,160,151,144,60,20,30,20,17,11,201,53,32,39,
+	37,129,114,4,170,135,252,80,60,132,170,34,34,8,89,33,
+	64,0,193,61,20,21,10,226,197,251,5,131,2,42,1,200,
+	73,97,15,11,141,20,8,137,7,73,129,64,36,40,93,249,
+	69,198,0,189,9,4,225,126,12,193,224,148,6,79,114,64,
+	2,148,145,194,67,194,128,126,66,241,16,135,58,176,187,173,
+	33,41,89,35,47,111,201,194,98,169,229,151,99,173,163,163,
+	99,133,104,41,68,6,197,69,3,243,71,18,36,91,199,197,
+	69,198,130,220,23,29,140,43,134,96,42,252,130,49,61,4,
+	16,64,104,30,98,135,120,8,24,1,192,120,73,9,78,136,
+	143,20,0,73,69,69,69,1,11,71,168,243,227,5,128,92,
+	6,172,30,74,1,230,219,96,129,100,63,100,15,241,128,227,
+	199,22,232,25,160,111,56,57,221,220,88,180,114,210,64,62,
+	130,251,39,4,18,57,233,144,130,10,226,104,96,150,8,1,
+	59,52,40,9,212,156,16,0,229,43,152,92,44,170,10,84,
+	15,1,4,16,146,135,162,128,217,66,0,152,153,128,41,137,
+	29,228,166,240,248,200,196,80,118,96,246,79,4,58,20,148,
+	253,65,210,64,144,12,52,59,37,30,232,233,48,160,72,50,
+	82,146,3,137,0,195,33,60,4,197,67,246,160,242,218,22,
+	234,27,113,113,79,79,9,78,173,108,63,107,184,135,66,216,
+	129,5,111,72,180,95,172,0,144,6,22,75,209,65,169,192,
+	148,155,26,20,23,14,241,80,80,120,24,176,66,13,2,149,
+	87,177,193,65,225,32,175,163,168,136,12,10,2,86,73,209,
+	193,96,67,252,252,0,2,8,201,67,225,193,241,241,192,226,
+	141,29,72,135,131,180,3,139,4,191,248,208,68,144,158,208,
+	224,80,129,152,68,246,208,80,144,251,195,194,227,227,227,129,
+	229,88,112,40,80,97,40,212,71,193,225,236,64,53,224,8,
+	12,247,67,246,16,216,63,89,16,223,0,61,35,33,161,170,
+	170,234,102,236,231,103,109,5,143,30,16,96,143,6,87,55,
+	65,169,160,198,29,16,196,1,253,144,4,41,229,32,92,184,
+	210,96,36,21,113,160,120,5,177,253,64,165,10,56,142,0,
+	2,8,238,161,132,208,152,144,4,112,226,143,98,128,208,137,
+	192,162,32,17,82,29,135,165,128,252,5,76,105,96,46,80,
+	33,36,12,66,98,18,33,34,64,133,49,137,9,64,102,100,
+	88,76,120,36,178,135,192,254,177,1,165,52,160,111,84,193,
+	128,137,137,73,28,232,35,54,72,227,14,220,24,0,34,191,
+	176,144,48,16,19,228,240,224,224,72,96,140,65,154,2,65,
+	17,97,2,32,46,180,165,0,105,43,32,169,136,6,137,133,
+	1,117,131,41,63,63,128,0,130,121,8,88,76,39,135,81,
+	220,214,9,11,77,102,15,143,65,242,16,200,63,57,238,226,
+	192,148,6,142,26,38,24,240,52,78,35,178,247,0,43,203,
+	136,5,0,1,4,243,80,20,3,3,67,2,229,173,183,148,
+	96,129,68,164,150,130,189,25,144,212,148,64,245,12,196,71,
+	26,68,13,52,178,167,130,90,226,164,244,156,0,2,136,166,
+	141,83,176,127,208,129,93,14,8,102,19,53,136,149,198,30,
+	17,28,28,193,78,138,157,0,1,68,223,238,3,29,0,64,
+	128,1,0,130,19,32,31,170,173,135,150,0,0,0,0,73,
+	69,78,68,174,66,96,130,
+
+};
+
+#include &lt;gtkmm/box.h&gt;
+
+aboutDialog_glade::aboutDialog_glade(
+)
+{  aboutDialog = this;
+   gmm_data = new GlademmData(get_accel_group());
+   closebutton1 = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-close&quot;)));
+   
+   Glib::RefPtr&lt;Gdk::PixbufLoader&gt; _pinotImage_loader=Gdk::PixbufLoader::create();
+   _pinotImage_loader-&gt;write(pinot_png_data, sizeof pinot_png_data);
+   _pinotImage_loader-&gt;close();
+   
+   Gtk::Image *pinotImage = Gtk::manage(new class Gtk::Image(_pinotImage_loader-&gt;get_pixbuf()));
+   _pinotImage_loader=Glib::RefPtr&lt;Gdk::PixbufLoader&gt;();
+   nameLabel = Gtk::manage(new class Gtk::Label(_(&quot;Pinot&quot;)));
+   
+   Gtk::Label *descriptionLabel = Gtk::manage(new class Gtk::Label(_(&quot;A metasearch tool for the Free Desktop.&quot;)));
+   Gtk::Label *copyrightLabel = Gtk::manage(new class Gtk::Label(_(&quot;Copyright (C) 2005 Fabrice Colin&quot;)));
+   Glib::RefPtr&lt;Gdk::PixbufLoader&gt; _xapianImage_loader=Gdk::PixbufLoader::create();
+   _xapianImage_loader-&gt;write(xapian_powered_png_data, sizeof xapian_powered_png_data);
+   _xapianImage_loader-&gt;close();
+   
+   Gtk::Image *xapianImage = Gtk::manage(new class Gtk::Image(_xapianImage_loader-&gt;get_pixbuf()));
+   _xapianImage_loader=Glib::RefPtr&lt;Gdk::PixbufLoader&gt;();
+   
+   Gtk::VBox *aboutVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   closebutton1-&gt;set_flags(Gtk::CAN_FOCUS);
+   closebutton1-&gt;set_flags(Gtk::CAN_DEFAULT);
+   closebutton1-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   aboutDialog-&gt;get_action_area()-&gt;property_layout_style().set_value(Gtk::BUTTONBOX_END);
+   pinotImage-&gt;set_alignment(0.5,0.5);
+   pinotImage-&gt;set_padding(0,0);
+   nameLabel-&gt;set_alignment(0.5,0.5);
+   nameLabel-&gt;set_padding(4,4);
+   nameLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   nameLabel-&gt;set_line_wrap(false);
+   nameLabel-&gt;set_use_markup(false);
+   nameLabel-&gt;set_selectable(false);
+   descriptionLabel-&gt;set_alignment(0.5,0.5);
+   descriptionLabel-&gt;set_padding(4,4);
+   descriptionLabel-&gt;set_justify(Gtk::JUSTIFY_CENTER);
+   descriptionLabel-&gt;set_line_wrap(true);
+   descriptionLabel-&gt;set_use_markup(false);
+   descriptionLabel-&gt;set_selectable(false);
+   copyrightLabel-&gt;set_alignment(0.5,0.5);
+   copyrightLabel-&gt;set_padding(4,4);
+   copyrightLabel-&gt;set_justify(Gtk::JUSTIFY_CENTER);
+   copyrightLabel-&gt;set_line_wrap(false);
+   copyrightLabel-&gt;set_use_markup(false);
+   copyrightLabel-&gt;set_selectable(false);
+   xapianImage-&gt;set_alignment(0.5,0.5);
+   xapianImage-&gt;set_padding(0,0);
+   aboutVbox-&gt;pack_start(*pinotImage);
+   aboutVbox-&gt;pack_start(*nameLabel, Gtk::PACK_SHRINK, 0);
+   aboutVbox-&gt;pack_start(*descriptionLabel, Gtk::PACK_SHRINK, 0);
+   aboutVbox-&gt;pack_start(*copyrightLabel, Gtk::PACK_SHRINK, 0);
+   aboutVbox-&gt;pack_start(*xapianImage);
+   aboutDialog-&gt;get_vbox()-&gt;set_homogeneous(false);
+   aboutDialog-&gt;get_vbox()-&gt;set_spacing(0);
+   aboutDialog-&gt;get_vbox()-&gt;pack_start(*aboutVbox, Gtk::PACK_SHRINK, 0);
+   aboutDialog-&gt;set_title(_(&quot;About Pinot&quot;));
+   aboutDialog-&gt;set_modal(false);
+   aboutDialog-&gt;property_window_position().set_value(Gtk::WIN_POS_NONE);
+   aboutDialog-&gt;set_resizable(false);
+   aboutDialog-&gt;property_destroy_with_parent().set_value(false);
+   aboutDialog-&gt;set_has_separator(true);
+   aboutDialog-&gt;add_action_widget(*closebutton1, -7);
+   closebutton1-&gt;show();
+   pinotImage-&gt;show();
+   nameLabel-&gt;show();
+   descriptionLabel-&gt;show();
+   copyrightLabel-&gt;show();
+   xapianImage-&gt;show();
+   aboutVbox-&gt;show();
+   aboutDialog-&gt;show();
+}
+
+aboutDialog_glade::~aboutDialog_glade()
+{  delete gmm_data;
+}


Property changes on: trunk/UI/GTK2/src/aboutDialog_glade.cc
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/aboutDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/aboutDialog_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/aboutDialog_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,52 @@
+// generated 2004/7/24 17:45:26 BST by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0_cvs
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.4.0 and gtkmm 2.2.12
+//
+// Please modify the corresponding derived classes in ./src/aboutDialog.hh and./src/aboutDialog.cc
+
+#ifndef _ABOUTDIALOG_GLADE_HH
+#  define _ABOUTDIALOG_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include &lt;gtkmm/accelgroup.h&gt;
+
+class GlademmData
+{  
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt; accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr&lt;Gtk::AccelGroup&gt; ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt;  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include &lt;gtkmm/dialog.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/label.h&gt;
+
+class aboutDialog_glade : public Gtk::Dialog
+{  
+        
+        GlademmData *gmm_data;
+public:
+        class Gtk::Dialog * aboutDialog;
+protected:
+        class Gtk::Button * closebutton1;
+        class Gtk::Label * nameLabel;
+        
+        aboutDialog_glade();
+        
+        ~aboutDialog_glade();
+};
+#endif


Property changes on: trunk/UI/GTK2/src/aboutDialog_glade.hh
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/importDialog.cc
===================================================================
--- trunk/UI/GTK2/src/importDialog.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/importDialog.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,324 @@
+// generated 2004/3/6 14:15:21 GMT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to importDialog.cc_new
+
+// This file is for your program, I won't touch it again!
+
+#include &lt;stdlib.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;dirent.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+#include &lt;glibmm/convert.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;MIMEScanner.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;importDialog.hh&quot;
+
+using namespace std;
+using namespace SigC;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+string importDialog::m_directory = &quot;&quot;;
+
+importDialog::importDialog(const Glib::ustring &amp;title,
+	bool selectTitle, bool selectDepth, bool allowLocalOnly) :
+	importDialog_glade(),
+	m_docsCount(0),
+	m_importDirectory(false),
+	m_maxDirLevel(1)
+{
+	// Associate the columns model to the type combo
+	m_refTypeList = ListStore::create(m_typeColumns);
+	typeCombobox-&gt;set_model(m_refTypeList);
+	typeCombobox-&gt;pack_start(m_typeColumns.m_name);
+	// Populate
+	populate_combobox(allowLocalOnly);
+
+	// Initialize the default directory
+	if (m_directory.empty() == true)
+	{
+		char *homeDir = getenv(&quot;HOME&quot;);
+		if (homeDir != NULL)
+		{
+			m_directory = homeDir + string(&quot;/&quot;);
+		}
+	}
+
+	set_title(title);
+
+	if (selectTitle == false)
+	{
+		titleLabel-&gt;hide();
+		titleEntry-&gt;hide();
+	}
+
+	if (selectDepth == false)
+	{
+		depthLabel-&gt;hide();
+		depthSpinbutton-&gt;hide();
+	}
+	else
+	{
+		// The default type is not directory
+		// FIXME: this could also apply to URLs !
+		depthSpinbutton-&gt;set_sensitive(false);
+		depthSpinbutton-&gt;set_value(m_maxDirLevel);
+	}
+
+	// Disable the OK button as long the location entry field is empty
+	// The title field may remain empty
+	importOkButton-&gt;set_sensitive(false);
+}
+
+importDialog::~importDialog()
+{
+}
+
+void importDialog::populate_combobox(bool allowLocalOnly)
+{
+	bool foundLanguage = false;
+
+	TreeModel::iterator iter = m_refTypeList-&gt;append();
+	TreeModel::Row row = *iter;
+	row[m_typeColumns.m_name] = _(&quot;Single file&quot;);
+	iter = m_refTypeList-&gt;append();
+	row = *iter;
+	row[m_typeColumns.m_name] = _(&quot;Whole directory&quot;);
+	if (allowLocalOnly == false)
+	{
+		iter = m_refTypeList-&gt;append();
+		row = *iter;
+		row[m_typeColumns.m_name] = _(&quot;URL&quot;);
+	}
+
+	typeCombobox-&gt;set_active(0);
+}
+
+void importDialog::scan_file(const string &amp;fileName, unsigned int &amp;level)
+{
+	struct stat fileStat;
+	Url urlObj(&quot;<A HREF="file://">file://</A>&quot; + fileName);
+
+	if ((fileName.empty() == true) ||
+		(urlObj.getFile() == &quot;.&quot;) ||
+		(urlObj.getFile() == &quot;..&quot;))
+	{
+		return;
+	}
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;importDialog::scan_file: &quot; &lt;&lt; fileName &lt;&lt; endl;
+#endif
+	if (lstat(fileName.c_str(), &amp;fileStat) == -1)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;importDialog::scan_file: stat failed&quot; &lt;&lt; endl;
+#endif
+		return;
+	}
+
+	// Is it a file or a directory ?
+	if (S_ISLNK(fileStat.st_mode))
+	{
+		cout &lt;&lt; &quot;importDialog::scan_file: skipping symlink&quot; &lt;&lt; endl;
+		return;
+	}
+	else if (S_ISDIR(fileStat.st_mode))
+	{
+		// A directory : scan it
+		DIR *pDir = opendir(fileName.c_str());
+		if (pDir == NULL)
+		{
+			return;
+		}
+
+		// Iterate through this directory's entries
+		struct dirent *pDirEntry = readdir(pDir);
+		while (pDirEntry != NULL)
+		{
+			char *pEntryName = pDirEntry-&gt;d_name;
+			if (pEntryName != NULL)
+			{
+				string location = fileName;
+				location += &quot;/&quot;;
+				location += pEntryName;
+
+				// Scan this entry
+				if ((m_maxDirLevel == 0) ||
+					(level &lt; m_maxDirLevel))
+				{
+					++level;
+					scan_file(location, level);
+					--level;
+				}
+#ifdef DEBUG
+				else cout &lt;&lt; &quot;importDialog::scan_file: not going deeper than level &quot; &lt;&lt; level &lt;&lt; endl;
+#endif
+			}
+
+			// Next entry
+			pDirEntry = readdir(pDir);
+		}
+		closedir(pDir);
+	}
+	else	if (S_ISREG(fileStat.st_mode))
+	{
+		// Get the MIME type
+		string mimeType = MIMEScanner::scanFile(fileName);
+		// Build a valid URL
+		string location = &quot;<A HREF="file://">file://</A>&quot;;
+		location += fileName;
+		string title = locale_from_utf8(m_title);
+
+		if (m_importDirectory == true)
+		{
+			title += &quot; &quot;;
+			title += urlObj.getFile();
+		}
+
+		// Fire up the signal
+		m_signalImportFile(DocumentInfo(title, location, mimeType, &quot;&quot;));
+		++m_docsCount;
+	}
+}
+
+ustring importDialog::getDocumentTitle(void)
+{
+	return m_title;
+}
+
+unsigned int importDialog::getDocumentsCount(void)
+{
+	return m_docsCount;
+}
+
+Signal1&lt;void, DocumentInfo&gt; &amp;importDialog::getImportFileSignal(void)
+{
+	return m_signalImportFile;
+}
+
+void importDialog::on_importOkButton_clicked()
+{
+	string location = locale_from_utf8(locationEntry-&gt;get_text());
+	unsigned int level = 0;
+
+	// Title
+	m_title = titleEntry-&gt;get_text();
+	// Type
+	if (typeCombobox-&gt;get_active_row_number() &lt;= 1)
+	{
+		string::size_type pos = location.find_last_of(&quot;/&quot;);
+		if (pos != string::npos)
+		{
+			// Update m_directory
+			m_directory = location.substr(0, pos + 1);
+#ifdef DEBUG
+			cout &lt;&lt; &quot;importDialog::on_importOkButton_clicked: directory now &quot; &lt;&lt; m_directory &lt;&lt; endl;
+#endif
+		}
+
+		// Maximum depth
+		m_maxDirLevel = (unsigned int)depthSpinbutton-&gt;get_value();
+
+		scan_file(location, level);
+	}
+	else
+	{
+		Url urlObj(location);
+
+		// Signal now
+		m_signalImportFile(DocumentInfo(locale_from_utf8(m_title), location,
+			MIMEScanner::scanUrl(urlObj), &quot;&quot;));
+		++m_docsCount;
+	}
+}
+
+void importDialog::on_selectButton_clicked()
+{
+	ustring fileName = locale_to_utf8(m_directory);
+
+	if (select_file_name(*this, _(&quot;Document To Import&quot;), fileName, true, m_importDirectory) == true)
+	{
+		// Update the location
+#ifdef DEBUG
+		cout &lt;&lt; &quot;importDialog::on_selectButton_clicked: location is &quot; &lt;&lt; fileName &lt;&lt; endl;
+#endif
+		locationEntry-&gt;set_text(fileName);
+		ustring::size_type pos = fileName.find_last_of(&quot;/&quot;);
+		if (pos != string::npos)
+		{
+			// Update m_directory
+		m_directory = locale_from_utf8(fileName.substr(0, pos + 1));
+#ifdef DEBUG
+		cout &lt;&lt; &quot;importDialog::on_selectButton_clicked: directory now &quot; &lt;&lt; m_directory &lt;&lt; endl;
+#endif
+		}
+	}
+}
+
+void importDialog::on_locationEntry_changed()
+{
+	ustring fileName = locationEntry-&gt;get_text();
+	bool enableOk = true;
+
+	if (fileName.empty() == false)
+	{
+		unsigned int type = typeCombobox-&gt;get_active_row_number();
+
+		// Check the entry makes sense
+		if (type &lt;= 1)
+		{
+			if (fileName[0] != '/')
+			{
+				enableOk = false;
+			}
+		}
+		else
+		{
+			Url urlObj(locale_from_utf8(fileName));
+
+			// Check the URL is valid
+			if (urlObj.getProtocol().empty() == true)
+			{
+				enableOk = false;
+			}
+			// FIXME: be more thorough
+		}
+	}
+	else
+	{
+		enableOk = false;
+	}
+
+	importOkButton-&gt;set_sensitive(enableOk);
+}
+
+void importDialog::on_typeCombobox_changed()
+{
+	unsigned int type = typeCombobox-&gt;get_active_row_number();
+	bool selectLocation = true;
+
+	m_importDirectory = false;
+	if (type == 1)
+	{
+		m_importDirectory = true;
+	}
+	else if (type &gt; 1)
+	{
+		// Disable the select button only if type is URL
+		selectLocation = false;
+	}
+
+	// FIXME: this could also apply to URLs !
+	depthSpinbutton-&gt;set_sensitive(m_importDirectory);
+	selectButton-&gt;set_sensitive(selectLocation);
+}

Added: trunk/UI/GTK2/src/importDialog.hh
===================================================================
--- trunk/UI/GTK2/src/importDialog.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/importDialog.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,63 @@
+// generated 2004/3/6 14:15:21 GMT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to importDialog.hh_new
+
+// you might replace
+//    class foo : public foo_glade { ... };
+// by
+//    typedef foo_glade foo;
+// if you didn't make any modifications to the widget
+
+#ifndef _IMPORTDIALOG_HH
+#define _IMPORTDIALOG_HH
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;sigc++/slot.h&gt;
+#include &lt;glibmm/refptr.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gtkmm/liststore.h&gt;
+
+#include &quot;DocumentInfo.h&quot;
+#include &quot;ModelColumns.h&quot;
+#include &quot;importDialog_glade.hh&quot;
+
+class importDialog : public importDialog_glade
+{  
+public:
+	/// Open the dialog box in import mode.
+	importDialog(const Glib::ustring &amp;title,
+		bool selectTitle = true, bool selectDepth = true,
+		bool allowLocalOnly = false);
+	virtual ~importDialog();
+
+	Glib::ustring getDocumentTitle(void);
+
+	unsigned int getDocumentsCount(void);
+
+	/// Returns the import file signal.
+	SigC::Signal1&lt;void, DocumentInfo&gt;&amp; getImportFileSignal(void);
+
+protected:
+	void populate_combobox(bool allowLocalOnly);
+	void scan_file(const std::string &amp;fileName, unsigned int &amp;level);
+
+private:
+	ComboModelColumns m_typeColumns;
+	Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTypeList;
+	Glib::ustring m_title;
+	unsigned int m_docsCount;
+	bool m_importDirectory;
+	unsigned int m_maxDirLevel;
+	SigC::Signal1&lt;void, DocumentInfo&gt; m_signalImportFile;
+	static std::string m_directory;
+
+	virtual void on_importOkButton_clicked();
+	virtual void on_selectButton_clicked();
+	virtual void on_locationEntry_changed();
+	virtual void on_typeCombobox_changed();
+
+};
+
+#endif

Added: trunk/UI/GTK2/src/importDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/importDialog_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/importDialog_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,197 @@
+// generated 2005/11/6 16:43:41 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/importDialog.cc
+
+
+#if defined __GNUC__ &amp;&amp; __GNUC__ &lt; 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include &quot;config.h&quot;
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include &lt;libintl.h&gt;
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include &lt;gtkmmconfig.h&gt;
+#if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
+#include &lt;sigc++/compatibility.h&gt;
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include &quot;importDialog_glade.hh&quot;
+#include &lt;gdk/gdkkeysyms.h&gt;
+#include &lt;gtkmm/accelgroup.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/buttonbox.h&gt;
+#include &lt;gtkmm/image.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/alignment.h&gt;
+#include &lt;gtkmm/adjustment.h&gt;
+
+importDialog_glade::importDialog_glade(
+)
+{  importDialog = this;
+   gmm_data = new GlademmData(get_accel_group());
+   
+   Gtk::Button *cancelbutton1 = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-cancel&quot;)));
+   importOkButton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-ok&quot;)));
+   
+   Gtk::Image *image180 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-open&quot;), Gtk::IconSize(4)));
+   Gtk::Label *label17 = Gtk::manage(new class Gtk::Label(_(&quot;Select&quot;)));
+   Gtk::HBox *hbox14 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment9 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
+   selectButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::HButtonBox *hbuttonbox3 = Gtk::manage(new class Gtk::HButtonBox(Gtk::BUTTONBOX_DEFAULT_STYLE, 0));
+   locationEntry = Gtk::manage(new class Gtk::Entry());
+   titleEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Label *locationLabel = Gtk::manage(new class Gtk::Label(_(&quot;Location:&quot;)));
+   titleLabel = Gtk::manage(new class Gtk::Label(_(&quot;Title:&quot;)));
+   depthLabel = Gtk::manage(new class Gtk::Label(_(&quot;Maximum depth:&quot;)));
+   
+   Gtk::Adjustment *depthSpinbutton_adj = Gtk::manage(new class Gtk::Adjustment(0, 0, 100, 1, 5, 5));
+   depthSpinbutton = Gtk::manage(new class Gtk::SpinButton(*depthSpinbutton_adj, 1, 0));
+   typeCombobox = Gtk::manage(new class Gtk::ComboBox());
+   
+   Gtk::Label *typeLabel = Gtk::manage(new class Gtk::Label(_(&quot;Type:&quot;)));
+   docTable = Gtk::manage(new class Gtk::Table(2, 2, false));
+   cancelbutton1-&gt;set_flags(Gtk::CAN_FOCUS);
+   cancelbutton1-&gt;set_flags(Gtk::CAN_DEFAULT);
+   cancelbutton1-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   importOkButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   importOkButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   importOkButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   importDialog-&gt;get_action_area()-&gt;property_layout_style().set_value(Gtk::BUTTONBOX_END);
+   image180-&gt;set_alignment(0.5,0.5);
+   image180-&gt;set_padding(0,0);
+   label17-&gt;set_alignment(0.5,0.5);
+   label17-&gt;set_padding(0,0);
+   label17-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   label17-&gt;set_line_wrap(false);
+   label17-&gt;set_use_markup(false);
+   label17-&gt;set_selectable(false);
+   hbox14-&gt;pack_start(*image180, Gtk::PACK_SHRINK, 0);
+   hbox14-&gt;pack_start(*label17, Gtk::PACK_SHRINK, 0);
+   alignment9-&gt;add(*hbox14);
+   selectButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   selectButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   selectButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   selectButton-&gt;add(*alignment9);
+   hbuttonbox3-&gt;pack_start(*selectButton);
+   locationEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   locationEntry-&gt;set_visibility(true);
+   locationEntry-&gt;set_editable(true);
+   locationEntry-&gt;set_max_length(0);
+   locationEntry-&gt;set_text(_(&quot;&quot;));
+   locationEntry-&gt;set_has_frame(true);
+   locationEntry-&gt;set_activates_default(false);
+   titleEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   titleEntry-&gt;set_visibility(true);
+   titleEntry-&gt;set_editable(true);
+   titleEntry-&gt;set_max_length(0);
+   titleEntry-&gt;set_text(_(&quot;&quot;));
+   titleEntry-&gt;set_has_frame(true);
+   titleEntry-&gt;set_activates_default(false);
+   locationLabel-&gt;set_alignment(0,0.5);
+   locationLabel-&gt;set_padding(4,4);
+   locationLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   locationLabel-&gt;set_line_wrap(false);
+   locationLabel-&gt;set_use_markup(false);
+   locationLabel-&gt;set_selectable(false);
+   titleLabel-&gt;set_alignment(0,0.5);
+   titleLabel-&gt;set_padding(4,4);
+   titleLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   titleLabel-&gt;set_line_wrap(false);
+   titleLabel-&gt;set_use_markup(false);
+   titleLabel-&gt;set_selectable(false);
+   depthLabel-&gt;set_alignment(0,0.5);
+   depthLabel-&gt;set_padding(4,4);
+   depthLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   depthLabel-&gt;set_line_wrap(false);
+   depthLabel-&gt;set_use_markup(false);
+   depthLabel-&gt;set_selectable(false);
+   depthSpinbutton-&gt;set_flags(Gtk::CAN_FOCUS);
+   depthSpinbutton-&gt;set_update_policy(Gtk::UPDATE_ALWAYS);
+   depthSpinbutton-&gt;set_numeric(false);
+   depthSpinbutton-&gt;set_digits(0);
+   depthSpinbutton-&gt;set_wrap(false);
+   typeLabel-&gt;set_alignment(0,0.5);
+   typeLabel-&gt;set_padding(4,4);
+   typeLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   typeLabel-&gt;set_line_wrap(false);
+   typeLabel-&gt;set_use_markup(false);
+   typeLabel-&gt;set_selectable(false);
+   docTable-&gt;set_row_spacings(0);
+   docTable-&gt;set_col_spacings(0);
+   docTable-&gt;attach(*hbuttonbox3, 2, 3, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   docTable-&gt;attach(*locationEntry, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   docTable-&gt;attach(*titleEntry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   docTable-&gt;attach(*locationLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   docTable-&gt;attach(*titleLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   docTable-&gt;attach(*depthLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
+   docTable-&gt;attach(*depthSpinbutton, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   docTable-&gt;attach(*typeCombobox, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   docTable-&gt;attach(*typeLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   importDialog-&gt;get_vbox()-&gt;set_homogeneous(false);
+   importDialog-&gt;get_vbox()-&gt;set_spacing(0);
+   importDialog-&gt;get_vbox()-&gt;pack_start(*docTable);
+   importDialog-&gt;set_title(_(&quot;Import document&quot;));
+   importDialog-&gt;set_modal(false);
+   importDialog-&gt;property_window_position().set_value(Gtk::WIN_POS_NONE);
+   importDialog-&gt;set_resizable(true);
+   importDialog-&gt;property_destroy_with_parent().set_value(false);
+   importDialog-&gt;set_has_separator(true);
+   importDialog-&gt;add_action_widget(*cancelbutton1, -6);
+   importDialog-&gt;add_action_widget(*importOkButton, -5);
+   cancelbutton1-&gt;show();
+   importOkButton-&gt;show();
+   image180-&gt;show();
+   label17-&gt;show();
+   hbox14-&gt;show();
+   alignment9-&gt;show();
+   selectButton-&gt;show();
+   hbuttonbox3-&gt;show();
+   locationEntry-&gt;show();
+   titleEntry-&gt;show();
+   locationLabel-&gt;show();
+   titleLabel-&gt;show();
+   depthLabel-&gt;show();
+   depthSpinbutton-&gt;show();
+   typeCombobox-&gt;show();
+   typeLabel-&gt;show();
+   docTable-&gt;show();
+   importDialog-&gt;show();
+   importOkButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;importDialog_glade::on_importOkButton_clicked), false);
+   selectButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;importDialog_glade::on_selectButton_clicked), false);
+   locationEntry-&gt;signal_changed().connect(SigC::slot(*this, &amp;importDialog_glade::on_locationEntry_changed), false);
+   typeCombobox-&gt;signal_changed().connect(SigC::slot(*this, &amp;importDialog_glade::on_typeCombobox_changed), false);
+}
+
+importDialog_glade::~importDialog_glade()
+{  delete gmm_data;
+}

Added: trunk/UI/GTK2/src/importDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/importDialog_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/importDialog_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,68 @@
+// generated 2005/11/6 16:25:47 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/importDialog.hh and./src/importDialog.cc
+
+#ifndef _IMPORTDIALOG_GLADE_HH
+#  define _IMPORTDIALOG_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include &lt;gtkmm/accelgroup.h&gt;
+
+class GlademmData
+{  
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt; accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr&lt;Gtk::AccelGroup&gt; ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt;  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include &lt;gtkmm/dialog.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/entry.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/spinbutton.h&gt;
+#include &lt;gtkmm/combobox.h&gt;
+#include &lt;gtkmm/table.h&gt;
+
+class importDialog_glade : public Gtk::Dialog
+{  
+        
+        GlademmData *gmm_data;
+public:
+        class Gtk::Dialog * importDialog;
+protected:
+        class Gtk::Button * importOkButton;
+        class Gtk::Button * selectButton;
+        class Gtk::Entry * locationEntry;
+        class Gtk::Entry * titleEntry;
+        class Gtk::Label * titleLabel;
+        class Gtk::Label * depthLabel;
+        class Gtk::SpinButton * depthSpinbutton;
+        class Gtk::ComboBox * typeCombobox;
+        class Gtk::Table * docTable;
+        
+        importDialog_glade();
+        
+        ~importDialog_glade();
+private:
+        virtual void on_importOkButton_clicked() = 0;
+        virtual void on_selectButton_clicked() = 0;
+        virtual void on_locationEntry_changed() = 0;
+        virtual void on_typeCombobox_changed() = 0;
+};
+#endif

Added: trunk/UI/GTK2/src/indexDialog.cc
===================================================================
--- trunk/UI/GTK2/src/indexDialog.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/indexDialog.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,243 @@
+// generated 2005/2/14 18:45:02 GMT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// newer (non customized) versions of this file go to indexDialog.cc_new
+
+// This file is for your program, I won't touch it again!
+
+#include &lt;iostream&gt;
+
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;indexDialog.hh&quot;
+
+using namespace std;
+using namespace Glib;
+using namespace Gtk;
+
+indexDialog::indexDialog() :
+	indexDialog_glade(),
+	m_editIndex(false),
+	m_badName(true)
+{
+	// Associate the columns model to the type combo
+	m_refTypeTree = ListStore::create(m_typeColumns);
+	typeCombobox-&gt;set_model(m_refTypeTree);
+	typeCombobox-&gt;pack_start(m_typeColumns.m_name);
+	// Populate
+	populate_typeCombobox();
+
+	// By default, type is set to local
+	typeCombobox-&gt;set_active(0);
+	portSpinbutton-&gt;set_sensitive(false);
+	// ...and both name and location are empty
+	indexOkbutton-&gt;set_sensitive(false);
+}
+
+indexDialog::indexDialog(const ustring &amp;name, const ustring &amp;location) :
+	indexDialog_glade(),
+	m_name(name),
+	m_location(location),
+	m_editIndex(false),
+	m_badName(true)
+{
+	ustring dirName = location;
+	unsigned int port = 1024;
+
+	// Associate the columns model to the type combo
+	m_refTypeTree = ListStore::create(m_typeColumns);
+	typeCombobox-&gt;set_model(m_refTypeTree);
+	typeCombobox-&gt;pack_start(m_typeColumns.m_name);
+	// Populate
+	populate_typeCombobox();
+
+	// Name
+	nameEntry-&gt;set_text(name);
+
+	// Type and location
+	ustring::size_type colonPos = location.find(&quot;:&quot;);
+	if ((location[0] != '/') &amp;&amp;
+		(colonPos != ustring::npos))
+	{
+		// This is a remote index
+		dirName = location.substr(0, colonPos);
+		port = (unsigned int)atoi(location.substr(colonPos + 1).c_str());
+
+		typeCombobox-&gt;set_active(1);
+		locationButton-&gt;set_sensitive(false);
+
+		// Port
+		portSpinbutton-&gt;set_value((double)port);
+	}
+	else
+	{
+		typeCombobox-&gt;set_active(0);
+		portSpinbutton-&gt;set_sensitive(false);
+	}
+	locationEntry-&gt;set_text(dirName);
+
+	m_editIndex = true;
+}
+
+indexDialog::~indexDialog()
+{
+}
+
+void indexDialog::populate_typeCombobox(void)
+{
+	TreeModel::iterator iter = m_refTypeTree-&gt;append();
+	TreeModel::Row row = *iter;
+	row[m_typeColumns.m_name] = &quot;Local&quot;;
+	iter = m_refTypeTree-&gt;append();
+	row = *iter;
+	row[m_typeColumns.m_name] = &quot;Remote&quot;;
+}
+
+void indexDialog::checkFields(void)
+{
+	bool enableOkButton = false;
+
+	ustring name = nameEntry-&gt;get_text();
+	ustring location = locationEntry-&gt;get_text();
+	if ((name.empty() == false) &amp;&amp;
+		(location.empty() == false))
+	{
+		bool startsWithSlash = false, isLocal = false;
+
+		if (location[0] == '/')
+		{
+			startsWithSlash = true;
+		}
+
+		if (typeCombobox-&gt;get_active_row_number() == 0)
+		{
+			isLocal = true;
+		}
+
+		// Disable the OK button if the type+location pair doesn't make sense
+		if (startsWithSlash == isLocal)
+		{
+			enableOkButton = true;
+		}
+	}
+
+	indexOkbutton-&gt;set_sensitive(enableOkButton);
+}
+
+bool indexDialog::badName(void) const
+{
+	return m_badName;
+}
+
+ustring indexDialog::getName(void) const
+{
+	return m_name;
+}
+
+ustring indexDialog::getLocation(void) const
+{
+	return m_location;
+}
+
+void indexDialog::on_indexOkbutton_clicked()
+{
+	PinotSettings &amp;settings = PinotSettings::getInstance();
+
+	// The changed() methods ensure name and location are set
+	ustring name = nameEntry-&gt;get_text();
+	ustring location = locationEntry-&gt;get_text();
+	m_badName = false;
+
+	// Is it a remote index ?
+	if (typeCombobox-&gt;get_active_row_number() == 1)
+	{
+		char portStr[64];
+		int port = portSpinbutton-&gt;get_value_as_int();
+		snprintf(portStr, 64, &quot;%d&quot;, port);
+
+		// Append the port number
+		location += &quot;:&quot;;
+		location += portStr;
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;indexDialog::on_indexOkbutton_clicked: &quot; &lt;&lt; name &lt;&lt; &quot;, &quot; &lt;&lt; location &lt;&lt; endl;
+#endif
+
+	// Look up that index name in the map
+	const std::map&lt;string, string&gt; &amp;indexesMap = settings.getIndexes();
+	std::map&lt;string, string&gt;::const_iterator indexIter = indexesMap.find(locale_from_utf8(name));
+	if (indexIter != indexesMap.end())
+	{
+		// This name is in use
+		m_badName = true;
+#ifdef DEBUG
+		cout &lt;&lt; &quot;indexDialog::on_indexOkbutton_clicked: name in use&quot; &lt;&lt; endl;
+#endif
+	}
+
+	if ((m_editIndex == true) &amp;&amp;
+		(name == m_name))
+	{
+		// ... but that's okay, because it's the original name
+		m_badName = false;
+#ifdef DEBUG
+		cout &lt;&lt; &quot;indexDialog::on_indexOkbutton_clicked: old name&quot; &lt;&lt; endl;
+#endif
+	}
+
+	m_name = name;
+	m_location = location;
+}
+
+void indexDialog::on_locationEntry_changed()
+{
+	checkFields();
+}
+
+void indexDialog::on_locationButton_clicked()
+{
+	ustring dirName = locationEntry-&gt;get_text();
+	if (select_file_name(*this, _(&quot;Index location&quot;), dirName, true, true) == true)
+	{
+		locationEntry-&gt;set_text(dirName);
+	}
+}
+
+void indexDialog::on_typeCombobox_changed()
+{
+	bool startsWithSlash = false, isLocal = false;
+
+	ustring location = locationEntry-&gt;get_text();
+	if ((location.empty() == false) &amp;&amp;
+		(location[0] == '/'))
+	{
+		startsWithSlash = true;
+	}
+
+	// Enable the browser entry field and button only if browsing is enabled
+	if (typeCombobox-&gt;get_active_row_number() == 1)
+	{
+		// Remote index
+		portSpinbutton-&gt;set_sensitive(true);
+		locationButton-&gt;set_sensitive(false);
+	}
+	else
+	{
+		// Local index
+		portSpinbutton-&gt;set_sensitive(false);
+		locationButton-&gt;set_sensitive(true);
+		isLocal = true;
+	}
+
+	if (startsWithSlash != isLocal)
+	{
+		indexOkbutton-&gt;set_sensitive(false);
+	}
+}
+
+void indexDialog::on_nameEntry_changed()
+{
+	checkFields();
+}

Added: trunk/UI/GTK2/src/indexDialog.hh
===================================================================
--- trunk/UI/GTK2/src/indexDialog.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/indexDialog.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,52 @@
+// generated 2005/2/14 18:45:02 GMT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// newer (non customized) versions of this file go to indexDialog.hh_new
+
+// you might replace
+//    class foo : public foo_glade { ... };
+// by
+//    typedef foo_glade foo;
+// if you didn't make any modifications to the widget
+
+#ifndef _INDEXDIALOG_HH
+#define _INDEXDIALOG_HH
+
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gtkmm/liststore.h&gt;
+
+#include &quot;ModelColumns.h&quot;
+#include &quot;indexDialog_glade.hh&quot;
+
+class indexDialog : public indexDialog_glade
+{  
+public:
+	indexDialog();
+	indexDialog(const Glib::ustring &amp;name, const Glib::ustring &amp;location);
+	virtual ~indexDialog();
+
+	bool badName(void) const;
+
+	Glib::ustring getName(void) const;
+
+	Glib::ustring getLocation(void) const;
+
+protected:
+	Glib::ustring m_name;
+	Glib::ustring m_location;
+	ComboModelColumns m_typeColumns;
+	Glib::RefPtr&lt;Gtk::ListStore&gt; m_refTypeTree;
+	bool m_editIndex;
+	bool m_badName;
+
+	void populate_typeCombobox(void);
+	void checkFields(void);
+
+	virtual void on_indexOkbutton_clicked();
+	virtual void on_locationEntry_changed();
+	virtual void on_locationButton_clicked();
+	virtual void on_typeCombobox_changed();
+	virtual void on_nameEntry_changed();
+
+};
+#endif

Added: trunk/UI/GTK2/src/indexDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/indexDialog_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/indexDialog_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,176 @@
+// generated 2005/4/17 5:19:13 BST by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at thorgrim.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.4.0 and gtkmm 2.4.8
+//
+// Please modify the corresponding derived classes in ./src/indexDialog.cc
+
+
+#if defined __GNUC__ &amp;&amp; __GNUC__ &lt; 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include &quot;config.h&quot;
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include &lt;libintl.h&gt;
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include &lt;gtkmmconfig.h&gt;
+#if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
+#include &lt;sigc++/compatibility.h&gt;
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include &quot;indexDialog_glade.hh&quot;
+#include &lt;gdk/gdkkeysyms.h&gt;
+#include &lt;gtkmm/accelgroup.h&gt;
+#include &lt;gtkmm/buttonbox.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/adjustment.h&gt;
+#include &lt;gtkmm/table.h&gt;
+
+indexDialog_glade::indexDialog_glade(
+)
+{  
+   
+   Gtk::Dialog *indexDialog = this;
+   gmm_data = new GlademmData(get_accel_group());
+   indexCancelbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-cancel&quot;)));
+   indexOkbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-ok&quot;)));
+   
+   Gtk::Label *nameLabel = Gtk::manage(new class Gtk::Label(_(&quot;Name:&quot;)));
+   locationEntry = Gtk::manage(new class Gtk::Entry());
+   locationButton = Gtk::manage(new class Gtk::Button(_(&quot;...&quot;)));
+   
+   Gtk::HBox *locationHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   Gtk::Label *typeLabel = Gtk::manage(new class Gtk::Label(_(&quot;Type:&quot;)));
+   Gtk::Label *locationLabel = Gtk::manage(new class Gtk::Label(_(&quot;Location:&quot;)));
+   Gtk::Label *portLabel = Gtk::manage(new class Gtk::Label(_(&quot;Port:&quot;)));
+   nameEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Adjustment *portSpinbutton_adj = Gtk::manage(new class Gtk::Adjustment(1024, 0, 65535, 1, 10, 10));
+   portSpinbutton = Gtk::manage(new class Gtk::SpinButton(*portSpinbutton_adj, 1, 0));
+   typeCombobox = Gtk::manage(new class Gtk::ComboBox());
+   
+   Gtk::Table *indexTable = Gtk::manage(new class Gtk::Table(2, 2, false));
+   indexCancelbutton-&gt;set_flags(Gtk::CAN_FOCUS);
+   indexCancelbutton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   indexCancelbutton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   indexOkbutton-&gt;set_flags(Gtk::CAN_FOCUS);
+   indexOkbutton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   indexOkbutton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   indexDialog-&gt;get_action_area()-&gt;property_layout_style().set_value(Gtk::BUTTONBOX_END);
+   nameLabel-&gt;set_alignment(0,0.5);
+   nameLabel-&gt;set_padding(4,4);
+   nameLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   nameLabel-&gt;set_line_wrap(false);
+   nameLabel-&gt;set_use_markup(false);
+   nameLabel-&gt;set_selectable(false);
+   locationEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   locationEntry-&gt;set_visibility(true);
+   locationEntry-&gt;set_editable(true);
+   locationEntry-&gt;set_max_length(0);
+   locationEntry-&gt;set_text(_(&quot;&quot;));
+   locationEntry-&gt;set_has_frame(true);
+   locationEntry-&gt;set_activates_default(false);
+   locationButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   locationButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   locationButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   locationHbox-&gt;pack_start(*locationEntry);
+   locationHbox-&gt;pack_start(*locationButton, Gtk::PACK_SHRINK, 4);
+   typeLabel-&gt;set_alignment(0,0.5);
+   typeLabel-&gt;set_padding(4,4);
+   typeLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   typeLabel-&gt;set_line_wrap(false);
+   typeLabel-&gt;set_use_markup(false);
+   typeLabel-&gt;set_selectable(false);
+   locationLabel-&gt;set_alignment(0,0.5);
+   locationLabel-&gt;set_padding(4,4);
+   locationLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   locationLabel-&gt;set_line_wrap(false);
+   locationLabel-&gt;set_use_markup(false);
+   locationLabel-&gt;set_selectable(false);
+   portLabel-&gt;set_alignment(0,0.5);
+   portLabel-&gt;set_padding(4,4);
+   portLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   portLabel-&gt;set_line_wrap(false);
+   portLabel-&gt;set_use_markup(false);
+   portLabel-&gt;set_selectable(false);
+   nameEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   nameEntry-&gt;set_visibility(true);
+   nameEntry-&gt;set_editable(true);
+   nameEntry-&gt;set_max_length(0);
+   nameEntry-&gt;set_text(_(&quot;&quot;));
+   nameEntry-&gt;set_has_frame(true);
+   nameEntry-&gt;set_activates_default(false);
+   portSpinbutton-&gt;set_flags(Gtk::CAN_FOCUS);
+   portSpinbutton-&gt;set_update_policy(Gtk::UPDATE_ALWAYS);
+   portSpinbutton-&gt;set_numeric(false);
+   portSpinbutton-&gt;set_digits(0);
+   portSpinbutton-&gt;set_wrap(false);
+   indexTable-&gt;set_row_spacings(0);
+   indexTable-&gt;set_col_spacings(0);
+   indexTable-&gt;attach(*nameLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   indexTable-&gt;attach(*locationHbox, 1, 2, 2, 3, Gtk::FILL, Gtk::FILL, 4, 4);
+   indexTable-&gt;attach(*typeLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   indexTable-&gt;attach(*locationLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
+   indexTable-&gt;attach(*portLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   indexTable-&gt;attach(*nameEntry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::AttachOptions(), 4, 4);
+   indexTable-&gt;attach(*portSpinbutton, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::AttachOptions(), 4, 4);
+   indexTable-&gt;attach(*typeCombobox, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::AttachOptions(), 4, 4);
+   indexDialog-&gt;get_vbox()-&gt;set_homogeneous(false);
+   indexDialog-&gt;get_vbox()-&gt;set_spacing(0);
+   indexDialog-&gt;get_vbox()-&gt;pack_start(*indexTable);
+   indexDialog-&gt;set_title(_(&quot;External index&quot;));
+   indexDialog-&gt;set_modal(false);
+   indexDialog-&gt;property_window_position().set_value(Gtk::WIN_POS_NONE);
+   indexDialog-&gt;set_resizable(true);
+   indexDialog-&gt;property_destroy_with_parent().set_value(false);
+   indexDialog-&gt;set_has_separator(true);
+   indexDialog-&gt;add_action_widget(*indexCancelbutton, -6);
+   indexDialog-&gt;add_action_widget(*indexOkbutton, -5);
+   indexCancelbutton-&gt;show();
+   indexOkbutton-&gt;show();
+   nameLabel-&gt;show();
+   locationEntry-&gt;show();
+   locationButton-&gt;show();
+   locationHbox-&gt;show();
+   typeLabel-&gt;show();
+   locationLabel-&gt;show();
+   portLabel-&gt;show();
+   nameEntry-&gt;show();
+   portSpinbutton-&gt;show();
+   typeCombobox-&gt;show();
+   indexTable-&gt;show();
+   indexDialog-&gt;show();
+   indexOkbutton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;indexDialog_glade::on_indexOkbutton_clicked), false);
+   locationEntry-&gt;signal_changed().connect(SigC::slot(*this, &amp;indexDialog_glade::on_locationEntry_changed), false);
+   locationButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;indexDialog_glade::on_locationButton_clicked), false);
+   nameEntry-&gt;signal_changed().connect(SigC::slot(*this, &amp;indexDialog_glade::on_nameEntry_changed), false);
+   typeCombobox-&gt;signal_changed().connect(SigC::slot(*this, &amp;indexDialog_glade::on_typeCombobox_changed), false);
+}
+
+indexDialog_glade::~indexDialog_glade()
+{  delete gmm_data;
+}

Added: trunk/UI/GTK2/src/indexDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/indexDialog_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/indexDialog_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,63 @@
+// generated 2005/4/17 5:19:13 BST by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at thorgrim.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.4.0 and gtkmm 2.4.8
+//
+// Please modify the corresponding derived classes in ./src/indexDialog.hh and./src/indexDialog.cc
+
+#ifndef _INDEXDIALOG_GLADE_HH
+#  define _INDEXDIALOG_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include &lt;gtkmm/accelgroup.h&gt;
+
+class GlademmData
+{  
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt; accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr&lt;Gtk::AccelGroup&gt; ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt;  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include &lt;gtkmm/dialog.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/entry.h&gt;
+#include &lt;gtkmm/spinbutton.h&gt;
+#include &lt;gtkmm/combobox.h&gt;
+
+class indexDialog_glade : public Gtk::Dialog
+{  
+        
+        GlademmData *gmm_data;
+protected:
+        class Gtk::Button * indexCancelbutton;
+        class Gtk::Button * indexOkbutton;
+        class Gtk::Entry * locationEntry;
+        class Gtk::Button * locationButton;
+        class Gtk::Entry * nameEntry;
+        class Gtk::SpinButton * portSpinbutton;
+        class Gtk::ComboBox * typeCombobox;
+        
+        indexDialog_glade();
+        
+        ~indexDialog_glade();
+private:
+        virtual void on_indexOkbutton_clicked() = 0;
+        virtual void on_locationEntry_changed() = 0;
+        virtual void on_locationButton_clicked() = 0;
+        virtual void on_nameEntry_changed() = 0;
+        virtual void on_typeCombobox_changed() = 0;
+};
+#endif

Added: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,2916 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;time.h&gt;
+#include &lt;string&gt;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+#include &lt;sigc++/class_slot.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;glibmm/stringutils.h&gt;
+#include &lt;glibmm/convert.h&gt;
+#include &lt;glibmm/thread.h&gt;
+#include &lt;gtkmm/stock.h&gt;
+#include &lt;gtkmm/messagedialog.h&gt;
+#include &lt;gtkmm/scrolledwindow.h&gt;
+#include &lt;gtkmm/clipboard.h&gt;
+#include &lt;gtkmm/main.h&gt;
+
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;IndexedDocument.h&quot;
+#include &quot;TimeConverter.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;ActionHistory.h&quot;
+#include &quot;LabelManager.h&quot;
+#include &quot;QueryHistory.h&quot;
+#include &quot;ViewHistory.h&quot;
+#include &quot;DownloaderFactory.h&quot;
+#include &quot;XapianIndex.h&quot;
+#include &quot;SearchEngineFactory.h&quot;
+#include &quot;XapianEngine.h&quot;
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;mainWindow.hh&quot;
+#include &quot;aboutDialog.hh&quot;
+#include &quot;importDialog.hh&quot;
+#include &quot;indexDialog.hh&quot;
+#include &quot;propertiesDialog.hh&quot;
+#include &quot;prefsDialog.hh&quot;
+#include &quot;queryDialog.hh&quot;
+
+using namespace std;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+// A function object to delete pointers from a set with for_each()
+struct DeleteSetPointer
+{
+	template&lt;typename T&gt;
+	void operator()(const T *ptr) const
+	{
+		delete ptr;
+	}
+};
+
+// FIXME: this ought to be configurable
+unsigned int mainWindow::m_maxDocsCount = 100;
+unsigned int mainWindow::m_maxThreads = 2;
+
+mainWindow::InternalState::InternalState() :
+	m_currentLabelPos(0),
+	m_currentLabelName(_(&quot;None&quot;)),
+	m_currentIndexName(_(&quot;My Documents&quot;)),
+	m_indexDocsCount(0),
+	m_startDoc(0),
+	m_backgroundThreads(0),
+	m_browsingIndex(false)
+{
+	pthread_rwlock_init(&amp;m_rwLock, NULL);
+}
+
+mainWindow::InternalState::~InternalState()
+{
+	// Destroy the read/write lock
+	pthread_rwlock_destroy(&amp;m_rwLock);
+}
+
+bool mainWindow::InternalState::readLock(unsigned int where)
+{
+	if (pthread_rwlock_rdlock(&amp;m_rwLock) == 0)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::InternalState::readLock &quot; &lt;&lt; where &lt;&lt; endl;
+#endif
+		return true;
+	}
+
+	return false;
+}
+
+bool mainWindow::InternalState::writeLock(unsigned int where)
+{
+	if (pthread_rwlock_wrlock(&amp;m_rwLock) == 0)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::InternalState::writeLock &quot; &lt;&lt; where &lt;&lt; endl;
+#endif
+		return true;
+	}
+
+	return false;
+}
+
+void mainWindow::InternalState::unlock(void)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::InternalState::unlock&quot; &lt;&lt; endl;
+#endif
+	pthread_rwlock_unlock(&amp;m_rwLock);
+}
+
+unsigned int mainWindow::InternalState::getCurrentLabel(string &amp;labelName)
+{
+	if (readLock(1) == true)
+	{
+		unsigned int labelPos = m_currentLabelPos;
+		labelName = m_currentLabelName;
+		unlock();
+
+		return labelPos;
+	}
+	
+	return 0;
+}
+
+void mainWindow::InternalState::setCurrentLabel(unsigned int labelPos, const string &amp;labelName)
+{
+	if (writeLock(1) == true)
+	{
+		m_currentLabelPos = labelPos;
+		m_currentLabelName = labelName;
+		unlock();
+	}
+}
+
+Glib::ustring mainWindow::InternalState::getCurrentIndex(void)
+{
+	ustring indexName;
+
+	if (readLock(2) == true)
+	{
+		indexName = m_currentIndexName;
+		unlock();
+	}
+
+	return indexName;
+}
+
+void mainWindow::InternalState::setCurrentIndex(const Glib::ustring &amp;indexName)
+{
+	if (writeLock(2) == true)
+	{
+		m_currentIndexName = indexName;
+		unlock();
+	}
+}
+
+//
+// Constructor
+//
+mainWindow::mainWindow() :
+	m_settings(PinotSettings::getInstance()), mainWindow_glade(),
+	m_pEnginesTree(NULL),
+	m_pResultsTree(NULL),
+	m_pIndexTree(NULL),
+	m_pLabelsMenu(NULL)
+{
+	// Reposition and resize the window
+	// Make sure the coordinates and sizes make sense
+	if ((m_settings.m_xPos &gt;= 0) &amp;&amp;
+		(m_settings.m_yPos &gt;= 0))
+	{
+		move(m_settings.m_xPos, m_settings.m_yPos);
+	}
+	if ((m_settings.m_width &gt; 0) &amp;&amp;
+		(m_settings.m_height &gt; 0))
+	{
+		resize(m_settings.m_width, m_settings.m_height);
+	}
+	if (m_settings.m_panePos &gt;= 0)
+	{
+		mainHpaned-&gt;set_position(m_settings.m_panePos);
+	}
+
+	// Position the engine tree
+	m_pEnginesTree = manage(new EnginesTree(enginesVbox, m_settings));
+	// Connect to the &quot;changed&quot; signal
+	m_pEnginesTree-&gt;get_selection()-&gt;signal_changed().connect(SigC::slot(*this,
+		&amp;mainWindow::on_enginesTreeviewSelection_changed));
+	// Connect to the edit index signal
+	m_pEnginesTree-&gt;getEditIndexSignal().connect(SigC::slot(*this,
+		&amp;mainWindow::on_editindex));
+
+	// Set an icon for this and other windows
+	set_icon_from_file(&quot;/usr/share/icons/hicolor/48x48/apps/pinot.png&quot;);
+	set_default_icon_from_file(&quot;/usr/share/icons/hicolor/48x48/apps/pinot.png&quot;);
+
+	// Associate the columns model to the query tree
+	m_refQueryTree = ListStore::create(m_queryColumns);
+	queryTreeview-&gt;set_model(m_refQueryTree);
+	TreeViewColumn *treeColumn = create_resizable_column(_(&quot;Query Name&quot;), m_queryColumns.m_name);
+	if (treeColumn != NULL)
+	{
+		queryTreeview-&gt;append_column(*manage(treeColumn));
+	}
+	queryTreeview-&gt;append_column(_(&quot;Last Run&quot;), m_queryColumns.m_lastRun);
+	queryTreeview-&gt;append_column(_(&quot;Summary&quot;), m_queryColumns.m_summary);
+	// Allow only single selection
+	queryTreeview-&gt;get_selection()-&gt;set_mode(SELECTION_SINGLE);
+	// Connect to the &quot;changed&quot; signal
+	queryTreeview-&gt;get_selection()-&gt;signal_changed().connect(SigC::slot(*this, 
+		&amp;mainWindow::on_queryTreeviewSelection_changed));
+	// Populate
+	populate_queryTreeview();
+
+	// Position the results tree
+	m_pResultsTree = manage(new ResultsTree(resultsVbox, resultsMenuitem-&gt;get_submenu(), m_settings));
+	// Connect to the &quot;changed&quot; signal
+	m_pResultsTree-&gt;get_selection()-&gt;signal_changed().connect(SigC::slot(*this,
+		&amp;mainWindow::on_resultsTreeviewSelection_changed));
+
+	// Position the index tree
+	m_pIndexTree = manage(new IndexTree(indexVbox, indexMenuitem-&gt;get_submenu(), m_settings));
+	// Connect to the &quot;changed&quot; signal
+	m_pIndexTree-&gt;get_selection()-&gt;signal_changed().connect(SigC::slot(*this,
+		&amp;mainWindow::on_indexTreeviewSelection_changed));
+	// Connect to the edit document signal
+	m_pIndexTree-&gt;getEditDocumentSignal().connect(SigC::slot(*this,
+		&amp;mainWindow::on_showfromindex_activate));
+
+	// Associate the columns model to the index combo
+	m_refIndexNameTree = ListStore::create(m_indexNameColumns);
+	indexCombobox-&gt;set_model(m_refIndexNameTree);
+	indexCombobox-&gt;pack_start(m_indexNameColumns.m_name);
+	// Populate the index combo
+	populate_indexCombobox();
+
+	// Populate the label menu
+	populate_labelMenu();
+
+	// Add an HTML renderer in the View tab
+	m_pHtmlView = new HtmlView(viewVbox, NULL);
+	if (m_settings.m_browseResults == true)
+	{
+		// Hide this tab
+		Widget *pPage = mainNotebook-&gt;get_nth_page(2);
+		if (pPage != NULL)
+		{
+			pPage-&gt;hide();
+		}
+	}
+	else
+	{
+		view_document(&quot;<A HREF="file:///usr/share/pinot/index.html">file:///usr/share/pinot/index.html</A>&quot;, true);
+	}
+
+	// Gray out menu items
+	editQueryButton-&gt;set_sensitive(false);
+	removeQueryButton-&gt;set_sensitive(false);
+	findQueryButton-&gt;set_sensitive(false);
+	clearresults1-&gt;set_sensitive(false);
+	viewresults1-&gt;set_sensitive(false);
+	// Hide the View Cache menu item ?
+	if (SearchEngineFactory::isSupported(&quot;googleapi&quot;) == false)
+	{
+		viewcache1-&gt;hide();
+	}
+	else
+	{
+		viewcache1-&gt;set_sensitive(false);
+	}
+	indexresults1-&gt;set_sensitive(false);
+	showlabels1-&gt;set_sensitive(false);
+	viewfromindex1-&gt;set_sensitive(false);
+	refreshindex1-&gt;set_sensitive(false);
+	showfromindex1-&gt;set_sensitive(false);
+	unindex1-&gt;set_sensitive(false);
+	//viewstop1-&gt;set_sensitive(false);
+	// ...and buttons
+	removeIndexButton-&gt;set_sensitive(false);
+	indexFirstButton-&gt;set_sensitive(false);
+	indexBackButton-&gt;set_sensitive(false);
+	indexForwardButton-&gt;set_sensitive(false);
+	indexLastButton-&gt;set_sensitive(false);
+
+	// Set focus on the query entry field
+	set_focus(*liveQueryEntry);
+
+	// Set tooltips
+	m_tooltips.set_tip(*addIndexButton, _(&quot;Add index&quot;));
+	m_tooltips.set_tip(*removeIndexButton, _(&quot;Remove index&quot;));
+
+	// FIXME: delete all &quot;ignored&quot; threads when exiting !!!
+	// Fire up a listener thread
+	ListenerThread *pListenThread = new ListenerThread(PinotSettings::getConfigurationDirectory() + string(&quot;/fifo&quot;));
+	// Connect to its reception signal
+	pListenThread-&gt;getReceptionSignal().connect(SigC::slot(*this,
+		&amp;mainWindow::on_message_reception));
+	start_thread(pListenThread, true);
+
+	// Fire up the mail monitor thread
+	MboxHandler *pMbox = new MboxHandler();
+	// Connect to its update signal
+	pMbox-&gt;getUpdateSignal().connect(SigC::slot(*this,
+		&amp;mainWindow::on_message_indexupdate));
+	MonitorThread *pMonitorThread = new MonitorThread(pMbox);
+	start_thread(pMonitorThread, true);
+	// The handler object will be deleted when the thread terminates
+
+	// List the documents index
+	browse_index();
+	// There might be queued actions
+	check_queue();
+
+	// Now we are ready
+	set_status(_(&quot;Ready&quot;));
+	show();
+}
+
+//
+// Destructor
+//
+mainWindow::~mainWindow()
+{
+	// Save queries
+	save_queryTreeview();
+
+	if (m_state.m_pThreads.empty() == false)
+	{
+		for_each(m_state.m_pThreads.begin(), m_state.m_pThreads.end(), DeleteSetPointer());
+	}
+
+	// This is a hack to avoid segfaults when the View tab hasn't been made visible
+	Widget *pPage = mainNotebook-&gt;get_nth_page(2);
+	if (pPage != NULL)
+	{
+		pPage-&gt;show();
+	}
+	mainNotebook-&gt;set_current_page(2);
+	// Stop if we were loading a page
+	m_pHtmlView-&gt;stop();
+	delete m_pHtmlView;
+}
+
+//
+// Load user-defined queries
+//
+void mainWindow::populate_queryTreeview()
+{
+	QueryHistory history(m_settings.m_historyDatabase);
+	const std::map&lt;string, QueryProperties&gt; &amp;queries = m_settings.getQueries();
+
+	// Reset the whole tree
+	queryTreeview-&gt;get_selection()-&gt;unselect_all();
+	m_refQueryTree-&gt;clear();
+
+	// Add all user-defined queries
+	std::map&lt;string, QueryProperties&gt;::const_iterator queryIter = queries.begin();
+	for (; queryIter != queries.end(); ++queryIter)
+	{
+		TreeModel::iterator iter = m_refQueryTree-&gt;append();
+		TreeModel::Row row = *iter;
+		string queryName = queryIter-&gt;first;
+
+		row[m_queryColumns.m_name] = to_utf8(queryName);
+		string lastRun = history.getLastRun(queryName);
+		if (lastRun.empty() == true)
+		{
+			lastRun = _(&quot;N/A&quot;);
+		}
+		row[m_queryColumns.m_lastRun] = lastRun;
+		string summary = queryIter-&gt;second.toString();
+		if (summary.empty() == false)
+		{
+			row[m_queryColumns.m_summary] = to_utf8(summary);
+		}
+		else
+		{
+			row[m_queryColumns.m_summary] = _(&quot;&lt;undefined&gt;&quot;);
+		}
+		row[m_queryColumns.m_properties] = queryIter-&gt;second;
+	}
+}
+
+//
+// Store defined queries into the settings object
+//
+void mainWindow::save_queryTreeview()
+{
+	// Clear the current queries
+	m_settings.clearQueries();
+
+	// Go through the query tree
+	TreeModel::Children children = m_refQueryTree-&gt;children();
+	if (children.empty() == false)
+	{
+		for (TreeModel::Children::iterator iter = children.begin();
+			iter != children.end(); ++iter)
+		{
+			TreeModel::Row row = *iter;
+
+			// Add this query to the settings
+			string name = locale_from_utf8(row[m_queryColumns.m_name]);
+			QueryProperties queryProps = row[m_queryColumns.m_properties];
+#ifdef DEBUG
+			cout &lt;&lt; &quot;mainWindow::save_queryTreeview: &quot; &lt;&lt; name &lt;&lt; endl;
+#endif
+			m_settings.addQuery(queryProps);
+		}
+	}
+}
+
+//
+// Populate the indexes list
+//
+void mainWindow::populate_indexCombobox()
+{
+	TreeModel::iterator iter;
+	TreeModel::Row row;
+
+	const std::map&lt;string, string&gt; &amp;indexes = m_settings.getIndexes();
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::populate_indexCombobox: &quot; &lt;&lt; indexes.size() &lt;&lt; &quot; indexes&quot; &lt;&lt; endl;
+#endif
+	m_refIndexNameTree-&gt;clear();
+	std::map&lt;string, string&gt;::const_iterator indexIter = indexes.begin();
+	for (; indexIter != indexes.end(); ++indexIter)
+	{
+		string indexName = indexIter-&gt;first;
+
+		if (m_settings.isInternalIndex(indexName) == true)
+		{
+			// Add this index
+			iter = m_refIndexNameTree-&gt;append();
+			row = *iter;
+			row[m_indexNameColumns.m_name] = to_utf8(indexName);
+#ifdef DEBUG
+			cout &lt;&lt; &quot;mainWindow::populate_indexCombobox: added &quot; &lt;&lt; indexName &lt;&lt; endl;
+#endif
+		}
+	}
+
+	indexCombobox-&gt;set_active(0);
+}
+
+//
+// Populate the labels menu
+//
+void mainWindow::populate_labelMenu()
+{
+	RadioMenuItem::Group labelsGroup;
+	RadioMenuItem *firstLabelMenuItem = NULL;
+	RadioMenuItem *labelMenuItem = NULL;
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::populate_labels_menu: called&quot; &lt;&lt; endl;
+#endif
+	if (m_pLabelsMenu == NULL)
+	{
+		m_pLabelsMenu = new Menu();
+		showlabels1-&gt;set_submenu(*m_pLabelsMenu);
+	}
+	else
+	{
+		// Clear the submenu
+		m_pLabelsMenu-&gt;items().clear();
+	}
+
+	SigC::Slot1&lt;void, unsigned int&gt; labelsSlot = SigC::slot(*this, &amp;mainWindow::on_labelMenu_changed);
+	unsigned int count = 1;
+                                                                                                                                                             
+	// Initialize the submenu
+	m_pLabelsMenu-&gt;items().push_back(Menu_Helpers::RadioMenuElem(labelsGroup, _(&quot;None&quot;)));
+	firstLabelMenuItem = labelMenuItem = (RadioMenuItem*)&amp;m_pLabelsMenu-&gt;items().back();
+	// Bind the callback's parameter to the menuitem's position in the submenu
+	SigC::Slot0&lt;void&gt; labelsSlot0 = sigc::bind(labelsSlot, 0);
+	labelMenuItem-&gt;signal_activate().connect(labelsSlot0);
+	for (set&lt;PinotSettings::Label&gt;::const_iterator iter = m_settings.m_labels.begin();
+		iter != m_settings.m_labels.end(); ++iter)
+	{
+		m_pLabelsMenu-&gt;items().push_back(Menu_Helpers::RadioMenuElem(labelsGroup, iter-&gt;m_name));
+		labelMenuItem = (RadioMenuItem*)&amp;m_pLabelsMenu-&gt;items().back();
+		SigC::Slot0&lt;void&gt; labelsSlot0 = sigc::bind(labelsSlot, count);
+		labelMenuItem-&gt;signal_activate().connect(labelsSlot0);
+		++count;
+	}
+
+	// Activate the first menuitem
+	firstLabelMenuItem-&gt;set_active(true);
+}
+
+//
+// Query list selection changed
+//
+void mainWindow::on_queryTreeviewSelection_changed()
+{
+	TreeModel::iterator iter = queryTreeview-&gt;get_selection()-&gt;get_selected();
+	// Anything selected ?
+	if (iter)
+	{
+		// Enable those
+		editQueryButton-&gt;set_sensitive(true);
+		removeQueryButton-&gt;set_sensitive(true);
+		findQueryButton-&gt;set_sensitive(true);
+	}
+	else
+	{
+		// Disable those
+		editQueryButton-&gt;set_sensitive(false);
+		removeQueryButton-&gt;set_sensitive(false);
+		findQueryButton-&gt;set_sensitive(false);
+	}
+}
+
+//
+// Engines tree selection changed
+//
+void mainWindow::on_enginesTreeviewSelection_changed()
+{
+	list&lt;TreeModel::Path&gt; selectedEngines = m_pEnginesTree-&gt;getSelection();
+	// If there are more than one row selected, don't bother
+	if (selectedEngines.size() != 1)
+	{
+		return;
+	}
+
+	list&lt;TreeModel::Path&gt;::iterator enginePath = selectedEngines.begin();
+	if (enginePath == selectedEngines.end())
+	{
+		return;
+	}
+
+	TreeModel::iterator engineIter = m_pEnginesTree-&gt;getIter(*enginePath);
+	TreeModel::Row engineRow = *engineIter;
+	bool enableRemoveIndex = false;
+
+	// Make sure it's a leaf node
+	if (engineIter-&gt;children().empty() == true)
+	{
+		TreeModel::Row engineRow = *engineIter;
+
+		// Is it an external index ?
+		EnginesModelColumns &amp;enginesColumns = m_pEnginesTree-&gt;getColumnRecord();
+		EnginesModelColumns::EngineType engineType = engineRow[enginesColumns.m_type];
+		if (engineType == EnginesModelColumns::INDEX_ENGINE)
+		{
+			// Yes, enable the remove index button
+			enableRemoveIndex = true;
+		}
+	}
+	removeIndexButton-&gt;set_sensitive(enableRemoveIndex);
+}
+
+//
+// Results tree selection changed
+//
+void mainWindow::on_resultsTreeviewSelection_changed()
+{
+	if (m_pResultsTree-&gt;onSelectionChanged() == true)
+	{
+		ustring url = m_pResultsTree-&gt;getFirstSelectionURL();
+		bool isViewable = true, isIndexable = true, isCached = false;
+
+		Url urlObj(locale_from_utf8(url));
+		string protocol = urlObj.getProtocol();
+		// FIXME: there should be a way to know which protocols can be viewed/indexed
+		if (protocol == &quot;xapian&quot;)
+		{
+			isViewable = isIndexable = false;
+		}
+
+		// Enable these menu items
+		viewresults1-&gt;set_sensitive(isViewable);
+		if (m_settings.m_browseResults == false)
+		{
+			if ((protocol == &quot;http&quot;) ||
+				(protocol == &quot;https&quot;))
+			{
+				isCached = true;
+			}
+		}
+		viewcache1-&gt;set_sensitive(isCached);
+		indexresults1-&gt;set_sensitive(isIndexable);
+
+		// Show the URL in the status bar
+		ustring statusText = _(&quot;Result location is&quot;);
+		statusText += &quot; &quot;;
+		statusText += url;
+		set_status(statusText, true);
+	}
+	else
+	{
+		// Disable these menu items
+		viewresults1-&gt;set_sensitive(false);
+		viewcache1-&gt;set_sensitive(false);
+		indexresults1-&gt;set_sensitive(false);
+
+		// Reset
+		set_status(&quot;&quot;);
+	}
+}
+
+//
+// Index tree selection changed
+//
+void mainWindow::on_indexTreeviewSelection_changed()
+{
+	if (m_pIndexTree-&gt;onSelectionChanged() == true)
+	{
+		bool isDocumentsIndex = true;
+		bool canViewDocument = true;
+
+		// Enable these menu items, unless the index is not the documents index
+		ustring currentIndexName = m_state.getCurrentIndex();
+		if (currentIndexName != _(&quot;My Documents&quot;))
+		{
+			isDocumentsIndex = false;
+		}
+		if ((currentIndexName == _(&quot;My Email&quot;)) &amp;&amp;
+			(m_settings.m_browseResults == true))
+		{
+			canViewDocument = false;
+		}
+		viewfromindex1-&gt;set_sensitive(canViewDocument);
+		refreshindex1-&gt;set_sensitive(isDocumentsIndex);
+		showfromindex1-&gt;set_sensitive(true);
+		unindex1-&gt;set_sensitive(isDocumentsIndex);
+
+		// Show the URL in the status bar
+		ustring statusText = _(&quot;Document location is&quot;);
+		statusText += &quot; &quot;;
+		statusText += m_pIndexTree-&gt;getFirstSelectionURL();
+		set_status(statusText, true);
+	}
+	else
+	{
+		// No, disable these
+		viewfromindex1-&gt;set_sensitive(false);
+		refreshindex1-&gt;set_sensitive(false);
+		showfromindex1-&gt;set_sensitive(false);
+		unindex1-&gt;set_sensitive(false);
+	}
+}
+
+//
+// Index &gt; Show Labels menu selected
+//
+void mainWindow::on_labelMenu_changed(unsigned int pos)
+{
+	string currentLabelName;
+	unsigned int currentLabelPos;
+
+	// Since we listen for signal_activate(), this handler gets called when the
+	// current item is unselected and when the new one is selected
+	currentLabelPos = m_state.getCurrentLabel(currentLabelName);
+	if (currentLabelPos == pos)
+	{
+		// Ignore unselections
+		return;
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::on_labelMenu_changed: called on &quot; &lt;&lt; pos &lt;&lt; endl;
+#endif
+	currentLabelPos = pos;
+	if (currentLabelPos == 0)
+	{
+		// User selected no label
+		currentLabelName = _(&quot;None&quot;);
+		m_state.setCurrentLabel(currentLabelPos, currentLabelName);
+		m_pIndexTree-&gt;setCurrentLabelColour(0, 0, 0, false);
+		set_status(_(&quot;No labels&quot;));
+		return;
+	}
+
+	// Get the actual label from the settings object
+	unsigned int labelNum = 1;
+	for (set&lt;PinotSettings::Label&gt;::iterator labelIter = m_settings.m_labels.begin();
+		labelIter != m_settings.m_labels.end(); ++labelIter)
+	{
+		if (labelNum == pos)
+		{
+			// That's the one
+			currentLabelName = locale_from_utf8(labelIter-&gt;m_name);
+			m_state.setCurrentLabel(currentLabelPos, currentLabelName);
+#ifdef DEBUG
+			cout &lt;&lt; &quot;mainWindow::on_labelMenu_changed: label is &quot; &lt;&lt; currentLabelName &lt;&lt; endl;
+#endif
+			// Switch temporarily to no label
+			m_pIndexTree-&gt;setCurrentLabelColour(0, 0, 0, false);
+
+			// Get the documents that match this label
+			start_thread(new LabelQueryThread(m_state.getCurrentIndex(), currentLabelName));
+			break;
+		}
+		++labelNum;
+	}
+}
+
+//
+// End of worker thread
+//
+void mainWindow::on_thread_end()
+{
+	WorkerThread *pThread = NULL;
+	ustring status;
+
+	// Get the first thread that's finished
+	if (m_state.readLock(3) == true)
+	{
+		for (set&lt;WorkerThread *&gt;::iterator threadIter = m_state.m_pThreads.begin();
+			threadIter != m_state.m_pThreads.end(); ++threadIter)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;mainWindow::on_thread_end: looking for thread&quot; &lt;&lt; endl;
+#endif
+			if ((*threadIter)-&gt;isDone() == true)
+			{
+				// This one will do...
+				pThread = (*threadIter);
+				// Remove it
+				m_state.m_pThreads.erase(threadIter);
+				break;
+			}
+		}
+
+		m_state.unlock();
+	}
+	if (pThread == NULL)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_thread_end: signalled but couldn't find any thread&quot; &lt;&lt; endl;
+#endif
+		return;
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::on_thread_end: end of thread &quot; &lt;&lt; pThread-&gt;getId() &lt;&lt; endl;
+#endif
+	update_threads_status();
+
+	// What type of thread was it ?
+	string type = pThread-&gt;getType();
+	if (pThread-&gt;isBackground() == true)
+	{
+		m_state.m_backgroundThreads--;
+	}
+	// Did the thread fail for some reason ?
+	string threadStatus = pThread-&gt;getStatus();
+	if (threadStatus.empty() == false)
+	{
+		// Yep, it did
+		set_status(to_utf8(threadStatus));
+		// Better reset that flag if an error occured while browsing an index
+		if (type == &quot;IndexBrowserThread&quot;)
+		{
+			m_state.m_browsingIndex = false;
+		}
+	}
+	// Based on type, take the appropriate action...
+	else if (type == &quot;IndexBrowserThread&quot;)
+	{
+		char docsCountStr[64];
+		unsigned int count = 0;
+		bool enableIndexOps = false;
+
+		IndexBrowserThread *pBrowseThread = dynamic_cast&lt;IndexBrowserThread *&gt;(pThread);
+		if (pBrowseThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		m_state.m_indexDocsCount = pBrowseThread-&gt;getDocumentsCount();
+		count = m_pIndexTree-&gt;getRowsCount();
+
+		status = _(&quot;Showing&quot;);
+		status += &quot; &quot;;
+		snprintf(docsCountStr, 64, &quot;%u&quot;, count);
+		status += docsCountStr;
+		status += &quot; &quot;;
+		status += _(&quot;off&quot;);
+		status += &quot; &quot;;
+		snprintf(docsCountStr, 64, &quot;%u&quot;, m_state.m_indexDocsCount);
+		status += docsCountStr;
+		status += &quot; &quot;;
+		status += _(&quot;documents from&quot;);
+		status += &quot; &quot;;
+		status += m_state.getCurrentIndex();
+		set_status(status);
+
+		if (m_state.m_indexDocsCount &gt; 0)
+		{
+			// Switch to the index page
+			mainNotebook-&gt;set_current_page(1);
+			// FIXME: not sure why, but this helps with refreshing the tree
+			m_pIndexTree-&gt;columns_autosize();
+			enableIndexOps = true;
+		}
+		showlabels1-&gt;set_sensitive(enableIndexOps);
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_thread_end: &quot; &lt;&lt; m_state.m_indexDocsCount
+			&lt;&lt; &quot; documents, starting at &quot; &lt;&lt; m_state.m_startDoc &lt;&lt; endl;
+#endif
+		if (m_state.m_startDoc &gt; 0)
+		{
+			indexFirstButton-&gt;set_sensitive(true);
+		}
+		else
+		{
+			indexFirstButton-&gt;set_sensitive(false);
+		}
+		if (m_state.m_startDoc &gt;= m_maxDocsCount)
+		{
+			indexBackButton-&gt;set_sensitive(true);
+		}
+		else
+		{
+			indexBackButton-&gt;set_sensitive(false);
+		}
+		if (m_state.m_indexDocsCount &gt;= m_state.m_startDoc + m_maxDocsCount)
+		{
+			indexForwardButton-&gt;set_sensitive(true);
+		}
+		else
+		{
+			indexForwardButton-&gt;set_sensitive(false);
+		}
+		if (m_state.m_indexDocsCount &gt; m_state.m_startDoc + count)
+		{
+			indexLastButton-&gt;set_sensitive(true);
+		}
+		else
+		{
+			indexLastButton-&gt;set_sensitive(false);
+		}
+		m_state.m_browsingIndex = false;
+	}
+	else if (type == &quot;QueryingThread&quot;)
+	{
+		std::map&lt;string, TreeModel::iterator&gt; updatedGroups;
+		unsigned int count = 0;
+		ResultsModelColumns::ResultType rootType;
+		bool mergeDuplicates = false;
+
+		QueryingThread *pQueryThread = dynamic_cast&lt;QueryingThread *&gt;(pThread);
+		if (pQueryThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		QueryProperties queryProps = pQueryThread-&gt;getQuery();
+		string queryName = queryProps.getName();
+		string engineName = pQueryThread-&gt;getEngineName();
+
+		status = _(&quot;Query&quot;);
+		status += &quot; &quot;;
+		status += to_utf8(queryName);
+		status += &quot; &quot;;
+		status += _(&quot;on&quot;);
+		status += &quot; &quot;;
+		status += to_utf8(engineName);
+		status += &quot; &quot;;
+		status += _(&quot;ended&quot;);
+		set_status(status);
+
+		// Switch to the results page
+		mainNotebook-&gt;set_current_page(0);
+
+		// Add these results to the tree
+		const vector&lt;Result&gt; &amp;resultsList = pQueryThread-&gt;getResults();
+		if (m_pResultsTree-&gt;addResults(queryProps, engineName,
+			resultsList, searchenginegroup1-&gt;get_active()) == true)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;mainWindow::on_thread_end: added results&quot; &lt;&lt; endl;
+#endif
+			// Enable results clearing
+			clearresults1-&gt;set_sensitive(true);
+
+			// Index results ?
+			if ((queryProps.getIndexResults() == true) &amp;&amp;
+				(resultsList.empty() == false))
+			{
+				string labelName = queryProps.getLabelName();
+
+#ifdef DEBUG
+				cout &lt;&lt; &quot;mainWindow::on_thread_end: indexing results, with label &quot; &lt;&lt; labelName &lt;&lt; endl;
+#endif
+				for (vector&lt;Result&gt;::const_iterator resultIter = resultsList.begin();
+					resultIter != resultsList.end(); ++resultIter)
+				{
+					// Queue this action
+					queue_index(DocumentInfo(resultIter-&gt;getTitle(), resultIter-&gt;getLocation(),
+						resultIter-&gt;getType(), resultIter-&gt;getLanguage()),
+						labelName);
+				}
+			}
+		}
+	}
+	else if (type == &quot;LabelQueryThread&quot;)
+	{
+		string currentLabelName;
+		unsigned int currentLabelPos = 0;
+
+		LabelQueryThread *pLabelQueryThread = dynamic_cast&lt;LabelQueryThread *&gt;(pThread);
+		if (pLabelQueryThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		// Don't bother if the index is not being listed, or if the user
+		// changed the label in the meantime
+		currentLabelPos = m_state.getCurrentLabel(currentLabelName);
+		if ((m_pIndexTree-&gt;isEmpty() == false) &amp;&amp;
+			(currentLabelPos &gt; 0) &amp;&amp;
+			(currentLabelName == pLabelQueryThread-&gt;getLabelName()))
+		{
+			const set&lt;unsigned int&gt; &amp;documentsList = pLabelQueryThread-&gt;getDocumentsList();
+			char docsCountStr[64];
+			unsigned int docsCount = documentsList.size();
+			unsigned int labelNum = 1;
+
+			status = _(&quot;Label&quot;);
+			status += &quot; &quot;;
+			status += to_utf8(pLabelQueryThread-&gt;getLabelName());
+			status += &quot; &quot;;
+			status += _(&quot;matches&quot;);
+			status += &quot; &quot;;
+			snprintf(docsCountStr, 64, &quot;%u&quot;, docsCount);
+			status += docsCountStr;
+			status += &quot; &quot;;
+			status += _(&quot;document(s)&quot;);
+			set_status(status);
+
+#ifdef DEBUG
+			cout &lt;&lt; &quot;mainWindow::on_thread_end: current label is &quot; &lt;&lt; currentLabelName &lt;&lt; endl;
+#endif
+			// Get the actual label colour from the settings
+			for (set&lt;PinotSettings::Label&gt;::iterator labelIter = m_settings.m_labels.begin();
+				labelIter != m_settings.m_labels.end(); ++labelIter)
+			{
+#ifdef DEBUG
+				cout &lt;&lt; &quot;mainWindow::on_thread_end: looking at label &quot;
+					&lt;&lt; labelIter-&gt;m_name &lt;&lt; &quot;, position &quot; &lt;&lt; labelNum &lt;&lt; endl;
+#endif
+				if (labelNum == currentLabelPos)
+				{
+					// Display the selected label's colour in the index tree
+					m_pIndexTree-&gt;setCurrentLabelColour(labelIter-&gt;m_red, labelIter-&gt;m_green, labelIter-&gt;m_blue);
+					m_pIndexTree-&gt;setLabel(documentsList);
+
+					// Switch to the index page
+					mainNotebook-&gt;set_current_page(1);
+					break;
+				}
+				++labelNum;
+			}
+		}
+	}
+	else if (type == &quot;DownloadingThread&quot;)
+	{
+		DownloadingThread *pDownloadThread = dynamic_cast&lt;DownloadingThread *&gt;(pThread);
+		if (pDownloadThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		string url = pDownloadThread-&gt;getURL();
+		const Document *pDoc = pDownloadThread-&gt;getDocument();
+		if (pDoc != NULL)
+		{
+			unsigned int dataLength = 0;
+
+			const char *pData = pDoc-&gt;getData(dataLength);
+			if ((pData != NULL) &amp;&amp;
+				(dataLength &gt; 0))
+			{
+				// Make sure settings haven't changed in the meantime
+				if (m_settings.m_browseResults == false)
+				{
+					// Display the URL in the View tab
+					mainNotebook-&gt;set_current_page(2);
+					if (m_pHtmlView-&gt;renderData(pData, dataLength, url) == true)
+					{
+						//viewstop1-&gt;set_sensitive(true);
+					}
+					set_status(locale_to_utf8(url));
+				}
+			}
+		}
+	}
+	else if (type == &quot;IndexingThread&quot;)
+	{
+		char docIdStr[64];
+
+		IndexingThread *pIndexThread = dynamic_cast&lt;IndexingThread *&gt;(pThread);
+		if (pIndexThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		const set&lt;unsigned int&gt; &amp;docIdList = pIndexThread-&gt;getDocumentIDs();
+
+		// Did the thread perform an update ?
+		if (pIndexThread-&gt;isNewDocument() == false)
+		{
+			// Yes, it did
+			status = _(&quot;Updated document&quot;);
+		}
+		else
+		{
+			string url = pIndexThread-&gt;getURL();
+			bool labeled = false;
+
+			status = _(&quot;Indexed&quot;);
+			status += &quot; &quot;;
+			status += to_utf8(url);
+
+			// Update the in-progress list
+			if (m_state.writeLock(3) == true)
+			{
+				set&lt;string&gt;::iterator urlIter = m_state.m_beingIndexed.find(url);
+				if (urlIter != m_state.m_beingIndexed.end())
+				{
+					m_state.m_beingIndexed.erase(urlIter);
+				}
+
+				m_state.unlock();
+			}
+
+			// Was the current label applied to that document ?
+			string currentLabelName;
+			if ((m_state.getCurrentLabel(currentLabelName) &gt; 0) &amp;&amp;
+				(pIndexThread-&gt;getLabelName() == currentLabelName))
+			{
+				labeled = true;
+			}
+
+			// Is the index still being shown ?
+			if (m_state.getCurrentIndex() == _(&quot;My Documents&quot;))
+			{
+				XapianIndex index(m_settings.m_indexLocation);
+				DocumentInfo docInfo;
+				string date;
+
+				// Update the index tree
+				for (set&lt;unsigned int&gt;::iterator idIter = docIdList.begin();
+					idIter != docIdList.end(); ++idIter)
+				{
+					unsigned int docId = *idIter;
+
+					// Get that document's properties
+					if (index.getDocumentInfo(docId, docInfo) == true)
+					{
+						// Append to the index tree
+						IndexedDocument indexedDoc(docInfo.getTitle(),
+							XapianEngine::buildUrl(m_settings.m_indexLocation, docId),
+							docInfo.getLocation(), docInfo.getType(),
+							docInfo.getLanguage());
+						indexedDoc.setTimestamp(docInfo.getTimestamp());
+						m_pIndexTree-&gt;appendDocument(indexedDoc, labeled);
+					}
+				}
+
+				showlabels1-&gt;set_sensitive(true);
+			}
+		}
+
+		set_status(status);
+	}
+	else if (type == &quot;UnindexingThread&quot;)
+	{
+		UnindexingThread *pUnindexThread = dynamic_cast&lt;UnindexingThread *&gt;(pThread);
+		if (pUnindexThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		if (pUnindexThread-&gt;getDocumentsCount() &gt; 0)
+		{
+			status = _(&quot;Unindexed document(s)&quot;);
+			set_status(status);
+		}
+		// Else, stay silent
+	}
+	else if (type == &quot;MonitorThread&quot;)
+	{
+		// FIXME: do something about this
+	}
+	else if (type == &quot;UpdateDocumentThread&quot;)
+	{
+		UpdateDocumentThread *pUpdateThread = dynamic_cast&lt;UpdateDocumentThread *&gt;(pThread);
+		if (pUpdateThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		m_pIndexTree-&gt;setDocumentTitle(pUpdateThread-&gt;getDocumentID(),
+			pUpdateThread-&gt;getDocumentInfo().getTitle());
+
+		status = _(&quot;Updated document&quot;);
+		set_status(status);
+	}
+	else if (type == &quot;ListenerThread&quot;)
+	{
+		// FIXME: do something about this
+	}
+
+	// Delete the thread
+	delete pThread;;
+
+	// We might be able to run a queued action
+	check_queue();
+
+	// Any threads left to return ?
+	if (get_threads_count() == 0)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_thread_end: disconnecting timeout&quot; &lt;&lt; endl;
+#endif
+		if (m_timeoutConnection.connected() == true)
+		{
+			m_timeoutConnection.block();
+			m_timeoutConnection.disconnect();
+			mainProgressbar-&gt;set_fraction(0.0);
+		}
+#ifdef DEBUG
+		else cout &lt;&lt; &quot;mainWindow::on_thread_end: not connected&quot; &lt;&lt; endl;
+#endif
+	}
+}
+
+//
+// Message reception by EnginesTree
+//
+void mainWindow::on_editindex(ustring indexName, ustring location)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::on_editindex: called&quot; &lt;&lt; endl;
+#endif
+	// Open the index properties dialog
+	indexDialog indexBox(indexName, location);
+	indexBox.show();
+	if (indexBox.run() != RESPONSE_OK)
+	{
+		return;
+	}
+
+	if ((indexName != indexBox.getName()) ||
+		(location != indexBox.getLocation()))
+	{
+		ustring newName = indexBox.getName();
+		ustring newLocation = indexBox.getLocation();
+
+		// Is the name okay ?
+		if (indexBox.badName() == true)
+		{
+			ustring statusText = _(&quot;Couldn't rename index, name&quot;);
+			statusText += &quot; &quot;;
+			statusText += newName;
+			statusText += &quot; &quot;;
+			statusText +=  _(&quot;is already in use&quot;);
+
+			// Tell user name is bad
+			set_status(statusText);
+			return;
+		}
+
+		// The only way to edit an index right now is to remove it
+		// first, then add it again
+		if ((m_settings.removeIndex(locale_from_utf8(indexName)) == false) ||
+			(m_settings.addIndex(locale_from_utf8(newName),
+				locale_from_utf8(newLocation)) == false))
+		{
+			ustring statusText = _(&quot;Couldn't rename index&quot;);
+			statusText += &quot; &quot;;
+			statusText += indexName;
+
+			// An error occured
+			set_status(statusText);
+			return;
+		}
+
+		// Refresh the engines list
+		m_pEnginesTree-&gt;populate();
+	}
+
+	set_status(_(&quot;Edited index&quot;));
+}
+
+//
+// Message reception from ListenerThread
+//
+void mainWindow::on_message_reception(DocumentInfo docInfo, string labelName)
+{
+	string location = docInfo.getLocation();
+
+	if (location.empty() == false)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_message_reception: indexing &quot; &lt;&lt; location &lt;&lt; endl;
+#endif
+		// Queue this
+		queue_index(docInfo, labelName);
+	}
+}
+
+//
+// Message reception from IndexBrowserThread
+//
+void mainWindow::on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, string indexName)
+{
+	LabelManager labelMan(m_settings.m_historyDatabase);
+	bool hasLabel = false;
+
+	if (indexName != locale_from_utf8(m_state.getCurrentIndex()))
+	{
+		// Ignore
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_message_indexupdate: &quot; &lt;&lt; indexName &lt;&lt; &quot; not current&quot; &lt;&lt; endl;
+#endif
+		return;
+	}
+
+	// Is the last page being displayed ?
+	if (m_state.m_startDoc + m_maxDocsCount &lt; m_state.m_indexDocsCount)
+	{
+		// No, so we can't add a new entry for that document
+		// Increment the count
+		++m_state.m_indexDocsCount;
+		// ...and make sure the user can display that last page
+		indexForwardButton-&gt;set_sensitive(true);
+		indexLastButton-&gt;set_sensitive(true);
+		return;
+	}
+
+	const std::map&lt;string, string&gt; &amp;indexesMap = PinotSettings::getInstance().getIndexes();
+	std::map&lt;string, string&gt;::const_iterator mapIter = indexesMap.find(indexName);
+	if (mapIter == indexesMap.end())
+	{
+		return;
+	}
+
+	// Does that document have the current label ?
+	string currentLabelName;
+	if (m_state.getCurrentLabel(currentLabelName) &gt; 0)
+	{
+		hasLabel = labelMan.hasLabel(docId, mapIter-&gt;second, currentLabelName);
+	}
+
+	// Add a row
+	if (m_pIndexTree-&gt;appendDocument(docInfo, hasLabel) == true)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_message_indexupdate: added document to index list&quot; &lt;&lt; endl;
+#endif
+		++m_state.m_indexDocsCount;
+	}
+}
+
+//
+// Message reception from importDialog
+//
+void mainWindow::on_message_import(DocumentInfo docInfo)
+{
+	string location = docInfo.getLocation();
+
+	if (location.empty() == false)
+	{
+		// Index the selected file
+		queue_index(docInfo, &quot;&quot;);
+	}
+}
+
+//
+// Session &gt; Configure menu selected
+//
+void mainWindow::on_configure_activate()
+{
+	bool useExternalBrowser = m_settings.m_browseResults;
+
+	prefsDialog prefsBox;
+	prefsBox.show();
+	if (prefsBox.run() != RESPONSE_OK)
+	{
+		return;
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::on_configure_activate: settings changed&quot; &lt;&lt; endl;
+#endif
+
+	// FIXME: if mail accounts are configured, make sure the MonitorThread
+	// is running and knows about the new accounts
+
+	// Synchronize the labels list with the new settings
+	m_pIndexTree-&gt;setCurrentLabelColour(0, 0, 0, false);
+	populate_labelMenu();
+
+	// Do the changes affect the View tab ?
+	if (useExternalBrowser != m_settings.m_browseResults)
+	{
+		int nCurrentPage = mainNotebook-&gt;get_current_page();
+		Widget *pPage = mainNotebook-&gt;get_nth_page(2);
+		if (pPage != NULL)
+		{
+			// Hide or show ?
+			if (m_settings.m_browseResults == true)
+			{
+				pPage-&gt;hide();
+			}
+			else
+			{
+				pPage-&gt;show();
+
+				// Make sure we show the same tab
+				mainNotebook-&gt;set_current_page(nCurrentPage);
+			}
+		}
+	}
+
+	// Any mail documents we should delete ?
+	const set&lt;string&gt; &amp;labelNames = prefsBox.getMailLabelsToDelete();
+	if (labelNames.empty() == false)
+	{
+		start_thread(new UnindexingThread(labelNames, locale_from_utf8(m_settings.m_mailIndexLocation)));
+	}
+}
+
+//
+// Session &gt; Quit menu selected
+//
+void mainWindow::on_quit_activate()
+{
+	on_mainWindow_delete_event(NULL);
+}
+
+//
+// Edit &gt; Cut menu selected
+//
+void mainWindow::on_cut_activate()
+{
+	// Copy
+	on_copy_activate();
+	// ...and delete
+	on_delete_activate();
+}
+
+//
+// Edit &gt; Copy menu selected
+//
+void mainWindow::on_copy_activate()
+{
+	ustring text;
+
+	if (queryTreeview-&gt;is_focus() == true)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_copy_activate: query tree&quot; &lt;&lt; endl;
+#endif
+		TreeModel::iterator iter = queryTreeview-&gt;get_selection()-&gt;get_selected();
+		TreeModel::Row row = *iter;
+		// Copy only the query name, not the summary
+		text = row[m_queryColumns.m_name];
+	}
+	else if (m_pResultsTree-&gt;is_focus() == true)
+	{
+		bool firstItem = true;
+
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_copy_activate: results tree&quot; &lt;&lt; endl;
+#endif
+		// Get the current results selection
+		vector&lt;Result&gt; resultsList;
+		m_pResultsTree-&gt;getSelection(resultsList);
+	
+		for (vector&lt;Result&gt;::const_iterator resultIter = resultsList.begin();
+			resultIter != resultsList.end(); ++resultIter)
+		{
+			if (firstItem == false)
+			{
+				text += &quot;\n&quot;;
+			}
+			text += resultIter-&gt;getTitle();
+			text += &quot; &quot;;
+			text += resultIter-&gt;getLocation();
+			firstItem = false;
+		}
+	}
+	else if (m_pIndexTree-&gt;is_focus() == true)
+	{
+		bool firstItem = true;
+
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_copy_activate: index tree&quot; &lt;&lt; endl;
+#endif
+		// Get the current documents selection
+		vector&lt;IndexedDocument&gt; documentsList;
+		m_pIndexTree-&gt;getSelection(documentsList);
+	
+		for (vector&lt;IndexedDocument&gt;::const_iterator docIter = documentsList.begin();
+			docIter != documentsList.end(); ++docIter)
+		{
+			if (firstItem == false)
+			{
+				text += &quot;\n&quot;;
+			}
+			text += docIter-&gt;getTitle();
+			text += &quot; &quot;;
+			text += docIter-&gt;getLocation();
+			firstItem = false;
+		}
+	}
+	else
+	{
+		// Only rows from the query, results and index trees can be copied
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_copy_activate: other&quot; &lt;&lt; endl;
+#endif
+		return;
+	}
+	
+	RefPtr&lt;Clipboard&gt; refClipboard = Clipboard::get();
+	refClipboard-&gt;set_text(text);
+}
+
+//
+// Edit &gt; Paste menu selected
+//
+void mainWindow::on_paste_activate()
+{
+	RefPtr&lt;Clipboard&gt; refClipboard = Clipboard::get();
+	if (refClipboard-&gt;wait_is_text_available() == false)
+	{
+		return;
+	}
+
+	ustring clipText = refClipboard-&gt;wait_for_text();
+	if (queryTreeview-&gt;is_focus() == true)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_paste_activate: query tree&quot; &lt;&lt; endl;
+#endif
+		// Use whatever text is in the clipboard as query name
+		// FIXME: look for \n as query fields separators ?
+		QueryProperties queryProps = QueryProperties(locale_from_utf8(clipText),
+			&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);
+		string summary = queryProps.toString();
+
+		// Add a new row to the query tree
+		TreeModel::iterator iter = m_refQueryTree-&gt;append();
+		TreeModel::Row row = *iter;
+		row[m_queryColumns.m_name] = clipText;
+		if (summary.empty() == false)
+		{
+			row[m_queryColumns.m_summary] = to_utf8(summary);
+		}
+		else
+		{
+			row[m_queryColumns.m_summary] = _(&quot;&lt;undefined&gt;&quot;);
+		}
+		row[m_queryColumns.m_properties] = queryProps;
+	}
+	else
+	{
+		// Only the query tree can be pasted into, others are read-only
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_paste_activate: other&quot; &lt;&lt; endl;
+#endif
+		return;
+	}
+}
+
+//
+// Edit &gt; Delete menu selected
+//
+void mainWindow::on_delete_activate()
+{
+	if (m_pResultsTree-&gt;is_focus() == true)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_delete_activate: results tree&quot; &lt;&lt; endl;
+#endif
+		if (m_pResultsTree-&gt;deleteSelection() == true)
+		{
+			// The results tree is now empty
+			clearresults1-&gt;set_sensitive(false);
+		}
+	}
+	// Nothing else can be deleted
+}
+
+//
+// Results &gt; Clear menu selected
+//
+void mainWindow::on_clearresults_activate()
+{
+	m_pResultsTree-&gt;clear();
+	clearresults1-&gt;set_sensitive(false);
+}
+
+//
+// Results &gt; Show Extract menu selected
+//
+void mainWindow::on_showextract_activate()
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::on_showextract_activate: called&quot; &lt;&lt; endl;
+#endif
+	m_pResultsTree-&gt;showExtract(showextract1-&gt;get_active());
+}
+
+//
+// Results &gt; Group menu selected
+//
+void mainWindow::on_groupresults_activate()
+{
+	ResultsModelColumns::ResultType currentType, newType;
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::on_groupresults_activate: called&quot; &lt;&lt; endl;
+#endif
+	// What's the new grouping criteria ?
+	m_pResultsTree-&gt;regroupResults(searchenginegroup1-&gt;get_active());
+}
+
+//
+// Results &gt; View menu selected
+//
+void mainWindow::on_viewresults_activate()
+{
+	ustring url = m_pResultsTree-&gt;getFirstSelectionURL();
+	if (view_document(locale_from_utf8(url)) == true)
+	{
+		// We can update the row right now
+		m_pResultsTree-&gt;setFirstSelectionViewedState(true);
+	}
+}
+
+//
+// Results &gt; View Cache menu selected
+//
+void mainWindow::on_viewcache_activate()
+{
+	ustring url = m_pResultsTree-&gt;getFirstSelectionURL();
+
+	start_thread(new DownloadingThread(url, true));
+
+	// Update the row now, even though the cached page may not be retrieved
+	m_pResultsTree-&gt;setFirstSelectionViewedState(true);
+}
+
+//
+// Results &gt; Index menu selected
+//
+void mainWindow::on_indexresults_activate()
+{
+	// Make sure this has been configured
+	if (m_settings.m_indexLocation.empty() == true)
+	{
+		set_status(_(&quot;Please set a location for the index first&quot;));
+		return;
+	}
+
+	vector&lt;Result&gt; resultsList;
+	m_pResultsTree-&gt;getSelection(resultsList);
+
+	// Go through selected results
+	for (vector&lt;Result&gt;::const_iterator resultIter = resultsList.begin();
+		resultIter != resultsList.end(); ++resultIter)
+	{
+		// Get the actual URL to download
+		string url = resultIter-&gt;getLocation();
+	
+		if (url.empty() == true)
+		{
+			set_status(_(&quot;Result location is unknown&quot;));
+			return;
+		}
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_indexresults_activate: URL is &quot; &lt;&lt; url &lt;&lt; endl;
+#endif
+		queue_index(DocumentInfo(resultIter-&gt;getTitle(), url,
+			resultIter-&gt;getType(), resultIter-&gt;getLanguage()), &quot;&quot;);
+	}
+}
+
+//
+// Index &gt; Import menu selected
+//
+void mainWindow::on_import_activate()
+{
+	importDialog importBox(_(&quot;Import Document(s)&quot;));
+
+	importBox.getImportFileSignal().connect(SigC::slot(*this,
+		&amp;mainWindow::on_message_import));
+	importBox.show();
+	importBox.run();
+	// Let the signal handler deal with mporting stuff
+}
+
+//
+// Index &gt; View menu selected
+//
+void mainWindow::on_viewfromindex_activate()
+{
+	// View the first document, don't bother about the rest
+	ustring url = m_pIndexTree-&gt;getFirstSelectionLiveURL();
+	view_document(locale_from_utf8(url));
+}
+
+//
+// Index &gt; Refresh menu selected
+//
+void mainWindow::on_refreshindex_activate()
+{
+	// Make sure this has been configured
+	if (m_settings.m_indexLocation.empty() == true)
+	{
+		set_status(_(&quot;Please set a location for the index first&quot;));
+		return;
+	}
+
+	// Get the current documents selection
+	vector&lt;IndexedDocument&gt; documentsList;
+	m_pIndexTree-&gt;getSelection(documentsList);
+
+	for (vector&lt;IndexedDocument&gt;::const_iterator docIter = documentsList.begin();
+		docIter != documentsList.end(); ++docIter)
+	{
+		// The URL to download, ie the original location of the document
+		string url = docIter-&gt;getOriginalLocation();
+		if (url.empty() == true)
+		{
+			continue;
+		}
+
+		// The document ID
+		unsigned int docId = docIter-&gt;getID();
+		if (docId == 0)
+		{
+			continue;
+		}
+
+		// The title
+		string title = docIter-&gt;getTitle();
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_refreshindex_activate: URL is &quot; &lt;&lt; url &lt;&lt; endl;
+#endif
+
+		// Add this action to the queue
+		queue_index(*docIter, &quot;&quot;, docId);
+	}
+}
+
+//
+// Index &gt; Show Properties menu selected
+//
+void mainWindow::on_showfromindex_activate()
+{
+	LabelManager labelMan(m_settings.m_historyDatabase);
+	vector&lt;IndexedDocument&gt; documentsList;
+	set&lt;string&gt; docLabels;
+	DocumentInfo docInfo;
+	unsigned int docId = 0;
+	int width, height;
+	bool matchedLabel = false, editTitle = false;
+
+	const std::map&lt;string, string&gt; &amp;indexesMap = PinotSettings::getInstance().getIndexes();
+	std::map&lt;string, string&gt;::const_iterator mapIter = indexesMap.find(m_state.getCurrentIndex());	
+	if (mapIter == indexesMap.end())
+	{
+		ustring statusText = _(&quot;Index&quot;);
+		statusText += &quot; &quot;;
+		statusText += m_state.getCurrentIndex();
+		statusText += &quot; &quot;;
+		statusText += _(&quot;doesn't exist&quot;);
+		set_status(statusText);
+		return;
+	}
+
+	// Get the current documents selection
+	m_pIndexTree-&gt;getSelection(documentsList);
+
+	// If there's only one document selected, get its labels
+	if (documentsList.size() == 1)
+	{
+		vector&lt;IndexedDocument&gt;::const_iterator docIter = documentsList.begin();
+
+		// Get the document ID
+		Url urlObj(docIter-&gt;getLocation());
+		docId = (unsigned int)atoi(urlObj.getFile().c_str());
+		if (docId &gt; 0)
+		{
+			labelMan.getLabels(docId, mapIter-&gt;second, docLabels);
+
+			// Does it match the current label ?
+			string currentLabelName;
+			if ((m_state.getCurrentLabel(currentLabelName) &gt; 0) &amp;&amp;
+				(find(docLabels.begin(), docLabels.end(), currentLabelName) != docLabels.end()))
+			{
+				matchedLabel = true;
+			}
+		}
+
+		docInfo.setTitle(docIter-&gt;getTitle());
+		docInfo.setLocation(docIter-&gt;getOriginalLocation());
+		docInfo.setType(docIter-&gt;getType());
+		docInfo.setLanguage(docIter-&gt;getLanguage());
+		docInfo.setTimestamp(docIter-&gt;getTimestamp());
+		editTitle = true;
+	}
+	// Else, start with a blank list
+
+	// Let the user set the labels
+	get_size(width, height);
+	propertiesDialog propertiesBox(docLabels, docInfo, editTitle);
+	propertiesBox.setHeight(height / 2);
+	propertiesBox.show();
+	if (propertiesBox.run() != RESPONSE_OK)
+	{
+		return;
+	}
+	const set&lt;string&gt; &amp;labels = propertiesBox.getLabels();
+
+	// Now apply these labels to all documents
+	for (vector&lt;IndexedDocument&gt;::const_iterator docIter = documentsList.begin();
+		docIter != documentsList.end(); ++docIter)
+	{
+		// Check the document ID
+		unsigned int docId = docIter-&gt;getID();
+		if (docId == 0)
+		{
+			continue;
+		}
+		// Set the document's labels list
+		labelMan.setLabels(docId, mapIter-&gt;second, labels);
+	}
+
+	if ((documentsList.size() == 1) &amp;&amp;
+		(docId &gt; 0))
+	{
+		bool matchesLabel = false;
+
+		// Does the sole selected document match the current label now ?
+		string currentLabelName;
+		if ((m_state.getCurrentLabel(currentLabelName) &gt; 0) &amp;&amp;
+			(find(labels.begin(), labels.end(), currentLabelName) != labels.end()))
+		{
+			matchesLabel = true;
+		}
+
+		// Was there any change ?
+		if (matchesLabel != matchedLabel)
+		{
+			// Update this document to the index tree
+			m_pIndexTree-&gt;setDocumentLabeledState(docId, matchesLabel);
+		}
+
+		string newTitle = propertiesBox.getDocumentInfo().getTitle();
+		if (newTitle != docInfo.getTitle())
+		{
+			docInfo.setTitle(newTitle);
+			
+			// Update the document's title
+			start_thread(new UpdateDocumentThread(m_state.getCurrentIndex(), docId, docInfo));
+		}
+	}
+	else
+	{
+		string currentLabelName;
+
+		// Because the current label may have been applied to or removed from
+		// one or more of the selected documents, refresh the list of matching documents
+		m_state.getCurrentLabel(currentLabelName);
+		start_thread(new LabelQueryThread(m_state.getCurrentIndex(), currentLabelName));
+	}
+}
+
+//
+// Index &gt; Unindex menu selected
+//
+void mainWindow::on_unindex_activate()
+{
+	ustring boxTitle = _(&quot;Delete this document from the index ?&quot;);
+
+	// Get the current documents selection
+	vector&lt;IndexedDocument&gt; documentsList;
+	if (m_pIndexTree-&gt;getSelection(documentsList) == false)
+	{
+		return;
+	}
+
+	if (documentsList.size() &gt; 1)
+	{
+		boxTitle = _(&quot;Delete these documents from the index ?&quot;);
+	}
+
+	// Ask for confirmation
+	MessageDialog msgDialog(boxTitle, false, MESSAGE_QUESTION, BUTTONS_YES_NO);
+	msgDialog.set_transient_for(*this);
+	msgDialog.show();
+	int result = msgDialog.run();
+	if (result == RESPONSE_NO)
+	{
+		return;
+	}
+
+	// Remove these documents from the tree
+	if (m_pIndexTree-&gt;deleteSelection() == true)
+	{
+		// The index tree is now empty
+		showlabels1-&gt;set_sensitive(false);
+	}
+
+	set&lt;unsigned int&gt; docIdList;
+	for (vector&lt;IndexedDocument&gt;::const_iterator docIter = documentsList.begin();
+		docIter != documentsList.end(); ++docIter)
+	{
+		// Get the actual URL of the document to delete
+		string url = docIter-&gt;getLocation();
+		string liveUrl = docIter-&gt;getOriginalLocation();
+		if (url.empty() == true)
+		{
+			continue;
+		}
+
+		unsigned int docId = docIter-&gt;getID();
+		if (docId &gt; 0)
+		{
+			docIdList.insert(docId);
+		}
+	}
+
+	if (docIdList.empty() == false)
+	{
+		// Queue this action
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_unindex_activate: &quot; &lt;&lt; docIdList.size() &lt;&lt; &quot; documents to unindex&quot; &lt;&lt; endl;
+#endif
+		queue_unindex(docIdList);
+	}
+}
+
+//
+// Help &gt; About menu selected
+//
+void mainWindow::on_about_activate()
+{
+	aboutDialog aboutBox;
+	aboutBox.show();
+	aboutBox.run();
+}
+
+//
+// Activity timeout elapsed
+//
+bool mainWindow::on_activity_timeout()
+{
+	if (m_timeoutConnection.blocked() == false)
+	{
+		mainProgressbar-&gt;pulse();
+	}
+#ifdef DEBUG
+	else cout &lt;&lt; &quot;mainWindow::on_activity_timeout: blocked&quot; &lt;&lt; endl;
+#endif
+
+	return true;
+}
+
+//
+// Add index button click
+//
+void mainWindow::on_addIndexButton_clicked()
+{
+	// Open the index properties dialog
+	indexDialog indexBox;
+	indexBox.show();
+	if (indexBox.run() != RESPONSE_OK)
+	{
+		return;
+	}
+
+	ustring name = indexBox.getName();
+	ustring location = indexBox.getLocation();
+
+	// Is the name okay ?
+	if (indexBox.badName() == true)
+	{
+		ustring statusText = _(&quot;Index name&quot;);
+		statusText += &quot; &quot;;
+		statusText += name;
+		statusText += &quot; &quot;;
+		statusText +=  _(&quot;is already in use&quot;);
+
+		// Tell user name is bad
+		set_status(statusText);
+		return;
+	}
+
+	// Add the new index
+	if (m_settings.addIndex(locale_from_utf8(name),
+			locale_from_utf8(location)) == false)
+	{
+		ustring statusText = _(&quot;Couldn't add index&quot;);
+		statusText += &quot; &quot;;
+		statusText += name;
+
+		// An error occured
+		set_status(statusText);
+	}
+	else
+	{
+		// Refresh the indexes list
+		removeIndexButton-&gt;set_sensitive(false);
+		m_pEnginesTree-&gt;populate();
+	}
+
+	set_status(_(&quot;Added new index&quot;));
+}
+
+//
+// Remove index button click
+//
+void mainWindow::on_removeIndexButton_clicked()
+{
+	list&lt;TreeModel::Path&gt; selectedEngines = m_pEnginesTree-&gt;getSelection();
+	// If there are more than one row selected, don't bother
+	if (selectedEngines.size() != 1)
+	{
+		return;
+	}
+
+	list&lt;TreeModel::Path&gt;::iterator enginePath = selectedEngines.begin();
+	if (enginePath == selectedEngines.end())
+	{
+		return;
+	}
+
+	TreeModel::iterator engineIter = m_pEnginesTree-&gt;getIter(*enginePath);
+	TreeModel::Row engineRow = *engineIter;
+
+	// Make sure the engine is an external index
+	EnginesModelColumns &amp;engineColumns = m_pEnginesTree-&gt;getColumnRecord();
+	EnginesModelColumns::EngineType engineType = engineRow[engineColumns.m_type];
+	if (engineType == EnginesModelColumns::INDEX_ENGINE)
+	{
+		ustring name = engineRow[engineColumns.m_name];
+
+		// Remove it
+		// FIXME: ask for confirmation ?
+		if (m_settings.removeIndex(locale_from_utf8(name)) == false)
+		{
+			ustring statusText = _(&quot;Couldn't remove index&quot;);
+			statusText += &quot; &quot;;
+			statusText += name;
+
+			// An error occured
+			set_status(statusText);
+		}
+		else
+		{
+			// Refresh the indexes list
+			removeIndexButton-&gt;set_sensitive(false);
+			m_pEnginesTree-&gt;populate();
+		}
+	}
+
+}
+
+//
+// Find button click
+//
+void mainWindow::on_findButton_clicked()
+{
+	QueryProperties queryProps;
+
+	queryProps.setName(&quot;Live query&quot;);
+	// FIXME: parse the query string !
+	queryProps.setAnyWords(locale_from_utf8(liveQueryEntry-&gt;get_text()));
+
+	run_search(queryProps);
+}
+
+//
+// Add query button click
+//
+void mainWindow::on_addQueryButton_clicked()
+{
+	QueryProperties queryProps = QueryProperties(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);
+
+	// Start with editing the new query's properties
+	queryDialog queryBox(queryProps);
+	queryBox.show();
+	if (queryBox.run() == RESPONSE_OK)
+	{
+		// Is the name okay ?
+		if (queryBox.badName() == true)
+		{
+			ustring statusText = _(&quot;Query name&quot;);
+			statusText += &quot; &quot;;
+			statusText += queryProps.getName();
+			statusText += &quot; &quot;;
+			statusText +=  _(&quot;is already in use&quot;);
+
+			// Tell user name is bad
+			set_status(statusText);
+			return;
+		}
+
+		// Add the new query
+		if (m_settings.addQuery(queryProps) == false)
+		{
+			ustring statusText = _(&quot;Couldn't add query&quot;);
+			statusText += &quot; &quot;;
+			statusText += queryProps.getName();
+
+			set_status(statusText);
+			return;
+		}
+
+		populate_queryTreeview();
+		set_status(_(&quot;Added new query&quot;));
+	}
+}
+
+//
+// Edit query button click
+//
+void mainWindow::on_editQueryButton_clicked()
+{
+	TreeModel::iterator iter = queryTreeview-&gt;get_selection()-&gt;get_selected();
+	// Anything selected ?
+	if (iter)
+	{
+		TreeModel::Row row = *iter;
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_editQueryButton_clicked: selected &quot; &lt;&lt; row[m_queryColumns.m_name] &lt;&lt; endl;
+#endif
+
+		// Backup the current name
+		ustring queryName = row[m_queryColumns.m_name];
+
+		// Edit this query's properties
+		QueryProperties queryProps = row[m_queryColumns.m_properties];
+		queryDialog queryBox(queryProps);
+		queryBox.show();
+		if (queryBox.run() != RESPONSE_OK)
+		{
+			// Nothing to do
+			return;
+		}
+
+		// Is the name okay ?
+		if (queryBox.badName() == true)
+		{
+			ustring statusText = _(&quot;Query name&quot;);
+			statusText += &quot; &quot;;
+			statusText += queryProps.getName();
+			statusText += &quot; &quot;;
+			statusText +=  _(&quot;is already in use&quot;);
+
+			// Tell user name is bad
+			set_status(statusText);
+			return;
+		}
+
+		// Did the name change ?
+		ustring newQueryName = to_utf8(queryProps.getName());
+		if (newQueryName != queryName)
+		{
+			// Remove records from QueryHistory
+			string queryName = locale_from_utf8(row[m_queryColumns.m_name]);
+			QueryHistory history(m_settings.m_historyDatabase);
+			history.deleteItems(queryName, true);
+		}
+
+		// Update the query properties
+		if ((m_settings.removeQuery(queryName) == false) ||
+			(m_settings.addQuery(queryProps) == false))
+		{
+			ustring statusText = _(&quot;Couldn't update query&quot;);
+			statusText += &quot; &quot;;
+			statusText += queryName;
+
+			set_status(statusText);
+			return;
+		}
+
+		populate_queryTreeview();
+		set_status(_(&quot;Edited query&quot;));
+	}
+}
+
+//
+// Remove query button click
+//
+void mainWindow::on_removeQueryButton_clicked()
+{
+	TreeModel::iterator iter = queryTreeview-&gt;get_selection()-&gt;get_selected();
+	// Anything selected ?
+	if (iter)
+	{
+		TreeModel::Row row = *iter;
+		string queryName = locale_from_utf8(row[m_queryColumns.m_name]);
+
+		if (m_settings.removeQuery(queryName) == true)
+		{
+			// Remove records from QueryHistory
+			QueryHistory history(m_settings.m_historyDatabase);
+			history.deleteItems(queryName, true);
+
+			// Select another row
+			queryTreeview-&gt;get_selection()-&gt;unselect(iter);
+			TreeModel::Path path = m_refQueryTree-&gt;get_path(iter);
+			path.next();
+			queryTreeview-&gt;get_selection()-&gt;select(path);
+			// Erase
+			m_refQueryTree-&gt;erase(row);
+
+			queryTreeview-&gt;columns_autosize();
+		}
+	}
+}
+
+//
+// Find query button click
+//
+void mainWindow::on_findQueryButton_clicked()
+{
+	TreeModel::iterator queryIter = queryTreeview-&gt;get_selection()-&gt;get_selected();
+	// Anything selected ?
+	if (queryIter)
+	{
+		TreeModel::Row queryRow = *queryIter;
+
+		QueryProperties queryProps = queryRow[m_queryColumns.m_properties];
+		run_search(queryProps);
+
+		// Update the Last Run column
+		queryRow[m_queryColumns.m_lastRun] = TimeConverter::toTimestamp(time(NULL));
+	}
+}
+
+//
+// Index list mouse click
+//
+void mainWindow::on_indexCombobox_changed()
+{
+	TreeModel::iterator indexIter = indexCombobox-&gt;get_active();
+	if (indexIter)
+	{
+		TreeModel::Row row = *indexIter;
+
+		ustring indexName = row[m_indexNameColumns.m_name];
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::on_indexCombobox_changed: current index now &quot; &lt;&lt; indexName &lt;&lt; endl;
+#endif
+		ustring currentIndexName = m_state.getCurrentIndex();
+		m_state.setCurrentIndex(indexName);
+		if ((currentIndexName.empty() == false) &amp;&amp;
+			(currentIndexName != indexName))
+		{
+			// Force a refresh if the selected index has changed
+			m_state.m_startDoc = m_state.m_indexDocsCount = 0;
+			on_indexForwardButton_clicked();
+		}
+	}
+}
+
+//
+// Index first button click
+//
+void mainWindow::on_indexFirstButton_clicked()
+{
+	m_state.m_startDoc = 0;
+	browse_index(m_state.m_startDoc);
+}
+
+//
+// Index back button click
+//
+void mainWindow::on_indexBackButton_clicked()
+{
+	if (m_state.m_startDoc &gt;= m_maxDocsCount)
+	{
+		m_state.m_startDoc -= m_maxDocsCount;
+		browse_index(m_state.m_startDoc);
+	}
+}
+
+//
+// Index forward button click
+//
+void mainWindow::on_indexForwardButton_clicked()
+{
+	if (m_state.m_indexDocsCount == 0)
+	{
+		m_state.m_startDoc = 0;
+		browse_index(m_state.m_startDoc);
+	}
+	else if (m_state.m_indexDocsCount &gt;= m_state.m_startDoc + m_maxDocsCount)
+	{
+		m_state.m_startDoc += m_maxDocsCount;
+		browse_index(m_state.m_startDoc);
+	}
+}
+
+//
+// Index last button click
+//
+void mainWindow::on_indexLastButton_clicked()
+{
+	if (m_state.m_indexDocsCount &gt;= m_state.m_startDoc + m_maxDocsCount)
+	{
+		m_state.m_startDoc = m_state.m_indexDocsCount - (m_state.m_indexDocsCount % m_maxDocsCount);
+		browse_index(m_state.m_startDoc);
+	}
+}
+
+//
+// Query list mouse click
+//
+bool mainWindow::on_queryTreeview_button_press_event(GdkEventButton *ev)
+{
+	// Check for double clicks
+	if (ev-&gt;type == GDK_2BUTTON_PRESS)
+	{
+		on_editQueryButton_clicked();
+	}
+
+	return false;
+}
+
+//
+// Main window deleted
+//
+bool mainWindow::on_mainWindow_delete_event(GdkEventAny *ev)
+{
+	// Any thread still running ?
+	if (get_threads_count() &gt; 0)
+	{
+		ustring boxTitle = _(&quot;At least one background task hasn't been completed yet. Quit now ?&quot;);
+		MessageDialog msgDialog(boxTitle, false, MESSAGE_QUESTION, BUTTONS_YES_NO);
+		msgDialog.set_transient_for(*this);
+		msgDialog.show();
+		int result = msgDialog.run();
+		if (result == RESPONSE_NO)
+		{
+			return true;
+		}
+
+		if (m_state.readLock(4) == true)
+		{
+			for (set&lt;WorkerThread *&gt;::iterator threadIter = m_state.m_pThreads.begin();
+				threadIter != m_state.m_pThreads.end(); ++threadIter)
+			{
+#ifdef DEBUG
+				cout &lt;&lt; &quot;mainWindow::on_mainWindow_delete_event: stopping thread&quot; &lt;&lt; endl;
+#endif
+				// Stop all non-background threads
+				if ((*threadIter)-&gt;isBackground() == false)
+				{
+					// FIXME: what if one thread doesn't stop ? can it corrupt anything ?
+					(*threadIter)-&gt;stop();
+				}
+			}
+
+			m_state.unlock();
+		}
+	}
+
+	// Save the window's position and dimensions now
+	// Don't worry about the gravity, it hasn't been changed
+	get_position(m_settings.m_xPos, m_settings.m_yPos);
+	get_size(m_settings.m_width, m_settings.m_height);
+	m_settings.m_panePos = mainHpaned-&gt;get_position();
+
+	Main::quit();
+	return false;
+}
+
+//
+// Queues additions to the index.
+//
+bool mainWindow::queue_index(const DocumentInfo &amp;docInfo,
+	const string &amp;labelName, unsigned int docId)
+{
+	ActionHistory::ActionType type = ActionHistory::ACTION_INDEX;
+
+	if (docId &gt; 0)
+	{
+		// This is an update
+		type = ActionHistory::ACTION_UPDATE;
+	}
+
+	if (get_threads_count() &gt;= m_maxThreads)
+	{
+		ActionHistory history(m_settings.m_historyDatabase);
+
+		string option = docInfo.getTitle();
+		option += &quot;|&quot;;
+		option += Url::escapeUrl(docInfo.getLocation());
+		option += &quot;|&quot;;
+		option += docInfo.getType();
+		option += &quot;|&quot;;
+		option += labelName;
+		if (type == ActionHistory::ACTION_UPDATE)
+		{
+			option += &quot;|&quot;;
+			char docIdStr[64];
+			snprintf(docIdStr, 64, &quot;%d&quot;, docId);
+			option += docIdStr;
+		}
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::queue_index: &quot; &lt;&lt; option &lt;&lt; endl;
+#endif
+
+		// Add this to ActionHistory and return
+		return history.insertItem(type, option);
+	}
+
+	if (type == ActionHistory::ACTION_UPDATE)
+	{
+		// Update the document
+		index_document(docInfo, labelName, docId);
+	}
+	else
+	{
+		// Index the document
+		index_document(docInfo, labelName);
+	}
+
+	return false;
+}
+
+//
+// Queues index removals.
+//
+bool mainWindow::queue_unindex(set&lt;unsigned int&gt; &amp;docIdList)
+{
+	// Delete the document(s) right away
+	start_thread(new UnindexingThread(docIdList));
+
+	return false;
+}
+
+//
+// Runs a search
+//
+void mainWindow::run_search(const QueryProperties &amp;queryProps)
+{
+	string querySummary = queryProps.toString();
+	if (querySummary.empty() == true)
+	{
+		set_status(_(&quot;Query is not set&quot;));
+		return;
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::run_search: query name is &quot; &lt;&lt; queryProps.getName() &lt;&lt; endl;
+#endif
+
+	// Check a search engine has been selected
+	list&lt;TreeModel::Path&gt; selectedEngines = m_pEnginesTree-&gt;getSelection();
+	if (selectedEngines.empty() == true)
+	{
+		set_status(_(&quot;No search engine selected&quot;));
+		return;
+	}
+
+	// Go through the tree and check selected nodes
+	vector&lt;TreeModel::iterator&gt; engineIters;
+	EnginesModelColumns &amp;engineColumns = m_pEnginesTree-&gt;getColumnRecord();
+	for (list&lt;TreeModel::Path&gt;::iterator enginePath = selectedEngines.begin();
+		enginePath != selectedEngines.end(); ++enginePath)
+	{
+		TreeModel::iterator engineIter = m_pEnginesTree-&gt;getIter(*enginePath);
+		TreeModel::Row engineRow = *engineIter;
+
+		EnginesModelColumns::EngineType engineType = engineRow[engineColumns.m_type];
+		if (engineType &lt; EnginesModelColumns::ENGINE_FOLDER)
+		{
+			// Skip
+			continue;
+		}
+
+		// Is it a folder ?
+		if (engineType == EnginesModelColumns::ENGINE_FOLDER)
+		{
+			TreeModel::Children children = engineIter-&gt;children();
+			for (TreeModel::Children::iterator folderEngineIter = children.begin();
+				folderEngineIter != children.end(); ++folderEngineIter)
+			{
+				TreeModel::Row folderEngineRow = *folderEngineIter;
+
+				EnginesModelColumns::EngineType engineType = engineRow[engineColumns.m_type];
+				if (engineType &lt; EnginesModelColumns::ENGINE_FOLDER)
+				{
+					// Skip
+					continue;
+				}
+
+				engineIters.push_back(folderEngineIter);
+			}
+		}
+		else
+		{
+			engineIters.push_back(engineIter);
+		}
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::run_search: selected &quot; &lt;&lt; engineIters.size()
+		&lt;&lt; &quot; engines&quot; &lt;&lt; endl;
+#endif
+
+	// Now go through the selected search engines
+	set&lt;ustring&gt; engineDisplayableNames;
+	for (vector&lt;TreeModel::iterator&gt;::iterator iter = engineIters.begin();
+		iter != engineIters.end(); ++iter)
+	{
+		TreeModel::Row engineRow = **iter;
+
+		// Check whether this engine has already been done
+		// Using a set&lt;TreeModel::iterator/Row&gt; would be preferable
+		// but is not helpful here
+		ustring engineDisplayableName = engineRow[engineColumns.m_name];
+		if (engineDisplayableNames.find(engineDisplayableName) != engineDisplayableNames.end())
+		{
+			continue;
+		}
+		engineDisplayableNames.insert(engineDisplayableName);
+
+		ustring engineName = engineRow[engineColumns.m_engineName];
+		ustring engineOption = engineRow[engineColumns.m_option];
+		EnginesModelColumns::EngineType engineType = engineRow[engineColumns.m_type];
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::run_search: engine &quot; &lt;&lt; engineDisplayableName &lt;&lt; endl;
+#endif
+
+		// Is it a web engine ?
+		if (engineType == EnginesModelColumns::WEB_ENGINE)
+		{
+			// There's a special case for the Google API...
+			if (engineName == &quot;googleapi&quot;)
+			{
+				// Make sure this has been configured
+				if (m_settings.m_googleAPIKey.empty() == true)
+				{
+					set_status(_(&quot;Please set the Google API key first&quot;));
+					// Skip this engine
+					continue;
+				}
+				// Option is the Google API key
+				engineOption = m_settings.m_googleAPIKey;
+			}
+		}
+
+		ustring status = _(&quot;Running query&quot;);
+		status += &quot; \&quot;&quot;;
+		status += to_utf8(queryProps.getName());
+		status += &quot;\&quot; &quot;;
+		status += _(&quot;on&quot;);
+		status += &quot; &quot;;
+		status += engineDisplayableName;
+		set_status(status);
+
+		// Spawn a new thread
+		start_thread(new QueryingThread(locale_from_utf8(engineName),
+			locale_from_utf8(engineDisplayableName), engineOption, queryProps));
+	}
+}
+
+//
+// Browse an index
+//
+void mainWindow::browse_index(unsigned int startDoc)
+{
+	bool enableIndexOps = false;
+
+	// Rudimentary lock
+	if (m_state.m_browsingIndex == true)
+	{
+		return;
+	}
+	m_state.m_browsingIndex = true;
+
+	// Remove existing rows in the index tree
+	m_pIndexTree-&gt;clear();
+	// Disable this
+	showlabels1-&gt;set_sensitive(false);
+	// Reset variables
+	m_state.m_indexDocsCount = 0;
+
+	if (m_state.getCurrentIndex() == _(&quot;My Documents&quot;))
+	{
+		enableIndexOps = true;
+	}
+	import1-&gt;set_sensitive(enableIndexOps);
+
+	// Spawn a new thread to browse the index
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::browse_index: indexing &quot; &lt;&lt; m_state.getCurrentIndex() &lt;&lt; endl;
+#endif
+	IndexBrowserThread *pBrowseThread = new IndexBrowserThread(
+		locale_from_utf8(m_state.getCurrentIndex()), m_maxDocsCount, startDoc);
+	pBrowseThread-&gt;getUpdateSignal().connect(SigC::slot(*this,
+		&amp;mainWindow::on_message_indexupdate));
+	start_thread(pBrowseThread);
+}
+
+//
+// Index (or update) a document
+//
+void mainWindow::index_document(const DocumentInfo &amp;docInfo,
+	const string &amp;labelName, unsigned int docId)
+{
+	LabelManager labelMan(m_settings.m_historyDatabase);
+	Url urlObj(docInfo.getLocation());
+	string indexName = m_settings.m_indexLocation;
+
+	// If the document is mail, we need to check My Email
+	if (urlObj.getProtocol() == &quot;mailbox&quot;)
+	{
+		indexName = m_settings.m_mailIndexLocation;
+	}
+
+	// Is it an update ?
+	if (docId &gt; 0)
+	{
+		// Yes, it is
+		start_thread(new IndexingThread(docInfo, docId));
+	}
+	else
+	{
+		XapianIndex index(indexName);
+		string url(docInfo.getLocation());
+		bool isNewDocument = false;
+
+		// No : see if the document is already indexed
+		// or is being indexed
+		if (index.isGood() == true)
+		{
+			docId = index.hasDocument(docInfo);
+		}
+		if ((docId == 0) &amp;&amp;
+			(m_state.writeLock(4) == true))
+		{
+			if (m_state.m_beingIndexed.find(url) == m_state.m_beingIndexed.end())
+			{
+				m_state.m_beingIndexed.insert(url);
+				isNewDocument = true;
+			}
+#ifdef DEBUG
+			else cout &lt;&lt; &quot;mainWindow::index_document: already indexed &quot; &lt;&lt; url &lt;&lt; endl;
+#endif
+
+			m_state.unlock();
+		}
+
+		if (isNewDocument == true)
+		{
+			// This is a new document
+			start_thread(new IndexingThread(docInfo, labelName));
+		}
+	}
+
+	// If the document is indexed, we may have to update its labels
+	if ((docId &gt; 0) &amp;&amp;
+		(labelName.empty() == false))
+	{
+		set&lt;string&gt; docLabels;
+
+		// Get the labels for this document
+		labelMan.getLabels(docId, indexName, docLabels);
+
+		// Add this new label if it's not in
+		if (find(docLabels.begin(), docLabels.end(), labelName) == docLabels.end())
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;mainWindow::index_document: applying label &quot; &lt;&lt; labelName &lt;&lt; &quot; to document &quot; &lt;&lt; docId &lt;&lt; endl;
+#endif
+			// Update the document's labels list
+			docLabels.insert(labelName);
+			labelMan.setLabels(docId, indexName, docLabels);
+
+			// Is this the current label ?
+			string currentLabelName;
+			if ((m_state.getCurrentLabel(currentLabelName) &gt; 0) &amp;&amp;
+				(labelName == currentLabelName))
+			{
+				// Update this document in the index tree
+				m_pIndexTree-&gt;setDocumentLabeledState(docId, true);
+			}
+		}
+#ifdef DEBUG
+		else cout &lt;&lt; &quot;mainWindow::index_document: label &quot; &lt;&lt; labelName &lt;&lt; &quot; already applied to document &quot; &lt;&lt; docId &lt;&lt; endl;
+#endif
+	}
+}
+
+//
+// View a document
+//
+bool mainWindow::view_document(const string &amp;url, bool internalViewerOnly)
+{
+	if (url.empty() == true)
+	{
+		set_status(_(&quot;No URL to browse&quot;));
+		return false;
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::view_document: URL is &quot; &lt;&lt; url &lt;&lt; endl;
+#endif
+
+	// Is browsing enabled ?
+	if ((internalViewerOnly == false) &amp;&amp;
+		(m_settings.m_browseResults == true))
+	{
+		// Point user-defined browser to that URL
+		if (m_settings.m_browserCommand.empty() == true)
+		{
+			set_status(_(&quot;No browser configured to view results&quot;));
+			return false;
+		}
+
+		string shellCommand = locale_from_utf8(m_settings.m_browserCommand);
+		// FIXME: do substitutions
+		shellCommand += &quot; \&quot;&quot;;
+		shellCommand += url;
+		shellCommand += &quot;\&quot; &amp;&quot;;
+		if ((url.empty() == true) ||
+			(system(shellCommand.c_str()) == -1))
+		{
+			ustring status = _(&quot;Couldn't browse URL:&quot;);
+			status == &quot; &quot;;
+			status += Glib::strerror(errno);
+			set_status(status);
+		}
+	}
+	else
+	{
+		Url urlObj(url);
+
+		// FIXME: there should be a way to know which protocols can be viewed/indexed
+		if (urlObj.getProtocol() == &quot;mailbox&quot;)
+		{
+			// Get that message
+			start_thread(new DownloadingThread(url, false));
+		}
+		else
+		{
+			// Display the URL in the View tab
+			mainNotebook-&gt;set_current_page(2);
+			if (m_pHtmlView-&gt;renderUrl(url) == true)
+			{
+				//viewstop1-&gt;set_sensitive(true);
+			}
+			set_status(locale_to_utf8(m_pHtmlView-&gt;getLocation()));
+		}
+	}
+
+	// Record this into the history
+	ViewHistory viewHistory(m_settings.m_historyDatabase);
+	if (viewHistory.hasItem(url) == false)
+	{
+		viewHistory.insertItem(url);
+	}
+
+	return true;
+}
+
+//
+// Start of worker thread
+//
+void mainWindow::start_thread(WorkerThread *pNewThread, bool inBackground)
+{
+	static unsigned int nextId = 1;
+	bool insertedThread = false;
+
+	if (pNewThread == NULL)
+	{
+		return;
+	}
+
+	pNewThread-&gt;setId(nextId);
+	// Connect to the finished signal
+	pNewThread-&gt;getFinishedSignal().connect(SigC::slot(*this,
+		&amp;mainWindow::on_thread_end));
+
+	if (m_state.writeLock(5) == true)
+	{
+		pair&lt;set&lt;WorkerThread *&gt;::iterator, bool&gt; insertPair = m_state.m_pThreads.insert(pNewThread);
+		insertedThread = insertPair.second;
+
+		m_state.unlock();
+	}
+
+	// Was it inserted ?
+	if (insertedThread == false)
+	{
+		// No, it wasn't : delete the object and return
+		cerr &lt;&lt; &quot;mainWindow::start_thread: couldn't start &quot;
+			&lt;&lt; pNewThread-&gt;getType() &lt;&lt; &quot; &quot; &lt;&lt; pNewThread-&gt;getId() &lt;&lt; endl;
+		delete pNewThread;
+
+		return;
+	}
+
+	// Start the thread
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::start_thread: start of &quot; &lt;&lt; pNewThread-&gt;getType()
+		&lt;&lt; &quot; &quot; &lt;&lt; pNewThread-&gt;getId() &lt;&lt; endl;
+#endif
+	if (inBackground == true)
+	{
+		pNewThread-&gt;inBackground();
+		++m_state.m_backgroundThreads;
+	}
+	pNewThread-&gt;start();
+
+	if (inBackground == false)
+	{
+		// Enable the activity progress bar
+		m_timeoutConnection.block();
+		m_timeoutConnection.disconnect();
+		m_timeoutConnection = Glib::signal_timeout().connect(SigC::slot(*this,
+			&amp;mainWindow::on_activity_timeout), 1000);
+		m_timeoutConnection.unblock();
+		// Update the status
+		update_threads_status();
+	}
+	++nextId;
+}
+
+//
+// Checks the queue and runs the oldest action if possible.
+//
+bool mainWindow::check_queue(void)
+{
+	if (get_threads_count() &gt;= m_maxThreads)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::check_queue: too many threads&quot; &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	ActionHistory history(m_settings.m_historyDatabase);
+	ActionHistory::ActionType type;
+	string option;
+
+	if (history.deleteOldestItem(type, option) == false)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;mainWindow::check_queue: found no action&quot; &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	if (type == ActionHistory::ACTION_INDEX)
+	{
+		string::size_type lastPos = 0, pos = option.find_first_of(&quot;|&quot;);
+		if (pos != string::npos)
+		{
+			string title = option.substr(lastPos, pos - lastPos);
+
+			lastPos = pos + 1;
+			pos = option.find_first_of(&quot;|&quot;, lastPos);
+			if (pos != string::npos)
+			{
+				string url = option.substr(lastPos, pos - lastPos);
+
+				lastPos = pos + 1;
+				pos = option.find_first_of(&quot;|&quot;, lastPos);
+				if (pos != string::npos)
+				{
+					string type = option.substr(lastPos, pos - lastPos);
+
+					string labelName = option.substr(pos + 1);
+
+					// Index the document
+					index_document(DocumentInfo(title, Url::unescapeUrl(url), type, &quot;&quot;),
+						labelName);
+				}
+			}
+		}
+	}
+	else if (type == ActionHistory::ACTION_UPDATE)
+	{
+		string::size_type lastPos = 0, pos = option.find_first_of(&quot;|&quot;);
+		if (pos != string::npos)
+		{
+			string title = option.substr(lastPos, pos - lastPos);
+
+			lastPos = pos + 1;
+			pos = option.find_first_of(&quot;|&quot;, lastPos);
+			if (pos != string::npos)
+			{
+				string url = option.substr(lastPos, pos - lastPos);
+
+				lastPos = pos + 1;
+				pos = option.find_first_of(&quot;|&quot;, lastPos);
+				if (pos != string::npos)
+				{
+					string type = option.substr(lastPos, pos - lastPos);
+
+					lastPos = pos + 1;
+					pos = option.find_first_of(&quot;|&quot;, lastPos);
+					if (pos != string::npos)
+					{
+						string labelName = option.substr(lastPos, pos - lastPos);
+
+						unsigned int docId = (unsigned int)atoi(option.substr(pos + 1).c_str());
+
+						// Update the document
+						index_document(DocumentInfo(title, Url::unescapeUrl(url), type, &quot;&quot;),
+							labelName, docId);
+					}
+				}
+			}
+		}
+	}
+
+	return true;
+}
+
+//
+// Returns the number of non-background threads.
+//
+unsigned int mainWindow::get_threads_count(void)
+{
+	int count = 0;
+
+	if (m_state.readLock(5) == true)
+	{
+		count = m_state.m_pThreads.size() - m_state.m_backgroundThreads;
+		m_state.unlock();
+	}
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::get_threads_count: &quot; &lt;&lt; count &lt;&lt; &quot; threads left&quot; &lt;&lt; endl;
+#endif
+
+	// A negative count would mean that a background thread returned
+	// without the main thread knowing about it
+	return (unsigned int)max(count , 0);
+}
+
+//
+// Updates the threads status text.
+//
+void mainWindow::update_threads_status(void)
+{
+	ustring text;
+	unsigned int threads = get_threads_count();
+
+	// Update the threads status text for the next call to set_status()
+	if (threads &gt; 0)
+	{
+		char countStr[64];
+		snprintf(countStr, 64, &quot;%d&quot;, threads);
+		text = countStr;
+		text += &quot; &quot;;
+		text += _(&quot;thread(s)&quot;);
+		text += &quot; - &quot;;
+		m_threadStatusText = text;
+	}
+	else
+	{
+		m_threadStatusText = &quot;&quot;;
+	}
+}
+
+//
+// Sets the status bar text.
+//
+void mainWindow::set_status(const ustring &amp;text, bool canBeSkipped)
+{
+	static time_t lastTime = time(NULL);
+
+	time_t now = time(NULL);
+	if ((difftime(now, lastTime) &lt; 1) &amp;&amp;
+		(canBeSkipped == true))
+	{
+		// Skip this
+		return;
+	}
+	lastTime = now;
+	
+	// Pop the previous message
+	mainStatusbar-&gt;pop();
+	// Append the new message to the threads status text
+	ustring newText = m_threadStatusText;
+	newText += text;
+	// Push
+	mainStatusbar-&gt;push(newText);
+}


Property changes on: trunk/UI/GTK2/src/mainWindow.cc
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/mainWindow.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/mainWindow.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,197 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MAINWINDOW_HH
+#define _MAINWINDOW_HH
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;set&gt;
+#include &lt;pthread.h&gt;
+#include &lt;glibmm/refptr.h&gt;
+#include &lt;gdkmm/pixbuf.h&gt;
+#include &lt;gdkmm/color.h&gt;
+#include &lt;gtkmm/rc.h&gt;
+#include &lt;gtkmm/liststore.h&gt;
+#include &lt;gtkmm/treestore.h&gt;
+#include &lt;gtkmm/treeselection.h&gt;
+#include &lt;gtkmm/selectiondata.h&gt;
+#include &lt;gtkmm/menu.h&gt;
+#include &lt;gtkmm/tooltips.h&gt;
+
+#include &quot;DocumentInfo.h&quot;
+#include &quot;IndexedDocument.h&quot;
+#include &quot;ActionHistory.h&quot;
+#include &quot;QueryProperties.h&quot;
+#include &quot;HtmlView.h&quot;
+#include &quot;EnginesTree.h&quot;
+#include &quot;IndexTree.h&quot;
+#include &quot;ModelColumns.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;ResultsTree.h&quot;
+#include &quot;WorkerThreads.h&quot;
+#include &quot;mainWindow_glade.hh&quot;
+
+class mainWindow : public mainWindow_glade
+{
+public:
+	mainWindow();
+	virtual ~mainWindow();
+
+protected:
+	// Utility methods
+	void populate_queryTreeview();
+	void save_queryTreeview();
+	void populate_indexCombobox();
+	void populate_labelMenu();
+
+	// Handlers
+	void on_enginesTreeviewSelection_changed();
+	void on_queryTreeviewSelection_changed();
+	void on_resultsTreeviewSelection_changed();
+	void on_indexTreeviewSelection_changed();
+	void on_labelMenu_changed(unsigned int pos);
+	void on_thread_end();
+	void on_editindex(Glib::ustring indexName, Glib::ustring location);
+	void on_message_reception(DocumentInfo docInfo, std::string labelName);
+	void on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, std::string indexName);
+	void on_message_import(DocumentInfo docInfo);
+
+	// Handlers inherited from the base class
+	virtual void on_configure_activate();
+	virtual void on_quit_activate();
+
+	virtual void on_cut_activate();
+	virtual void on_copy_activate();
+	virtual void on_paste_activate();
+	virtual void on_delete_activate();
+
+	virtual void on_clearresults_activate();
+	virtual void on_showextract_activate();
+	virtual void on_groupresults_activate();
+	virtual void on_viewresults_activate();
+	virtual void on_viewcache_activate();
+	virtual void on_indexresults_activate();
+
+	virtual void on_import_activate();
+	virtual void on_viewfromindex_activate();
+	virtual void on_refreshindex_activate();
+	virtual void on_showfromindex_activate();
+	virtual void on_unindex_activate();
+
+	virtual void on_about_activate();
+
+	virtual void on_addIndexButton_clicked();
+	virtual void on_removeIndexButton_clicked();
+
+	virtual void on_findButton_clicked();
+	virtual void on_addQueryButton_clicked();
+	virtual void on_editQueryButton_clicked();
+	virtual void on_removeQueryButton_clicked();
+	virtual void on_findQueryButton_clicked();
+
+	virtual void on_indexCombobox_changed();
+
+	virtual void on_indexFirstButton_clicked();
+	virtual void on_indexBackButton_clicked();
+	virtual void on_indexForwardButton_clicked();
+	virtual void on_indexLastButton_clicked();
+
+	virtual bool on_queryTreeview_button_press_event(GdkEventButton *ev);
+	virtual bool on_mainWindow_delete_event(GdkEventAny *ev);
+
+	// Action methods
+	bool queue_index(const DocumentInfo &amp;docInfo, const std::string &amp;labelName,
+		unsigned int docId = 0);
+	bool queue_unindex(set&lt;unsigned int&gt; &amp;docIdList);
+	void run_search(const QueryProperties &amp;queryProps);
+	void browse_index(unsigned int startDoc = 0);
+	void index_document(const DocumentInfo &amp;docInfo, const std::string &amp;labelName,
+		unsigned int docId = 0);
+	bool view_document(const std::string &amp;url, bool internalViewerOnly = false);
+	void start_thread(WorkerThread *pNewThread, bool inBackground = false);
+	bool check_queue(void);
+
+	// Status methods
+	bool on_activity_timeout(void);
+	unsigned int get_threads_count(void);
+	void update_threads_status(void);
+	void set_status(const Glib::ustring &amp;text, bool canBeSkipped = false);
+
+private:
+	// Threads status text
+	Glib::ustring m_threadStatusText;
+	// Global settings
+	PinotSettings &amp;m_settings;
+	// Engine
+	EnginesTree *m_pEnginesTree;
+	// Query
+	QueryModelColumns m_queryColumns;
+	Glib::RefPtr&lt;Gtk::ListStore&gt; m_refQueryTree;
+	// Results
+	ResultsTree *m_pResultsTree;
+	// Index
+	IndexTree *m_pIndexTree;
+	Gtk::Menu *m_pLabelsMenu;
+	ComboModelColumns m_indexNameColumns;
+	Glib::RefPtr&lt;Gtk::ListStore&gt; m_refIndexNameTree;
+	// View
+	HtmlView *m_pHtmlView;
+	// Tooltips
+	Gtk::Tooltips m_tooltips;
+	// Activity timeout
+	SigC::Connection m_timeoutConnection;
+	// Internal state
+	struct InternalState
+	{
+		public:
+			InternalState();
+			~InternalState();
+
+			bool readLock(unsigned int where);
+			bool writeLock(unsigned int where);
+			void unlock(void);
+
+			unsigned int getCurrentLabel(std::string &amp;labelName);
+			void setCurrentLabel(unsigned int labelPos, const std::string &amp;labelName);
+			Glib::ustring getCurrentIndex(void);
+			void setCurrentIndex(const Glib::ustring &amp;indexName);
+
+			// Index
+			unsigned int m_indexDocsCount;
+			unsigned int m_startDoc;
+			// Worker threads
+			std::set&lt;WorkerThread *&gt; m_pThreads;
+			unsigned int m_backgroundThreads;
+			// In-progress actions
+			std::set&lt;std::string&gt; m_beingIndexed;
+			bool m_browsingIndex;
+
+		protected:
+			// Read/write lock
+			pthread_rwlock_t m_rwLock;
+			// Index
+			unsigned int m_currentLabelPos;
+			std::string m_currentLabelName;
+			Glib::ustring m_currentIndexName;
+
+	} m_state;
+	static unsigned int m_maxDocsCount;
+	static unsigned int m_maxThreads;
+
+};
+
+#endif


Property changes on: trunk/UI/GTK2/src/mainWindow.hh
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/mainWindow_glade.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,574 @@
+// generated 2005/12/2 19:36:17 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/mainWindow.cc
+
+
+#if defined __GNUC__ &amp;&amp; __GNUC__ &lt; 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include &quot;config.h&quot;
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include &lt;libintl.h&gt;
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include &lt;gtkmmconfig.h&gt;
+#if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
+#include &lt;sigc++/compatibility.h&gt;
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include &quot;mainWindow_glade.hh&quot;
+#include &lt;gdk/gdkkeysyms.h&gt;
+#include &lt;gtkmm/accelgroup.h&gt;
+#include &lt;gtk/gtkimagemenuitem.h&gt;
+#include &lt;gtkmm/menu.h&gt;
+#include &lt;gtkmm/image.h&gt;
+#include &lt;gtkmm/menuitem.h&gt;
+#include &lt;gtkmm/menubar.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/buttonbox.h&gt;
+#include &lt;gtkmm/scrolledwindow.h&gt;
+#include &lt;gtkmm/alignment.h&gt;
+
+mainWindow_glade::mainWindow_glade(
+) : Gtk::Window(Gtk::WINDOW_TOPLEVEL)
+{  mainWindow = this;
+   gmm_data = new GlademmData(get_accel_group());
+   configure1 = NULL;
+   separatormenuitem1 = NULL;
+   quit1 = NULL;
+   
+   Gtk::Menu *sessionMenuitem_menu = Gtk::manage(new class Gtk::Menu());
+   sessionMenuitem = NULL;
+   cut1 = NULL;
+   copy1 = NULL;
+   paste1 = NULL;
+   delete1 = NULL;
+   Gtk::Menu *editMenuitem_menu = Gtk::manage(new class Gtk::Menu());
+   editMenuitem = NULL;
+   Gtk::Image *image514 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-clear&quot;), Gtk::IconSize(1)));
+   clearresults1 = NULL;
+   showextract1 = NULL;
+   searchenginegroup1 = NULL;
+   Gtk::RadioMenuItem::Group _RadioMIGroup_searchenginegroup1;
+   hostnamegroup1 = NULL;
+   Gtk::Menu *groupresults1_menu = Gtk::manage(new class Gtk::Menu());
+   Gtk::MenuItem *groupresults1 = NULL;
+   Gtk::MenuItem *separator1 = NULL;
+   viewresults1 = NULL;
+   viewcache1 = NULL;
+   indexresults1 = NULL;
+   Gtk::Menu *resultsMenuitem_menu = Gtk::manage(new class Gtk::Menu());
+   resultsMenuitem = NULL;
+   showlabels1 = NULL;
+   Gtk::Image *image515 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-open&quot;), Gtk::IconSize(1)));
+   import1 = NULL;
+   Gtk::MenuItem *separator3 = NULL;
+   viewfromindex1 = NULL;
+   Gtk::Image *image516 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-refresh&quot;), Gtk::IconSize(1)));
+   refreshindex1 = NULL;
+   Gtk::Image *image517 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-delete&quot;), Gtk::IconSize(1)));
+   unindex1 = NULL;
+   Gtk::Image *image518 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-properties&quot;), Gtk::IconSize(1)));
+   showfromindex1 = NULL;
+   Gtk::Menu *indexMenuitem_menu = Gtk::manage(new class Gtk::Menu());
+   indexMenuitem = NULL;
+   about1 = NULL;
+   Gtk::Menu *helpMenuitem_menu = Gtk::manage(new class Gtk::Menu());
+   helpMenuitem = NULL;
+   Gtk::MenuBar *mainMenubar = Gtk::manage(new class Gtk::MenuBar());
+   enginesVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   
+   Gtk::Image *image439 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-add&quot;), Gtk::IconSize(4)));
+   addIndexButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::Image *image438 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-remove&quot;), Gtk::IconSize(4)));
+   removeIndexButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::HBox *indexHbox = Gtk::manage(new class Gtk::HBox(true, 4));
+   Gtk::VBox *leftVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   Gtk::Label *liveQueryLabel = Gtk::manage(new class Gtk::Label(_(&quot;Query:&quot;)));
+   liveQueryEntry = Gtk::manage(new class Gtk::Entry());
+   findButton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-find&quot;)));
+   
+   Gtk::VButtonBox *findVbuttonbox = Gtk::manage(new class Gtk::VButtonBox(Gtk::BUTTONBOX_DEFAULT_STYLE, 0));
+   Gtk::HBox *liveQueryHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   queryTreeview = Gtk::manage(new class Gtk::TreeView());
+   
+   Gtk::ScrolledWindow *queryScrolledwindow = Gtk::manage(new class Gtk::ScrolledWindow());
+   addQueryButton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-add&quot;)));
+   
+   Gtk::Image *image400 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-open&quot;), Gtk::IconSize(4)));
+   Gtk::Label *label47 = Gtk::manage(new class Gtk::Label(_(&quot;Edit&quot;)));
+   Gtk::HBox *hbox40 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment26 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
+   editQueryButton = Gtk::manage(new class Gtk::Button());
+   removeQueryButton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-remove&quot;)));
+   findQueryButton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-find&quot;)));
+   
+   Gtk::VButtonBox *queryVbuttonbox = Gtk::manage(new class Gtk::VButtonBox(Gtk::BUTTONBOX_START, 0));
+   Gtk::HBox *queryHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   Gtk::Label *queryLabel = Gtk::manage(new class Gtk::Label(_(&quot;Stored queries&quot;)));
+#if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
+   queryExpander = Gtk::manage(new class Gtk::Expander());
+#else //
+   queryExpander = Gtk::manage(new class Gtk::HandleBox());
+#endif //
+   resultsVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   
+   Gtk::Label *resultsLabel = Gtk::manage(new class Gtk::Label(_(&quot;Results&quot;)));
+   indexCombobox = Gtk::manage(new class Gtk::ComboBox());
+   
+   Gtk::Image *image478 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-goto-first&quot;), Gtk::IconSize(4)));
+   indexFirstButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::Image *image479 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-go-back&quot;), Gtk::IconSize(4)));
+   indexBackButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::Image *image480 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-go-forward&quot;), Gtk::IconSize(4)));
+   indexForwardButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::Image *image481 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-goto-last&quot;), Gtk::IconSize(4)));
+   indexLastButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::HButtonBox *indexHbuttonbox = Gtk::manage(new class Gtk::HButtonBox(Gtk::BUTTONBOX_SPREAD, 0));
+   Gtk::HBox *indexButtonsHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   indexVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   
+   Gtk::Label *indexLabel = Gtk::manage(new class Gtk::Label(_(&quot;Index&quot;)));
+   viewVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   
+   Gtk::Label *viewLabel = Gtk::manage(new class Gtk::Label(_(&quot;View&quot;)));
+   mainNotebook = Gtk::manage(new class Gtk::Notebook());
+   
+   Gtk::VBox *rightVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   mainHpaned = Gtk::manage(new class Gtk::HPaned());
+   mainProgressbar = Gtk::manage(new class Gtk::ProgressBar());
+   mainStatusbar = Gtk::manage(new class Gtk::Statusbar());
+   
+   Gtk::HBox *mainHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   Gtk::VBox *vbox1 = Gtk::manage(new class Gtk::VBox(false, 0));
+   
+   sessionMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::StockMenuElem(Gtk::StockID(&quot;gtk-preferences&quot;)));
+   configure1 = (Gtk::ImageMenuItem *)&amp;sessionMenuitem_menu-&gt;items().back();
+   
+   sessionMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::SeparatorElem());
+   separatormenuitem1 = (Gtk::MenuItem *)&amp;sessionMenuitem_menu-&gt;items().back();
+   
+   sessionMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::StockMenuElem(Gtk::StockID(&quot;gtk-quit&quot;)));
+   quit1 = (Gtk::ImageMenuItem *)&amp;sessionMenuitem_menu-&gt;items().back();
+   
+   editMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::StockMenuElem(Gtk::StockID(&quot;gtk-cut&quot;)));
+   cut1 = (Gtk::ImageMenuItem *)&amp;editMenuitem_menu-&gt;items().back();
+   
+   editMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::StockMenuElem(Gtk::StockID(&quot;gtk-copy&quot;)));
+   copy1 = (Gtk::ImageMenuItem *)&amp;editMenuitem_menu-&gt;items().back();
+   
+   editMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::StockMenuElem(Gtk::StockID(&quot;gtk-paste&quot;)));
+   paste1 = (Gtk::ImageMenuItem *)&amp;editMenuitem_menu-&gt;items().back();
+   
+   editMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::StockMenuElem(Gtk::StockID(&quot;gtk-delete&quot;)));
+   delete1 = (Gtk::ImageMenuItem *)&amp;editMenuitem_menu-&gt;items().back();
+   
+   groupresults1_menu-&gt;items().push_back(Gtk::Menu_Helpers::RadioMenuElem(_RadioMIGroup_searchenginegroup1, _(&quot;Search Engine&quot;)));
+   searchenginegroup1 = (Gtk::RadioMenuItem *)&amp;groupresults1_menu-&gt;items().back();
+   
+   groupresults1_menu-&gt;items().push_back(Gtk::Menu_Helpers::RadioMenuElem(_RadioMIGroup_searchenginegroup1, _(&quot;Host Name&quot;)));
+   hostnamegroup1 = (Gtk::RadioMenuItem *)&amp;groupresults1_menu-&gt;items().back();
+   
+   resultsMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Clear List&quot;), *image514));
+   clearresults1 = (Gtk::ImageMenuItem *)&amp;resultsMenuitem_menu-&gt;items().back();
+   
+   resultsMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::CheckMenuElem(_(&quot;Show Extract&quot;)));
+   showextract1 = (Gtk::CheckMenuItem *)&amp;resultsMenuitem_menu-&gt;items().back();
+   
+   resultsMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;Group By&quot;), *groupresults1_menu));
+   groupresults1 = (Gtk::MenuItem *)&amp;resultsMenuitem_menu-&gt;items().back();
+   
+   resultsMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::SeparatorElem());
+   separator1 = (Gtk::MenuItem *)&amp;resultsMenuitem_menu-&gt;items().back();
+   
+   resultsMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;Vie_w&quot;)));
+   viewresults1 = (Gtk::MenuItem *)&amp;resultsMenuitem_menu-&gt;items().back();
+   
+   resultsMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;View Cache&quot;)));
+   viewcache1 = (Gtk::MenuItem *)&amp;resultsMenuitem_menu-&gt;items().back();
+   
+   resultsMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;_Index&quot;)));
+   indexresults1 = (Gtk::MenuItem *)&amp;resultsMenuitem_menu-&gt;items().back();
+   
+   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;Show Label&quot;)));
+   showlabels1 = (Gtk::MenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
+   
+   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Import&quot;), *image515));
+   import1 = (Gtk::ImageMenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
+   
+   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::SeparatorElem());
+   separator3 = (Gtk::MenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
+   
+   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;View&quot;)));
+   viewfromindex1 = (Gtk::MenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
+   
+   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Update&quot;), *image516));
+   refreshindex1 = (Gtk::ImageMenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
+   
+   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Unindex&quot;), *image517));
+   unindex1 = (Gtk::ImageMenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
+   
+   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Properties&quot;), *image518));
+   showfromindex1 = (Gtk::ImageMenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
+   
+   helpMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;_About&quot;)));
+   about1 = (Gtk::MenuItem *)&amp;helpMenuitem_menu-&gt;items().back();
+   
+   mainMenubar-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;_Session&quot;), *sessionMenuitem_menu));
+   sessionMenuitem = (Gtk::MenuItem *)&amp;mainMenubar-&gt;items().back();
+   
+   mainMenubar-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;_Edit&quot;), *editMenuitem_menu));
+   editMenuitem = (Gtk::MenuItem *)&amp;mainMenubar-&gt;items().back();
+   
+   mainMenubar-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;_Results&quot;), *resultsMenuitem_menu));
+   resultsMenuitem = (Gtk::MenuItem *)&amp;mainMenubar-&gt;items().back();
+   
+   mainMenubar-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;_Index&quot;), *indexMenuitem_menu));
+   indexMenuitem = (Gtk::MenuItem *)&amp;mainMenubar-&gt;items().back();
+   
+   mainMenubar-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;_Help&quot;), *helpMenuitem_menu));
+   helpMenuitem = (Gtk::MenuItem *)&amp;mainMenubar-&gt;items().back();
+   image514-&gt;set_alignment(0.5,0.5);
+   image514-&gt;set_padding(0,0);
+   showextract1-&gt;set_active(true);
+   searchenginegroup1-&gt;set_active(true);
+   hostnamegroup1-&gt;set_active(false);
+   image515-&gt;set_alignment(0.5,0.5);
+   image515-&gt;set_padding(0,0);
+   image516-&gt;set_alignment(0.5,0.5);
+   image516-&gt;set_padding(0,0);
+   image517-&gt;set_alignment(0.5,0.5);
+   image517-&gt;set_padding(0,0);
+   image518-&gt;set_alignment(0.5,0.5);
+   image518-&gt;set_padding(0,0);
+   image439-&gt;set_alignment(0.5,0.5);
+   image439-&gt;set_padding(0,0);
+   addIndexButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   addIndexButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   addIndexButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   addIndexButton-&gt;add(*image439);
+   image438-&gt;set_alignment(0.5,0.5);
+   image438-&gt;set_padding(0,0);
+   removeIndexButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   removeIndexButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   removeIndexButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   removeIndexButton-&gt;add(*image438);
+   indexHbox-&gt;pack_start(*addIndexButton);
+   indexHbox-&gt;pack_start(*removeIndexButton);
+   leftVbox-&gt;pack_start(*enginesVbox);
+   leftVbox-&gt;pack_start(*indexHbox, Gtk::PACK_SHRINK, 0);
+   liveQueryLabel-&gt;set_alignment(0.5,0.5);
+   liveQueryLabel-&gt;set_padding(0,0);
+   liveQueryLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   liveQueryLabel-&gt;set_line_wrap(false);
+   liveQueryLabel-&gt;set_use_markup(false);
+   liveQueryLabel-&gt;set_selectable(false);
+   liveQueryEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   liveQueryEntry-&gt;set_visibility(true);
+   liveQueryEntry-&gt;set_editable(true);
+   liveQueryEntry-&gt;set_max_length(0);
+   liveQueryEntry-&gt;set_text(_(&quot;&quot;));
+   liveQueryEntry-&gt;set_has_frame(true);
+   liveQueryEntry-&gt;set_activates_default(false);
+   findButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   findButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   findButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   findVbuttonbox-&gt;pack_start(*findButton);
+   liveQueryHbox-&gt;pack_start(*liveQueryLabel, Gtk::PACK_SHRINK, 4);
+   liveQueryHbox-&gt;pack_start(*liveQueryEntry, Gtk::PACK_EXPAND_WIDGET, 4);
+   liveQueryHbox-&gt;pack_start(*findVbuttonbox, Gtk::PACK_SHRINK, 4);
+   queryTreeview-&gt;set_events(Gdk::BUTTON_PRESS_MASK);
+   queryTreeview-&gt;set_flags(Gtk::CAN_FOCUS);
+   queryTreeview-&gt;set_headers_visible(true);
+   queryTreeview-&gt;set_rules_hint(false);
+   queryTreeview-&gt;set_reorderable(false);
+   queryTreeview-&gt;set_enable_search(false);
+   queryScrolledwindow-&gt;set_flags(Gtk::CAN_FOCUS);
+   queryScrolledwindow-&gt;set_shadow_type(Gtk::SHADOW_NONE);
+   queryScrolledwindow-&gt;set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+   queryScrolledwindow-&gt;property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+   queryScrolledwindow-&gt;add(*queryTreeview);
+   addQueryButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   addQueryButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   addQueryButton-&gt;set_border_width(4);
+   addQueryButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   image400-&gt;set_alignment(0.5,0.5);
+   image400-&gt;set_padding(0,0);
+   label47-&gt;set_alignment(0.5,0.5);
+   label47-&gt;set_padding(0,0);
+   label47-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   label47-&gt;set_line_wrap(false);
+   label47-&gt;set_use_markup(false);
+   label47-&gt;set_selectable(false);
+   hbox40-&gt;pack_start(*image400, Gtk::PACK_SHRINK, 0);
+   hbox40-&gt;pack_start(*label47, Gtk::PACK_SHRINK, 0);
+   alignment26-&gt;add(*hbox40);
+   editQueryButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   editQueryButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   editQueryButton-&gt;set_border_width(4);
+   editQueryButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   editQueryButton-&gt;add(*alignment26);
+   removeQueryButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   removeQueryButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   removeQueryButton-&gt;set_border_width(4);
+   removeQueryButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   findQueryButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   findQueryButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   findQueryButton-&gt;set_border_width(4);
+   findQueryButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   queryVbuttonbox-&gt;pack_start(*addQueryButton);
+   queryVbuttonbox-&gt;pack_start(*editQueryButton);
+   queryVbuttonbox-&gt;pack_start(*removeQueryButton);
+   queryVbuttonbox-&gt;pack_start(*findQueryButton);
+   queryHbox-&gt;pack_start(*queryScrolledwindow);
+   queryHbox-&gt;pack_start(*queryVbuttonbox, Gtk::PACK_SHRINK, 0);
+   queryLabel-&gt;set_alignment(0.5,0.5);
+   queryLabel-&gt;set_padding(0,0);
+   queryLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   queryLabel-&gt;set_line_wrap(false);
+   queryLabel-&gt;set_use_markup(false);
+   queryLabel-&gt;set_selectable(false);
+   queryExpander-&gt;set_flags(Gtk::CAN_FOCUS);
+#if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
+   queryExpander-&gt;set_expanded(false);
+   queryExpander-&gt;set_spacing(0);
+#endif //
+   queryExpander-&gt;add(*queryHbox);
+#if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
+   queryExpander-&gt;set_label_widget(*queryLabel);
+#endif //
+   resultsLabel-&gt;set_alignment(0.5,0.5);
+   resultsLabel-&gt;set_padding(0,0);
+   resultsLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   resultsLabel-&gt;set_line_wrap(false);
+   resultsLabel-&gt;set_use_markup(false);
+   resultsLabel-&gt;set_selectable(false);
+   image478-&gt;set_alignment(0.5,0.5);
+   image478-&gt;set_padding(0,0);
+   indexFirstButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   indexFirstButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   indexFirstButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   indexFirstButton-&gt;add(*image478);
+   image479-&gt;set_alignment(0.5,0.5);
+   image479-&gt;set_padding(0,0);
+   indexBackButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   indexBackButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   indexBackButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   indexBackButton-&gt;add(*image479);
+   image480-&gt;set_alignment(0.5,0.5);
+   image480-&gt;set_padding(0,0);
+   indexForwardButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   indexForwardButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   indexForwardButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   indexForwardButton-&gt;add(*image480);
+   image481-&gt;set_alignment(0.5,0.5);
+   image481-&gt;set_padding(0,0);
+   indexLastButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   indexLastButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   indexLastButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   indexLastButton-&gt;add(*image481);
+   indexHbuttonbox-&gt;pack_start(*indexFirstButton);
+   indexHbuttonbox-&gt;pack_start(*indexBackButton);
+   indexHbuttonbox-&gt;pack_start(*indexForwardButton);
+   indexHbuttonbox-&gt;pack_start(*indexLastButton);
+   indexButtonsHbox-&gt;pack_start(*indexCombobox, Gtk::PACK_SHRINK, 4);
+   indexButtonsHbox-&gt;pack_start(*indexHbuttonbox, Gtk::PACK_SHRINK, 4);
+   indexVbox-&gt;pack_start(*indexButtonsHbox, Gtk::PACK_SHRINK, 4);
+   indexLabel-&gt;set_alignment(0.5,0.5);
+   indexLabel-&gt;set_padding(0,0);
+   indexLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   indexLabel-&gt;set_line_wrap(false);
+   indexLabel-&gt;set_use_markup(false);
+   indexLabel-&gt;set_selectable(false);
+   viewLabel-&gt;set_alignment(0.5,0.5);
+   viewLabel-&gt;set_padding(0,0);
+   viewLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   viewLabel-&gt;set_line_wrap(false);
+   viewLabel-&gt;set_use_markup(false);
+   viewLabel-&gt;set_selectable(false);
+   mainNotebook-&gt;set_flags(Gtk::CAN_FOCUS);
+   mainNotebook-&gt;set_show_tabs(true);
+   mainNotebook-&gt;set_show_border(true);
+   mainNotebook-&gt;set_tab_pos(Gtk::POS_TOP);
+   mainNotebook-&gt;set_scrollable(false);
+   mainNotebook-&gt;append_page(*resultsVbox, *resultsLabel);
+   mainNotebook-&gt;pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   mainNotebook-&gt;append_page(*indexVbox, *indexLabel);
+   mainNotebook-&gt;pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   mainNotebook-&gt;append_page(*viewVbox, *viewLabel);
+   mainNotebook-&gt;pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   rightVbox-&gt;pack_start(*liveQueryHbox, Gtk::PACK_SHRINK, 0);
+   rightVbox-&gt;pack_start(*queryExpander, Gtk::PACK_SHRINK, 0);
+   rightVbox-&gt;pack_start(*mainNotebook, Gtk::PACK_EXPAND_WIDGET, 4);
+   mainHpaned-&gt;set_flags(Gtk::CAN_FOCUS);
+   mainHpaned-&gt;set_position(105);
+   mainHpaned-&gt;pack1(*leftVbox, Gtk::SHRINK);
+   mainHpaned-&gt;pack2(*rightVbox, Gtk::EXPAND|Gtk::SHRINK);
+   mainHbox-&gt;pack_start(*mainProgressbar, Gtk::PACK_SHRINK, 0);
+   mainHbox-&gt;pack_start(*mainStatusbar);
+   vbox1-&gt;pack_start(*mainMenubar, Gtk::PACK_SHRINK, 0);
+   vbox1-&gt;pack_start(*mainHpaned, Gtk::PACK_EXPAND_WIDGET, 4);
+   vbox1-&gt;pack_start(*mainHbox, Gtk::PACK_SHRINK, 0);
+   mainWindow-&gt;set_events(Gdk::BUTTON_PRESS_MASK);
+   mainWindow-&gt;set_title(_(&quot;Pinot&quot;));
+   mainWindow-&gt;set_default_size(400,-1);
+   mainWindow-&gt;set_modal(false);
+   mainWindow-&gt;property_window_position().set_value(Gtk::WIN_POS_NONE);
+   mainWindow-&gt;set_resizable(true);
+   mainWindow-&gt;property_destroy_with_parent().set_value(false);
+   mainWindow-&gt;add(*vbox1);
+   configure1-&gt;show();
+   separatormenuitem1-&gt;show();
+   quit1-&gt;show();
+   sessionMenuitem-&gt;show();
+   cut1-&gt;show();
+   copy1-&gt;show();
+   paste1-&gt;show();
+   delete1-&gt;show();
+   editMenuitem-&gt;show();
+   image514-&gt;show();
+   clearresults1-&gt;show();
+   showextract1-&gt;show();
+   searchenginegroup1-&gt;show();
+   hostnamegroup1-&gt;show();
+   groupresults1-&gt;show();
+   separator1-&gt;show();
+   viewresults1-&gt;show();
+   viewcache1-&gt;show();
+   indexresults1-&gt;show();
+   resultsMenuitem-&gt;show();
+   showlabels1-&gt;show();
+   image515-&gt;show();
+   import1-&gt;show();
+   separator3-&gt;show();
+   viewfromindex1-&gt;show();
+   image516-&gt;show();
+   refreshindex1-&gt;show();
+   image517-&gt;show();
+   unindex1-&gt;show();
+   image518-&gt;show();
+   showfromindex1-&gt;show();
+   indexMenuitem-&gt;show();
+   about1-&gt;show();
+   helpMenuitem-&gt;show();
+   mainMenubar-&gt;show();
+   enginesVbox-&gt;show();
+   image439-&gt;show();
+   addIndexButton-&gt;show();
+   image438-&gt;show();
+   removeIndexButton-&gt;show();
+   indexHbox-&gt;show();
+   leftVbox-&gt;show();
+   liveQueryLabel-&gt;show();
+   liveQueryEntry-&gt;show();
+   findButton-&gt;show();
+   findVbuttonbox-&gt;show();
+   liveQueryHbox-&gt;show();
+   queryTreeview-&gt;show();
+   queryScrolledwindow-&gt;show();
+   addQueryButton-&gt;show();
+   image400-&gt;show();
+   label47-&gt;show();
+   hbox40-&gt;show();
+   alignment26-&gt;show();
+   editQueryButton-&gt;show();
+   removeQueryButton-&gt;show();
+   findQueryButton-&gt;show();
+   queryVbuttonbox-&gt;show();
+   queryHbox-&gt;show();
+   queryLabel-&gt;show();
+   queryExpander-&gt;show();
+   resultsVbox-&gt;show();
+   resultsLabel-&gt;show();
+   indexCombobox-&gt;show();
+   image478-&gt;show();
+   indexFirstButton-&gt;show();
+   image479-&gt;show();
+   indexBackButton-&gt;show();
+   image480-&gt;show();
+   indexForwardButton-&gt;show();
+   image481-&gt;show();
+   indexLastButton-&gt;show();
+   indexHbuttonbox-&gt;show();
+   indexButtonsHbox-&gt;show();
+   indexVbox-&gt;show();
+   indexLabel-&gt;show();
+   viewVbox-&gt;show();
+   viewLabel-&gt;show();
+   mainNotebook-&gt;show();
+   rightVbox-&gt;show();
+   mainHpaned-&gt;show();
+   mainProgressbar-&gt;show();
+   mainStatusbar-&gt;show();
+   mainHbox-&gt;show();
+   vbox1-&gt;show();
+   mainWindow-&gt;show();
+   configure1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_configure_activate), false);
+   quit1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_quit_activate), false);
+   cut1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_cut_activate), false);
+   copy1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_copy_activate), false);
+   paste1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_paste_activate), false);
+   delete1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_delete_activate), false);
+   clearresults1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_clearresults_activate), false);
+   showextract1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_showextract_activate), false);
+   searchenginegroup1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_groupresults_activate), false);
+   viewresults1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_viewresults_activate), false);
+   viewcache1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_viewcache_activate), false);
+   indexresults1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_indexresults_activate), false);
+   import1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_import_activate), false);
+   viewfromindex1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_viewfromindex_activate), false);
+   refreshindex1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_refreshindex_activate), false);
+   unindex1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_unindex_activate), false);
+   showfromindex1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_showfromindex_activate), false);
+   about1-&gt;signal_activate().connect(SigC::slot(*this, &amp;mainWindow_glade::on_about_activate), false);
+   addIndexButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_addIndexButton_clicked), false);
+   removeIndexButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_removeIndexButton_clicked), false);
+   findButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_findButton_clicked), false);
+   queryTreeview-&gt;signal_button_press_event().connect(SigC::slot(*this, &amp;mainWindow_glade::on_queryTreeview_button_press_event), false);
+   addQueryButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_addQueryButton_clicked), false);
+   editQueryButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_editQueryButton_clicked), false);
+   removeQueryButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_removeQueryButton_clicked), false);
+   findQueryButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_findQueryButton_clicked), false);
+   indexCombobox-&gt;signal_changed().connect(SigC::slot(*this, &amp;mainWindow_glade::on_indexCombobox_changed), false);
+   indexFirstButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_indexFirstButton_clicked), false);
+   indexBackButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_indexBackButton_clicked), false);
+   indexForwardButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_indexForwardButton_clicked), false);
+   indexLastButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_indexLastButton_clicked), false);
+   mainWindow-&gt;signal_delete_event().connect(SigC::slot(*this, &amp;mainWindow_glade::on_mainWindow_delete_event), false);
+}
+
+mainWindow_glade::~mainWindow_glade()
+{  delete gmm_data;
+}


Property changes on: trunk/UI/GTK2/src/mainWindow_glade.cc
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/mainWindow_glade.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/mainWindow_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,152 @@
+// generated 2005/11/6 16:50:21 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/mainWindow.hh and./src/mainWindow.cc
+
+#ifndef _MAINWINDOW_GLADE_HH
+#  define _MAINWINDOW_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include &lt;gtkmm/accelgroup.h&gt;
+
+class GlademmData
+{  
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt; accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr&lt;Gtk::AccelGroup&gt; ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt;  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include &lt;gtkmm/window.h&gt;
+#include &lt;gtkmm/imagemenuitem.h&gt;
+#include &lt;gtkmm/menuitem.h&gt;
+#include &lt;gtkmm/checkmenuitem.h&gt;
+#include &lt;gtkmm/radiomenuitem.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/entry.h&gt;
+#include &lt;gtkmm/treeview.h&gt;
+#if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
+#include &lt;gtkmm/expander.h&gt;
+#else //
+#include &lt;gtkmm/handlebox.h&gt;
+#endif //
+#include &lt;gtkmm/combobox.h&gt;
+#include &lt;gtkmm/notebook.h&gt;
+#include &lt;gtkmm/paned.h&gt;
+#include &lt;gtkmm/progressbar.h&gt;
+#include &lt;gtkmm/statusbar.h&gt;
+
+class mainWindow_glade : public Gtk::Window
+{  
+        
+        GlademmData *gmm_data;
+public:
+        class Gtk::Window * mainWindow;
+protected:
+        class Gtk::ImageMenuItem * configure1;
+        class Gtk::MenuItem * separatormenuitem1;
+        class Gtk::ImageMenuItem * quit1;
+        class Gtk::MenuItem * sessionMenuitem;
+        class Gtk::ImageMenuItem * cut1;
+        class Gtk::ImageMenuItem * copy1;
+        class Gtk::ImageMenuItem * paste1;
+        class Gtk::ImageMenuItem * delete1;
+        class Gtk::MenuItem * editMenuitem;
+        class Gtk::ImageMenuItem * clearresults1;
+        class Gtk::CheckMenuItem * showextract1;
+        class Gtk::RadioMenuItem * searchenginegroup1;
+        class Gtk::RadioMenuItem * hostnamegroup1;
+        class Gtk::MenuItem * viewresults1;
+        class Gtk::MenuItem * viewcache1;
+        class Gtk::MenuItem * indexresults1;
+        class Gtk::MenuItem * resultsMenuitem;
+        class Gtk::MenuItem * showlabels1;
+        class Gtk::ImageMenuItem * import1;
+        class Gtk::MenuItem * viewfromindex1;
+        class Gtk::ImageMenuItem * refreshindex1;
+        class Gtk::ImageMenuItem * unindex1;
+        class Gtk::ImageMenuItem * showfromindex1;
+        class Gtk::MenuItem * indexMenuitem;
+        class Gtk::MenuItem * about1;
+        class Gtk::MenuItem * helpMenuitem;
+        class Gtk::VBox * enginesVbox;
+        class Gtk::Button * addIndexButton;
+        class Gtk::Button * removeIndexButton;
+        class Gtk::Entry * liveQueryEntry;
+        class Gtk::Button * findButton;
+        class Gtk::TreeView * queryTreeview;
+        class Gtk::Button * addQueryButton;
+        class Gtk::Button * editQueryButton;
+        class Gtk::Button * removeQueryButton;
+        class Gtk::Button * findQueryButton;
+#if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
+        class Gtk::Expander * queryExpander;
+#else //
+        class Gtk::HandleBox * queryExpander;
+#endif //
+        class Gtk::VBox * resultsVbox;
+        class Gtk::ComboBox * indexCombobox;
+        class Gtk::Button * indexFirstButton;
+        class Gtk::Button * indexBackButton;
+        class Gtk::Button * indexForwardButton;
+        class Gtk::Button * indexLastButton;
+        class Gtk::VBox * indexVbox;
+        class Gtk::VBox * viewVbox;
+        class Gtk::Notebook * mainNotebook;
+        class Gtk::HPaned * mainHpaned;
+        class Gtk::ProgressBar * mainProgressbar;
+        class Gtk::Statusbar * mainStatusbar;
+        
+        mainWindow_glade();
+        
+        ~mainWindow_glade();
+private:
+        virtual void on_configure_activate() = 0;
+        virtual void on_quit_activate() = 0;
+        virtual void on_cut_activate() = 0;
+        virtual void on_copy_activate() = 0;
+        virtual void on_paste_activate() = 0;
+        virtual void on_delete_activate() = 0;
+        virtual void on_clearresults_activate() = 0;
+        virtual void on_showextract_activate() = 0;
+        virtual void on_groupresults_activate() = 0;
+        virtual void on_viewresults_activate() = 0;
+        virtual void on_viewcache_activate() = 0;
+        virtual void on_indexresults_activate() = 0;
+        virtual void on_import_activate() = 0;
+        virtual void on_viewfromindex_activate() = 0;
+        virtual void on_refreshindex_activate() = 0;
+        virtual void on_unindex_activate() = 0;
+        virtual void on_showfromindex_activate() = 0;
+        virtual void on_about_activate() = 0;
+        virtual void on_addIndexButton_clicked() = 0;
+        virtual void on_removeIndexButton_clicked() = 0;
+        virtual void on_findButton_clicked() = 0;
+        virtual bool on_queryTreeview_button_press_event(GdkEventButton *ev) = 0;
+        virtual void on_addQueryButton_clicked() = 0;
+        virtual void on_editQueryButton_clicked() = 0;
+        virtual void on_removeQueryButton_clicked() = 0;
+        virtual void on_findQueryButton_clicked() = 0;
+        virtual void on_indexCombobox_changed() = 0;
+        virtual void on_indexFirstButton_clicked() = 0;
+        virtual void on_indexBackButton_clicked() = 0;
+        virtual void on_indexForwardButton_clicked() = 0;
+        virtual void on_indexLastButton_clicked() = 0;
+        virtual bool on_mainWindow_delete_event(GdkEventAny *ev) = 0;
+};
+#endif


Property changes on: trunk/UI/GTK2/src/mainWindow_glade.hh
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/pinot.cpp
===================================================================
--- trunk/UI/GTK2/src/pinot.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/pinot.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,152 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;libintl.h&gt;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+#include &lt;glibmm.h&gt;
+#include &lt;glibmm/thread.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;glibmm/convert.h&gt;
+#include &lt;gtkmm/main.h&gt;
+
+#include &quot;TokenizerFactory.h&quot;
+#include &quot;Languages.h&quot;
+#include &quot;ActionHistory.h&quot;
+#include &quot;LabelManager.h&quot;
+#include &quot;QueryHistory.h&quot;
+#include &quot;ViewHistory.h&quot;
+#include &quot;XapianDatabase.h&quot;
+#include &quot;XapianDatabaseFactory.h&quot;
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;mainWindow.hh&quot;
+
+using namespace std;
+
+ofstream outputFile;
+streambuf *coutbuf = NULL;
+streambuf *cerrbuf = NULL;
+
+void closeAll(void)
+{
+	cout &lt;&lt; &quot;Exiting...&quot; &lt;&lt; endl;
+
+	// Save the settings
+	PinotSettings &amp;settings = PinotSettings::getInstance();
+	if (settings.save() == false)
+	{
+		cerr &lt;&lt; _(&quot;Couldn't save configuration file&quot;) &lt;&lt; endl;
+	}
+
+	// Close all indexes we may have opened
+	XapianDatabaseFactory::closeAll();
+
+	// Close the tokenizer libraries
+	TokenizerFactory::unloadTokenizers();
+
+	// Restore the stream buffers
+	if (coutbuf != NULL)
+	{
+		cout.rdbuf(coutbuf);
+	}
+	if (cerrbuf != NULL)
+	{
+		cerr.rdbuf(cerrbuf);
+	}
+}
+
+int main(int argc, char **argv)
+{
+#if defined(ENABLE_NLS)
+	bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
+	textdomain (GETTEXT_PACKAGE);
+#endif //ENABLE_NLS
+
+	Glib::thread_init();
+	Gtk::Main m(&amp;argc, &amp;argv);
+
+	// This will create the necessary directories on the first run
+	PinotSettings &amp;settings = PinotSettings::getInstance();
+
+	string confDirectory = PinotSettings::getConfigurationDirectory();
+	chdir(confDirectory.c_str());
+
+	// Redirect cout and cerr to a file
+	string logFileName = confDirectory;
+	logFileName += &quot;/pinot.log&quot;;
+	outputFile.open(logFileName.c_str());
+	coutbuf = cout.rdbuf();
+	cerrbuf = cerr.rdbuf();
+	cout.rdbuf(outputFile.rdbuf());
+	cerr.rdbuf(outputFile.rdbuf());
+
+	// Load the settings
+	settings.load();
+	settings.loadSearchEngines(&quot;/usr/share/pinot/engines&quot;);
+	settings.loadSearchEngines(confDirectory + string(&quot;/engines&quot;));
+	// Load tokenizer libraries, if any
+	TokenizerFactory::loadTokenizers(&quot;/usr/share/pinot/tokenizers&quot;);
+	TokenizerFactory::loadTokenizers(confDirectory + string(&quot;/tokenizers&quot;));
+
+	// Ensure Xapian will be able to deal with internal indices
+	if (XapianDatabaseFactory::getDatabase(settings.m_indexLocation, false) == NULL)
+	{
+		cerr &lt;&lt; _(&quot;Index&quot;) &lt;&lt; &quot; &quot; &lt;&lt; settings.m_indexLocation &lt;&lt; &quot; &quot;
+			&lt;&lt; _(&quot;is not valid, please check&quot;) &lt;&lt; endl;
+	}
+	if (XapianDatabaseFactory::getDatabase(settings.m_mailIndexLocation, false) == NULL)
+	{
+		cerr &lt;&lt; _(&quot;Index&quot;) &lt;&lt; &quot; &quot; &lt;&lt; settings.m_mailIndexLocation &lt;&lt; &quot; &quot;
+			&lt;&lt; _(&quot;is not valid, please check&quot;) &lt;&lt; endl;
+	}
+
+	// Do the same for the history database
+	if ((settings.m_historyDatabase.empty() == true) ||
+		(ActionHistory::create(settings.m_historyDatabase) == false) ||
+		(LabelManager::create(settings.m_historyDatabase) == false) ||
+		(QueryHistory::create(settings.m_historyDatabase) == false) ||
+		(ViewHistory::create(settings.m_historyDatabase) == false))
+	{
+		cerr &lt;&lt; _(&quot;History database&quot;) &lt;&lt; &quot; &quot; &lt;&lt; settings.m_historyDatabase &lt;&lt; &quot; &quot;
+			&lt;&lt; _(&quot;couldn't be created&quot;) &lt;&lt; endl;
+	}
+
+	atexit(closeAll);
+
+	// Localize language names
+	Languages::setIntlName(0, _(&quot;Danish&quot;));
+	Languages::setIntlName(1, _(&quot;Dutch&quot;));
+	Languages::setIntlName(2, _(&quot;English&quot;));
+	Languages::setIntlName(3, _(&quot;Finnish&quot;));
+	Languages::setIntlName(4, _(&quot;French&quot;));
+	Languages::setIntlName(5, _(&quot;German&quot;));
+	Languages::setIntlName(6, _(&quot;Italian&quot;));
+	Languages::setIntlName(7, _(&quot;Norwegian&quot;));
+	Languages::setIntlName(8, _(&quot;Portuguese&quot;));
+	Languages::setIntlName(9, _(&quot;Russian&quot;));
+	Languages::setIntlName(10, _(&quot;Spanish&quot;));
+	Languages::setIntlName(11, _(&quot;Swedish&quot;));
+
+	// Create and open the main dialog box
+	mainWindow mainBox;
+	m.run(mainBox);
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/UI/GTK2/src/pinot.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/prefsDialog.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/prefsDialog.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,514 @@
+// generated 2003/5/18 21:15:37 BST by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to prefsDialog.cc_new
+
+// This file is for your program, I won't touch it again!
+
+#include &lt;stdlib.h&gt;
+#include &lt;iostream&gt;
+#include &lt;glibmm/convert.h&gt;
+#include &lt;gdkmm/color.h&gt;
+#include &lt;gtkmm/colorselection.h&gt;
+#include &lt;gtkmm/menu.h&gt;
+#include &lt;gtkmm/messagedialog.h&gt;
+
+#include &quot;MIMEScanner.h&quot;
+#include &quot;SearchEngineFactory.h&quot;
+#include &quot;LabelManager.h&quot;
+#include &quot;QueryHistory.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;importDialog.hh&quot;
+#include &quot;prefsDialog.hh&quot;
+
+using namespace std;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+unsigned int prefsDialog::m_maxDirLevel = 1;
+
+prefsDialog::prefsDialog() :
+	m_settings(PinotSettings::getInstance()), prefsDialog_glade()
+{
+	// Associate the columns model to the view combo
+	m_refViewTree = ListStore::create(m_viewColumns);
+	viewCombobox-&gt;set_model(m_refViewTree);
+	viewCombobox-&gt;pack_start(m_viewColumns.m_name);
+	// Populate
+	populate_comboboxes();
+
+	// Initialize widgets
+	// Ignore robots directives
+	ignoreRobotsCheckbutton-&gt;set_active(m_settings.m_ignoreRobotsDirectives);
+	if (m_settings.m_googleAPIKey.empty() == false)
+	{
+		apiKeyEntry-&gt;set_text(m_settings.m_googleAPIKey);
+	}
+	// Browser command
+	if (m_settings.m_browserCommand.empty() == false)
+	{
+		browserEntry-&gt;set_text(m_settings.m_browserCommand);
+	}
+	// Browser entry field and button
+	browserEntry-&gt;set_sensitive(m_settings.m_browseResults);
+	browserButton-&gt;set_sensitive(m_settings.m_browseResults);
+
+	// Associate the columns model to the labels tree
+	m_refLabelsTree = ListStore::create(m_labelsColumns);
+	labelsTreeview-&gt;set_model(m_refLabelsTree);
+	labelsTreeview-&gt;append_column_editable(_(&quot;Name&quot;), m_labelsColumns.m_name);
+	// Allow only single selection
+	labelsTreeview-&gt;get_selection()-&gt;set_mode(SELECTION_SINGLE);
+	populate_labelsTreeview();
+
+	// Associate the columns model to the mail accounts tree
+	m_refMailTree = ListStore::create(m_mailColumns);
+	mailTreeview-&gt;set_model(m_refMailTree);
+	mailTreeview-&gt;append_column(_(&quot;Location&quot;), m_mailColumns.m_location);
+	mailTreeview-&gt;append_column(_(&quot;MIME Type&quot;), m_mailColumns.m_type);
+	// Allow only single selection
+	mailTreeview-&gt;get_selection()-&gt;set_mode(SELECTION_SINGLE);
+	populate_mailTreeview();
+
+	// Hide the Google API entry field ?
+	if (SearchEngineFactory::isSupported(&quot;googleapi&quot;) == false)
+	{
+		apiKeyLabel-&gt;hide();
+		apiKeyEntry-&gt;hide();
+	}
+}
+
+prefsDialog::~prefsDialog()
+{
+}
+
+const set&lt;string&gt; &amp;prefsDialog::getMailLabelsToDelete(void) const
+{
+	// This will have been reset by save_labelsTreeview()
+	// and set by save_mailTreeview() !
+	return m_deletedLabels;
+}
+
+void prefsDialog::populate_comboboxes()
+{
+	TreeModel::iterator iter = m_refViewTree-&gt;append();
+	TreeModel::Row row = *iter;
+	row[m_viewColumns.m_name] = _(&quot;In internal viewer&quot;);
+	iter = m_refViewTree-&gt;append();
+	row = *iter;
+	row[m_viewColumns.m_name] = _(&quot;In browser&quot;);
+	// Default results view
+	if (m_settings.m_browseResults == false)
+	{
+		viewCombobox-&gt;set_active(0);
+	}
+	else
+	{
+		viewCombobox-&gt;set_active(1);
+	}
+}
+
+void prefsDialog::populate_labelsTreeview()
+{
+	TreeModel::iterator iter;
+	TreeModel::Row row;
+
+	if (m_settings.m_labels.empty() == true)
+	{
+		// These buttons will stay disabled until labels are added to the list
+		editLabelButton-&gt;set_sensitive(false);
+		removeLabelButton-&gt;set_sensitive(false);
+		return;
+	}
+
+	// Populate the tree
+	for (set&lt;PinotSettings::Label&gt;::iterator labelIter = m_settings.m_labels.begin();
+		labelIter != m_settings.m_labels.end();
+		++labelIter)
+	{
+		// Create a new row
+		iter = m_refLabelsTree-&gt;append();
+		row = *iter;
+		// Set its name and colour
+		row[m_labelsColumns.m_name] = labelIter-&gt;m_name;
+		row[m_labelsColumns.m_oldName] = labelIter-&gt;m_name;
+		Color labelColour;
+		labelColour.set_rgb(labelIter-&gt;m_red, labelIter-&gt;m_green, labelIter-&gt;m_blue);
+		row[m_labelsColumns.m_colour] = labelColour;
+		// This allows to differentiate existing labels from new labels the user may create
+		row[m_labelsColumns.m_enabled] = true;
+	}
+
+	editLabelButton-&gt;set_sensitive(true);
+	removeLabelButton-&gt;set_sensitive(true);
+}
+
+bool prefsDialog::save_labelsTreeview()
+{
+	LabelManager labelMan(m_settings.m_historyDatabase);
+
+	// Clear the current settings
+	m_settings.m_labels.clear();
+
+	// Go through the labels tree
+	TreeModel::Children children = m_refLabelsTree-&gt;children();
+	if (children.empty() == false)
+	{
+		TreeModel::Children::iterator iter = children.begin();
+		for (; iter != children.end(); ++iter)
+		{
+			TreeModel::Row row = *iter;
+
+			// Add this new label to the settings
+			PinotSettings::Label label;
+			label.m_name = row[m_labelsColumns.m_name];
+			ustring oldName = row[m_labelsColumns.m_oldName];
+			// Was this label renamed ?
+			if ((row[m_labelsColumns.m_enabled] == true) &amp;&amp;
+				(label.m_name != oldName))
+			{
+				// Yes, it was
+				labelMan.renameLabel(locale_from_utf8(oldName), locale_from_utf8(label.m_name));
+			}
+			// Check user didn't recreate this label after having deleted it
+			set&lt;string&gt;::iterator labelIter = m_deletedLabels.find(locale_from_utf8(label.m_name));
+			if (labelIter != m_deletedLabels.end())
+			{
+				m_deletedLabels.erase(labelIter);
+			}
+
+			Color labelColour = row[m_labelsColumns.m_colour];
+			label.m_red = labelColour.get_red();
+			label.m_green = labelColour.get_green();
+			label.m_blue = labelColour.get_blue();
+#ifdef DEBUG
+			cout &lt;&lt; &quot;prefsDialog::save_labelsTreeview: &quot; &lt;&lt; label.m_name &lt;&lt; endl;
+#endif
+			m_settings.m_labels.insert(label);
+		}
+	}
+
+	// Remove all references to labels that have been deleted
+	for (set&lt;string&gt;::iterator labelIter = m_deletedLabels.begin(); labelIter != m_deletedLabels.end(); ++labelIter)
+	{
+		labelMan.deleteLabel(*labelIter);
+	}
+	m_deletedLabels.clear();
+
+	return true;
+}
+
+void prefsDialog::populate_mailTreeview()
+{
+	TreeModel::iterator iter;
+	TreeModel::Row row;
+
+	if (m_settings.m_mailAccounts.empty() == true)
+	{
+		// These buttons will stay disabled until labels are added to the list
+		editAccountButton-&gt;set_sensitive(false);
+		removeAccountButton-&gt;set_sensitive(false);
+		return;
+	}
+
+	// Populate the tree
+	for (set&lt;PinotSettings::MailAccount&gt;::iterator mailIter = m_settings.m_mailAccounts.begin();
+		mailIter != m_settings.m_mailAccounts.end();
+		++mailIter)
+	{
+		// Create a new row
+		iter = m_refMailTree-&gt;append();
+		row = *iter;
+		// Set its name, type and minium date
+		row[m_mailColumns.m_location] = mailIter-&gt;m_name;
+		row[m_mailColumns.m_type] = mailIter-&gt;m_type;
+		row[m_mailColumns.m_mTime] = mailIter-&gt;m_modTime;
+		row[m_mailColumns.m_minDate] = mailIter-&gt;m_lastMessageTime;
+	}
+
+	editAccountButton-&gt;set_sensitive(true);
+	removeAccountButton-&gt;set_sensitive(true);
+}
+
+bool prefsDialog::save_mailTreeview()
+{
+	// Clear the current settings
+	m_settings.m_mailAccounts.clear();
+
+	// Go through the mail accounts tree
+	TreeModel::Children children = m_refMailTree-&gt;children();
+	if (children.empty() == false)
+	{
+		TreeModel::Children::iterator iter = children.begin();
+		for (; iter != children.end(); ++iter)
+		{
+			TreeModel::Row row = *iter;
+			PinotSettings::MailAccount mailAccount;
+
+			ustring mimeType = row[m_mailColumns.m_type];
+			if (mimeType == &quot;text/x-mail&quot;)
+			{
+				// Add this new mail account to the settings
+				mailAccount.m_name = row[m_mailColumns.m_location];
+				mailAccount.m_type = mimeType;
+				mailAccount.m_modTime = row[m_mailColumns.m_mTime];
+				mailAccount.m_lastMessageTime = row[m_mailColumns.m_minDate];
+
+				// Check user didn't recreate this mail account after having deleted it
+				set&lt;ustring&gt;::iterator mailIter = m_deletedMail.find(mailAccount.m_name);
+				if (mailIter != m_deletedMail.end())
+				{
+					m_deletedMail.erase(mailIter);
+				}
+
+#ifdef DEBUG
+				cout &lt;&lt; &quot;prefsDialog::save_mailTreeview: &quot; &lt;&lt; mailAccount.m_name &lt;&lt; endl;
+#endif
+				m_settings.m_mailAccounts.insert(mailAccount);
+			}
+#ifdef DEBUG
+			else cout &lt;&lt; &quot;prefsDialog::save_mailTreeview: format &quot; &lt;&lt; mimeType
+				&lt;&lt; &quot;, file &quot; &lt;&lt; row[m_mailColumns.m_location] &lt;&lt; &quot;, is not supported&quot; &lt;&lt; endl;
+#endif
+		}
+	}
+
+	// Remove all documents from deleted mail accounts
+	for (set&lt;ustring&gt;::iterator mailIter = m_deletedMail.begin(); mailIter != m_deletedMail.end(); ++mailIter)
+	{
+		string sourceLabel = &quot;<A HREF="mailbox://">mailbox://</A>&quot;;
+		sourceLabel += *mailIter;
+
+		// Reuse the labels list
+		m_deletedLabels.insert(sourceLabel);
+#ifdef DEBUG
+		cout &lt;&lt; &quot;prefsDialog::save_mailTreeview: will unindex documents from &quot; &lt;&lt; *mailIter &lt;&lt; endl;
+#endif
+	}
+
+	return true;
+}
+
+void prefsDialog::on_message_import(DocumentInfo docInfo)
+{
+	Url urlObj(docInfo.getLocation());
+	string mimeType = docInfo.getType();
+
+	if ((urlObj.getProtocol() == &quot;file&quot;) &amp;&amp;
+		(mimeType == &quot;text/x-mail&quot;))
+	{
+		string fileName = urlObj.getLocation();
+		fileName += &quot;/&quot;;
+		fileName += urlObj.getFile();
+
+		// Create a new entry in the mail accounts list
+		TreeModel::iterator iter = m_refMailTree-&gt;append();
+		TreeModel::Row row = *iter;
+
+		row[m_mailColumns.m_location] = locale_to_utf8(fileName);
+		row[m_mailColumns.m_type] = locale_to_utf8(mimeType);
+		row[m_mailColumns.m_mTime] = 0;
+		row[m_mailColumns.m_minDate] = 0;
+	}
+
+	// Enable these buttons
+	editAccountButton-&gt;set_sensitive(true);
+	removeAccountButton-&gt;set_sensitive(true);
+}
+
+void prefsDialog::on_prefsOkbutton_clicked()
+{
+	// Synchronise widgets with settings
+	m_settings.m_ignoreRobotsDirectives = ignoreRobotsCheckbutton-&gt;get_active();
+	// Default results view mode
+	int viewMode = viewCombobox-&gt;get_active_row_number();
+	if (viewMode == 0)
+	{
+		// Source
+		m_settings.m_browseResults = false;
+	}
+	else
+	{
+		// Browser
+		m_settings.m_browseResults = true;
+	}
+	m_settings.m_browserCommand = browserEntry-&gt;get_text();
+	m_settings.m_googleAPIKey = apiKeyEntry-&gt;get_text();
+
+	// Validate the current labels and mail accounts
+	save_labelsTreeview();
+	save_mailTreeview();
+}
+
+void prefsDialog::on_viewCombobox_changed()
+{
+	bool browseResults = true;
+
+	// Enable the browser entry field and button only if browsing is enabled
+	if (viewCombobox-&gt;get_active_row_number() == 0)
+	{
+		browseResults = false;
+	}
+
+	browserEntry-&gt;set_sensitive(browseResults);
+	browserButton-&gt;set_sensitive(browseResults);
+}
+
+void prefsDialog::on_browserButton_clicked()
+{
+	ustring browserCmd = browserEntry-&gt;get_text();
+	if (select_file_name(*this, _(&quot;Browser location&quot;), browserCmd, true) == true)
+	{
+		browserEntry-&gt;set_text(browserCmd);
+	}
+}
+
+void prefsDialog::on_addLabelButton_clicked()
+{
+	// Now create a new entry in the labels list
+	TreeModel::iterator iter = m_refLabelsTree-&gt;append();
+	TreeModel::Row row = *iter;
+	row[m_labelsColumns.m_name] = locale_to_utf8(_(&quot;New Label&quot;));
+	// This marks the label as new
+	row[m_labelsColumns.m_enabled] = false;
+	// FIXME: initialize the colour to something meaningful, depending on the current theme perhaps ?
+	Color labelColour;
+	labelColour.set_rgb(0, 0, 0);
+	row[m_labelsColumns.m_colour] = labelColour;
+
+	// Enable these buttons
+	editLabelButton-&gt;set_sensitive(true);
+	removeLabelButton-&gt;set_sensitive(true);
+}
+
+void prefsDialog::on_editLabelButton_clicked()
+{
+	// Get the selected label in the list
+	TreeModel::iterator iter = labelsTreeview-&gt;get_selection()-&gt;get_selected();
+	if (iter)
+	{
+		TreeModel::Row row = *iter;
+		ustring dialogTitle = row[m_labelsColumns.m_name];
+		dialogTitle += &quot; &quot;;
+		dialogTitle += _(&quot;Colour&quot;);
+		Color labelColour = row[m_labelsColumns.m_colour];
+
+		ColorSelectionDialog colorSelector(dialogTitle);
+		ColorSelection *colorSel = colorSelector.get_colorsel();
+		if (colorSel != NULL)
+		{
+			colorSel-&gt;set_has_opacity_control(false);
+			colorSel-&gt;set_current_color(labelColour);
+		}
+		colorSelector.set_transient_for(*this);
+		colorSelector.show();
+		int result = colorSelector.run();
+		if (result == RESPONSE_OK)
+		{
+			// Retrieve the chosen colour
+			labelColour = colorSel-&gt;get_current_color();
+#ifdef DEBUG
+			cout &lt;&lt; &quot;prefsDialog::on_editLabelButton_clicked: selected &quot; &lt;&lt; labelColour.get_red() &lt;&lt; &quot; &quot; &lt;&lt; labelColour.get_green() &lt;&lt; &quot; &quot; &lt;&lt; labelColour.get_blue() &lt;&lt; endl;
+#endif
+
+			row[m_labelsColumns.m_colour] = labelColour;
+		}
+	}
+}
+
+void prefsDialog::on_removeLabelButton_clicked()
+{
+	// Get the selected label in the list
+	TreeModel::iterator iter = labelsTreeview-&gt;get_selection()-&gt;get_selected();
+	if (iter)
+	{
+		// Unselect
+		labelsTreeview-&gt;get_selection()-&gt;unselect(iter);
+		// Select another row
+		TreeModel::Path path = m_refLabelsTree-&gt;get_path(iter);
+		path.next();
+		labelsTreeview-&gt;get_selection()-&gt;select(path);
+		// Erase
+		TreeModel::Row row = *iter;
+		m_deletedLabels.insert(locale_from_utf8(row[m_labelsColumns.m_name]));
+		m_refLabelsTree-&gt;erase(row);
+
+		TreeModel::Children children = m_refLabelsTree-&gt;children();
+		if (children.empty() == true)
+		{
+			// Disable these buttons
+			editLabelButton-&gt;set_sensitive(false);
+			removeLabelButton-&gt;set_sensitive(false);
+		}
+	}
+}
+
+bool prefsDialog::on_mailTreeview_button_press_event(GdkEventButton *ev)
+{
+	// Check for double clicks
+	if (ev-&gt;type == GDK_2BUTTON_PRESS)
+	{
+		on_editAccountButton_clicked();
+	}
+
+	return false;
+}
+
+void prefsDialog::on_addAccountButton_clicked()
+{
+	importDialog importBox(_(&quot;Import Mail Box(es)&quot;), false, true, true);
+
+	importBox.getImportFileSignal().connect(SigC::slot(*this,
+		&amp;prefsDialog::on_message_import));
+	importBox.show();
+	importBox.run();
+	// Let the signal handler deal with importing mail accounts
+}
+
+void prefsDialog::on_editAccountButton_clicked()
+{
+	// Get the selected mail account in the list
+	TreeModel::iterator iter = mailTreeview-&gt;get_selection()-&gt;get_selected();
+	if (iter)
+	{
+		TreeModel::Row row = *iter;
+		ustring fileName = row[m_mailColumns.m_location];
+		// Let the user edit the location
+		if (select_file_name(*this, _(&quot;Mbox File Location&quot;), fileName, true) == true)
+		{
+			row[m_mailColumns.m_location] = fileName;
+			row[m_mailColumns.m_type] = locale_to_utf8(MIMEScanner::scanFile(fileName));
+		}
+	}
+}
+
+void prefsDialog::on_removeAccountButton_clicked()
+{
+	// Get the selected mail account in the list
+	TreeModel::iterator iter = mailTreeview-&gt;get_selection()-&gt;get_selected();
+	if (iter)
+	{
+		// Unselect
+		mailTreeview-&gt;get_selection()-&gt;unselect(iter);
+		// Select another row
+		TreeModel::Path path = m_refMailTree-&gt;get_path(iter);
+		path.next();
+		mailTreeview-&gt;get_selection()-&gt;select(path);
+		// Erase
+		TreeModel::Row row = *iter;
+		m_deletedMail.insert(row[m_mailColumns.m_location]);
+		m_refMailTree-&gt;erase(row);
+
+		TreeModel::Children children = m_refMailTree-&gt;children();
+		if (children.empty() == true)
+		{
+			// Disable these buttons
+			editAccountButton-&gt;set_sensitive(false);
+			removeAccountButton-&gt;set_sensitive(false);
+		}
+	}
+}


Property changes on: trunk/UI/GTK2/src/prefsDialog.cc
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/prefsDialog.hh
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/prefsDialog.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,68 @@
+// generated 2003/5/18 21:15:37 BST by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to prefsDialog.hh_new
+
+// you might replace
+//    class foo : public foo_glade { ... };
+// by
+//    typedef foo_glade foo;
+// if you didn't make any modifications to the widget
+
+#ifndef _PREFSDIALOG_HH
+#define _PREFSDIALOG_HH
+
+#include &lt;string&gt;
+#include &lt;set&gt;
+#include &lt;glibmm/refptr.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gtkmm/liststore.h&gt;
+
+#include &quot;ModelColumns.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;prefsDialog_glade.hh&quot;
+
+class prefsDialog : public prefsDialog_glade
+{  
+public:
+	prefsDialog();
+	virtual ~prefsDialog();
+
+	const std::set&lt;std::string&gt; &amp;getMailLabelsToDelete(void) const;
+
+protected:
+	virtual void on_prefsOkbutton_clicked();
+	virtual void on_viewCombobox_changed();
+	virtual void on_browserButton_clicked();
+	virtual void on_addLabelButton_clicked();
+	virtual void on_editLabelButton_clicked();
+	virtual void on_removeLabelButton_clicked();
+	virtual bool on_mailTreeview_button_press_event(GdkEventButton *ev);
+	virtual void on_addAccountButton_clicked();
+	virtual void on_editAccountButton_clicked();
+	virtual void on_removeAccountButton_clicked();
+
+	void populate_comboboxes();
+	void populate_labelsTreeview();
+	bool save_labelsTreeview();
+	void populate_mailTreeview();
+	bool save_mailTreeview();
+	void on_message_import(DocumentInfo docInfo);
+
+private:
+	PinotSettings &amp;m_settings;
+	ComboModelColumns m_viewColumns;
+	Glib::RefPtr&lt;Gtk::ListStore&gt; m_refViewTree;
+	OtherIndexModelColumns m_otherIndexColumns;
+	Glib::RefPtr&lt;Gtk::ListStore&gt; m_refOtherIndexTree;
+	LabelModelColumns m_labelsColumns;
+	Glib::RefPtr&lt;Gtk::ListStore&gt; m_refLabelsTree;
+	MailAccountModelColumns m_mailColumns;
+	Glib::RefPtr&lt;Gtk::ListStore&gt; m_refMailTree;
+	std::set&lt;Glib::ustring&gt; m_deletedIndexes;
+	std::set&lt;std::string&gt; m_deletedLabels;
+	std::set&lt;Glib::ustring&gt; m_deletedMail;
+	static unsigned int m_maxDirLevel;
+
+};
+#endif


Property changes on: trunk/UI/GTK2/src/prefsDialog.hh
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/prefsDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/prefsDialog_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,408 @@
+// generated 2005/12/1 23:54:57 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/prefsDialog.cc
+
+
+#if defined __GNUC__ &amp;&amp; __GNUC__ &lt; 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include &quot;config.h&quot;
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include &lt;libintl.h&gt;
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include &lt;gtkmmconfig.h&gt;
+#if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
+#include &lt;sigc++/compatibility.h&gt;
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include &quot;prefsDialog_glade.hh&quot;
+#include &lt;gdk/gdkkeysyms.h&gt;
+#include &lt;gtkmm/accelgroup.h&gt;
+#include &lt;gtkmm/buttonbox.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/table.h&gt;
+#include &lt;gtkmm/scrolledwindow.h&gt;
+#include &lt;gtkmm/image.h&gt;
+#include &lt;gtkmm/alignment.h&gt;
+
+prefsDialog_glade::prefsDialog_glade(
+)
+{  prefsDialog = this;
+   gmm_data = new GlademmData(get_accel_group());
+   prefsCancelbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-cancel&quot;)));
+   prefsOkbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-ok&quot;)));
+   
+   Gtk::Label *robotsLabel = Gtk::manage(new class Gtk::Label(_(&quot;HTTP crawling:&quot;)));
+   Gtk::Label *viewLabel = Gtk::manage(new class Gtk::Label(_(&quot;View documents:&quot;)));
+   Gtk::Label *browserLabel = Gtk::manage(new class Gtk::Label(_(&quot;Browser:&quot;)));
+   apiKeyLabel = Gtk::manage(new class Gtk::Label(_(&quot;Google API Key:&quot;)));
+   apiKeyEntry = Gtk::manage(new class Gtk::Entry());
+   viewCombobox = Gtk::manage(new class Gtk::ComboBox());
+   ignoreRobotsCheckbutton = Gtk::manage(new class Gtk::CheckButton(_(&quot;Ignore robots.txt and Robots META tag&quot;)));
+   browserEntry = Gtk::manage(new class Gtk::Entry());
+   browserButton = Gtk::manage(new class Gtk::Button(_(&quot;...&quot;)));
+   
+   Gtk::HBox *browserHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   Gtk::Table *generalTable = Gtk::manage(new class Gtk::Table(2, 2, false));
+   Gtk::Label *generalLabel = Gtk::manage(new class Gtk::Label(_(&quot;General&quot;)));
+   Gtk::Label *indexLabelsLabel = Gtk::manage(new class Gtk::Label(_(&quot;Labels are used to classify indexed documents:&quot;)));
+   labelsTreeview = Gtk::manage(new class Gtk::TreeView());
+   
+   Gtk::ScrolledWindow *labelsScrolledwindow = Gtk::manage(new class Gtk::ScrolledWindow());
+   Gtk::Image *image235 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-add&quot;), Gtk::IconSize(4)));
+   Gtk::Label *label35 = Gtk::manage(new class Gtk::Label(_(&quot;Add&quot;)));
+   Gtk::HBox *hbox29 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment17 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
+   addLabelButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::Image *image237 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-select-color&quot;), Gtk::IconSize(4)));
+   Gtk::Label *label37 = Gtk::manage(new class Gtk::Label(_(&quot;Edit&quot;)));
+   Gtk::HBox *hbox31 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment19 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
+   editLabelButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::Image *image236 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-remove&quot;), Gtk::IconSize(4)));
+   Gtk::Label *label36 = Gtk::manage(new class Gtk::Label(_(&quot;Remove&quot;)));
+   Gtk::HBox *hbox30 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment18 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
+   removeLabelButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::VButtonBox *labelsVbuttonbox = Gtk::manage(new class Gtk::VButtonBox(Gtk::BUTTONBOX_START, 0));
+   Gtk::HBox *labelsHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   Gtk::VBox *labelsVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   Gtk::Label *labelsLabel = Gtk::manage(new class Gtk::Label(_(&quot;Labels&quot;)));
+   Gtk::Label *mailAccountsLabel = Gtk::manage(new class Gtk::Label(_(&quot;Mail boxes of type mbox can be monitored and indexed:&quot;)));
+   mailTreeview = Gtk::manage(new class Gtk::TreeView());
+   
+   Gtk::ScrolledWindow *mailScrolledwindow = Gtk::manage(new class Gtk::ScrolledWindow());
+   Gtk::Image *image497 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-add&quot;), Gtk::IconSize(4)));
+   Gtk::Label *label49 = Gtk::manage(new class Gtk::Label(_(&quot;Add&quot;)));
+   Gtk::HBox *hbox42 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment28 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
+   addAccountButton = Gtk::manage(new class Gtk::Button());
+   editAccountButton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-edit&quot;)));
+   removeAccountButton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-remove&quot;)));
+   
+   Gtk::VButtonBox *mailVbuttonbox = Gtk::manage(new class Gtk::VButtonBox(Gtk::BUTTONBOX_START, 0));
+   Gtk::HBox *mailHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   Gtk::VBox *mailVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   Gtk::Label *mailLabel = Gtk::manage(new class Gtk::Label(_(&quot;My Email&quot;)));
+   prefsNotebook = Gtk::manage(new class Gtk::Notebook());
+   prefsCancelbutton-&gt;set_flags(Gtk::CAN_FOCUS);
+   prefsCancelbutton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   prefsCancelbutton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   prefsOkbutton-&gt;set_flags(Gtk::CAN_FOCUS);
+   prefsOkbutton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   prefsOkbutton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   prefsDialog-&gt;get_action_area()-&gt;property_layout_style().set_value(Gtk::BUTTONBOX_END);
+   robotsLabel-&gt;set_alignment(0,0.5);
+   robotsLabel-&gt;set_padding(4,4);
+   robotsLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   robotsLabel-&gt;set_line_wrap(false);
+   robotsLabel-&gt;set_use_markup(false);
+   robotsLabel-&gt;set_selectable(false);
+   viewLabel-&gt;set_alignment(0,0.5);
+   viewLabel-&gt;set_padding(4,4);
+   viewLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   viewLabel-&gt;set_line_wrap(false);
+   viewLabel-&gt;set_use_markup(false);
+   viewLabel-&gt;set_selectable(false);
+   browserLabel-&gt;set_alignment(0,0.5);
+   browserLabel-&gt;set_padding(4,4);
+   browserLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   browserLabel-&gt;set_line_wrap(false);
+   browserLabel-&gt;set_use_markup(false);
+   browserLabel-&gt;set_selectable(false);
+   apiKeyLabel-&gt;set_alignment(0,0.5);
+   apiKeyLabel-&gt;set_padding(4,4);
+   apiKeyLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   apiKeyLabel-&gt;set_line_wrap(false);
+   apiKeyLabel-&gt;set_use_markup(false);
+   apiKeyLabel-&gt;set_selectable(false);
+   apiKeyEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   apiKeyEntry-&gt;set_visibility(true);
+   apiKeyEntry-&gt;set_editable(true);
+   apiKeyEntry-&gt;set_max_length(0);
+   apiKeyEntry-&gt;set_text(_(&quot;&quot;));
+   apiKeyEntry-&gt;set_has_frame(true);
+   apiKeyEntry-&gt;set_activates_default(false);
+   ignoreRobotsCheckbutton-&gt;set_flags(Gtk::CAN_FOCUS);
+   ignoreRobotsCheckbutton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   ignoreRobotsCheckbutton-&gt;set_mode(true);
+   ignoreRobotsCheckbutton-&gt;set_active(false);
+   browserEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   browserEntry-&gt;set_visibility(true);
+   browserEntry-&gt;set_editable(true);
+   browserEntry-&gt;set_max_length(0);
+   browserEntry-&gt;set_text(_(&quot;&quot;));
+   browserEntry-&gt;set_has_frame(true);
+   browserEntry-&gt;set_activates_default(false);
+   browserButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   browserButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   browserButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   browserHbox-&gt;pack_start(*browserEntry);
+   browserHbox-&gt;pack_start(*browserButton, Gtk::PACK_SHRINK, 4);
+   generalTable-&gt;set_row_spacings(0);
+   generalTable-&gt;set_col_spacings(0);
+   generalTable-&gt;attach(*robotsLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   generalTable-&gt;attach(*viewLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   generalTable-&gt;attach(*browserLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
+   generalTable-&gt;attach(*apiKeyLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   generalTable-&gt;attach(*apiKeyEntry, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   generalTable-&gt;attach(*viewCombobox, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   generalTable-&gt;attach(*ignoreRobotsCheckbutton, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   generalTable-&gt;attach(*browserHbox, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   generalLabel-&gt;set_alignment(0.5,0.5);
+   generalLabel-&gt;set_padding(0,0);
+   generalLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   generalLabel-&gt;set_line_wrap(false);
+   generalLabel-&gt;set_use_markup(false);
+   generalLabel-&gt;set_selectable(false);
+   indexLabelsLabel-&gt;set_alignment(0,0.5);
+   indexLabelsLabel-&gt;set_padding(4,4);
+   indexLabelsLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   indexLabelsLabel-&gt;set_line_wrap(true);
+   indexLabelsLabel-&gt;set_use_markup(false);
+   indexLabelsLabel-&gt;set_selectable(false);
+   labelsTreeview-&gt;set_flags(Gtk::CAN_FOCUS);
+   labelsTreeview-&gt;set_headers_visible(true);
+   labelsTreeview-&gt;set_rules_hint(false);
+   labelsTreeview-&gt;set_reorderable(false);
+   labelsTreeview-&gt;set_enable_search(true);
+   labelsScrolledwindow-&gt;set_flags(Gtk::CAN_FOCUS);
+   labelsScrolledwindow-&gt;set_border_width(4);
+   labelsScrolledwindow-&gt;set_shadow_type(Gtk::SHADOW_NONE);
+   labelsScrolledwindow-&gt;set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+   labelsScrolledwindow-&gt;property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+   labelsScrolledwindow-&gt;add(*labelsTreeview);
+   image235-&gt;set_alignment(0.5,0.5);
+   image235-&gt;set_padding(0,0);
+   label35-&gt;set_alignment(0.5,0.5);
+   label35-&gt;set_padding(0,0);
+   label35-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   label35-&gt;set_line_wrap(false);
+   label35-&gt;set_use_markup(false);
+   label35-&gt;set_selectable(false);
+   hbox29-&gt;pack_start(*image235, Gtk::PACK_SHRINK, 0);
+   hbox29-&gt;pack_start(*label35, Gtk::PACK_SHRINK, 0);
+   alignment17-&gt;add(*hbox29);
+   addLabelButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   addLabelButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   addLabelButton-&gt;set_border_width(4);
+   addLabelButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   addLabelButton-&gt;add(*alignment17);
+   image237-&gt;set_alignment(0.5,0.5);
+   image237-&gt;set_padding(0,0);
+   label37-&gt;set_alignment(0.5,0.5);
+   label37-&gt;set_padding(0,0);
+   label37-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   label37-&gt;set_line_wrap(false);
+   label37-&gt;set_use_markup(false);
+   label37-&gt;set_selectable(false);
+   hbox31-&gt;pack_start(*image237, Gtk::PACK_SHRINK, 0);
+   hbox31-&gt;pack_start(*label37, Gtk::PACK_SHRINK, 0);
+   alignment19-&gt;add(*hbox31);
+   editLabelButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   editLabelButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   editLabelButton-&gt;set_border_width(4);
+   editLabelButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   editLabelButton-&gt;add(*alignment19);
+   image236-&gt;set_alignment(0.5,0.5);
+   image236-&gt;set_padding(0,0);
+   label36-&gt;set_alignment(0.5,0.5);
+   label36-&gt;set_padding(0,0);
+   label36-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   label36-&gt;set_line_wrap(false);
+   label36-&gt;set_use_markup(false);
+   label36-&gt;set_selectable(false);
+   hbox30-&gt;pack_start(*image236, Gtk::PACK_SHRINK, 0);
+   hbox30-&gt;pack_start(*label36, Gtk::PACK_SHRINK, 0);
+   alignment18-&gt;add(*hbox30);
+   removeLabelButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   removeLabelButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   removeLabelButton-&gt;set_border_width(4);
+   removeLabelButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   removeLabelButton-&gt;add(*alignment18);
+   labelsVbuttonbox-&gt;pack_start(*addLabelButton);
+   labelsVbuttonbox-&gt;pack_start(*editLabelButton);
+   labelsVbuttonbox-&gt;pack_start(*removeLabelButton);
+   labelsHbox-&gt;pack_start(*labelsScrolledwindow);
+   labelsHbox-&gt;pack_start(*labelsVbuttonbox, Gtk::PACK_SHRINK, 0);
+   labelsVbox-&gt;pack_start(*indexLabelsLabel, Gtk::PACK_SHRINK, 4);
+   labelsVbox-&gt;pack_start(*labelsHbox, Gtk::PACK_EXPAND_WIDGET, 4);
+   labelsLabel-&gt;set_alignment(0.5,0.5);
+   labelsLabel-&gt;set_padding(0,0);
+   labelsLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   labelsLabel-&gt;set_line_wrap(false);
+   labelsLabel-&gt;set_use_markup(false);
+   labelsLabel-&gt;set_selectable(false);
+   mailAccountsLabel-&gt;set_alignment(0,0.5);
+   mailAccountsLabel-&gt;set_padding(4,4);
+   mailAccountsLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   mailAccountsLabel-&gt;set_line_wrap(true);
+   mailAccountsLabel-&gt;set_use_markup(false);
+   mailAccountsLabel-&gt;set_selectable(false);
+   mailTreeview-&gt;set_flags(Gtk::CAN_FOCUS);
+   mailTreeview-&gt;set_headers_visible(true);
+   mailTreeview-&gt;set_rules_hint(false);
+   mailTreeview-&gt;set_reorderable(false);
+   mailTreeview-&gt;set_enable_search(true);
+   mailScrolledwindow-&gt;set_flags(Gtk::CAN_FOCUS);
+   mailScrolledwindow-&gt;set_border_width(4);
+   mailScrolledwindow-&gt;set_shadow_type(Gtk::SHADOW_NONE);
+   mailScrolledwindow-&gt;set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+   mailScrolledwindow-&gt;property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+   mailScrolledwindow-&gt;add(*mailTreeview);
+   image497-&gt;set_alignment(0.5,0.5);
+   image497-&gt;set_padding(0,0);
+   label49-&gt;set_alignment(0.5,0.5);
+   label49-&gt;set_padding(0,0);
+   label49-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   label49-&gt;set_line_wrap(false);
+   label49-&gt;set_use_markup(false);
+   label49-&gt;set_selectable(false);
+   hbox42-&gt;pack_start(*image497, Gtk::PACK_SHRINK, 0);
+   hbox42-&gt;pack_start(*label49, Gtk::PACK_SHRINK, 0);
+   alignment28-&gt;add(*hbox42);
+   addAccountButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   addAccountButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   addAccountButton-&gt;set_border_width(4);
+   addAccountButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   addAccountButton-&gt;add(*alignment28);
+   editAccountButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   editAccountButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   editAccountButton-&gt;set_border_width(4);
+   editAccountButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   removeAccountButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   removeAccountButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   removeAccountButton-&gt;set_border_width(4);
+   removeAccountButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   mailVbuttonbox-&gt;pack_start(*addAccountButton);
+   mailVbuttonbox-&gt;pack_start(*editAccountButton);
+   mailVbuttonbox-&gt;pack_start(*removeAccountButton);
+   mailHbox-&gt;pack_start(*mailScrolledwindow);
+   mailHbox-&gt;pack_start(*mailVbuttonbox, Gtk::PACK_SHRINK, 0);
+   mailVbox-&gt;pack_start(*mailAccountsLabel, Gtk::PACK_SHRINK, 4);
+   mailVbox-&gt;pack_start(*mailHbox, Gtk::PACK_EXPAND_WIDGET, 4);
+   mailLabel-&gt;set_alignment(0.5,0.5);
+   mailLabel-&gt;set_padding(0,0);
+   mailLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   mailLabel-&gt;set_line_wrap(false);
+   mailLabel-&gt;set_use_markup(false);
+   mailLabel-&gt;set_selectable(false);
+   prefsNotebook-&gt;set_flags(Gtk::CAN_FOCUS);
+   prefsNotebook-&gt;set_show_tabs(true);
+   prefsNotebook-&gt;set_show_border(true);
+   prefsNotebook-&gt;set_tab_pos(Gtk::POS_TOP);
+   prefsNotebook-&gt;set_scrollable(false);
+   prefsNotebook-&gt;append_page(*generalTable, *generalLabel);
+   prefsNotebook-&gt;pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   prefsNotebook-&gt;append_page(*labelsVbox, *labelsLabel);
+   prefsNotebook-&gt;pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   prefsNotebook-&gt;append_page(*mailVbox, *mailLabel);
+   prefsNotebook-&gt;pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   prefsDialog-&gt;get_vbox()-&gt;set_homogeneous(false);
+   prefsDialog-&gt;get_vbox()-&gt;set_spacing(0);
+   prefsDialog-&gt;get_vbox()-&gt;pack_start(*prefsNotebook);
+   prefsDialog-&gt;set_title(_(&quot;Preferences&quot;));
+   prefsDialog-&gt;set_modal(false);
+   prefsDialog-&gt;property_window_position().set_value(Gtk::WIN_POS_NONE);
+   prefsDialog-&gt;set_resizable(true);
+   prefsDialog-&gt;property_destroy_with_parent().set_value(false);
+   prefsDialog-&gt;set_has_separator(true);
+   prefsDialog-&gt;add_action_widget(*prefsCancelbutton, -6);
+   prefsDialog-&gt;add_action_widget(*prefsOkbutton, -5);
+   prefsCancelbutton-&gt;show();
+   prefsOkbutton-&gt;show();
+   robotsLabel-&gt;show();
+   viewLabel-&gt;show();
+   browserLabel-&gt;show();
+   apiKeyLabel-&gt;show();
+   apiKeyEntry-&gt;show();
+   viewCombobox-&gt;show();
+   ignoreRobotsCheckbutton-&gt;show();
+   browserEntry-&gt;show();
+   browserButton-&gt;show();
+   browserHbox-&gt;show();
+   generalTable-&gt;show();
+   generalLabel-&gt;show();
+   indexLabelsLabel-&gt;show();
+   labelsTreeview-&gt;show();
+   labelsScrolledwindow-&gt;show();
+   image235-&gt;show();
+   label35-&gt;show();
+   hbox29-&gt;show();
+   alignment17-&gt;show();
+   addLabelButton-&gt;show();
+   image237-&gt;show();
+   label37-&gt;show();
+   hbox31-&gt;show();
+   alignment19-&gt;show();
+   editLabelButton-&gt;show();
+   image236-&gt;show();
+   label36-&gt;show();
+   hbox30-&gt;show();
+   alignment18-&gt;show();
+   removeLabelButton-&gt;show();
+   labelsVbuttonbox-&gt;show();
+   labelsHbox-&gt;show();
+   labelsVbox-&gt;show();
+   labelsLabel-&gt;show();
+   mailAccountsLabel-&gt;show();
+   mailTreeview-&gt;show();
+   mailScrolledwindow-&gt;show();
+   image497-&gt;show();
+   label49-&gt;show();
+   hbox42-&gt;show();
+   alignment28-&gt;show();
+   addAccountButton-&gt;show();
+   editAccountButton-&gt;show();
+   removeAccountButton-&gt;show();
+   mailVbuttonbox-&gt;show();
+   mailHbox-&gt;show();
+   mailVbox-&gt;show();
+   mailLabel-&gt;show();
+   prefsNotebook-&gt;show();
+   prefsDialog-&gt;show();
+   prefsOkbutton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;prefsDialog_glade::on_prefsOkbutton_clicked), false);
+   viewCombobox-&gt;signal_changed().connect(SigC::slot(*this, &amp;prefsDialog_glade::on_viewCombobox_changed), false);
+   browserButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;prefsDialog_glade::on_browserButton_clicked), false);
+   addLabelButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;prefsDialog_glade::on_addLabelButton_clicked), false);
+   editLabelButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;prefsDialog_glade::on_editLabelButton_clicked), false);
+   removeLabelButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;prefsDialog_glade::on_removeLabelButton_clicked), false);
+   mailTreeview-&gt;signal_button_press_event().connect(SigC::slot(*this, &amp;prefsDialog_glade::on_mailTreeview_button_press_event), false);
+   addAccountButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;prefsDialog_glade::on_addAccountButton_clicked), false);
+   editAccountButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;prefsDialog_glade::on_editAccountButton_clicked), false);
+   removeAccountButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;prefsDialog_glade::on_removeAccountButton_clicked), false);
+}
+
+prefsDialog_glade::~prefsDialog_glade()
+{  delete gmm_data;
+}


Property changes on: trunk/UI/GTK2/src/prefsDialog_glade.cc
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/prefsDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/prefsDialog_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/prefsDialog_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,83 @@
+// generated 2005/11/29 20:59:00 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/prefsDialog.hh and./src/prefsDialog.cc
+
+#ifndef _PREFSDIALOG_GLADE_HH
+#  define _PREFSDIALOG_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include &lt;gtkmm/accelgroup.h&gt;
+
+class GlademmData
+{  
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt; accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr&lt;Gtk::AccelGroup&gt; ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt;  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include &lt;gtkmm/dialog.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/entry.h&gt;
+#include &lt;gtkmm/combobox.h&gt;
+#include &lt;gtkmm/checkbutton.h&gt;
+#include &lt;gtkmm/treeview.h&gt;
+#include &lt;gtkmm/notebook.h&gt;
+
+class prefsDialog_glade : public Gtk::Dialog
+{  
+        
+        GlademmData *gmm_data;
+public:
+        class Gtk::Dialog * prefsDialog;
+protected:
+        class Gtk::Button * prefsCancelbutton;
+        class Gtk::Button * prefsOkbutton;
+        class Gtk::Label * apiKeyLabel;
+        class Gtk::Entry * apiKeyEntry;
+        class Gtk::ComboBox * viewCombobox;
+        class Gtk::CheckButton * ignoreRobotsCheckbutton;
+        class Gtk::Entry * browserEntry;
+        class Gtk::Button * browserButton;
+        class Gtk::TreeView * labelsTreeview;
+        class Gtk::Button * addLabelButton;
+        class Gtk::Button * editLabelButton;
+        class Gtk::Button * removeLabelButton;
+        class Gtk::TreeView * mailTreeview;
+        class Gtk::Button * addAccountButton;
+        class Gtk::Button * editAccountButton;
+        class Gtk::Button * removeAccountButton;
+        class Gtk::Notebook * prefsNotebook;
+        
+        prefsDialog_glade();
+        
+        ~prefsDialog_glade();
+private:
+        virtual void on_prefsOkbutton_clicked() = 0;
+        virtual void on_viewCombobox_changed() = 0;
+        virtual void on_browserButton_clicked() = 0;
+        virtual void on_addLabelButton_clicked() = 0;
+        virtual void on_editLabelButton_clicked() = 0;
+        virtual void on_removeLabelButton_clicked() = 0;
+        virtual bool on_mailTreeview_button_press_event(GdkEventButton *ev) = 0;
+        virtual void on_addAccountButton_clicked() = 0;
+        virtual void on_editAccountButton_clicked() = 0;
+        virtual void on_removeAccountButton_clicked() = 0;
+};
+#endif


Property changes on: trunk/UI/GTK2/src/prefsDialog_glade.hh
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/propertiesDialog.cc
===================================================================
--- trunk/UI/GTK2/src/propertiesDialog.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/propertiesDialog.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,174 @@
+// generated 2004/8/13 22:59:43 BST by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0_cvs
+//
+// newer (non customized) versions of this file go to propertiesDialog.cc_new
+
+// This file is for your program, I won't touch it again!
+
+#include &lt;iostream&gt;
+#include &lt;glibmm/convert.h&gt;
+#include &lt;pangomm/font.h&gt;
+#include &lt;gtkmm/rc.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;propertiesDialog.hh&quot;
+
+using namespace std;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+propertiesDialog::propertiesDialog(const std::set&lt;std::string&gt; &amp;docLabels,
+	const DocumentInfo &amp;docInfo, bool editDocument) :
+	propertiesDialog_glade(),
+	m_editDocument(editDocument),
+	m_docInfo(docInfo)
+{
+	// Associate the columns model to the labels tree
+	m_refLabelsTree = ListStore::create(m_labelsColumns);
+	labelsTreeview-&gt;set_model(m_refLabelsTree);
+	labelsTreeview-&gt;append_column_editable(&quot; &quot;, m_labelsColumns.m_enabled);
+	labelsTreeview-&gt;append_column(_(&quot;Label&quot;), m_labelsColumns.m_name);
+	// Allow only single selection
+	labelsTreeview-&gt;get_selection()-&gt;set_mode(SELECTION_SINGLE);
+
+	if (m_editDocument == true)
+	{
+		ustring language = to_utf8(docInfo.getLanguage());
+
+		titleEntry-&gt;set_text(to_utf8(docInfo.getTitle()));
+		if (language.empty() == true)
+		{
+			language = _(&quot;Unknown&quot;);
+		}
+		languageEntry-&gt;set_text(language);
+		typeEntry-&gt;set_text(to_utf8(docInfo.getType()));
+	}
+	else
+	{
+		titleLabel-&gt;hide();
+		titleEntry-&gt;hide();
+		languageLabel-&gt;hide();
+		languageEntry-&gt;hide();
+		typeLabel-&gt;hide();
+		typeEntry-&gt;hide();
+	}
+	// FIXME: get the extract
+	extractLabel-&gt;hide();
+	extractScrolledwindow-&gt;hide();
+
+	populate_labelsTreeview(docLabels);
+}
+
+propertiesDialog::~propertiesDialog()
+{
+}
+
+void propertiesDialog::populate_labelsTreeview(const set&lt;string&gt; &amp;docLabels)
+{
+	TreeModel::iterator iter;
+	TreeModel::Row row;
+
+	// Populate the tree
+	const set&lt;PinotSettings::Label&gt; &amp;sysLabels = PinotSettings::getInstance().m_labels;
+	for (set&lt;PinotSettings::Label&gt;::const_iterator labelIter = sysLabels.begin(); labelIter != sysLabels.end(); ++labelIter)
+	{
+		// Create a new row
+		iter = m_refLabelsTree-&gt;append();
+		row = *iter;
+
+		row[m_labelsColumns.m_name] = labelIter-&gt;m_name;
+		string labelName = locale_from_utf8(labelIter-&gt;m_name);
+		// Is it in the document labels list ?
+		set&lt;string&gt;::const_iterator iter = find(docLabels.begin(), docLabels.end(), labelName);
+		if (iter != docLabels.end())
+		{
+			// Yup
+			row[m_labelsColumns.m_enabled] = true;
+		}
+		else
+		{
+			row[m_labelsColumns.m_enabled] = false;
+		}
+	}
+}
+
+void propertiesDialog::setHeight(int maxHeight)
+{
+	// FIXME: there must be a better way to determine how high the tree should be
+	// for all rows to be visible !
+	int labelsCount = m_refLabelsTree-&gt;children().size();
+	// By default, the tree is high enough for two rows to be visible
+	if (labelsCount &gt; 2)
+	{
+		int width, height;
+		get_size(width, height);
+
+		RefPtr&lt;Style&gt; refRCStyle = RC::get_style(*labelsTreeview);
+		int fontSize = refRCStyle-&gt;get_font().get_size() / Pango::SCALE;
+#ifdef DEBUG
+		cout &lt;&lt; &quot;propertiesDialog::setHeight: max &quot; &lt;&lt; maxHeight &lt;&lt; &quot;, dialog &quot; &lt;&lt; height
+			&lt;&lt; &quot;, font &quot; &lt;&lt; fontSize &lt;&lt; &quot; &quot; &lt;&lt; refRCStyle-&gt;get_font().get_size() &lt;&lt; endl;
+#endif
+		height += fontSize * (labelsCount - 2);
+
+		TreeViewColumn *pColumn = labelsTreeview-&gt;get_column(1);
+		if (pColumn != NULL)
+		{
+			Rectangle cell_area;
+			int x_offset, y_offset, cellWidth, cellHeight;
+			pColumn-&gt;cell_get_size(cell_area, x_offset, y_offset, cellWidth, cellHeight);
+#ifdef DEBUG
+			cout &lt;&lt; &quot;propertiesDialog::setHeight: cell &quot; &lt;&lt; cellHeight &lt;&lt; &quot; &quot; &lt;&lt; y_offset &lt;&lt; endl;
+#endif
+			height += cellHeight * (labelsCount - 2);
+		}
+#ifdef DEBUG
+		cout &lt;&lt; &quot;propertiesDialog::setHeight: dialog &quot; &lt;&lt; height &lt;&lt; endl;
+#endif
+
+		if (height &gt; maxHeight)
+		{
+			height = maxHeight;
+		}
+		resize(width, height);
+	}
+}
+
+const DocumentInfo &amp;propertiesDialog::getDocumentInfo(void)
+{
+	return m_docInfo;
+}
+
+const set&lt;string&gt; &amp;propertiesDialog::getLabels(void) const
+{
+	return m_labels;
+}
+
+void propertiesDialog::on_labelOkButton_clicked()
+{
+	if (m_editDocument == true)
+	{
+		// Title
+		m_docInfo.setTitle(locale_from_utf8(titleEntry-&gt;get_text()));
+	}
+	// Go through the labels tree
+	TreeModel::Children children = m_refLabelsTree-&gt;children();
+	if (children.empty() == false)
+	{
+		for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
+		{
+			TreeModel::Row row = *iter;
+
+			bool enabled = row[m_labelsColumns.m_enabled];
+			if (enabled == true)
+			{
+				ustring labelName = row[m_labelsColumns.m_name];
+				m_labels.insert(locale_from_utf8(labelName));
+			}
+		}
+	}
+}

Added: trunk/UI/GTK2/src/propertiesDialog.hh
===================================================================
--- trunk/UI/GTK2/src/propertiesDialog.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/propertiesDialog.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+// generated 2004/8/13 22:59:43 BST by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0_cvs
+//
+// newer (non customized) versions of this file go to propertiesDialog.hh_new
+
+// you might replace
+//    class foo : public foo_glade { ... };
+// by
+//    typedef foo_glade foo;
+// if you didn't make any modifications to the widget
+
+#ifndef _LABELDIALOG_HH
+#define _LABELDIALOG_HH
+
+#include &lt;string&gt;
+#include &lt;set&gt;
+#include &lt;glibmm/refptr.h&gt;
+#include &lt;gtkmm/liststore.h&gt;
+
+#include &quot;DocumentInfo.h&quot;
+#include &quot;ModelColumns.h&quot;
+#include &quot;propertiesDialog_glade.hh&quot;
+
+class propertiesDialog : public propertiesDialog_glade
+{  
+public:
+	propertiesDialog(const std::set&lt;std::string&gt; &amp;docLabels,
+		const DocumentInfo &amp;docInfo, bool editDocument = true);
+	virtual ~propertiesDialog();
+
+	void setHeight(int maxHeight);
+
+	const DocumentInfo &amp;getDocumentInfo(void);
+
+	const std::set&lt;std::string&gt; &amp;getLabels(void) const;
+
+protected:
+	LabelModelColumns m_labelsColumns;
+	Glib::RefPtr&lt;Gtk::ListStore&gt; m_refLabelsTree;
+	std::set&lt;std::string&gt; m_labels;
+	bool m_editDocument;
+	DocumentInfo m_docInfo;
+
+	void populate_labelsTreeview(const std::set&lt;std::string&gt; &amp;docLabels);
+
+	void on_labelOkButton_clicked();
+
+};
+#endif // _LABELDIALOG_HH

Added: trunk/UI/GTK2/src/propertiesDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/propertiesDialog_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/propertiesDialog_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,204 @@
+// generated 2005/11/26 18:15:06 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/propertiesDialog.cc
+
+
+#if defined __GNUC__ &amp;&amp; __GNUC__ &lt; 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include &quot;config.h&quot;
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include &lt;libintl.h&gt;
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include &lt;gtkmmconfig.h&gt;
+#if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
+#include &lt;sigc++/compatibility.h&gt;
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include &quot;propertiesDialog_glade.hh&quot;
+#include &lt;gdk/gdkkeysyms.h&gt;
+#include &lt;gtkmm/accelgroup.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/buttonbox.h&gt;
+#include &lt;gtkmm/table.h&gt;
+#include &lt;gtkmm/viewport.h&gt;
+#include &lt;gtkmm/adjustment.h&gt;
+#include &lt;gtkmm/box.h&gt;
+
+propertiesDialog_glade::propertiesDialog_glade(
+)
+{  propertiesDialog = this;
+   gmm_data = new GlademmData(get_accel_group());
+   
+   Gtk::Button *cancelbutton2 = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-cancel&quot;)));
+   labelOkButton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-ok&quot;)));
+   titleEntry = Gtk::manage(new class Gtk::Entry());
+   extractTextview = Gtk::manage(new class Gtk::TextView());
+   extractScrolledwindow = Gtk::manage(new class Gtk::ScrolledWindow());
+   titleLabel = Gtk::manage(new class Gtk::Label(_(&quot;Title:&quot;)));
+   extractLabel = Gtk::manage(new class Gtk::Label(_(&quot;Extract:&quot;)));
+   languageLabel = Gtk::manage(new class Gtk::Label(_(&quot;Language:&quot;)));
+   languageEntry = Gtk::manage(new class Gtk::Entry());
+   typeLabel = Gtk::manage(new class Gtk::Label(_(&quot;Type:&quot;)));
+   typeEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Table *propertiesTable = Gtk::manage(new class Gtk::Table(2, 2, false));
+   labelsTreeview = Gtk::manage(new class Gtk::TreeView());
+   
+   Gtk::Viewport *viewport1 = Gtk::manage(new class Gtk::Viewport(*manage(new Gtk::Adjustment(0,0,1)), *manage(new Gtk::Adjustment(0,0,1))));
+   labelsScrolledwindow = Gtk::manage(new class Gtk::ScrolledWindow());
+   
+   Gtk::VBox *propertiesVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   cancelbutton2-&gt;set_flags(Gtk::CAN_FOCUS);
+   cancelbutton2-&gt;set_flags(Gtk::CAN_DEFAULT);
+   cancelbutton2-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   labelOkButton-&gt;set_flags(Gtk::CAN_FOCUS);
+   labelOkButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   labelOkButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   propertiesDialog-&gt;get_action_area()-&gt;property_layout_style().set_value(Gtk::BUTTONBOX_END);
+   titleEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   titleEntry-&gt;set_visibility(true);
+   titleEntry-&gt;set_editable(true);
+   titleEntry-&gt;set_max_length(0);
+   titleEntry-&gt;set_text(_(&quot;&quot;));
+   titleEntry-&gt;set_has_frame(true);
+   titleEntry-&gt;set_activates_default(false);
+   extractTextview-&gt;set_flags(Gtk::CAN_FOCUS);
+   extractTextview-&gt;set_editable(true);
+   extractTextview-&gt;set_cursor_visible(true);
+   extractTextview-&gt;set_pixels_above_lines(0);
+   extractTextview-&gt;set_pixels_below_lines(0);
+   extractTextview-&gt;set_pixels_inside_wrap(0);
+   extractTextview-&gt;set_left_margin(3);
+   extractTextview-&gt;set_right_margin(0);
+   extractTextview-&gt;set_indent(0);
+   extractTextview-&gt;set_wrap_mode(Gtk::WRAP_NONE);
+   extractTextview-&gt;set_justification(Gtk::JUSTIFY_LEFT);
+   extractScrolledwindow-&gt;set_flags(Gtk::CAN_FOCUS);
+   extractScrolledwindow-&gt;set_shadow_type(Gtk::SHADOW_IN);
+   extractScrolledwindow-&gt;set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+   extractScrolledwindow-&gt;property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+   extractScrolledwindow-&gt;add(*extractTextview);
+   titleLabel-&gt;set_alignment(0,0.5);
+   titleLabel-&gt;set_padding(4,4);
+   titleLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   titleLabel-&gt;set_line_wrap(false);
+   titleLabel-&gt;set_use_markup(false);
+   titleLabel-&gt;set_selectable(false);
+   extractLabel-&gt;set_alignment(0,0.5);
+   extractLabel-&gt;set_padding(4,4);
+   extractLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   extractLabel-&gt;set_line_wrap(false);
+   extractLabel-&gt;set_use_markup(false);
+   extractLabel-&gt;set_selectable(false);
+   languageLabel-&gt;set_alignment(0,0.5);
+   languageLabel-&gt;set_padding(4,4);
+   languageLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   languageLabel-&gt;set_line_wrap(false);
+   languageLabel-&gt;set_use_markup(false);
+   languageLabel-&gt;set_selectable(false);
+   languageEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   languageEntry-&gt;set_visibility(true);
+   languageEntry-&gt;set_editable(false);
+   languageEntry-&gt;set_max_length(0);
+   languageEntry-&gt;set_text(_(&quot;&quot;));
+   languageEntry-&gt;set_has_frame(true);
+   languageEntry-&gt;set_activates_default(false);
+   typeLabel-&gt;set_alignment(0,0.5);
+   typeLabel-&gt;set_padding(4,4);
+   typeLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   typeLabel-&gt;set_line_wrap(false);
+   typeLabel-&gt;set_use_markup(false);
+   typeLabel-&gt;set_selectable(false);
+   typeEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   typeEntry-&gt;set_visibility(true);
+   typeEntry-&gt;set_editable(false);
+   typeEntry-&gt;set_max_length(0);
+   typeEntry-&gt;set_text(_(&quot;&quot;));
+   typeEntry-&gt;set_has_frame(true);
+   typeEntry-&gt;set_activates_default(false);
+   propertiesTable-&gt;set_row_spacings(0);
+   propertiesTable-&gt;set_col_spacings(0);
+   propertiesTable-&gt;attach(*titleEntry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   propertiesTable-&gt;attach(*extractScrolledwindow, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   propertiesTable-&gt;attach(*titleLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   propertiesTable-&gt;attach(*extractLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   propertiesTable-&gt;attach(*languageLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
+   propertiesTable-&gt;attach(*languageEntry, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   propertiesTable-&gt;attach(*typeLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   propertiesTable-&gt;attach(*typeEntry, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   labelsTreeview-&gt;set_flags(Gtk::CAN_FOCUS);
+   labelsTreeview-&gt;set_headers_visible(true);
+   labelsTreeview-&gt;set_rules_hint(false);
+   labelsTreeview-&gt;set_reorderable(false);
+   labelsTreeview-&gt;set_enable_search(true);
+   viewport1-&gt;set_shadow_type(Gtk::SHADOW_IN);
+   viewport1-&gt;add(*labelsTreeview);
+   labelsScrolledwindow-&gt;set_flags(Gtk::CAN_FOCUS);
+   labelsScrolledwindow-&gt;set_border_width(4);
+   labelsScrolledwindow-&gt;set_shadow_type(Gtk::SHADOW_NONE);
+   labelsScrolledwindow-&gt;set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+   labelsScrolledwindow-&gt;property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+   labelsScrolledwindow-&gt;add(*viewport1);
+   propertiesVbox-&gt;pack_start(*propertiesTable, Gtk::PACK_SHRINK, 0);
+   propertiesVbox-&gt;pack_start(*labelsScrolledwindow);
+   propertiesDialog-&gt;get_vbox()-&gt;set_homogeneous(false);
+   propertiesDialog-&gt;get_vbox()-&gt;set_spacing(0);
+   propertiesDialog-&gt;get_vbox()-&gt;pack_start(*propertiesVbox);
+   propertiesDialog-&gt;set_title(_(&quot;Properties&quot;));
+   propertiesDialog-&gt;set_modal(false);
+   propertiesDialog-&gt;property_window_position().set_value(Gtk::WIN_POS_NONE);
+   propertiesDialog-&gt;set_resizable(true);
+   propertiesDialog-&gt;property_destroy_with_parent().set_value(false);
+   propertiesDialog-&gt;set_has_separator(true);
+   propertiesDialog-&gt;add_action_widget(*cancelbutton2, -6);
+   propertiesDialog-&gt;add_action_widget(*labelOkButton, -5);
+   cancelbutton2-&gt;show();
+   labelOkButton-&gt;show();
+   titleEntry-&gt;show();
+   extractTextview-&gt;show();
+   extractScrolledwindow-&gt;show();
+   titleLabel-&gt;show();
+   extractLabel-&gt;show();
+   languageLabel-&gt;show();
+   languageEntry-&gt;show();
+   typeLabel-&gt;show();
+   typeEntry-&gt;show();
+   propertiesTable-&gt;show();
+   labelsTreeview-&gt;show();
+   viewport1-&gt;show();
+   labelsScrolledwindow-&gt;show();
+   propertiesVbox-&gt;show();
+   propertiesDialog-&gt;show();
+   labelOkButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;propertiesDialog_glade::on_labelOkButton_clicked), false);
+}
+
+propertiesDialog_glade::~propertiesDialog_glade()
+{  delete gmm_data;
+}

Added: trunk/UI/GTK2/src/propertiesDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/propertiesDialog_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/propertiesDialog_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,68 @@
+// generated 2005/11/26 18:15:06 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/propertiesDialog.hh and./src/propertiesDialog.cc
+
+#ifndef _PROPERTIESDIALOG_GLADE_HH
+#  define _PROPERTIESDIALOG_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include &lt;gtkmm/accelgroup.h&gt;
+
+class GlademmData
+{  
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt; accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr&lt;Gtk::AccelGroup&gt; ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt;  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include &lt;gtkmm/dialog.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/entry.h&gt;
+#include &lt;gtkmm/textview.h&gt;
+#include &lt;gtkmm/scrolledwindow.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/treeview.h&gt;
+
+class propertiesDialog_glade : public Gtk::Dialog
+{  
+        
+        GlademmData *gmm_data;
+public:
+        class Gtk::Dialog * propertiesDialog;
+protected:
+        class Gtk::Button * labelOkButton;
+        class Gtk::Entry * titleEntry;
+        class Gtk::TextView * extractTextview;
+        class Gtk::ScrolledWindow * extractScrolledwindow;
+        class Gtk::Label * titleLabel;
+        class Gtk::Label * extractLabel;
+        class Gtk::Label * languageLabel;
+        class Gtk::Entry * languageEntry;
+        class Gtk::Label * typeLabel;
+        class Gtk::Entry * typeEntry;
+        class Gtk::TreeView * labelsTreeview;
+        class Gtk::ScrolledWindow * labelsScrolledwindow;
+        
+        propertiesDialog_glade();
+        
+        ~propertiesDialog_glade();
+private:
+        virtual void on_labelOkButton_clicked() = 0;
+};
+#endif

Added: trunk/UI/GTK2/src/queryDialog.cc
===================================================================
--- trunk/UI/GTK2/src/queryDialog.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/queryDialog.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,221 @@
+// generated 2003/6/13 20:26:49 BST by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to queryDialog.cc_new
+
+// This file is for your program, I won't touch it again!
+
+#include &lt;iostream&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;glibmm/convert.h&gt;
+#include &lt;gtkmm/menu.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;Languages.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;queryDialog.hh&quot;
+
+using namespace std;
+using namespace Glib;
+using namespace Gtk;
+
+queryDialog::queryDialog(QueryProperties &amp;properties) :
+	queryDialog_glade(),
+	m_name(properties.getName()),
+	m_properties(properties),
+	m_labels(PinotSettings::getInstance().m_labels),
+	m_badName(true)
+{
+	string name = m_properties.getName();
+
+	// Associate the columns model to the label combo
+	m_refLabelTree = ListStore::create(m_labelColumns);
+	labelCombobox-&gt;set_model(m_refLabelTree);
+	labelCombobox-&gt;pack_start(m_labelColumns.m_name);
+	// Associate the columns model to the language combo
+	m_refLanguageTree = ListStore::create(m_languageColumns);
+	languageCombobox-&gt;set_model(m_refLanguageTree);
+	languageCombobox-&gt;pack_start(m_languageColumns.m_name);
+	// Populate
+	populate_comboboxes();
+
+	// Name
+	if (name.empty() == true)
+	{
+		queryOkbutton-&gt;set_sensitive(false);
+	}
+	else
+	{
+		nameEntry-&gt;set_text(locale_to_utf8(name));
+	}
+	// Query terms
+	andEntry-&gt;set_text(locale_to_utf8(m_properties.getAndWords()));
+	phraseEntry-&gt;set_text(locale_to_utf8(m_properties.getPhrase()));
+	anyEntry-&gt;set_text(locale_to_utf8(m_properties.getAnyWords()));
+	notEntry-&gt;set_text(locale_to_utf8(m_properties.getNotWords()));
+
+	// Host name
+	hostNameEntry-&gt;set_text(locale_to_utf8(m_properties.getHostNameFilter()));
+	// File name
+	fileNameEntry-&gt;set_text(locale_to_utf8(m_properties.getFileNameFilter()));
+	// Maximum number of results
+	resultsCountSpinbutton-&gt;set_value((double)m_properties.getMaximumResultsCount());
+	// Index all results
+	indexCheckbutton-&gt;set_active(m_properties.getIndexResults());
+}
+
+queryDialog::~queryDialog()
+{
+}
+
+void queryDialog::populate_comboboxes()
+{
+	unsigned int labelNum = 1;
+	bool foundLanguage = false;
+
+	TreeModel::iterator iter = m_refLabelTree-&gt;append();
+	TreeModel::Row row = *iter;
+	row[m_labelColumns.m_name] = &quot;None&quot;;
+	labelCombobox-&gt;set_active(0);
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;queryDialog::populate_comboboxes: looking for &quot; &lt;&lt; m_properties.getLabelName() &lt;&lt; endl;
+#endif
+	// Add all labels to the combo and select the one defined for the query
+	for (set&lt;PinotSettings::Label&gt;::const_iterator labelIter = m_labels.begin(); labelIter != m_labels.end(); ++labelIter)
+	{
+		string labelName = labelIter-&gt;m_name;
+
+		iter = m_refLabelTree-&gt;append();
+		row = *iter;
+		row[m_labelColumns.m_name] = locale_to_utf8(labelName);
+#ifdef DEBUG
+	cout &lt;&lt; &quot;queryDialog::populate_comboboxes: added label &quot; &lt;&lt; labelName &lt;&lt; endl;
+#endif
+
+		if (labelName == m_properties.getLabelName())
+		{
+			labelCombobox-&gt;set_active(labelNum);
+			// Keep going
+		}
+		++labelNum;
+	}
+
+	string queryLanguage = m_properties.getLanguage();
+	iter = m_refLanguageTree-&gt;append();
+	row = *iter;
+	row[m_languageColumns.m_name] = _(&quot;Any&quot;);
+
+	// Add all supported languages and select the one defined for the query
+#ifdef DEBUG
+	cout &lt;&lt; &quot;queryDialog::populate_comboboxes: looking for &quot; &lt;&lt; queryLanguage &lt;&lt; endl;
+#endif
+	for (unsigned int languageNum = 0; languageNum &lt; Languages::m_count; ++languageNum)
+	{
+		string languageName = Languages::getIntlName(languageNum);
+		iter = m_refLanguageTree-&gt;append();
+		row = *iter;
+		row[m_languageColumns.m_name] = languageName;
+
+		if ((foundLanguage == false) &amp;&amp;
+			(queryLanguage.empty() == false) &amp;&amp;
+			(queryLanguage == languageName))
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;queryDialog::populate_comboboxes: found at &quot; &lt;&lt; languageNum &lt;&lt; endl;
+#endif
+			languageCombobox-&gt;set_active(languageNum + 1);
+			foundLanguage = true;
+		}
+	}
+	if (foundLanguage == false)
+	{
+		languageCombobox-&gt;set_active(0);
+	}
+}
+
+bool queryDialog::badName(void) const
+{
+	return m_badName;
+}
+void queryDialog::on_queryOkbutton_clicked()
+{
+	// Name
+	m_properties.setName(locale_from_utf8(nameEntry-&gt;get_text()));
+	m_badName = false;
+	// Did the name change ?
+	if (m_name != m_properties.getName())
+	{
+		const std::map&lt;string, QueryProperties&gt; &amp;queries = PinotSettings::getInstance().getQueries();
+
+		// Is it already used ?
+		std::map&lt;string, QueryProperties&gt;::const_iterator queryIter = queries.find(m_properties.getName());
+		if (queryIter != queries.end())
+		{
+			// Yes, it is
+			m_badName = true;
+#ifdef DEBUG
+			cout &lt;&lt; &quot;queryDialog::on_queryOkbutton_clicked: name in use&quot; &lt;&lt; endl;
+#endif
+		}
+	}
+
+	// Query terms
+	m_properties.setAndWords(locale_from_utf8(andEntry-&gt;get_text()));
+	m_properties.setPhrase(locale_from_utf8(phraseEntry-&gt;get_text()));
+	m_properties.setAnyWords(locale_from_utf8(anyEntry-&gt;get_text()));
+	m_properties.setNotWords(locale_from_utf8(notEntry-&gt;get_text()));
+	// Language
+	m_properties.setLanguage(&quot;&quot;);
+	int chosenLanguage = languageCombobox-&gt;get_active_row_number();
+	if (chosenLanguage &lt; Languages::m_count + 1)
+	{
+		if (chosenLanguage &gt; 0)
+		{
+			--chosenLanguage;
+			m_properties.setLanguage(Languages::getIntlName(chosenLanguage));
+		}
+	}
+	// Host name
+	m_properties.setHostNameFilter(locale_from_utf8(hostNameEntry-&gt;get_text()));
+	// File name
+	m_properties.setFileNameFilter(locale_from_utf8(fileNameEntry-&gt;get_text()));
+	// Maximum number of results
+	m_properties.setMaximumResultsCount((unsigned int)resultsCountSpinbutton-&gt;get_value());
+	// Index all results
+	m_properties.setIndexResults(indexCheckbutton-&gt;get_active());
+	// Label
+	int chosenLabel = labelCombobox-&gt;get_active_row_number();
+#ifdef DEBUG
+	cout &lt;&lt; &quot;queryDialog::on_queryOkbutton_clicked: chosen label &quot; &lt;&lt; chosenLabel &lt;&lt; endl;
+#endif
+	if (chosenLabel == 0)
+	{
+		// No label
+		m_properties.setLabelName(&quot;&quot;);
+	}
+	else
+	{
+		TreeModel::iterator iter = labelCombobox-&gt;get_active();
+		TreeModel::Row row = *iter;
+		string labelName = locale_from_utf8(row[m_labelColumns.m_name]);
+
+#ifdef DEBUG
+		cout &lt;&lt; &quot;queryDialog::on_queryOkbutton_clicked: label is &quot; &lt;&lt; labelName &lt;&lt; endl;
+#endif
+		m_properties.setLabelName(labelName);
+	}
+}
+
+void queryDialog::on_nameEntry_changed()
+{
+	ustring name = nameEntry-&gt;get_text();
+	if (name.empty() == false)
+	{
+		queryOkbutton-&gt;set_sensitive(true);
+	}
+	else
+	{
+		queryOkbutton-&gt;set_sensitive(false);
+	}
+}

Added: trunk/UI/GTK2/src/queryDialog.hh
===================================================================
--- trunk/UI/GTK2/src/queryDialog.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/queryDialog.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,48 @@
+// generated 2003/6/13 20:26:49 BST by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to queryDialog.hh_new
+
+// you might replace
+//    class foo : public foo_glade { ... };
+// by
+//    typedef foo_glade foo;
+// if you didn't make any modifications to the widget
+
+#ifndef _QUERYDIALOG_HH
+#define _QUERYDIALOG_HH
+
+#include &lt;string&gt;
+#include &lt;set&gt;
+#include &lt;gtkmm/liststore.h&gt;
+
+#include &quot;QueryProperties.h&quot;
+#include &quot;ModelColumns.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;queryDialog_glade.hh&quot;
+
+class queryDialog : public queryDialog_glade
+{
+public:
+	queryDialog(QueryProperties &amp;properties);
+	virtual ~queryDialog();
+
+	bool badName(void) const;
+
+protected:
+	std::string m_name;
+	QueryProperties&amp; m_properties;
+	const std::set&lt;PinotSettings::Label&gt; &amp;m_labels;
+	ComboModelColumns m_labelColumns;
+	Glib::RefPtr&lt;Gtk::ListStore&gt; m_refLabelTree;
+	ComboModelColumns m_languageColumns;
+	Glib::RefPtr&lt;Gtk::ListStore&gt; m_refLanguageTree;
+	bool m_badName;
+
+	void populate_comboboxes();
+
+	virtual void on_queryOkbutton_clicked();
+	virtual void on_nameEntry_changed();
+
+};
+#endif

Added: trunk/UI/GTK2/src/queryDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/queryDialog_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/queryDialog_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,325 @@
+// generated 2005/11/26 12:46:55 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/queryDialog.cc
+
+
+#if defined __GNUC__ &amp;&amp; __GNUC__ &lt; 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include &quot;config.h&quot;
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include &lt;libintl.h&gt;
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include &lt;gtkmmconfig.h&gt;
+#if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
+#include &lt;sigc++/compatibility.h&gt;
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include &quot;queryDialog_glade.hh&quot;
+#include &lt;gdk/gdkkeysyms.h&gt;
+#include &lt;gtkmm/accelgroup.h&gt;
+#include &lt;gtkmm/buttonbox.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/table.h&gt;
+#include &lt;gtkmm/adjustment.h&gt;
+#include &lt;gtkmm/box.h&gt;
+
+queryDialog_glade::queryDialog_glade(
+)
+{  queryDialog = this;
+   gmm_data = new GlademmData(get_accel_group());
+   queryCancelbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-cancel&quot;)));
+   queryOkbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID(&quot;gtk-ok&quot;)));
+   
+   Gtk::Label *nameLabel = Gtk::manage(new class Gtk::Label(_(&quot;Name:&quot;)));
+   nameEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Table *table1 = Gtk::manage(new class Gtk::Table(2, 2, false));
+   anyEntry = Gtk::manage(new class Gtk::Entry());
+   hostNameEntry = Gtk::manage(new class Gtk::Entry());
+   fileNameEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Adjustment *resultsCountSpinbutton_adj = Gtk::manage(new class Gtk::Adjustment(10, 10, 100, 10, 20, 20));
+   resultsCountSpinbutton = Gtk::manage(new class Gtk::SpinButton(*resultsCountSpinbutton_adj, 1, 0));
+   indexCheckbutton = Gtk::manage(new class Gtk::CheckButton(_(&quot;Index all results with label&quot;)));
+   
+   Gtk::Label *anyLabel = Gtk::manage(new class Gtk::Label(_(&quot;Any of the words:&quot;)));
+   Gtk::Label *hostLabel = Gtk::manage(new class Gtk::Label(_(&quot;Host name:&quot;)));
+   Gtk::Label *fileNameLabel = Gtk::manage(new class Gtk::Label(_(&quot;File name:&quot;)));
+   Gtk::Label *resultsCountLabel = Gtk::manage(new class Gtk::Label(_(&quot;Number of results:&quot;)));
+   labelCombobox = Gtk::manage(new class Gtk::ComboBox());
+   
+   Gtk::Table *tersmTable = Gtk::manage(new class Gtk::Table(2, 2, false));
+   Gtk::VBox *termsVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   Gtk::Label *propertiesLabel = Gtk::manage(new class Gtk::Label(_(&quot;Properties&quot;)));
+   Gtk::Label *filtersLabel = Gtk::manage(new class Gtk::Label(_(&quot;Limit to documents that match&quot;)));
+   phraseEntry = Gtk::manage(new class Gtk::Entry());
+   notEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Label *phraseLabel = Gtk::manage(new class Gtk::Label(_(&quot;the exact phrase:&quot;)));
+   Gtk::Label *notLabel = Gtk::manage(new class Gtk::Label(_(&quot;none of the words:&quot;)));
+   Gtk::Label *label14 = Gtk::manage(new class Gtk::Label(_(&quot;the language:&quot;)));
+   languageCombobox = Gtk::manage(new class Gtk::ComboBox());
+   andEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Label *andLabel = Gtk::manage(new class Gtk::Label(_(&quot;all the words:&quot;)));
+   Gtk::Table *advancedTable = Gtk::manage(new class Gtk::Table(2, 2, false));
+   Gtk::VBox *advancedVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   Gtk::Label *advancedLabel = Gtk::manage(new class Gtk::Label(_(&quot;Advanced&quot;)));
+   queryNotebook = Gtk::manage(new class Gtk::Notebook());
+   
+   Gtk::VBox *queryVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   queryCancelbutton-&gt;set_flags(Gtk::CAN_FOCUS);
+   queryCancelbutton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   queryCancelbutton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   queryOkbutton-&gt;set_flags(Gtk::CAN_FOCUS);
+   queryOkbutton-&gt;set_flags(Gtk::CAN_DEFAULT);
+   queryOkbutton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   queryDialog-&gt;get_action_area()-&gt;property_layout_style().set_value(Gtk::BUTTONBOX_END);
+   nameLabel-&gt;set_alignment(0.5,0.5);
+   nameLabel-&gt;set_padding(4,4);
+   nameLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   nameLabel-&gt;set_line_wrap(false);
+   nameLabel-&gt;set_use_markup(false);
+   nameLabel-&gt;set_selectable(false);
+   nameEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   nameEntry-&gt;set_visibility(true);
+   nameEntry-&gt;set_editable(true);
+   nameEntry-&gt;set_max_length(0);
+   nameEntry-&gt;set_text(_(&quot;&quot;));
+   nameEntry-&gt;set_has_frame(true);
+   nameEntry-&gt;set_activates_default(false);
+   table1-&gt;set_row_spacings(0);
+   table1-&gt;set_col_spacings(0);
+   table1-&gt;attach(*nameLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
+   table1-&gt;attach(*nameEntry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::AttachOptions(), 4, 4);
+   anyEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   anyEntry-&gt;set_visibility(true);
+   anyEntry-&gt;set_editable(true);
+   anyEntry-&gt;set_max_length(0);
+   anyEntry-&gt;set_text(_(&quot;&quot;));
+   anyEntry-&gt;set_has_frame(true);
+   anyEntry-&gt;set_activates_default(false);
+   hostNameEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   hostNameEntry-&gt;set_visibility(true);
+   hostNameEntry-&gt;set_editable(true);
+   hostNameEntry-&gt;set_max_length(0);
+   hostNameEntry-&gt;set_text(_(&quot;&quot;));
+   hostNameEntry-&gt;set_has_frame(true);
+   hostNameEntry-&gt;set_activates_default(false);
+   fileNameEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   fileNameEntry-&gt;set_visibility(true);
+   fileNameEntry-&gt;set_editable(true);
+   fileNameEntry-&gt;set_max_length(0);
+   fileNameEntry-&gt;set_text(_(&quot;&quot;));
+   fileNameEntry-&gt;set_has_frame(true);
+   fileNameEntry-&gt;set_activates_default(false);
+   resultsCountSpinbutton-&gt;set_flags(Gtk::CAN_FOCUS);
+   resultsCountSpinbutton-&gt;set_update_policy(Gtk::UPDATE_ALWAYS);
+   resultsCountSpinbutton-&gt;set_numeric(false);
+   resultsCountSpinbutton-&gt;set_digits(0);
+   resultsCountSpinbutton-&gt;set_wrap(false);
+   indexCheckbutton-&gt;set_flags(Gtk::CAN_FOCUS);
+   indexCheckbutton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+   indexCheckbutton-&gt;set_mode(true);
+   indexCheckbutton-&gt;set_active(false);
+   anyLabel-&gt;set_alignment(0,0.5);
+   anyLabel-&gt;set_padding(4,4);
+   anyLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   anyLabel-&gt;set_line_wrap(false);
+   anyLabel-&gt;set_use_markup(false);
+   anyLabel-&gt;set_selectable(false);
+   hostLabel-&gt;set_alignment(0,0.5);
+   hostLabel-&gt;set_padding(4,4);
+   hostLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   hostLabel-&gt;set_line_wrap(false);
+   hostLabel-&gt;set_use_markup(false);
+   hostLabel-&gt;set_selectable(false);
+   fileNameLabel-&gt;set_alignment(0,0.5);
+   fileNameLabel-&gt;set_padding(4,4);
+   fileNameLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   fileNameLabel-&gt;set_line_wrap(false);
+   fileNameLabel-&gt;set_use_markup(false);
+   fileNameLabel-&gt;set_selectable(false);
+   resultsCountLabel-&gt;set_alignment(0,0.5);
+   resultsCountLabel-&gt;set_padding(4,4);
+   resultsCountLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   resultsCountLabel-&gt;set_line_wrap(false);
+   resultsCountLabel-&gt;set_use_markup(false);
+   resultsCountLabel-&gt;set_selectable(false);
+   tersmTable-&gt;set_row_spacings(0);
+   tersmTable-&gt;set_col_spacings(0);
+   tersmTable-&gt;attach(*anyEntry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable-&gt;attach(*hostNameEntry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable-&gt;attach(*fileNameEntry, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable-&gt;attach(*resultsCountSpinbutton, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable-&gt;attach(*indexCheckbutton, 0, 1, 4, 5, Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable-&gt;attach(*anyLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   tersmTable-&gt;attach(*hostLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   tersmTable-&gt;attach(*fileNameLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
+   tersmTable-&gt;attach(*resultsCountLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   tersmTable-&gt;attach(*labelCombobox, 1, 2, 4, 5, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   termsVbox-&gt;pack_start(*tersmTable, Gtk::PACK_SHRINK, 4);
+   propertiesLabel-&gt;set_alignment(0.5,0.5);
+   propertiesLabel-&gt;set_padding(0,0);
+   propertiesLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   propertiesLabel-&gt;set_line_wrap(false);
+   propertiesLabel-&gt;set_use_markup(false);
+   propertiesLabel-&gt;set_selectable(false);
+   filtersLabel-&gt;set_alignment(0,0.5);
+   filtersLabel-&gt;set_padding(4,4);
+   filtersLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   filtersLabel-&gt;set_line_wrap(false);
+   filtersLabel-&gt;set_use_markup(false);
+   filtersLabel-&gt;set_selectable(false);
+   phraseEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   phraseEntry-&gt;set_visibility(true);
+   phraseEntry-&gt;set_editable(true);
+   phraseEntry-&gt;set_max_length(0);
+   phraseEntry-&gt;set_text(_(&quot;&quot;));
+   phraseEntry-&gt;set_has_frame(true);
+   phraseEntry-&gt;set_activates_default(false);
+   notEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   notEntry-&gt;set_visibility(true);
+   notEntry-&gt;set_editable(true);
+   notEntry-&gt;set_max_length(0);
+   notEntry-&gt;set_text(_(&quot;&quot;));
+   notEntry-&gt;set_has_frame(true);
+   notEntry-&gt;set_activates_default(false);
+   phraseLabel-&gt;set_alignment(0,0.5);
+   phraseLabel-&gt;set_padding(4,4);
+   phraseLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   phraseLabel-&gt;set_line_wrap(false);
+   phraseLabel-&gt;set_use_markup(false);
+   phraseLabel-&gt;set_selectable(false);
+   notLabel-&gt;set_alignment(0,0.5);
+   notLabel-&gt;set_padding(4,4);
+   notLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   notLabel-&gt;set_line_wrap(false);
+   notLabel-&gt;set_use_markup(false);
+   notLabel-&gt;set_selectable(false);
+   label14-&gt;set_alignment(0,0.5);
+   label14-&gt;set_padding(4,4);
+   label14-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   label14-&gt;set_line_wrap(false);
+   label14-&gt;set_use_markup(false);
+   label14-&gt;set_selectable(false);
+   andEntry-&gt;set_flags(Gtk::CAN_FOCUS);
+   andEntry-&gt;set_visibility(true);
+   andEntry-&gt;set_editable(true);
+   andEntry-&gt;set_max_length(0);
+   andEntry-&gt;set_text(_(&quot;&quot;));
+   andEntry-&gt;set_has_frame(true);
+   andEntry-&gt;set_activates_default(false);
+   andLabel-&gt;set_alignment(0,0.5);
+   andLabel-&gt;set_padding(4,4);
+   andLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   andLabel-&gt;set_line_wrap(false);
+   andLabel-&gt;set_use_markup(false);
+   andLabel-&gt;set_selectable(false);
+   advancedTable-&gt;set_row_spacings(0);
+   advancedTable-&gt;set_col_spacings(0);
+   advancedTable-&gt;attach(*phraseEntry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   advancedTable-&gt;attach(*notEntry, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   advancedTable-&gt;attach(*phraseLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   advancedTable-&gt;attach(*notLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
+   advancedTable-&gt;attach(*label14, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   advancedTable-&gt;attach(*languageCombobox, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   advancedTable-&gt;attach(*andEntry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   advancedTable-&gt;attach(*andLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   advancedVbox-&gt;pack_start(*filtersLabel, Gtk::PACK_SHRINK, 4);
+   advancedVbox-&gt;pack_start(*advancedTable, Gtk::PACK_SHRINK, 0);
+   advancedLabel-&gt;set_alignment(0.5,0.5);
+   advancedLabel-&gt;set_padding(0,0);
+   advancedLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+   advancedLabel-&gt;set_line_wrap(false);
+   advancedLabel-&gt;set_use_markup(false);
+   advancedLabel-&gt;set_selectable(false);
+   queryNotebook-&gt;set_flags(Gtk::CAN_FOCUS);
+   queryNotebook-&gt;set_show_tabs(true);
+   queryNotebook-&gt;set_show_border(true);
+   queryNotebook-&gt;set_tab_pos(Gtk::POS_TOP);
+   queryNotebook-&gt;set_scrollable(false);
+   queryNotebook-&gt;append_page(*termsVbox, *propertiesLabel);
+   queryNotebook-&gt;pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   queryNotebook-&gt;append_page(*advancedVbox, *advancedLabel);
+   queryNotebook-&gt;pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   queryVbox-&gt;pack_start(*table1, Gtk::PACK_SHRINK, 0);
+   queryVbox-&gt;pack_start(*queryNotebook);
+   queryDialog-&gt;get_vbox()-&gt;set_homogeneous(false);
+   queryDialog-&gt;get_vbox()-&gt;set_spacing(0);
+   queryDialog-&gt;get_vbox()-&gt;pack_start(*queryVbox);
+   queryDialog-&gt;set_title(_(&quot;Query properties&quot;));
+   queryDialog-&gt;set_modal(false);
+   queryDialog-&gt;property_window_position().set_value(Gtk::WIN_POS_NONE);
+   queryDialog-&gt;set_resizable(true);
+   queryDialog-&gt;property_destroy_with_parent().set_value(false);
+   queryDialog-&gt;set_has_separator(true);
+   queryDialog-&gt;add_action_widget(*queryCancelbutton, -6);
+   queryDialog-&gt;add_action_widget(*queryOkbutton, -5);
+   queryCancelbutton-&gt;show();
+   queryOkbutton-&gt;show();
+   nameLabel-&gt;show();
+   nameEntry-&gt;show();
+   table1-&gt;show();
+   anyEntry-&gt;show();
+   hostNameEntry-&gt;show();
+   fileNameEntry-&gt;show();
+   resultsCountSpinbutton-&gt;show();
+   indexCheckbutton-&gt;show();
+   anyLabel-&gt;show();
+   hostLabel-&gt;show();
+   fileNameLabel-&gt;show();
+   resultsCountLabel-&gt;show();
+   labelCombobox-&gt;show();
+   tersmTable-&gt;show();
+   termsVbox-&gt;show();
+   propertiesLabel-&gt;show();
+   filtersLabel-&gt;show();
+   phraseEntry-&gt;show();
+   notEntry-&gt;show();
+   phraseLabel-&gt;show();
+   notLabel-&gt;show();
+   label14-&gt;show();
+   languageCombobox-&gt;show();
+   andEntry-&gt;show();
+   andLabel-&gt;show();
+   advancedTable-&gt;show();
+   advancedVbox-&gt;show();
+   advancedLabel-&gt;show();
+   queryNotebook-&gt;show();
+   queryVbox-&gt;show();
+   queryDialog-&gt;show();
+   queryOkbutton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;queryDialog_glade::on_queryOkbutton_clicked), false);
+   nameEntry-&gt;signal_changed().connect(SigC::slot(*this, &amp;queryDialog_glade::on_nameEntry_changed), false);
+}
+
+queryDialog_glade::~queryDialog_glade()
+{  delete gmm_data;
+}

Added: trunk/UI/GTK2/src/queryDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/queryDialog_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/queryDialog_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,71 @@
+// generated 2005/11/26 12:46:55 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/queryDialog.hh and./src/queryDialog.cc
+
+#ifndef _QUERYDIALOG_GLADE_HH
+#  define _QUERYDIALOG_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include &lt;gtkmm/accelgroup.h&gt;
+
+class GlademmData
+{  
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt; accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr&lt;Gtk::AccelGroup&gt; ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr&lt;Gtk::AccelGroup&gt;  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include &lt;gtkmm/dialog.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/entry.h&gt;
+#include &lt;gtkmm/spinbutton.h&gt;
+#include &lt;gtkmm/checkbutton.h&gt;
+#include &lt;gtkmm/combobox.h&gt;
+#include &lt;gtkmm/notebook.h&gt;
+
+class queryDialog_glade : public Gtk::Dialog
+{  
+        
+        GlademmData *gmm_data;
+public:
+        class Gtk::Dialog * queryDialog;
+protected:
+        class Gtk::Button * queryCancelbutton;
+        class Gtk::Button * queryOkbutton;
+        class Gtk::Entry * nameEntry;
+        class Gtk::Entry * anyEntry;
+        class Gtk::Entry * hostNameEntry;
+        class Gtk::Entry * fileNameEntry;
+        class Gtk::SpinButton * resultsCountSpinbutton;
+        class Gtk::CheckButton * indexCheckbutton;
+        class Gtk::ComboBox * labelCombobox;
+        class Gtk::Entry * phraseEntry;
+        class Gtk::Entry * notEntry;
+        class Gtk::ComboBox * languageCombobox;
+        class Gtk::Entry * andEntry;
+        class Gtk::Notebook * queryNotebook;
+        
+        queryDialog_glade();
+        
+        ~queryDialog_glade();
+private:
+        virtual void on_queryOkbutton_clicked() = 0;
+        virtual void on_nameEntry_changed() = 0;
+};
+#endif

Added: trunk/UI/GTK2/xapian-powered.png
===================================================================
(Binary files differ)


Property changes on: trunk/UI/GTK2/xapian-powered.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/UI/RenderHTML/Makefile
===================================================================
--- trunk/UI/RenderHTML/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/RenderHTML/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,21 @@
+
+ROOT_DIR = ../..
+include ${ROOT_DIR}/variables.mk
+
+CXXFLAGS += -DHAVE_CONFIG_H -I. -I.. ${GTKMOZ_CXXFLAGS} 
+
+LIBS += ${GTKMOZ_LIBS}
+
+HTML_SRCS = MozillaRenderer.cpp
+HTML_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${HTML_SRCS})
+
+targets : dirs ${HTML_LIB}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${HTML_LIB}
+
+# Library
+ 
+${HTML_LIB} : ${HTML_OBJS}
+	@echo Building ${HTML_LIB}
+	${AR} cr ${HTML_LIB} ${HTML_OBJS}


Property changes on: trunk/UI/RenderHTML/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/RenderHTML/MozillaRenderer.cpp
===================================================================
--- trunk/UI/RenderHTML/MozillaRenderer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/RenderHTML/MozillaRenderer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,223 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#include &lt;iostream&gt;
+#include &lt;gtkmozembed.h&gt;
+
+#include &quot;MozillaRenderer.h&quot;
+
+MozillaRenderer::MozillaRenderer()
+{
+	gtk_moz_embed_push_startup();
+
+	// Create our web browser component
+	m_htmlWidget = gtk_moz_embed_new();
+	if (m_htmlWidget != NULL)
+	{
+		// Turn off all features
+		gtk_moz_embed_set_chrome_mask(GTK_MOZ_EMBED(m_htmlWidget), 0);
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MozillaRenderer::ctor: embedded Mozilla&quot; &lt;&lt; endl;
+#endif
+	}
+#ifdef DEBUG
+	else cerr &lt;&lt; &quot;MozillaRenderer::ctor: failed to embed Mozilla&quot; &lt;&lt; endl;
+#endif
+	m_rendering = false;
+}
+
+MozillaRenderer::~MozillaRenderer()
+{
+	gtk_moz_embed_pop_startup();
+}
+
+/// Returns the GTK widget.
+GtkWidget *MozillaRenderer::getWidget(void)
+{
+	return m_htmlWidget;
+}
+
+/// Renders HTML held in a buffer.
+bool MozillaRenderer::renderData(const char *data, unsigned int length, const string &amp;baseUrl)
+{
+	if ((m_htmlWidget == NULL) ||
+		(data == NULL) ||
+		(length == 0))
+	{
+		return false;
+	}
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;MozillaRenderer::renderData: data length &quot; &lt;&lt; strlen(data) &lt;&lt; &quot;/&quot; &lt;&lt; length &lt;&lt; &quot; at &quot; &lt;&lt; baseUrl &lt;&lt; endl;
+#endif
+	gtk_moz_embed_open_stream(GTK_MOZ_EMBED(m_htmlWidget), baseUrl.c_str(), &quot;text/html&quot;);
+	// Append data to stream in medium-sized chunks
+	const char *where = data;
+	unsigned int total = length, chunk = 0;
+	while (total &gt; 0)
+	{
+		if (total &gt; 15000)
+		{
+			chunk = 15000;
+		}
+		else
+		{
+			chunk = total;
+		}
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MozillaRenderer::renderData: appending &quot; &lt;&lt; chunk &lt;&lt; &quot; to stream&quot; &lt;&lt; endl;
+#endif
+		gtk_moz_embed_append_data(GTK_MOZ_EMBED(m_htmlWidget), where, chunk);
+
+		where += chunk;
+		total = total - chunk;
+	}
+	gtk_moz_embed_close_stream(GTK_MOZ_EMBED(m_htmlWidget));
+	m_rendering = true;
+
+	return true;
+}
+
+/// Renders the given URL.
+bool MozillaRenderer::renderUrl(const string &amp;url)
+{
+	if (m_htmlWidget != NULL)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MozillaRenderer::renderUrl: url &quot; &lt;&lt; url &lt;&lt; endl;
+#endif
+		gtk_moz_embed_load_url(GTK_MOZ_EMBED(m_htmlWidget), url.c_str());
+		m_rendering = true;
+	}
+
+	return m_rendering;
+}
+
+/// Returns the current location.
+string MozillaRenderer::getLocation(void)
+{
+	if ((m_htmlWidget == NULL) ||
+		(m_rendering == false))
+	{
+		return &quot;&quot;;
+	}
+
+	char *location = gtk_moz_embed_get_location(GTK_MOZ_EMBED(m_htmlWidget));
+	if (location == NULL)
+	{
+		return &quot;&quot;;
+	}
+	string locationStr = location;
+	free(location);
+
+	return locationStr;
+}
+
+/// Returns the currently displayed document's title.
+string MozillaRenderer::getTitle(void)
+{
+	if ((m_htmlWidget == NULL) ||
+		(m_rendering == false))
+	{
+		return &quot;&quot;;
+	}
+
+	char *title = gtk_moz_embed_get_title(GTK_MOZ_EMBED(m_htmlWidget));
+	if (title == NULL)
+	{
+		return &quot;&quot;;
+	}
+	string titleStr = title;
+	free(title);
+
+	return titleStr;
+}
+
+/// Goes forward.
+bool MozillaRenderer::goForward(void)
+{
+	if (canGoForward() == true)
+	{
+		gtk_moz_embed_go_forward(GTK_MOZ_EMBED(m_htmlWidget));
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Goes back.
+bool MozillaRenderer::goBack(void)
+{
+	if (canGoForward() == true)
+	{
+		gtk_moz_embed_go_back(GTK_MOZ_EMBED(m_htmlWidget));
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Reloads the current page.
+bool MozillaRenderer::reload(void)
+{
+	if ((m_htmlWidget == NULL) ||
+		(m_rendering == false))
+	{
+		return false;
+	}
+
+	gtk_moz_embed_reload(GTK_MOZ_EMBED(m_htmlWidget), GTK_MOZ_EMBED_FLAG_RELOADNORMAL);
+
+	return true;	
+}
+
+/// Stops loading.
+bool MozillaRenderer::stop(void)
+{
+	if ((m_htmlWidget == NULL) ||
+		(m_rendering == false))
+	{
+		return false;
+	}
+
+	gtk_moz_embed_stop_load(GTK_MOZ_EMBED(m_htmlWidget));
+
+	return true;	
+}
+
+bool MozillaRenderer::canGoForward(void)
+{
+	if ((m_htmlWidget == NULL) ||
+		(m_rendering == false))
+	{
+		return false;
+	}
+
+	return gtk_moz_embed_can_go_forward(GTK_MOZ_EMBED(m_htmlWidget));
+}
+
+bool MozillaRenderer::canGoBack(void)
+{
+	if ((m_htmlWidget == NULL) ||
+		(m_rendering == false))
+	{
+		return false;
+	}
+
+	return gtk_moz_embed_can_go_back(GTK_MOZ_EMBED(m_htmlWidget));
+}

Added: trunk/UI/RenderHTML/MozillaRenderer.h
===================================================================
--- trunk/UI/RenderHTML/MozillaRenderer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/RenderHTML/MozillaRenderer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,78 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MOZILLARENDERER_H
+#define _MOZILLARENDERER_H
+
+#include &lt;string&gt;
+#include &lt;gtk/gtkwidget.h&gt;
+
+using namespace std;
+
+/**
+  * A class that renders HTML using gtk-mozembed.
+  * See documentation at <A HREF="http://www.mozilla.org/unix/gtk-embedding.html">http://www.mozilla.org/unix/gtk-embedding.html</A>
+  */
+class MozillaRenderer
+{
+	public:
+		MozillaRenderer();
+		virtual ~MozillaRenderer();
+
+		/// Returns the GTK widget.
+		GtkWidget *getWidget(void);
+
+		/// Renders HTML held in a buffer.
+		bool renderData(const char *data, unsigned int length, const string &amp;baseUrl);
+
+		/// Renders the given URL.
+		bool renderUrl(const string &amp;url);
+
+		/// Returns the current location.
+		string getLocation(void);
+
+		/// Returns the currently displayed document's title.
+		string getTitle(void);
+
+		/// Goes forward.
+		bool goForward(void);
+
+		/// Goes back.
+		bool goBack(void);
+
+		/// Reloads the current page.
+		bool reload(void);
+
+		/// Stops loading.
+		bool stop(void);
+
+		/// Returns true if renderer can go forward.
+		bool canGoForward(void);
+
+		/// Returns true if renderer can go back.
+		bool canGoBack(void);
+
+	protected:
+		GtkWidget *m_htmlWidget;
+		bool m_rendering;
+
+	private:
+		MozillaRenderer(const MozillaRenderer &amp;other);
+		MozillaRenderer &amp;operator=(const MozillaRenderer &amp;other);
+
+};
+
+#endif // _MOZILLARENDERER_H

Added: trunk/Utils/Document.cpp
===================================================================
--- trunk/Utils/Document.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Document.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,218 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;sys/mman.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;Document.h&quot;
+
+using std::cout;
+using std::endl;
+using std::string;
+
+Document::Document() :
+	DocumentInfo(),
+	m_pData(NULL),
+	m_dataLength(0),
+	m_isMapped(false)
+{
+}
+
+Document::Document(const string &amp;title, const string &amp;location,
+	const string &amp;type, const string &amp;language) :
+	DocumentInfo(title, location, type, language),
+	m_pData(NULL),
+	m_dataLength(0),
+	m_isMapped(false)
+{
+}
+
+Document::Document(const Document &amp;other) :
+	DocumentInfo(other),
+	m_pData(NULL),
+	m_dataLength(0),
+	m_isMapped(false)
+{
+	setData(other.m_pData, other.m_dataLength);
+}
+
+Document::~Document()
+{
+	freeData();
+}
+
+Document&amp; Document::operator=(const Document&amp; other)
+{
+	DocumentInfo::operator=(other);
+	setData(other.m_pData, other.m_dataLength);
+
+	return *this;
+}
+
+bool Document::operator&lt;(const Document&amp; other) const
+{
+	if (DocumentInfo::operator&lt;(other) == false)
+	{
+		if (m_dataLength &lt; other.m_dataLength)
+		{
+			return true;
+		}
+
+		return false;
+	}
+
+	return true;
+}
+
+void Document::freeData(void)
+{
+	if (m_pData != NULL)
+	{
+		if (m_isMapped == false)
+		{
+			// Free
+			free(m_pData);
+		}
+		else
+		{
+			// Unmap
+			munmap((void*)m_pData, m_dataLength);
+		}
+	}
+
+	m_pData = NULL;
+	m_dataLength = 0;
+	m_isMapped = false;
+}
+
+/// Copies the given data in the document.
+bool Document::setData(const char *data, unsigned int length)
+{
+	if ((data == NULL) ||
+		(length == 0))
+	{
+		return false;
+	}
+
+	// Discard existing data
+	freeData();
+
+	m_pData = (char *)malloc(sizeof(char) * (length + 1));
+	if (m_pData != NULL)
+	{
+		memcpy(m_pData, data, length);
+		m_pData[length] = '\0';
+		m_dataLength = length;
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Maps the given file.
+bool Document::setDataFromFile(const string &amp;fileName)
+{
+	struct stat fileStat;
+
+	if (fileName.empty() == true)
+	{
+		return false;
+	}
+
+	// Make sure the file exists
+	if ((stat(fileName.c_str(), &amp;fileStat) != 0) ||
+		(!S_ISREG(fileStat.st_mode)))
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;Document::setDataFromFile: &quot; &lt;&lt; fileName &lt;&lt; &quot; is not a file&quot; &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	// Open the file in read-only mode
+	int fd = open(fileName.c_str(), O_RDONLY);
+	if (fd == -1)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;Document::setDataFromFile: &quot; &lt;&lt; fileName &lt;&lt; &quot; couldn't be opened&quot; &lt;&lt; endl;
+#endif
+		return false;
+	}
+
+	// Discard existing data
+	freeData();
+
+	// Request a private mapping of the whole file
+	void *mapSpace = mmap(NULL, fileStat.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
+	if (mapSpace != MAP_FAILED)
+	{
+		m_pData = (char*)mapSpace;
+		m_dataLength = fileStat.st_size;
+		m_isMapped = true;
+	}
+#ifdef DEBUG
+	else	cout &lt;&lt; &quot;Document::setDataFromFile: mapping failed&quot; &lt;&lt; endl;
+#endif
+
+	// Close the file
+	if (close(fd) == -1)
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;Document::setDataFromFile: close failed&quot; &lt;&lt; endl;
+#endif
+	}
+
+	return m_isMapped;
+}
+
+/// Returns the document's data; NULL if document is empty.
+const char *Document::getData(unsigned int &amp;length) const
+{
+	length = m_dataLength;
+	return m_pData;
+}
+
+/// Checks whether the document is binary.
+bool Document::isBinary(void) const
+{
+	unsigned int maxLen = 100;
+
+	// Look at the first 100 bytes or so
+	if (m_dataLength &lt; 100)
+	{
+		maxLen = m_dataLength;
+	}
+	for (unsigned int i = 0; i &lt; maxLen; ++i)
+	{
+		if (isascii(m_pData[i]) == 0)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;Document::isBinary: &quot; &lt;&lt; m_pData[i] &lt;&lt; endl;
+#endif
+			return true;
+		}
+	}
+
+	return false;
+}

Added: trunk/Utils/Document.h
===================================================================
--- trunk/Utils/Document.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Document.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,58 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DOCUMENT_H
+#define _DOCUMENT_H
+
+#include &lt;string&gt;
+
+#include &quot;DocumentInfo.h&quot;
+
+class Document : public DocumentInfo
+{
+	public:
+		Document();
+		Document(const std::string &amp;title, const std::string &amp;location,
+			const std::string &amp;type, const std::string &amp;language);
+		Document(const Document &amp;other);
+		virtual ~Document();
+
+		Document&amp; operator=(const Document&amp; other);
+
+		bool operator&lt;(const Document&amp; other) const;
+
+		/// Copies the given data in the document.
+		virtual bool setData(const char *data, unsigned int length);
+
+		/// Maps the given file.
+		virtual bool setDataFromFile(const std::string &amp;fileName);
+
+		/// Returns the document's data; NULL if document is empty.
+		virtual const char *getData(unsigned int &amp;length) const;
+
+		/// Checks whether the document is binary.
+		virtual bool isBinary(void) const;
+
+	protected:
+		char *m_pData;
+		unsigned int m_dataLength;
+		bool m_isMapped;
+
+		void freeData(void);
+
+};
+	
+#endif // _DOCUMENT_H

Added: trunk/Utils/DocumentInfo.cpp
===================================================================
--- trunk/Utils/DocumentInfo.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/DocumentInfo.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,129 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &quot;TimeConverter.h&quot;
+#include &quot;DocumentInfo.h&quot;
+
+using std::string;
+
+DocumentInfo::DocumentInfo()
+{
+	m_timestamp = TimeConverter::toTimestamp(time(NULL));
+}
+
+DocumentInfo::DocumentInfo(const string &amp;title, const string &amp;location,
+	const string &amp;type, const string &amp;language)
+{
+	m_title = title;
+	m_location = location;
+	m_type = type;
+	m_language = language;
+	m_timestamp = TimeConverter::toTimestamp(time(NULL));
+}
+
+DocumentInfo::DocumentInfo(const DocumentInfo &amp;other)
+{
+	m_title = other.m_title;
+	m_location = other.m_location;
+	m_type = other.m_type;
+	m_language = other.m_language;
+	m_timestamp = other.m_timestamp;
+}
+
+DocumentInfo::~DocumentInfo()
+{
+}
+
+DocumentInfo&amp; DocumentInfo::operator=(const DocumentInfo&amp; other)
+{
+	m_title = other.m_title;
+	m_location = other.m_location;
+	m_type = other.m_type;
+	m_language = other.m_language;
+	m_timestamp = other.m_timestamp;
+
+	return *this;
+}
+
+bool DocumentInfo::operator&lt;(const DocumentInfo&amp; other) const
+{
+	if (m_title &lt; other.m_title)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+/// Sets the title of the document.
+void DocumentInfo::setTitle(const string &amp;title)
+{
+	m_title = title;
+}
+
+/// Returns the title of the document.
+string DocumentInfo::getTitle(void) const
+{
+	return m_title;
+}
+
+/// Sets the original location of the document.
+void DocumentInfo::setLocation(const string &amp;location)
+{
+	m_location = location;
+}
+
+/// Returns the original location of the document.
+string DocumentInfo::getLocation(void) const
+{
+	return m_location;
+}
+
+/// Sets the type of the document.
+void DocumentInfo::setType(const string &amp;type)
+{
+	m_type = type;
+}
+
+/// Returns the type of the document.
+string DocumentInfo::getType(void) const
+{
+	return m_type;
+}
+
+/// Sets the language of the document.
+void DocumentInfo::setLanguage(const string &amp;language)
+{
+	m_language = language;
+}
+
+/// Returns the document's language.
+string DocumentInfo::getLanguage(void) const
+{
+	return m_language;
+}
+
+/// Sets the document's timestamp.
+void DocumentInfo::setTimestamp(const string &amp;timestamp)
+{
+	m_timestamp = timestamp;
+}
+
+/// Returns the document's timestamp.
+string DocumentInfo::getTimestamp(void) const
+{
+	return m_timestamp;
+}

Added: trunk/Utils/DocumentInfo.h
===================================================================
--- trunk/Utils/DocumentInfo.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/DocumentInfo.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,74 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DOCUMENT_INFO_H
+#define _DOCUMENT_INFO_H
+
+#include &lt;string&gt;
+
+class DocumentInfo
+{
+	public:
+		DocumentInfo();
+		DocumentInfo(const std::string &amp;title, const std::string &amp;location,
+			const std::string &amp;type, const std::string &amp;language);
+		DocumentInfo(const DocumentInfo &amp;other);
+		virtual ~DocumentInfo();
+
+		DocumentInfo&amp; operator=(const DocumentInfo&amp; other);
+
+		bool operator&lt;(const DocumentInfo&amp; other) const;
+
+		/// Sets the title of the document.
+		virtual void setTitle(const std::string &amp;title);
+
+		/// Returns the title of the document.
+		virtual std::string getTitle(void) const;
+
+		/// Sets the original location of the document.
+		virtual void setLocation(const std::string &amp;location);
+
+		/// Returns the original location of the document.
+		virtual std::string getLocation(void) const;
+
+		/// Sets the type of the document.
+		virtual void setType(const std::string &amp;type);
+
+		/// Returns the type of the document.
+		virtual std::string getType(void) const;
+
+		/// Sets the language of the document.
+		virtual void setLanguage(const std::string &amp;language);
+
+		/// Returns the document's language.
+		virtual std::string getLanguage(void) const;
+
+		/// Sets the document's timestamp.
+		virtual void setTimestamp(const std::string &amp;timestamp);
+
+		/// Returns the document's timestamp.
+		virtual std::string getTimestamp(void) const;
+
+	protected:
+		std::string m_title;
+		std::string m_location;
+		std::string m_type;
+		std::string m_language;
+		std::string m_timestamp;
+
+};
+	
+#endif // _DOCUMENT_INFO_H

Added: trunk/Utils/HtmlDocument.cpp
===================================================================
--- trunk/Utils/HtmlDocument.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/HtmlDocument.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,72 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;ctype.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &quot;HtmlDocument.h&quot;
+
+using std::string;
+
+HtmlDocument::HtmlDocument(const string &amp;title, const string &amp;location,
+	const string &amp;type, const string &amp;language) :
+	Document(title, location, type, language)
+{
+}
+
+HtmlDocument::HtmlDocument(const HtmlDocument &amp;other) :
+	Document(other)
+{
+}
+
+HtmlDocument::~HtmlDocument()
+{
+}
+
+/// Copies the given data in the document.
+bool HtmlDocument::setData(const char *data, unsigned int length)
+{
+	if ((data == NULL) ||
+		(length == 0))
+	{
+		return false;
+	}
+
+	// Discard existing data
+	freeData();
+
+	// FIXME: there must be a way of getting rid of this
+	m_pData = (char *)calloc(length + 1, sizeof(char));
+	if (m_pData != NULL)
+	{
+		// Removing non-printable characters, as found in pages from alltheweb sometimes
+		// They prevent us from using strstr() and mess up the regexps
+		for (unsigned int i = 0; i &lt; length; ++i)
+		{
+			if (isprint(data[i]) == 0)
+			{
+				m_pData[i] = ' ';
+			}
+			else
+			{
+				m_pData[i] = data[i];
+			}
+		}
+		m_dataLength = length;
+	}
+
+	return true;
+}

Added: trunk/Utils/HtmlDocument.h
===================================================================
--- trunk/Utils/HtmlDocument.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/HtmlDocument.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,37 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _HTML_DOCUMENT_H
+#define _HTML_DOCUMENT_H
+
+#include &lt;string&gt;
+
+#include &quot;Document.h&quot;
+
+class HtmlDocument : public Document
+{
+	public:
+		HtmlDocument(const std::string &amp;title, const std::string &amp;location,
+			const std::string &amp;type, const std::string &amp;language);
+		HtmlDocument(const HtmlDocument &amp;other);
+		virtual ~HtmlDocument();
+
+		/// Copies the given data in the document.
+		virtual bool setData(const char *data, unsigned int length);
+
+};
+	
+#endif // _HTML_DOCUMENT_H

Added: trunk/Utils/IndexedDocument.cpp
===================================================================
--- trunk/Utils/IndexedDocument.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/IndexedDocument.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,75 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &quot;Url.h&quot;
+#include &quot;IndexedDocument.h&quot;
+
+using std::string;
+
+IndexedDocument::IndexedDocument(const string &amp;title, const string &amp;location,
+	const string &amp;originalLocation, const string &amp;type, const string &amp;language) :
+	Document(title, location, type, language)
+{
+	m_originalLocation = originalLocation;
+}
+
+IndexedDocument::IndexedDocument(const IndexedDocument &amp;other) :
+	Document(other)
+{
+	m_originalLocation = other.m_originalLocation;
+}
+
+IndexedDocument::~IndexedDocument()
+{
+}
+
+IndexedDocument&amp; IndexedDocument::operator=(const IndexedDocument&amp; other)
+{
+	m_originalLocation = other.m_originalLocation;
+}
+
+/// Returns the document ID.
+unsigned int IndexedDocument::getID(void) const
+{
+	unsigned int docId = 0;
+
+	// Double-check the URL
+	Url urlObj(m_location);
+	if ((urlObj.getProtocol() == &quot;xapian&quot;) ||
+		(urlObj.getFile() != &quot;&quot;))
+	{
+		// The document ID is the final part of the URL, ie the file
+		int val = atoi(urlObj.getFile().c_str());
+		if (val &gt; 0)
+		{
+			docId = (unsigned int)val;
+		}
+	}
+
+	return docId;
+}
+
+/// Sets the original location of the document.
+void IndexedDocument::setOriginalLocation(const string &amp;originalLocation)
+{
+	m_originalLocation = originalLocation;
+}
+
+/// Returns the original location of the document.
+string IndexedDocument::getOriginalLocation(void) const
+{
+	return m_originalLocation;
+}

Added: trunk/Utils/IndexedDocument.h
===================================================================
--- trunk/Utils/IndexedDocument.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/IndexedDocument.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _INDEXED_DOCUMENT_H
+#define _INDEXED_DOCUMENT_H
+
+#include &lt;string&gt;
+
+#include &quot;Document.h&quot;
+
+class IndexedDocument : public Document
+{
+	public:
+		IndexedDocument(const std::string &amp;title, const std::string &amp;location,
+			const std::string &amp;originalLocation, const std::string &amp;type,
+			const std::string &amp;language);
+		IndexedDocument(const IndexedDocument &amp;other);
+		virtual ~IndexedDocument();
+
+		IndexedDocument&amp; operator=(const IndexedDocument&amp; other);
+
+		/// Returns the document ID.
+		virtual unsigned int getID(void) const;
+
+		/// Sets the original location of the document.
+		virtual void setOriginalLocation(const std::string &amp;originalLocation);
+
+		/// Returns the original location of the document.
+		virtual std::string getOriginalLocation(void) const;
+
+	protected:
+		std::string m_originalLocation;
+
+};
+	
+#endif // _INDEXED_DOCUMENT_H

Added: trunk/Utils/Languages.cpp
===================================================================
--- trunk/Utils/Languages.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Languages.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,58 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &quot;Languages.h&quot;
+
+using std::string;
+using std::map;
+using std::pair;
+
+unsigned int Languages::m_count = 12;
+
+char *Languages::m_names[] = {&quot;Danish&quot;, &quot;Dutch&quot;, &quot;English&quot;, &quot;Finnish&quot;, \
+	&quot;French&quot;, &quot;German&quot;, &quot;Italian&quot;, &quot;Norwegian&quot;, &quot;Portuguese&quot;, &quot;Russian&quot;, \
+	&quot;Spanish&quot;, &quot;Swedish&quot; };
+
+char *Languages::m_codes[] = { &quot;da&quot;, &quot;nl&quot;, &quot;en&quot;, &quot;fi&quot;, &quot;fr&quot;, &quot;de&quot;, \
+	&quot;it&quot;, &quot;nn&quot;, &quot;pt&quot;, &quot;ru&quot;, &quot;es&quot;, &quot;sv&quot; };
+
+map&lt;unsigned int, string&gt; Languages::m_intlNames;
+
+Languages::Languages()
+{
+}
+
+Languages::~Languages()
+{
+}
+
+bool Languages::setIntlName(unsigned int num, const string &amp;name)
+{
+		pair&lt;map&lt;unsigned int, string&gt;::iterator, bool&gt; insertPair = m_intlNames.insert(pair&lt;unsigned int, string&gt;(num, name));
+		// Was it inserted ?
+		return insertPair.second;
+}
+
+string Languages::getIntlName(unsigned int num)
+{
+	map&lt;unsigned int, string&gt;::iterator iter = m_intlNames.find(num);
+	if (iter == m_intlNames.end())
+	{
+		return &quot;&quot;;
+	}
+
+	return iter-&gt;second;
+}


Property changes on: trunk/Utils/Languages.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/Languages.h
===================================================================
--- trunk/Utils/Languages.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Languages.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _LANGUAGES_H
+#define _LANGUAGES_H
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+
+class Languages
+{
+	public:
+		virtual ~Languages();
+
+		/// Sets the name for the given code.
+		static bool setIntlName(unsigned int num, const std::string &amp;name);
+
+		/// Gets the name for the given code.
+		static std::string getIntlName(unsigned int num);
+
+		static unsigned int m_count;
+		static char *m_codes[];
+		static char *m_names[];
+
+	protected:
+		static std::map&lt;unsigned int, std::string&gt; m_intlNames;
+
+		Languages();
+
+	private:
+		Languages(const Languages &amp;other);
+		Languages &amp;operator=(const Languages &amp;other);
+
+};
+
+#endif // _LANGUAGES_H


Property changes on: trunk/Utils/Languages.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/MIMEScanner.cpp
===================================================================
--- trunk/Utils/MIMEScanner.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/MIMEScanner.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,120 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;strings.h&gt;
+#include &lt;magic.h&gt;
+
+#include &quot;Url.h&quot;
+#include &quot;MIMEScanner.h&quot;
+
+using std::string;
+
+MIMEScanner::MIMEScanner()
+{
+}
+
+string MIMEScanner::scanFileType(const std::string &amp;fileName)
+{
+	string::size_type fileExtPos = fileName.find_last_of(&quot;.&quot;);
+	if (fileExtPos != string::npos)
+	{
+		string fileExt = fileName.substr(fileExtPos);
+
+		if (strncasecmp(fileExt.c_str(), &quot;.txt&quot;, 4) == 0)
+		{
+			return &quot;text/plain&quot;;
+		}
+		else if (strncasecmp(fileExt.c_str(), &quot;.html&quot;, 5) == 0)
+		{
+			return &quot;text/html&quot;;
+		}
+		else if (strncasecmp(fileExt.c_str(), &quot;.xml&quot;, 4) == 0)
+		{
+			return &quot;text/xml&quot;;
+		}
+		else if (strncasecmp(fileExt.c_str(), &quot;.pdf&quot;, 4) == 0)
+		{
+			return &quot;application/pdf&quot;;
+		}
+		else if (strncasecmp(fileExt.c_str(), &quot;.ps&quot;, 3) == 0)
+		{
+			return &quot;application/postscript&quot;;
+		}
+	}
+
+	// Unknown type
+	return &quot;&quot;;
+}
+
+/// Finds out the given file's MIME type.
+string MIMEScanner::scanFile(const string &amp;fileName)
+{
+	if (fileName.empty() == true)
+	{
+		return &quot;&quot;;
+	}
+
+	// Does it have an obvious extension ?
+	string mimeType = scanFileType(fileName);
+	if (mimeType.empty() == false)
+	{
+		return mimeType;
+	}
+
+	// Open
+	magic_t magicCookie = magic_open(MAGIC_SYMLINK|MAGIC_MIME);
+	if (magicCookie == NULL)
+	{
+		return &quot;&quot;;
+	}
+	if (magic_load(magicCookie, NULL) == -1)
+	{
+		magic_close(magicCookie);
+		return &quot;&quot;;
+	}
+
+	const char *type = magic_file(magicCookie, fileName.c_str());
+	if (type != NULL)
+	{
+		mimeType = type;
+
+		// The MIME string might be of the form &quot;mime_type; charset=...&quot;
+		string::size_type mimeTypeEnd = mimeType.find(&quot;;&quot;);
+		if (mimeTypeEnd != string::npos)
+		{
+			mimeType.resize(mimeTypeEnd);
+		}
+	}
+
+	// Close
+	magic_close(magicCookie);
+
+	return mimeType;
+}
+
+/// Finds out the given URL's MIME type.
+string MIMEScanner::scanUrl(const Url &amp;urlObj)
+{
+	string fileName = urlObj.getFile();
+
+	string mimeType = scanFileType(fileName);
+	if (mimeType.empty() == true)
+	{
+		mimeType = &quot;text/plain&quot;;
+	}
+
+	return mimeType;
+}

Added: trunk/Utils/MIMEScanner.h
===================================================================
--- trunk/Utils/MIMEScanner.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/MIMEScanner.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,44 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MIME_SCANNER_H
+#define _MIME_SCANNER_H
+
+#include &lt;string&gt;
+
+#include &quot;Url.h&quot;
+
+class MIMEScanner
+{
+	public:
+		/// Finds out the given file's MIME type.
+		static std::string scanFile(const std::string &amp;fileName);
+
+		/// Finds out the given URL's MIME type.
+		static std::string scanUrl(const Url &amp;urlObj);
+
+	protected:
+		MIMEScanner();
+
+		static std::string scanFileType(const std::string &amp;fileName);
+
+	private:
+		MIMEScanner(const MIMEScanner &amp;other);
+		MIMEScanner&amp; operator=(const MIMEScanner&amp; other);
+
+};
+
+#endif // _MIME_SCANNER_H

Added: trunk/Utils/Makefile
===================================================================
--- trunk/Utils/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,32 @@
+
+ROOT_DIR = ..
+
+include ${ROOT_DIR}/variables.mk
+
+UTILS_SRCS = DocumentInfo.cpp Document.cpp HtmlDocument.cpp \
+	IndexedDocument.cpp Languages.cpp MIMEScanner.cpp MboxParser.cpp \
+	PluginParser.cpp Result.cpp StringManip.cpp TimeConverter.cpp \
+	Timer.cpp Url.cpp XapianDatabase.cpp XapianDatabaseFactory.cpp
+UTILS_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${UTILS_SRCS})
+
+PLUGIN_TEST = ${BIN_DIR}/plugintest
+
+targets : dirs ${UTILS_LIB} ${TOKENIZER_TEST} ${PLUGIN_TEST} \
+	${PDF_TOKENIZER_DL} ${WORD_TOKENIZER_DL}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${UTILS_LIB} ${TOKENIZER_TEST} \
+	${PLUGIN_TEST} ${PDF_TOKENIZER_DL} ${WORD_TOKENIZER_DL}
+
+# Utils tester
+
+${PLUGIN_TEST} : ${OBJ_DIR}/plugintest.o ${UTILS_LIB}
+	@echo Building ${PLUGIN_TEST}
+	${LINK} -o ${PLUGIN_TEST} ${OBJ_DIR}/plugintest.o ${UTILS_LIB} ${LIBS}
+
+# Library
+
+${UTILS_LIB} : ${UTILS_OBJS}
+	@echo Building ${UTILS_LIB}
+	${AR} cr ${UTILS_LIB} ${UTILS_OBJS}
+


Property changes on: trunk/Utils/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/MboxParser.cpp
===================================================================
--- trunk/Utils/MboxParser.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/MboxParser.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,402 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;string.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;regex.h&gt;
+#include &lt;iostream&gt;
+#include &lt;algorithm&gt;
+
+#include &lt;gmime/gmime.h&gt;
+
+#include &quot;StringManip.h&quot;
+#include &quot;TimeConverter.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;MboxParser.h&quot;
+
+using namespace std;
+
+MboxParser::MboxParser(const string &amp;fileName, off_t mboxOffset)
+{
+	m_fileName = fileName;
+	m_fd = -1;
+	m_pMboxStream = NULL;
+	m_pParser = NULL;
+	m_partsCount = m_partNum = -1;
+	m_messageStart = mboxOffset;
+	m_pCurrentMessage = NULL;
+	m_messageDate = 0;
+
+	if (initialize() == true)
+	{
+		// Extract the first message
+		extractMessage();
+	}
+}
+
+MboxParser::~MboxParser()
+{
+	if (m_pCurrentMessage != NULL)
+	{
+		delete m_pCurrentMessage;
+	}
+
+	finalize();
+}
+
+bool MboxParser::initialize(void)
+{
+	// Open the mbox file
+	m_fd = open(m_fileName.c_str(), O_RDONLY);
+	if (m_fd &lt; 0)
+	{
+		return false;
+	}
+
+	// Initialize gmime
+	g_mime_init(GMIME_INIT_FLAG_UTF8);
+
+	// Create a stream
+	if (m_messageStart &gt; 0)
+	{
+		struct stat fileStat;
+
+		if ((fstat(m_fd, &amp;fileStat) == 0) &amp;&amp;
+			(!S_ISREG(fileStat.st_mode)))
+		{
+			// This is not a file !
+			return false;
+		}
+
+		if (m_messageStart &gt; fileStat.st_size)
+		{
+			// This offset doesn't make sense !
+			m_messageStart = 0;
+		}
+
+		m_pMboxStream = g_mime_stream_fs_new_with_bounds(m_fd, m_messageStart, fileStat.st_size);
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxParser::initialize: stream starts at offset &quot; &lt;&lt; m_messageStart &lt;&lt; endl;
+#endif
+	}
+	else
+	{
+		m_pMboxStream = g_mime_stream_fs_new(m_fd);
+	}
+
+	// And a parser
+	m_pParser = g_mime_parser_new();
+	if ((m_pMboxStream != NULL) &amp;&amp;
+		(m_pParser != NULL))
+	{
+		g_mime_parser_init_with_stream(m_pParser, m_pMboxStream);
+		g_mime_parser_set_respect_content_length(m_pParser, TRUE);
+		// Scan for mbox From-lines
+		g_mime_parser_set_scan_from(m_pParser, TRUE);
+
+		return true;
+	}
+
+	return false;
+}
+
+void MboxParser::finalize(void)
+{
+	if (m_pParser != NULL)
+	{
+		// FIXME: does the parser close the stream ?
+		g_object_unref(G_OBJECT(m_pParser));
+	}
+	else if (m_pMboxStream != NULL)
+	{
+		g_object_unref(G_OBJECT(m_pMboxStream));
+	}
+	if (m_fd &gt;= 0)
+	{
+		close(m_fd);
+	}
+	g_mime_shutdown();
+}
+
+char *MboxParser::extractPart(GMimeObject *part, string &amp;contentType, ssize_t &amp;partLen)
+{
+	char *pBuffer = NULL;
+
+	if (part == NULL)
+	{
+		return NULL;
+	}
+
+	// Message parts may be nested
+	while (GMIME_IS_MESSAGE_PART(part))
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxParser::extractPart: nested message part&quot; &lt;&lt; endl;
+#endif
+		GMimeMessage *partMessage = g_mime_message_part_get_message(GMIME_MESSAGE_PART(part));
+		part = g_mime_message_get_mime_part(partMessage);
+		g_mime_object_unref(GMIME_OBJECT(partMessage));
+	}
+
+	// Is this a multipart ?
+	if (GMIME_IS_MULTIPART(part))
+	{
+		ssize_t allPartsLen = 0;
+
+		m_partsCount = g_mime_multipart_get_number(GMIME_MULTIPART(part));
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxParser::extractPart: message has &quot; &lt;&lt; m_partsCount &lt;&lt; &quot; parts&quot; &lt;&lt; endl;
+#endif
+		for (int partNum = max(m_partNum, 0); partNum &lt; m_partsCount; ++partNum)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;MboxParser::extractPart: extracting part &quot; &lt;&lt; partNum &lt;&lt; endl;
+#endif
+			
+			GMimeObject *multiMimePart = g_mime_multipart_get_part(GMIME_MULTIPART(part), partNum);
+			if (multiMimePart == NULL)
+			{
+				continue;
+			}
+
+			char *pPart = extractPart(multiMimePart, contentType, partLen);
+			g_mime_object_unref(multiMimePart);
+			if (pPart != NULL)
+			{
+				m_partNum = ++partNum;
+				return NULL;
+			}
+		}
+
+		// None of the parts were suitable
+		m_partsCount = m_partNum = -1;
+	}
+
+	if (!GMIME_IS_PART(part))
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxParser::extractPart: not a part&quot; &lt;&lt; endl;
+#endif
+		return NULL;
+	}
+	GMimePart *mimePart = GMIME_PART(part);
+
+	// Check the content type
+	const GMimeContentType *mimeType = g_mime_part_get_content_type(mimePart);
+	if (g_mime_content_type_is_type(mimeType, &quot;text&quot;, &quot;*&quot;) == TRUE)
+	{
+		// Set this for caller
+		char *partType = g_mime_content_type_to_string(mimeType);
+		if (partType != NULL)
+		{
+			contentType = partType;
+			g_free(partType);
+		}
+
+		GMimePartEncodingType encodingType = g_mime_part_get_encoding(mimePart);
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxParser::extractPart: encoding is &quot; &lt;&lt; encodingType &lt;&lt; endl;
+#endif
+
+		// Write the part to memory
+		g_mime_part_set_encoding(mimePart, GMIME_PART_ENCODING_QUOTEDPRINTABLE);
+		GMimeStream *memStream = g_mime_stream_mem_new();
+		GMimeDataWrapper *dataWrapper = g_mime_part_get_content_object(mimePart);
+		if (dataWrapper != NULL)
+		{
+			ssize_t writeLen = g_mime_data_wrapper_write_to_stream(dataWrapper, memStream);
+#ifdef DEBUG
+			cout &lt;&lt; &quot;MboxParser::extractPart: wrote &quot; &lt;&lt; writeLen &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;
+#endif
+			g_object_unref(dataWrapper);
+		}
+		g_mime_stream_flush(memStream);
+		partLen = g_mime_stream_length(memStream);
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxParser::extractPart: part is &quot; &lt;&lt; partLen &lt;&lt; &quot; bytes long&quot; &lt;&lt; endl;
+#endif
+
+		pBuffer = (char*)malloc(partLen + 1);
+		pBuffer[partLen] = '\0';
+		g_mime_stream_reset(memStream);
+		ssize_t readLen = g_mime_stream_read(memStream, pBuffer, partLen);
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxParser::extractPart: read &quot; &lt;&lt; readLen &lt;&lt; &quot; bytes&quot; &lt;&lt; endl;
+#endif
+		g_mime_stream_unref(memStream);
+	}
+#ifdef DEBUG
+	else	cout &lt;&lt; &quot;MboxParser::extractPart: part is not text&quot; &lt;&lt; endl;
+#endif
+
+	return pBuffer;
+}
+
+bool MboxParser::extractMessage(void)
+{
+	string fromLine, contentType;
+
+	while (g_mime_stream_eos(m_pMboxStream) == FALSE)
+	{
+		if (m_partsCount != -1)
+		{
+			// FIXME: the previous message has parts left to parse
+			// The parser doesn't allow to poke at the stream
+			// See g_mime_parser_init_with_stream() here :
+			// <A HREF="http://spruce.sourceforge.net/gmime/doc/gmime-gmime-parser.html">http://spruce.sourceforge.net/gmime/doc/gmime-gmime-parser.html</A>
+#ifdef DEBUG
+			cout &lt;&lt; &quot;MboxParser::extractMessage: skipping parts...&quot; &lt;&lt; endl;
+#endif
+			m_partsCount = m_partNum = -1;
+		}
+		// Get the next message
+		GMimeMessage *mimeMessage = g_mime_parser_construct_message(m_pParser);
+
+		m_messageStart = g_mime_parser_get_from_offset(m_pParser);
+		off_t messageEnd = g_mime_parser_tell(m_pParser);
+
+#ifdef DEBUG
+		cout &lt;&lt; &quot;MboxParser::extractMessage: message between offsets &quot; &lt;&lt; m_messageStart
+			&lt;&lt; &quot; and &quot; &lt;&lt; messageEnd &lt;&lt; endl;
+#endif
+		if (messageEnd &gt; m_messageStart)
+		{
+			char *msgFromLine = g_mime_parser_get_from(m_pParser);
+			if (msgFromLine != NULL)
+			{
+				fromLine = msgFromLine;
+				g_free(msgFromLine);
+			}
+
+			// FIXME: this only applies to Mozilla
+			const char *msgMozStatus = g_mime_message_get_header(mimeMessage, &quot;X-Mozilla-Status&quot;);
+			if (msgMozStatus != NULL)
+			{
+				long int mozStatus = strtol(msgMozStatus, NULL, 16);
+				// Watch out for Mozilla specific flags :
+				// MSG_FLAG_EXPUNGED, MSG_FLAG_EXPIRED
+				// They are defined in mailnews/MailNewsTypes.h and msgbase/nsMsgMessageFlags.h
+				if ((mozStatus &amp; 0x0008) ||
+					(mozStatus &amp; 0x0040))
+				{
+#ifdef DEBUG
+					cout &lt;&lt; &quot;MboxParser::extractMessage: flagged by Mozilla&quot; &lt;&lt; endl;
+#endif
+					g_mime_object_unref(GMIME_OBJECT(mimeMessage));
+					continue;
+				}
+			}
+
+			// How old is this message ?
+			const char *msgDate = g_mime_message_get_header(mimeMessage, &quot;Date&quot;);
+			if (msgDate != NULL)
+			{
+				m_messageDate = TimeConverter::fromTimestamp(msgDate);
+			}
+			else
+			{
+				m_messageDate = 0;
+			}
+#ifdef DEBUG
+			cout &lt;&lt; &quot;MboxParser::extractMessage: message date is &quot; &lt;&lt; m_messageDate &lt;&lt; endl;
+#endif
+
+			// Extract the subject and source address
+			const char *msgSubject = g_mime_message_get_header(mimeMessage, &quot;Subject&quot;);
+			const char *msgFrom = g_mime_message_get_header(mimeMessage, &quot;From&quot;);
+
+			// Get the top-level MIME part in the message
+			GMimeObject *mimePart = g_mime_message_get_mime_part(mimeMessage);
+
+			// Extract the part's text
+			ssize_t partLength = 0;
+			char *pPart = extractPart(mimePart, contentType, partLength);
+			if (pPart != NULL)
+			{
+				string location, subject;
+				char posStr[64];
+
+				// New location
+				// FIXME: use the same scheme as Mozilla
+				location = &quot;<A HREF="mailbox://">mailbox://</A>&quot;;
+				location += m_fileName;
+				location += &quot;?o=&quot;;
+				snprintf(posStr, 64, &quot;%u&quot;, m_messageStart);
+				location += posStr;
+				location += &quot;&amp;p=&quot;;
+				snprintf(posStr, 64, &quot;%d&quot;, max(m_partNum, 0));
+				location += posStr;
+				location += &quot;&amp;h=&quot;;
+				location += StringManip::hashString(fromLine);
+#ifdef DEBUG
+				cout &lt;&lt; &quot;MboxParser::extractMessage: message location is &quot; &lt;&lt; location &lt;&lt; endl;
+#endif
+
+				if (msgSubject != NULL)
+				{
+					subject = msgSubject;
+#ifdef DEBUG
+					cout &lt;&lt; &quot;MboxParser::extractMessage: message subject is &quot; &lt;&lt; subject &lt;&lt; endl;
+#endif
+				}
+#ifdef DEBUG
+				else cout &lt;&lt; &quot;MboxParser::extractMessage: message has no subject&quot; &lt;&lt; endl;
+#endif
+
+				// New message
+				m_pCurrentMessage = new Document(subject, location, contentType, &quot;&quot;);
+				m_pCurrentMessage-&gt;setData(pPart, (unsigned int)partLength);
+
+				free(pPart);
+				g_mime_object_unref(mimePart);
+				g_mime_object_unref(GMIME_OBJECT(mimeMessage));
+
+				return true;
+			}
+
+			g_mime_object_unref(mimePart);
+		}
+
+		g_mime_object_unref(GMIME_OBJECT(mimeMessage));
+	}
+
+	return false;
+}
+
+/// Gets the current message's date.
+time_t MboxParser::getDate(void) const
+{
+	return m_messageDate;
+}
+
+/// Jumps to the next message.
+bool MboxParser::nextMessage(void)
+{
+	delete m_pCurrentMessage;
+	m_pCurrentMessage = NULL;
+	// Get the next message from the original document
+	return extractMessage();
+}
+
+/// Returns a pointer to the current message's document.
+const Document *MboxParser::getDocument(void)
+{
+	// FIXME: this object can be invalidated by nextMessage() at any time;
+	// use auto_ptr all the way ?
+	return m_pCurrentMessage;
+}


Property changes on: trunk/Utils/MboxParser.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/MboxParser.h
===================================================================
--- trunk/Utils/MboxParser.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/MboxParser.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,81 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MBOX_PARSER_H
+#define _MBOX_PARSER_H
+
+#include &lt;time.h&gt;
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;utility&gt;
+#include &lt;set&gt;
+
+#include &lt;gmime/gmime-object.h&gt;
+#include &lt;gmime/gmime-stream.h&gt;
+#include &lt;gmime/gmime-parser.h&gt;
+
+#include &quot;Document.h&quot;
+
+using namespace std;
+
+/**
+  * A parser for mbox files. Each message is extracted and
+  * returned in a separate document by getDocument(). The value
+  * returned by getDocumentIncrement() enables to determine a new
+  * message has been extracted and is ready to be tokenized.
+  * See <A HREF="http://en.wikipedia.org/wiki/Mbox">http://en.wikipedia.org/wiki/Mbox</A> for details about the format.
+  */
+class MboxParser
+{
+	public:
+		MboxParser(const string &amp;fileName, off_t mboxOffset = 0);
+		virtual ~MboxParser();
+
+		/// Gets the current message's date.
+		time_t getDate(void) const;
+
+		/// Jumps to the next message.
+		bool nextMessage(void);
+
+		/// Returns a pointer to the current message's document.
+		virtual const Document *getDocument(void);
+
+	protected:
+		string m_fileName;
+		int m_fd;
+		GMimeStream *m_pMboxStream;
+		GMimeParser *m_pParser;
+		int m_partsCount;
+		int m_partNum;
+		off_t m_messageStart;
+		Document *m_pCurrentMessage;
+		time_t m_messageDate;
+
+		bool initialize(void);
+
+		void finalize(void);
+
+		bool extractMessage(void);
+
+		char *extractPart(GMimeObject *mimeObject, string &amp;contentType, ssize_t &amp;partLen);
+
+	private:
+		MboxParser(const MboxParser &amp;other);
+		MboxParser&amp; operator=(const MboxParser&amp; other);
+
+};
+
+#endif // _MBOX_PARSER_H


Property changes on: trunk/Utils/MboxParser.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/NLS.h
===================================================================
--- trunk/Utils/NLS.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/NLS.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,42 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _NLS_H
+#define _NLS_H
+
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include &lt;libintl.h&gt;
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+
+#endif // _NLS_H

Added: trunk/Utils/PluginParser.cpp
===================================================================
--- trunk/Utils/PluginParser.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/PluginParser.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,272 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;iostream&gt;
+#include &lt;boost/spirit/core.hpp&gt;
+#include &lt;boost/spirit/actor/push_back_actor.hpp&gt;
+#include &lt;boost/spirit/actor/insert_at_actor.hpp&gt;
+#include &lt;boost/spirit/utility/confix.hpp&gt;
+
+#include &quot;PluginParser.h&quot;
+
+using namespace std;
+using namespace boost::spirit;
+
+struct skip_grammar : public grammar&lt;skip_grammar&gt;
+{
+	template &lt;typename ScannerT&gt;
+	struct definition
+	{
+		definition(skip_grammar const &amp;self)
+		{
+			// Skip all spaces and comments, starting with a #
+			// FIXME: make sure comments start at the beginning of the line !
+			skip = space_p | (ch_p('#') &gt;&gt; *(anychar_p - ch_p('\n')) &gt;&gt; ch_p('\n'));
+		}
+	
+		rule&lt;ScannerT&gt; skip;
+	
+		rule&lt;ScannerT&gt; const&amp; start() const
+		{
+			return skip;
+		}
+	};
+};
+
+/**
+  * A minimal grammar for Sherlock plugins.
+  * This only checks for the existence of the SEARCH tag.
+  * It is used to quickly extract SEARCH attributes.
+  */
+struct plugin_min_grammar : public grammar&lt;plugin_min_grammar&gt;
+{
+	 plugin_min_grammar(PluginProperties &amp;properties)
+        : m_properties(properties)
+	{
+	}
+
+	template &lt;typename ScannerT&gt;
+	struct definition
+	{
+		definition(plugin_min_grammar const &amp;self)
+		{
+			// Start
+			search_plugin = search_header &gt;&gt; rest;
+
+			// All items have a name and an optionally-quoted value, separated by =
+			end_of_name = ch_p('=');
+			any_name = *(~ch_p('&gt;') - end_of_name);
+			any_value_without_quotes = lexeme_d[*(~ch_p('&gt;') - ch_p('\n'))];
+			any_value = ch_p('\'') &gt;&gt; (*(~ch_p('\'')))[assign_a(unquotedValue)] &gt;&gt; ch_p('\'') |
+				ch_p('&quot;') &gt;&gt; (*(~ch_p('&quot;')))[assign_a(unquotedValue)] &gt;&gt; ch_p('&quot;') |
+				any_value_without_quotes[assign_a(unquotedValue)];
+
+			// SEARCH attributes are items
+			// There should be only one SEARCH tag
+			search_item = (any_name[assign_a(itemName)]
+				&gt;&gt; ch_p('=') &gt;&gt; any_value[assign_a(itemValue, unquotedValue)])
+				[insert_at_a(self.m_properties.m_searchParams, itemName, itemValue)];
+
+			// SEARCH may have any number of attributes
+			search_header = ch_p('&lt;') &gt;&gt; as_lower_d[str_p(&quot;search&quot;)] &gt;&gt; *search_item &gt;&gt; ch_p('&gt;');
+
+			// Rest
+			rest = *anychar_p;
+		}
+
+		string unquotedValue, itemName, itemValue;		
+		rule&lt;ScannerT&gt; search_plugin, search_header, rest;
+		rule&lt;ScannerT&gt; end_of_name, any_name, any_value_without_quotes, any_value, search_item;
+
+		rule&lt;ScannerT&gt; const&amp; start() const
+		{
+			return search_plugin;
+		}
+	};
+
+	PluginProperties &amp;m_properties;
+
+};
+
+/**
+  * A complete but lax grammar for Sherlock plugins.
+  * For instance, it doesn't mind if INPUT has a NAME but no VALUE.
+  * More importantly, it doesn't enforce types, eg FACTOR should be an integer.
+  */
+struct plugin_grammar : public grammar&lt;plugin_grammar&gt;
+{
+	 plugin_grammar(PluginProperties &amp;properties)
+        : m_properties(properties)
+	{
+	}
+
+	template &lt;typename ScannerT&gt;
+	struct definition
+	{
+		definition(plugin_grammar const &amp;self)
+		{
+			// Start
+			search_plugin = search_header &gt;&gt; input_elements &gt;&gt; search_footer;
+
+			// All items have a name and an optionally-quoted value, separated by =
+			end_of_name = ch_p('=');
+			any_name = *(~ch_p('&gt;') - end_of_name);
+			any_value_without_quotes = lexeme_d[*(~ch_p('&gt;') - ch_p('\n'))];
+			any_value = ch_p('\'') &gt;&gt; (*(~ch_p('\'')))[assign_a(unquotedValue)] &gt;&gt; ch_p('\'') |
+				ch_p('&quot;') &gt;&gt; (*(~ch_p('&quot;')))[assign_a(unquotedValue)] &gt;&gt; ch_p('&quot;') |
+				any_value_without_quotes[assign_a(unquotedValue)];
+
+			// SEARCH attributes are items
+			// There should be only one SEARCH tag
+			search_item = (any_name[assign_a(itemName)]
+				&gt;&gt; ch_p('=') &gt;&gt; any_value[assign_a(itemValue, unquotedValue)])
+				[insert_at_a(self.m_properties.m_searchParams, itemName, itemValue)];
+
+			// SEARCH may have any number of attributes
+			search_header = ch_p('&lt;') &gt;&gt; as_lower_d[str_p(&quot;search&quot;)] &gt;&gt; *search_item &gt;&gt; ch_p('&gt;');
+
+			// INPUT
+			input_item_name = as_lower_d[str_p(&quot;name&quot;)] &gt;&gt; ch_p('=')
+				&gt;&gt; any_value[assign_a(itemName, unquotedValue)];
+			input_item_value = as_lower_d[str_p(&quot;value&quot;)] &gt;&gt; ch_p('=')
+				&gt;&gt; any_value[assign_a(itemValue, unquotedValue)];
+			input_item_user = as_lower_d[str_p(&quot;user&quot;)];
+			input_item_factor = as_lower_d[str_p(&quot;factor&quot;)]
+				&gt;&gt; ch_p('=') &gt;&gt; any_value[assign_a(itemValue, unquotedValue)];
+
+			// INPUT tags have name and value items; one is marked with USER
+			input_item = input_item_name |
+				input_item_value |
+				input_item_user[assign_a(self.m_properties.m_userInput, itemName)];
+
+			input_element = (ch_p('&lt;') &gt;&gt; as_lower_d[str_p(&quot;input&quot;)] &gt;&gt; *input_item &gt;&gt; ch_p('&gt;'))
+				[insert_at_a(self.m_properties.m_inputItems, itemName, itemValue)];
+
+			// INPUTPREV tags have name and either factor or value items
+			// There should be only one INPUTPREV tag
+			// FIXME: save those
+			inputprev_item = input_item_name |
+				input_item_factor |
+				input_item_value;
+
+			inputprev_element = ch_p('&lt;') &gt;&gt; as_lower_d[str_p(&quot;inputprev&quot;)] &gt;&gt; *inputprev_item &gt;&gt; ch_p('&gt;');
+
+			// INPUTNEXT tags have name and either factor or value items
+			// There should be only one INPUTNEXT tag
+			inputnext_item = input_item_name[assign_a(self.m_properties.m_nextInput, itemName)] |
+				input_item_factor[assign_a(self.m_properties.m_nextFactor, itemValue)] |
+				input_item_value[assign_a(self.m_properties.m_nextValue, itemValue)];
+
+			inputnext_element = ch_p('&lt;') &gt;&gt; as_lower_d[str_p(&quot;inputnext&quot;)] &gt;&gt; *inputnext_item &gt;&gt; ch_p('&gt;');
+
+			// INTERPRET tags have varied types of items
+			// There should be only one INTERPRET tag
+			interpret_item = (any_name[assign_a(itemName)]
+				&gt;&gt; ch_p('=') &gt;&gt; any_value[assign_a(itemValue, unquotedValue)])
+				[insert_at_a(self.m_properties.m_interpretParams, itemName, itemValue)];
+
+			interpret_element = ch_p('&lt;') &gt;&gt; as_lower_d[str_p(&quot;interpret&quot;)] &gt;&gt; *interpret_item &gt;&gt; ch_p('&gt;');
+
+			// INPUT, INPUTNEXT and INTERPRET may appear in any order
+			input_elements = *(input_element |
+				inputprev_element |
+				inputnext_element |
+				interpret_element);
+
+			// SEARCH has a closing tag
+			search_footer =  ch_p('&lt;') &gt;&gt; ch_p('/') &gt;&gt; as_lower_d[str_p(&quot;search&quot;)] &gt;&gt; ch_p('&gt;');
+		}
+
+		string unquotedValue, itemName, itemValue;		
+		rule&lt;ScannerT&gt; search_plugin, search_header, search_footer;
+		rule&lt;ScannerT&gt; end_of_name, any_name, any_value_without_quotes, any_value, search_item;
+		rule&lt;ScannerT&gt; input_elements, input_element, inputprev_element, inputnext_element, interpret_element;
+		rule&lt;ScannerT&gt; input_item_name, input_item_value, input_item_user, input_item_factor;
+		rule&lt;ScannerT&gt; input_item, inputprev_item, inputnext_item, interpret_item;
+
+		rule&lt;ScannerT&gt; const&amp; start() const
+		{
+			return search_plugin;
+		}
+	};
+
+	PluginProperties &amp;m_properties;
+
+};
+
+PluginParser::PluginParser(const Document *pDocument)
+{
+	m_pDocument = pDocument;
+}
+
+PluginParser::~PluginParser()
+{
+}
+
+bool PluginParser::parse(bool extractSearchParams)
+{
+	if (m_pDocument == NULL)
+	{
+		return false;
+	}
+
+	unsigned int dataLength;
+	const char *pData = m_pDocument-&gt;getData(dataLength);
+	if ((pData == NULL) ||
+		(dataLength == 0))
+	{
+		return false;
+	}
+
+	skip_grammar skip;
+	parse_info&lt;&gt; parseInfo;
+
+	if (extractSearchParams == false)
+	{
+		plugin_grammar plugin(m_properties);
+
+		parseInfo = boost::spirit::parse(pData, plugin, skip);
+	}
+	else
+	{
+		plugin_min_grammar plugin(m_properties);
+
+		parseInfo = boost::spirit::parse(pData, plugin, skip);
+	}
+#ifdef DEBUG
+	if (parseInfo.full == false)
+	{
+		cout &lt;&lt; &quot;PluginParser::parse: syntax error near &quot; &lt;&lt; parseInfo.stop &lt;&lt; endl;
+	}
+#endif
+
+	return parseInfo.hit;
+}
+
+/// Returns the plugin's properties.
+PluginProperties &amp;PluginParser::getProperties(void)
+{
+	return m_properties;
+}
+
+/// Returns a pointer to the plugin file's document.
+const Document *PluginParser::getDocument(void)
+{
+	return m_pDocument;
+}

Added: trunk/Utils/PluginParser.h
===================================================================
--- trunk/Utils/PluginParser.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/PluginParser.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,78 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _PLUGIN_PARSER_H
+#define _PLUGIN_PARSER_H
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+
+#include &quot;Document.h&quot;
+
+using namespace std;
+
+class PluginProperties
+{
+	public:
+		PluginProperties()
+		{
+		}
+		virtual ~PluginProperties()
+		{
+		}
+
+
+		map&lt;string, string&gt; m_searchParams;
+		map&lt;string, string&gt; m_inputItems;
+		string m_userInput;
+		string m_nextInput;
+		string m_nextFactor;
+		string m_nextValue;
+		map&lt;string, string&gt; m_interpretParams;
+
+	private:
+		PluginProperties(const PluginProperties &amp;other);
+		PluginProperties&amp; operator=(const PluginProperties&amp; other);
+
+};
+
+/// A parser for Sherlock plugin files.
+class PluginParser
+{
+	public:
+		PluginParser(const Document *pDocument);
+		virtual ~PluginParser();
+
+		/// Parses the plugin; false if not all could be parsed.
+		bool parse(bool extractSearchParams = false);
+
+		/// Returns the plugin's properties.
+		virtual PluginProperties &amp;getProperties(void);
+
+		/// Returns a pointer to the plugin file's document.
+		virtual const Document *getDocument(void);
+
+	protected:
+		const Document *m_pDocument;
+		PluginProperties m_properties;
+
+	private:
+		PluginParser(const PluginParser &amp;other);
+		PluginParser&amp; operator=(const PluginParser&amp; other);
+
+};
+
+#endif // _PLUGIN_PARSER_H

Added: trunk/Utils/Result.cpp
===================================================================
--- trunk/Utils/Result.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Result.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,74 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &quot;Result.h&quot;
+
+using std::string;
+
+Result::Result(const string &amp;location, const string &amp;title, const string &amp;extract,
+	const string &amp;language, float percentageScore) :
+	DocumentInfo(title, location, &quot;&quot;, language),
+	m_extract(extract),
+	m_score(percentageScore)
+{
+}
+
+Result::Result(const Result &amp;other) :
+	DocumentInfo(other),
+	m_extract(other.m_extract),
+	m_score(other.m_score)
+{
+}
+
+Result::~Result()
+{
+}
+
+Result &amp;Result::operator=(const Result &amp;other)
+{
+	DocumentInfo::operator=(other);
+	m_extract = other.m_extract;
+	m_score = other.m_score;
+
+	return *this;
+}
+
+bool Result::operator&lt;(const Result&amp; other) const
+{
+	if (DocumentInfo::operator&lt;(other) == false)
+	{
+		if (m_score &lt; other.m_score)
+		{
+			return true;
+		}
+
+		return false;
+	}
+
+	return true;
+}
+
+/// Returns the result extract.
+string Result::getExtract(void) const
+{
+	return m_extract;
+}
+
+/// Returns the result score.
+float Result::getScore(void) const
+{
+	return m_score;
+}


Property changes on: trunk/Utils/Result.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/Result.h
===================================================================
--- trunk/Utils/Result.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Result.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _RESULT_H
+#define _RESULT_H
+
+#include &lt;string&gt;
+
+#include &quot;DocumentInfo.h&quot;
+
+class Result : public DocumentInfo
+{
+	public:
+		Result(const std::string &amp;location, const std::string &amp;title,
+			const std::string &amp;extract, const std::string &amp;language,
+			float percentageScore = 0.0);
+		Result(const Result &amp;other);
+		virtual ~Result();
+
+		Result &amp;operator=(const Result &amp;other);
+
+		bool operator&lt;(const Result&amp; other) const;
+
+		/// Returns the result extract.
+		std::string getExtract(void) const;
+
+		/// Returns the result score.
+		float getScore(void) const;
+
+	protected:
+		std::string m_extract;
+		float m_score;
+
+};
+
+#endif // _RESULT_H


Property changes on: trunk/Utils/Result.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/StringManip.cpp
===================================================================
--- trunk/Utils/StringManip.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/StringManip.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,146 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#define _XOPEN_SOURCE
+#include &lt;unistd.h&gt;
+#undef _XOPEN_SOURCE
+#include &lt;ctype.h&gt;
+#include &lt;algorithm&gt;
+
+#include &quot;StringManip.h&quot;
+
+using std::string;
+using std::for_each;
+
+#define CRYPT_SALT &quot;$1$ajfpehom$&quot;
+
+// A function object to lower case strings with for_each()
+struct ToLower
+{
+	public:
+		void operator()(char &amp;c)
+		{
+			c = (char)tolower((int)c);
+		}
+};
+
+StringManip::StringManip()
+{
+}
+
+/// Converts to lowercase.
+string StringManip::toLowerCase(const string &amp;str)
+{
+	string tmp = str;
+
+	for_each(tmp.begin(), tmp.end(), ToLower());
+
+	return tmp;
+}
+
+/// Extracts the sub-string between start and end.
+string StringManip::extractField(const string &amp;str, const string &amp;start, const string &amp;end)
+{
+	string::size_type endPos = 0;
+
+	return extractField(str, start, end, endPos);
+}
+
+/// Extracts the sub-string between start and end.
+string StringManip::extractField(const string &amp;str, const string &amp;start, const string &amp;end, string::size_type &amp;endPos)
+{
+	string fieldValue;
+
+	string::size_type startPos = str.find(start, endPos);
+	if (startPos != string::npos)
+	{
+		startPos += start.length();
+		endPos = str.find(end, startPos);
+		if (endPos != string::npos)
+		{
+			fieldValue = str.substr(startPos, endPos - startPos);
+		}
+	}
+
+	return fieldValue;
+}
+
+/// Replaces a sub-string.
+string StringManip::replaceSubString(const string &amp;str, const std::string &amp;substr, const std::string &amp;rep)
+{
+	string cleanStr = str;
+
+	string::size_type startPos = cleanStr.find(substr);
+	while (startPos != string::npos)
+	{
+		string::size_type endPos = startPos + substr.length();
+
+		string tmp = cleanStr.substr(0, startPos);
+		tmp += rep;
+		tmp += cleanStr.substr(endPos);
+		cleanStr = tmp;
+
+		startPos += rep.length();
+		if (startPos &gt; cleanStr.length())
+		{
+			break;
+		}
+
+		startPos = cleanStr.find(substr, startPos);
+	}
+
+	return cleanStr;
+}
+
+/// Removes characters from a string.
+unsigned int StringManip::removeCharacters(string &amp;str, const string &amp;characters)
+{
+	unsigned int count = 0;
+
+	string::size_type charPos = str.find_first_of(characters.c_str());
+	while (charPos != string::npos)
+	{
+		str.erase(charPos, 1);
+		charPos = str.find_first_of(characters.c_str(), charPos - 1);
+	}
+
+	return count;	
+}
+
+/// Hashes a string.
+string StringManip::hashString(string &amp;str)
+{
+	if (str.empty() == true)
+	{
+		return &quot;&quot;;
+	}
+
+	char *hashedString = crypt(str.c_str(), CRYPT_SALT);
+	if (hashedString == NULL)
+	{
+		return NULL;
+	}
+
+	if (strlen(hashedString) &gt; strlen(CRYPT_SALT))
+	{
+		if (strncmp(hashedString, CRYPT_SALT, strlen(CRYPT_SALT)) == 0)
+		{
+			return hashedString + strlen(CRYPT_SALT);
+		}
+	}
+
+	return hashedString;
+}

Added: trunk/Utils/StringManip.h
===================================================================
--- trunk/Utils/StringManip.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/StringManip.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,55 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _STRING_MANIP_H
+#define _STRING_MANIP_H
+
+#include &lt;string&gt;
+
+class StringManip
+{
+	public:
+		/// Converts to lowercase.
+		static std::string toLowerCase(const std::string &amp;str);
+
+		/// Extracts the sub-string between start and end.
+		static std::string extractField(const std::string &amp;str, const std::string &amp;start,
+			const std::string &amp;end);
+
+		/// Extracts the sub-string between start and end.
+		static std::string extractField(const std::string &amp;str, const std::string &amp;start,
+			const std::string &amp;end, std::string::size_type &amp;endPos);
+
+		/// Replaces a sub-string.
+		static std::string replaceSubString(const std::string &amp;str, const std::string &amp;substr,
+			const std::string &amp;rep);
+
+		/// Removes characters from a string.
+		static unsigned int removeCharacters(std::string &amp;str, const std::string &amp;characters);
+
+		/// Hashes a string.
+		static std::string hashString(std::string &amp;str);
+
+	protected:
+		StringManip();
+
+	private:
+		StringManip(const StringManip &amp;other);
+		StringManip&amp; operator=(const StringManip&amp; other);
+
+};
+
+#endif // _STRING_MANIP_H

Added: trunk/Utils/TimeConverter.cpp
===================================================================
--- trunk/Utils/TimeConverter.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/TimeConverter.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,157 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#define _XOPEN_SOURCE	// glibc2 needs this
+#include &lt;time.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;TimeConverter.h&quot;
+
+using std::cout;
+using std::endl;
+
+TimeConverter::TimeConverter()
+{
+}
+
+/// Converts into an RFC 822 timestamp.
+string TimeConverter::toTimestamp(time_t aTime, bool inGMTime)
+{
+	struct tm timeTm;
+
+	if (((inGMTime == true) &amp;&amp;
+		(gmtime_r(&amp;aTime, &amp;timeTm) != NULL)) ||
+		(localtime_r(&amp;aTime, &amp;timeTm) != NULL))
+	{
+		char timeStr[64];
+
+		if (strftime(timeStr, 64, &quot;%a, %d %b %Y %H:%M:%S %Z&quot;, &amp;timeTm) &gt; 0)
+		{
+			return timeStr;
+		}
+	}
+
+	return &quot;&quot;;
+}
+
+/// Converts from a RFC 822 timestamp.
+time_t TimeConverter::fromTimestamp(const string &amp;timestamp, bool inGMTime)
+{
+	struct tm timeTm;
+	string formatString;
+#ifndef _STRPTIME_COPES_WITH_TIMEZONE
+	bool fixTimezone = false;
+#endif
+
+	if (timestamp.empty() == true)
+	{
+		return 0;
+	}
+
+	// Find out if the date has an RFC-822/ISO 8601 time zone specification
+	// or a time zone name
+	// FIXME: it looks like strptime() can't diffentiate between %Z and %z
+	// and that the value extracted with %z is ignored
+	char *remainder = strptime(timestamp.c_str(), &quot;%a, %d %b %Y %H:%M:%S &quot;, &amp;timeTm);
+	if (remainder != NULL)
+	{
+		if ((remainder[0] == '+') ||
+			(remainder[0] == '-'))
+		{
+#ifdef _STRPTIME_COPES_WITH_TIMEZONE
+			formatString = &quot;%a, %d %b %Y %H:%M:%S %z&quot;;
+#else
+			formatString = &quot;%a, %d %b %Y %H:%M:%S &quot;;
+			fixTimezone = true;
+#endif
+		}
+		else
+		{
+			formatString = &quot;%a, %d %b %Y %H:%M:%S %Z&quot;;
+		}
+	}
+	else
+	{
+		remainder = strptime(timestamp.c_str(), &quot;%Y %b %d %H:%M:%S &quot;, &amp;timeTm);
+		if (remainder == NULL)
+		{
+			// How is it formatted then ?
+			return 0;
+		}
+
+		if ((remainder[0] == '+') ||
+			(remainder[0] == '-'))
+		{
+#ifdef _STRPTIME_COPES_WITH_TIMEZONE
+			formatString = &quot;%Y %b %d %H:%M:%S %z&quot;;
+#else
+			formatString = &quot;%Y %b %d %H:%M:%S &quot;;
+			fixTimezone = true;
+#endif
+		}
+		else
+		{
+			formatString = &quot;%Y %b %d %H:%M:%S %Z&quot;;
+		}
+	}
+
+	if ((formatString.empty() == false) &amp;&amp;
+		(strptime(timestamp.c_str(), formatString.c_str(), &amp;timeTm) != NULL))
+	{
+		time_t gmTime = 0;
+
+		if (inGMTime == true)
+		{
+			gmTime = timegm(&amp;timeTm);
+		}
+		else
+		{
+			gmTime = timelocal(&amp;timeTm);
+		}
+
+#ifndef _STRPTIME_COPES_WITH_TIMEZONE
+		if ((fixTimezone == true) &amp;&amp;
+			(remainder != NULL))
+		{
+			unsigned int tzDiff = 0;
+
+			if ((sscanf(remainder + 1, &quot;%u&quot;, &amp;tzDiff) != 0) &amp;&amp;
+				(tzDiff &lt; 1200))
+			{
+				unsigned int hourDiff = tzDiff / 100;
+				unsigned int minDiff = tzDiff % 100;
+
+#ifdef DEBUG
+				cout &lt;&lt; &quot;TimeConverter::fromTimestamp: diff is &quot; &lt;&lt; remainder[0] &lt;&lt; hourDiff &lt;&lt; &quot;:&quot; &lt;&lt; minDiff &lt;&lt; endl;
+#endif
+				if (remainder[0] == '+')
+				{
+					// Ahead of GMT
+					gmTime -= (hourDiff * 3600) + (minDiff * 60);
+				}
+				else
+				{
+					// Behind GMT
+					gmTime += (hourDiff * 3600) + (minDiff * 60);
+				}
+			}
+		}
+#endif
+		return gmTime;
+	}
+
+	return 0;
+}

Added: trunk/Utils/TimeConverter.h
===================================================================
--- trunk/Utils/TimeConverter.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/TimeConverter.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,42 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TIME_CONVERTER_H
+#define _TIME_CONVERTER_H
+
+#include &lt;string&gt;
+
+using namespace std;
+
+class TimeConverter
+{
+	public:
+		/// Converts into an RFC 822 timestamp.
+		static string toTimestamp(time_t aTime, bool inGMTime = false);
+
+		/// Converts from a RFC 822 timestamp.
+		static time_t fromTimestamp(const string &amp;timestamp, bool inGMTime = false);
+	
+	protected:
+		TimeConverter();
+
+	private:
+		TimeConverter(const TimeConverter &amp;other);
+		TimeConverter&amp; operator=(const TimeConverter&amp; other);
+
+};
+
+#endif // _TIME_CONVERTER_H

Added: trunk/Utils/Timer.cpp
===================================================================
--- trunk/Utils/Timer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Timer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,59 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &quot;Timer.h&quot;
+
+Timer::Timer()
+{
+	gettimeofday(&amp;m_start, NULL);
+	gettimeofday(&amp;m_stop, NULL);
+}
+
+Timer::Timer(const Timer &amp;other) :
+	m_start(other.m_start),
+	m_stop(other.m_stop)
+{
+}
+
+
+Timer &amp;Timer::operator=(const Timer &amp;other)
+{
+	m_start = other.m_start;
+	m_stop = other.m_stop;
+
+	return *this;
+}
+
+Timer::~Timer()
+{
+}
+
+/// Starts the timer.
+void Timer::start(void)
+{
+	gettimeofday(&amp;m_start, NULL);
+}
+
+/// Stops the timer and returns the number of microseconds elapsed.
+long Timer::stop(void)
+{
+	gettimeofday(&amp;m_stop, NULL);
+
+	long timeDiff = (m_stop.tv_sec - m_start.tv_sec) * 1000000
+		+ (m_stop.tv_usec - m_start.tv_usec);
+
+	return timeDiff;
+}


Property changes on: trunk/Utils/Timer.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/Timer.h
===================================================================
--- trunk/Utils/Timer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Timer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,44 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TIMER_H
+#define _TIMER_H
+
+#include &lt;time.h&gt;
+#include &lt;sys/time.h&gt;
+
+class Timer
+{
+	public:
+		Timer();
+		Timer(const Timer &amp;other);
+		virtual ~Timer();
+
+		Timer &amp;operator=(const Timer &amp;other);
+
+		/// Starts the timer.
+		void start(void);
+
+		/// Stops the timer and returns the number of microseconds elapsed.
+		long stop(void);
+
+	protected:
+		struct timeval m_start;
+		struct timeval m_stop;
+
+};
+
+#endif // _TIMER_H


Property changes on: trunk/Utils/Timer.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/Url.cpp
===================================================================
--- trunk/Utils/Url.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Url.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,330 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;neon/ne_uri.h&gt;
+
+#include &quot;Url.h&quot;
+
+Url::Url(const string &amp;url)
+{
+	parse(url);
+}
+
+Url::~Url()
+{
+}
+
+Url::Url(const Url &amp;other) :
+	m_protocol(other.m_protocol),
+	m_user(other.m_user),
+	m_password(other.m_password),
+	m_host(other.m_host),
+	m_location(other.m_location),
+	m_file(other.m_file),
+	m_parameters(other.m_parameters)
+{
+}
+
+Url&amp; Url::operator=(const Url&amp; other)
+{
+	m_protocol = other.m_protocol;
+	m_user = other.m_user;
+	m_password = other.m_password;
+	m_host = other.m_host;
+	m_location = other.m_location;
+	m_file = other.m_file;
+	m_parameters = other.m_parameters;
+
+	return *this;
+}
+
+void Url::parse(const string &amp;url)
+{
+	string::size_type pos1 =0, pos2 = 0;
+	bool hasHostName = true;
+
+	// If the URL starts with a slash, don't parse and consider it local
+	if (url[0] == '/')
+	{
+		m_location = url;
+		return;
+	}
+
+	// Protocol
+	pos1 = url.find(&quot;://&quot;);
+	if (pos1 != string::npos)
+	{
+		m_protocol = url.substr(0, pos1);
+		pos1 += 3;
+
+		if ((m_protocol == &quot;file&quot;) ||
+			(m_protocol == &quot;mailbox&quot;))
+		{
+			hasHostName = false;
+		}
+	}
+	else
+	{
+		// Assume default protocol
+		m_protocol = &quot;http&quot;;
+		pos1 = 0;
+	}
+
+	if (hasHostName == true)
+	{
+		// User and password
+		pos2 = url.find_first_of(&quot;:&quot;, pos1);
+		if (pos2 != string::npos)
+		{
+			bool isPartOfLocation = false;
+
+			string::size_type firstSlash = url.find_first_of(&quot;/&quot;, pos1);
+			if (firstSlash != string::npos)
+			{
+				// The : is part of the location if it follows the /, eg like in this URL :
+				// <A HREF="http://216.239.39.100/search?q=cache:X8L8R9AazsAJ:eastenwest.free.fr/site/php/download.php%3Ftype%3Darticles%26ID%3D193+fabrice+colin&amp;hl=en&amp;ie=UTF-8">http://216.239.39.100/search?q=cache:X8L8R9AazsAJ:eastenwest.free.fr/site/php/download.php%3Ftype%3Darticles%26ID%3D193+fabrice+colin&amp;hl=en&amp;ie=UTF-8</A>
+				if (pos2 &gt; firstSlash)
+				{
+					isPartOfLocation = true;
+				}
+			}
+
+			if (isPartOfLocation == false)
+			{
+				m_user = url.substr(pos1, pos2 - pos1);
+				pos1 = pos2 + 1;
+
+				pos2 = url.find_first_of(&quot;@&quot;, pos1);
+				if (pos2 != string::npos)
+				{
+					m_password = url.substr(pos1, pos2 - pos1);
+					pos1 = pos2 + 1;
+				}
+			}
+		}
+
+		// Host name
+		pos2 = url.find_first_of(&quot;/&quot;, pos1);
+		if (pos2 != string::npos)
+		{
+			m_host = url.substr(pos1, pos2 - pos1);
+			pos2++;
+		}
+		else
+		{
+			m_host = url.substr(pos1);
+			return;
+		}
+		// FIXME: what about the port number ?
+	}
+	else
+	{
+		m_host = &quot;localhost&quot;;
+		pos2 = pos1;
+	}
+
+	string locationAndFile = url.substr(pos2);
+	pos2 = locationAndFile.find(&quot;?&quot;);
+	// Parameters
+	if (pos2 != string::npos)
+	{
+		m_parameters = locationAndFile.substr(pos2+1);
+		locationAndFile.resize(pos2);
+	}
+
+	// Location and file
+	pos1 = locationAndFile.find_last_of(&quot;/&quot;);
+	if (pos1 != string::npos)
+	{
+		m_location = locationAndFile.substr(0, pos1);
+		m_file = locationAndFile.substr(pos1+1);
+	}
+	else
+	{
+		// No slash found, what we have got is either a directory
+		// directly under the root or a file name
+		// Assume this is a directory unless there's a dot
+		if (locationAndFile.find('.') == string::npos)
+		{
+			m_location = locationAndFile;
+			m_file = &quot;&quot;;
+		}
+		else
+		{
+			m_location = &quot;&quot;;
+			m_file = locationAndFile;
+		}
+	}
+}
+
+string Url::getProtocol(void) const
+{
+	return m_protocol;
+}
+
+string Url::getUser(void) const
+{
+	return m_user;
+}
+
+string Url::getPassword(void) const
+{
+	return m_password;
+}
+
+string Url::getHost(void) const
+{
+	return m_host;
+}
+
+string Url::getLocation(void) const
+{
+	return m_location;
+}
+
+string Url::getFile(void) const
+{
+	return m_file;
+}
+
+string Url::getParameters(void) const
+{
+	return m_parameters;
+}
+
+/// Canonicalizes an URL.
+string Url::canonicalizeUrl(const string &amp;url)
+{
+	if (url.empty() == true)
+	{
+		return &quot;&quot;;
+	}
+
+	Url urlObj(url);
+	string location = urlObj.getLocation();
+	string file = urlObj.getFile();
+
+	// Get rid of the last directory's slash
+	if ((file.empty() == true) &amp;&amp;
+		(location.empty() == false) &amp;&amp;
+		(url[url.length() - 1] == '/'))
+	{
+		return url.substr(0, url.length() - 1);
+	}
+
+	return url;
+}
+
+/// Truncates an URL to the given length by discarding characters in the middle.
+string Url::prettifyUrl(const string &amp;url, unsigned int maxLen)
+{
+	if (maxLen &gt;= url.length())
+	{
+		// Don't change anything...
+		return url;
+	}
+
+	unsigned int diffLen = url.length() - maxLen;
+	Url urlObj(url);
+	string protocol = urlObj.getProtocol();
+	string user = urlObj.getUser();
+	string password = urlObj.getPassword();
+	string host = urlObj.getHost();
+	string location = urlObj.getLocation();
+	string file = urlObj.getFile();
+	
+	string prettyUrl = protocol;
+	prettyUrl += &quot;://&quot;;
+	if (user.empty() == false)
+	{
+		prettyUrl += user;
+		prettyUrl += &quot;:&quot;;
+		prettyUrl += password;
+	}
+	prettyUrl += host;
+	prettyUrl += &quot;/&quot;;
+
+	if (url.length() &lt;= diffLen)
+	{
+		// That's the bare minimum...
+		prettyUrl = protocol;
+		prettyUrl += &quot;://&quot;;
+		prettyUrl += host;
+		prettyUrl += &quot;/...&quot;;
+	}
+	else if (location.length() &gt; diffLen + 3)
+	{
+		// Truncate the location and keep the rest intact
+		prettyUrl += location.substr(0, location.length() - (diffLen + 3));
+		prettyUrl += &quot;.../&quot;;
+		prettyUrl += file;
+	}
+	else
+	{
+		// Cut somewhere in the middle of the URL then
+		prettyUrl += location;
+		prettyUrl += &quot;/&quot;;
+		prettyUrl += file;
+		unsigned int urlLen = prettyUrl.length();
+		string::size_type startPos = 0;
+		if (urlLen - diffLen &gt; 0)
+		{
+			startPos = (urlLen - diffLen) / 2;
+		}
+		string tmp = prettyUrl;
+		prettyUrl = tmp.substr(0, startPos);
+		prettyUrl += &quot;...&quot;;
+		prettyUrl += tmp.substr(startPos + diffLen);
+	}
+
+	return prettyUrl;
+}
+
+/// Escapes an URL.
+string Url::escapeUrl(const string &amp;url)
+{
+	string escapedUrlStr = &quot;&quot;;
+
+	if (url.empty() == false)
+	{
+		char *escapedUrl = ne_path_escape(url.c_str());
+		if (escapedUrl != NULL)
+		{
+			escapedUrlStr = escapedUrl;
+			free(escapedUrl);
+		}
+	}
+
+	return escapedUrlStr;
+}
+
+/// Unescapes an URL.
+string Url::unescapeUrl(const string &amp;escapedUrl)
+{
+	string unescapedUrlStr = &quot;&quot;;
+
+	if (escapedUrl.empty() == false)
+	{
+		char *unescapedUrl = ne_path_unescape(escapedUrl.c_str());
+		if (unescapedUrl != NULL)
+		{
+			unescapedUrlStr = unescapedUrl;
+			free(unescapedUrl);
+		}
+	}
+
+	return unescapedUrlStr;
+}

Added: trunk/Utils/Url.h
===================================================================
--- trunk/Utils/Url.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Url.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,66 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _URL_H
+#define _URL_H
+
+#include &lt;string&gt;
+
+using std::string;
+
+class Url
+{
+	public:
+		Url(const string &amp;url);
+		Url(const Url &amp;other);
+		virtual ~Url();
+
+		Url&amp; operator=(const Url&amp; other);
+
+		string getProtocol(void) const;
+		string getUser(void) const;
+		string getPassword(void) const;
+		string getHost(void) const;
+		string getLocation(void) const;
+		string getFile(void) const;
+		string getParameters(void) const;
+
+		/// Canonicalizes an URL.
+		static string canonicalizeUrl(const string &amp;url);
+
+		/// Truncates an URL to the given length by discarding characters in the middle.
+		static string prettifyUrl(const string &amp;url, unsigned int maxLen);
+
+		/// Escapes an URL.
+		static string escapeUrl(const string &amp;url);
+
+		/// Unescapes an URL.
+		static string unescapeUrl(const string &amp;escapedUrl);
+
+	protected:
+		string m_protocol;
+		string m_user;
+		string m_password;
+		string m_host;
+		string m_location;
+		string m_file;
+		string m_parameters;
+
+		void parse(const string &amp;url);
+
+};
+
+#endif // _URL_H

Added: trunk/Utils/XapianDatabase.cpp
===================================================================
--- trunk/Utils/XapianDatabase.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/XapianDatabase.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,192 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;iostream&gt;
+
+#include &quot;XapianDatabase.h&quot;
+
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+
+XapianDatabase::XapianDatabase(const string &amp;databaseName, bool readOnly) :
+	m_databaseName(databaseName),
+	m_readOnly(readOnly),
+	m_pDatabase(NULL),
+	m_isOpen(false)
+{
+	pthread_rwlock_init(&amp;m_rwLock, NULL);
+	m_isOpen = openDatabase();
+}
+
+XapianDatabase::~XapianDatabase()
+{
+	if (m_pDatabase != NULL)
+	{
+		delete m_pDatabase;
+	}
+	pthread_rwlock_destroy(&amp;m_rwLock);
+}
+
+bool XapianDatabase::openDatabase(void)
+{
+	struct stat dbStat;
+
+	if (m_databaseName.empty() == true)
+	{
+		return false;
+	}
+
+	// Is it a remote database ?
+	string::size_type colonPos = m_databaseName.find(&quot;:&quot;);
+	if ((m_databaseName[0] != '/') &amp;&amp;
+		(colonPos != string::npos))
+	{
+		string hostName = m_databaseName.substr(0, colonPos);
+		unsigned int port = (unsigned int)atoi(m_databaseName.substr(colonPos + 1).c_str());
+
+		if (m_readOnly == false)
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;XapianDatabase::openDatabase: remote databases are read-only&quot; &lt;&lt; endl;
+#endif
+			return false;
+		}
+
+		try
+		{
+#ifdef DEBUG
+			cout &lt;&lt; &quot;XapianDatabase::openDatabase: remote database at &quot;
+				&lt;&lt; hostName &lt;&lt; &quot;:&quot; &lt;&lt; port &lt;&lt; endl;
+#endif
+			Xapian::Database remoteDatabase = Xapian::Remote::open(hostName, port);
+			m_pDatabase = new Xapian::Database(remoteDatabase);
+
+			return true;
+		}
+		catch (const Xapian::Error &amp;error)
+		{
+			cerr &lt;&lt; &quot;XapianDatabase::openDatabase: couldn't open remote database: &quot;
+				&lt;&lt; error.get_msg() &lt;&lt; endl;
+		}
+
+		return false;		
+	}
+
+	// It's a local database : the specified path must be a directory
+	if (stat(m_databaseName.c_str(), &amp;dbStat) == -1)
+	{
+		if (m_readOnly == true)
+		{
+			cerr &lt;&lt; &quot;XapianDatabase::openDatabase: database &quot; &lt;&lt; m_databaseName
+				&lt;&lt; &quot; doesn't exist&quot; &lt;&lt; endl;
+			return false;
+		}
+
+		// Database directory doesn't exist, create it (mode 755)
+		if (mkdir(m_databaseName.c_str(), (mode_t)S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) != 0)
+		{
+			cerr &lt;&lt; &quot;XapianDatabase::openDatabase: couldn't create database directory &quot;
+				&lt;&lt; m_databaseName &lt;&lt; endl;
+			return false;
+		}
+	}
+	else if (!S_ISDIR(dbStat.st_mode))
+	{
+		cerr &lt;&lt; &quot;XapianDatabase::openDatabase: &quot; &lt;&lt; m_databaseName
+			&lt;&lt; &quot; is not a directory&quot; &lt;&lt; endl;
+		return false;
+	}
+
+	// Try opening it now, creating if if necessary
+	try
+	{
+		if (m_readOnly == true)
+		{
+			m_pDatabase = new Xapian::Database(m_databaseName);
+		}
+		else
+		{
+			m_pDatabase = new Xapian::WritableDatabase(m_databaseName, Xapian::DB_CREATE_OR_OPEN);
+		}
+
+		return true;
+	}
+	catch (const Xapian::Error &amp;error)
+	{
+		cerr &lt;&lt; &quot;XapianDatabase::openDatabase: couldn't open database: &quot;
+			&lt;&lt; error.get_msg() &lt;&lt; endl;
+	}
+
+	return false;
+}
+
+/// Returns false if the database couldn't be opened.
+bool XapianDatabase::isOpen(void) const
+{
+	return m_isOpen;
+}
+
+/// Attempts to lock and retrieve the database.
+Xapian::Database *XapianDatabase::readLock(void)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;XapianDatabase::readLock: &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
+#endif
+	if (pthread_rwlock_rdlock(&amp;m_rwLock) == 0)
+	{
+		return m_pDatabase;
+	}
+
+	return NULL;
+}
+
+/// Attempts to lock and retrieve the database.
+Xapian::WritableDatabase *XapianDatabase::writeLock(void)
+{
+	if (m_readOnly == true)
+	{
+		// FIXME: close and reopen in write mode
+		cerr &lt;&lt; &quot;Couldn't open read-only database &quot; &lt;&lt; m_databaseName
+			&lt;&lt; &quot; for writing&quot; &lt;&lt; endl;
+		return NULL;
+	}
+
+#ifdef DEBUG
+	cout &lt;&lt; &quot;XapianDatabase::writeLock: &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
+#endif
+	if (pthread_rwlock_wrlock(&amp;m_rwLock) == 0)
+	{
+		return dynamic_cast&lt;Xapian::WritableDatabase *&gt;(m_pDatabase);
+	}
+
+	return NULL;
+}
+
+/// Unlocks the database.
+void XapianDatabase::unlock(void)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;XapianDatabase::unlock: &quot; &lt;&lt; m_databaseName &lt;&lt; endl;
+#endif
+	pthread_rwlock_unlock(&amp;m_rwLock);
+}


Property changes on: trunk/Utils/XapianDatabase.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/XapianDatabase.h
===================================================================
--- trunk/Utils/XapianDatabase.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/XapianDatabase.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,62 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XAPIAN_DATABASE_H
+#define _XAPIAN_DATABASE_H
+
+#include &lt;string&gt;
+#include &lt;set&gt;
+#include &lt;pthread.h&gt;
+
+#include &lt;xapian.h&gt;
+
+#include &quot;DocumentInfo.h&quot;
+#include &quot;IndexHistory.h&quot;
+#include &quot;IndexInterface.h&quot;
+
+class XapianDatabase
+{
+	public:
+		XapianDatabase(const std::string &amp;databaseName, bool readOnly = true);
+		XapianDatabase(const XapianDatabase &amp;other);
+		virtual ~XapianDatabase();
+
+		XapianDatabase &amp;operator=(const XapianDatabase &amp;other);
+
+		/// Returns false if the database couldn't be opened.
+		bool isOpen(void) const;
+
+		/// Attempts to lock and retrieve the database.
+		Xapian::Database *readLock(void);
+
+		/// Attempts to lock and retrieve the database.
+		Xapian::WritableDatabase *writeLock(void);
+
+		/// Unlocks the database.
+		void unlock(void);
+
+	protected:
+		std::string m_databaseName;
+		bool m_readOnly;
+		pthread_rwlock_t m_rwLock;
+		Xapian::Database *m_pDatabase;
+		bool m_isOpen;
+
+		bool openDatabase(void);
+
+};
+
+#endif // _XAPIAN_DATABASE_H


Property changes on: trunk/Utils/XapianDatabase.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/XapianDatabaseFactory.cpp
===================================================================
--- trunk/Utils/XapianDatabaseFactory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/XapianDatabaseFactory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,117 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+
+#include &quot;XapianDatabaseFactory.h&quot;
+
+using std::cout;
+using std::endl;
+using std::string;
+using std::map;
+using std::pair;
+
+pthread_mutex_t XapianDatabaseFactory::m_mutex = PTHREAD_MUTEX_INITIALIZER;
+map&lt;string, XapianDatabase *&gt; XapianDatabaseFactory::m_databases;
+
+XapianDatabaseFactory::XapianDatabaseFactory()
+{
+}
+
+XapianDatabaseFactory::~XapianDatabaseFactory()
+{
+}
+
+/// Returns a XapianDatabase pointer; NULL if unavailable.
+XapianDatabase *XapianDatabaseFactory::getDatabase(const string &amp;location, bool readOnly)
+{
+	XapianDatabase *pDb = NULL;
+
+	if (location.empty() == true)
+	{
+		return NULL;
+	}
+
+	// Lock the map
+	if (pthread_mutex_lock(&amp;m_mutex) != 0)
+	{
+		return NULL;
+	}
+
+	map&lt;string, XapianDatabase *&gt;::iterator dbIter = m_databases.find(location);
+	if (dbIter != m_databases.end())
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;XapianDatabaseFactory::getDatabase: found &quot; &lt;&lt; location &lt;&lt; endl;
+#endif
+		pDb = dbIter-&gt;second;
+	}
+	else
+	{
+#ifdef DEBUG
+		cout &lt;&lt; &quot;XapianDatabaseFactory::getDatabase: opening &quot; &lt;&lt; location
+			&lt;&lt; &quot; in mode &quot; &lt;&lt; readOnly &lt;&lt; endl;
+#endif
+		// Create a new instance
+		pDb = new XapianDatabase(location, readOnly);
+		// Insert it into the map
+		pair&lt;map&lt;string, XapianDatabase *&gt;::iterator, bool&gt; insertPair = m_databases.insert(pair&lt;string, XapianDatabase *&gt;(location, pDb));
+		// Was it inserted ?
+		if (insertPair.second == false)
+		{
+			// No, it wasn't : delete the object
+			delete pDb;
+			pDb = NULL;
+		}
+	}
+
+	// Unlock the map
+	pthread_mutex_unlock(&amp;m_mutex);
+
+	return pDb;
+}
+
+/// Closes all databases.
+void XapianDatabaseFactory::closeAll(void)
+{
+	if (m_databases.empty() == true)
+	{
+		return;
+	}
+
+	// Lock the map
+	if (pthread_mutex_lock(&amp;m_mutex) != 0)
+	{
+		return;
+	}
+
+	std::map&lt;std::string, XapianDatabase *&gt;::iterator dbIter = m_databases.begin();
+	while (dbIter != m_databases.end())
+	{
+		XapianDatabase *pDb = dbIter-&gt;second;
+		dbIter-&gt;second = NULL;
+#ifdef DEBUG
+		cout &lt;&lt; &quot;XapianDatabaseFactory::closeAll: closing &quot; &lt;&lt; dbIter-&gt;first &lt;&lt; endl;
+#endif
+		m_databases.erase(dbIter);
+		delete pDb;
+
+		dbIter = m_databases.begin();
+	}
+
+	// Unlock the map
+	pthread_mutex_unlock(&amp;m_mutex);
+}


Property changes on: trunk/Utils/XapianDatabaseFactory.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/XapianDatabaseFactory.h
===================================================================
--- trunk/Utils/XapianDatabaseFactory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/XapianDatabaseFactory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XAPIAN_DATABASE_FACTORY_H
+#define _XAPIAN_DATABASE_FACTORY_H
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;pthread.h&gt;
+
+#include &quot;XapianDatabase.h&quot;
+
+class XapianDatabaseFactory
+{
+	public:
+		virtual ~XapianDatabaseFactory();
+
+		/// Returns a XapianDatabase pointer; NULL if unavailable.
+		static XapianDatabase *getDatabase(const std::string &amp;location, bool readOnly = true);
+
+		/// Closes all databases.
+		static void closeAll(void);
+
+	protected:
+		static pthread_mutex_t m_mutex;
+		static std::map&lt;std::string, XapianDatabase *&gt; m_databases;
+
+		XapianDatabaseFactory();
+
+	private:
+		XapianDatabaseFactory(const XapianDatabaseFactory &amp;other);
+		XapianDatabaseFactory &amp;operator=(const XapianDatabaseFactory &amp;other);
+
+};
+
+#endif // _XAPIAN_DATABASE_FACTORY_H


Property changes on: trunk/Utils/XapianDatabaseFactory.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/plugintest.cpp
===================================================================
--- trunk/Utils/plugintest.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/plugintest.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,111 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;strings.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+#include &lt;string&gt;
+
+#include &quot;PluginParser.h&quot;
+
+using namespace std;
+
+int main(int argc, char **argv)
+{
+	if (argc &lt; 2)
+	{
+		cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;file name&gt; [MIN]&quot; &lt;&lt; endl;
+		return EXIT_FAILURE;
+	}
+
+	struct stat fileStat;
+	if ((stat(argv[1], &amp;fileStat) == 0) &amp;&amp;
+		(S_ISREG(fileStat.st_mode)))
+	{
+		char *buffer = new char[fileStat.st_size + 1];
+		int fd = open(argv[1], O_RDONLY);
+		// Read the file
+		ssize_t readBytes = read(fd, buffer, fileStat.st_size);
+		if (readBytes == -1)
+		{
+			cerr &lt;&lt; &quot;Couldn't read &quot; &lt;&lt; argv[1] &lt;&lt; &quot; !&quot; &lt;&lt; endl;
+			return EXIT_FAILURE;
+		}
+
+		// Put that data into a document
+		Document doc;
+		doc.setData(buffer, readBytes);
+		delete[] buffer;
+
+		bool minParser = false;
+		PluginParser parser(&amp;doc);
+
+		if ((argc &gt;= 3) &amp;&amp;
+			(strncasecmp(argv[2], &quot;MIN&quot;, 3) == 0))
+		{
+			minParser = true;
+		}
+
+		if (parser.parse(minParser) == true)
+		{
+			cout &lt;&lt; &quot;Successfully parsed &quot; &lt;&lt; argv[1] &lt;&lt; endl;
+		}
+
+		PluginProperties &amp;properties = parser.getProperties();
+
+		cout &lt;&lt; &quot;SEARCH parameters are :&quot; &lt;&lt; endl;
+		for (map&lt;string, string&gt;::iterator iter = properties.m_searchParams.begin();
+			iter != properties.m_searchParams.end(); ++iter)
+		{
+			cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;=&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;
+		}
+		cout &lt;&lt; &quot;End of SEARCH parameters&quot; &lt;&lt; endl;
+
+		cout &lt;&lt; &quot;INPUT items are :&quot; &lt;&lt; endl;
+		for (map&lt;string, string&gt;::iterator iter = properties.m_inputItems.begin();
+			iter != properties.m_inputItems.end(); ++iter)
+		{
+			if (iter-&gt;first != properties.m_userInput)
+			{
+				cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;=&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;
+			}
+			else
+			{
+				cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; USER&quot; &lt;&lt; endl;
+			}
+		}
+		cout &lt;&lt; &quot;NEXT &quot; &lt;&lt; properties.m_nextInput &lt;&lt; &quot;=&quot; &lt;&lt; properties.m_nextFactor &lt;&lt; endl;
+		cout &lt;&lt; &quot;End of INPUT items&quot; &lt;&lt; endl;
+
+		cout &lt;&lt; &quot;INTERPRET parameters are :&quot; &lt;&lt; endl;
+		for (map&lt;string, string&gt;::iterator iter = properties.m_interpretParams.begin();
+			iter != properties.m_interpretParams.end(); ++iter)
+		{
+			cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;=&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;
+		}
+		cout &lt;&lt; &quot;End of INTERPRET parameters&quot; &lt;&lt; endl;
+
+	}
+	else
+	{
+		cerr &lt;&lt; &quot;Couldn't stat &quot; &lt;&lt; argv[1] &lt;&lt; &quot; !&quot; &lt;&lt; endl;
+	}
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/Utils/plugintest.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/index.html
===================================================================
--- trunk/index.html	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/index.html	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,34 @@
+&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2//EN&quot;&gt;
+&lt;HTML&gt;
+&lt;html&gt;
+&lt;head&gt;&lt;title&gt;Welcome to Pinot !&lt;/title&gt;
+&lt;/head&gt;
+&lt;body bgcolor=&quot;#ffffff&quot; text=&quot;#000000&quot; link=&quot;#c80000&quot; vlink=&quot;#900000&quot; alink=&quot;#ea5b1a&quot;&gt;
+
+&lt;table width=&quot;100%&quot;&gt;
+&lt;tr&gt;
+&lt;td colspan=&quot;3&quot; align=&quot;center&quot;&gt;
+&lt;strong&gt;Welcome to Pinot !&lt;/strong&gt;
+&lt;/td&gt;
+&lt;/tr&gt;
+
+&lt;tr&gt;
+&lt;td colspan=&quot;3&quot; align=&quot;center&quot;&gt;
+The official Pinot &lt;a href=&quot;<A HREF="http://pinot.berlios.de/">http://pinot.berlios.de/</A>&quot;&gt;web site&lt;/a&gt;.
+&lt;/td&gt;
+&lt;/tr&gt;
+
+&lt;tr&gt;
+&lt;td colspan=&quot;3&quot; align=&quot;center&quot;&gt;
+Pinot is powered by &lt;a href=&quot;<A HREF="http://www.xapian.org/">http://www.xapian.org/</A>&quot;&gt;Xapian&lt;/a&gt;.&lt;br&gt;
+&lt;/td&gt;
+&lt;/tr&gt;
+
+&lt;tr&gt;
+&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;
+&lt;img src=&quot;xapian-powered.png&quot; alt=&quot;Powered By Xapian Logo&quot; width=&quot;208&quot; height=&quot;30&quot;&gt;
+&lt;/td&gt;
+&lt;/tr&gt;
+
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/libxmlpp026.patch
===================================================================
--- trunk/libxmlpp026.patch	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/libxmlpp026.patch	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,13 @@
+--- pinot-0.20/variables.mk_bak    2005-07-17 19:55:39.549604896 +0800
++++ pinot-0.20/variables.mk        2005-07-17 20:01:56.493300744 +0800
+@@ -72,8 +72,8 @@
+ SQLITE_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags sqlite3)
+ SQLITE_LIBS = $(shell /usr/bin/pkg-config --libs sqlite3)
+ # LibXML 2.0
+-LIBXML_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags libxml++-2.6)
+-LIBXML_LIBS = $(shell /usr/bin/pkg-config --libs libxml++-2.6)
++LIBXML_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags libxml++-1.0) -DHAS_LIBXMLPP026
++LIBXML_LIBS = $(shell /usr/bin/pkg-config --libs libxml++-1.0)
+ # Mozilla
+ MOZILLA_LIB_DIR = $(shell dirname `find /usr/lib*/mozilla* -name libgtkembedmoz.so | head -1`)
+ ifeq ($(MOZILLA_LIB_DIR),)

Added: trunk/pinot.spec
===================================================================
--- trunk/pinot.spec	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/pinot.spec	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,138 @@
+# We need an explicit dependency on mozilla as the so files don't have a version number 
+%define mozilla_ver %(/usr/bin/mozilla-config --version)
+
+Summary: Metasearch tool
+Name: pinot
+Version: 0.30
+Release: 1
+License: GPL
+Group: Applications/Internet 
+Source: %{name}-%{version}.tar.gz
+Patch0: libxmlpp026.patch
+URL: <A HREF="http://pinot.berlios.de/">http://pinot.berlios.de/</A>
+BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
+Requires: xapian-core-libs &gt;= 0.9.0, neon &gt;= 0.24, gtkmm24 &gt;= 2.4.12, mozilla &gt;= %{mozilla_ver}, sqlite &gt;= 3.1.2, ots &gt;= 0.4.2, libtextcat &gt;= 2.2, fam &gt;= 2.6.10, gmime &gt;= 2.1, file
+BuildRequires: xapian-core-devel &gt;= 0.9.0, neon-devel &gt;= 0.24, gtkmm24-devel &gt;= 2.4.12, mozilla-devel &gt;= %{mozilla_ver}, sqlite-devel &gt;= 3.1.2, ots-devel &gt;= 0.4.2, libtextcat-devel &gt;= 2.2, fam-devel &gt;= 2.6.10, gmime-devel &gt;= 2.1, file, boost-devel &gt;= 1.32, desktop-file-utils
+%if 0%{?_with_libxmlpp026:1}
+Requires: libxml++ &gt;= 0.26
+BuildRequires: libxml++-devel &gt;= 0.26
+%else
+Requires: libxml++ &gt;= 2.6 
+BuildRequires: libxml++-devel &gt;= 2.6
+%endif
+
+%description
+Pinot is a metasearch tool for the Free Desktop.  It enables one to query
+sources, display as well as analyze and locally index the returned results.
+It may also be used as a lightweight personal space search tool.
+
+%package pdf
+Summary: PDF tokenizer for Pinot that uses pdftohtml
+Group: Applications/Internet
+Requires: %{name} = %{version}
+Requires: pdftohtml
+
+%description pdf
+The included tokenizer enables Pinot to index PDF documents.
+
+%package word 
+Summary: MS Word tokenizer for Pinot that uses antiword
+Group: Applications/Internet
+Requires: %{name} = %{version}
+Requires: antiword
+
+%description word
+The included tokenizer enables Pinot to index MS Word documents.
+
+%package omega 
+Summary: Xapian Omega plugin for Pinot
+Group: Applications/Internet
+Requires: %{name} = %{version}
+Requires: xapian-omega
+
+%description omega
+The included plugin enables Pinot to use Xapian Omega as a search engine.
+
+%prep
+%setup -q
+%if 0%{?_with_libxmlpp026:1}
+%patch0 -p1 -b .xml026
+%endif
+
+%build
+make DEBUG=yes
+make DEBUG=yes pinot_mo
+
+%install
+[ -n &quot;$RPM_BUILD_ROOT&quot; -a &quot;$RPM_BUILD_ROOT&quot; != / ] &amp;&amp; rm -rf $RPM_BUILD_ROOT
+make install PREFIX=$RPM_BUILD_ROOT
+# This engine is not usable as it is
+mv $RPM_BUILD_ROOT/%{_datadir}/pinot/engines/AmazonAPI.src $RPM_BUILD_ROOT/%{_datadir}/pinot/
+# Desktop file
+cat &gt;%{name}.desktop &lt;&lt; EOF
+[Desktop Entry]
+Name=Pinot Metasearch tool
+Comment=Search the Web and your documents
+Exec=%{_bindir}/pinot
+Icon=pinot.png
+Terminal=false
+Type=Application
+Categories=Application;Network;
+Encoding=UTF-8
+EOF
+mkdir -p $RPM_BUILD_ROOT/%{_datadir}/applications
+desktop-file-install --vendor Amra \
+	--dir $RPM_BUILD_ROOT/%{_datadir}/applications  \
+	%{name}.desktop
+
+%post
+gtk-update-icon-cache -q -f %{_datadir}/icons/hicolor || :
+
+%clean
+[ -n &quot;$RPM_BUILD_ROOT&quot; -a &quot;$RPM_BUILD_ROOT&quot; != / ] &amp;&amp; rm -rf $RPM_BUILD_ROOT
+
+%files
+%defattr(-, root, root, -)
+%doc ChangeLog COPYING README TODO
+%{_bindir}/pinot
+%{_datadir}/pinot/index.html
+%{_datadir}/pinot/xapian-powered.png
+%{_datadir}/pinot/metase-gtk2.glade
+%{_datadir}/pinot/metase-gtk2.gladep
+%{_datadir}/pinot/textcat_conf.txt
+%{_datadir}/pinot/*.src
+%dir %{_datadir}/pinot/engines/
+%config(noreplace) %{_datadir}/pinot/engines/A9.src
+%config(noreplace) %{_datadir}/pinot/engines/Acoona.src
+%config(noreplace) %{_datadir}/pinot/engines/Altavista.src
+%config(noreplace) %{_datadir}/pinot/engines/AskJeeves.src
+%config(noreplace) %{_datadir}/pinot/engines/BitTorrent.src
+%config(noreplace) %{_datadir}/pinot/engines/Clusty.src
+%config(noreplace) %{_datadir}/pinot/engines/Freshmeat.src
+%config(noreplace) %{_datadir}/pinot/engines/Koders.src
+%config(noreplace) %{_datadir}/pinot/engines/Google.src
+%config(noreplace) %{_datadir}/pinot/engines/Lycos.src
+%config(noreplace) %{_datadir}/pinot/engines/MSN.src
+%config(noreplace) %{_datadir}/pinot/engines/Teoma.src
+%config(noreplace) %{_datadir}/pinot/engines/Topix.src
+%config(noreplace) %{_datadir}/pinot/engines/WiseNut.src
+%config(noreplace) %{_datadir}/pinot/engines/Yahoo.src
+%config(noreplace) %{_datadir}/pinot/engines/YahooAPI.src
+%config(noreplace) %{_datadir}/pinot/engines/Wikipedia.src
+%{_datadir}/locale/fr/LC_MESSAGES/pinot.mo
+%{_datadir}/icons/hicolor/48x48/apps/pinot.png
+%{_datadir}/applications/Amra-%{name}.desktop
+
+%files pdf
+%defattr(-, root, root, -)
+%dir %{_datadir}/pinot/tokenizers/pdf_tokenizer.so
+
+%files word
+%defattr(-, root, root, -)
+%dir %{_datadir}/pinot/tokenizers/word_tokenizer.so
+
+%files omega
+%defattr(-, root, root, -)
+%config(noreplace) %{_datadir}/pinot/engines/Omega.src
+
+%changelog

Added: trunk/po/POTFILES
===================================================================
--- trunk/po/POTFILES	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/po/POTFILES	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,24 @@
+UI/GTK2/src/aboutDialog.cc
+UI/GTK2/src/aboutDialog_glade.cc
+UI/GTK2/src/EnginesTree.cpp
+UI/GTK2/src/HtmlView.cpp
+UI/GTK2/src/importDialog.cc
+UI/GTK2/src/importDialog_glade.cc
+UI/GTK2/src/indexDialog.cc
+UI/GTK2/src/indexDialog_glade.cc
+UI/GTK2/src/IndexTree.cpp
+UI/GTK2/src/mainWindow.cc
+UI/GTK2/src/mainWindow_glade.cc
+UI/GTK2/src/ModelColumns.cpp
+UI/GTK2/src/MonitorHandler.cpp
+UI/GTK2/src/pinot.cpp
+UI/GTK2/src/PinotSettings.cpp
+UI/GTK2/src/PinotUtils.cpp
+UI/GTK2/src/prefsDialog.cc
+UI/GTK2/src/prefsDialog_glade.cc
+UI/GTK2/src/propertiesDialog.cc
+UI/GTK2/src/propertiesDialog_glade.cc
+UI/GTK2/src/queryDialog.cc
+UI/GTK2/src/queryDialog_glade.cc
+UI/GTK2/src/ResultsTree.cpp
+UI/GTK2/src/WorkerThreads.cpp

Added: trunk/po/en_GB.po
===================================================================
--- trunk/po/en_GB.po	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/po/en_GB.po	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,815 @@
+# en_GB PO file for pinot.
+# Copyright (C) 2005 Fabrice Colin
+# This file is distributed under the same license as the pinot package.
+# Fabrice Colin &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">colinf at chez.com</A>&gt;, 2005.
+#
+#: UI/GTK2/src/importDialog_glade.cc:110 UI/GTK2/src/importDialog_glade.cc:117
+#: UI/GTK2/src/indexDialog_glade.cc:94 UI/GTK2/src/indexDialog_glade.cc:124
+#: UI/GTK2/src/mainWindow_glade.cc:302 UI/GTK2/src/prefsDialog_glade.cc:153
+#: UI/GTK2/src/prefsDialog_glade.cc:164
+#: UI/GTK2/src/propertiesDialog_glade.cc:89
+#: UI/GTK2/src/propertiesDialog_glade.cc:130
+#: UI/GTK2/src/propertiesDialog_glade.cc:143
+#: UI/GTK2/src/queryDialog_glade.cc:115 UI/GTK2/src/queryDialog_glade.cc:126
+#: UI/GTK2/src/queryDialog_glade.cc:133 UI/GTK2/src/queryDialog_glade.cc:140
+#: UI/GTK2/src/queryDialog_glade.cc:205 UI/GTK2/src/queryDialog_glade.cc:212
+#: UI/GTK2/src/queryDialog_glade.cc:237
+#, fuzzy
+msgid &quot;&quot;
+msgstr &quot;&quot;
+&quot;Project-Id-Version: pinot 0.20\n&quot;
+&quot;Report-Msgid-Bugs-To: \n&quot;
+&quot;POT-Creation-Date: 2005-12-08 19:20+0800\n&quot;
+&quot;PO-Revision-Date: 2005-12-08 19:20+0800\n&quot;
+&quot;Last-Translator: Fabrice Colin &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">colinf at chez.com</A>&gt;\n&quot;
+&quot;Language-Team: en_GB &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">colinf at chez.com</A>&gt;\n&quot;
+&quot;MIME-Version: 1.0\n&quot;
+&quot;Content-Type: text/plain; charset=utf-8\n&quot;
+&quot;Content-Transfer-Encoding: 8bit\n&quot;
+
+#: UI/GTK2/src/aboutDialog_glade.cc:342 UI/GTK2/src/mainWindow_glade.cc:445
+msgid &quot;Pinot&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/aboutDialog_glade.cc:344
+msgid &quot;A metasearch tool for the Free Desktop.&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/aboutDialog_glade.cc:345
+msgid &quot;Copyright (C) 2005 Fabrice Colin&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/aboutDialog_glade.cc:388
+msgid &quot;About Pinot&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/EnginesTree.cpp:67
+msgid &quot;Search Engines&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/EnginesTree.cpp:291
+msgid &quot;Current User&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:79
+#: UI/GTK2/src/mainWindow.cc:631 UI/GTK2/src/mainWindow.cc:1059
+#: UI/GTK2/src/mainWindow.cc:2514 UI/GTK2/src/PinotSettings.cpp:198
+#: UI/GTK2/src/PinotSettings.cpp:859 UI/GTK2/src/PinotSettings.cpp:915
+msgid &quot;My Documents&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:635
+#: UI/GTK2/src/MonitorHandler.cpp:173 UI/GTK2/src/PinotSettings.cpp:199
+#: UI/GTK2/src/PinotSettings.cpp:860 UI/GTK2/src/PinotSettings.cpp:916
+#: UI/GTK2/src/prefsDialog_glade.cc:116
+msgid &quot;My Email&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/importDialog.cc:92
+msgid &quot;Single file&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/importDialog.cc:95
+msgid &quot;Whole directory&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/importDialog.cc:100 UI/GTK2/src/IndexTree.cpp:72
+#: UI/GTK2/src/ResultsTree.cpp:116
+msgid &quot;URL&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/importDialog.cc:249
+msgid &quot;Document To Import&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/importDialog_glade.cc:64
+msgid &quot;Select&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/importDialog_glade.cc:73 UI/GTK2/src/indexDialog_glade.cc:68
+msgid &quot;Location:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/importDialog_glade.cc:74
+#: UI/GTK2/src/propertiesDialog_glade.cc:64
+msgid &quot;Title:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/importDialog_glade.cc:75
+msgid &quot;Maximum depth:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/importDialog_glade.cc:81 UI/GTK2/src/indexDialog_glade.cc:67
+#: UI/GTK2/src/propertiesDialog_glade.cc:68
+msgid &quot;Type:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/importDialog_glade.cc:163
+msgid &quot;Import document&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/indexDialog.cc:202
+msgid &quot;Index location&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/indexDialog_glade.cc:62 UI/GTK2/src/queryDialog_glade.cc:60
+msgid &quot;Name:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/indexDialog_glade.cc:64 UI/GTK2/src/prefsDialog_glade.cc:70
+msgid &quot;...&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/indexDialog_glade.cc:69
+msgid &quot;Port:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/indexDialog_glade.cc:145
+msgid &quot;External index&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/IndexTree.cpp:66 UI/GTK2/src/ResultsTree.cpp:98
+msgid &quot;Title&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/IndexTree.cpp:77
+msgid &quot;Timestamp&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/IndexTree.cpp:219 UI/GTK2/src/WorkerThreads.cpp:341
+msgid &quot;No title&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:78 UI/GTK2/src/mainWindow.cc:489
+#: UI/GTK2/src/mainWindow.cc:684
+msgid &quot;None&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:217
+msgid &quot;Query Name&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:222
+msgid &quot;Last Run&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:223
+msgid &quot;Summary&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:306
+msgid &quot;Add index&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:307
+msgid &quot;Remove index&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:332
+msgid &quot;Ready&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:385
+msgid &quot;N/A&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:395 UI/GTK2/src/mainWindow.cc:1480
+msgid &quot;&lt;undefined&gt;&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:602
+msgid &quot;Result location is&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:646
+msgid &quot;Document location is&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:687
+msgid &quot;No labels&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:791
+msgid &quot;Showing&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:796
+msgid &quot;off&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:801
+msgid &quot;documents from&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:871
+msgid &quot;Query&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:875 UI/GTK2/src/mainWindow.cc:2482
+#: UI/GTK2/src/ResultsTree.cpp:436 UI/GTK2/src/ResultsTree.cpp:708
+msgid &quot;on&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:879
+msgid &quot;ended&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:940 UI/GTK2/src/propertiesDialog.cc:34
+msgid &quot;Label&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:944
+msgid &quot;matches&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:949
+msgid &quot;document(s)&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1027 UI/GTK2/src/mainWindow.cc:1122
+msgid &quot;Updated document&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1034
+msgid &quot;Indexed&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1101
+msgid &quot;Unindexed document(s)&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1179
+msgid &quot;Couldn't rename index, name&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1183 UI/GTK2/src/mainWindow.cc:1914
+#: UI/GTK2/src/mainWindow.cc:2024 UI/GTK2/src/mainWindow.cc:2081
+msgid &quot;is already in use&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1196
+msgid &quot;Couldn't rename index&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1209
+msgid &quot;Edited index&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1581 UI/GTK2/src/mainWindow.cc:1640
+msgid &quot;Please set a location for the index first&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1597
+msgid &quot;Result location is unknown&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1613
+msgid &quot;Import Document(s)&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1693 UI/GTK2/src/mainWindow_glade.cc:163
+#: UI/GTK2/src/pinot.cpp:111 UI/GTK2/src/pinot.cpp:116
+#: UI/GTK2/src/WorkerThreads.cpp:184 UI/GTK2/src/WorkerThreads.cpp:417
+#: UI/GTK2/src/WorkerThreads.cpp:960
+msgid &quot;Index&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1697 UI/GTK2/src/WorkerThreads.cpp:188
+#: UI/GTK2/src/WorkerThreads.cpp:421 UI/GTK2/src/WorkerThreads.cpp:964
+msgid &quot;doesn't exist&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1805
+msgid &quot;Delete this document from the index ?&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1816
+msgid &quot;Delete these documents from the index ?&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1910
+msgid &quot;Index name&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1925
+msgid &quot;Couldn't add index&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1939
+msgid &quot;Added new index&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1974
+msgid &quot;Couldn't remove index&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2020 UI/GTK2/src/mainWindow.cc:2077
+msgid &quot;Query name&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2034
+msgid &quot;Couldn't add query&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2043
+msgid &quot;Added new query&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2102
+msgid &quot;Couldn't update query&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2111
+msgid &quot;Edited query&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2263
+msgid &quot;At least one background task hasn't been completed yet. Quit now ?&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2376
+msgid &quot;Query is not set&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2387
+msgid &quot;No search engine selected&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2469
+msgid &quot;Please set the Google API key first&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2478
+msgid &quot;Running query&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2628
+msgid &quot;No URL to browse&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2642
+msgid &quot;No browser configured to view results&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2654
+msgid &quot;Couldn't browse URL:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2883
+msgid &quot;thread(s)&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:115
+msgid &quot;Query:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:127 UI/GTK2/src/prefsDialog_glade.cc:86
+msgid &quot;Edit&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:136
+msgid &quot;Stored queries&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:144
+msgid &quot;Results&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:166 UI/GTK2/src/mainWindow_glade.cc:234
+msgid &quot;View&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:198
+msgid &quot;Search Engine&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:201
+msgid &quot;Host Name&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:204
+msgid &quot;Clear List&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:207
+msgid &quot;Show Extract&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:210
+msgid &quot;Group By&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:216
+msgid &quot;Vie_w&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:219
+msgid &quot;View Cache&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:222 UI/GTK2/src/mainWindow_glade.cc:258
+msgid &quot;_Index&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:225
+msgid &quot;Show Label&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:228
+msgid &quot;Import&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:237
+msgid &quot;Update&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:240
+msgid &quot;Unindex&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:243
+#: UI/GTK2/src/propertiesDialog_glade.cc:174
+#: UI/GTK2/src/queryDialog_glade.cc:80
+msgid &quot;Properties&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:246
+msgid &quot;_About&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:249
+msgid &quot;_Session&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:252
+msgid &quot;_Edit&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:255
+msgid &quot;_Results&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:261
+msgid &quot;_Help&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:55
+msgid &quot;Couldn't save configuration file&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:112 UI/GTK2/src/pinot.cpp:117
+msgid &quot;is not valid, please check&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:127
+msgid &quot;History database&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:128
+msgid &quot;couldn't be created&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:134
+msgid &quot;Danish&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:135
+msgid &quot;Dutch&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:136
+msgid &quot;English&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:137
+msgid &quot;Finnish&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:138
+msgid &quot;French&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:139
+msgid &quot;German&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:140
+msgid &quot;Italian&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:141
+msgid &quot;Norwegian&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:142
+msgid &quot;Portuguese&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:143
+msgid &quot;Russian&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:144
+msgid &quot;Spanish&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/pinot.cpp:145
+msgid &quot;Swedish&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:105
+msgid &quot;Couldn't create pinot directory at&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:194
+msgid &quot;Failed to parse configuration file&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:203
+msgid &quot;Red&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:205
+msgid &quot;Blue&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:207
+msgid &quot;Green&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:279
+msgid &quot;Couldn't load ui block&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:286
+msgid &quot;Couldn't load extraindex block&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:293
+msgid &quot;Couldn't load storedquery block&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:300
+msgid &quot;Couldn't load results block&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:307
+msgid &quot;Couldn't load label block&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:325
+msgid &quot;Couldn't load mailaccount block&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:711
+msgid &quot;Unclassified&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:63
+msgid &quot;Name&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:71
+msgid &quot;Location&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:72
+msgid &quot;MIME Type&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:100
+msgid &quot;In internal viewer&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:103
+msgid &quot;In browser&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:364
+msgid &quot;Browser location&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:375
+msgid &quot;New Label&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:397
+msgid &quot;Colour&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:463
+msgid &quot;Import Mail Box(es)&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:481
+msgid &quot;Mbox File Location&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:62
+msgid &quot;HTTP crawling:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:63
+msgid &quot;View documents:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:64
+msgid &quot;Browser:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:65
+msgid &quot;Google API Key:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:68
+msgid &quot;Ignore robots.txt and Robots META tag&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:74
+msgid &quot;General&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:75
+msgid &quot;Labels are used to classify indexed documents:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:80 UI/GTK2/src/prefsDialog_glade.cc:106
+msgid &quot;Add&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:92
+msgid &quot;Remove&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:100
+msgid &quot;Labels&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:101
+msgid &quot;Mail boxes of type mbox can be monitored and indexed:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:334
+msgid &quot;Preferences&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/propertiesDialog.cc:45
+msgid &quot;Unknown&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/propertiesDialog_glade.cc:65
+msgid &quot;Extract:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/propertiesDialog_glade.cc:66
+msgid &quot;Language:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/queryDialog.cc:107
+msgid &quot;Any&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:70
+msgid &quot;Index all results with label&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:72
+msgid &quot;Any of the words:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:73
+msgid &quot;Host name:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:74
+msgid &quot;File name:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:75
+msgid &quot;Number of results:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:81
+msgid &quot;Limit to documents that match&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:85
+msgid &quot;the exact phrase:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:86
+msgid &quot;none of the words:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:87
+msgid &quot;the language:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:91
+msgid &quot;all the words:&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:94
+msgid &quot;Advanced&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:278
+msgid &quot;Query properties&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:163
+msgid &quot;Stopped browsing&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:197 UI/GTK2/src/WorkerThreads.cpp:632
+#: UI/GTK2/src/WorkerThreads.cpp:838 UI/GTK2/src/WorkerThreads.cpp:973
+msgid &quot;Index error on&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:303
+msgid &quot;Stopped querying&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:315
+msgid &quot;Couldn't create search engine&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:327
+msgid &quot;Couldn't run query on search engine&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:401
+msgid &quot;Stopped querying index labels&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:482
+msgid &quot;Stopped retrieval of&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:518
+msgid &quot;Couldn't obtain downloader for protocol&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:532 UI/GTK2/src/WorkerThreads.cpp:646
+msgid &quot;Couldn't retrieve&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:617
+msgid &quot;Stopped indexing&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:671
+msgid &quot;Cannot index document type&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:675
+msgid &quot;at&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:693
+msgid &quot;Couln't tokenize&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:714
+msgid &quot;Robots META tag forbids indexing&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:760
+msgid &quot;Couldn't index&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:825
+msgid &quot;Stopped unindexing document(s)&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:846
+msgid &quot;Couldn't unindex document(s)&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:945
+msgid &quot;Stopped document update for &quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:982
+msgid &quot;Couldn't update document&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:1022
+msgid &quot;Stopped listening on&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:1114
+msgid &quot;Couldn't read FIFO at&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:1154
+msgid &quot;Stopped monitoring&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:1172
+msgid &quot;No monitoring handler&quot;
+msgstr &quot;&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:1206
+msgid &quot;Couldn't open FAM connection&quot;
+msgstr &quot;&quot;

Added: trunk/po/fr_FR.po
===================================================================
--- trunk/po/fr_FR.po	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/po/fr_FR.po	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,815 @@
+# fr_FR PO file for pinot.
+# Copyright (C) 2005 Fabrice Colin
+# This file is distributed under the same license as the pinot package.
+# Fabrice Colin &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">colinf at chez.com</A>&gt;, 2005.
+#
+#: UI/GTK2/src/importDialog_glade.cc:110 UI/GTK2/src/importDialog_glade.cc:117
+#: UI/GTK2/src/indexDialog_glade.cc:94 UI/GTK2/src/indexDialog_glade.cc:124
+#: UI/GTK2/src/mainWindow_glade.cc:302 UI/GTK2/src/prefsDialog_glade.cc:153
+#: UI/GTK2/src/prefsDialog_glade.cc:164
+#: UI/GTK2/src/propertiesDialog_glade.cc:89
+#: UI/GTK2/src/propertiesDialog_glade.cc:130
+#: UI/GTK2/src/propertiesDialog_glade.cc:143
+#: UI/GTK2/src/queryDialog_glade.cc:115 UI/GTK2/src/queryDialog_glade.cc:126
+#: UI/GTK2/src/queryDialog_glade.cc:133 UI/GTK2/src/queryDialog_glade.cc:140
+#: UI/GTK2/src/queryDialog_glade.cc:205 UI/GTK2/src/queryDialog_glade.cc:212
+#: UI/GTK2/src/queryDialog_glade.cc:237
+#, fuzzy
+msgid &quot;&quot;
+msgstr &quot;&quot;
+&quot;Project-Id-Version: pinot 0.20\n&quot;
+&quot;Report-Msgid-Bugs-To: \n&quot;
+&quot;POT-Creation-Date: 2005-12-08 19:20+0800\n&quot;
+&quot;PO-Revision-Date: 2005-12-08 19:20+0800\n&quot;
+&quot;Last-Translator: Fabrice Colin &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">colinf at chez.com</A>&gt;\n&quot;
+&quot;Language-Team: en_GB &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">colinf at chez.com</A>&gt;\n&quot;
+&quot;MIME-Version: 1.0\n&quot;
+&quot;Content-Type: text/plain; charset=utf-8\n&quot;
+&quot;Content-Transfer-Encoding: 8bit\n&quot;
+
+#: UI/GTK2/src/aboutDialog_glade.cc:342 UI/GTK2/src/mainWindow_glade.cc:445
+msgid &quot;Pinot&quot;
+msgstr &quot;Pinot&quot;
+
+#: UI/GTK2/src/aboutDialog_glade.cc:344
+msgid &quot;A metasearch tool for the Free Desktop.&quot;
+msgstr &quot;Un outil de recherche pour le Bureau Libre&quot;
+
+#: UI/GTK2/src/aboutDialog_glade.cc:345
+msgid &quot;Copyright (C) 2005 Fabrice Colin&quot;
+msgstr &quot;Copyright (C) 2005 Fabrice Colin&quot;
+
+#: UI/GTK2/src/aboutDialog_glade.cc:388
+msgid &quot;About Pinot&quot;
+msgstr &quot;A Propos de Pinot&quot;
+
+#: UI/GTK2/src/EnginesTree.cpp:67
+msgid &quot;Search Engines&quot;
+msgstr &quot;Moteurs&quot;
+
+#: UI/GTK2/src/EnginesTree.cpp:291
+msgid &quot;Current User&quot;
+msgstr &quot;Utilisateur&quot;
+
+#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:79
+#: UI/GTK2/src/mainWindow.cc:631 UI/GTK2/src/mainWindow.cc:1059
+#: UI/GTK2/src/mainWindow.cc:2514 UI/GTK2/src/PinotSettings.cpp:198
+#: UI/GTK2/src/PinotSettings.cpp:859 UI/GTK2/src/PinotSettings.cpp:915
+msgid &quot;My Documents&quot;
+msgstr &quot;Mes Documents&quot;
+
+#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:635
+#: UI/GTK2/src/MonitorHandler.cpp:173 UI/GTK2/src/PinotSettings.cpp:199
+#: UI/GTK2/src/PinotSettings.cpp:860 UI/GTK2/src/PinotSettings.cpp:916
+#: UI/GTK2/src/prefsDialog_glade.cc:116
+msgid &quot;My Email&quot;
+msgstr &quot;Mon Courrier&quot;
+
+#: UI/GTK2/src/importDialog.cc:92
+msgid &quot;Single file&quot;
+msgstr &quot;Un fichier&quot;
+
+#: UI/GTK2/src/importDialog.cc:95
+msgid &quot;Whole directory&quot;
+msgstr &quot;Un repertoire&quot;
+
+#: UI/GTK2/src/importDialog.cc:100 UI/GTK2/src/IndexTree.cpp:72
+#: UI/GTK2/src/ResultsTree.cpp:116
+msgid &quot;URL&quot;
+msgstr &quot;URL&quot;
+
+#: UI/GTK2/src/importDialog.cc:249
+msgid &quot;Document To Import&quot;
+msgstr &quot;Document A Importer&quot;
+
+#: UI/GTK2/src/importDialog_glade.cc:64
+msgid &quot;Select&quot;
+msgstr &quot;Selectionner&quot;
+
+#: UI/GTK2/src/importDialog_glade.cc:73 UI/GTK2/src/indexDialog_glade.cc:68
+msgid &quot;Location:&quot;
+msgstr &quot;Location:&quot;
+
+#: UI/GTK2/src/importDialog_glade.cc:74
+#: UI/GTK2/src/propertiesDialog_glade.cc:64
+msgid &quot;Title:&quot;
+msgstr &quot;Titre:&quot;
+
+#: UI/GTK2/src/importDialog_glade.cc:75
+msgid &quot;Maximum depth:&quot;
+msgstr &quot;Profondeur maximum:&quot;
+
+#: UI/GTK2/src/importDialog_glade.cc:81 UI/GTK2/src/indexDialog_glade.cc:67
+#: UI/GTK2/src/propertiesDialog_glade.cc:68
+msgid &quot;Type:&quot;
+msgstr &quot;Type:&quot;
+
+#: UI/GTK2/src/importDialog_glade.cc:163
+msgid &quot;Import document&quot;
+msgstr &quot;Importation de document&quot;
+
+#: UI/GTK2/src/indexDialog.cc:202
+msgid &quot;Index location&quot;
+msgstr &quot;Location de l'index&quot;
+
+#: UI/GTK2/src/indexDialog_glade.cc:62 UI/GTK2/src/queryDialog_glade.cc:60
+msgid &quot;Name:&quot;
+msgstr &quot;Nom:&quot;
+
+#: UI/GTK2/src/indexDialog_glade.cc:64 UI/GTK2/src/prefsDialog_glade.cc:70
+msgid &quot;...&quot;
+msgstr &quot;...&quot;
+
+#: UI/GTK2/src/indexDialog_glade.cc:69
+msgid &quot;Port:&quot;
+msgstr &quot;Port:&quot;
+
+#: UI/GTK2/src/indexDialog_glade.cc:145
+msgid &quot;External index&quot;
+msgstr &quot;Index externe&quot;
+
+#: UI/GTK2/src/IndexTree.cpp:66 UI/GTK2/src/ResultsTree.cpp:98
+msgid &quot;Title&quot;
+msgstr &quot;Titre&quot;
+
+#: UI/GTK2/src/IndexTree.cpp:77
+msgid &quot;Timestamp&quot;
+msgstr &quot;Date&quot;
+
+#: UI/GTK2/src/IndexTree.cpp:219 UI/GTK2/src/WorkerThreads.cpp:341
+msgid &quot;No title&quot;
+msgstr &quot;Pas de titre&quot;
+
+#: UI/GTK2/src/mainWindow.cc:78 UI/GTK2/src/mainWindow.cc:489
+#: UI/GTK2/src/mainWindow.cc:684
+msgid &quot;None&quot;
+msgstr &quot;Aucune&quot;
+
+#: UI/GTK2/src/mainWindow.cc:217
+msgid &quot;Query Name&quot;
+msgstr &quot;Nom de la Recherche&quot;
+
+#: UI/GTK2/src/mainWindow.cc:222
+msgid &quot;Last Run&quot;
+msgstr &quot;Derniere Utilisation&quot;
+
+#: UI/GTK2/src/mainWindow.cc:223
+msgid &quot;Summary&quot;
+msgstr &quot;Sommaire&quot;
+
+#: UI/GTK2/src/mainWindow.cc:306
+msgid &quot;Add index&quot;
+msgstr &quot;Ajouter un index&quot;
+
+#: UI/GTK2/src/mainWindow.cc:307
+msgid &quot;Remove index&quot;
+msgstr &quot;Enlever un index&quot;
+
+#: UI/GTK2/src/mainWindow.cc:332
+msgid &quot;Ready&quot;
+msgstr &quot;Pret&quot;
+
+#: UI/GTK2/src/mainWindow.cc:385
+msgid &quot;N/A&quot;
+msgstr &quot;Inconnue&quot;
+
+#: UI/GTK2/src/mainWindow.cc:395 UI/GTK2/src/mainWindow.cc:1480
+msgid &quot;&lt;undefined&gt;&quot;
+msgstr &quot;&lt;inconnu&gt;&quot;
+
+#: UI/GTK2/src/mainWindow.cc:602
+msgid &quot;Result location is&quot;
+msgstr &quot;La location du resultat est&quot;
+
+#: UI/GTK2/src/mainWindow.cc:646
+msgid &quot;Document location is&quot;
+msgstr &quot;La location du document is&quot;
+
+#: UI/GTK2/src/mainWindow.cc:687
+msgid &quot;No labels&quot;
+msgstr &quot;Pas d'etiquettes&quot;
+
+#: UI/GTK2/src/mainWindow.cc:791
+msgid &quot;Showing&quot;
+msgstr &quot;Listant&quot;
+
+#: UI/GTK2/src/mainWindow.cc:796
+msgid &quot;off&quot;
+msgstr &quot;de&quot;
+
+#: UI/GTK2/src/mainWindow.cc:801
+msgid &quot;documents from&quot;
+msgstr &quot;documents venant de&quot;
+
+#: UI/GTK2/src/mainWindow.cc:871
+msgid &quot;Query&quot;
+msgstr &quot;La recherche&quot;
+
+#: UI/GTK2/src/mainWindow.cc:875 UI/GTK2/src/mainWindow.cc:2482
+#: UI/GTK2/src/ResultsTree.cpp:436 UI/GTK2/src/ResultsTree.cpp:708
+msgid &quot;on&quot;
+msgstr &quot;sur&quot;
+
+#: UI/GTK2/src/mainWindow.cc:879
+msgid &quot;ended&quot;
+msgstr &quot;est terminee&quot;
+
+#: UI/GTK2/src/mainWindow.cc:940 UI/GTK2/src/propertiesDialog.cc:34
+msgid &quot;Label&quot;
+msgstr &quot;L'etiquette&quot;
+
+#: UI/GTK2/src/mainWindow.cc:944
+msgid &quot;matches&quot;
+msgstr &quot;correspond a&quot;
+
+#: UI/GTK2/src/mainWindow.cc:949
+msgid &quot;document(s)&quot;
+msgstr &quot;document(s)&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1027 UI/GTK2/src/mainWindow.cc:1122
+msgid &quot;Updated document&quot;
+msgstr &quot;Mis a jour le document&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1034
+msgid &quot;Indexed&quot;
+msgstr &quot;Indexe&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1101
+msgid &quot;Unindexed document(s)&quot;
+msgstr &quot;Desindexe le(s) document(s)&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1179
+msgid &quot;Couldn't rename index, name&quot;
+msgstr &quot;N'a pas pu renommer l'index&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1183 UI/GTK2/src/mainWindow.cc:1914
+#: UI/GTK2/src/mainWindow.cc:2024 UI/GTK2/src/mainWindow.cc:2081
+msgid &quot;is already in use&quot;
+msgstr &quot;est deja utilise&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1196
+msgid &quot;Couldn't rename index&quot;
+msgstr &quot;N'a pas pu renommer l'index&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1209
+msgid &quot;Edited index&quot;
+msgstr &quot;Edite l'index&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1581 UI/GTK2/src/mainWindow.cc:1640
+msgid &quot;Please set a location for the index first&quot;
+msgstr &quot;Donnez une location a l'index&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1597
+msgid &quot;Result location is unknown&quot;
+msgstr &quot;La location du resultat est inconnue&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1613
+msgid &quot;Import Document(s)&quot;
+msgstr &quot;Importation de Document(s)&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1693 UI/GTK2/src/mainWindow_glade.cc:163
+#: UI/GTK2/src/pinot.cpp:111 UI/GTK2/src/pinot.cpp:116
+#: UI/GTK2/src/WorkerThreads.cpp:184 UI/GTK2/src/WorkerThreads.cpp:417
+#: UI/GTK2/src/WorkerThreads.cpp:960
+msgid &quot;Index&quot;
+msgstr &quot;L'index&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1697 UI/GTK2/src/WorkerThreads.cpp:188
+#: UI/GTK2/src/WorkerThreads.cpp:421 UI/GTK2/src/WorkerThreads.cpp:964
+msgid &quot;doesn't exist&quot;
+msgstr &quot;n'existe pas&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1805
+msgid &quot;Delete this document from the index ?&quot;
+msgstr &quot;Enlever ce document de l'index ?&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1816
+msgid &quot;Delete these documents from the index ?&quot;
+msgstr &quot;Enlever ces documents de l'index ?&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1910
+msgid &quot;Index name&quot;
+msgstr &quot;Nom de l'index&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1925
+msgid &quot;Couldn't add index&quot;
+msgstr &quot;N'a pas pu ajouter l'index&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1939
+msgid &quot;Added new index&quot;
+msgstr &quot;Ajouter un nouvel index&quot;
+
+#: UI/GTK2/src/mainWindow.cc:1974
+msgid &quot;Couldn't remove index&quot;
+msgstr &quot;N'a pas pu enlever l'index&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2020 UI/GTK2/src/mainWindow.cc:2077
+msgid &quot;Query name&quot;
+msgstr &quot;Nom de la recherche&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2034
+msgid &quot;Couldn't add query&quot;
+msgstr &quot;N'a pas pu ajouter la recherche&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2043
+msgid &quot;Added new query&quot;
+msgstr &quot;Ajoute une nouvelle recherche&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2102
+msgid &quot;Couldn't update query&quot;
+msgstr &quot;N'a pas pu mettre a jour la recherche&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2111
+msgid &quot;Edited query&quot;
+msgstr &quot;Edite la recherche&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2263
+msgid &quot;At least one background task hasn't been completed yet. Quit now ?&quot;
+msgstr &quot;Au moins une tache n'est pas terminee. Quitter maintenant ?&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2376
+msgid &quot;Query is not set&quot;
+msgstr &quot;Recherche indefinie&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2387
+msgid &quot;No search engine selected&quot;
+msgstr &quot;Pas de moteur selectionne&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2469
+msgid &quot;Please set the Google API key first&quot;
+msgstr &quot;Configurez la clef de l'API Google &quot;
+
+#: UI/GTK2/src/mainWindow.cc:2478
+msgid &quot;Running query&quot;
+msgstr &quot;Recherche en cours&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2628
+msgid &quot;No URL to browse&quot;
+msgstr &quot;Pas d'URL a brouter&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2642
+msgid &quot;No browser configured to view results&quot;
+msgstr &quot;Pas de brouter configure&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2654
+msgid &quot;Couldn't browse URL:&quot;
+msgstr &quot;N'a pas pu brouter l'URL&quot;
+
+#: UI/GTK2/src/mainWindow.cc:2883
+msgid &quot;thread(s)&quot;
+msgstr &quot;tache(s)&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:115
+msgid &quot;Query:&quot;
+msgstr &quot;Recherche:&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:127 UI/GTK2/src/prefsDialog_glade.cc:86
+msgid &quot;Edit&quot;
+msgstr &quot;Editer&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:136
+msgid &quot;Stored queries&quot;
+msgstr &quot;Recherches Sauvees&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:144
+msgid &quot;Results&quot;
+msgstr &quot;Resultats&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:166 UI/GTK2/src/mainWindow_glade.cc:234
+msgid &quot;View&quot;
+msgstr &quot;Voir&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:198
+msgid &quot;Search Engine&quot;
+msgstr &quot;Moteurs&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:201
+msgid &quot;Host Name&quot;
+msgstr &quot;Nom de machine&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:204
+msgid &quot;Clear List&quot;
+msgstr &quot;Nettoyer la Liste&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:207
+msgid &quot;Show Extract&quot;
+msgstr &quot;Montrer l'Extrait&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:210
+msgid &quot;Group By&quot;
+msgstr &quot;Grouper Par&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:216
+msgid &quot;Vie_w&quot;
+msgstr &quot;Voir&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:219
+msgid &quot;View Cache&quot;
+msgstr &quot;Voir le Cache&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:222 UI/GTK2/src/mainWindow_glade.cc:258
+msgid &quot;_Index&quot;
+msgstr &quot;Indexer&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:225
+msgid &quot;Show Label&quot;
+msgstr &quot;Montrer l'Etiquette&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:228
+msgid &quot;Import&quot;
+msgstr &quot;Importer&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:237
+msgid &quot;Update&quot;
+msgstr &quot;Mettre a Jour&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:240
+msgid &quot;Unindex&quot;
+msgstr &quot;Desindexer&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:243
+#: UI/GTK2/src/propertiesDialog_glade.cc:174
+#: UI/GTK2/src/queryDialog_glade.cc:80
+msgid &quot;Properties&quot;
+msgstr &quot;Proprietes&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:246
+msgid &quot;_About&quot;
+msgstr &quot;A Propos&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:249
+msgid &quot;_Session&quot;
+msgstr &quot;Session&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:252
+msgid &quot;_Edit&quot;
+msgstr &quot;Editer&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:255
+msgid &quot;_Results&quot;
+msgstr &quot;Resultats&quot;
+
+#: UI/GTK2/src/mainWindow_glade.cc:261
+msgid &quot;_Help&quot;
+msgstr &quot;Aide&quot;
+
+#: UI/GTK2/src/pinot.cpp:55
+msgid &quot;Couldn't save configuration file&quot;
+msgstr &quot;N'a pas pu sauver la configuration&quot;
+
+#: UI/GTK2/src/pinot.cpp:112 UI/GTK2/src/pinot.cpp:117
+msgid &quot;is not valid, please check&quot;
+msgstr &quot;n'est pas valide, veuillez verifier&quot;
+
+#: UI/GTK2/src/pinot.cpp:127
+msgid &quot;History database&quot;
+msgstr &quot;La base des historiques&quot;
+
+#: UI/GTK2/src/pinot.cpp:128
+msgid &quot;couldn't be created&quot;
+msgstr &quot;n'a pas pu etre creee&quot;
+
+#: UI/GTK2/src/pinot.cpp:134
+msgid &quot;Danish&quot;
+msgstr &quot;Danois&quot;
+
+#: UI/GTK2/src/pinot.cpp:135
+msgid &quot;Dutch&quot;
+msgstr &quot;Hollandais&quot;
+
+#: UI/GTK2/src/pinot.cpp:136
+msgid &quot;English&quot;
+msgstr &quot;Anglais&quot;
+
+#: UI/GTK2/src/pinot.cpp:137
+msgid &quot;Finnish&quot;
+msgstr &quot;Finlandais&quot;
+
+#: UI/GTK2/src/pinot.cpp:138
+msgid &quot;French&quot;
+msgstr &quot;Francais&quot;
+
+#: UI/GTK2/src/pinot.cpp:139
+msgid &quot;German&quot;
+msgstr &quot;Allemand&quot;
+
+#: UI/GTK2/src/pinot.cpp:140
+msgid &quot;Italian&quot;
+msgstr &quot;Italien&quot;
+
+#: UI/GTK2/src/pinot.cpp:141
+msgid &quot;Norwegian&quot;
+msgstr &quot;Norvegien&quot;
+
+#: UI/GTK2/src/pinot.cpp:142
+msgid &quot;Portuguese&quot;
+msgstr &quot;Portugais&quot;
+
+#: UI/GTK2/src/pinot.cpp:143
+msgid &quot;Russian&quot;
+msgstr &quot;Russe&quot;
+
+#: UI/GTK2/src/pinot.cpp:144
+msgid &quot;Spanish&quot;
+msgstr &quot;Espagnol&quot;
+
+#: UI/GTK2/src/pinot.cpp:145
+msgid &quot;Swedish&quot;
+msgstr &quot;Suedois&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:105
+msgid &quot;Couldn't create pinot directory at&quot;
+msgstr &quot;N'a pas pu creer le repertoire a&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:194
+msgid &quot;Failed to parse configuration file&quot;
+msgstr &quot;N'a pas pu lire le fichier de configuration&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:203
+msgid &quot;Red&quot;
+msgstr &quot;Rouge&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:205
+msgid &quot;Blue&quot;
+msgstr &quot;Bleu&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:207
+msgid &quot;Green&quot;
+msgstr &quot;Vert&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:279
+msgid &quot;Couldn't load ui block&quot;
+msgstr &quot;N'a pas pu charger le bloc ui&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:286
+msgid &quot;Couldn't load extraindex block&quot;
+msgstr &quot;N'a pas pu charger le bloc extraindex&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:293
+msgid &quot;Couldn't load storedquery block&quot;
+msgstr &quot;N'a pas pu charger le bloc storedquery&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:300
+msgid &quot;Couldn't load results block&quot;
+msgstr &quot;N'a pas pu charger le bloc results&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:307
+msgid &quot;Couldn't load label block&quot;
+msgstr &quot;N'a pas pu charger le bloc label&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:325
+msgid &quot;Couldn't load mailaccount block&quot;
+msgstr &quot;N'a pas pu charger le bloc mailaccount&quot;
+
+#: UI/GTK2/src/PinotSettings.cpp:711
+msgid &quot;Unclassified&quot;
+msgstr &quot;Non classifie&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:63
+msgid &quot;Name&quot;
+msgstr &quot;Nom&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:71
+msgid &quot;Location&quot;
+msgstr &quot;Location&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:72
+msgid &quot;MIME Type&quot;
+msgstr &quot;Type MIME&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:100
+msgid &quot;In internal viewer&quot;
+msgstr &quot;Dans le brouteur interne&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:103
+msgid &quot;In browser&quot;
+msgstr &quot;Dans le brouteur&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:364
+msgid &quot;Browser location&quot;
+msgstr &quot;Brouter la location&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:375
+msgid &quot;New Label&quot;
+msgstr &quot;Nouvelle Etiquette&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:397
+msgid &quot;Colour&quot;
+msgstr &quot;Couleur&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:463
+msgid &quot;Import Mail Box(es)&quot;
+msgstr &quot;Impoter des Boites de Courrier&quot;
+
+#: UI/GTK2/src/prefsDialog.cc:481
+msgid &quot;Mbox File Location&quot;
+msgstr &quot;Location du Fichier mbox&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:62
+msgid &quot;HTTP crawling:&quot;
+msgstr &quot;Brouteur HTTP:&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:63
+msgid &quot;View documents:&quot;
+msgstr &quot;Voir les documents&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:64
+msgid &quot;Browser:&quot;
+msgstr &quot;Brouteur:&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:65
+msgid &quot;Google API Key:&quot;
+msgstr &quot;Clef de l'API Google&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:68
+msgid &quot;Ignore robots.txt and Robots META tag&quot;
+msgstr &quot;Ignorer robots.txt et le META tag Robots&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:74
+msgid &quot;General&quot;
+msgstr &quot;General&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:75
+msgid &quot;Labels are used to classify indexed documents:&quot;
+msgstr &quot;Les etiquettes servent a classer les documents:&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:80 UI/GTK2/src/prefsDialog_glade.cc:106
+msgid &quot;Add&quot;
+msgstr &quot;Ajouter&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:92
+msgid &quot;Remove&quot;
+msgstr &quot;Enlever&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:100
+msgid &quot;Labels&quot;
+msgstr &quot;Etiquettes&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:101
+msgid &quot;Mail boxes of type mbox can be monitored and indexed:&quot;
+msgstr &quot;Les boites de type mbox peuvent etre indexees&quot;
+
+#: UI/GTK2/src/prefsDialog_glade.cc:334
+msgid &quot;Preferences&quot;
+msgstr &quot;Preferences&quot;
+
+#: UI/GTK2/src/propertiesDialog.cc:45
+msgid &quot;Unknown&quot;
+msgstr &quot;Inconnu&quot;
+
+#: UI/GTK2/src/propertiesDialog_glade.cc:65
+msgid &quot;Extract:&quot;
+msgstr &quot;Extrait:&quot;
+
+#: UI/GTK2/src/propertiesDialog_glade.cc:66
+msgid &quot;Language:&quot;
+msgstr &quot;Langue:&quot;
+
+#: UI/GTK2/src/queryDialog.cc:107
+msgid &quot;Any&quot;
+msgstr &quot;N'importe&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:70
+msgid &quot;Index all results with label&quot;
+msgstr &quot;Indexer tous les resultats avec l'etiquette&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:72
+msgid &quot;Any of the words:&quot;
+msgstr &quot;N'importe lequel des mots:&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:73
+msgid &quot;Host name:&quot;
+msgstr &quot;Nom de machine:&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:74
+msgid &quot;File name:&quot;
+msgstr &quot;Nom de fichier:&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:75
+msgid &quot;Number of results:&quot;
+msgstr &quot;Nombre de resultats:&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:81
+msgid &quot;Limit to documents that match&quot;
+msgstr &quot;Limiter aux documents qui ont&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:85
+msgid &quot;the exact phrase:&quot;
+msgstr &quot;la phrase&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:86
+msgid &quot;none of the words:&quot;
+msgstr &quot;aucun des mots&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:87
+msgid &quot;the language:&quot;
+msgstr &quot;la langue&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:91
+msgid &quot;all the words:&quot;
+msgstr &quot;tous les mots&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:94
+msgid &quot;Advanced&quot;
+msgstr &quot;Avance&quot;
+
+#: UI/GTK2/src/queryDialog_glade.cc:278
+msgid &quot;Query properties&quot;
+msgstr &quot;Proprietes de la recherche&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:163
+msgid &quot;Stopped browsing&quot;
+msgstr &quot;Arrete le brouteur&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:197 UI/GTK2/src/WorkerThreads.cpp:632
+#: UI/GTK2/src/WorkerThreads.cpp:838 UI/GTK2/src/WorkerThreads.cpp:973
+msgid &quot;Index error on&quot;
+msgstr &quot;Erreur d'index sur&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:303
+msgid &quot;Stopped querying&quot;
+msgstr &quot;Arrete la recherche&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:315
+msgid &quot;Couldn't create search engine&quot;
+msgstr &quot;N'a pas pu creer le moteur&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:327
+msgid &quot;Couldn't run query on search engine&quot;
+msgstr &quot;N'a pas pu lancer la recherche sur le moteur&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:401
+msgid &quot;Stopped querying index labels&quot;
+msgstr &quot;Arrete la recherche d'etiquettes&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:482
+msgid &quot;Stopped retrieval of&quot;
+msgstr &quot;Arrete le telechargement de&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:518
+msgid &quot;Couldn't obtain downloader for protocol&quot;
+msgstr &quot;N'a pas pu obtenir un brouteur pour =&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:532 UI/GTK2/src/WorkerThreads.cpp:646
+msgid &quot;Couldn't retrieve&quot;
+msgstr &quot;N'a pas pu telecharger&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:617
+msgid &quot;Stopped indexing&quot;
+msgstr &quot;Arrete l'indexation&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:671
+msgid &quot;Cannot index document type&quot;
+msgstr &quot;Impossible d'indexer de type de documents&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:675
+msgid &quot;at&quot;
+msgstr &quot;a&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:693
+msgid &quot;Couln't tokenize&quot;
+msgstr &quot;N'a pas pu tokenise&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:714
+msgid &quot;Robots META tag forbids indexing&quot;
+msgstr &quot;Le META tag Robots empeche d'indexer&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:760
+msgid &quot;Couldn't index&quot;
+msgstr &quot;N'a pas pu indexer&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:825
+msgid &quot;Stopped unindexing document(s)&quot;
+msgstr &quot;Arrete d'indexer les document(s)&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:846
+msgid &quot;Couldn't unindex document(s)&quot;
+msgstr &quot;N'a pas pu desindexer le(s) document(s)&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:945
+msgid &quot;Stopped document update for &quot;
+msgstr &quot;Arrete la mise a jour pour &quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:982
+msgid &quot;Couldn't update document&quot;
+msgstr &quot;N'a pas pu mettre a jour le document&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:1022
+msgid &quot;Stopped listening on&quot;
+msgstr &quot;Arrete l'ecoute sur&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:1114
+msgid &quot;Couldn't read FIFO at&quot;
+msgstr &quot;N'a pas pu lire la FIFO a&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:1154
+msgid &quot;Stopped monitoring&quot;
+msgstr &quot;Arrete la surveillance&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:1172
+msgid &quot;No monitoring handler&quot;
+msgstr &quot;Pas de moniteur&quot;
+
+#: UI/GTK2/src/WorkerThreads.cpp:1206
+msgid &quot;Couldn't open FAM connection&quot;
+msgstr &quot;N'a pas pu ouvrir la connection FAM&quot;

Added: trunk/textcat_conf.txt
===================================================================
--- trunk/textcat_conf.txt	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/textcat_conf.txt	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,18 @@
+#
+# libtextcat 2.2 config file
+# The following languages are supported by Xapian::Stem
+#
+/usr/share/libtextcat/LM/english.lm                     english
+/usr/share/libtextcat/LM/spanish.lm                     spanish
+/usr/share/libtextcat/LM/french.lm                      french
+/usr/share/libtextcat/LM/german.lm                      german
+/usr/share/libtextcat/LM/danish.lm			danish
+/usr/share/libtextcat/LM/dutch.lm			dutch
+/usr/share/libtextcat/LM/finnish.lm			finnish
+/usr/share/libtextcat/LM/italian.lm			italian
+/usr/share/libtextcat/LM/norwegian.lm			norwegian
+/usr/share/libtextcat/LM/portuguese.lm			portuguese
+/usr/share/libtextcat/LM/russian-iso8859_5.lm		russian-iso8859_5
+/usr/share/libtextcat/LM/russian-koi8_r.lm		russian-koi8_r
+/usr/share/libtextcat/LM/russian-windows1251.lm		russian-windows1251
+/usr/share/libtextcat/LM/swedish.lm			swedish

Added: trunk/variables.mk
===================================================================
--- trunk/variables.mk	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/variables.mk	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,113 @@
+CXX := @g++
+LINK := @libtool --mode=link g++
+AR := @ar
+WSDLC := @${GSOAP_HOME}/wsdl2h
+SOAPC := @${GSOAP_HOME}/soapcpp2 -I${GSOAP_HOME}
+
+HW_NAME := $(shell uname -i)
+OBJ_DIR := obj-${HW_NAME}
+LIB_DIR := ${ROOT_DIR}/lib-${HW_NAME}
+BIN_DIR := ${ROOT_DIR}/bin-${HW_NAME}
+
+# Libraries
+
+UTILS_LIB := ${LIB_DIR}/libutils.a
+TOKENIZE_LIB := ${LIB_DIR}/libtokenize.a
+SQL_LIB := ${LIB_DIR}/libsql.a
+DL_LIB := ${LIB_DIR}/libcollect.a
+GAPI_LIB := ${LIB_DIR}/libgoogleapi.a
+OSAPI_LIB := ${LIB_DIR}/libosapi.a
+SE_LIB := ${LIB_DIR}/libsearch.a
+SE_LIBS := ${SE_LIB}
+SOAPENV_LIB := ${LIB_DIR}/libsoapenv.a
+IDX_LIB := ${LIB_DIR}/libindex.a
+HTML_LIB := ${LIB_DIR}/libhtml.a
+
+# Flags
+
+PROJECT_CXXFLAGS := -I${ROOT_DIR}/Utils -I${ROOT_DIR}/Tokenize -I${ROOT_DIR}/SQL \
+	-I${ROOT_DIR}/Collect -I${ROOT_DIR}/Search -I${ROOT_DIR}/Index \
+	-I${ROOT_DIR}/UI/RenderHTML
+
+# SOAP
+NEEDS_SOAP := no
+# Google SOAP API is optional
+ifeq ($(HAS_GOOGLEAPI),yes)
+GOOGLEAPI_CXXFLAGS := -I${GSOAP_HOME} -I${ROOT_DIR}/Search/Google -DHAS_GOOGLEAPI
+SE_LIBS += ${GAPI_LIB}
+NEEDS_SOAP := yes
+else
+GOOGLEAPI_CXXFLAGS :=
+endif
+# ObjectsSearch SOAP API is also optional
+ifeq ($(HAS_OSAPI),yes)
+OSAPI_CXXFLAGS := -I${GSOAP_HOME} -I${ROOT_DIR}/Search/ObjectsSearch -DHAS_OSAPI
+SE_LIBS += ${OSAPI_LIB}
+NEEDS_SOAP := yes
+else
+OSAPI_CXXFLAGS :=
+endif
+ifeq ($(NEEDS_SOAP),yes)
+SE_LIBS += ${SOAPENV_LIB}
+endif
+
+# NEON
+NEON_CXXFLAGS = $(shell neon-config --cflags)
+NEON_LIBS = $(shell neon-config --libs)
+# OTS
+OTS_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags libots-1)
+OTS_LIBS = $(shell /usr/bin/pkg-config --libs libots-1)
+# GMime
+GMIME_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags gmime-2.0)
+GMIME_LIBS = $(shell /usr/bin/pkg-config --libs gmime-2.0)
+# Libtextcat
+TEXTCAT_CXXFLAGS =
+TEXTCAT_LIBS = -ltextcat
+# Xapian
+XAPIAN_CXXFLAGS = $(shell xapian-config --cxxflags)
+XAPIAN_LIBS = $(shell xapian-config --libs)
+# SQLite
+SQLITE_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags sqlite3)
+SQLITE_LIBS = $(shell /usr/bin/pkg-config --libs sqlite3)
+# LibXML 2.0
+LIBXML_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags libxml++-2.6)
+LIBXML_LIBS = $(shell /usr/bin/pkg-config --libs libxml++-2.6)
+# Mozilla
+MOZILLA_LIB_DIR = $(shell dirname `find /usr/lib*/mozilla* -name libgtkembedmoz.so | head -1`)
+ifeq ($(MOZILLA_LIB_DIR),)
+MOZILLA_LIB_DIR = /usr/lib/mozilla
+endif
+MOZILLA_INC_DIR = $(shell dirname `find /usr/include/mozilla* -name mozilla-config.h | head -1`)
+ifeq ($(MOZILLA_INC_DIR),)
+MOZILLA_INC_DIR = /usr/include/mozilla
+endif
+MOZILLA_XPCOM_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags mozilla-xpcom)
+MOZILLA_XPCOM_LIBS = -Xlinker -rpath -Xlinker ${MOZILLA_LIB_DIR} $(shell /usr/bin/pkg-config --libs mozilla-xpcom)
+GTKMOZ_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags mozilla-gtkmozembed gtk+-2.0)
+GTKMOZ_LIBS = -Xlinker -rpath -Xlinker ${MOZILLA_LIB_DIR} $(shell /usr/bin/pkg-config --libs mozilla-gtkmozembed gtk+-2.0)
+# GTKmm 2.0
+GTKMM_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags gtkmm-2.4)
+GTKMM_LIBS = $(shell /usr/bin/pkg-config --libs gtkmm-2.4)
+
+CXXFLAGS = -DENABLE_NLS ${PROJECT_CXXFLAGS} ${GOOGLEAPI_CXXFLAGS} ${OSAPI_CXXFLAGS} \
+	${NEON_CXXFLAGS} ${OTS_CXXFLAGS} ${GMIME_CXXFLAGS} ${TEXTCAT_CXXFLAGS} \
+	${LIBXML_CXXFLAGS} ${XAPIAN_CXXFLAGS} ${SQLITE_CXXFLAGS}
+ifeq ($(DEBUG),yes)
+CXXFLAGS += -g -DDEBUG
+endif
+LIBS := -lmagic -lpthread -lcrypt ${NEON_LIBS} ${OTS_LIBS} ${GMIME_LIBS} ${TEXTCAT_LIBS} \
+	${LIBXML_LIBS} ${XAPIAN_LIBS} ${SQLITE_LIBS} ${MOZILLA_XPCOM_LIBS}
+
+# Common targets
+
+all : targets
+
+dirs :
+	@mkdir -p ${OBJ_DIR} ${LIB_DIR} ${BIN_DIR}
+
+${OBJ_DIR}/%.o : %.cpp
+	${CXX} -c $&lt; -o $@ ${CXXFLAGS}
+
+${OBJ_DIR}/%.o : %.cc
+	${CXX} -c $&lt; -o $@ ${CXXFLAGS}
+


Property changes on: trunk/variables.mk
___________________________________________________________________
Name: svn:executable
   + 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000001.html">[Pinot-svn] r2 - /
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#0">[ date ]</a>
              <a href="thread.html#0">[ thread ]</a>
              <a href="subject.html#0">[ subject ]</a>
              <a href="author.html#0">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/pinot-svn">More information about the Pinot-svn
mailing list</a><br>
</body></html>
