<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Pinot-svn] r28 - in trunk/UI/GTK2: . src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/pinot-svn/2005-December/index.html" >
   <LINK REL="made" HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r28%20-%20in%20trunk/UI/GTK2%3A%20.%20src&In-Reply-To=%3C200512290900.jBT90wrq032068%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000026.html">
   <LINK REL="Next"  HREF="000028.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Pinot-svn] r28 - in trunk/UI/GTK2: . src</H1>
    <B>fabricecolin at BerliOS</B> 
    <A HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r28%20-%20in%20trunk/UI/GTK2%3A%20.%20src&In-Reply-To=%3C200512290900.jBT90wrq032068%40sheep.berlios.de%3E"
       TITLE="[Pinot-svn] r28 - in trunk/UI/GTK2: . src">fabricecolin at berlios.de
       </A><BR>
    <I>Thu Dec 29 10:00:58 CET 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000026.html">[Pinot-svn] r27 - tags
</A></li>
        <LI>Next message: <A HREF="000028.html">[Pinot-svn] r29 - in trunk/UI: GTK2 GTK2/src RenderHTML
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27">[ date ]</a>
              <a href="thread.html#27">[ thread ]</a>
              <a href="subject.html#27">[ subject ]</a>
              <a href="author.html#27">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fabricecolin
Date: 2005-12-29 10:00:55 +0100 (Thu, 29 Dec 2005)
New Revision: 28

Added:
   trunk/UI/GTK2/src/IndexPage.cpp
   trunk/UI/GTK2/src/IndexPage.h
   trunk/UI/GTK2/src/NotebookTabBox.cpp
   trunk/UI/GTK2/src/NotebookTabBox.h
Modified:
   trunk/UI/GTK2/metase-gtk2.glade
   trunk/UI/GTK2/src/IndexTree.cpp
   trunk/UI/GTK2/src/IndexTree.h
   trunk/UI/GTK2/src/Makefile
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/PinotUtils.cpp
   trunk/UI/GTK2/src/PinotUtils.h
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/mainWindow.hh
   trunk/UI/GTK2/src/mainWindow_glade.cc
   trunk/UI/GTK2/src/mainWindow_glade.hh
Log:
First stab at getting rid of 3 tabs limitation.


Modified: trunk/UI/GTK2/metase-gtk2.glade
===================================================================
--- trunk/UI/GTK2/metase-gtk2.glade	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/metase-gtk2.glade	2005-12-29 09:00:55 UTC (rev 28)
@@ -146,7 +146,7 @@
 		      &lt;signal name=&quot;activate&quot; handler=&quot;on_clearresults_activate&quot; last_modification_time=&quot;Wed, 03 Mar 2004 19:51:48 GMT&quot;/&gt;
 
 		      &lt;child internal-child=&quot;image&quot;&gt;
-			&lt;widget class=&quot;GtkImage&quot; id=&quot;image514&quot;&gt;
+			&lt;widget class=&quot;GtkImage&quot; id=&quot;image538&quot;&gt;
 			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
 			  &lt;property name=&quot;stock&quot;&gt;gtk-clear&lt;/property&gt;
 			  &lt;property name=&quot;icon_size&quot;&gt;1&lt;/property&gt;
@@ -256,10 +256,10 @@
 		&lt;widget class=&quot;GtkMenu&quot; id=&quot;indexMenuitem_menu&quot;&gt;
 
 		  &lt;child&gt;
-		    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;showlabels1&quot;&gt;
+		    &lt;widget class=&quot;GtkMenuItem&quot; id=&quot;list1&quot;&gt;
 		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
 		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Show Label&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;List Contents Of&lt;/property&gt;
 		      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
 		    &lt;/widget&gt;
 		  &lt;/child&gt;
@@ -273,7 +273,7 @@
 		      &lt;signal name=&quot;activate&quot; handler=&quot;on_import_activate&quot; last_modification_time=&quot;Tue, 02 Mar 2004 22:13:44 GMT&quot;/&gt;
 
 		      &lt;child internal-child=&quot;image&quot;&gt;
-			&lt;widget class=&quot;GtkImage&quot; id=&quot;image515&quot;&gt;
+			&lt;widget class=&quot;GtkImage&quot; id=&quot;image539&quot;&gt;
 			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
 			  &lt;property name=&quot;stock&quot;&gt;gtk-open&lt;/property&gt;
 			  &lt;property name=&quot;icon_size&quot;&gt;1&lt;/property&gt;
@@ -311,7 +311,7 @@
 		      &lt;signal name=&quot;activate&quot; handler=&quot;on_refreshindex_activate&quot; last_modification_time=&quot;Fri, 20 Feb 2004 18:57:09 GMT&quot;/&gt;
 
 		      &lt;child internal-child=&quot;image&quot;&gt;
-			&lt;widget class=&quot;GtkImage&quot; id=&quot;image516&quot;&gt;
+			&lt;widget class=&quot;GtkImage&quot; id=&quot;image540&quot;&gt;
 			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
 			  &lt;property name=&quot;stock&quot;&gt;gtk-refresh&lt;/property&gt;
 			  &lt;property name=&quot;icon_size&quot;&gt;1&lt;/property&gt;
@@ -333,7 +333,7 @@
 		      &lt;signal name=&quot;activate&quot; handler=&quot;on_unindex_activate&quot; last_modification_time=&quot;Thu, 28 Jul 2005 12:42:23 GMT&quot;/&gt;
 
 		      &lt;child internal-child=&quot;image&quot;&gt;
-			&lt;widget class=&quot;GtkImage&quot; id=&quot;image517&quot;&gt;
+			&lt;widget class=&quot;GtkImage&quot; id=&quot;image541&quot;&gt;
 			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
 			  &lt;property name=&quot;stock&quot;&gt;gtk-delete&lt;/property&gt;
 			  &lt;property name=&quot;icon_size&quot;&gt;1&lt;/property&gt;
@@ -355,7 +355,7 @@
 		      &lt;signal name=&quot;activate&quot; handler=&quot;on_showfromindex_activate&quot; last_modification_time=&quot;Sun, 06 Nov 2005 08:43:05 GMT&quot;/&gt;
 
 		      &lt;child internal-child=&quot;image&quot;&gt;
-			&lt;widget class=&quot;GtkImage&quot; id=&quot;image518&quot;&gt;
+			&lt;widget class=&quot;GtkImage&quot; id=&quot;image542&quot;&gt;
 			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
 			  &lt;property name=&quot;stock&quot;&gt;gtk-properties&lt;/property&gt;
 			  &lt;property name=&quot;icon_size&quot;&gt;1&lt;/property&gt;
@@ -826,6 +826,7 @@
 		  &lt;property name=&quot;tab_pos&quot;&gt;GTK_POS_TOP&lt;/property&gt;
 		  &lt;property name=&quot;scrollable&quot;&gt;False&lt;/property&gt;
 		  &lt;property name=&quot;enable_popup&quot;&gt;False&lt;/property&gt;
+		  &lt;signal name=&quot;switch_page&quot; handler=&quot;on_mainNotebook_switch_page&quot; last_modification_time=&quot;Wed, 28 Dec 2005 16:33:00 GMT&quot;/&gt;
 
 		  &lt;child&gt;
 		    &lt;widget class=&quot;GtkVBox&quot; id=&quot;resultsVbox&quot;&gt;
@@ -872,240 +873,6 @@
 		  &lt;/child&gt;
 
 		  &lt;child&gt;
-		    &lt;widget class=&quot;GtkVBox&quot; id=&quot;indexVbox&quot;&gt;
-		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
-		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-		      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
-		      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
-
-		      &lt;child&gt;
-			&lt;widget class=&quot;GtkHBox&quot; id=&quot;indexButtonsHbox&quot;&gt;
-			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-			  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
-			  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
-
-			  &lt;child&gt;
-			    &lt;widget class=&quot;GtkComboBox&quot; id=&quot;indexCombobox&quot;&gt;
-			      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
-			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-			      &lt;property name=&quot;items&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
-			      &lt;property name=&quot;add_tearoffs&quot;&gt;False&lt;/property&gt;
-			      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
-			      &lt;signal name=&quot;changed&quot; handler=&quot;on_indexCombobox_changed&quot; last_modification_time=&quot;Mon, 18 Jul 2005 12:49:12 GMT&quot;/&gt;
-			    &lt;/widget&gt;
-			    &lt;packing&gt;
-			      &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
-			      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
-			      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
-			    &lt;/packing&gt;
-			  &lt;/child&gt;
-
-			  &lt;child&gt;
-			    &lt;widget class=&quot;GtkHButtonBox&quot; id=&quot;indexHbuttonbox&quot;&gt;
-			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-			      &lt;property name=&quot;layout_style&quot;&gt;GTK_BUTTONBOX_SPREAD&lt;/property&gt;
-			      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
-
-			      &lt;child&gt;
-				&lt;widget class=&quot;GtkButton&quot; id=&quot;indexBackButton&quot;&gt;
-				  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
-				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-				  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
-				  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
-				  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
-				  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
-				  &lt;signal name=&quot;clicked&quot; handler=&quot;on_indexBackButton_clicked&quot; last_modification_time=&quot;Tue, 05 Jul 2005 13:26:43 GMT&quot;/&gt;
-
-				  &lt;child&gt;
-				    &lt;widget class=&quot;GtkAlignment&quot; id=&quot;alignment31&quot;&gt;
-				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
-				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
-				      &lt;property name=&quot;xscale&quot;&gt;0&lt;/property&gt;
-				      &lt;property name=&quot;yscale&quot;&gt;0&lt;/property&gt;
-				      &lt;property name=&quot;top_padding&quot;&gt;0&lt;/property&gt;
-				      &lt;property name=&quot;bottom_padding&quot;&gt;0&lt;/property&gt;
-				      &lt;property name=&quot;left_padding&quot;&gt;0&lt;/property&gt;
-				      &lt;property name=&quot;right_padding&quot;&gt;0&lt;/property&gt;
-
-				      &lt;child&gt;
-					&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox45&quot;&gt;
-					  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-					  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
-					  &lt;property name=&quot;spacing&quot;&gt;2&lt;/property&gt;
-
-					  &lt;child&gt;
-					    &lt;widget class=&quot;GtkImage&quot; id=&quot;image521&quot;&gt;
-					      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-					      &lt;property name=&quot;stock&quot;&gt;gtk-media-rewind&lt;/property&gt;
-					      &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
-					      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
-					      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
-					      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
-					      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
-					    &lt;/widget&gt;
-					    &lt;packing&gt;
-					      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-					      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
-					      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
-					    &lt;/packing&gt;
-					  &lt;/child&gt;
-
-					  &lt;child&gt;
-					    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label52&quot;&gt;
-					      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-					      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Show Previous&lt;/property&gt;
-					      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
-					      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
-					      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
-					      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
-					      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
-					      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
-					      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
-					      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
-					      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
-					      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
-					      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
-					      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
-					      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
-					    &lt;/widget&gt;
-					    &lt;packing&gt;
-					      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-					      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
-					      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
-					    &lt;/packing&gt;
-					  &lt;/child&gt;
-					&lt;/widget&gt;
-				      &lt;/child&gt;
-				    &lt;/widget&gt;
-				  &lt;/child&gt;
-				&lt;/widget&gt;
-			      &lt;/child&gt;
-
-			      &lt;child&gt;
-				&lt;widget class=&quot;GtkButton&quot; id=&quot;indexForwardButton&quot;&gt;
-				  &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
-				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-				  &lt;property name=&quot;can_default&quot;&gt;True&lt;/property&gt;
-				  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
-				  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
-				  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
-				  &lt;signal name=&quot;clicked&quot; handler=&quot;on_indexForwardButton_clicked&quot; last_modification_time=&quot;Tue, 05 Jul 2005 13:26:48 GMT&quot;/&gt;
-
-				  &lt;child&gt;
-				    &lt;widget class=&quot;GtkAlignment&quot; id=&quot;alignment32&quot;&gt;
-				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
-				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
-				      &lt;property name=&quot;xscale&quot;&gt;0&lt;/property&gt;
-				      &lt;property name=&quot;yscale&quot;&gt;0&lt;/property&gt;
-				      &lt;property name=&quot;top_padding&quot;&gt;0&lt;/property&gt;
-				      &lt;property name=&quot;bottom_padding&quot;&gt;0&lt;/property&gt;
-				      &lt;property name=&quot;left_padding&quot;&gt;0&lt;/property&gt;
-				      &lt;property name=&quot;right_padding&quot;&gt;0&lt;/property&gt;
-
-				      &lt;child&gt;
-					&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox46&quot;&gt;
-					  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-					  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
-					  &lt;property name=&quot;spacing&quot;&gt;2&lt;/property&gt;
-
-					  &lt;child&gt;
-					    &lt;widget class=&quot;GtkImage&quot; id=&quot;image522&quot;&gt;
-					      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-					      &lt;property name=&quot;stock&quot;&gt;gtk-media-forward&lt;/property&gt;
-					      &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
-					      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
-					      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
-					      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
-					      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
-					    &lt;/widget&gt;
-					    &lt;packing&gt;
-					      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-					      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
-					      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
-					    &lt;/packing&gt;
-					  &lt;/child&gt;
-
-					  &lt;child&gt;
-					    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label53&quot;&gt;
-					      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-					      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Show Next&lt;/property&gt;
-					      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
-					      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
-					      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
-					      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
-					      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
-					      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
-					      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
-					      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
-					      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
-					      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
-					      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
-					      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
-					      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
-					    &lt;/widget&gt;
-					    &lt;packing&gt;
-					      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-					      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
-					      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
-					    &lt;/packing&gt;
-					  &lt;/child&gt;
-					&lt;/widget&gt;
-				      &lt;/child&gt;
-				    &lt;/widget&gt;
-				  &lt;/child&gt;
-				&lt;/widget&gt;
-			      &lt;/child&gt;
-			    &lt;/widget&gt;
-			    &lt;packing&gt;
-			      &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
-			      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
-			      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
-			    &lt;/packing&gt;
-			  &lt;/child&gt;
-			&lt;/widget&gt;
-			&lt;packing&gt;
-			  &lt;property name=&quot;padding&quot;&gt;4&lt;/property&gt;
-			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
-			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
-			&lt;/packing&gt;
-		      &lt;/child&gt;
-
-		      &lt;child&gt;
-			&lt;placeholder/&gt;
-		      &lt;/child&gt;
-		    &lt;/widget&gt;
-		    &lt;packing&gt;
-		      &lt;property name=&quot;tab_expand&quot;&gt;False&lt;/property&gt;
-		      &lt;property name=&quot;tab_fill&quot;&gt;True&lt;/property&gt;
-		    &lt;/packing&gt;
-		  &lt;/child&gt;
-
-		  &lt;child&gt;
-		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;indexLabel&quot;&gt;
-		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
-		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Index&lt;/property&gt;
-		      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
-		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
-		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
-		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
-		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
-		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
-		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
-		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
-		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
-		      &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
-		      &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
-		      &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
-		      &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
-		    &lt;/widget&gt;
-		    &lt;packing&gt;
-		      &lt;property name=&quot;type&quot;&gt;tab&lt;/property&gt;
-		    &lt;/packing&gt;
-		  &lt;/child&gt;
-
-		  &lt;child&gt;
 		    &lt;widget class=&quot;GtkVBox&quot; id=&quot;viewVbox&quot;&gt;
 		      &lt;property agent=&quot;glademm&quot; name=&quot;cxx_visibility&quot;&gt;protected&lt;/property&gt;
 		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;

Added: trunk/UI/GTK2/src/IndexPage.cpp
===================================================================
--- trunk/UI/GTK2/src/IndexPage.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/IndexPage.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -0,0 +1,307 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+#include &lt;gtkmm/alignment.h&gt;
+#include &lt;gtkmm/buttonbox.h&gt;
+#include &lt;gtkmm/stock.h&gt;
+#include &lt;gtkmm/textbuffer.h&gt;
+
+#include &quot;HtmlTokenizer.h&quot;
+#include &quot;Url.h&quot;
+#include &quot;QueryHistory.h&quot;
+#include &quot;ViewHistory.h&quot;
+#include &quot;config.h&quot;
+#include &quot;NLS.h&quot;
+#include &quot;PinotSettings.h&quot;
+#include &quot;PinotUtils.h&quot;
+#include &quot;IndexPage.h&quot;
+
+using namespace std;
+using namespace SigC;
+using namespace Glib;
+using namespace Gtk;
+
+IndexPage::IndexPage(const ustring &amp;indexName, IndexTree *pTree,
+	PinotSettings &amp;settings) :
+	VBox(),
+	m_indexName(indexName),
+	m_pTree(pTree),
+	m_settings(settings),
+	m_pLabelCombobox(NULL),
+	m_pBackButton(NULL),
+	m_pForwardButton(NULL),
+	m_docsCount(0),
+	m_firstDoc(0)
+{
+	m_pLabelCombobox = manage(new ComboBox());
+
+	Image *image521 = manage(new Image(StockID(&quot;gtk-media-rewind&quot;), IconSize(4)));
+	Label *label52 = manage(new Label(_(&quot;Show Previous&quot;)));
+	HBox *hbox45 = manage(new HBox(false, 2));
+	Alignment *alignment31 = manage(new Alignment(0.5, 0.5, 0, 0));
+	m_pBackButton = manage(new Button());
+
+	Image *image522 = manage(new Image(StockID(&quot;gtk-media-forward&quot;), IconSize(4)));
+	Label *label53 = manage(new Label(_(&quot;Show Next&quot;)));
+	HBox *hbox46 = manage(new HBox(false, 2));
+	Alignment *alignment32 = manage(new Alignment(0.5, 0.5, 0, 0));
+	m_pForwardButton = manage(new Button());
+
+	HButtonBox *indexHbuttonbox = manage(new HButtonBox(BUTTONBOX_START, 0));
+	HBox *indexButtonsHbox = manage(new HBox(false, 0));
+
+	// Buttons
+	image521-&gt;set_alignment(0.5,0.5);
+	image521-&gt;set_padding(0,0);
+	label52-&gt;set_alignment(0.5,0.5);
+	label52-&gt;set_padding(0,0);
+	label52-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+	label52-&gt;set_line_wrap(false);
+	label52-&gt;set_use_markup(false);
+	label52-&gt;set_selectable(false);
+	hbox45-&gt;pack_start(*image521, Gtk::PACK_SHRINK, 0);
+	hbox45-&gt;pack_start(*label52, Gtk::PACK_SHRINK, 0);
+	alignment31-&gt;add(*hbox45);
+	m_pBackButton-&gt;set_flags(Gtk::CAN_FOCUS);
+	m_pBackButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+	m_pBackButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+	m_pBackButton-&gt;add(*alignment31);
+	image522-&gt;set_alignment(0.5,0.5);
+	image522-&gt;set_padding(0,0);
+	label53-&gt;set_alignment(0.5,0.5);
+	label53-&gt;set_padding(0,0);
+	label53-&gt;set_justify(Gtk::JUSTIFY_LEFT);
+	label53-&gt;set_line_wrap(false);
+	label53-&gt;set_use_markup(false);
+	label53-&gt;set_selectable(false);
+	hbox46-&gt;pack_start(*image522, Gtk::PACK_SHRINK, 0);
+	hbox46-&gt;pack_start(*label53, Gtk::PACK_SHRINK, 0);
+	alignment32-&gt;add(*hbox46);
+	m_pForwardButton-&gt;set_flags(Gtk::CAN_FOCUS);
+	m_pForwardButton-&gt;set_flags(Gtk::CAN_DEFAULT);
+	m_pForwardButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
+	m_pForwardButton-&gt;add(*alignment32);
+
+	// Position everything
+	indexHbuttonbox-&gt;pack_start(*m_pBackButton);
+	indexHbuttonbox-&gt;pack_start(*m_pForwardButton);
+	indexButtonsHbox-&gt;pack_start(*m_pLabelCombobox, Gtk::PACK_SHRINK, 4);
+	indexButtonsHbox-&gt;pack_start(*indexHbuttonbox, Gtk::PACK_EXPAND_WIDGET, 4);
+	pack_start(*indexButtonsHbox, Gtk::PACK_SHRINK, 4);
+	if (pTree != NULL)
+	{
+		pack_start(*pTree-&gt;getScrolledWindow());
+	}
+
+	// Associate the columns model to the label combo
+	m_refLabelNameTree = ListStore::create(m_labelNameColumns);
+	m_pLabelCombobox-&gt;set_model(m_refLabelNameTree);
+	m_pLabelCombobox-&gt;pack_start(m_labelNameColumns.m_name);
+	// Populate
+	populateLabelCombobox();
+
+	// Connect the signals
+	m_pLabelCombobox-&gt;signal_changed().connect(
+		SigC::slot(*this, &amp;IndexPage::onLabelChanged));
+	m_pBackButton-&gt;signal_clicked().connect(
+		SigC::slot(*this, &amp;IndexPage::onBackClicked));
+	m_pForwardButton-&gt;signal_clicked().connect(
+		SigC::slot(*this, &amp;IndexPage::onForwardClicked));
+
+	// Disable the buttons until something is being shown
+	m_pBackButton-&gt;set_sensitive(false);
+	m_pForwardButton-&gt;set_sensitive(false);
+
+	// Show all
+	m_pLabelCombobox-&gt;show();
+	image521-&gt;show();
+	label52-&gt;show();
+	hbox45-&gt;show();
+	alignment31-&gt;show();
+	m_pBackButton-&gt;show();
+	image522-&gt;show();
+	label53-&gt;show();
+	hbox46-&gt;show();
+	alignment32-&gt;show();
+	m_pForwardButton-&gt;show();
+	indexHbuttonbox-&gt;show();
+	indexButtonsHbox-&gt;show();
+	show();
+}
+
+IndexPage::~IndexPage()
+{
+}
+
+void IndexPage::onLabelChanged(void)
+{
+	TreeModel::iterator labelIter = m_pLabelCombobox-&gt;get_active();
+	if (labelIter)
+	{
+		TreeModel::Row row = *labelIter;
+
+		m_labelName = row[m_labelNameColumns.m_name];
+#ifdef DEBUG
+		cout &lt;&lt; &quot;IndexPage::onLabelChanged: current label now &quot; &lt;&lt; m_labelName &lt;&lt; endl;
+#endif
+		if (m_labelName == _(&quot;None&quot;))
+		{
+			m_labelName.clear();
+		}
+		m_signalLabelChanged(m_indexName, m_labelName);
+	}
+}
+
+void IndexPage::onBackClicked(void)
+{
+	m_signalBackClicked(m_indexName);
+}
+
+void IndexPage::onForwardClicked(void)
+{
+	m_signalForwardClicked(m_indexName);
+}
+
+//
+// Returns the name of the index being listed.
+//
+ustring IndexPage::getIndexName(void) const
+{
+	return m_indexName;
+}
+
+//
+// Returns the name of the current label.
+//
+ustring IndexPage::getLabelName(void) const
+{
+	return m_labelName;
+}
+
+//
+// Returns the page's tree.
+//
+IndexTree *IndexPage::getTree(void) const
+{
+	return m_pTree;
+}
+
+//
+// Populates the labels list.
+//
+void IndexPage::populateLabelCombobox(void)
+{
+	TreeModel::iterator iter;
+	TreeModel::Row row;
+
+	m_refLabelNameTree-&gt;clear();
+
+	iter = m_refLabelNameTree-&gt;append();
+	row = *iter;
+	row[m_labelNameColumns.m_name] = _(&quot;None&quot;);
+
+	for (set&lt;PinotSettings::Label&gt;::const_iterator labelIter = m_settings.m_labels.begin();
+		labelIter != m_settings.m_labels.end(); ++labelIter)
+	{
+		string labelName(labelIter-&gt;m_name);
+
+		iter = m_refLabelNameTree-&gt;append();
+		row = *iter;
+		row[m_labelNameColumns.m_name] = to_utf8(labelName);
+	}
+
+	m_pLabelCombobox-&gt;set_active(0);
+}
+
+//
+// Updates the state of the index buttons.
+//
+void IndexPage::updateButtons(unsigned int maxDocsCount)
+{
+	if (m_firstDoc &gt;= maxDocsCount)
+	{
+		m_pBackButton-&gt;set_sensitive(true);
+	}
+	else
+	{
+		m_pBackButton-&gt;set_sensitive(false);
+	}
+	if (m_docsCount &gt;= m_firstDoc + maxDocsCount)
+	{
+		m_pForwardButton-&gt;set_sensitive(true);
+	}
+	else
+	{
+		m_pForwardButton-&gt;set_sensitive(false);
+	}
+}
+
+//
+// Gets the number of documents.
+//
+unsigned int IndexPage::getDocumentsCount(void) const
+{
+	return m_docsCount;
+}
+
+//
+// Sets the number of documents.
+//
+void IndexPage::setDocumentsCount(unsigned int docsCount)
+{
+	m_docsCount = docsCount;
+}
+
+//
+// Gets the first document.
+//
+unsigned int IndexPage::getFirstDocument(void) const
+{
+	return m_firstDoc;
+}
+
+//
+// Sets the first document.
+//
+void IndexPage::setFirstDocument(unsigned int startDoc)
+{
+	m_firstDoc = startDoc;
+}
+
+//
+// Returns the changed label signal.
+//
+Signal2&lt;void, ustring, ustring&gt;&amp; IndexPage::getLabelChangedSignal(void)
+{
+	return m_signalLabelChanged;
+}
+
+//
+// Returns the back button clicked signal.
+//
+Signal1&lt;void, ustring&gt;&amp; IndexPage::getBackClickedSignal(void)
+{
+	return m_signalBackClicked;
+}
+
+//
+// Returns the forward button clicked signal.
+//
+Signal1&lt;void, ustring&gt;&amp; IndexPage::getForwardClickedSignal(void)
+{
+	return m_signalForwardClicked;
+}

Added: trunk/UI/GTK2/src/IndexPage.h
===================================================================
--- trunk/UI/GTK2/src/IndexPage.h	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/IndexPage.h	2005-12-29 09:00:55 UTC (rev 28)
@@ -0,0 +1,113 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _INDEXPAGE_HH
+#define _INDEXPAGE_HH
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;sigc++/slot.h&gt;
+#include &lt;glibmm/refptr.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/menu.h&gt;
+#include &lt;gdkmm/pixbuf.h&gt;
+#include &lt;gtkmm/combobox.h&gt;
+#include &lt;gtkmm/button.h&gt;
+#include &lt;gtkmm/scrolledwindow.h&gt;
+#include &lt;gtkmm/textview.h&gt;
+#include &lt;gtkmm/liststore.h&gt;
+#include &lt;gtkmm/treeview.h&gt;
+#include &lt;gtkmm/treeselection.h&gt;
+
+#include &quot;QueryProperties.h&quot;
+#include &quot;IndexedDocument.h&quot;
+#include &quot;IndexTree.h&quot;
+#include &quot;ModelColumns.h&quot;
+#include &quot;PinotSettings.h&quot;
+
+class IndexPage : public Gtk::VBox
+{
+	public:
+		IndexPage(const Glib::ustring &amp;indexName, IndexTree *pTree,
+			PinotSettings &amp;settings);
+		virtual ~IndexPage();
+
+		/// Returns the name of the index being listed.
+		Glib::ustring getIndexName(void) const;
+
+		/// Returns the name of the current label.
+		Glib::ustring getLabelName(void) const;
+
+		/// Returns the page's tree.
+		IndexTree *getTree(void) const;
+
+		/// Populates the labels list.
+		void populateLabelCombobox(void);
+
+		/// Updates the state of the index buttons.
+		void updateButtons(unsigned int maxDocsCount);
+
+		/// Gets the number of documents.
+		unsigned int getDocumentsCount(void) const;
+
+		/// Sets the number of documents.
+		void setDocumentsCount(unsigned int docsCount);
+
+		/// Gets the first document.
+		unsigned int getFirstDocument(void) const;
+
+		/// Sets the first document.
+		void setFirstDocument(unsigned int startDoc);
+
+		/// Returns the changed label signal.
+		SigC::Signal2&lt;void, Glib::ustring, Glib::ustring&gt;&amp; getLabelChangedSignal(void);
+
+		/// Returns the back button clicked signal.
+		SigC::Signal1&lt;void, Glib::ustring&gt;&amp; getBackClickedSignal(void);
+
+		/// Returns the forward button clicked signal.
+		SigC::Signal1&lt;void, Glib::ustring&gt;&amp; getForwardClickedSignal(void);
+
+	protected:
+		Glib::ustring m_indexName;
+		Glib::ustring m_labelName;
+		IndexTree *m_pTree;
+		PinotSettings &amp;m_settings;
+		ComboModelColumns m_labelNameColumns;
+		Glib::RefPtr&lt;Gtk::ListStore&gt; m_refLabelNameTree;
+		Gtk::ComboBox *m_pLabelCombobox;
+		Gtk::Button *m_pBackButton;
+		Gtk::Button *m_pForwardButton;
+		unsigned int m_docsCount;
+		unsigned int m_firstDoc;
+		SigC::Signal2&lt;void, Glib::ustring, Glib::ustring&gt; m_signalLabelChanged;
+		SigC::Signal1&lt;void, Glib::ustring&gt; m_signalBackClicked;
+		SigC::Signal1&lt;void, Glib::ustring&gt; m_signalForwardClicked;
+
+		void onLabelChanged(void);
+
+		void onBackClicked(void);
+
+		void onForwardClicked(void);
+
+	private:
+		IndexPage(const IndexPage &amp;other);
+		IndexPage &amp;operator=(const IndexPage &amp;other);
+
+};
+
+#endif // _INDEXPAGE_HH

Modified: trunk/UI/GTK2/src/IndexTree.cpp
===================================================================
--- trunk/UI/GTK2/src/IndexTree.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/IndexTree.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -34,12 +34,13 @@
 using namespace Gdk;
 using namespace Gtk;
 
-IndexTree::IndexTree(VBox *indexVbox, Menu *pPopupMenu, PinotSettings &amp;settings) :
+IndexTree::IndexTree(const ustring &amp;indexName, Menu *pPopupMenu, PinotSettings &amp;settings) :
 	TreeView(),
+	m_indexName(indexName),
 	m_pPopupMenu(pPopupMenu),
 	m_settings(settings)
 {
-	ScrolledWindow *indexScrolledwindow = manage(new ScrolledWindow());
+	m_pIndexScrolledwindow = manage(new ScrolledWindow());
 
 	// This is the actual index tree
 	set_events(Gdk::BUTTON_PRESS_MASK);
@@ -48,16 +49,13 @@
 	set_rules_hint(true);
 	set_reorderable(false);
 	set_enable_search(true);
-	indexScrolledwindow-&gt;set_flags(Gtk::CAN_FOCUS);
-	indexScrolledwindow-&gt;set_border_width(4);
-	indexScrolledwindow-&gt;set_shadow_type(Gtk::SHADOW_NONE);
-	indexScrolledwindow-&gt;set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_ALWAYS);
-	indexScrolledwindow-&gt;property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
-	indexScrolledwindow-&gt;add(*this);
+	m_pIndexScrolledwindow-&gt;set_flags(Gtk::CAN_FOCUS);
+	m_pIndexScrolledwindow-&gt;set_border_width(4);
+	m_pIndexScrolledwindow-&gt;set_shadow_type(Gtk::SHADOW_NONE);
+	m_pIndexScrolledwindow-&gt;set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_ALWAYS);
+	m_pIndexScrolledwindow-&gt;property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+	m_pIndexScrolledwindow-&gt;add(*this);
 
-	// Position the scrolled window
-	indexVbox-&gt;pack_start(*indexScrolledwindow);
-	
 	// Associate the columns model to the index tree
 	m_refStore = ListStore::create(m_indexColumns);
 	set_model(m_refStore);
@@ -81,8 +79,12 @@
 	// Allow multiple selection
 	get_selection()-&gt;set_mode(SELECTION_MULTIPLE);
 
-	// Handle button presses
-	signal_button_press_event().connect_notify(SigC::slot(*this, &amp;IndexTree::onButtonPressEvent));
+	// Connect the signals
+	signal_button_press_event().connect_notify(
+		SigC::slot(*this, &amp;IndexTree::onButtonPressEvent));
+	get_selection()-&gt;signal_changed().connect(
+		SigC::slot(*this, &amp;IndexTree::onSelectionChanged));
+
 	// Enable interactive search
 	set_search_column(m_indexColumns.m_text.index());
 	set_search_equal_func(SigC::slot(*this, &amp;IndexTree::onSearchEqual));
@@ -96,8 +98,8 @@
 	setCurrentLabelColour(0, 0, 0, false);
 
 	// Show all
+	m_pIndexScrolledwindow-&gt;show();
 	show();
-	indexScrolledwindow-&gt;show();
 }
 
 IndexTree::~IndexTree()
@@ -134,17 +136,6 @@
 	}
 }
 
-//
-// Interactive search equal function.
-//
-bool IndexTree::onSearchEqual(const RefPtr&lt;TreeModel&gt;&amp; model, int column,
-	const ustring&amp; key, const TreeModel::iterator&amp; iter)
-{
-}
-
-//
-// Handles button presses.
-//
 void IndexTree::onButtonPressEvent(GdkEventButton *ev)
 {
 	// Check for popup click
@@ -159,30 +150,20 @@
 	// Check for double clicks
 	else if (ev-&gt;type == GDK_2BUTTON_PRESS)
 	{
-		m_signalEdit();
+		m_signalEdit;
 	}
 }
 
-//
-// Handles selection changes.
-//
-bool IndexTree::onSelectionChanged(void)
+void IndexTree::onSelectionChanged(void)
 {
-#ifdef DEBUG
-	cout &lt;&lt; &quot;IndexTree::onSelectionChanged: called&quot; &lt;&lt; endl;
-#endif
-	list&lt;TreeModel::Path&gt; selectedItems = get_selection()-&gt;get_selected_rows();
-	if (selectedItems.empty() == true)
-	{
-		return false;
-	}
+	m_signalSelectionChanged(m_indexName);
+}
 
-	return true;
+bool IndexTree::onSearchEqual(const RefPtr&lt;TreeModel&gt;&amp; model, int column,
+	const ustring&amp; key, const TreeModel::iterator&amp; iter)
+{
 }
 
-//
-// Handles attempts to select rows.
-//
 bool IndexTree::onSelectionSelect(const RefPtr&lt;TreeModel&gt;&amp; model,
 		const TreeModel::Path&amp; path, bool path_currently_selected)
 {
@@ -206,6 +187,14 @@
 }
 
 //
+// Returns the tree's scrolled window.
+//
+ScrolledWindow *IndexTree::getScrolledWindow(void) const
+{
+	return m_pIndexScrolledwindow;
+}
+
+//
 // Appends a new row in the index tree.
 //
 bool IndexTree::appendDocument(const IndexedDocument &amp;docInfo, bool labeled)
@@ -485,6 +474,15 @@
 }
 
 //
+// Refreshes the tree.
+//
+void IndexTree::refresh(void)
+{
+	// FIXME: not sure why, but this helps with refreshing the tree
+	columns_autosize();
+}
+
+//
 // Returns true if the tree is empty.
 //
 bool IndexTree::isEmpty(void)
@@ -532,3 +530,11 @@
 {
 	return m_signalEdit;
 }
+
+//
+// Returns the changed selection signal.
+//
+Signal1&lt;void, ustring&gt;&amp; IndexTree::getSelectionChangedSignal(void)
+{
+	return m_signalSelectionChanged;
+}

Modified: trunk/UI/GTK2/src/IndexTree.h
===================================================================
--- trunk/UI/GTK2/src/IndexTree.h	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/IndexTree.h	2005-12-29 09:00:55 UTC (rev 28)
@@ -22,7 +22,6 @@
 #include &lt;sigc++/slot.h&gt;
 #include &lt;glibmm/refptr.h&gt;
 #include &lt;glibmm/ustring.h&gt;
-#include &lt;gtkmm/box.h&gt;
 #include &lt;gtkmm/menu.h&gt;
 #include &lt;gdkmm/pixbuf.h&gt;
 #include &lt;gtkmm/scrolledwindow.h&gt;
@@ -39,14 +38,12 @@
 class IndexTree : public Gtk::TreeView
 {
 	public:
-		IndexTree(Gtk::VBox *indexVbox, Gtk::Menu *pPopupMenu, PinotSettings &amp;settings);
+		IndexTree(const Glib::ustring &amp;indexName, Gtk::Menu *pPopupMenu,
+			PinotSettings &amp;settings);
 		virtual ~IndexTree();
 
-		/**
-		  * Handles selection changes.
-		  * Returns true if a result is selected.
-		  */
-		bool onSelectionChanged(void);
+		/// Returns the tree's scrolled window.
+		Gtk::ScrolledWindow *getScrolledWindow(void) const;
 
 		/// Adds a set of documents.
 		bool addDocuments(const std::vector&lt;IndexedDocument&gt; &amp;documentsList);
@@ -85,6 +82,9 @@
 		/// Returns the number of rows.
 		unsigned int getRowsCount(void);
 
+		/// Refreshes the tree.
+		void refresh(void);
+
 		/// Returns true if the tree is empty.
 		bool isEmpty(void);
 
@@ -94,10 +94,16 @@
 		/// Returns the document edit signal.
 		SigC::Signal0&lt;void&gt;&amp; getEditDocumentSignal(void);
 
+		/// Returns the changed selection signal.
+		SigC::Signal1&lt;void, Glib::ustring&gt;&amp; getSelectionChangedSignal(void);
+
 	protected:
+		Glib::ustring m_indexName;
+		Gtk::Menu *m_pPopupMenu;
+		Gtk::ScrolledWindow *m_pIndexScrolledwindow;
 		Glib::RefPtr&lt;Gtk::ListStore&gt; m_refStore;
-		Gtk::Menu *m_pPopupMenu;
 		SigC::Signal0&lt;void&gt; m_signalEdit;
+		SigC::Signal1&lt;void, Glib::ustring&gt; m_signalSelectionChanged;
 		PinotSettings &amp;m_settings;
 		IndexModelColumns m_indexColumns;
 		Gdk::Color m_currentLabelColour;
@@ -106,14 +112,13 @@
 
 		void renderLabel(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &amp;iter);
 
-		/// Interactive search equal function.
+		void onButtonPressEvent(GdkEventButton *ev);
+
+		void onSelectionChanged(void);
+
 		bool onSearchEqual(const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model, int column,
 			const Glib::ustring&amp; key, const Gtk::TreeModel::iterator&amp; iter);
 
-		/// Handles button presses.
-		void onButtonPressEvent(GdkEventButton *ev);
-
-		/// Handles attempts to select rows.
 		bool onSelectionSelect(const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,
 			const Gtk::TreeModel::Path&amp; path, bool path_currently_selected);
 

Modified: trunk/UI/GTK2/src/Makefile
===================================================================
--- trunk/UI/GTK2/src/Makefile	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/Makefile	2005-12-29 09:00:55 UTC (rev 28)
@@ -13,10 +13,9 @@
 	propertiesDialog.cc propertiesDialog_glade.cc \
 	queryDialog.cc queryDialog_glade.cc \
 	mainWindow.cc mainWindow_glade.cc
-UI_SRCS = pinot.cpp EnginesTree.cpp IndexTree.cpp \
-	HtmlView.cpp ModelColumns.cpp MonitorHandler.cpp \
-	PinotSettings.cpp PinotUtils.cpp ResultsTree.cpp \
-	WorkerThreads.cpp
+UI_SRCS = pinot.cpp EnginesTree.cpp IndexPage.cpp IndexTree.cpp \
+	HtmlView.cpp ModelColumns.cpp MonitorHandler.cpp NotebookTabBox.cpp \
+	PinotSettings.cpp PinotUtils.cpp ResultsTree.cpp WorkerThreads.cpp
 UI_GTK2_OBJS := $(patsubst %.cc,${OBJ_DIR}/%.o,${UI_GTK2_SRCS})
 UI_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${UI_SRCS})
 UI_GTK2_BIN = ${BIN_DIR}/pinot

Added: trunk/UI/GTK2/src/NotebookTabBox.cpp
===================================================================
--- trunk/UI/GTK2/src/NotebookTabBox.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/NotebookTabBox.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -0,0 +1,130 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;sigc++/slot.h&gt;
+
+#include &quot;NotebookTabBox.h&quot;
+#include &quot;PinotUtils.h&quot;
+
+using namespace SigC;
+using namespace Glib;
+using namespace Gtk;
+
+NotebookTabBox::NotebookTabBox(const Glib::ustring &amp;title, PageType type) :
+	HBox(),
+	m_title(title),
+	m_pageType(type),
+	m_tabLabel(NULL),
+#if _USE_BUTTON_TAB
+	m_tabButton(NULL)
+#else
+	m_tabEventBox(NULL)
+#endif
+{
+	int width, height;
+
+	// Lookup the standard icon size
+	bool gotDimensions = IconSize::lookup(ICON_SIZE_MENU, width, height);
+
+	m_tabLabel = manage(new Label(title));
+	m_tabImage = manage(new Image(StockID(&quot;gtk-close&quot;), IconSize(ICON_SIZE_MENU)));
+#if _USE_BUTTON_TAB
+	m_tabButton = manage(new Button());
+#else
+	m_tabEventBox = manage(new EventBox);
+#endif
+
+	m_tabLabel-&gt;set_alignment(0,0.5);
+	m_tabLabel-&gt;set_padding(0,0);
+	m_tabLabel-&gt;set_justify(JUSTIFY_LEFT);
+	m_tabLabel-&gt;set_line_wrap(false);
+	m_tabLabel-&gt;set_use_markup(false);
+	m_tabLabel-&gt;set_selectable(false);
+	m_tabImage-&gt;set_alignment(0,0);
+	m_tabImage-&gt;set_padding(0,0);
+#if _USE_BUTTON_TAB
+	m_tabButton-&gt;set_flags(CAN_FOCUS);
+	m_tabButton-&gt;set_flags(CAN_DEFAULT);
+	m_tabButton-&gt;add(*m_tabImage);
+	m_tabButton-&gt;set_relief(RELIEF_NONE);
+	m_tabButton-&gt;set_border_width(0);
+	m_tabButton-&gt;set_alignment(0,0);
+	// Resize the button
+	if (gotDimensions == true)
+	{
+		m_tabButton-&gt;set_size_request(width, height);
+		m_tabButton-&gt;check_resize();
+	}
+#else
+	m_tabEventBox-&gt;add(*m_tabImage);
+	m_tabEventBox-&gt;set_events(Gdk::BUTTON_PRESS_MASK);
+#endif
+	pack_start(*m_tabLabel);
+#if _USE_BUTTON_TAB
+	pack_start(*m_tabButton, PACK_SHRINK);
+#else
+	pack_start(*m_tabEventBox, PACK_SHRINK);
+#endif
+	set_spacing(0);
+	set_homogeneous(false);
+	m_tabLabel-&gt;show();
+	m_tabImage-&gt;show();
+#if _USE_BUTTON_TAB
+	m_tabButton-&gt;show();
+#else
+	m_tabEventBox-&gt;show();
+#endif
+	show();
+
+#if _USE_BUTTON_TAB
+	m_tabButton-&gt;signal_clicked().connect(
+		SigC::slot(*this, &amp;NotebookTabBox::onButtonClicked));
+#else
+	m_tabEventBox-&gt;signal_button_press_event().connect(
+		SigC::slot(*this, &amp;NotebookTabBox::onButtonPressEvent));
+#endif
+}
+
+NotebookTabBox::~NotebookTabBox()
+{
+}
+
+#if _USE_BUTTON_TAB
+void NotebookTabBox::onButtonClicked(void)
+#else
+bool NotebookTabBox::onButtonPressEvent(GdkEventButton *ev)
+#endif
+{
+	m_signalClose(m_title, m_pageType);
+
+	return true;
+}
+
+//
+// Returns the page type.
+//
+NotebookTabBox::PageType NotebookTabBox::getPageType(void) const
+{
+	return m_pageType;
+}
+
+//
+// Returns the close signal.
+//
+Signal2&lt;void, ustring, NotebookTabBox::PageType&gt;&amp; NotebookTabBox::getCloseSignal(void)
+{
+	return m_signalClose;
+}

Added: trunk/UI/GTK2/src/NotebookTabBox.h
===================================================================
--- trunk/UI/GTK2/src/NotebookTabBox.h	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/NotebookTabBox.h	2005-12-29 09:00:55 UTC (rev 28)
@@ -0,0 +1,68 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _NOTEBOOKTABBOX_HH
+#define _NOTEBOOKTABBOX_HH
+
+#include &lt;sigc++/signal.h&gt;
+#include &lt;glibmm/ustring.h&gt;
+#include &lt;gtkmm/box.h&gt;
+#include &lt;gtkmm/label.h&gt;
+#include &lt;gtkmm/image.h&gt;
+#if _USE_BUTTON_TAB
+#include &lt;gtkmm/button.h&gt;
+#else
+#include &lt;gtkmm/eventbox.h&gt;
+#endif
+
+/**
+  * Closable notebook tab.
+  */
+class NotebookTabBox : public Gtk::HBox
+{
+	public:
+		typedef enum { RESULTS_PAGE = 0, INDEX_PAGE, VIEW_PAGE } PageType;
+
+		NotebookTabBox(const Glib::ustring &amp;title, PageType type);
+		virtual ~NotebookTabBox();
+
+		/// Returns the page type.
+		PageType getPageType(void) const;
+
+		/// Returns the close signal.
+		SigC::Signal2&lt;void, Glib::ustring, PageType&gt;&amp; getCloseSignal(void);
+
+	protected:
+		Glib::ustring m_title;
+		PageType m_pageType;
+		Gtk::Label *m_tabLabel;
+		Gtk::Image *m_tabImage;
+#if _USE_BUTTON_TAB
+		Gtk::Button *m_tabButton;
+#else
+		Gtk::EventBox *m_tabEventBox;
+#endif
+		SigC::Signal2&lt;void, Glib::ustring, PageType&gt; m_signalClose;
+
+#if _USE_BUTTON_TAB
+		void onButtonClicked(void);
+#else
+		bool onButtonPressEvent(GdkEventButton *ev);
+#endif
+
+};
+
+#endif // _NOTEBOOKTABBOX_HH

Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -253,10 +253,10 @@
 	// FIXME: check the top-level element is okay
 
 	// Go through the subnodes
-	Node::NodeList childNodes = pRootElem-&gt;get_children();
+	const Node::NodeList childNodes = pRootElem-&gt;get_children();
 	if (childNodes.empty() == false)
 	{
-		for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+		for (Node::NodeList::const_iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
 		{
 			Node *pNode = (*iter);
 			// All nodes should be elements

Modified: trunk/UI/GTK2/src/PinotUtils.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/PinotUtils.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -23,6 +23,7 @@
 #include &quot;PinotUtils.h&quot;
 
 using namespace std;
+using namespace SigC;
 using namespace Glib;
 using namespace Gtk;
 
@@ -80,8 +81,8 @@
 	fileChooser.set_select_multiple(false);
 	fileChooser.set_transient_for(parentWindow);
 	// Add response buttons
-	fileChooser.add_button(Stock::CANCEL, Gtk::RESPONSE_CANCEL);
-	fileChooser.add_button(okButtonStockId, Gtk::RESPONSE_OK);
+	fileChooser.add_button(Stock::CANCEL, RESPONSE_CANCEL);
+	fileChooser.add_button(okButtonStockId, RESPONSE_OK);
 	// FIXME: add FileFilter's
 	fileChooser.show();
 	int result = fileChooser.run();
@@ -116,23 +117,6 @@
 	return treeColumn;
 }
 
-/// Create a resizable text column, rendered by renderTextCell.
-TreeViewColumn *create_resizable_column(const ustring &amp;title, const TreeModelColumnBase&amp; modelColumn,
-	const TreeViewColumn::SlotCellData &amp;renderTextCell)
-{
-	TreeViewColumn *treeColumn = new TreeViewColumn(title);
-
-	CellRendererText *textCellRenderer = new CellRendererText();
-	treeColumn-&gt;pack_start(*manage(textCellRenderer));
-	// This will be called to render the text
-	treeColumn-&gt;set_cell_data_func(*textCellRenderer, renderTextCell);
-
-	treeColumn-&gt;add_attribute(textCellRenderer-&gt;property_text(), modelColumn);
-	treeColumn-&gt;set_resizable(true);
-
-	return treeColumn;
-}
-
 /// Create a resizable icon and text column, rendered by renderTextAndIconCell.
 TreeViewColumn *create_resizable_column_with_icon(const ustring &amp;title,
 	const TreeModelColumnBase&amp; modelColumn, const TreeViewColumn::SlotCellData &amp;renderTextAndIconCell)

Modified: trunk/UI/GTK2/src/PinotUtils.h
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.h	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/PinotUtils.h	2005-12-29 09:00:55 UTC (rev 28)
@@ -22,42 +22,11 @@
 #if GTKMM_MAJOR_VERSION==2 &amp;&amp; GTKMM_MINOR_VERSION&gt;2
 #include &lt;sigc++/compatibility.h&gt;
 #endif
-#include &lt;sigc++/signal.h&gt;
 #include &lt;glibmm/ustring.h&gt;
 #include &lt;gtkmm/window.h&gt;
 #include &lt;gtkmm/treeview.h&gt;
 #include &lt;gtkmm/treemodel.h&gt;
 
-/**
-  * DCTreeView subclasses TreeView and handles double clicks.
-  * Handling double-clicks on tree views is not straight-forward, see :
-  * <A HREF="http://bugzilla.gnome.org/show_bug.cgi?id=89780">http://bugzilla.gnome.org/show_bug.cgi?id=89780</A>
-  * <A HREF="http://www.gtkmm.org/gtkmm2/docs/tutorial/html/ch08s07.html">http://www.gtkmm.org/gtkmm2/docs/tutorial/html/ch08s07.html</A>
-  */
-class DCTreeView : public Gtk::TreeView
-{
-	public:
-		DCTreeView() : Gtk::TreeView() {}
-		virtual ~DCTreeView() {}
-
-		SigC::Signal0&lt;void&gt; signal_double_click_event;
-
-	protected:
-		bool on_button_press_event(GdkEventButton* event)
-		{
-			// Check for double clicks
-			if (event-&gt;type == GDK_2BUTTON_PRESS)
-			{
-				signal_double_click_event();
-				return true;
-			}
-
-			// Not handled
-			return TreeView::on_button_press_event(event);
-		}
-
-};
-
 /// Open a FileSelector and request a file. Location can be initialized.
 bool select_file_name(Gtk::Window &amp;parentWindow, const Glib::ustring &amp;title,
 	Glib::ustring &amp;location, bool openOrCreate = true, bool directoriesOnly = false);
@@ -66,11 +35,6 @@
 Gtk::TreeViewColumn *create_resizable_column(const Glib::ustring &amp;title,
 	const Gtk::TreeModelColumnBase&amp; modelColumn);
 
-/// Create a resizable text column, rendered by renderTextCell.
-Gtk::TreeViewColumn *create_resizable_column(const Glib::ustring &amp;title,
-	const Gtk::TreeModelColumnBase&amp; modelColumn,
-	const  Gtk::TreeViewColumn::SlotCellData &amp;renderTextCell);
-
 /// Create a resizable icon and text column, rendered by renderTextAndIconCell.
 Gtk::TreeViewColumn *create_resizable_column_with_icon(const Glib::ustring &amp;title,
 	const Gtk::TreeModelColumnBase&amp; modelColumn,

Modified: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -48,7 +48,6 @@
 	m_extractTextview(NULL),
 	m_showExtract(true)
 {
-	HBox *extractHbox = manage(new class Gtk::HBox(false, 0));
 	ScrolledWindow *resultsScrolledwindow = manage(new ScrolledWindow());
 	m_extractScrolledwindow = manage(new ScrolledWindow());
 	m_extractTextview = manage(new TextView());
@@ -142,7 +141,6 @@
 	resultsScrolledwindow-&gt;show();
 	m_extractTextview-&gt;show();
 	m_extractScrolledwindow-&gt;show();
-	extractHbox-&gt;show();
 }
 
 ResultsTree::~ResultsTree()

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -389,6 +389,11 @@
 	return &quot;LabelQueryThread&quot;;
 }
 
+string LabelQueryThread::getIndexName(void) const
+{
+	return m_indexName;
+}
+
 string LabelQueryThread::getLabelName(void) const
 {
 	return m_labelName;

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2005-12-29 09:00:55 UTC (rev 28)
@@ -125,11 +125,11 @@
 
 		virtual std::string getType(void) const;
 
-		virtual std::string getEngineName(void) const;
+		std::string getEngineName(void) const;
 
-		virtual QueryProperties getQuery(void) const;
+		QueryProperties getQuery(void) const;
 
-		virtual const std::vector&lt;Result&gt; &amp;getResults(void) const;
+		const std::vector&lt;Result&gt; &amp;getResults(void) const;
 
 		virtual bool stop(void);
 
@@ -158,11 +158,13 @@
 
 		virtual std::string getType(void) const;
 
-		virtual std::string getLabelName(void) const;
+		std::string getIndexName(void) const;
 
+		std::string getLabelName(void) const;
+
 		virtual bool stop(void);
 
-		virtual const std::set&lt;unsigned int&gt; &amp;getDocumentsList(void) const;
+		const std::set&lt;unsigned int&gt; &amp;getDocumentsList(void) const;
 
 	protected:
 		std::string m_indexName;
@@ -212,9 +214,9 @@
 
 		virtual std::string getType(void) const;
 
-		virtual std::string getURL(void) const;
+		std::string getURL(void) const;
 
-		virtual const Document *getDocument(void) const;
+		const Document *getDocument(void) const;
 
 		virtual bool stop(void);
 

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-29 09:00:55 UTC (rev 28)
@@ -73,11 +73,7 @@
 unsigned int mainWindow::m_maxThreads = 2;
 
 mainWindow::InternalState::InternalState() :
-	m_currentLabelPos(0),
-	m_currentLabelName(_(&quot;None&quot;)),
-	m_currentIndexName(_(&quot;My Documents&quot;)),
-	m_indexDocsCount(0),
-	m_startDoc(0),
+	m_currentPage(0),
 	m_backgroundThreads(0),
 	m_browsingIndex(false)
 {
@@ -124,52 +120,6 @@
 	pthread_rwlock_unlock(&amp;m_rwLock);
 }
 
-unsigned int mainWindow::InternalState::getCurrentLabel(string &amp;labelName)
-{
-	if (readLock(1) == true)
-	{
-		unsigned int labelPos = m_currentLabelPos;
-		labelName = m_currentLabelName;
-		unlock();
-
-		return labelPos;
-	}
-	
-	return 0;
-}
-
-void mainWindow::InternalState::setCurrentLabel(unsigned int labelPos, const string &amp;labelName)
-{
-	if (writeLock(1) == true)
-	{
-		m_currentLabelPos = labelPos;
-		m_currentLabelName = labelName;
-		unlock();
-	}
-}
-
-Glib::ustring mainWindow::InternalState::getCurrentIndex(void)
-{
-	ustring indexName;
-
-	if (readLock(2) == true)
-	{
-		indexName = m_currentIndexName;
-		unlock();
-	}
-
-	return indexName;
-}
-
-void mainWindow::InternalState::setCurrentIndex(const Glib::ustring &amp;indexName)
-{
-	if (writeLock(2) == true)
-	{
-		m_currentIndexName = indexName;
-		unlock();
-	}
-}
-
 //
 // Constructor
 //
@@ -177,7 +127,7 @@
 	m_settings(PinotSettings::getInstance()), mainWindow_glade(),
 	m_pEnginesTree(NULL),
 	m_pResultsTree(NULL),
-	m_pIndexTree(NULL),
+	m_pIndexMenu(NULL),
 	m_pLabelsMenu(NULL)
 {
 	// Reposition and resize the window
@@ -234,31 +184,15 @@
 	m_pResultsTree-&gt;get_selection()-&gt;signal_changed().connect(SigC::slot(*this,
 		&amp;mainWindow::on_resultsTreeviewSelection_changed));
 
-	// Position the index tree
-	m_pIndexTree = manage(new IndexTree(indexVbox, indexMenuitem-&gt;get_submenu(), m_settings));
-	// Connect to the &quot;changed&quot; signal
-	m_pIndexTree-&gt;get_selection()-&gt;signal_changed().connect(SigC::slot(*this,
-		&amp;mainWindow::on_indexTreeviewSelection_changed));
-	// Connect to the edit document signal
-	m_pIndexTree-&gt;getEditDocumentSignal().connect(SigC::slot(*this,
-		&amp;mainWindow::on_showfromindex_activate));
+	// Populate the index menu
+	populate_indexMenu();
 
-	// Associate the columns model to the index combo
-	m_refIndexNameTree = ListStore::create(m_indexNameColumns);
-	indexCombobox-&gt;set_model(m_refIndexNameTree);
-	indexCombobox-&gt;pack_start(m_indexNameColumns.m_name);
-	// Populate the index combo
-	populate_indexCombobox();
-
-	// Populate the label menu
-	populate_labelMenu();
-
 	// Add an HTML renderer in the View tab
 	m_pHtmlView = new HtmlView(viewVbox, NULL);
 	if (m_settings.m_browseResults == true)
 	{
 		// Hide this tab
-		Widget *pPage = mainNotebook-&gt;get_nth_page(2);
+		Widget *pPage = mainNotebook-&gt;get_nth_page(1);
 		if (pPage != NULL)
 		{
 			pPage-&gt;hide();
@@ -285,7 +219,6 @@
 		viewcache1-&gt;set_sensitive(false);
 	}
 	indexresults1-&gt;set_sensitive(false);
-	showlabels1-&gt;set_sensitive(false);
 	viewfromindex1-&gt;set_sensitive(false);
 	refreshindex1-&gt;set_sensitive(false);
 	showfromindex1-&gt;set_sensitive(false);
@@ -293,8 +226,6 @@
 	//viewstop1-&gt;set_sensitive(false);
 	// ...and buttons
 	removeIndexButton-&gt;set_sensitive(false);
-	indexBackButton-&gt;set_sensitive(false);
-	indexForwardButton-&gt;set_sensitive(false);
 
 	// Set focus on the query entry field
 	set_focus(*liveQueryEntry);
@@ -320,8 +251,6 @@
 	start_thread(pMonitorThread, true);
 	// The handler object will be deleted when the thread terminates
 
-	// List the documents index
-	browse_index();
 	// There might be queued actions
 	check_queue();
 
@@ -344,12 +273,12 @@
 	}
 
 	// This is a hack to avoid segfaults when the View tab hasn't been made visible
-	Widget *pPage = mainNotebook-&gt;get_nth_page(2);
+	Widget *pPage = mainNotebook-&gt;get_nth_page(1);
 	if (pPage != NULL)
 	{
 		pPage-&gt;show();
 	}
-	mainNotebook-&gt;set_current_page(2);
+	mainNotebook-&gt;set_current_page(1);
 	// Stop if we were loading a page
 	m_pHtmlView-&gt;stop();
 	delete m_pHtmlView;
@@ -424,82 +353,35 @@
 }
 
 //
-// Populate the indexes list
+// Populate the index menu
 //
-void mainWindow::populate_indexCombobox()
+void mainWindow::populate_indexMenu()
 {
-	TreeModel::iterator iter;
-	TreeModel::Row row;
-
-	const std::map&lt;string, string&gt; &amp;indexes = m_settings.getIndexes();
-#ifdef DEBUG
-	cout &lt;&lt; &quot;mainWindow::populate_indexCombobox: &quot; &lt;&lt; indexes.size() &lt;&lt; &quot; indexes&quot; &lt;&lt; endl;
-#endif
-	m_refIndexNameTree-&gt;clear();
-	std::map&lt;string, string&gt;::const_iterator indexIter = indexes.begin();
-	for (; indexIter != indexes.end(); ++indexIter)
+	if (m_pIndexMenu == NULL)
 	{
-		string indexName = indexIter-&gt;first;
-
-		if (m_settings.isInternalIndex(indexName) == true)
-		{
-			// Add this index
-			iter = m_refIndexNameTree-&gt;append();
-			row = *iter;
-			row[m_indexNameColumns.m_name] = to_utf8(indexName);
-#ifdef DEBUG
-			cout &lt;&lt; &quot;mainWindow::populate_indexCombobox: added &quot; &lt;&lt; indexName &lt;&lt; endl;
-#endif
-		}
+		m_pIndexMenu = new Menu();
+		list1-&gt;set_submenu(*m_pIndexMenu);
 	}
-
-	indexCombobox-&gt;set_active(0);
-}
-
-//
-// Populate the labels menu
-//
-void mainWindow::populate_labelMenu()
-{
-	RadioMenuItem::Group labelsGroup;
-	RadioMenuItem *firstLabelMenuItem = NULL;
-	RadioMenuItem *labelMenuItem = NULL;
-
-#ifdef DEBUG
-	cout &lt;&lt; &quot;mainWindow::populate_labels_menu: called&quot; &lt;&lt; endl;
-#endif
-	if (m_pLabelsMenu == NULL)
-	{
-		m_pLabelsMenu = new Menu();
-		showlabels1-&gt;set_submenu(*m_pLabelsMenu);
-	}
 	else
 	{
 		// Clear the submenu
-		m_pLabelsMenu-&gt;items().clear();
+		m_pIndexMenu-&gt;items().clear();
 	}
 
-	SigC::Slot1&lt;void, unsigned int&gt; labelsSlot = SigC::slot(*this, &amp;mainWindow::on_labelMenu_changed);
-	unsigned int count = 1;
-                                                                                                                                                             
-	// Initialize the submenu
-	m_pLabelsMenu-&gt;items().push_back(Menu_Helpers::RadioMenuElem(labelsGroup, _(&quot;None&quot;)));
-	firstLabelMenuItem = labelMenuItem = (RadioMenuItem*)&amp;m_pLabelsMenu-&gt;items().back();
-	// Bind the callback's parameter to the menuitem's position in the submenu
-	SigC::Slot0&lt;void&gt; labelsSlot0 = sigc::bind(labelsSlot, 0);
-	labelMenuItem-&gt;signal_activate().connect(labelsSlot0);
-	for (set&lt;PinotSettings::Label&gt;::const_iterator iter = m_settings.m_labels.begin();
-		iter != m_settings.m_labels.end(); ++iter)
-	{
-		m_pLabelsMenu-&gt;items().push_back(Menu_Helpers::RadioMenuElem(labelsGroup, iter-&gt;m_name));
-		labelMenuItem = (RadioMenuItem*)&amp;m_pLabelsMenu-&gt;items().back();
-		SigC::Slot0&lt;void&gt; labelsSlot0 = sigc::bind(labelsSlot, count);
-		labelMenuItem-&gt;signal_activate().connect(labelsSlot0);
-		++count;
-	}
+	SigC::Slot1&lt;void, ustring&gt; indexSlot = SigC::slot(*this, &amp;mainWindow::on_index_changed);
 
-	// Activate the first menuitem
-	firstLabelMenuItem-&gt;set_active(true);
+	// Populate the submenu
+	m_pIndexMenu-&gt;items().push_back(Menu_Helpers::MenuElem(_(&quot;My Documents&quot;)));
+	MenuItem *pMenuItem = &amp;m_pIndexMenu-&gt;items().back();
+	// Bind the callback's parameter to the index name
+	SigC::Slot0&lt;void&gt; documentsActivateSlot = sigc::bind(indexSlot, _(&quot;My Documents&quot;));
+	pMenuItem-&gt;signal_activate().connect(documentsActivateSlot);
+
+	m_pIndexMenu-&gt;items().push_back(Menu_Helpers::MenuElem(_(&quot;My Email&quot;)));
+	pMenuItem = &amp;m_pIndexMenu-&gt;items().back();
+	// Bind the callback's parameter to the index name
+	SigC::Slot0&lt;void&gt; emailActivateSlot = sigc::bind(indexSlot, _(&quot;My Email&quot;));
+	pMenuItem-&gt;signal_activate().connect(emailActivateSlot);
 }
 
 //
@@ -616,20 +498,29 @@
 //
 // Index tree selection changed
 //
-void mainWindow::on_indexTreeviewSelection_changed()
+void mainWindow::on_indexTreeviewSelection_changed(ustring indexName)
 {
-	if (m_pIndexTree-&gt;onSelectionChanged() == true)
+	vector&lt;IndexedDocument&gt; documentsList;
+
+	IndexPage *pIndexPage = get_index_page(indexName);
+	if (pIndexPage == NULL)
 	{
+		return;
+	}
+
+	IndexTree *pIndexTree = pIndexPage-&gt;getTree();
+	if ((pIndexTree != NULL) &amp;&amp;
+		(pIndexTree-&gt;getSelection(documentsList) == true))
+	{
 		bool isDocumentsIndex = true;
 		bool canViewDocument = true;
 
 		// Enable these menu items, unless the index is not the documents index
-		ustring currentIndexName = m_state.getCurrentIndex();
-		if (currentIndexName != _(&quot;My Documents&quot;))
+		if (indexName != _(&quot;My Documents&quot;))
 		{
 			isDocumentsIndex = false;
 		}
-		if ((currentIndexName == _(&quot;My Email&quot;)) &amp;&amp;
+		if ((indexName == _(&quot;My Email&quot;)) &amp;&amp;
 			(m_settings.m_browseResults == true))
 		{
 			canViewDocument = false;
@@ -642,7 +533,7 @@
 		// Show the URL in the status bar
 		ustring statusText = _(&quot;Document location is&quot;);
 		statusText += &quot; &quot;;
-		statusText += m_pIndexTree-&gt;getFirstSelectionURL();
+		statusText += pIndexTree-&gt;getFirstSelectionURL();
 		set_status(statusText, true);
 	}
 	else
@@ -656,56 +547,128 @@
 }
 
 //
-// Index &gt; Show Labels menu selected
+// Index &gt; List menu selected
 //
-void mainWindow::on_labelMenu_changed(unsigned int pos)
+void mainWindow::on_index_changed(ustring indexName)
 {
-	string currentLabelName;
-	unsigned int currentLabelPos;
+	IndexTree *pIndexTree = NULL;
+	IndexPage *pIndexPage = NULL;
+	bool foundPage = false;
 
-	// Since we listen for signal_activate(), this handler gets called when the
-	// current item is unselected and when the new one is selected
-	currentLabelPos = m_state.getCurrentLabel(currentLabelName);
-	if (currentLabelPos == pos)
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::on_index_changed: current index now &quot; &lt;&lt; indexName &lt;&lt; endl;
+#endif
+
+	// Is there already a page for this index ?
+	pIndexPage = get_index_page(indexName);
+	if (pIndexPage != NULL)
 	{
-		// Ignore unselections
+		// Force a refresh
+		pIndexTree = pIndexPage-&gt;getTree();
+		if (pIndexTree != NULL)
+		{
+			pIndexTree-&gt;clear();
+		}
+		pIndexPage-&gt;setFirstDocument(0);
+		pIndexPage-&gt;setDocumentsCount(0);
+		foundPage = true;
+	}
+
+	if ((foundPage == false) &amp;&amp;
+		(m_state.writeLock(1) == true))
+	{
+		NotebookTabBox *pTab = manage(new NotebookTabBox(indexName,
+			NotebookTabBox::INDEX_PAGE));
+		pTab-&gt;getCloseSignal().connect(
+			SigC::slot(*this, &amp;mainWindow::on_page_closed));
+
+		// Position the index tree
+		pIndexTree = manage(new IndexTree(indexName, indexMenuitem-&gt;get_submenu(), m_settings));
+		pIndexPage = manage(new IndexPage(indexName, pIndexTree, m_settings));
+		// Connect to the &quot;changed&quot; signal
+		pIndexTree-&gt;getSelectionChangedSignal().connect(
+			SigC::slot(*this, &amp;mainWindow::on_indexTreeviewSelection_changed));
+		// Connect to the edit document signal
+		pIndexTree-&gt;getEditDocumentSignal().connect(
+			SigC::slot(*this, &amp;mainWindow::on_showfromindex_activate));
+		// Connect to the label changed signal
+		pIndexPage-&gt;getLabelChangedSignal().connect(
+			SigC::slot(*this, &amp;mainWindow::on_label_changed));
+		// ...and to the buttons clicked signals
+		pIndexPage-&gt;getBackClickedSignal().connect(
+			SigC::slot(*this, &amp;mainWindow::on_indexBackButton_clicked));
+		pIndexPage-&gt;getForwardClickedSignal().connect(
+			SigC::slot(*this, &amp;mainWindow::on_indexForwardButton_clicked));
+		int pageNum = mainNotebook-&gt;append_page(*pIndexPage, *pTab);
+		if (pageNum &gt;= 0)
+		{
+			// Add this page to the list
+			foundPage = true;
+		}
+
+		m_state.unlock();
+	}
+
+	if (foundPage == true)
+	{
+		browse_index(indexName, 0);
+	}
+}
+
+//
+// Index &gt; labels combo selection changed
+//
+void mainWindow::on_label_changed(ustring indexName, ustring labelName)
+{
+	IndexPage *pIndexPage = get_index_page(indexName);
+	if (pIndexPage == NULL)
+	{
 		return;
 	}
+	IndexTree *pIndexTree = pIndexPage-&gt;getTree();
+	if (pIndexTree == NULL)
+	{
+		return;
+	}
+
 #ifdef DEBUG
-	cout &lt;&lt; &quot;mainWindow::on_labelMenu_changed: called on &quot; &lt;&lt; pos &lt;&lt; endl;
+	cout &lt;&lt; &quot;mainWindow::on_label_changed: called on &quot; &lt;&lt; labelName &lt;&lt; endl;
 #endif
-	currentLabelPos = pos;
-	if (currentLabelPos == 0)
+	pIndexTree-&gt;setCurrentLabelColour(0, 0, 0, false);
+	if (labelName.empty() == true)
 	{
 		// User selected no label
-		currentLabelName = _(&quot;None&quot;);
-		m_state.setCurrentLabel(currentLabelPos, currentLabelName);
-		m_pIndexTree-&gt;setCurrentLabelColour(0, 0, 0, false);
-		set_status(_(&quot;No labels&quot;));
+		set_status(_(&quot;No label&quot;));
 		return;
 	}
 
-	// Get the actual label from the settings object
-	unsigned int labelNum = 1;
-	for (set&lt;PinotSettings::Label&gt;::iterator labelIter = m_settings.m_labels.begin();
-		labelIter != m_settings.m_labels.end(); ++labelIter)
+	// Get the documents that match this label
+	start_thread(new LabelQueryThread(indexName, labelName));
+}
+
+//
+// Notebook page closed
+//
+void mainWindow::on_page_closed(ustring title, NotebookTabBox::PageType type)
+{
+	if (type != NotebookTabBox::INDEX_PAGE)
 	{
-		if (labelNum == pos)
-		{
-			// That's the one
-			currentLabelName = locale_from_utf8(labelIter-&gt;m_name);
-			m_state.setCurrentLabel(currentLabelPos, currentLabelName);
+		return;
+	}
+
 #ifdef DEBUG
-			cout &lt;&lt; &quot;mainWindow::on_labelMenu_changed: label is &quot; &lt;&lt; currentLabelName &lt;&lt; endl;
+	cout &lt;&lt; &quot;mainWindow::on_page_closed: called for tab &quot; &lt;&lt; title &lt;&lt; endl;
 #endif
-			// Switch temporarily to no label
-			m_pIndexTree-&gt;setCurrentLabelColour(0, 0, 0, false);
+	int pageNum = get_index_page_number(title);
+	if (pageNum &gt;= 0)
+	{
+		if (m_state.writeLock(2) == true)
+		{
+			// Remove the page
+			mainNotebook-&gt;remove_page(pageNum);
 
-			// Get the documents that match this label
-			start_thread(new LabelQueryThread(m_state.getCurrentIndex(), currentLabelName));
-			break;
+			m_state.unlock();
 		}
-		++labelNum;
 	}
 }
 
@@ -773,7 +736,6 @@
 	{
 		char docsCountStr[64];
 		unsigned int count = 0;
-		bool enableIndexOps = false;
 
 		IndexBrowserThread *pBrowseThread = dynamic_cast&lt;IndexBrowserThread *&gt;(pThread);
 		if (pBrowseThread == NULL)
@@ -782,9 +744,26 @@
 			return;
 		}
 
-		m_state.m_indexDocsCount = pBrowseThread-&gt;getDocumentsCount();
-		count = m_pIndexTree-&gt;getRowsCount();
+		IndexPage *pIndexPage = NULL;
+		IndexTree *pIndexTree = NULL;
+		ustring indexName = locale_to_utf8(pBrowseThread-&gt;getIndexName());
 
+		// Find the page for this index
+		pIndexPage = get_index_page(indexName);
+		if (pIndexPage == NULL)
+		{
+			// It's probably been closed by the user
+			return;
+		}
+		pIndexTree = pIndexPage-&gt;getTree();
+		if (pIndexTree == NULL)
+		{
+			return;
+		}
+
+		pIndexPage-&gt;setDocumentsCount(pBrowseThread-&gt;getDocumentsCount());
+		count = pIndexTree-&gt;getRowsCount();
+
 		status = _(&quot;Showing&quot;);
 		status += &quot; &quot;;
 		snprintf(docsCountStr, 64, &quot;%u&quot;, count);
@@ -792,43 +771,20 @@
 		status += &quot; &quot;;
 		status += _(&quot;off&quot;);
 		status += &quot; &quot;;
-		snprintf(docsCountStr, 64, &quot;%u&quot;, m_state.m_indexDocsCount);
+		snprintf(docsCountStr, 64, &quot;%u&quot;, pIndexPage-&gt;getDocumentsCount());
 		status += docsCountStr;
 		status += &quot; &quot;;
 		status += _(&quot;documents from&quot;);
 		status += &quot; &quot;;
-		status += m_state.getCurrentIndex();
+		status += indexName;
 		set_status(status);
 
-		if (m_state.m_indexDocsCount &gt; 0)
+		if (pIndexPage-&gt;getDocumentsCount() &gt; 0)
 		{
-			// Switch to the index page
-			mainNotebook-&gt;set_current_page(1);
-			// FIXME: not sure why, but this helps with refreshing the tree
-			m_pIndexTree-&gt;columns_autosize();
-			enableIndexOps = true;
+			// Refresh the tree
+			pIndexTree-&gt;refresh();
 		}
-		showlabels1-&gt;set_sensitive(enableIndexOps);
-#ifdef DEBUG
-		cout &lt;&lt; &quot;mainWindow::on_thread_end: &quot; &lt;&lt; m_state.m_indexDocsCount
-			&lt;&lt; &quot; documents, starting at &quot; &lt;&lt; m_state.m_startDoc &lt;&lt; endl;
-#endif
-		if (m_state.m_startDoc &gt;= m_maxDocsCount)
-		{
-			indexBackButton-&gt;set_sensitive(true);
-		}
-		else
-		{
-			indexBackButton-&gt;set_sensitive(false);
-		}
-		if (m_state.m_indexDocsCount &gt;= m_state.m_startDoc + m_maxDocsCount)
-		{
-			indexForwardButton-&gt;set_sensitive(true);
-		}
-		else
-		{
-			indexForwardButton-&gt;set_sensitive(false);
-		}
+		pIndexPage-&gt;updateButtons(m_maxDocsCount);
 		m_state.m_browsingIndex = false;
 	}
 	else if (type == &quot;QueryingThread&quot;)
@@ -896,31 +852,39 @@
 	}
 	else if (type == &quot;LabelQueryThread&quot;)
 	{
-		string currentLabelName;
-		unsigned int currentLabelPos = 0;
-
 		LabelQueryThread *pLabelQueryThread = dynamic_cast&lt;LabelQueryThread *&gt;(pThread);
 		if (pLabelQueryThread == NULL)
 		{
 			delete pThread;
 			return;
 		}
+		ustring indexName = locale_to_utf8(pLabelQueryThread-&gt;getIndexName());
 
+		IndexPage *pIndexPage = get_index_page(indexName);
+		if (pIndexPage == NULL)
+		{
+			return;
+		}
+		IndexTree *pIndexTree = pIndexPage-&gt;getTree();
+		if (pIndexTree == NULL)
+		{
+			return;
+		}
+
 		// Don't bother if the index is not being listed, or if the user
 		// changed the label in the meantime
-		currentLabelPos = m_state.getCurrentLabel(currentLabelName);
-		if ((m_pIndexTree-&gt;isEmpty() == false) &amp;&amp;
-			(currentLabelPos &gt; 0) &amp;&amp;
-			(currentLabelName == pLabelQueryThread-&gt;getLabelName()))
+		ustring labelName = pIndexPage-&gt;getLabelName();
+		if ((pIndexTree-&gt;isEmpty() == false) &amp;&amp;
+			(labelName.empty() == false) &amp;&amp;
+			(labelName == locale_to_utf8(pLabelQueryThread-&gt;getLabelName())))
 		{
 			const set&lt;unsigned int&gt; &amp;documentsList = pLabelQueryThread-&gt;getDocumentsList();
 			char docsCountStr[64];
 			unsigned int docsCount = documentsList.size();
-			unsigned int labelNum = 1;
 
 			status = _(&quot;Label&quot;);
 			status += &quot; &quot;;
-			status += to_utf8(pLabelQueryThread-&gt;getLabelName());
+			status += labelName;
 			status += &quot; &quot;;
 			status += _(&quot;matches&quot;);
 			status += &quot; &quot;;
@@ -931,27 +895,22 @@
 			set_status(status);
 
 #ifdef DEBUG
-			cout &lt;&lt; &quot;mainWindow::on_thread_end: current label is &quot; &lt;&lt; currentLabelName &lt;&lt; endl;
+			cout &lt;&lt; &quot;mainWindow::on_thread_end: current label is &quot; &lt;&lt; labelName &lt;&lt; endl;
 #endif
 			// Get the actual label colour from the settings
 			for (set&lt;PinotSettings::Label&gt;::iterator labelIter = m_settings.m_labels.begin();
 				labelIter != m_settings.m_labels.end(); ++labelIter)
 			{
-#ifdef DEBUG
-				cout &lt;&lt; &quot;mainWindow::on_thread_end: looking at label &quot;
-					&lt;&lt; labelIter-&gt;m_name &lt;&lt; &quot;, position &quot; &lt;&lt; labelNum &lt;&lt; endl;
-#endif
-				if (labelNum == currentLabelPos)
+				if (labelName == labelIter-&gt;m_name)
 				{
 					// Display the selected label's colour in the index tree
-					m_pIndexTree-&gt;setCurrentLabelColour(labelIter-&gt;m_red, labelIter-&gt;m_green, labelIter-&gt;m_blue);
-					m_pIndexTree-&gt;setLabel(documentsList);
+					pIndexTree-&gt;setCurrentLabelColour(labelIter-&gt;m_red, labelIter-&gt;m_green, labelIter-&gt;m_blue);
+					pIndexTree-&gt;setLabel(documentsList);
 
 					// Switch to the index page
-					mainNotebook-&gt;set_current_page(1);
+					mainNotebook-&gt;set_current_page(get_index_page_number(indexName));
 					break;
 				}
-				++labelNum;
 			}
 		}
 	}
@@ -990,7 +949,7 @@
 				if (m_settings.m_browseResults == false)
 				{
 					// Display the URL in the View tab
-					mainNotebook-&gt;set_current_page(2);
+					mainNotebook-&gt;set_current_page(1);
 					if (m_pHtmlView-&gt;renderData(pData, dataLength, url) == true)
 					{
 						//viewstop1-&gt;set_sensitive(true);
@@ -1029,7 +988,7 @@
 			status += to_utf8(url);
 
 			// Update the in-progress list
-			if (m_state.writeLock(3) == true)
+			if (m_state.writeLock(4) == true)
 			{
 				set&lt;string&gt;::iterator urlIter = m_state.m_beingIndexed.find(url);
 				if (urlIter != m_state.m_beingIndexed.end())
@@ -1040,21 +999,24 @@
 				m_state.unlock();
 			}
 
-			// Was the current label applied to that document ?
-			string currentLabelName;
-			if ((m_state.getCurrentLabel(currentLabelName) &gt; 0) &amp;&amp;
-				(pIndexThread-&gt;getLabelName() == currentLabelName))
-			{
-				labeled = true;
-			}
-
 			// Is the index still being shown ?
-			if (m_state.getCurrentIndex() == _(&quot;My Documents&quot;))
+			IndexPage *pIndexPage = get_index_page(_(&quot;My Documents&quot;));
+			if (pIndexPage != NULL)
 			{
+				IndexTree *pIndexTree = pIndexPage-&gt;getTree();
 				XapianIndex index(m_settings.m_indexLocation);
 
-				if (index.isGood() == true)
+				// Was the current label applied to that document ?
+				ustring labelName = pIndexPage-&gt;getLabelName();
+				if ((labelName.empty() == false) &amp;&amp;
+					(labelName == locale_to_utf8(pIndexThread-&gt;getLabelName())))
 				{
+					labeled = true;
+				}
+
+				if ((pIndexTree != NULL) &amp;&amp;
+					(index.isGood() == true))
+				{
 					// Update the index tree
 					for (set&lt;unsigned int&gt;::iterator idIter = docIdList.begin();
 						idIter != docIdList.end(); ++idIter)
@@ -1071,12 +1033,10 @@
 								docInfo.getLocation(), docInfo.getType(),
 								docInfo.getLanguage());
 							indexedDoc.setTimestamp(docInfo.getTimestamp());
-							m_pIndexTree-&gt;appendDocument(indexedDoc, labeled);
+							pIndexTree-&gt;appendDocument(indexedDoc, labeled);
 						}
 					}
 				}
-
-				showlabels1-&gt;set_sensitive(true);
 			}
 		}
 
@@ -1111,8 +1071,16 @@
 			return;
 		}
 
-		m_pIndexTree-&gt;setDocumentTitle(pUpdateThread-&gt;getDocumentID(),
-			pUpdateThread-&gt;getDocumentInfo().getTitle());
+		IndexPage *pIndexPage = get_index_page(_(&quot;My Documents&quot;));
+		if (pIndexPage != NULL)
+		{
+			IndexTree *pIndexTree = pIndexPage-&gt;getTree();
+			if (pIndexTree != NULL)
+			{
+				pIndexTree-&gt;setDocumentTitle(pUpdateThread-&gt;getDocumentID(),
+					pUpdateThread-&gt;getDocumentInfo().getTitle());
+			}
+		}
 
 		status = _(&quot;Updated document&quot;);
 		set_status(status);
@@ -1226,31 +1194,40 @@
 //
 void mainWindow::on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, string indexName)
 {
+	IndexPage *pIndexPage = NULL;
+	IndexTree *pIndexTree = NULL;
 	bool hasLabel = false;
 
-	if (indexName != locale_from_utf8(m_state.getCurrentIndex()))
+	// Find the page for this index
+	pIndexPage = get_index_page(locale_to_utf8(indexName));
+	if (pIndexPage == NULL)
 	{
-		// Ignore
+		// It's probably been closed by the user
 #ifdef DEBUG
-		cout &lt;&lt; &quot;mainWindow::on_message_indexupdate: &quot; &lt;&lt; indexName &lt;&lt; &quot; not current&quot; &lt;&lt; endl;
+		cout &lt;&lt; &quot;mainWindow::on_message_indexupdate: &quot; &lt;&lt; indexName &lt;&lt; &quot; not being shown&quot; &lt;&lt; endl;
 #endif
 		return;
 	}
+	pIndexTree = pIndexPage-&gt;getTree();
+	if (pIndexTree == NULL)
+	{
+		return;
+	}
 
 	// Is the last page being displayed ?
-	if (m_state.m_startDoc + m_maxDocsCount &lt; m_state.m_indexDocsCount)
+	if (pIndexPage-&gt;getFirstDocument() + m_maxDocsCount &lt; pIndexPage-&gt;getDocumentsCount())
 	{
 		// No, so we can't add a new entry for that document
 		// Increment the count
-		++m_state.m_indexDocsCount;
+		pIndexPage-&gt;setDocumentsCount(pIndexPage-&gt;getDocumentsCount() + 1);
 		// ...and make sure the user can display that last page
-		indexForwardButton-&gt;set_sensitive(true);
+		pIndexPage-&gt;updateButtons(m_maxDocsCount);
 		return;
 	}
 
 	// Does that document have the current label ?
-	string currentLabelName;
-	if (m_state.getCurrentLabel(currentLabelName) &gt; 0)
+	ustring labelName = pIndexPage-&gt;getLabelName();
+	if (labelName.empty() == false)
 	{
 		const std::map&lt;string, string&gt; &amp;indexesMap = PinotSettings::getInstance().getIndexes();
 		std::map&lt;string, string&gt;::const_iterator mapIter = indexesMap.find(indexName);
@@ -1260,18 +1237,18 @@
 
 			if (index.isGood() == true)
 			{
-				hasLabel = index.hasLabel(docId, currentLabelName);
+				hasLabel = index.hasLabel(docId, locale_from_utf8(labelName));
 			}
 		}
 	}
 
 	// Add a row
-	if (m_pIndexTree-&gt;appendDocument(docInfo, hasLabel) == true)
+	if (pIndexTree-&gt;appendDocument(docInfo, hasLabel) == true)
 	{
 #ifdef DEBUG
 		cout &lt;&lt; &quot;mainWindow::on_message_indexupdate: added document to index list&quot; &lt;&lt; endl;
 #endif
-		++m_state.m_indexDocsCount;
+		pIndexPage-&gt;setDocumentsCount(pIndexPage-&gt;getDocumentsCount() + 1);
 	}
 }
 
@@ -1309,15 +1286,36 @@
 	// FIXME: if mail accounts are configured, make sure the MonitorThread
 	// is running and knows about the new accounts
 
-	// Synchronize the labels list with the new settings
-	m_pIndexTree-&gt;setCurrentLabelColour(0, 0, 0, false);
-	populate_labelMenu();
+	if (m_state.readLock(5) == true)
+	{
+		for (int pageNum = 0; pageNum &lt; mainNotebook-&gt;get_n_pages(); ++pageNum)
+		{
+			Widget *pPage = mainNotebook-&gt;get_nth_page(pageNum);
+			if (pPage != NULL)
+			{
+				IndexPage *pIndexPage = dynamic_cast&lt;IndexPage*&gt;(pPage);
+				if (pIndexPage != NULL)
+				{
+					IndexTree *pIndexTree = pIndexPage-&gt;getTree();
 
+					// Synchronize the labels list with the new settings
+					if (pIndexTree != NULL)
+					{
+						pIndexTree-&gt;setCurrentLabelColour(0, 0, 0, false);
+					}
+					pIndexPage-&gt;populateLabelCombobox();
+				}
+			}
+		}
+
+		m_state.unlock();
+	}
+
 	// Do the changes affect the View tab ?
 	if (useExternalBrowser != m_settings.m_browseResults)
 	{
 		int nCurrentPage = mainNotebook-&gt;get_current_page();
-		Widget *pPage = mainNotebook-&gt;get_nth_page(2);
+		Widget *pPage = mainNotebook-&gt;get_nth_page(1);
 		if (pPage != NULL)
 		{
 			// Hide or show ?
@@ -1417,37 +1415,47 @@
 			firstItem = false;
 		}
 	}
-	else if (m_pIndexTree-&gt;is_focus() == true)
+	else
 	{
-		vector&lt;IndexedDocument&gt; documentsList;
-		bool firstItem = true;
+		// The focus may be on one of the index tabs
+		IndexPage *pIndexPage = get_index_page_with_focus(true);
+		if (pIndexPage != NULL)
+		{
+			IndexTree *pIndexTree = pIndexPage-&gt;getTree();
+			if (pIndexTree != NULL)
+			{
+				vector&lt;IndexedDocument&gt; documentsList;
+				bool firstItem = true;
 
 #ifdef DEBUG
-		cout &lt;&lt; &quot;mainWindow::on_copy_activate: index tree&quot; &lt;&lt; endl;
+				cout &lt;&lt; &quot;mainWindow::on_copy_activate: index tree&quot; &lt;&lt; endl;
 #endif
-		// Get the current documents selection
-		m_pIndexTree-&gt;getSelection(documentsList);
-	
-		for (vector&lt;IndexedDocument&gt;::const_iterator docIter = documentsList.begin();
-			docIter != documentsList.end(); ++docIter)
-		{
-			if (firstItem == false)
-			{
-				text += &quot;\n&quot;;
+				// Get the current documents selection
+				pIndexTree-&gt;getSelection(documentsList);
+
+				for (vector&lt;IndexedDocument&gt;::const_iterator docIter = documentsList.begin();
+					docIter != documentsList.end(); ++docIter)
+				{
+					if (firstItem == false)
+					{
+						text += &quot;\n&quot;;
+					}
+					text += docIter-&gt;getTitle();
+					text += &quot; &quot;;
+					text += docIter-&gt;getLocation();
+					firstItem = false;
+				}
 			}
-			text += docIter-&gt;getTitle();
-			text += &quot; &quot;;
-			text += docIter-&gt;getLocation();
-			firstItem = false;
 		}
-	}
-	else
-	{
-		// Only rows from the query, results and index trees can be copied
+
+		if (text.empty() == true)
+		{
+			// Only rows from the query, results and index trees can be copied
 #ifdef DEBUG
-		cout &lt;&lt; &quot;mainWindow::on_copy_activate: other&quot; &lt;&lt; endl;
+			cout &lt;&lt; &quot;mainWindow::on_copy_activate: other&quot; &lt;&lt; endl;
 #endif
-		return;
+			return;
+		}
 	}
 	
 	RefPtr&lt;Clipboard&gt; refClipboard = Clipboard::get();
@@ -1631,9 +1639,18 @@
 //
 void mainWindow::on_viewfromindex_activate()
 {
-	// View the first document, don't bother about the rest
-	ustring url = m_pIndexTree-&gt;getFirstSelectionLiveURL();
-	view_document(locale_from_utf8(url));
+	IndexPage *pIndexPage = get_index_page_with_focus(false);
+	if (pIndexPage != NULL)
+	{
+		IndexTree *pIndexTree = pIndexPage-&gt;getTree();
+
+		if (pIndexTree != NULL)
+		{
+			// View the first document, don't bother about the rest
+			ustring url = pIndexTree-&gt;getFirstSelectionLiveURL();
+			view_document(locale_from_utf8(url));
+		}
+	}
 }
 
 //
@@ -1651,11 +1668,20 @@
 	}
 
 	// Get the current documents selection
-	if ((m_pIndexTree-&gt;getSelection(documentsList) == false) ||
-		(documentsList.empty() == true))
+	IndexPage *pIndexPage = get_index_page_with_focus(false);
+	if (pIndexPage != NULL)
 	{
-		// No selection
-		return;
+		IndexTree *pIndexTree = pIndexPage-&gt;getTree();
+
+		if (pIndexTree != NULL)
+		{
+			if ((pIndexTree-&gt;getSelection(documentsList) == false) ||
+				(documentsList.empty() == true))
+			{
+				// No selection
+				return;
+			}
+		}
 	}
 
 	for (vector&lt;IndexedDocument&gt;::const_iterator docIter = documentsList.begin();
@@ -1693,19 +1719,28 @@
 {
 	vector&lt;IndexedDocument&gt; documentsList;
 	set&lt;string&gt; docLabels;
-	string currentLabelName;
+	string indexName, labelName;
 	DocumentInfo docInfo;
 	unsigned int docId = 0;
 	int width, height;
 	bool matchedLabel = false, editTitle = false;
 
+	IndexTree *pIndexTree = NULL;
+	IndexPage *pIndexPage = get_index_page_with_focus(false);
+	if (pIndexPage != NULL)
+	{
+		indexName = locale_from_utf8(pIndexPage-&gt;getIndexName());
+		labelName = locale_from_utf8(pIndexPage-&gt;getLabelName());
+		pIndexTree = pIndexPage-&gt;getTree();
+	}
+
 	const std::map&lt;string, string&gt; &amp;indexesMap = PinotSettings::getInstance().getIndexes();
-	std::map&lt;string, string&gt;::const_iterator mapIter = indexesMap.find(m_state.getCurrentIndex());	
+	std::map&lt;string, string&gt;::const_iterator mapIter = indexesMap.find(indexName);	
 	if (mapIter == indexesMap.end())
 	{
 		ustring statusText = _(&quot;Index&quot;);
 		statusText += &quot; &quot;;
-		statusText += m_state.getCurrentIndex();
+		statusText += indexName;
 		statusText += &quot; &quot;;
 		statusText += _(&quot;doesn't exist&quot;);
 		set_status(statusText);
@@ -1715,7 +1750,8 @@
 	XapianIndex index(mapIter-&gt;second);
 
 	// Get the current documents selection
-	if ((m_pIndexTree-&gt;getSelection(documentsList) == false) ||
+	if ((pIndexTree == NULL) ||
+		(pIndexTree-&gt;getSelection(documentsList) == false) ||
 		(documentsList.empty() == true))
 	{
 		// No selection
@@ -1736,8 +1772,8 @@
 			index.getDocumentLabels(docId, docLabels);
 
 			// Does it match the current label ?
-			if ((m_state.getCurrentLabel(currentLabelName) &gt; 0) &amp;&amp;
-				(find(docLabels.begin(), docLabels.end(), currentLabelName) != docLabels.end()))
+			if ((labelName.empty() == false) &amp;&amp;
+				(find(docLabels.begin(), docLabels.end(), labelName) != docLabels.end()))
 			{
 				matchedLabel = true;
 			}
@@ -1778,17 +1814,17 @@
 		bool matchesLabel = false;
 
 		// Does the sole selected document match the current label now ?
-		if ((currentLabelName.empty() == false) &amp;&amp;
-			(find(labels.begin(), labels.end(), currentLabelName) != labels.end()))
+		if ((labelName.empty() == false) &amp;&amp;
+			(find(labels.begin(), labels.end(), labelName) != labels.end()))
 		{
-				matchesLabel = true;
+			matchesLabel = true;
 		}
 
 		// Was there any change ?
 		if (matchesLabel != matchedLabel)
 		{
-				// Update this document to the index tree
-				m_pIndexTree-&gt;setDocumentLabeledState(docId, matchesLabel);
+			// Update this document to the index tree
+			pIndexTree-&gt;setDocumentLabeledState(docId, matchesLabel);
 		}
 
 		// Did the title change ?
@@ -1798,18 +1834,16 @@
 			docInfo.setTitle(newTitle);
 			
 			// Update the document
-			start_thread(new UpdateDocumentThread(m_state.getCurrentIndex(), docId, docInfo));
+			start_thread(new UpdateDocumentThread(indexName, docId, docInfo));
 		}
 	}
 	else
 	{
-		string currentLabelName;
-
-		if (m_state.getCurrentLabel(currentLabelName) &gt; 0)
+		if (labelName.empty() == false)
 		{
 			// The current label may have been applied to or removed from
 			// one or more of the selected documents, so refresh the list
-			start_thread(new LabelQueryThread(m_state.getCurrentIndex(), currentLabelName));
+			start_thread(new LabelQueryThread(indexName, labelName));
 		}
 	}
 }
@@ -1822,8 +1856,16 @@
 	vector&lt;IndexedDocument&gt; documentsList;
 	ustring boxTitle = _(&quot;Delete this document from the index ?&quot;);
 
+	IndexTree *pIndexTree = NULL;
+	IndexPage *pIndexPage = get_index_page_with_focus(false);
+	if (pIndexPage != NULL)
+	{
+		pIndexTree = pIndexPage-&gt;getTree();
+	}
+
 	// Get the current documents selection
-	if ((m_pIndexTree-&gt;getSelection(documentsList) == false) ||
+	if ((pIndexTree == NULL) ||
+		(pIndexTree-&gt;getSelection(documentsList) == false) ||
 		(documentsList.empty() == true))
 	{
 		return;
@@ -1845,11 +1887,7 @@
 	}
 
 	// Remove these documents from the tree
-	if (m_pIndexTree-&gt;deleteSelection() == true)
-	{
-		// The index tree is now empty
-		showlabels1-&gt;set_sensitive(false);
-	}
+	pIndexTree-&gt;deleteSelection();
 
 	set&lt;unsigned int&gt; docIdList;
 	for (vector&lt;IndexedDocument&gt;::const_iterator docIter = documentsList.begin();
@@ -2101,58 +2139,40 @@
 }
 
 //
-// Index list mouse click
+// Index back button click
 //
-void mainWindow::on_indexCombobox_changed()
+void mainWindow::on_indexBackButton_clicked(ustring indexName)
 {
-	TreeModel::iterator indexIter = indexCombobox-&gt;get_active();
-	if (indexIter)
+	IndexPage *pIndexPage = get_index_page(indexName);
+	if (pIndexPage != NULL)
 	{
-		TreeModel::Row row = *indexIter;
-
-		ustring indexName = row[m_indexNameColumns.m_name];
-#ifdef DEBUG
-		cout &lt;&lt; &quot;mainWindow::on_indexCombobox_changed: current index now &quot; &lt;&lt; indexName &lt;&lt; endl;
-#endif
-		ustring currentIndexName = m_state.getCurrentIndex();
-		m_state.setCurrentIndex(indexName);
-		if ((currentIndexName.empty() == false) &amp;&amp;
-			(currentIndexName != indexName))
+		if (pIndexPage-&gt;getFirstDocument() &gt;= m_maxDocsCount)
 		{
-			// Force a refresh if the selected index has changed
-			m_state.m_startDoc = m_state.m_indexDocsCount = 0;
-			on_indexForwardButton_clicked();
+			pIndexPage-&gt;setFirstDocument(pIndexPage-&gt;getFirstDocument() - m_maxDocsCount);
+			browse_index(indexName, pIndexPage-&gt;getFirstDocument());
 		}
 	}
 }
 
 //
-// Index back button click
-//
-void mainWindow::on_indexBackButton_clicked()
-{
-	if (m_state.m_startDoc &gt;= m_maxDocsCount)
-	{
-		m_state.m_startDoc -= m_maxDocsCount;
-		browse_index(m_state.m_startDoc);
-	}
-}
-
-//
 // Index forward button click
 //
-void mainWindow::on_indexForwardButton_clicked()
+void mainWindow::on_indexForwardButton_clicked(ustring indexName)
 {
-	if (m_state.m_indexDocsCount == 0)
+	IndexPage *pIndexPage = get_index_page(indexName);
+	if (pIndexPage != NULL)
 	{
-		m_state.m_startDoc = 0;
-		browse_index(m_state.m_startDoc);
+		if (pIndexPage-&gt;getDocumentsCount() == 0)
+		{
+			pIndexPage-&gt;setFirstDocument(0);
+			browse_index(indexName, 0);
+		}
+		else if (pIndexPage-&gt;getDocumentsCount() &gt;= pIndexPage-&gt;getFirstDocument() + m_maxDocsCount)
+		{
+			pIndexPage-&gt;setFirstDocument(pIndexPage-&gt;getFirstDocument() + m_maxDocsCount);
+			browse_index(indexName, pIndexPage-&gt;getFirstDocument());
+		}
 	}
-	else if (m_state.m_indexDocsCount &gt;= m_state.m_startDoc + m_maxDocsCount)
-	{
-		m_state.m_startDoc += m_maxDocsCount;
-		browse_index(m_state.m_startDoc);
-	}
 }
 
 //
@@ -2170,6 +2190,31 @@
 }
 
 //
+// Notebook page switch
+//
+void mainWindow::on_mainNotebook_switch_page(GtkNotebookPage *p0, guint p1)
+{
+#ifdef DEBUG
+	cout &lt;&lt; &quot;mainWindow::on_mainNotebook_switch_page: switched to page &quot; &lt;&lt; p1 &lt;&lt; endl;
+#endif
+	if (m_state.m_currentPage != (int)p1)
+	{
+		// Disable the widgets that depend on what page is selected
+		// Results
+		clearresults1-&gt;set_sensitive(false);
+		viewresults1-&gt;set_sensitive(false);
+		viewcache1-&gt;set_sensitive(false);
+		indexresults1-&gt;set_sensitive(false);
+		// Index
+		viewfromindex1-&gt;set_sensitive(false);
+		refreshindex1-&gt;set_sensitive(false);
+		showfromindex1-&gt;set_sensitive(false);
+		unindex1-&gt;set_sensitive(false);
+	}
+	m_state.m_currentPage = (int)p1;
+}
+
+//
 // Main window deleted
 //
 bool mainWindow::on_mainWindow_delete_event(GdkEventAny *ev)
@@ -2187,7 +2232,7 @@
 			return true;
 		}
 
-		if (m_state.readLock(4) == true)
+		if (m_state.readLock(6) == true)
 		{
 			for (set&lt;WorkerThread *&gt;::iterator threadIter = m_state.m_pThreads.begin();
 				threadIter != m_state.m_pThreads.end(); ++threadIter)
@@ -2218,6 +2263,127 @@
 }
 
 //
+// Returns the IndexPage for the index that has the focus.
+//
+IndexPage *mainWindow::get_index_page_with_focus(bool checkTree)
+{
+	IndexPage *pIndexPage = NULL;
+
+	if (m_state.readLock(7) == true)
+	{
+		for (int pageNum = 0; pageNum &lt; mainNotebook-&gt;get_n_pages(); ++pageNum)
+		{
+			Widget *pPage = mainNotebook-&gt;get_nth_page(pageNum);
+			if (pPage != NULL)
+			{
+				pIndexPage = dynamic_cast&lt;IndexPage*&gt;(pPage);
+				if (pIndexPage != NULL)
+				{
+#ifdef DEBUG
+					cout &lt;&lt; &quot;mainWindow::get_index_page_with_focus: &quot; &lt;&lt; pIndexPage-&gt;getIndexName() &lt;&lt; endl;
+#endif
+					if (checkTree == false)
+					{
+						if (pIndexPage-&gt;is_focus() == true)
+						{
+							break;
+						}
+					}
+					else
+					{
+						IndexTree *pIndexTree = pIndexPage-&gt;getTree();
+						if ((pIndexTree != NULL) &amp;&amp;
+							(pIndexTree-&gt;is_focus() == true))
+						{
+							break;
+						}
+					}
+					pIndexPage = NULL;
+				}
+			}
+		}
+
+		m_state.unlock();
+	}
+
+	return pIndexPage;
+}
+
+//
+// Returns the IndexPage for the given index.
+//
+IndexPage *mainWindow::get_index_page(const ustring &amp;indexName)
+{
+	IndexPage *pIndexPage = NULL;
+
+	if (m_state.readLock(8) == true)
+	{
+		for (int pageNum = 0; pageNum &lt; mainNotebook-&gt;get_n_pages(); ++pageNum)
+		{
+			Widget *pPage = mainNotebook-&gt;get_nth_page(pageNum);
+			if (pPage != NULL)
+			{
+				pIndexPage = dynamic_cast&lt;IndexPage*&gt;(pPage);
+				if (pIndexPage != NULL)
+				{
+#ifdef DEBUG
+					cout &lt;&lt; &quot;mainWindow::get_index_page: &quot; &lt;&lt; pIndexPage-&gt;getIndexName() &lt;&lt; endl;
+#endif
+					// It's an index page, check the name of the index
+					if (indexName == pIndexPage-&gt;getIndexName())
+					{
+						// That's the page we are looking for
+						break;
+					}
+					pIndexPage = NULL;
+				}
+			}
+		}
+
+		m_state.unlock();
+	}
+
+	return pIndexPage;
+}
+
+//
+// Returns the page number for the given index.
+//
+int mainWindow::get_index_page_number(const ustring &amp;indexName)
+{
+	int pageNumber = -1;
+
+	if (m_state.readLock(9) == true)
+	{
+		for (int pageNum = 0; pageNum &lt; mainNotebook-&gt;get_n_pages(); ++pageNum)
+		{
+			Widget *pPage = mainNotebook-&gt;get_nth_page(pageNum);
+			if (pPage != NULL)
+			{
+				IndexPage *pIndexPage = dynamic_cast&lt;IndexPage*&gt;(pPage);
+				if (pIndexPage != NULL)
+				{
+#ifdef DEBUG
+					cout &lt;&lt; &quot;mainWindow::get_index_page_number: &quot; &lt;&lt; pIndexPage-&gt;getIndexName() &lt;&lt; endl;
+#endif
+					// It's an index page, check the name of the index
+					if (indexName == pIndexPage-&gt;getIndexName())
+					{
+						// That's the page we are looking for
+						pageNumber = pageNum;
+						break;
+					}
+				}
+			}
+		}
+
+		m_state.unlock();
+	}
+
+	return pageNumber;
+}
+
+//
 // Queues additions to the index.
 //
 bool mainWindow::queue_index(const DocumentInfo &amp;docInfo,
@@ -2491,7 +2657,7 @@
 //
 // Browse an index
 //
-void mainWindow::browse_index(unsigned int startDoc)
+void mainWindow::browse_index(const ustring &amp;indexName, unsigned int startDoc)
 {
 	bool enableIndexOps = false;
 
@@ -2502,25 +2668,31 @@
 	}
 	m_state.m_browsingIndex = true;
 
-	// Remove existing rows in the index tree
-	m_pIndexTree-&gt;clear();
-	// Disable this
-	showlabels1-&gt;set_sensitive(false);
-	// Reset variables
-	m_state.m_indexDocsCount = 0;
+	IndexPage *pIndexPage = get_index_page(indexName);
+	if (pIndexPage != NULL)
+	{
+		IndexTree *pIndexTree = pIndexPage-&gt;getTree();
+		if (pIndexTree != NULL)
+		{
+			// Remove existing rows in the index tree
+			pIndexTree-&gt;clear();
+		}
+		// Reset variables
+		pIndexPage-&gt;setDocumentsCount(0);
 
-	if (m_state.getCurrentIndex() == _(&quot;My Documents&quot;))
+		// Switch to that index page
+		mainNotebook-&gt;set_current_page(get_index_page_number(indexName));
+	}
+
+	if (indexName == _(&quot;My Documents&quot;))
 	{
 		enableIndexOps = true;
 	}
 	import1-&gt;set_sensitive(enableIndexOps);
 
 	// Spawn a new thread to browse the index
-#ifdef DEBUG
-	cout &lt;&lt; &quot;mainWindow::browse_index: indexing &quot; &lt;&lt; m_state.getCurrentIndex() &lt;&lt; endl;
-#endif
 	IndexBrowserThread *pBrowseThread = new IndexBrowserThread(
-		locale_from_utf8(m_state.getCurrentIndex()), m_maxDocsCount, startDoc);
+		locale_from_utf8(indexName), m_maxDocsCount, startDoc);
 	pBrowseThread-&gt;getUpdateSignal().connect(SigC::slot(*this,
 		&amp;mainWindow::on_message_indexupdate));
 	start_thread(pBrowseThread);
@@ -2561,7 +2733,7 @@
 			docId = index.hasDocument(url);
 		}
 		if ((docId == 0) &amp;&amp;
-			(m_state.writeLock(4) == true))
+			(m_state.writeLock(10) == true))
 		{
 			if (m_state.m_beingIndexed.find(url) == m_state.m_beingIndexed.end())
 			{
@@ -2649,7 +2821,7 @@
 		else
 		{
 			// Display the URL in the View tab
-			mainNotebook-&gt;set_current_page(2);
+			mainNotebook-&gt;set_current_page(1);
 			if (m_pHtmlView-&gt;renderUrl(url) == true)
 			{
 				//viewstop1-&gt;set_sensitive(true);
@@ -2686,7 +2858,7 @@
 	pNewThread-&gt;getFinishedSignal().connect(SigC::slot(*this,
 		&amp;mainWindow::on_thread_end));
 
-	if (m_state.writeLock(5) == true)
+	if (m_state.writeLock(11) == true)
 	{
 		pair&lt;set&lt;WorkerThread *&gt;::iterator, bool&gt; insertPair = m_state.m_pThreads.insert(pNewThread);
 		insertedThread = insertPair.second;
@@ -2833,7 +3005,7 @@
 {
 	int count = 0;
 
-	if (m_state.readLock(5) == true)
+	if (m_state.readLock(12) == true)
 	{
 		count = m_state.m_pThreads.size() - m_state.m_backgroundThreads;
 		m_state.unlock();

Modified: trunk/UI/GTK2/src/mainWindow.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow.hh	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/mainWindow.hh	2005-12-29 09:00:55 UTC (rev 28)
@@ -36,10 +36,11 @@
 #include &quot;IndexedDocument.h&quot;
 #include &quot;ActionHistory.h&quot;
 #include &quot;QueryProperties.h&quot;
-#include &quot;HtmlView.h&quot;
 #include &quot;EnginesTree.h&quot;
-#include &quot;IndexTree.h&quot;
+#include &quot;HtmlView.h&quot;
+#include &quot;IndexPage.h&quot;
 #include &quot;ModelColumns.h&quot;
+#include &quot;NotebookTabBox.h&quot;
 #include &quot;PinotSettings.h&quot;
 #include &quot;ResultsTree.h&quot;
 #include &quot;WorkerThreads.h&quot;
@@ -55,15 +56,16 @@
 	// Utility methods
 	void populate_queryTreeview();
 	void save_queryTreeview();
-	void populate_indexCombobox();
-	void populate_labelMenu();
+	void populate_indexMenu();
 
 	// Handlers
 	void on_enginesTreeviewSelection_changed();
 	void on_queryTreeviewSelection_changed();
 	void on_resultsTreeviewSelection_changed();
-	void on_indexTreeviewSelection_changed();
-	void on_labelMenu_changed(unsigned int pos);
+	void on_indexTreeviewSelection_changed(Glib::ustring indexName);
+	void on_index_changed(Glib::ustring indexName);
+	void on_label_changed(Glib::ustring indexName, Glib::ustring labelName);
+	void on_page_closed(Glib::ustring title, NotebookTabBox::PageType type);
 	void on_thread_end();
 	void on_editindex(Glib::ustring indexName, Glib::ustring location);
 	void on_message_reception(DocumentInfo docInfo, std::string labelName);
@@ -103,21 +105,23 @@
 	virtual void on_removeQueryButton_clicked();
 	virtual void on_findQueryButton_clicked();
 
-	virtual void on_indexCombobox_changed();
+	virtual void on_indexBackButton_clicked(Glib::ustring indexName);
+	virtual void on_indexForwardButton_clicked(Glib::ustring indexName);
 
-	virtual void on_indexBackButton_clicked();
-	virtual void on_indexForwardButton_clicked();
-
 	virtual bool on_queryTreeview_button_press_event(GdkEventButton *ev);
+	virtual void on_mainNotebook_switch_page(GtkNotebookPage *p0, guint p1);
 	virtual bool on_mainWindow_delete_event(GdkEventAny *ev);
 
 	// Action methods
+	IndexPage *get_index_page_with_focus(bool checkTree);
+	IndexPage *get_index_page(const Glib::ustring &amp;indexName);
+	int get_index_page_number(const Glib::ustring &amp;indexName);
 	bool queue_index(const DocumentInfo &amp;docInfo, const std::string &amp;labelName,
 		unsigned int docId = 0);
 	bool queue_unindex(set&lt;unsigned int&gt; &amp;docIdList);
 	void edit_query(QueryProperties &amp;queryProps, bool newQuery);
 	void run_search(const QueryProperties &amp;queryProps);
-	void browse_index(unsigned int startDoc = 0);
+	void browse_index(const Glib::ustring &amp;indexName, unsigned int startDoc);
 	void index_document(const DocumentInfo &amp;docInfo, const std::string &amp;labelName,
 		unsigned int docId = 0);
 	bool view_document(const std::string &amp;url, bool internalViewerOnly = false);
@@ -143,7 +147,7 @@
 	// Results
 	ResultsTree *m_pResultsTree;
 	// Index
-	IndexTree *m_pIndexTree;
+	Gtk::Menu *m_pIndexMenu;
 	Gtk::Menu *m_pLabelsMenu;
 	ComboModelColumns m_indexNameColumns;
 	Glib::RefPtr&lt;Gtk::ListStore&gt; m_refIndexNameTree;
@@ -164,14 +168,8 @@
 			bool writeLock(unsigned int where);
 			void unlock(void);
 
-			unsigned int getCurrentLabel(std::string &amp;labelName);
-			void setCurrentLabel(unsigned int labelPos, const std::string &amp;labelName);
-			Glib::ustring getCurrentIndex(void);
-			void setCurrentIndex(const Glib::ustring &amp;indexName);
-
-			// Index
-			unsigned int m_indexDocsCount;
-			unsigned int m_startDoc;
+			// Notebook pages
+			int m_currentPage;
 			// Worker threads
 			std::set&lt;WorkerThread *&gt; m_pThreads;
 			unsigned int m_backgroundThreads;
@@ -182,10 +180,6 @@
 		protected:
 			// Read/write lock
 			pthread_rwlock_t m_rwLock;
-			// Index
-			unsigned int m_currentLabelPos;
-			std::string m_currentLabelName;
-			Glib::ustring m_currentIndexName;
 
 	} m_state;
 	static unsigned int m_maxDocsCount;

Modified: trunk/UI/GTK2/src/mainWindow_glade.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-29 09:00:55 UTC (rev 28)
@@ -1,4 +1,4 @@
-// generated 2005/12/16 0:48:33 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// generated 2005/12/29 0:33:08 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at thorgrim.dyndns.org.</A>(none)
 // using glademm V2.6.0
 //
 // DO NOT EDIT THIS FILE ! It was created using
@@ -71,7 +71,7 @@
    delete1 = NULL;
    Gtk::Menu *editMenuitem_menu = Gtk::manage(new class Gtk::Menu());
    editMenuitem = NULL;
-   Gtk::Image *image514 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-clear&quot;), Gtk::IconSize(1)));
+   Gtk::Image *image530 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-clear&quot;), Gtk::IconSize(1)));
    clearresults1 = NULL;
    showextract1 = NULL;
    searchenginegroup1 = NULL;
@@ -85,16 +85,16 @@
    indexresults1 = NULL;
    Gtk::Menu *resultsMenuitem_menu = Gtk::manage(new class Gtk::Menu());
    resultsMenuitem = NULL;
-   showlabels1 = NULL;
-   Gtk::Image *image515 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-open&quot;), Gtk::IconSize(1)));
+   list1 = NULL;
+   Gtk::Image *image531 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-open&quot;), Gtk::IconSize(1)));
    import1 = NULL;
    Gtk::MenuItem *separator3 = NULL;
    viewfromindex1 = NULL;
-   Gtk::Image *image516 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-refresh&quot;), Gtk::IconSize(1)));
+   Gtk::Image *image532 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-refresh&quot;), Gtk::IconSize(1)));
    refreshindex1 = NULL;
-   Gtk::Image *image517 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-delete&quot;), Gtk::IconSize(1)));
+   Gtk::Image *image533 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-delete&quot;), Gtk::IconSize(1)));
    unindex1 = NULL;
-   Gtk::Image *image518 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-properties&quot;), Gtk::IconSize(1)));
+   Gtk::Image *image534 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-properties&quot;), Gtk::IconSize(1)));
    showfromindex1 = NULL;
    Gtk::Menu *indexMenuitem_menu = Gtk::manage(new class Gtk::Menu());
    indexMenuitem = NULL;
@@ -142,25 +142,6 @@
    resultsVbox = Gtk::manage(new class Gtk::VBox(false, 0));
    
    Gtk::Label *resultsLabel = Gtk::manage(new class Gtk::Label(_(&quot;Results&quot;)));
-   indexCombobox = Gtk::manage(new class Gtk::ComboBox());
-   
-   Gtk::Image *image521 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-media-rewind&quot;), Gtk::IconSize(4)));
-   Gtk::Label *label52 = Gtk::manage(new class Gtk::Label(_(&quot;Show Previous&quot;)));
-   Gtk::HBox *hbox45 = Gtk::manage(new class Gtk::HBox(false, 2));
-   Gtk::Alignment *alignment31 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
-   indexBackButton = Gtk::manage(new class Gtk::Button());
-   
-   Gtk::Image *image522 = Gtk::manage(new class Gtk::Image(Gtk::StockID(&quot;gtk-media-forward&quot;), Gtk::IconSize(4)));
-   Gtk::Label *label53 = Gtk::manage(new class Gtk::Label(_(&quot;Show Next&quot;)));
-   Gtk::HBox *hbox46 = Gtk::manage(new class Gtk::HBox(false, 2));
-   Gtk::Alignment *alignment32 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
-   indexForwardButton = Gtk::manage(new class Gtk::Button());
-   
-   Gtk::HButtonBox *indexHbuttonbox = Gtk::manage(new class Gtk::HButtonBox(Gtk::BUTTONBOX_SPREAD, 0));
-   Gtk::HBox *indexButtonsHbox = Gtk::manage(new class Gtk::HBox(false, 0));
-   indexVbox = Gtk::manage(new class Gtk::VBox(false, 0));
-   
-   Gtk::Label *indexLabel = Gtk::manage(new class Gtk::Label(_(&quot;Index&quot;)));
    viewVbox = Gtk::manage(new class Gtk::VBox(false, 0));
    
    Gtk::Label *viewLabel = Gtk::manage(new class Gtk::Label(_(&quot;View&quot;)));
@@ -201,7 +182,7 @@
    groupresults1_menu-&gt;items().push_back(Gtk::Menu_Helpers::RadioMenuElem(_RadioMIGroup_searchenginegroup1, _(&quot;Host Name&quot;)));
    hostnamegroup1 = (Gtk::RadioMenuItem *)&amp;groupresults1_menu-&gt;items().back();
    
-   resultsMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Clear List&quot;), *image514));
+   resultsMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Clear List&quot;), *image530));
    clearresults1 = (Gtk::ImageMenuItem *)&amp;resultsMenuitem_menu-&gt;items().back();
    
    resultsMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::CheckMenuElem(_(&quot;Show Extract&quot;)));
@@ -222,10 +203,10 @@
    resultsMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;_Index&quot;)));
    indexresults1 = (Gtk::MenuItem *)&amp;resultsMenuitem_menu-&gt;items().back();
    
-   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;Show Label&quot;)));
-   showlabels1 = (Gtk::MenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
+   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;List Contents Of&quot;)));
+   list1 = (Gtk::MenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
    
-   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Import&quot;), *image515));
+   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Import&quot;), *image531));
    import1 = (Gtk::ImageMenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
    
    indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::SeparatorElem());
@@ -234,13 +215,13 @@
    indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;View&quot;)));
    viewfromindex1 = (Gtk::MenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
    
-   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Update&quot;), *image516));
+   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Update&quot;), *image532));
    refreshindex1 = (Gtk::ImageMenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
    
-   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Unindex&quot;), *image517));
+   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Unindex&quot;), *image533));
    unindex1 = (Gtk::ImageMenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
    
-   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Properties&quot;), *image518));
+   indexMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_(&quot;Properties&quot;), *image534));
    showfromindex1 = (Gtk::ImageMenuItem *)&amp;indexMenuitem_menu-&gt;items().back();
    
    helpMenuitem_menu-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;_About&quot;)));
@@ -260,19 +241,19 @@
    
    mainMenubar-&gt;items().push_back(Gtk::Menu_Helpers::MenuElem(_(&quot;_Help&quot;), *helpMenuitem_menu));
    helpMenuitem = (Gtk::MenuItem *)&amp;mainMenubar-&gt;items().back();
-   image514-&gt;set_alignment(0.5,0.5);
-   image514-&gt;set_padding(0,0);
+   image530-&gt;set_alignment(0.5,0.5);
+   image530-&gt;set_padding(0,0);
    showextract1-&gt;set_active(true);
    searchenginegroup1-&gt;set_active(true);
    hostnamegroup1-&gt;set_active(false);
-   image515-&gt;set_alignment(0.5,0.5);
-   image515-&gt;set_padding(0,0);
-   image516-&gt;set_alignment(0.5,0.5);
-   image516-&gt;set_padding(0,0);
-   image517-&gt;set_alignment(0.5,0.5);
-   image517-&gt;set_padding(0,0);
-   image518-&gt;set_alignment(0.5,0.5);
-   image518-&gt;set_padding(0,0);
+   image531-&gt;set_alignment(0.5,0.5);
+   image531-&gt;set_padding(0,0);
+   image532-&gt;set_alignment(0.5,0.5);
+   image532-&gt;set_padding(0,0);
+   image533-&gt;set_alignment(0.5,0.5);
+   image533-&gt;set_padding(0,0);
+   image534-&gt;set_alignment(0.5,0.5);
+   image534-&gt;set_padding(0,0);
    image439-&gt;set_alignment(0.5,0.5);
    image439-&gt;set_padding(0,0);
    addIndexButton-&gt;set_flags(Gtk::CAN_FOCUS);
@@ -375,47 +356,6 @@
    resultsLabel-&gt;set_line_wrap(false);
    resultsLabel-&gt;set_use_markup(false);
    resultsLabel-&gt;set_selectable(false);
-   image521-&gt;set_alignment(0.5,0.5);
-   image521-&gt;set_padding(0,0);
-   label52-&gt;set_alignment(0.5,0.5);
-   label52-&gt;set_padding(0,0);
-   label52-&gt;set_justify(Gtk::JUSTIFY_LEFT);
-   label52-&gt;set_line_wrap(false);
-   label52-&gt;set_use_markup(false);
-   label52-&gt;set_selectable(false);
-   hbox45-&gt;pack_start(*image521, Gtk::PACK_SHRINK, 0);
-   hbox45-&gt;pack_start(*label52, Gtk::PACK_SHRINK, 0);
-   alignment31-&gt;add(*hbox45);
-   indexBackButton-&gt;set_flags(Gtk::CAN_FOCUS);
-   indexBackButton-&gt;set_flags(Gtk::CAN_DEFAULT);
-   indexBackButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
-   indexBackButton-&gt;add(*alignment31);
-   image522-&gt;set_alignment(0.5,0.5);
-   image522-&gt;set_padding(0,0);
-   label53-&gt;set_alignment(0.5,0.5);
-   label53-&gt;set_padding(0,0);
-   label53-&gt;set_justify(Gtk::JUSTIFY_LEFT);
-   label53-&gt;set_line_wrap(false);
-   label53-&gt;set_use_markup(false);
-   label53-&gt;set_selectable(false);
-   hbox46-&gt;pack_start(*image522, Gtk::PACK_SHRINK, 0);
-   hbox46-&gt;pack_start(*label53, Gtk::PACK_SHRINK, 0);
-   alignment32-&gt;add(*hbox46);
-   indexForwardButton-&gt;set_flags(Gtk::CAN_FOCUS);
-   indexForwardButton-&gt;set_flags(Gtk::CAN_DEFAULT);
-   indexForwardButton-&gt;set_relief(Gtk::RELIEF_NORMAL);
-   indexForwardButton-&gt;add(*alignment32);
-   indexHbuttonbox-&gt;pack_start(*indexBackButton);
-   indexHbuttonbox-&gt;pack_start(*indexForwardButton);
-   indexButtonsHbox-&gt;pack_start(*indexCombobox, Gtk::PACK_SHRINK, 4);
-   indexButtonsHbox-&gt;pack_start(*indexHbuttonbox, Gtk::PACK_SHRINK, 4);
-   indexVbox-&gt;pack_start(*indexButtonsHbox, Gtk::PACK_SHRINK, 4);
-   indexLabel-&gt;set_alignment(0.5,0.5);
-   indexLabel-&gt;set_padding(0,0);
-   indexLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
-   indexLabel-&gt;set_line_wrap(false);
-   indexLabel-&gt;set_use_markup(false);
-   indexLabel-&gt;set_selectable(false);
    viewLabel-&gt;set_alignment(0.5,0.5);
    viewLabel-&gt;set_padding(0,0);
    viewLabel-&gt;set_justify(Gtk::JUSTIFY_LEFT);
@@ -429,8 +369,6 @@
    mainNotebook-&gt;set_scrollable(false);
    mainNotebook-&gt;append_page(*resultsVbox, *resultsLabel);
    mainNotebook-&gt;pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
-   mainNotebook-&gt;append_page(*indexVbox, *indexLabel);
-   mainNotebook-&gt;pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
    mainNotebook-&gt;append_page(*viewVbox, *viewLabel);
    mainNotebook-&gt;pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
    rightVbox-&gt;pack_start(*liveQueryHbox, Gtk::PACK_SHRINK, 0);
@@ -462,7 +400,7 @@
    paste1-&gt;show();
    delete1-&gt;show();
    editMenuitem-&gt;show();
-   image514-&gt;show();
+   image530-&gt;show();
    clearresults1-&gt;show();
    showextract1-&gt;show();
    searchenginegroup1-&gt;show();
@@ -473,16 +411,16 @@
    viewcache1-&gt;show();
    indexresults1-&gt;show();
    resultsMenuitem-&gt;show();
-   showlabels1-&gt;show();
-   image515-&gt;show();
+   list1-&gt;show();
+   image531-&gt;show();
    import1-&gt;show();
    separator3-&gt;show();
    viewfromindex1-&gt;show();
-   image516-&gt;show();
+   image532-&gt;show();
    refreshindex1-&gt;show();
-   image517-&gt;show();
+   image533-&gt;show();
    unindex1-&gt;show();
-   image518-&gt;show();
+   image534-&gt;show();
    showfromindex1-&gt;show();
    indexMenuitem-&gt;show();
    about1-&gt;show();
@@ -516,21 +454,6 @@
    queryExpander-&gt;show();
    resultsVbox-&gt;show();
    resultsLabel-&gt;show();
-   indexCombobox-&gt;show();
-   image521-&gt;show();
-   label52-&gt;show();
-   hbox45-&gt;show();
-   alignment31-&gt;show();
-   indexBackButton-&gt;show();
-   image522-&gt;show();
-   label53-&gt;show();
-   hbox46-&gt;show();
-   alignment32-&gt;show();
-   indexForwardButton-&gt;show();
-   indexHbuttonbox-&gt;show();
-   indexButtonsHbox-&gt;show();
-   indexVbox-&gt;show();
-   indexLabel-&gt;show();
    viewVbox-&gt;show();
    viewLabel-&gt;show();
    mainNotebook-&gt;show();
@@ -567,9 +490,7 @@
    editQueryButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_editQueryButton_clicked), false);
    removeQueryButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_removeQueryButton_clicked), false);
    findQueryButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_findQueryButton_clicked), false);
-   indexCombobox-&gt;signal_changed().connect(SigC::slot(*this, &amp;mainWindow_glade::on_indexCombobox_changed), false);
-   indexBackButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_indexBackButton_clicked), false);
-   indexForwardButton-&gt;signal_clicked().connect(SigC::slot(*this, &amp;mainWindow_glade::on_indexForwardButton_clicked), false);
+   mainNotebook-&gt;signal_switch_page().connect(SigC::slot(*this, &amp;mainWindow_glade::on_mainNotebook_switch_page), false);
    mainWindow-&gt;signal_delete_event().connect(SigC::slot(*this, &amp;mainWindow_glade::on_mainWindow_delete_event), false);
 }
 

Modified: trunk/UI/GTK2/src/mainWindow_glade.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.hh	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/mainWindow_glade.hh	2005-12-29 09:00:55 UTC (rev 28)
@@ -1,4 +1,4 @@
-// generated 2005/12/16 0:34:21 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at amra.dyndns.org.</A>(none)
+// generated 2005/12/29 0:33:08 SGT by <A HREF="https://lists.berlios.de/mailman/listinfo/pinot-svn">fabrice at thorgrim.dyndns.org.</A>(none)
 // using glademm V2.6.0
 //
 // DO NOT EDIT THIS FILE ! It was created using
@@ -45,7 +45,6 @@
 #else //
 #include &lt;gtkmm/handlebox.h&gt;
 #endif //
-#include &lt;gtkmm/combobox.h&gt;
 #include &lt;gtkmm/notebook.h&gt;
 #include &lt;gtkmm/paned.h&gt;
 #include &lt;gtkmm/progressbar.h&gt;
@@ -75,7 +74,7 @@
         class Gtk::MenuItem * viewcache1;
         class Gtk::MenuItem * indexresults1;
         class Gtk::MenuItem * resultsMenuitem;
-        class Gtk::MenuItem * showlabels1;
+        class Gtk::MenuItem * list1;
         class Gtk::ImageMenuItem * import1;
         class Gtk::MenuItem * viewfromindex1;
         class Gtk::ImageMenuItem * refreshindex1;
@@ -100,10 +99,6 @@
         class Gtk::HandleBox * queryExpander;
 #endif //
         class Gtk::VBox * resultsVbox;
-        class Gtk::ComboBox * indexCombobox;
-        class Gtk::Button * indexBackButton;
-        class Gtk::Button * indexForwardButton;
-        class Gtk::VBox * indexVbox;
         class Gtk::VBox * viewVbox;
         class Gtk::Notebook * mainNotebook;
         class Gtk::HPaned * mainHpaned;
@@ -140,9 +135,7 @@
         virtual void on_editQueryButton_clicked() = 0;
         virtual void on_removeQueryButton_clicked() = 0;
         virtual void on_findQueryButton_clicked() = 0;
-        virtual void on_indexCombobox_changed() = 0;
-        virtual void on_indexBackButton_clicked() = 0;
-        virtual void on_indexForwardButton_clicked() = 0;
+        virtual void on_mainNotebook_switch_page(GtkNotebookPage *p0, guint p1) = 0;
         virtual bool on_mainWindow_delete_event(GdkEventAny *ev) = 0;
 };
 #endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000026.html">[Pinot-svn] r27 - tags
</A></li>
	<LI>Next message: <A HREF="000028.html">[Pinot-svn] r29 - in trunk/UI: GTK2 GTK2/src RenderHTML
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27">[ date ]</a>
              <a href="thread.html#27">[ thread ]</a>
              <a href="subject.html#27">[ subject ]</a>
              <a href="author.html#27">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/pinot-svn">More information about the Pinot-svn
mailing list</a><br>
</body></html>
