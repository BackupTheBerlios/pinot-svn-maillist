<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Pinot-svn] r188 - trunk/Search/Google
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/pinot-svn/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r188%20-%20trunk/Search/Google&In-Reply-To=%3C200604051307.k35D71oV020392%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000185.html">
   <LINK REL="Next"  HREF="000186.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Pinot-svn] r188 - trunk/Search/Google</H1>
    <B>fabricecolin at BerliOS</B> 
    <A HREF="mailto:pinot-svn%40lists.berlios.de?Subject=Re%3A%20%5BPinot-svn%5D%20r188%20-%20trunk/Search/Google&In-Reply-To=%3C200604051307.k35D71oV020392%40sheep.berlios.de%3E"
       TITLE="[Pinot-svn] r188 - trunk/Search/Google">fabricecolin at berlios.de
       </A><BR>
    <I>Wed Apr  5 15:07:02 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000185.html">[Pinot-svn] r187 - trunk/UI/GTK2/src
</A></li>
        <LI>Next message: <A HREF="000186.html">[Pinot-svn] r189 - trunk/Search/Google
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#187">[ date ]</a>
              <a href="thread.html#187">[ thread ]</a>
              <a href="subject.html#187">[ subject ]</a>
              <a href="author.html#187">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fabricecolin
Date: 2006-04-05 15:06:48 +0200 (Wed, 05 Apr 2006)
New Revision: 188

Added:
   trunk/Search/Google/GAPI.nsmap
   trunk/Search/Google/GAPIC.cpp
   trunk/Search/Google/GAPIClient.cpp
   trunk/Search/Google/GAPIClientLib.cpp
   trunk/Search/Google/GAPIGoogleSearchBindingProxy.h
   trunk/Search/Google/GAPIH.h
   trunk/Search/Google/GAPIStub.h
Log:
Checking in gSOAP-generated (v2.7.6e) client stubs. They shouldn't have to be
regenerated too often and one of them needs to be fixed (see next commit :-).


Added: trunk/Search/Google/GAPI.nsmap
===================================================================
--- trunk/Search/Google/GAPI.nsmap	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPI.nsmap	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,11 @@
+
+#include &quot;GAPIH.h&quot;
+SOAP_NMAC struct Namespace GAPI_namespaces[] =
+{
+	{&quot;SOAP-ENV&quot;, &quot;<A HREF="http://schemas.xmlsoap.org/soap/envelope/">http://schemas.xmlsoap.org/soap/envelope/</A>&quot;, &quot;<A HREF="http://www.w3.org/*/soap-envelope">http://www.w3.org/*/soap-envelope</A>&quot;, NULL},
+	{&quot;SOAP-ENC&quot;, &quot;<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>&quot;, &quot;<A HREF="http://www.w3.org/*/soap-encoding">http://www.w3.org/*/soap-encoding</A>&quot;, NULL},
+	{&quot;xsi&quot;, &quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot;, &quot;<A HREF="http://www.w3.org/*/XMLSchema-instance">http://www.w3.org/*/XMLSchema-instance</A>&quot;, NULL},
+	{&quot;xsd&quot;, &quot;<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>&quot;, &quot;<A HREF="http://www.w3.org/*/XMLSchema">http://www.w3.org/*/XMLSchema</A>&quot;, NULL},
+	{&quot;gapi1&quot;, &quot;urn:GoogleSearch&quot;, NULL, NULL},
+	{NULL, NULL, NULL, NULL}
+};

Added: trunk/Search/Google/GAPIC.cpp
===================================================================
--- trunk/Search/Google/GAPIC.cpp	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPIC.cpp	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,4187 @@
+/* GAPIC.cpp
+   Generated by gSOAP 2.7.6e from GoogleSearch.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+
+#include &quot;GAPIH.h&quot;
+
+SOAP_SOURCE_STAMP(&quot;@(#) GAPIC.cpp ver 2.7.6e 2006-04-05 04:17:23 GMT&quot;)
+
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
+{
+	if (soap-&gt;header)
+		soap_serialize_SOAP_ENV__Header(soap, soap-&gt;header);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
+{
+	if (soap-&gt;header)
+	{	soap-&gt;part = SOAP_IN_HEADER;
+		soap_out_SOAP_ENV__Header(soap, &quot;SOAP-ENV:Header&quot;, 0, soap-&gt;header, NULL);
+		soap-&gt;part = SOAP_END_HEADER;
+	}
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
+{
+	soap-&gt;part = SOAP_IN_HEADER;
+	soap-&gt;header = soap_in_SOAP_ENV__Header(soap, &quot;SOAP-ENV:Header&quot;, NULL, NULL);
+	soap-&gt;part = SOAP_END_HEADER;
+	return soap-&gt;header == NULL;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
+{
+	if (!soap-&gt;fault)
+	{	soap-&gt;fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
+		soap_default_SOAP_ENV__Fault(soap, soap-&gt;fault);
+	}
+	if (soap-&gt;version == 2 &amp;&amp; !soap-&gt;fault-&gt;SOAP_ENV__Code)
+	{	soap-&gt;fault-&gt;SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
+		soap_default_SOAP_ENV__Code(soap, soap-&gt;fault-&gt;SOAP_ENV__Code);
+	}
+	if (soap-&gt;version == 2 &amp;&amp; !soap-&gt;fault-&gt;SOAP_ENV__Reason)
+	{	soap-&gt;fault-&gt;SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
+		soap_default_SOAP_ENV__Reason(soap, soap-&gt;fault-&gt;SOAP_ENV__Reason);
+	}
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
+{
+	if (soap-&gt;fault)
+		soap_serialize_SOAP_ENV__Fault(soap, soap-&gt;fault);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
+{
+	if (soap-&gt;fault)
+		return soap_put_SOAP_ENV__Fault(soap, soap-&gt;fault, &quot;SOAP-ENV:Fault&quot;, NULL);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
+{
+	return (soap-&gt;fault = soap_get_SOAP_ENV__Fault(soap, NULL, &quot;SOAP-ENV:Fault&quot;, NULL)) == NULL;
+}
+
+SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
+{
+	soap_fault(soap);
+	if (soap-&gt;version == 2)
+		return (const char**)&amp;soap-&gt;fault-&gt;SOAP_ENV__Code-&gt;SOAP_ENV__Value;
+	return (const char**)&amp;soap-&gt;fault-&gt;faultcode;
+}
+
+SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
+{
+	soap_fault(soap);
+	if (soap-&gt;version == 2)
+	{	if (!soap-&gt;fault-&gt;SOAP_ENV__Code-&gt;SOAP_ENV__Subcode)
+		{	soap-&gt;fault-&gt;SOAP_ENV__Code-&gt;SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
+			soap_default_SOAP_ENV__Code(soap, soap-&gt;fault-&gt;SOAP_ENV__Code-&gt;SOAP_ENV__Subcode);
+		}
+		return (const char**)&amp;soap-&gt;fault-&gt;SOAP_ENV__Code-&gt;SOAP_ENV__Subcode-&gt;SOAP_ENV__Value;
+	}
+	return (const char**)&amp;soap-&gt;fault-&gt;faultcode;
+}
+
+SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
+{
+	soap_fault(soap);
+	if (soap-&gt;version == 2)
+		return (const char**)&amp;soap-&gt;fault-&gt;SOAP_ENV__Reason-&gt;SOAP_ENV__Text;
+	return (const char**)&amp;soap-&gt;fault-&gt;faultstring;
+}
+
+SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
+{
+	soap_fault(soap);
+	if (soap-&gt;version == 1)
+	{	if (!soap-&gt;fault-&gt;detail)
+		{	soap-&gt;fault-&gt;detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
+			soap_default_SOAP_ENV__Detail(soap, soap-&gt;fault-&gt;detail);
+		}
+		return (const char**)&amp;soap-&gt;fault-&gt;detail-&gt;__any;
+	}
+	if (!soap-&gt;fault-&gt;SOAP_ENV__Detail)
+	{	soap-&gt;fault-&gt;SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
+		soap_default_SOAP_ENV__Detail(soap, soap-&gt;fault-&gt;SOAP_ENV__Detail);
+	}
+	return (const char**)&amp;soap-&gt;fault-&gt;SOAP_ENV__Detail-&gt;__any;
+}
+
+#endif
+
+#ifndef WITH_NOIDREF
+SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
+{
+	int t;
+	for (;;)
+		if (!soap_getelement(soap, &amp;t))
+			if (soap-&gt;error || soap_ignore_element(soap))
+				break;
+	if (soap-&gt;error == SOAP_NO_TAG || soap-&gt;error == SOAP_EOF)
+		soap-&gt;error = SOAP_OK;
+	return soap-&gt;error;
+}
+#endif
+
+#ifndef WITH_NOIDREF
+SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
+{
+	if (soap_peek_element(soap))
+		return NULL;
+	if (!*soap-&gt;id || !(*type = soap_lookup_type(soap, soap-&gt;id)))
+		*type = soap_lookup_type(soap, soap-&gt;href);
+	switch (*type)
+	{
+	case SOAP_TYPE_byte:
+		return soap_in_byte(soap, NULL, NULL, &quot;xsd:byte&quot;);
+	case SOAP_TYPE_int:
+		return soap_in_int(soap, NULL, NULL, &quot;xsd:int&quot;);
+	case SOAP_TYPE_double:
+		return soap_in_double(soap, NULL, NULL, &quot;xsd:double&quot;);
+	case SOAP_TYPE_unsignedByte:
+		return soap_in_unsignedByte(soap, NULL, NULL, &quot;xsd:unsignedByte&quot;);
+	case SOAP_TYPE_unsignedInt:
+		return soap_in_unsignedInt(soap, NULL, NULL, &quot;xsd:unsignedInt&quot;);
+	case SOAP_TYPE_bool:
+		return soap_in_bool(soap, NULL, NULL, &quot;xsd:boolean&quot;);
+	case SOAP_TYPE_gapi1__DirectoryCategory:
+		return soap_in_gapi1__DirectoryCategory(soap, NULL, NULL, &quot;gapi1:DirectoryCategory&quot;);
+	case SOAP_TYPE_gapi1DirectoryCategoryArray:
+		return soap_in_gapi1DirectoryCategoryArray(soap, NULL, NULL, &quot;gapi1:DirectoryCategory&quot;);
+	case SOAP_TYPE_gapi1ResultElementArray:
+		return soap_in_gapi1ResultElementArray(soap, NULL, NULL, &quot;gapi1:ResultElement&quot;);
+	case SOAP_TYPE_gapi1__ResultElement:
+		return soap_in_gapi1__ResultElement(soap, NULL, NULL, &quot;gapi1:ResultElement&quot;);
+	case SOAP_TYPE_gapi1__GoogleSearchResult:
+		return soap_in_gapi1__GoogleSearchResult(soap, NULL, NULL, &quot;gapi1:GoogleSearchResult&quot;);
+	case SOAP_TYPE__SOAP_ENC__arrayType:
+		return soap_in__SOAP_ENC__arrayType(soap, NULL, NULL, &quot;SOAP-ENC:arrayType&quot;);
+	case SOAP_TYPE_std__string:
+		return soap_in_std__string(soap, NULL, NULL, &quot;xsd:string&quot;);
+	case SOAP_TYPE_xsd__base64Binary:
+		return soap_in_xsd__base64Binary(soap, NULL, NULL, &quot;xsd:base64Binary&quot;);
+	case SOAP_TYPE_gapi1__doGoogleSearch:
+		return soap_in_gapi1__doGoogleSearch(soap, NULL, NULL, &quot;gapi1:doGoogleSearch&quot;);
+	case SOAP_TYPE_gapi1__doGoogleSearchResponse:
+		return soap_in_gapi1__doGoogleSearchResponse(soap, NULL, NULL, &quot;gapi1:doGoogleSearchResponse&quot;);
+	case SOAP_TYPE_gapi1__doSpellingSuggestion:
+		return soap_in_gapi1__doSpellingSuggestion(soap, NULL, NULL, &quot;gapi1:doSpellingSuggestion&quot;);
+	case SOAP_TYPE_gapi1__doSpellingSuggestionResponse:
+		return soap_in_gapi1__doSpellingSuggestionResponse(soap, NULL, NULL, &quot;gapi1:doSpellingSuggestionResponse&quot;);
+	case SOAP_TYPE_gapi1__doGetCachedPage:
+		return soap_in_gapi1__doGetCachedPage(soap, NULL, NULL, &quot;gapi1:doGetCachedPage&quot;);
+	case SOAP_TYPE_gapi1__doGetCachedPageResponse:
+		return soap_in_gapi1__doGetCachedPageResponse(soap, NULL, NULL, &quot;gapi1:doGetCachedPageResponse&quot;);
+	case SOAP_TYPE_PointerTogapi1__GoogleSearchResult:
+		return soap_in_PointerTogapi1__GoogleSearchResult(soap, NULL, NULL, &quot;gapi1:GoogleSearchResult&quot;);
+	case SOAP_TYPE_PointerToPointerTogapi1__DirectoryCategory:
+		return soap_in_PointerToPointerTogapi1__DirectoryCategory(soap, NULL, NULL, &quot;gapi1:DirectoryCategory&quot;);
+	case SOAP_TYPE_PointerToPointerTogapi1__ResultElement:
+		return soap_in_PointerToPointerTogapi1__ResultElement(soap, NULL, NULL, &quot;gapi1:ResultElement&quot;);
+	case SOAP_TYPE_PointerTogapi1__ResultElement:
+		return soap_in_PointerTogapi1__ResultElement(soap, NULL, NULL, &quot;gapi1:ResultElement&quot;);
+	case SOAP_TYPE_PointerTogapi1__DirectoryCategory:
+		return soap_in_PointerTogapi1__DirectoryCategory(soap, NULL, NULL, &quot;gapi1:DirectoryCategory&quot;);
+	case SOAP_TYPE_PointerTogapi1DirectoryCategoryArray:
+		return soap_in_PointerTogapi1DirectoryCategoryArray(soap, NULL, NULL, &quot;gapi1:DirectoryCategory&quot;);
+	case SOAP_TYPE_PointerTogapi1ResultElementArray:
+		return soap_in_PointerTogapi1ResultElementArray(soap, NULL, NULL, &quot;gapi1:ResultElement&quot;);
+	case SOAP_TYPE_PointerTounsignedByte:
+		return soap_in_PointerTounsignedByte(soap, NULL, NULL, &quot;xsd:unsignedByte&quot;);
+	case SOAP_TYPE__QName:
+	{	char **s;
+		s = soap_in__QName(soap, NULL, NULL, &quot;QName&quot;);
+		return s ? *s : NULL;
+	}
+	case SOAP_TYPE_string:
+	{	char **s;
+		s = soap_in_string(soap, NULL, NULL, &quot;xsd:string&quot;);
+		return s ? *s : NULL;
+	}
+	default:
+	{	const char *t = soap-&gt;type;
+		if (!*t)
+			t = soap-&gt;tag;
+		if (!soap_match_tag(soap, t, &quot;xsd:byte&quot;))
+		{	*type = SOAP_TYPE_byte;
+			return soap_in_byte(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;xsd:int&quot;))
+		{	*type = SOAP_TYPE_int;
+			return soap_in_int(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;xsd:double&quot;))
+		{	*type = SOAP_TYPE_double;
+			return soap_in_double(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;xsd:unsignedByte&quot;))
+		{	*type = SOAP_TYPE_unsignedByte;
+			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;xsd:unsignedInt&quot;))
+		{	*type = SOAP_TYPE_unsignedInt;
+			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;xsd:boolean&quot;))
+		{	*type = SOAP_TYPE_bool;
+			return soap_in_bool(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;gapi1:DirectoryCategory&quot;))
+		{	*type = SOAP_TYPE_gapi1__DirectoryCategory;
+			return soap_in_gapi1__DirectoryCategory(soap, NULL, NULL, NULL);
+		}
+		if (*soap-&gt;arrayType &amp;&amp; !soap_match_array(soap, &quot;gapi1:DirectoryCategory&quot;))
+		{	*type = SOAP_TYPE_gapi1DirectoryCategoryArray;
+			return soap_in_gapi1DirectoryCategoryArray(soap, NULL, NULL, NULL);
+		}
+		if (*soap-&gt;arrayType &amp;&amp; !soap_match_array(soap, &quot;gapi1:ResultElement&quot;))
+		{	*type = SOAP_TYPE_gapi1ResultElementArray;
+			return soap_in_gapi1ResultElementArray(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;gapi1:ResultElement&quot;))
+		{	*type = SOAP_TYPE_gapi1__ResultElement;
+			return soap_in_gapi1__ResultElement(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;gapi1:GoogleSearchResult&quot;))
+		{	*type = SOAP_TYPE_gapi1__GoogleSearchResult;
+			return soap_in_gapi1__GoogleSearchResult(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;SOAP-ENC:arrayType&quot;))
+		{	*type = SOAP_TYPE__SOAP_ENC__arrayType;
+			return soap_in__SOAP_ENC__arrayType(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;xsd:string&quot;))
+		{	*type = SOAP_TYPE_std__string;
+			return soap_in_std__string(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;xsd:base64Binary&quot;))
+		{	*type = SOAP_TYPE_xsd__base64Binary;
+			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;gapi1:doGoogleSearch&quot;))
+		{	*type = SOAP_TYPE_gapi1__doGoogleSearch;
+			return soap_in_gapi1__doGoogleSearch(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;gapi1:doGoogleSearchResponse&quot;))
+		{	*type = SOAP_TYPE_gapi1__doGoogleSearchResponse;
+			return soap_in_gapi1__doGoogleSearchResponse(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;gapi1:doSpellingSuggestion&quot;))
+		{	*type = SOAP_TYPE_gapi1__doSpellingSuggestion;
+			return soap_in_gapi1__doSpellingSuggestion(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;gapi1:doSpellingSuggestionResponse&quot;))
+		{	*type = SOAP_TYPE_gapi1__doSpellingSuggestionResponse;
+			return soap_in_gapi1__doSpellingSuggestionResponse(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;gapi1:doGetCachedPage&quot;))
+		{	*type = SOAP_TYPE_gapi1__doGetCachedPage;
+			return soap_in_gapi1__doGetCachedPage(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;gapi1:doGetCachedPageResponse&quot;))
+		{	*type = SOAP_TYPE_gapi1__doGetCachedPageResponse;
+			return soap_in_gapi1__doGetCachedPageResponse(soap, NULL, NULL, NULL);
+		}
+		if (!soap_match_tag(soap, t, &quot;QName&quot;))
+		{	char **s;
+			*type = SOAP_TYPE__QName;
+			s = soap_in__QName(soap, NULL, NULL, NULL);
+			return s ? *s : NULL;
+		}
+		if (!soap_match_tag(soap, t, &quot;xsd:string&quot;))
+		{	char **s;
+			*type = SOAP_TYPE_string;
+			s = soap_in_string(soap, NULL, NULL, NULL);
+			return s ? *s : NULL;
+		}
+	}
+	}
+	soap-&gt;error = SOAP_TAG_MISMATCH;
+	return NULL;
+}
+#endif
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
+{
+	if (!soap_peek_element(soap))
+	{	int t;
+		if (soap-&gt;mustUnderstand &amp;&amp; !soap-&gt;other)
+			return soap-&gt;error = SOAP_MUSTUNDERSTAND;
+		if (((soap-&gt;mode &amp; SOAP_XML_STRICT) &amp;&amp; soap-&gt;part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap-&gt;tag, &quot;SOAP-ENV:&quot;))
+			return soap-&gt;error = SOAP_TAG_MISMATCH;
+		if (!*soap-&gt;id || !soap_getelement(soap, &amp;t))
+		{	soap-&gt;peeked = 0;
+			DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Unknown element '%s' (level=%u, %d)\n&quot;, soap-&gt;tag, soap-&gt;level, soap-&gt;body));
+			if (soap-&gt;fignore)
+				soap-&gt;error = soap-&gt;fignore(soap, soap-&gt;tag);
+			else
+				soap-&gt;error = SOAP_OK;
+			DBGLOG(TEST, if (!soap-&gt;error) SOAP_MESSAGE(fdebug, &quot;IGNORING element '%s'\n&quot;, soap-&gt;tag));
+			if (!soap-&gt;error &amp;&amp; soap-&gt;body)
+			{	soap-&gt;level++;
+				while (!soap_ignore_element(soap))
+					;
+				if (soap-&gt;error == SOAP_NO_TAG)
+					soap-&gt;error = soap_element_end_in(soap, NULL);
+			}
+		}
+	}
+	return soap-&gt;error;
+}
+
+#ifndef WITH_NOIDREF
+SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
+{
+	int i;
+	struct soap_plist *pp;
+	if (soap-&gt;version == 1 &amp;&amp; soap-&gt;encodingStyle &amp;&amp; !(soap-&gt;mode &amp; (SOAP_XML_TREE | SOAP_XML_GRAPH)))
+		for (i = 0; i &lt; SOAP_PTRHASH; i++)
+			for (pp = soap-&gt;pht[i]; pp; pp = pp-&gt;next)
+				if (pp-&gt;mark1 == 2 || pp-&gt;mark2 == 2)
+					if (soap_putelement(soap, pp-&gt;ptr, &quot;id&quot;, pp-&gt;id, pp-&gt;type))
+						return soap-&gt;error;
+	return SOAP_OK;
+}
+#endif
+
+#ifndef WITH_NOIDREF
+SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
+{
+	switch (type)
+	{
+	case SOAP_TYPE_byte:
+		return soap_out_byte(soap, tag, id, (const char *)ptr, &quot;xsd:byte&quot;);
+	case SOAP_TYPE_int:
+		return soap_out_int(soap, tag, id, (const int *)ptr, &quot;xsd:int&quot;);
+	case SOAP_TYPE_double:
+		return soap_out_double(soap, tag, id, (const double *)ptr, &quot;xsd:double&quot;);
+	case SOAP_TYPE_unsignedByte:
+		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, &quot;xsd:unsignedByte&quot;);
+	case SOAP_TYPE_unsignedInt:
+		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, &quot;xsd:unsignedInt&quot;);
+	case SOAP_TYPE_bool:
+		return soap_out_bool(soap, tag, id, (const bool *)ptr, &quot;xsd:boolean&quot;);
+	case SOAP_TYPE_gapi1__DirectoryCategory:
+		return ((gapi1__DirectoryCategory *)ptr)-&gt;soap_out(soap, tag, id, &quot;gapi1:DirectoryCategory&quot;);
+	case SOAP_TYPE_gapi1DirectoryCategoryArray:
+		return ((gapi1DirectoryCategoryArray *)ptr)-&gt;soap_out(soap, tag, id, &quot;gapi1:DirectoryCategory&quot;);
+	case SOAP_TYPE_gapi1ResultElementArray:
+		return ((gapi1ResultElementArray *)ptr)-&gt;soap_out(soap, tag, id, &quot;gapi1:ResultElement&quot;);
+	case SOAP_TYPE_gapi1__ResultElement:
+		return ((gapi1__ResultElement *)ptr)-&gt;soap_out(soap, tag, id, &quot;gapi1:ResultElement&quot;);
+	case SOAP_TYPE_gapi1__GoogleSearchResult:
+		return ((gapi1__GoogleSearchResult *)ptr)-&gt;soap_out(soap, tag, id, &quot;gapi1:GoogleSearchResult&quot;);
+	case SOAP_TYPE__SOAP_ENC__arrayType:
+		return soap_out__SOAP_ENC__arrayType(soap, &quot;SOAP-ENC:arrayType&quot;, id, (const std::string *)ptr, NULL);
+	case SOAP_TYPE_std__string:
+		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, &quot;xsd:string&quot;);
+	case SOAP_TYPE_xsd__base64Binary:
+		return ((xsd__base64Binary *)ptr)-&gt;soap_out(soap, tag, id, &quot;xsd:base64Binary&quot;);
+	case SOAP_TYPE_gapi1__doGoogleSearch:
+		return soap_out_gapi1__doGoogleSearch(soap, tag, id, (const struct gapi1__doGoogleSearch *)ptr, &quot;gapi1:doGoogleSearch&quot;);
+	case SOAP_TYPE_gapi1__doGoogleSearchResponse:
+		return soap_out_gapi1__doGoogleSearchResponse(soap, tag, id, (const struct gapi1__doGoogleSearchResponse *)ptr, &quot;gapi1:doGoogleSearchResponse&quot;);
+	case SOAP_TYPE_gapi1__doSpellingSuggestion:
+		return soap_out_gapi1__doSpellingSuggestion(soap, tag, id, (const struct gapi1__doSpellingSuggestion *)ptr, &quot;gapi1:doSpellingSuggestion&quot;);
+	case SOAP_TYPE_gapi1__doSpellingSuggestionResponse:
+		return soap_out_gapi1__doSpellingSuggestionResponse(soap, tag, id, (const struct gapi1__doSpellingSuggestionResponse *)ptr, &quot;gapi1:doSpellingSuggestionResponse&quot;);
+	case SOAP_TYPE_gapi1__doGetCachedPage:
+		return soap_out_gapi1__doGetCachedPage(soap, tag, id, (const struct gapi1__doGetCachedPage *)ptr, &quot;gapi1:doGetCachedPage&quot;);
+	case SOAP_TYPE_gapi1__doGetCachedPageResponse:
+		return soap_out_gapi1__doGetCachedPageResponse(soap, tag, id, (const struct gapi1__doGetCachedPageResponse *)ptr, &quot;gapi1:doGetCachedPageResponse&quot;);
+	case SOAP_TYPE_PointerTogapi1__GoogleSearchResult:
+		return soap_out_PointerTogapi1__GoogleSearchResult(soap, tag, id, (gapi1__GoogleSearchResult *const*)ptr, &quot;gapi1:GoogleSearchResult&quot;);
+	case SOAP_TYPE_PointerToPointerTogapi1__DirectoryCategory:
+		return soap_out_PointerToPointerTogapi1__DirectoryCategory(soap, tag, id, (gapi1__DirectoryCategory **const*)ptr, &quot;gapi1:DirectoryCategory&quot;);
+	case SOAP_TYPE_PointerToPointerTogapi1__ResultElement:
+		return soap_out_PointerToPointerTogapi1__ResultElement(soap, tag, id, (gapi1__ResultElement **const*)ptr, &quot;gapi1:ResultElement&quot;);
+	case SOAP_TYPE_PointerTogapi1__ResultElement:
+		return soap_out_PointerTogapi1__ResultElement(soap, tag, id, (gapi1__ResultElement *const*)ptr, &quot;gapi1:ResultElement&quot;);
+	case SOAP_TYPE_PointerTogapi1__DirectoryCategory:
+		return soap_out_PointerTogapi1__DirectoryCategory(soap, tag, id, (gapi1__DirectoryCategory *const*)ptr, &quot;gapi1:DirectoryCategory&quot;);
+	case SOAP_TYPE_PointerTogapi1DirectoryCategoryArray:
+		return soap_out_PointerTogapi1DirectoryCategoryArray(soap, tag, id, (gapi1DirectoryCategoryArray *const*)ptr, &quot;gapi1:DirectoryCategory&quot;);
+	case SOAP_TYPE_PointerTogapi1ResultElementArray:
+		return soap_out_PointerTogapi1ResultElementArray(soap, tag, id, (gapi1ResultElementArray *const*)ptr, &quot;gapi1:ResultElement&quot;);
+	case SOAP_TYPE_PointerTounsignedByte:
+		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, &quot;xsd:unsignedByte&quot;);
+	case SOAP_TYPE__QName:
+		return soap_out_string(soap, &quot;QName&quot;, id, (char**)&amp;ptr, NULL);
+	case SOAP_TYPE_string:
+		return soap_out_string(soap, tag, id, (char**)&amp;ptr, &quot;xsd:string&quot;);
+	}
+	return SOAP_OK;
+}
+#endif
+
+#ifndef WITH_NOIDREF
+SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
+{
+	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
+	switch (type)
+	{
+	case SOAP_TYPE_gapi1__DirectoryCategory:
+		((gapi1__DirectoryCategory *)ptr)-&gt;soap_serialize(soap);
+		break;
+	case SOAP_TYPE_gapi1DirectoryCategoryArray:
+		((gapi1DirectoryCategoryArray *)ptr)-&gt;soap_serialize(soap);
+		break;
+	case SOAP_TYPE_gapi1ResultElementArray:
+		((gapi1ResultElementArray *)ptr)-&gt;soap_serialize(soap);
+		break;
+	case SOAP_TYPE_gapi1__ResultElement:
+		((gapi1__ResultElement *)ptr)-&gt;soap_serialize(soap);
+		break;
+	case SOAP_TYPE_gapi1__GoogleSearchResult:
+		((gapi1__GoogleSearchResult *)ptr)-&gt;soap_serialize(soap);
+		break;
+	case SOAP_TYPE__SOAP_ENC__arrayType:
+		soap_serialize__SOAP_ENC__arrayType(soap, (const std::string *)ptr);
+		break;
+	case SOAP_TYPE_std__string:
+		soap_serialize_std__string(soap, (const std::string *)ptr);
+		break;
+	case SOAP_TYPE_xsd__base64Binary:
+		((xsd__base64Binary *)ptr)-&gt;soap_serialize(soap);
+		break;
+	case SOAP_TYPE_gapi1__doGoogleSearch:
+		soap_serialize_gapi1__doGoogleSearch(soap, (const struct gapi1__doGoogleSearch *)ptr);
+		break;
+	case SOAP_TYPE_gapi1__doGoogleSearchResponse:
+		soap_serialize_gapi1__doGoogleSearchResponse(soap, (const struct gapi1__doGoogleSearchResponse *)ptr);
+		break;
+	case SOAP_TYPE_gapi1__doSpellingSuggestion:
+		soap_serialize_gapi1__doSpellingSuggestion(soap, (const struct gapi1__doSpellingSuggestion *)ptr);
+		break;
+	case SOAP_TYPE_gapi1__doSpellingSuggestionResponse:
+		soap_serialize_gapi1__doSpellingSuggestionResponse(soap, (const struct gapi1__doSpellingSuggestionResponse *)ptr);
+		break;
+	case SOAP_TYPE_gapi1__doGetCachedPage:
+		soap_serialize_gapi1__doGetCachedPage(soap, (const struct gapi1__doGetCachedPage *)ptr);
+		break;
+	case SOAP_TYPE_gapi1__doGetCachedPageResponse:
+		soap_serialize_gapi1__doGetCachedPageResponse(soap, (const struct gapi1__doGetCachedPageResponse *)ptr);
+		break;
+	case SOAP_TYPE_PointerTogapi1__GoogleSearchResult:
+		soap_serialize_PointerTogapi1__GoogleSearchResult(soap, (gapi1__GoogleSearchResult *const*)ptr);
+		break;
+	case SOAP_TYPE_PointerToPointerTogapi1__DirectoryCategory:
+		soap_serialize_PointerToPointerTogapi1__DirectoryCategory(soap, (gapi1__DirectoryCategory **const*)ptr);
+		break;
+	case SOAP_TYPE_PointerToPointerTogapi1__ResultElement:
+		soap_serialize_PointerToPointerTogapi1__ResultElement(soap, (gapi1__ResultElement **const*)ptr);
+		break;
+	case SOAP_TYPE_PointerTogapi1__ResultElement:
+		soap_serialize_PointerTogapi1__ResultElement(soap, (gapi1__ResultElement *const*)ptr);
+		break;
+	case SOAP_TYPE_PointerTogapi1__DirectoryCategory:
+		soap_serialize_PointerTogapi1__DirectoryCategory(soap, (gapi1__DirectoryCategory *const*)ptr);
+		break;
+	case SOAP_TYPE_PointerTogapi1DirectoryCategoryArray:
+		soap_serialize_PointerTogapi1DirectoryCategoryArray(soap, (gapi1DirectoryCategoryArray *const*)ptr);
+		break;
+	case SOAP_TYPE_PointerTogapi1ResultElementArray:
+		soap_serialize_PointerTogapi1ResultElementArray(soap, (gapi1ResultElementArray *const*)ptr);
+		break;
+	case SOAP_TYPE_PointerTounsignedByte:
+		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
+		break;
+	case SOAP_TYPE__QName:
+		soap_serialize_string(soap, (char**)&amp;ptr);
+		break;
+	case SOAP_TYPE_string:
+		soap_serialize_string(soap, (char**)&amp;ptr);
+		break;
+	}
+}
+#endif
+
+SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
+{
+	switch (t)
+	{
+	case SOAP_TYPE_xsd__base64Binary:
+		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_std__string:
+		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__GoogleSearchResult:
+		return (void*)soap_instantiate_gapi1__GoogleSearchResult(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__ResultElement:
+		return (void*)soap_instantiate_gapi1__ResultElement(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__DirectoryCategory:
+		return (void*)soap_instantiate_gapi1__DirectoryCategory(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1ResultElementArray:
+		return (void*)soap_instantiate_gapi1ResultElementArray(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1DirectoryCategoryArray:
+		return (void*)soap_instantiate_gapi1DirectoryCategoryArray(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__doGetCachedPageResponse:
+		return (void*)soap_instantiate_gapi1__doGetCachedPageResponse(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__doGetCachedPage:
+		return (void*)soap_instantiate_gapi1__doGetCachedPage(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__doSpellingSuggestionResponse:
+		return (void*)soap_instantiate_gapi1__doSpellingSuggestionResponse(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__doSpellingSuggestion:
+		return (void*)soap_instantiate_gapi1__doSpellingSuggestion(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__doGoogleSearchResponse:
+		return (void*)soap_instantiate_gapi1__doGoogleSearchResponse(soap, -1, type, arrayType, n);
+	case SOAP_TYPE_gapi1__doGoogleSearch:
+		return (void*)soap_instantiate_gapi1__doGoogleSearch(soap, -1, type, arrayType, n);
+	case SOAP_TYPE__SOAP_ENC__arrayType:
+		return (void*)soap_instantiate__SOAP_ENC__arrayType(soap, -1, type, arrayType, n);
+	}
+	return NULL;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
+{	switch (p-&gt;type)
+	{
+	case SOAP_TYPE_xsd__base64Binary:
+		if (p-&gt;size &lt; 0)
+			delete (xsd__base64Binary*)p-&gt;ptr;
+		else
+			delete[] (xsd__base64Binary*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_std__string:
+		if (p-&gt;size &lt; 0)
+			delete (std::string*)p-&gt;ptr;
+		else
+			delete[] (std::string*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_gapi1__GoogleSearchResult:
+		if (p-&gt;size &lt; 0)
+			delete (gapi1__GoogleSearchResult*)p-&gt;ptr;
+		else
+			delete[] (gapi1__GoogleSearchResult*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_gapi1__ResultElement:
+		if (p-&gt;size &lt; 0)
+			delete (gapi1__ResultElement*)p-&gt;ptr;
+		else
+			delete[] (gapi1__ResultElement*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_gapi1__DirectoryCategory:
+		if (p-&gt;size &lt; 0)
+			delete (gapi1__DirectoryCategory*)p-&gt;ptr;
+		else
+			delete[] (gapi1__DirectoryCategory*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_gapi1ResultElementArray:
+		if (p-&gt;size &lt; 0)
+			delete (gapi1ResultElementArray*)p-&gt;ptr;
+		else
+			delete[] (gapi1ResultElementArray*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_gapi1DirectoryCategoryArray:
+		if (p-&gt;size &lt; 0)
+			delete (gapi1DirectoryCategoryArray*)p-&gt;ptr;
+		else
+			delete[] (gapi1DirectoryCategoryArray*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_gapi1__doGetCachedPageResponse:
+		if (p-&gt;size &lt; 0)
+			delete (struct gapi1__doGetCachedPageResponse*)p-&gt;ptr;
+		else
+			delete[] (struct gapi1__doGetCachedPageResponse*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_gapi1__doGetCachedPage:
+		if (p-&gt;size &lt; 0)
+			delete (struct gapi1__doGetCachedPage*)p-&gt;ptr;
+		else
+			delete[] (struct gapi1__doGetCachedPage*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_gapi1__doSpellingSuggestionResponse:
+		if (p-&gt;size &lt; 0)
+			delete (struct gapi1__doSpellingSuggestionResponse*)p-&gt;ptr;
+		else
+			delete[] (struct gapi1__doSpellingSuggestionResponse*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_gapi1__doSpellingSuggestion:
+		if (p-&gt;size &lt; 0)
+			delete (struct gapi1__doSpellingSuggestion*)p-&gt;ptr;
+		else
+			delete[] (struct gapi1__doSpellingSuggestion*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_gapi1__doGoogleSearchResponse:
+		if (p-&gt;size &lt; 0)
+			delete (struct gapi1__doGoogleSearchResponse*)p-&gt;ptr;
+		else
+			delete[] (struct gapi1__doGoogleSearchResponse*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_gapi1__doGoogleSearch:
+		if (p-&gt;size &lt; 0)
+			delete (struct gapi1__doGoogleSearch*)p-&gt;ptr;
+		else
+			delete[] (struct gapi1__doGoogleSearch*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_SOAP_ENV__Header:
+		if (p-&gt;size &lt; 0)
+			delete (struct SOAP_ENV__Header*)p-&gt;ptr;
+		else
+			delete[] (struct SOAP_ENV__Header*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_SOAP_ENV__Code:
+		if (p-&gt;size &lt; 0)
+			delete (struct SOAP_ENV__Code*)p-&gt;ptr;
+		else
+			delete[] (struct SOAP_ENV__Code*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_SOAP_ENV__Detail:
+		if (p-&gt;size &lt; 0)
+			delete (struct SOAP_ENV__Detail*)p-&gt;ptr;
+		else
+			delete[] (struct SOAP_ENV__Detail*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_SOAP_ENV__Reason:
+		if (p-&gt;size &lt; 0)
+			delete (struct SOAP_ENV__Reason*)p-&gt;ptr;
+		else
+			delete[] (struct SOAP_ENV__Reason*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE_SOAP_ENV__Fault:
+		if (p-&gt;size &lt; 0)
+			delete (struct SOAP_ENV__Fault*)p-&gt;ptr;
+		else
+			delete[] (struct SOAP_ENV__Fault*)p-&gt;ptr;
+		break;
+	case SOAP_TYPE__SOAP_ENC__arrayType:
+		if (p-&gt;size &lt; 0)
+			delete (std::string*)p-&gt;ptr;
+		else
+			delete[] (std::string*)p-&gt;ptr;
+		break;
+	}
+}
+
+SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
+{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
+}
+
+SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
+{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{	switch (tt)
+	{
+	default:
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Could not insert type=%d in %d\n&quot;, st, tt));
+	}
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_byte
+	*a = SOAP_DEFAULT_byte;
+#else
+	*a = (char)0;
+#endif
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
+	if (soap_out_byte(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
+{
+	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
+}
+
+SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_byte(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
+{
+	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_int
+	*a = SOAP_DEFAULT_int;
+#else
+	*a = (int)0;
+#endif
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
+	if (soap_out_int(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
+{
+	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
+}
+
+SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_int(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
+{
+	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_double
+	*a = SOAP_DEFAULT_double;
+#else
+	*a = (double)0;
+#endif
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
+	if (soap_out_double(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
+{
+	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
+}
+
+SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_double(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
+{
+	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_unsignedByte
+	*a = SOAP_DEFAULT_unsignedByte;
+#else
+	*a = (unsigned char)0;
+#endif
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
+	if (soap_out_unsignedByte(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
+{
+	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
+}
+
+SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
+{
+	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_unsignedInt
+	*a = SOAP_DEFAULT_unsignedInt;
+#else
+	*a = (unsigned int)0;
+#endif
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
+	if (soap_out_unsignedInt(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
+{
+	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
+}
+
+SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
+{
+	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_bool
+	*a = SOAP_DEFAULT_bool;
+#else
+	*a = (bool)0;
+#endif
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
+	if (soap_out_bool(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+static const struct soap_code_map soap_codes_bool[] =
+{	{ (long)false, &quot;false&quot; },
+	{ (long)true, &quot;true&quot; },
+	{ 0, NULL }
+};
+
+SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
+{	const char *s = soap_str_code(soap_codes_bool, (long)n);
+	if (s)
+		return s;
+	return soap_long2s(soap, (long)n);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
+{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
+	soap_send(soap, soap_bool2s(soap, *a));
+	return soap_element_end_out(soap, tag);
+}
+
+SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_bool(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
+{
+	const struct soap_code_map *map;
+	if (!s)
+		return SOAP_OK;
+	map = soap_code(soap_codes_bool, s);
+	if (map)
+		*a = (bool)(map-&gt;code != 0);
+	else
+	{	long n;
+		if (soap_s2long(soap, s, &amp;n) || ((soap-&gt;mode &amp; SOAP_XML_STRICT) &amp;&amp; (n &lt; 0 || n &gt; 1)))
+			return soap-&gt;error = SOAP_TYPE;
+		*a = (bool)(n != 0);
+	}
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (bool *)soap_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (bool *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+void gapi1__DirectoryCategory::soap_serialize(struct soap *soap) const
+{
+	(void)soap; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &amp;((gapi1__DirectoryCategory*)this)-&gt;fullViewableName);
+	soap_serialize_std__string(soap, &amp;((gapi1__DirectoryCategory*)this)-&gt;specialEncoding);
+	/* transient soap skipped */
+}
+
+void gapi1__DirectoryCategory::soap_default(struct soap *soap)
+{
+	this-&gt;soap = soap;
+	soap_default_std__string(soap, &amp;((gapi1__DirectoryCategory*)this)-&gt;fullViewableName);
+	soap_default_std__string(soap, &amp;((gapi1__DirectoryCategory*)this)-&gt;specialEncoding);
+	/* transient soap skipped */
+}
+
+int gapi1__DirectoryCategory::soap_put(struct soap *soap, const char *tag, const  char *type) const
+{
+	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gapi1__DirectoryCategory);
+	if (this-&gt;soap_out(soap, tag, id, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+int gapi1__DirectoryCategory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
+{
+	return soap_out_gapi1__DirectoryCategory(soap, tag, id, this, type);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__DirectoryCategory(struct soap *soap, const char *tag, int id, const gapi1__DirectoryCategory *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__DirectoryCategory), type);
+	soap_out_std__string(soap, &quot;fullViewableName&quot;, -1, &amp;(((gapi1__DirectoryCategory*)a)-&gt;fullViewableName), &quot;&quot;);
+	soap_out_std__string(soap, &quot;specialEncoding&quot;, -1, &amp;(((gapi1__DirectoryCategory*)a)-&gt;specialEncoding), &quot;&quot;);
+	/* transient soap skipped */
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+void *gapi1__DirectoryCategory::soap_get(struct soap *soap, const char *tag, const char *type)
+{
+	return soap_get_gapi1__DirectoryCategory(soap, this, tag, type);
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_get_gapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__DirectoryCategory(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+void *gapi1__DirectoryCategory::soap_in(struct soap *soap, const char *tag, const char *type)
+{	return soap_in_gapi1__DirectoryCategory(soap, tag, this, type);
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_in_gapi1__DirectoryCategory(struct soap *soap, const char *tag, gapi1__DirectoryCategory *a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	a = (gapi1__DirectoryCategory *)soap_class_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_gapi1__DirectoryCategory, sizeof(gapi1__DirectoryCategory), soap-&gt;type, soap-&gt;arrayType);
+	if (!a)
+		return NULL;
+	if (soap-&gt;alloced)
+	{	a-&gt;soap_default(soap);
+		if (soap-&gt;clist-&gt;type != SOAP_TYPE_gapi1__DirectoryCategory)
+		{	soap_revert(soap);
+			*soap-&gt;id = '\0';
+			return (gapi1__DirectoryCategory *)a-&gt;soap_in(soap, tag, type);
+		}
+	}
+	short soap_flag_fullViewableName1 = 1, soap_flag_specialEncoding1 = 1;
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+			if (soap_flag_fullViewableName1 &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;fullViewableName&quot;, &amp;(((gapi1__DirectoryCategory*)a)-&gt;fullViewableName), &quot;xsd:string&quot;))
+				{	soap_flag_fullViewableName1--;
+					continue;
+				}
+			if (soap_flag_specialEncoding1 &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;specialEncoding&quot;, &amp;(((gapi1__DirectoryCategory*)a)-&gt;specialEncoding), &quot;xsd:string&quot;))
+				{	soap_flag_specialEncoding1--;
+					continue;
+				}
+			/* transient soap skipped */
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if ((soap-&gt;mode &amp; SOAP_XML_STRICT) &amp;&amp; (soap_flag_fullViewableName1 &gt; 0 || soap_flag_specialEncoding1 &gt; 0))
+		{	soap-&gt;error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__DirectoryCategory *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_gapi1__DirectoryCategory, 0, sizeof(gapi1__DirectoryCategory), 0, soap_copy_gapi1__DirectoryCategory);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 gapi1__DirectoryCategory * SOAP_FMAC6 soap_new_gapi1__DirectoryCategory(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__DirectoryCategory(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_instantiate_gapi1__DirectoryCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_gapi1__DirectoryCategory(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__DirectoryCategory, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new gapi1__DirectoryCategory;
+		if (size)
+			*size = sizeof(gapi1__DirectoryCategory);
+		((gapi1__DirectoryCategory*)cp-&gt;ptr)-&gt;soap = soap;
+	}
+	else
+	{	cp-&gt;ptr = (void*)new gapi1__DirectoryCategory[n];
+		if (size)
+			*size = n * sizeof(gapi1__DirectoryCategory);
+		for (int i = 0; i &lt; n; i++)
+			((gapi1__DirectoryCategory*)cp-&gt;ptr)[i].soap = soap;
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (gapi1__DirectoryCategory*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__DirectoryCategory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying gapi1__DirectoryCategory %p -&gt; %p\n&quot;, q, p));
+	*(gapi1__DirectoryCategory*)p = *(gapi1__DirectoryCategory*)q;
+}
+
+void gapi1DirectoryCategoryArray::soap_serialize(struct soap *soap) const
+{
+	if (this-&gt;__ptr &amp;&amp; !soap_array_reference(soap, this, (struct soap_array*)&amp;this-&gt;__ptr, 1, SOAP_TYPE_gapi1DirectoryCategoryArray))
+		for (int i = 0; i &lt; this-&gt;__size; i++)
+		{
+			soap_serialize_PointerTogapi1__DirectoryCategory(soap, this-&gt;__ptr + i);
+		}
+}
+
+void gapi1DirectoryCategoryArray::soap_default(struct soap *soap)
+{
+	this-&gt;soap = soap;
+	this-&gt;__size = 0;
+	this-&gt;__ptr = NULL;
+}
+
+int gapi1DirectoryCategoryArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
+{
+	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&amp;this-&gt;__ptr, 1, tag, SOAP_TYPE_gapi1DirectoryCategoryArray);
+	if (this-&gt;soap_out(soap, tag, id, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+int gapi1DirectoryCategoryArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
+{	return soap_out_gapi1DirectoryCategoryArray(soap, tag, id, this, type);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1DirectoryCategoryArray(struct soap *soap, const char *tag, int id, const gapi1DirectoryCategoryArray *a, const char *type)
+{
+	int i, n = a-&gt;__size;
+	char *t = soap_putsize(soap, &quot;gapi1:DirectoryCategory&quot;, a-&gt;__size);
+	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&amp;a-&gt;__ptr, 1, type, SOAP_TYPE_gapi1DirectoryCategoryArray);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	soap_array_begin_out(soap, tag, id, t, NULL);
+	for (i = 0; i &lt; n; i++)
+	{
+		soap-&gt;position = 1;
+		soap-&gt;positions[0] = i;
+		soap_out_PointerTogapi1__DirectoryCategory(soap, &quot;item&quot;, -1, &amp;a-&gt;__ptr[i], &quot;&quot;);
+	}
+	soap-&gt;position = 0;
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+void *gapi1DirectoryCategoryArray::soap_get(struct soap *soap, const char *tag, const char *type)
+{
+	return soap_get_gapi1DirectoryCategoryArray(soap, this, tag, type);
+}
+
+SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_get_gapi1DirectoryCategoryArray(struct soap *soap, gapi1DirectoryCategoryArray *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1DirectoryCategoryArray(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+void *gapi1DirectoryCategoryArray::soap_in(struct soap *soap, const char *tag, const char *type)
+{	return soap_in_gapi1DirectoryCategoryArray(soap, tag, this, type);
+}
+
+SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_in_gapi1DirectoryCategoryArray(struct soap *soap, const char *tag, gapi1DirectoryCategoryArray *a, const char *type)
+{	int i, j;
+	gapi1__DirectoryCategory **p;
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (soap_match_array(soap, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (gapi1DirectoryCategoryArray *)soap_class_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_gapi1DirectoryCategoryArray, sizeof(gapi1DirectoryCategoryArray), soap-&gt;type, soap-&gt;arrayType);
+	if (!a)
+		return NULL;
+	if (soap-&gt;alloced)
+		a-&gt;soap_default(soap);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		a-&gt;__size = soap_getsize(soap-&gt;arraySize, soap-&gt;arrayOffset, &amp;j);
+		if (a-&gt;__size &gt;= 0)
+		{	a-&gt;__ptr = (gapi1__DirectoryCategory **)soap_malloc(soap, sizeof(gapi1__DirectoryCategory *) * a-&gt;__size);
+			for (i = 0; i &lt; a-&gt;__size; i++)
+				a-&gt;__ptr[i] = NULL;
+			for (i = 0; i &lt; a-&gt;__size; i++)
+			{	soap_peek_element(soap);
+				if (soap-&gt;position)
+				{	i = soap-&gt;positions[0]-j;
+					if (i &lt; 0 || i &gt;= a-&gt;__size)
+					{	soap-&gt;error = SOAP_IOB;
+						return NULL;
+					}
+				}
+				if (!soap_in_PointerTogapi1__DirectoryCategory(soap, NULL, a-&gt;__ptr + i, &quot;gapi1:DirectoryCategory&quot;))
+				{	if (soap-&gt;error != SOAP_NO_TAG)
+						return NULL;
+					soap-&gt;error = SOAP_OK;
+					break;
+				}
+			}
+		}
+		else
+		{	soap_new_block(soap);
+			for (a-&gt;__size = 0; ; a-&gt;__size++)
+			{	p = (gapi1__DirectoryCategory **)soap_push_block(soap, sizeof(gapi1__DirectoryCategory *));
+				if (!p)
+					return NULL;
+				*p = NULL;
+				if (!soap_in_PointerTogapi1__DirectoryCategory(soap, NULL, p, &quot;gapi1:DirectoryCategory&quot;))
+				{	if (soap-&gt;error != SOAP_NO_TAG)
+						return NULL;
+					soap-&gt;error = SOAP_OK;
+					break;
+				}
+			}
+			soap_pop_block(soap);
+			a-&gt;__ptr = (gapi1__DirectoryCategory **)soap_malloc(soap, soap-&gt;blist-&gt;size);
+			soap_save_block(soap, (char*)a-&gt;__ptr, 1);
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (gapi1DirectoryCategoryArray *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_gapi1DirectoryCategoryArray, 0, sizeof(gapi1DirectoryCategoryArray), 0, soap_copy_gapi1DirectoryCategoryArray);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 gapi1DirectoryCategoryArray * SOAP_FMAC6 soap_new_gapi1DirectoryCategoryArray(struct soap *soap, int n)
+{	return soap_instantiate_gapi1DirectoryCategoryArray(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1DirectoryCategoryArray(struct soap *soap, gapi1DirectoryCategoryArray *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_instantiate_gapi1DirectoryCategoryArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_gapi1DirectoryCategoryArray(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1DirectoryCategoryArray, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new gapi1DirectoryCategoryArray;
+		if (size)
+			*size = sizeof(gapi1DirectoryCategoryArray);
+		((gapi1DirectoryCategoryArray*)cp-&gt;ptr)-&gt;soap = soap;
+	}
+	else
+	{	cp-&gt;ptr = (void*)new gapi1DirectoryCategoryArray[n];
+		if (size)
+			*size = n * sizeof(gapi1DirectoryCategoryArray);
+		for (int i = 0; i &lt; n; i++)
+			((gapi1DirectoryCategoryArray*)cp-&gt;ptr)[i].soap = soap;
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (gapi1DirectoryCategoryArray*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1DirectoryCategoryArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying gapi1DirectoryCategoryArray %p -&gt; %p\n&quot;, q, p));
+	*(gapi1DirectoryCategoryArray*)p = *(gapi1DirectoryCategoryArray*)q;
+}
+
+void gapi1ResultElementArray::soap_serialize(struct soap *soap) const
+{
+	if (this-&gt;__ptr &amp;&amp; !soap_array_reference(soap, this, (struct soap_array*)&amp;this-&gt;__ptr, 1, SOAP_TYPE_gapi1ResultElementArray))
+		for (int i = 0; i &lt; this-&gt;__size; i++)
+		{
+			soap_serialize_PointerTogapi1__ResultElement(soap, this-&gt;__ptr + i);
+		}
+}
+
+void gapi1ResultElementArray::soap_default(struct soap *soap)
+{
+	this-&gt;soap = soap;
+	this-&gt;__size = 0;
+	this-&gt;__ptr = NULL;
+}
+
+int gapi1ResultElementArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
+{
+	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&amp;this-&gt;__ptr, 1, tag, SOAP_TYPE_gapi1ResultElementArray);
+	if (this-&gt;soap_out(soap, tag, id, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+int gapi1ResultElementArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
+{	return soap_out_gapi1ResultElementArray(soap, tag, id, this, type);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1ResultElementArray(struct soap *soap, const char *tag, int id, const gapi1ResultElementArray *a, const char *type)
+{
+	int i, n = a-&gt;__size;
+	char *t = soap_putsize(soap, &quot;gapi1:ResultElement&quot;, a-&gt;__size);
+	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&amp;a-&gt;__ptr, 1, type, SOAP_TYPE_gapi1ResultElementArray);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	soap_array_begin_out(soap, tag, id, t, NULL);
+	for (i = 0; i &lt; n; i++)
+	{
+		soap-&gt;position = 1;
+		soap-&gt;positions[0] = i;
+		soap_out_PointerTogapi1__ResultElement(soap, &quot;item&quot;, -1, &amp;a-&gt;__ptr[i], &quot;&quot;);
+	}
+	soap-&gt;position = 0;
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+void *gapi1ResultElementArray::soap_get(struct soap *soap, const char *tag, const char *type)
+{
+	return soap_get_gapi1ResultElementArray(soap, this, tag, type);
+}
+
+SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_get_gapi1ResultElementArray(struct soap *soap, gapi1ResultElementArray *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1ResultElementArray(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+void *gapi1ResultElementArray::soap_in(struct soap *soap, const char *tag, const char *type)
+{	return soap_in_gapi1ResultElementArray(soap, tag, this, type);
+}
+
+SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_in_gapi1ResultElementArray(struct soap *soap, const char *tag, gapi1ResultElementArray *a, const char *type)
+{	int i, j;
+	gapi1__ResultElement **p;
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (soap_match_array(soap, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (gapi1ResultElementArray *)soap_class_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_gapi1ResultElementArray, sizeof(gapi1ResultElementArray), soap-&gt;type, soap-&gt;arrayType);
+	if (!a)
+		return NULL;
+	if (soap-&gt;alloced)
+		a-&gt;soap_default(soap);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		a-&gt;__size = soap_getsize(soap-&gt;arraySize, soap-&gt;arrayOffset, &amp;j);
+		if (a-&gt;__size &gt;= 0)
+		{	a-&gt;__ptr = (gapi1__ResultElement **)soap_malloc(soap, sizeof(gapi1__ResultElement *) * a-&gt;__size);
+			for (i = 0; i &lt; a-&gt;__size; i++)
+				a-&gt;__ptr[i] = NULL;
+			for (i = 0; i &lt; a-&gt;__size; i++)
+			{	soap_peek_element(soap);
+				if (soap-&gt;position)
+				{	i = soap-&gt;positions[0]-j;
+					if (i &lt; 0 || i &gt;= a-&gt;__size)
+					{	soap-&gt;error = SOAP_IOB;
+						return NULL;
+					}
+				}
+				if (!soap_in_PointerTogapi1__ResultElement(soap, NULL, a-&gt;__ptr + i, &quot;gapi1:ResultElement&quot;))
+				{	if (soap-&gt;error != SOAP_NO_TAG)
+						return NULL;
+					soap-&gt;error = SOAP_OK;
+					break;
+				}
+			}
+		}
+		else
+		{	soap_new_block(soap);
+			for (a-&gt;__size = 0; ; a-&gt;__size++)
+			{	p = (gapi1__ResultElement **)soap_push_block(soap, sizeof(gapi1__ResultElement *));
+				if (!p)
+					return NULL;
+				*p = NULL;
+				if (!soap_in_PointerTogapi1__ResultElement(soap, NULL, p, &quot;gapi1:ResultElement&quot;))
+				{	if (soap-&gt;error != SOAP_NO_TAG)
+						return NULL;
+					soap-&gt;error = SOAP_OK;
+					break;
+				}
+			}
+			soap_pop_block(soap);
+			a-&gt;__ptr = (gapi1__ResultElement **)soap_malloc(soap, soap-&gt;blist-&gt;size);
+			soap_save_block(soap, (char*)a-&gt;__ptr, 1);
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (gapi1ResultElementArray *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_gapi1ResultElementArray, 0, sizeof(gapi1ResultElementArray), 0, soap_copy_gapi1ResultElementArray);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 gapi1ResultElementArray * SOAP_FMAC6 soap_new_gapi1ResultElementArray(struct soap *soap, int n)
+{	return soap_instantiate_gapi1ResultElementArray(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1ResultElementArray(struct soap *soap, gapi1ResultElementArray *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_instantiate_gapi1ResultElementArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_gapi1ResultElementArray(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1ResultElementArray, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new gapi1ResultElementArray;
+		if (size)
+			*size = sizeof(gapi1ResultElementArray);
+		((gapi1ResultElementArray*)cp-&gt;ptr)-&gt;soap = soap;
+	}
+	else
+	{	cp-&gt;ptr = (void*)new gapi1ResultElementArray[n];
+		if (size)
+			*size = n * sizeof(gapi1ResultElementArray);
+		for (int i = 0; i &lt; n; i++)
+			((gapi1ResultElementArray*)cp-&gt;ptr)[i].soap = soap;
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (gapi1ResultElementArray*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1ResultElementArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying gapi1ResultElementArray %p -&gt; %p\n&quot;, q, p));
+	*(gapi1ResultElementArray*)p = *(gapi1ResultElementArray*)q;
+}
+
+void gapi1__ResultElement::soap_serialize(struct soap *soap) const
+{
+	(void)soap; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;summary);
+	soap_serialize_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;URL);
+	soap_serialize_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;snippet);
+	soap_serialize_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;title);
+	soap_serialize_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;cachedSize);
+	soap_serialize_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;hostName);
+	soap_serialize_PointerTogapi1__DirectoryCategory(soap, &amp;((gapi1__ResultElement*)this)-&gt;directoryCategory);
+	soap_serialize_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;directoryTitle);
+	/* transient soap skipped */
+}
+
+void gapi1__ResultElement::soap_default(struct soap *soap)
+{
+	this-&gt;soap = soap;
+	soap_default_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;summary);
+	soap_default_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;URL);
+	soap_default_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;snippet);
+	soap_default_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;title);
+	soap_default_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;cachedSize);
+	soap_default_bool(soap, &amp;((gapi1__ResultElement*)this)-&gt;relatedInformationPresent);
+	soap_default_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;hostName);
+	((gapi1__ResultElement*)this)-&gt;directoryCategory = NULL;
+	soap_default_std__string(soap, &amp;((gapi1__ResultElement*)this)-&gt;directoryTitle);
+	/* transient soap skipped */
+}
+
+int gapi1__ResultElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
+{
+	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gapi1__ResultElement);
+	if (this-&gt;soap_out(soap, tag, id, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+int gapi1__ResultElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
+{
+	return soap_out_gapi1__ResultElement(soap, tag, id, this, type);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__ResultElement(struct soap *soap, const char *tag, int id, const gapi1__ResultElement *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__ResultElement), type);
+	soap_out_std__string(soap, &quot;summary&quot;, -1, &amp;(((gapi1__ResultElement*)a)-&gt;summary), &quot;&quot;);
+	soap_out_std__string(soap, &quot;URL&quot;, -1, &amp;(((gapi1__ResultElement*)a)-&gt;URL), &quot;&quot;);
+	soap_out_std__string(soap, &quot;snippet&quot;, -1, &amp;(((gapi1__ResultElement*)a)-&gt;snippet), &quot;&quot;);
+	soap_out_std__string(soap, &quot;title&quot;, -1, &amp;(((gapi1__ResultElement*)a)-&gt;title), &quot;&quot;);
+	soap_out_std__string(soap, &quot;cachedSize&quot;, -1, &amp;(((gapi1__ResultElement*)a)-&gt;cachedSize), &quot;&quot;);
+	soap_out_bool(soap, &quot;relatedInformationPresent&quot;, -1, &amp;(((gapi1__ResultElement*)a)-&gt;relatedInformationPresent), &quot;&quot;);
+	soap_out_std__string(soap, &quot;hostName&quot;, -1, &amp;(((gapi1__ResultElement*)a)-&gt;hostName), &quot;&quot;);
+	soap_out_PointerTogapi1__DirectoryCategory(soap, &quot;directoryCategory&quot;, -1, &amp;(((gapi1__ResultElement*)a)-&gt;directoryCategory), &quot;&quot;);
+	soap_out_std__string(soap, &quot;directoryTitle&quot;, -1, &amp;(((gapi1__ResultElement*)a)-&gt;directoryTitle), &quot;&quot;);
+	/* transient soap skipped */
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+void *gapi1__ResultElement::soap_get(struct soap *soap, const char *tag, const char *type)
+{
+	return soap_get_gapi1__ResultElement(soap, this, tag, type);
+}
+
+SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_get_gapi1__ResultElement(struct soap *soap, gapi1__ResultElement *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__ResultElement(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+void *gapi1__ResultElement::soap_in(struct soap *soap, const char *tag, const char *type)
+{	return soap_in_gapi1__ResultElement(soap, tag, this, type);
+}
+
+SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_in_gapi1__ResultElement(struct soap *soap, const char *tag, gapi1__ResultElement *a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	a = (gapi1__ResultElement *)soap_class_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_gapi1__ResultElement, sizeof(gapi1__ResultElement), soap-&gt;type, soap-&gt;arrayType);
+	if (!a)
+		return NULL;
+	if (soap-&gt;alloced)
+	{	a-&gt;soap_default(soap);
+		if (soap-&gt;clist-&gt;type != SOAP_TYPE_gapi1__ResultElement)
+		{	soap_revert(soap);
+			*soap-&gt;id = '\0';
+			return (gapi1__ResultElement *)a-&gt;soap_in(soap, tag, type);
+		}
+	}
+	short soap_flag_summary1 = 1, soap_flag_URL1 = 1, soap_flag_snippet1 = 1, soap_flag_title1 = 1, soap_flag_cachedSize1 = 1, soap_flag_relatedInformationPresent1 = 1, soap_flag_hostName1 = 1, soap_flag_directoryCategory1 = 1, soap_flag_directoryTitle1 = 1;
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+			if (soap_flag_summary1 &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;summary&quot;, &amp;(((gapi1__ResultElement*)a)-&gt;summary), &quot;xsd:string&quot;))
+				{	soap_flag_summary1--;
+					continue;
+				}
+			if (soap_flag_URL1 &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;URL&quot;, &amp;(((gapi1__ResultElement*)a)-&gt;URL), &quot;xsd:string&quot;))
+				{	soap_flag_URL1--;
+					continue;
+				}
+			if (soap_flag_snippet1 &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;snippet&quot;, &amp;(((gapi1__ResultElement*)a)-&gt;snippet), &quot;xsd:string&quot;))
+				{	soap_flag_snippet1--;
+					continue;
+				}
+			if (soap_flag_title1 &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;title&quot;, &amp;(((gapi1__ResultElement*)a)-&gt;title), &quot;xsd:string&quot;))
+				{	soap_flag_title1--;
+					continue;
+				}
+			if (soap_flag_cachedSize1 &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;cachedSize&quot;, &amp;(((gapi1__ResultElement*)a)-&gt;cachedSize), &quot;xsd:string&quot;))
+				{	soap_flag_cachedSize1--;
+					continue;
+				}
+			if (soap_flag_relatedInformationPresent1 &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_bool(soap, &quot;relatedInformationPresent&quot;, &amp;(((gapi1__ResultElement*)a)-&gt;relatedInformationPresent), &quot;xsd:boolean&quot;))
+				{	soap_flag_relatedInformationPresent1--;
+					continue;
+				}
+			if (soap_flag_hostName1 &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;hostName&quot;, &amp;(((gapi1__ResultElement*)a)-&gt;hostName), &quot;xsd:string&quot;))
+				{	soap_flag_hostName1--;
+					continue;
+				}
+			if (soap_flag_directoryCategory1 &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerTogapi1__DirectoryCategory(soap, &quot;directoryCategory&quot;, &amp;(((gapi1__ResultElement*)a)-&gt;directoryCategory), &quot;gapi1:DirectoryCategory&quot;))
+				{	soap_flag_directoryCategory1--;
+					continue;
+				}
+			if (soap_flag_directoryTitle1 &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;directoryTitle&quot;, &amp;(((gapi1__ResultElement*)a)-&gt;directoryTitle), &quot;xsd:string&quot;))
+				{	soap_flag_directoryTitle1--;
+					continue;
+				}
+			/* transient soap skipped */
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if ((soap-&gt;mode &amp; SOAP_XML_STRICT) &amp;&amp; (soap_flag_summary1 &gt; 0 || soap_flag_URL1 &gt; 0 || soap_flag_snippet1 &gt; 0 || soap_flag_title1 &gt; 0 || soap_flag_cachedSize1 &gt; 0 || soap_flag_relatedInformationPresent1 &gt; 0 || soap_flag_hostName1 &gt; 0 || soap_flag_directoryCategory1 &gt; 0 || soap_flag_directoryTitle1 &gt; 0))
+		{	soap-&gt;error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__ResultElement *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_gapi1__ResultElement, 0, sizeof(gapi1__ResultElement), 0, soap_copy_gapi1__ResultElement);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 gapi1__ResultElement * SOAP_FMAC6 soap_new_gapi1__ResultElement(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__ResultElement(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__ResultElement(struct soap *soap, gapi1__ResultElement *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_instantiate_gapi1__ResultElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_gapi1__ResultElement(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__ResultElement, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new gapi1__ResultElement;
+		if (size)
+			*size = sizeof(gapi1__ResultElement);
+		((gapi1__ResultElement*)cp-&gt;ptr)-&gt;soap = soap;
+	}
+	else
+	{	cp-&gt;ptr = (void*)new gapi1__ResultElement[n];
+		if (size)
+			*size = n * sizeof(gapi1__ResultElement);
+		for (int i = 0; i &lt; n; i++)
+			((gapi1__ResultElement*)cp-&gt;ptr)[i].soap = soap;
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (gapi1__ResultElement*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__ResultElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying gapi1__ResultElement %p -&gt; %p\n&quot;, q, p));
+	*(gapi1__ResultElement*)p = *(gapi1__ResultElement*)q;
+}
+
+void gapi1__GoogleSearchResult::soap_serialize(struct soap *soap) const
+{
+	(void)soap; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;searchComments);
+	soap_serialize_PointerTogapi1ResultElementArray(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;resultElements);
+	soap_serialize_std__string(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;searchQuery);
+	soap_serialize_std__string(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;searchTips);
+	soap_serialize_PointerTogapi1DirectoryCategoryArray(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;directoryCategories);
+	/* transient soap skipped */
+}
+
+void gapi1__GoogleSearchResult::soap_default(struct soap *soap)
+{
+	this-&gt;soap = soap;
+	soap_default_bool(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;documentFiltering);
+	soap_default_std__string(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;searchComments);
+	soap_default_int(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;estimatedTotalResultsCount);
+	soap_default_bool(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;estimateIsExact);
+	((gapi1__GoogleSearchResult*)this)-&gt;resultElements = NULL;
+	soap_default_std__string(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;searchQuery);
+	soap_default_int(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;startIndex);
+	soap_default_int(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;endIndex);
+	soap_default_std__string(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;searchTips);
+	((gapi1__GoogleSearchResult*)this)-&gt;directoryCategories = NULL;
+	soap_default_double(soap, &amp;((gapi1__GoogleSearchResult*)this)-&gt;searchTime);
+	/* transient soap skipped */
+}
+
+int gapi1__GoogleSearchResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
+{
+	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gapi1__GoogleSearchResult);
+	if (this-&gt;soap_out(soap, tag, id, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+int gapi1__GoogleSearchResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
+{
+	return soap_out_gapi1__GoogleSearchResult(soap, tag, id, this, type);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__GoogleSearchResult(struct soap *soap, const char *tag, int id, const gapi1__GoogleSearchResult *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__GoogleSearchResult), type);
+	soap_out_bool(soap, &quot;documentFiltering&quot;, -1, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;documentFiltering), &quot;&quot;);
+	soap_out_std__string(soap, &quot;searchComments&quot;, -1, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;searchComments), &quot;&quot;);
+	soap_out_int(soap, &quot;estimatedTotalResultsCount&quot;, -1, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;estimatedTotalResultsCount), &quot;&quot;);
+	soap_out_bool(soap, &quot;estimateIsExact&quot;, -1, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;estimateIsExact), &quot;&quot;);
+	soap_out_PointerTogapi1ResultElementArray(soap, &quot;resultElements&quot;, -1, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;resultElements), &quot;&quot;);
+	soap_out_std__string(soap, &quot;searchQuery&quot;, -1, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;searchQuery), &quot;&quot;);
+	soap_out_int(soap, &quot;startIndex&quot;, -1, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;startIndex), &quot;&quot;);
+	soap_out_int(soap, &quot;endIndex&quot;, -1, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;endIndex), &quot;&quot;);
+	soap_out_std__string(soap, &quot;searchTips&quot;, -1, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;searchTips), &quot;&quot;);
+	soap_out_PointerTogapi1DirectoryCategoryArray(soap, &quot;directoryCategories&quot;, -1, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;directoryCategories), &quot;&quot;);
+	soap_out_double(soap, &quot;searchTime&quot;, -1, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;searchTime), &quot;&quot;);
+	/* transient soap skipped */
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+void *gapi1__GoogleSearchResult::soap_get(struct soap *soap, const char *tag, const char *type)
+{
+	return soap_get_gapi1__GoogleSearchResult(soap, this, tag, type);
+}
+
+SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_get_gapi1__GoogleSearchResult(struct soap *soap, gapi1__GoogleSearchResult *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__GoogleSearchResult(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+void *gapi1__GoogleSearchResult::soap_in(struct soap *soap, const char *tag, const char *type)
+{	return soap_in_gapi1__GoogleSearchResult(soap, tag, this, type);
+}
+
+SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_in_gapi1__GoogleSearchResult(struct soap *soap, const char *tag, gapi1__GoogleSearchResult *a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	a = (gapi1__GoogleSearchResult *)soap_class_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_gapi1__GoogleSearchResult, sizeof(gapi1__GoogleSearchResult), soap-&gt;type, soap-&gt;arrayType);
+	if (!a)
+		return NULL;
+	if (soap-&gt;alloced)
+	{	a-&gt;soap_default(soap);
+		if (soap-&gt;clist-&gt;type != SOAP_TYPE_gapi1__GoogleSearchResult)
+		{	soap_revert(soap);
+			*soap-&gt;id = '\0';
+			return (gapi1__GoogleSearchResult *)a-&gt;soap_in(soap, tag, type);
+		}
+	}
+	short soap_flag_documentFiltering1 = 1, soap_flag_searchComments1 = 1, soap_flag_estimatedTotalResultsCount1 = 1, soap_flag_estimateIsExact1 = 1, soap_flag_resultElements1 = 1, soap_flag_searchQuery1 = 1, soap_flag_startIndex1 = 1, soap_flag_endIndex1 = 1, soap_flag_searchTips1 = 1, soap_flag_directoryCategories1 = 1, soap_flag_searchTime1 = 1;
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+			if (soap_flag_documentFiltering1 &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_bool(soap, &quot;documentFiltering&quot;, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;documentFiltering), &quot;xsd:boolean&quot;))
+				{	soap_flag_documentFiltering1--;
+					continue;
+				}
+			if (soap_flag_searchComments1 &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;searchComments&quot;, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;searchComments), &quot;xsd:string&quot;))
+				{	soap_flag_searchComments1--;
+					continue;
+				}
+			if (soap_flag_estimatedTotalResultsCount1 &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_int(soap, &quot;estimatedTotalResultsCount&quot;, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;estimatedTotalResultsCount), &quot;xsd:int&quot;))
+				{	soap_flag_estimatedTotalResultsCount1--;
+					continue;
+				}
+			if (soap_flag_estimateIsExact1 &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_bool(soap, &quot;estimateIsExact&quot;, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;estimateIsExact), &quot;xsd:boolean&quot;))
+				{	soap_flag_estimateIsExact1--;
+					continue;
+				}
+			if (soap_flag_resultElements1 &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerTogapi1ResultElementArray(soap, &quot;resultElements&quot;, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;resultElements), &quot;gapi1:ResultElement&quot;))
+				{	soap_flag_resultElements1--;
+					continue;
+				}
+			if (soap_flag_searchQuery1 &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;searchQuery&quot;, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;searchQuery), &quot;xsd:string&quot;))
+				{	soap_flag_searchQuery1--;
+					continue;
+				}
+			if (soap_flag_startIndex1 &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_int(soap, &quot;startIndex&quot;, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;startIndex), &quot;xsd:int&quot;))
+				{	soap_flag_startIndex1--;
+					continue;
+				}
+			if (soap_flag_endIndex1 &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_int(soap, &quot;endIndex&quot;, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;endIndex), &quot;xsd:int&quot;))
+				{	soap_flag_endIndex1--;
+					continue;
+				}
+			if (soap_flag_searchTips1 &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;searchTips&quot;, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;searchTips), &quot;xsd:string&quot;))
+				{	soap_flag_searchTips1--;
+					continue;
+				}
+			if (soap_flag_directoryCategories1 &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerTogapi1DirectoryCategoryArray(soap, &quot;directoryCategories&quot;, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;directoryCategories), &quot;gapi1:DirectoryCategory&quot;))
+				{	soap_flag_directoryCategories1--;
+					continue;
+				}
+			if (soap_flag_searchTime1 &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_double(soap, &quot;searchTime&quot;, &amp;(((gapi1__GoogleSearchResult*)a)-&gt;searchTime), &quot;xsd:double&quot;))
+				{	soap_flag_searchTime1--;
+					continue;
+				}
+			/* transient soap skipped */
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if ((soap-&gt;mode &amp; SOAP_XML_STRICT) &amp;&amp; (soap_flag_documentFiltering1 &gt; 0 || soap_flag_searchComments1 &gt; 0 || soap_flag_estimatedTotalResultsCount1 &gt; 0 || soap_flag_estimateIsExact1 &gt; 0 || soap_flag_resultElements1 &gt; 0 || soap_flag_searchQuery1 &gt; 0 || soap_flag_startIndex1 &gt; 0 || soap_flag_endIndex1 &gt; 0 || soap_flag_searchTips1 &gt; 0 || soap_flag_directoryCategories1 &gt; 0 || soap_flag_searchTime1 &gt; 0))
+		{	soap-&gt;error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__GoogleSearchResult *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_gapi1__GoogleSearchResult, 0, sizeof(gapi1__GoogleSearchResult), 0, soap_copy_gapi1__GoogleSearchResult);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 gapi1__GoogleSearchResult * SOAP_FMAC6 soap_new_gapi1__GoogleSearchResult(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__GoogleSearchResult(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__GoogleSearchResult(struct soap *soap, gapi1__GoogleSearchResult *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_instantiate_gapi1__GoogleSearchResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_gapi1__GoogleSearchResult(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__GoogleSearchResult, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new gapi1__GoogleSearchResult;
+		if (size)
+			*size = sizeof(gapi1__GoogleSearchResult);
+		((gapi1__GoogleSearchResult*)cp-&gt;ptr)-&gt;soap = soap;
+	}
+	else
+	{	cp-&gt;ptr = (void*)new gapi1__GoogleSearchResult[n];
+		if (size)
+			*size = n * sizeof(gapi1__GoogleSearchResult);
+		for (int i = 0; i &lt; n; i++)
+			((gapi1__GoogleSearchResult*)cp-&gt;ptr)[i].soap = soap;
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (gapi1__GoogleSearchResult*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__GoogleSearchResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying gapi1__GoogleSearchResult %p -&gt; %p\n&quot;, q, p));
+	*(gapi1__GoogleSearchResult*)p = *(gapi1__GoogleSearchResult*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__SOAP_ENC__arrayType(struct soap *soap, std::string const*a)
+{	soap_serialize_std__string(soap, a);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default__SOAP_ENC__arrayType(struct soap *soap, std::string *a)
+{	soap_default_std__string(soap, a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put__SOAP_ENC__arrayType(struct soap *soap, const std::string *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__SOAP_ENC__arrayType);
+	if (soap_out__SOAP_ENC__arrayType(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+SOAP_FMAC3 int SOAP_FMAC4 soap_out__SOAP_ENC__arrayType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
+{
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE__SOAP_ENC__arrayType), type) || soap_string_out(soap, s-&gt;c_str(), 0) || soap_element_end_out(soap, tag))
+		return soap-&gt;error;
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get__SOAP_ENC__arrayType(struct soap *soap, std::string *p, const char *tag, const char *type)
+{
+	if ((p = soap_in__SOAP_ENC__arrayType(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in__SOAP_ENC__arrayType(struct soap *soap, const char *tag, std::string *s, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!s)
+		s = soap_new_std__string(soap, -1);
+	if (soap-&gt;null)
+		if (s)
+			s-&gt;erase();
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{	char *t;
+		s = (std::string*)soap_class_id_enter(soap, soap-&gt;id, s, SOAP_TYPE__SOAP_ENC__arrayType, sizeof(std::string), soap-&gt;type, soap-&gt;arrayType);
+		if (s)
+			if ((t = soap_string_in(soap, 1, -1, -1)))
+				s-&gt;assign(t);
+			else
+				return NULL;
+	}
+	else
+		s = (std::string*)soap_id_forward(soap, soap-&gt;href, soap_class_id_enter(soap, soap-&gt;id, s, SOAP_TYPE__SOAP_ENC__arrayType, sizeof(std::string), soap-&gt;type, soap-&gt;arrayType), 0, SOAP_TYPE__SOAP_ENC__arrayType, 0, sizeof(std::string), 0, soap_copy__SOAP_ENC__arrayType);
+	if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+		return NULL;
+	return s;
+}
+
+SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new__SOAP_ENC__arrayType(struct soap *soap, int n)
+{	return soap_instantiate__SOAP_ENC__arrayType(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete__SOAP_ENC__arrayType(struct soap *soap, std::string *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate__SOAP_ENC__arrayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate__SOAP_ENC__arrayType(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__SOAP_ENC__arrayType, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new std::string;
+		if (size)
+			*size = sizeof(std::string);
+	}
+	else
+	{	cp-&gt;ptr = (void*)new std::string[n];
+		if (size)
+			*size = n * sizeof(std::string);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (std::string*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy__SOAP_ENC__arrayType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying std::string %p -&gt; %p\n&quot;, q, p));
+	*(std::string*)p = *(std::string*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
+{	(void)soap; (void)p; /* appease -Wall -Werror */
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
+{	(void)soap; /* appease -Wall -Werror */
+	p-&gt;erase();
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
+	if (soap_out_std__string(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
+{
+	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s-&gt;c_str(), 0) || soap_element_end_out(soap, tag))
+		return soap-&gt;error;
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_std__string(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!s)
+		s = soap_new_std__string(soap, -1);
+	if (soap-&gt;null)
+		if (s)
+			s-&gt;erase();
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{	char *t;
+		s = (std::string*)soap_class_id_enter(soap, soap-&gt;id, s, SOAP_TYPE_std__string, sizeof(std::string), soap-&gt;type, soap-&gt;arrayType);
+		if (s)
+			if ((t = soap_string_in(soap, 1, -1, -1)))
+				s-&gt;assign(t);
+			else
+				return NULL;
+	}
+	else
+		s = (std::string*)soap_id_forward(soap, soap-&gt;href, soap_class_id_enter(soap, soap-&gt;id, s, SOAP_TYPE_std__string, sizeof(std::string), soap-&gt;type, soap-&gt;arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
+	if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+		return NULL;
+	return s;
+}
+
+SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
+{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_std__string(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new std::string;
+		if (size)
+			*size = sizeof(std::string);
+	}
+	else
+	{	cp-&gt;ptr = (void*)new std::string[n];
+		if (size)
+			*size = n * sizeof(std::string);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (std::string*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying std::string %p -&gt; %p\n&quot;, q, p));
+	*(std::string*)p = *(std::string*)q;
+}
+
+void xsd__base64Binary::soap_serialize(struct soap *soap) const
+{
+	if (this-&gt;__ptr &amp;&amp; !soap_array_reference(soap, this, (struct soap_array*)&amp;this-&gt;__ptr, 1, SOAP_TYPE_xsd__base64Binary))
+		if (this-&gt;id || this-&gt;type)
+			soap-&gt;mode |= SOAP_ENC_DIME;
+}
+
+void xsd__base64Binary::soap_default(struct soap *soap)
+{
+	this-&gt;soap = soap;
+	this-&gt;__size = 0;
+	this-&gt;__ptr = NULL;
+	this-&gt;id = NULL;
+	this-&gt;type = NULL;
+	this-&gt;options = NULL;
+}
+
+int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
+{
+	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&amp;this-&gt;__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
+	if (this-&gt;soap_out(soap, tag, id, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
+{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
+{
+	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&amp;a-&gt;__ptr, a-&gt;id, a-&gt;type, a-&gt;options, 1, type, SOAP_TYPE_xsd__base64Binary);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	soap_element_begin_out(soap, tag, id, type);
+	soap_putbase64(soap, a-&gt;__ptr, a-&gt;__size);
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
+{
+	return soap_get_xsd__base64Binary(soap, this, tag, type);
+}
+
+SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
+{	return soap_in_xsd__base64Binary(soap, tag, this, type);
+}
+
+SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type) &amp;&amp; soap_match_tag(soap, soap-&gt;type, &quot;:base64Binary&quot;) &amp;&amp; soap_match_tag(soap, soap-&gt;type, &quot;:base64&quot;))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap-&gt;type, soap-&gt;arrayType);
+	if (!a)
+		return NULL;
+	if (soap-&gt;alloced)
+		a-&gt;soap_default(soap);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		a-&gt;__ptr = soap_getbase64(soap, &amp;a-&gt;__size, 0);
+		if (soap_xop_forward(soap, &amp;a-&gt;__ptr, &amp;a-&gt;__size, &amp;a-&gt;id, &amp;a-&gt;type, &amp;a-&gt;options))
+			return NULL;
+		if ((!a-&gt;__ptr &amp;&amp; soap-&gt;error) || soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	if (*soap-&gt;href != '#')
+		{	if (soap_dime_forward(soap, &amp;a-&gt;__ptr, &amp;a-&gt;__size, &amp;a-&gt;id, &amp;a-&gt;type, &amp;a-&gt;options))
+				return NULL;
+		}
+		else
+			a = (xsd__base64Binary *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_new_xsd__base64Binary(struct soap *soap, int n)
+{	return soap_instantiate_xsd__base64Binary(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_xsd__base64Binary(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new xsd__base64Binary;
+		if (size)
+			*size = sizeof(xsd__base64Binary);
+		((xsd__base64Binary*)cp-&gt;ptr)-&gt;soap = soap;
+	}
+	else
+	{	cp-&gt;ptr = (void*)new xsd__base64Binary[n];
+		if (size)
+			*size = n * sizeof(xsd__base64Binary);
+		for (int i = 0; i &lt; n; i++)
+			((xsd__base64Binary*)cp-&gt;ptr)[i].soap = soap;
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (xsd__base64Binary*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying xsd__base64Binary %p -&gt; %p\n&quot;, q, p));
+	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
+}
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize__QName(soap, &amp;a-&gt;faultcode);
+	soap_serialize_string(soap, &amp;a-&gt;faultstring);
+	soap_serialize_string(soap, &amp;a-&gt;faultactor);
+	soap_serialize_PointerToSOAP_ENV__Detail(soap, &amp;a-&gt;detail);
+	soap_serialize_PointerToSOAP_ENV__Code(soap, &amp;a-&gt;SOAP_ENV__Code);
+	soap_serialize_PointerToSOAP_ENV__Reason(soap, &amp;a-&gt;SOAP_ENV__Reason);
+	soap_serialize_string(soap, &amp;a-&gt;SOAP_ENV__Node);
+	soap_serialize_string(soap, &amp;a-&gt;SOAP_ENV__Role);
+	soap_serialize_PointerToSOAP_ENV__Detail(soap, &amp;a-&gt;SOAP_ENV__Detail);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default__QName(soap, &amp;a-&gt;faultcode);
+	soap_default_string(soap, &amp;a-&gt;faultstring);
+	soap_default_string(soap, &amp;a-&gt;faultactor);
+	a-&gt;detail = NULL;
+	a-&gt;SOAP_ENV__Code = NULL;
+	a-&gt;SOAP_ENV__Reason = NULL;
+	soap_default_string(soap, &amp;a-&gt;SOAP_ENV__Node);
+	soap_default_string(soap, &amp;a-&gt;SOAP_ENV__Role);
+	a-&gt;SOAP_ENV__Detail = NULL;
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
+	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
+{
+	const char *soap_tmp_faultcode = soap_QName2s(soap, a-&gt;faultcode);
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
+	soap_out__QName(soap, &quot;faultcode&quot;, -1, (char*const*)&amp;soap_tmp_faultcode, &quot;&quot;);
+	soap_out_string(soap, &quot;faultstring&quot;, -1, &amp;a-&gt;faultstring, &quot;&quot;);
+	soap_out_string(soap, &quot;faultactor&quot;, -1, &amp;a-&gt;faultactor, &quot;&quot;);
+	soap_out_PointerToSOAP_ENV__Detail(soap, &quot;detail&quot;, -1, &amp;a-&gt;detail, &quot;&quot;);
+	soap_out_PointerToSOAP_ENV__Code(soap, &quot;SOAP-ENV:Code&quot;, -1, &amp;a-&gt;SOAP_ENV__Code, &quot;&quot;);
+	soap_out_PointerToSOAP_ENV__Reason(soap, &quot;SOAP-ENV:Reason&quot;, -1, &amp;a-&gt;SOAP_ENV__Reason, &quot;&quot;);
+	soap_out_string(soap, &quot;SOAP-ENV:Node&quot;, -1, &amp;a-&gt;SOAP_ENV__Node, &quot;&quot;);
+	soap_out_string(soap, &quot;SOAP-ENV:Role&quot;, -1, &amp;a-&gt;SOAP_ENV__Role, &quot;&quot;);
+	soap_out_PointerToSOAP_ENV__Detail(soap, &quot;SOAP-ENV:Detail&quot;, -1, &amp;a-&gt;SOAP_ENV__Detail, &quot;&quot;);
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
+{
+	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	soap_default_SOAP_ENV__Fault(soap, a);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+			if (soap_flag_faultcode &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in__QName(soap, &quot;faultcode&quot;, &amp;a-&gt;faultcode, &quot;&quot;))
+				{	soap_flag_faultcode--;
+					continue;
+				}
+			if (soap_flag_faultstring &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_string(soap, &quot;faultstring&quot;, &amp;a-&gt;faultstring, &quot;xsd:string&quot;))
+				{	soap_flag_faultstring--;
+					continue;
+				}
+			if (soap_flag_faultactor &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_string(soap, &quot;faultactor&quot;, &amp;a-&gt;faultactor, &quot;xsd:string&quot;))
+				{	soap_flag_faultactor--;
+					continue;
+				}
+			if (soap_flag_detail &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerToSOAP_ENV__Detail(soap, &quot;detail&quot;, &amp;a-&gt;detail, &quot;&quot;))
+				{	soap_flag_detail--;
+					continue;
+				}
+			if (soap_flag_SOAP_ENV__Code &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerToSOAP_ENV__Code(soap, &quot;SOAP-ENV:Code&quot;, &amp;a-&gt;SOAP_ENV__Code, &quot;&quot;))
+				{	soap_flag_SOAP_ENV__Code--;
+					continue;
+				}
+			if (soap_flag_SOAP_ENV__Reason &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerToSOAP_ENV__Reason(soap, &quot;SOAP-ENV:Reason&quot;, &amp;a-&gt;SOAP_ENV__Reason, &quot;&quot;))
+				{	soap_flag_SOAP_ENV__Reason--;
+					continue;
+				}
+			if (soap_flag_SOAP_ENV__Node &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_string(soap, &quot;SOAP-ENV:Node&quot;, &amp;a-&gt;SOAP_ENV__Node, &quot;xsd:string&quot;))
+				{	soap_flag_SOAP_ENV__Node--;
+					continue;
+				}
+			if (soap_flag_SOAP_ENV__Role &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_string(soap, &quot;SOAP-ENV:Role&quot;, &amp;a-&gt;SOAP_ENV__Role, &quot;xsd:string&quot;))
+				{	soap_flag_SOAP_ENV__Role--;
+					continue;
+				}
+			if (soap_flag_SOAP_ENV__Detail &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerToSOAP_ENV__Detail(soap, &quot;SOAP-ENV:Detail&quot;, &amp;a-&gt;SOAP_ENV__Detail, &quot;&quot;))
+				{	soap_flag_SOAP_ENV__Detail--;
+					continue;
+				}
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
+{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new struct SOAP_ENV__Fault;
+		if (size)
+			*size = sizeof(struct SOAP_ENV__Fault);
+	}
+	else
+	{	cp-&gt;ptr = (void*)new struct SOAP_ENV__Fault[n];
+		if (size)
+			*size = n * sizeof(struct SOAP_ENV__Fault);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (struct SOAP_ENV__Fault*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying struct SOAP_ENV__Fault %p -&gt; %p\n&quot;, q, p));
+	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
+}
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize_string(soap, &amp;a-&gt;SOAP_ENV__Text);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default_string(soap, &amp;a-&gt;SOAP_ENV__Text);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
+	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
+	soap_out_string(soap, &quot;SOAP-ENV:Text&quot;, -1, &amp;a-&gt;SOAP_ENV__Text, &quot;&quot;);
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
+{
+	short soap_flag_SOAP_ENV__Text = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	soap_default_SOAP_ENV__Reason(soap, a);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+			if (soap_flag_SOAP_ENV__Text &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_string(soap, &quot;SOAP-ENV:Text&quot;, &amp;a-&gt;SOAP_ENV__Text, &quot;xsd:string&quot;))
+				{	soap_flag_SOAP_ENV__Text--;
+					continue;
+				}
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
+{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new struct SOAP_ENV__Reason;
+		if (size)
+			*size = sizeof(struct SOAP_ENV__Reason);
+	}
+	else
+	{	cp-&gt;ptr = (void*)new struct SOAP_ENV__Reason[n];
+		if (size)
+			*size = n * sizeof(struct SOAP_ENV__Reason);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (struct SOAP_ENV__Reason*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying struct SOAP_ENV__Reason %p -&gt; %p\n&quot;, q, p));
+	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
+}
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_markelement(soap, a-&gt;fault, a-&gt;__type);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	a-&gt;__type = 0;
+	a-&gt;fault = NULL;
+	a-&gt;__any = NULL;
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
+	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
+	soap_putelement(soap, a-&gt;fault, &quot;fault&quot;, -1, a-&gt;__type);
+	soap_outliteral(soap, &quot;-any&quot;, &amp;a-&gt;__any);
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
+{
+	short soap_flag_fault = 1, soap_flag___any = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	soap_default_SOAP_ENV__Detail(soap, a);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+			if (soap_flag_fault &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if ((a-&gt;fault = soap_getelement(soap, &amp;a-&gt;__type)))
+				{	soap_flag_fault = 0;
+					continue;
+				}
+			if (soap_flag___any &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_inliteral(soap, &quot;-any&quot;, &amp;a-&gt;__any))
+				{	soap_flag___any--;
+					continue;
+				}
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
+{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new struct SOAP_ENV__Detail;
+		if (size)
+			*size = sizeof(struct SOAP_ENV__Detail);
+	}
+	else
+	{	cp-&gt;ptr = (void*)new struct SOAP_ENV__Detail[n];
+		if (size)
+			*size = n * sizeof(struct SOAP_ENV__Detail);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (struct SOAP_ENV__Detail*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying struct SOAP_ENV__Detail %p -&gt; %p\n&quot;, q, p));
+	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
+}
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize__QName(soap, &amp;a-&gt;SOAP_ENV__Value);
+	soap_serialize_PointerToSOAP_ENV__Code(soap, &amp;a-&gt;SOAP_ENV__Subcode);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default__QName(soap, &amp;a-&gt;SOAP_ENV__Value);
+	a-&gt;SOAP_ENV__Subcode = NULL;
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
+	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
+{
+	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a-&gt;SOAP_ENV__Value);
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
+	soap_out__QName(soap, &quot;SOAP-ENV:Value&quot;, -1, (char*const*)&amp;soap_tmp_SOAP_ENV__Value, &quot;&quot;);
+	soap_out_PointerToSOAP_ENV__Code(soap, &quot;SOAP-ENV:Subcode&quot;, -1, &amp;a-&gt;SOAP_ENV__Subcode, &quot;&quot;);
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
+{
+	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	soap_default_SOAP_ENV__Code(soap, a);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+			if (soap_flag_SOAP_ENV__Value &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in__QName(soap, &quot;SOAP-ENV:Value&quot;, &amp;a-&gt;SOAP_ENV__Value, &quot;&quot;))
+				{	soap_flag_SOAP_ENV__Value--;
+					continue;
+				}
+			if (soap_flag_SOAP_ENV__Subcode &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerToSOAP_ENV__Code(soap, &quot;SOAP-ENV:Subcode&quot;, &amp;a-&gt;SOAP_ENV__Subcode, &quot;&quot;))
+				{	soap_flag_SOAP_ENV__Subcode--;
+					continue;
+				}
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
+{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new struct SOAP_ENV__Code;
+		if (size)
+			*size = sizeof(struct SOAP_ENV__Code);
+	}
+	else
+	{	cp-&gt;ptr = (void*)new struct SOAP_ENV__Code[n];
+		if (size)
+			*size = n * sizeof(struct SOAP_ENV__Code);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (struct SOAP_ENV__Code*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying struct SOAP_ENV__Code %p -&gt; %p\n&quot;, q, p));
+	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
+}
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	/* transient dummy skipped */
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	/* transient dummy skipped */
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
+	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
+	/* transient dummy skipped */
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
+{;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	soap_default_SOAP_ENV__Header(soap, a);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+		/* transient dummy skipped */
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
+{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new struct SOAP_ENV__Header;
+		if (size)
+			*size = sizeof(struct SOAP_ENV__Header);
+	}
+	else
+	{	cp-&gt;ptr = (void*)new struct SOAP_ENV__Header[n];
+		if (size)
+			*size = n * sizeof(struct SOAP_ENV__Header);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (struct SOAP_ENV__Header*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying struct SOAP_ENV__Header %p -&gt; %p\n&quot;, q, p));
+	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
+}
+
+#endif
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGoogleSearch(struct soap *soap, const struct gapi1__doGoogleSearch *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &amp;a-&gt;key);
+	soap_serialize_std__string(soap, &amp;a-&gt;q);
+	soap_serialize_std__string(soap, &amp;a-&gt;restrict_);
+	soap_serialize_std__string(soap, &amp;a-&gt;lr);
+	soap_serialize_std__string(soap, &amp;a-&gt;ie);
+	soap_serialize_std__string(soap, &amp;a-&gt;oe);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGoogleSearch(struct soap *soap, struct gapi1__doGoogleSearch *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default_std__string(soap, &amp;a-&gt;key);
+	soap_default_std__string(soap, &amp;a-&gt;q);
+	soap_default_int(soap, &amp;a-&gt;start);
+	soap_default_int(soap, &amp;a-&gt;maxResults);
+	soap_default_bool(soap, &amp;a-&gt;filter);
+	soap_default_std__string(soap, &amp;a-&gt;restrict_);
+	soap_default_bool(soap, &amp;a-&gt;safeSearch);
+	soap_default_std__string(soap, &amp;a-&gt;lr);
+	soap_default_std__string(soap, &amp;a-&gt;ie);
+	soap_default_std__string(soap, &amp;a-&gt;oe);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGoogleSearch(struct soap *soap, const struct gapi1__doGoogleSearch *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_gapi1__doGoogleSearch);
+	if (soap_out_gapi1__doGoogleSearch(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGoogleSearch(struct soap *soap, const char *tag, int id, const struct gapi1__doGoogleSearch *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGoogleSearch), type);
+	soap_out_std__string(soap, &quot;key&quot;, -1, &amp;a-&gt;key, &quot;&quot;);
+	soap_out_std__string(soap, &quot;q&quot;, -1, &amp;a-&gt;q, &quot;&quot;);
+	soap_out_int(soap, &quot;start&quot;, -1, &amp;a-&gt;start, &quot;&quot;);
+	soap_out_int(soap, &quot;maxResults&quot;, -1, &amp;a-&gt;maxResults, &quot;&quot;);
+	soap_out_bool(soap, &quot;filter&quot;, -1, &amp;a-&gt;filter, &quot;&quot;);
+	soap_out_std__string(soap, &quot;restrict&quot;, -1, &amp;a-&gt;restrict_, &quot;&quot;);
+	soap_out_bool(soap, &quot;safeSearch&quot;, -1, &amp;a-&gt;safeSearch, &quot;&quot;);
+	soap_out_std__string(soap, &quot;lr&quot;, -1, &amp;a-&gt;lr, &quot;&quot;);
+	soap_out_std__string(soap, &quot;ie&quot;, -1, &amp;a-&gt;ie, &quot;&quot;);
+	soap_out_std__string(soap, &quot;oe&quot;, -1, &amp;a-&gt;oe, &quot;&quot;);
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_get_gapi1__doGoogleSearch(struct soap *soap, struct gapi1__doGoogleSearch *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__doGoogleSearch(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_in_gapi1__doGoogleSearch(struct soap *soap, const char *tag, struct gapi1__doGoogleSearch *a, const char *type)
+{
+	short soap_flag_key = 1, soap_flag_q = 1, soap_flag_start = 1, soap_flag_maxResults = 1, soap_flag_filter = 1, soap_flag_restrict_ = 1, soap_flag_safeSearch = 1, soap_flag_lr = 1, soap_flag_ie = 1, soap_flag_oe = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct gapi1__doGoogleSearch *)soap_class_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_gapi1__doGoogleSearch, sizeof(struct gapi1__doGoogleSearch), soap-&gt;type, soap-&gt;arrayType);
+	if (!a)
+		return NULL;
+	soap_default_gapi1__doGoogleSearch(soap, a);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+			if (soap_flag_key &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;key&quot;, &amp;a-&gt;key, &quot;xsd:string&quot;))
+				{	soap_flag_key--;
+					continue;
+				}
+			if (soap_flag_q &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;q&quot;, &amp;a-&gt;q, &quot;xsd:string&quot;))
+				{	soap_flag_q--;
+					continue;
+				}
+			if (soap_flag_start &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_int(soap, &quot;start&quot;, &amp;a-&gt;start, &quot;xsd:int&quot;))
+				{	soap_flag_start--;
+					continue;
+				}
+			if (soap_flag_maxResults &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_int(soap, &quot;maxResults&quot;, &amp;a-&gt;maxResults, &quot;xsd:int&quot;))
+				{	soap_flag_maxResults--;
+					continue;
+				}
+			if (soap_flag_filter &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_bool(soap, &quot;filter&quot;, &amp;a-&gt;filter, &quot;xsd:boolean&quot;))
+				{	soap_flag_filter--;
+					continue;
+				}
+			if (soap_flag_restrict_ &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;restrict&quot;, &amp;a-&gt;restrict_, &quot;xsd:string&quot;))
+				{	soap_flag_restrict_--;
+					continue;
+				}
+			if (soap_flag_safeSearch &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_bool(soap, &quot;safeSearch&quot;, &amp;a-&gt;safeSearch, &quot;xsd:boolean&quot;))
+				{	soap_flag_safeSearch--;
+					continue;
+				}
+			if (soap_flag_lr &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;lr&quot;, &amp;a-&gt;lr, &quot;xsd:string&quot;))
+				{	soap_flag_lr--;
+					continue;
+				}
+			if (soap_flag_ie &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;ie&quot;, &amp;a-&gt;ie, &quot;xsd:string&quot;))
+				{	soap_flag_ie--;
+					continue;
+				}
+			if (soap_flag_oe &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;oe&quot;, &amp;a-&gt;oe, &quot;xsd:string&quot;))
+				{	soap_flag_oe--;
+					continue;
+				}
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if ((soap-&gt;mode &amp; SOAP_XML_STRICT) &amp;&amp; (soap_flag_key &gt; 0 || soap_flag_q &gt; 0 || soap_flag_start &gt; 0 || soap_flag_maxResults &gt; 0 || soap_flag_filter &gt; 0 || soap_flag_restrict_ &gt; 0 || soap_flag_safeSearch &gt; 0 || soap_flag_lr &gt; 0 || soap_flag_ie &gt; 0 || soap_flag_oe &gt; 0))
+		{	soap-&gt;error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct gapi1__doGoogleSearch *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_gapi1__doGoogleSearch, 0, sizeof(struct gapi1__doGoogleSearch), 0, soap_copy_gapi1__doGoogleSearch);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct gapi1__doGoogleSearch * SOAP_FMAC6 soap_new_gapi1__doGoogleSearch(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__doGoogleSearch(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGoogleSearch(struct soap *soap, struct gapi1__doGoogleSearch *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_instantiate_gapi1__doGoogleSearch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_gapi1__doGoogleSearch(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doGoogleSearch, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new struct gapi1__doGoogleSearch;
+		if (size)
+			*size = sizeof(struct gapi1__doGoogleSearch);
+	}
+	else
+	{	cp-&gt;ptr = (void*)new struct gapi1__doGoogleSearch[n];
+		if (size)
+			*size = n * sizeof(struct gapi1__doGoogleSearch);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (struct gapi1__doGoogleSearch*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGoogleSearch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying struct gapi1__doGoogleSearch %p -&gt; %p\n&quot;, q, p));
+	*(struct gapi1__doGoogleSearch*)p = *(struct gapi1__doGoogleSearch*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGoogleSearchResponse(struct soap *soap, const struct gapi1__doGoogleSearchResponse *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize_PointerTogapi1__GoogleSearchResult(soap, &amp;a-&gt;return_);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGoogleSearchResponse(struct soap *soap, struct gapi1__doGoogleSearchResponse *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	a-&gt;return_ = NULL;
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGoogleSearchResponse(struct soap *soap, const struct gapi1__doGoogleSearchResponse *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_gapi1__doGoogleSearchResponse);
+	if (soap_out_gapi1__doGoogleSearchResponse(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGoogleSearchResponse(struct soap *soap, const char *tag, int id, const struct gapi1__doGoogleSearchResponse *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGoogleSearchResponse), type);
+	if (a-&gt;return_)
+		soap_element_result(soap, &quot;return&quot;);
+	soap_out_PointerTogapi1__GoogleSearchResult(soap, &quot;return&quot;, -1, &amp;a-&gt;return_, &quot;&quot;);
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_get_gapi1__doGoogleSearchResponse(struct soap *soap, struct gapi1__doGoogleSearchResponse *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__doGoogleSearchResponse(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_in_gapi1__doGoogleSearchResponse(struct soap *soap, const char *tag, struct gapi1__doGoogleSearchResponse *a, const char *type)
+{
+	short soap_flag_return_ = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct gapi1__doGoogleSearchResponse *)soap_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_gapi1__doGoogleSearchResponse, sizeof(struct gapi1__doGoogleSearchResponse), 0, NULL, NULL, NULL);
+	if (!a)
+		return NULL;
+	soap_default_gapi1__doGoogleSearchResponse(soap, a);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+			if (soap_flag_return_ &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (soap_in_PointerTogapi1__GoogleSearchResult(soap, &quot;return&quot;, &amp;a-&gt;return_, &quot;gapi1:GoogleSearchResult&quot;))
+				{	soap_flag_return_--;
+					continue;
+				}
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct gapi1__doGoogleSearchResponse *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_gapi1__doGoogleSearchResponse, 0, sizeof(struct gapi1__doGoogleSearchResponse), 0, NULL);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct gapi1__doGoogleSearchResponse * SOAP_FMAC6 soap_new_gapi1__doGoogleSearchResponse(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__doGoogleSearchResponse(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGoogleSearchResponse(struct soap *soap, struct gapi1__doGoogleSearchResponse *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_instantiate_gapi1__doGoogleSearchResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_gapi1__doGoogleSearchResponse(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doGoogleSearchResponse, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new struct gapi1__doGoogleSearchResponse;
+		if (size)
+			*size = sizeof(struct gapi1__doGoogleSearchResponse);
+	}
+	else
+	{	cp-&gt;ptr = (void*)new struct gapi1__doGoogleSearchResponse[n];
+		if (size)
+			*size = n * sizeof(struct gapi1__doGoogleSearchResponse);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (struct gapi1__doGoogleSearchResponse*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGoogleSearchResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying struct gapi1__doGoogleSearchResponse %p -&gt; %p\n&quot;, q, p));
+	*(struct gapi1__doGoogleSearchResponse*)p = *(struct gapi1__doGoogleSearchResponse*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doSpellingSuggestion(struct soap *soap, const struct gapi1__doSpellingSuggestion *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &amp;a-&gt;key);
+	soap_serialize_std__string(soap, &amp;a-&gt;phrase);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doSpellingSuggestion(struct soap *soap, struct gapi1__doSpellingSuggestion *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default_std__string(soap, &amp;a-&gt;key);
+	soap_default_std__string(soap, &amp;a-&gt;phrase);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doSpellingSuggestion(struct soap *soap, const struct gapi1__doSpellingSuggestion *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_gapi1__doSpellingSuggestion);
+	if (soap_out_gapi1__doSpellingSuggestion(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doSpellingSuggestion(struct soap *soap, const char *tag, int id, const struct gapi1__doSpellingSuggestion *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doSpellingSuggestion), type);
+	soap_out_std__string(soap, &quot;key&quot;, -1, &amp;a-&gt;key, &quot;&quot;);
+	soap_out_std__string(soap, &quot;phrase&quot;, -1, &amp;a-&gt;phrase, &quot;&quot;);
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_get_gapi1__doSpellingSuggestion(struct soap *soap, struct gapi1__doSpellingSuggestion *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__doSpellingSuggestion(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_in_gapi1__doSpellingSuggestion(struct soap *soap, const char *tag, struct gapi1__doSpellingSuggestion *a, const char *type)
+{
+	short soap_flag_key = 1, soap_flag_phrase = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct gapi1__doSpellingSuggestion *)soap_class_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_gapi1__doSpellingSuggestion, sizeof(struct gapi1__doSpellingSuggestion), soap-&gt;type, soap-&gt;arrayType);
+	if (!a)
+		return NULL;
+	soap_default_gapi1__doSpellingSuggestion(soap, a);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+			if (soap_flag_key &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;key&quot;, &amp;a-&gt;key, &quot;xsd:string&quot;))
+				{	soap_flag_key--;
+					continue;
+				}
+			if (soap_flag_phrase &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;phrase&quot;, &amp;a-&gt;phrase, &quot;xsd:string&quot;))
+				{	soap_flag_phrase--;
+					continue;
+				}
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if ((soap-&gt;mode &amp; SOAP_XML_STRICT) &amp;&amp; (soap_flag_key &gt; 0 || soap_flag_phrase &gt; 0))
+		{	soap-&gt;error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct gapi1__doSpellingSuggestion *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_gapi1__doSpellingSuggestion, 0, sizeof(struct gapi1__doSpellingSuggestion), 0, soap_copy_gapi1__doSpellingSuggestion);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct gapi1__doSpellingSuggestion * SOAP_FMAC6 soap_new_gapi1__doSpellingSuggestion(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__doSpellingSuggestion(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doSpellingSuggestion(struct soap *soap, struct gapi1__doSpellingSuggestion *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_instantiate_gapi1__doSpellingSuggestion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_gapi1__doSpellingSuggestion(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doSpellingSuggestion, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new struct gapi1__doSpellingSuggestion;
+		if (size)
+			*size = sizeof(struct gapi1__doSpellingSuggestion);
+	}
+	else
+	{	cp-&gt;ptr = (void*)new struct gapi1__doSpellingSuggestion[n];
+		if (size)
+			*size = n * sizeof(struct gapi1__doSpellingSuggestion);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (struct gapi1__doSpellingSuggestion*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doSpellingSuggestion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying struct gapi1__doSpellingSuggestion %p -&gt; %p\n&quot;, q, p));
+	*(struct gapi1__doSpellingSuggestion*)p = *(struct gapi1__doSpellingSuggestion*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doSpellingSuggestionResponse(struct soap *soap, const struct gapi1__doSpellingSuggestionResponse *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &amp;a-&gt;return_);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doSpellingSuggestionResponse(struct soap *soap, struct gapi1__doSpellingSuggestionResponse *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default_std__string(soap, &amp;a-&gt;return_);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doSpellingSuggestionResponse(struct soap *soap, const struct gapi1__doSpellingSuggestionResponse *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_gapi1__doSpellingSuggestionResponse);
+	if (soap_out_gapi1__doSpellingSuggestionResponse(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doSpellingSuggestionResponse(struct soap *soap, const char *tag, int id, const struct gapi1__doSpellingSuggestionResponse *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doSpellingSuggestionResponse), type);
+	soap_element_result(soap, &quot;return&quot;);
+	soap_out_std__string(soap, &quot;return&quot;, -1, &amp;a-&gt;return_, &quot;&quot;);
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_get_gapi1__doSpellingSuggestionResponse(struct soap *soap, struct gapi1__doSpellingSuggestionResponse *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__doSpellingSuggestionResponse(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_in_gapi1__doSpellingSuggestionResponse(struct soap *soap, const char *tag, struct gapi1__doSpellingSuggestionResponse *a, const char *type)
+{
+	short soap_flag_return_ = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct gapi1__doSpellingSuggestionResponse *)soap_class_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_gapi1__doSpellingSuggestionResponse, sizeof(struct gapi1__doSpellingSuggestionResponse), soap-&gt;type, soap-&gt;arrayType);
+	if (!a)
+		return NULL;
+	soap_default_gapi1__doSpellingSuggestionResponse(soap, a);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+			if (soap_flag_return_ &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;return&quot;, &amp;a-&gt;return_, &quot;xsd:string&quot;))
+				{	soap_flag_return_--;
+					continue;
+				}
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if ((soap-&gt;mode &amp; SOAP_XML_STRICT) &amp;&amp; (soap_flag_return_ &gt; 0))
+		{	soap-&gt;error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct gapi1__doSpellingSuggestionResponse *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_gapi1__doSpellingSuggestionResponse, 0, sizeof(struct gapi1__doSpellingSuggestionResponse), 0, soap_copy_gapi1__doSpellingSuggestionResponse);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC6 soap_new_gapi1__doSpellingSuggestionResponse(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__doSpellingSuggestionResponse(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doSpellingSuggestionResponse(struct soap *soap, struct gapi1__doSpellingSuggestionResponse *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_instantiate_gapi1__doSpellingSuggestionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_gapi1__doSpellingSuggestionResponse(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doSpellingSuggestionResponse, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new struct gapi1__doSpellingSuggestionResponse;
+		if (size)
+			*size = sizeof(struct gapi1__doSpellingSuggestionResponse);
+	}
+	else
+	{	cp-&gt;ptr = (void*)new struct gapi1__doSpellingSuggestionResponse[n];
+		if (size)
+			*size = n * sizeof(struct gapi1__doSpellingSuggestionResponse);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (struct gapi1__doSpellingSuggestionResponse*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doSpellingSuggestionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying struct gapi1__doSpellingSuggestionResponse %p -&gt; %p\n&quot;, q, p));
+	*(struct gapi1__doSpellingSuggestionResponse*)p = *(struct gapi1__doSpellingSuggestionResponse*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGetCachedPage(struct soap *soap, const struct gapi1__doGetCachedPage *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_serialize_std__string(soap, &amp;a-&gt;key);
+	soap_serialize_std__string(soap, &amp;a-&gt;url);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGetCachedPage(struct soap *soap, struct gapi1__doGetCachedPage *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	soap_default_std__string(soap, &amp;a-&gt;key);
+	soap_default_std__string(soap, &amp;a-&gt;url);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGetCachedPage(struct soap *soap, const struct gapi1__doGetCachedPage *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_gapi1__doGetCachedPage);
+	if (soap_out_gapi1__doGetCachedPage(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGetCachedPage(struct soap *soap, const char *tag, int id, const struct gapi1__doGetCachedPage *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGetCachedPage), type);
+	soap_out_std__string(soap, &quot;key&quot;, -1, &amp;a-&gt;key, &quot;&quot;);
+	soap_out_std__string(soap, &quot;url&quot;, -1, &amp;a-&gt;url, &quot;&quot;);
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_get_gapi1__doGetCachedPage(struct soap *soap, struct gapi1__doGetCachedPage *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__doGetCachedPage(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_in_gapi1__doGetCachedPage(struct soap *soap, const char *tag, struct gapi1__doGetCachedPage *a, const char *type)
+{
+	short soap_flag_key = 1, soap_flag_url = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct gapi1__doGetCachedPage *)soap_class_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_gapi1__doGetCachedPage, sizeof(struct gapi1__doGetCachedPage), soap-&gt;type, soap-&gt;arrayType);
+	if (!a)
+		return NULL;
+	soap_default_gapi1__doGetCachedPage(soap, a);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+			if (soap_flag_key &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;key&quot;, &amp;a-&gt;key, &quot;xsd:string&quot;))
+				{	soap_flag_key--;
+					continue;
+				}
+			if (soap_flag_url &amp;&amp; (soap-&gt;error == SOAP_TAG_MISMATCH || soap-&gt;error == SOAP_NO_TAG))
+				if (soap_in_std__string(soap, &quot;url&quot;, &amp;a-&gt;url, &quot;xsd:string&quot;))
+				{	soap_flag_url--;
+					continue;
+				}
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if ((soap-&gt;mode &amp; SOAP_XML_STRICT) &amp;&amp; (soap_flag_key &gt; 0 || soap_flag_url &gt; 0))
+		{	soap-&gt;error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct gapi1__doGetCachedPage *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_gapi1__doGetCachedPage, 0, sizeof(struct gapi1__doGetCachedPage), 0, soap_copy_gapi1__doGetCachedPage);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct gapi1__doGetCachedPage * SOAP_FMAC6 soap_new_gapi1__doGetCachedPage(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__doGetCachedPage(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGetCachedPage(struct soap *soap, struct gapi1__doGetCachedPage *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_instantiate_gapi1__doGetCachedPage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_gapi1__doGetCachedPage(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doGetCachedPage, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new struct gapi1__doGetCachedPage;
+		if (size)
+			*size = sizeof(struct gapi1__doGetCachedPage);
+	}
+	else
+	{	cp-&gt;ptr = (void*)new struct gapi1__doGetCachedPage[n];
+		if (size)
+			*size = n * sizeof(struct gapi1__doGetCachedPage);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (struct gapi1__doGetCachedPage*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGetCachedPage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying struct gapi1__doGetCachedPage %p -&gt; %p\n&quot;, q, p));
+	*(struct gapi1__doGetCachedPage*)p = *(struct gapi1__doGetCachedPage*)q;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGetCachedPageResponse(struct soap *soap, const struct gapi1__doGetCachedPageResponse *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	a-&gt;return_.soap_serialize(soap);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGetCachedPageResponse(struct soap *soap, struct gapi1__doGetCachedPageResponse *a)
+{
+	(void)soap; (void)a; /* appease -Wall -Werror */
+	a-&gt;return_.xsd__base64Binary::soap_default(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGetCachedPageResponse(struct soap *soap, const struct gapi1__doGetCachedPageResponse *a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_gapi1__doGetCachedPageResponse);
+	if (soap_out_gapi1__doGetCachedPageResponse(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGetCachedPageResponse(struct soap *soap, const char *tag, int id, const struct gapi1__doGetCachedPageResponse *a, const char *type)
+{
+	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gapi1__doGetCachedPageResponse), type);
+	soap_element_result(soap, &quot;return&quot;);
+	a-&gt;return_.soap_out(soap, &quot;return&quot;, -1, &quot;&quot;);
+	soap_element_end_out(soap, tag);
+	return SOAP_OK;
+}
+
+SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_get_gapi1__doGetCachedPageResponse(struct soap *soap, struct gapi1__doGetCachedPageResponse *p, const char *tag, const char *type)
+{
+	if ((p = soap_in_gapi1__doGetCachedPageResponse(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_in_gapi1__doGetCachedPageResponse(struct soap *soap, const char *tag, struct gapi1__doGetCachedPageResponse *a, const char *type)
+{
+	short soap_flag_return_ = 1;
+	if (soap_element_begin_in(soap, tag, 0))
+		return NULL;
+	if (*soap-&gt;type &amp;&amp; soap_match_tag(soap, soap-&gt;type, type))
+	{	soap-&gt;error = SOAP_TYPE;
+		return NULL;
+	}
+	a = (struct gapi1__doGetCachedPageResponse *)soap_class_id_enter(soap, soap-&gt;id, a, SOAP_TYPE_gapi1__doGetCachedPageResponse, sizeof(struct gapi1__doGetCachedPageResponse), soap-&gt;type, soap-&gt;arrayType);
+	if (!a)
+		return NULL;
+	soap_default_gapi1__doGetCachedPageResponse(soap, a);
+	if (soap-&gt;body &amp;&amp; !*soap-&gt;href)
+	{
+		for (;;)
+		{	soap-&gt;error = SOAP_TAG_MISMATCH;
+			if (soap_flag_return_ &amp;&amp; soap-&gt;error == SOAP_TAG_MISMATCH)
+				if (a-&gt;return_.soap_in(soap, &quot;return&quot;, &quot;xsd:base64Binary&quot;))
+				{	soap_flag_return_--;
+					continue;
+				}
+			if (soap-&gt;error == SOAP_TAG_MISMATCH)
+				soap-&gt;error = soap_ignore_element(soap);
+			if (soap-&gt;error == SOAP_NO_TAG)
+				break;
+			if (soap-&gt;error)
+				return NULL;
+		}
+		if ((soap-&gt;mode &amp; SOAP_XML_STRICT) &amp;&amp; (soap_flag_return_ &gt; 0))
+		{	soap-&gt;error = SOAP_OCCURS;
+			return NULL;
+		}
+		if (soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	else
+	{	a = (struct gapi1__doGetCachedPageResponse *)soap_id_forward(soap, soap-&gt;href, (void**)a, 0, SOAP_TYPE_gapi1__doGetCachedPageResponse, 0, sizeof(struct gapi1__doGetCachedPageResponse), 0, soap_copy_gapi1__doGetCachedPageResponse);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC5 struct gapi1__doGetCachedPageResponse * SOAP_FMAC6 soap_new_gapi1__doGetCachedPageResponse(struct soap *soap, int n)
+{	return soap_instantiate_gapi1__doGetCachedPageResponse(soap, n, NULL, NULL, NULL);
+}
+
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGetCachedPageResponse(struct soap *soap, struct gapi1__doGetCachedPageResponse *p)
+{	soap_delete(soap, p);
+}
+
+SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_instantiate_gapi1__doGetCachedPageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;soap_instantiate_gapi1__doGetCachedPageResponse(%d, %s, %s)\n&quot;, n, type?type:&quot;&quot;, arrayType?arrayType:&quot;&quot;));
+	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gapi1__doGetCachedPageResponse, n, soap_fdelete);
+	if (!cp)
+		return NULL;
+	if (n &lt; 0)
+	{	cp-&gt;ptr = (void*)new struct gapi1__doGetCachedPageResponse;
+		if (size)
+			*size = sizeof(struct gapi1__doGetCachedPageResponse);
+	}
+	else
+	{	cp-&gt;ptr = (void*)new struct gapi1__doGetCachedPageResponse[n];
+		if (size)
+			*size = n * sizeof(struct gapi1__doGetCachedPageResponse);
+	}
+		DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Instantiated location=%p\n&quot;, cp-&gt;ptr));
+	return (struct gapi1__doGetCachedPageResponse*)cp-&gt;ptr;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGetCachedPageResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
+{
+	DBGLOG(TEST, SOAP_MESSAGE(fdebug, &quot;Copying struct gapi1__doGetCachedPageResponse %p -&gt; %p\n&quot;, q, p));
+	*(struct gapi1__doGetCachedPageResponse*)p = *(struct gapi1__doGetCachedPageResponse*)q;
+}
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
+		soap_serialize_SOAP_ENV__Reason(soap, *a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
+	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
+			return NULL;
+	*a = NULL;
+	if (!soap-&gt;null &amp;&amp; *soap-&gt;href != '#')
+	{	soap_revert(soap);
+		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
+		soap_serialize_SOAP_ENV__Detail(soap, *a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
+	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
+			return NULL;
+	*a = NULL;
+	if (!soap-&gt;null &amp;&amp; *soap-&gt;href != '#')
+	{	soap_revert(soap);
+		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
+		soap_serialize_SOAP_ENV__Code(soap, *a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
+	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
+			return NULL;
+	*a = NULL;
+	if (!soap-&gt;null &amp;&amp; *soap-&gt;href != '#')
+	{	soap_revert(soap);
+		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
+			return NULL;
+	}
+	else
+	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+#endif
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1__GoogleSearchResult(struct soap *soap, gapi1__GoogleSearchResult *const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_gapi1__GoogleSearchResult))
+		(*a)-&gt;soap_serialize(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1__GoogleSearchResult(struct soap *soap, gapi1__GoogleSearchResult *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogapi1__GoogleSearchResult);
+	if (soap_out_PointerTogapi1__GoogleSearchResult(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1__GoogleSearchResult(struct soap *soap, const char *tag, int id, gapi1__GoogleSearchResult *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gapi1__GoogleSearchResult);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	return (*a)-&gt;soap_out(soap, tag, id, type);
+}
+
+SOAP_FMAC3 gapi1__GoogleSearchResult ** SOAP_FMAC4 soap_get_PointerTogapi1__GoogleSearchResult(struct soap *soap, gapi1__GoogleSearchResult **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerTogapi1__GoogleSearchResult(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1__GoogleSearchResult ** SOAP_FMAC4 soap_in_PointerTogapi1__GoogleSearchResult(struct soap *soap, const char *tag, gapi1__GoogleSearchResult **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1__GoogleSearchResult **)soap_malloc(soap, sizeof(gapi1__GoogleSearchResult *))))
+			return NULL;
+	*a = NULL;
+	if (!soap-&gt;null &amp;&amp; *soap-&gt;href != '#')
+	{	soap_revert(soap);
+		if (!(*a = (gapi1__GoogleSearchResult *)soap_instantiate_gapi1__GoogleSearchResult(soap, -1, soap-&gt;type, soap-&gt;arrayType, NULL)))
+			return NULL;
+		(*a)-&gt;soap_default(soap);
+		if (!(*a)-&gt;soap_in(soap, tag, NULL))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__GoogleSearchResult **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1__GoogleSearchResult, sizeof(gapi1__GoogleSearchResult), 0);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory **const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTogapi1__DirectoryCategory))
+		soap_serialize_PointerTogapi1__DirectoryCategory(soap, *a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory **const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTogapi1__DirectoryCategory);
+	if (soap_out_PointerToPointerTogapi1__DirectoryCategory(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTogapi1__DirectoryCategory(struct soap *soap, const char *tag, int id, gapi1__DirectoryCategory **const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTogapi1__DirectoryCategory);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	return soap_out_PointerTogapi1__DirectoryCategory(soap, tag, id, *a, type);
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory *** SOAP_FMAC4 soap_get_PointerToPointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory ***p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerToPointerTogapi1__DirectoryCategory(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory *** SOAP_FMAC4 soap_in_PointerToPointerTogapi1__DirectoryCategory(struct soap *soap, const char *tag, gapi1__DirectoryCategory ***a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1__DirectoryCategory ***)soap_malloc(soap, sizeof(gapi1__DirectoryCategory **))))
+			return NULL;
+	*a = NULL;
+	if (!soap-&gt;null &amp;&amp; *soap-&gt;href != '#')
+	{	soap_revert(soap);
+		if (!(*a = soap_in_PointerTogapi1__DirectoryCategory(soap, tag, *a, type)))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__DirectoryCategory ***)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_PointerTogapi1__DirectoryCategory, sizeof(gapi1__DirectoryCategory *), 1);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement **const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTogapi1__ResultElement))
+		soap_serialize_PointerTogapi1__ResultElement(soap, *a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement **const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTogapi1__ResultElement);
+	if (soap_out_PointerToPointerTogapi1__ResultElement(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTogapi1__ResultElement(struct soap *soap, const char *tag, int id, gapi1__ResultElement **const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTogapi1__ResultElement);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	return soap_out_PointerTogapi1__ResultElement(soap, tag, id, *a, type);
+}
+
+SOAP_FMAC3 gapi1__ResultElement *** SOAP_FMAC4 soap_get_PointerToPointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement ***p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerToPointerTogapi1__ResultElement(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1__ResultElement *** SOAP_FMAC4 soap_in_PointerToPointerTogapi1__ResultElement(struct soap *soap, const char *tag, gapi1__ResultElement ***a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1__ResultElement ***)soap_malloc(soap, sizeof(gapi1__ResultElement **))))
+			return NULL;
+	*a = NULL;
+	if (!soap-&gt;null &amp;&amp; *soap-&gt;href != '#')
+	{	soap_revert(soap);
+		if (!(*a = soap_in_PointerTogapi1__ResultElement(soap, tag, *a, type)))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__ResultElement ***)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_PointerTogapi1__ResultElement, sizeof(gapi1__ResultElement *), 1);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement *const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_gapi1__ResultElement))
+		(*a)-&gt;soap_serialize(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogapi1__ResultElement);
+	if (soap_out_PointerTogapi1__ResultElement(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1__ResultElement(struct soap *soap, const char *tag, int id, gapi1__ResultElement *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gapi1__ResultElement);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	return (*a)-&gt;soap_out(soap, tag, id, type);
+}
+
+SOAP_FMAC3 gapi1__ResultElement ** SOAP_FMAC4 soap_get_PointerTogapi1__ResultElement(struct soap *soap, gapi1__ResultElement **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerTogapi1__ResultElement(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1__ResultElement ** SOAP_FMAC4 soap_in_PointerTogapi1__ResultElement(struct soap *soap, const char *tag, gapi1__ResultElement **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1__ResultElement **)soap_malloc(soap, sizeof(gapi1__ResultElement *))))
+			return NULL;
+	*a = NULL;
+	if (!soap-&gt;null &amp;&amp; *soap-&gt;href != '#')
+	{	soap_revert(soap);
+		if (!(*a = (gapi1__ResultElement *)soap_instantiate_gapi1__ResultElement(soap, -1, soap-&gt;type, soap-&gt;arrayType, NULL)))
+			return NULL;
+		(*a)-&gt;soap_default(soap);
+		if (!(*a)-&gt;soap_in(soap, tag, NULL))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__ResultElement **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1__ResultElement, sizeof(gapi1__ResultElement), 0);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory *const*a)
+{
+	if (!soap_reference(soap, *a, SOAP_TYPE_gapi1__DirectoryCategory))
+		(*a)-&gt;soap_serialize(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogapi1__DirectoryCategory);
+	if (soap_out_PointerTogapi1__DirectoryCategory(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1__DirectoryCategory(struct soap *soap, const char *tag, int id, gapi1__DirectoryCategory *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gapi1__DirectoryCategory);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	return (*a)-&gt;soap_out(soap, tag, id, type);
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory ** SOAP_FMAC4 soap_get_PointerTogapi1__DirectoryCategory(struct soap *soap, gapi1__DirectoryCategory **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerTogapi1__DirectoryCategory(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1__DirectoryCategory ** SOAP_FMAC4 soap_in_PointerTogapi1__DirectoryCategory(struct soap *soap, const char *tag, gapi1__DirectoryCategory **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1__DirectoryCategory **)soap_malloc(soap, sizeof(gapi1__DirectoryCategory *))))
+			return NULL;
+	*a = NULL;
+	if (!soap-&gt;null &amp;&amp; *soap-&gt;href != '#')
+	{	soap_revert(soap);
+		if (!(*a = (gapi1__DirectoryCategory *)soap_instantiate_gapi1__DirectoryCategory(soap, -1, soap-&gt;type, soap-&gt;arrayType, NULL)))
+			return NULL;
+		(*a)-&gt;soap_default(soap);
+		if (!(*a)-&gt;soap_in(soap, tag, NULL))
+			return NULL;
+	}
+	else
+	{	a = (gapi1__DirectoryCategory **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1__DirectoryCategory, sizeof(gapi1__DirectoryCategory), 0);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1DirectoryCategoryArray(struct soap *soap, gapi1DirectoryCategoryArray *const*a)
+{
+	if (*a)
+		(*a)-&gt;soap_serialize(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1DirectoryCategoryArray(struct soap *soap, gapi1DirectoryCategoryArray *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogapi1DirectoryCategoryArray);
+	if (soap_out_PointerTogapi1DirectoryCategoryArray(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1DirectoryCategoryArray(struct soap *soap, const char *tag, int id, gapi1DirectoryCategoryArray *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&amp;(*a)-&gt;__ptr, 1, type, SOAP_TYPE_gapi1DirectoryCategoryArray);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	return (*a)-&gt;soap_out(soap, tag, id, type);
+}
+
+SOAP_FMAC3 gapi1DirectoryCategoryArray ** SOAP_FMAC4 soap_get_PointerTogapi1DirectoryCategoryArray(struct soap *soap, gapi1DirectoryCategoryArray **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerTogapi1DirectoryCategoryArray(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1DirectoryCategoryArray ** SOAP_FMAC4 soap_in_PointerTogapi1DirectoryCategoryArray(struct soap *soap, const char *tag, gapi1DirectoryCategoryArray **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1DirectoryCategoryArray **)soap_malloc(soap, sizeof(gapi1DirectoryCategoryArray *))))
+			return NULL;
+	*a = NULL;
+	if (!soap-&gt;null &amp;&amp; *soap-&gt;href != '#')
+	{	soap_revert(soap);
+		if (!(*a = (gapi1DirectoryCategoryArray *)soap_instantiate_gapi1DirectoryCategoryArray(soap, -1, soap-&gt;type, soap-&gt;arrayType, NULL)))
+			return NULL;
+		(*a)-&gt;soap_default(soap);
+		if (!(*a)-&gt;soap_in(soap, tag, NULL))
+			return NULL;
+	}
+	else
+	{	a = (gapi1DirectoryCategoryArray **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1DirectoryCategoryArray, sizeof(gapi1DirectoryCategoryArray), 0);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1ResultElementArray(struct soap *soap, gapi1ResultElementArray *const*a)
+{
+	if (*a)
+		(*a)-&gt;soap_serialize(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1ResultElementArray(struct soap *soap, gapi1ResultElementArray *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogapi1ResultElementArray);
+	if (soap_out_PointerTogapi1ResultElementArray(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1ResultElementArray(struct soap *soap, const char *tag, int id, gapi1ResultElementArray *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&amp;(*a)-&gt;__ptr, 1, type, SOAP_TYPE_gapi1ResultElementArray);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	return (*a)-&gt;soap_out(soap, tag, id, type);
+}
+
+SOAP_FMAC3 gapi1ResultElementArray ** SOAP_FMAC4 soap_get_PointerTogapi1ResultElementArray(struct soap *soap, gapi1ResultElementArray **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerTogapi1ResultElementArray(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 gapi1ResultElementArray ** SOAP_FMAC4 soap_in_PointerTogapi1ResultElementArray(struct soap *soap, const char *tag, gapi1ResultElementArray **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (gapi1ResultElementArray **)soap_malloc(soap, sizeof(gapi1ResultElementArray *))))
+			return NULL;
+	*a = NULL;
+	if (!soap-&gt;null &amp;&amp; *soap-&gt;href != '#')
+	{	soap_revert(soap);
+		if (!(*a = (gapi1ResultElementArray *)soap_instantiate_gapi1ResultElementArray(soap, -1, soap-&gt;type, soap-&gt;arrayType, NULL)))
+			return NULL;
+		(*a)-&gt;soap_default(soap);
+		if (!(*a)-&gt;soap_in(soap, tag, NULL))
+			return NULL;
+	}
+	else
+	{	a = (gapi1ResultElementArray **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_gapi1ResultElementArray, sizeof(gapi1ResultElementArray), 0);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
+{
+	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
+	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
+{
+	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
+	if (id &lt; 0)
+		return soap-&gt;error;
+	return soap_out_unsignedByte(soap, tag, id, *a, type);
+}
+
+SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
+{
+	if (soap_element_begin_in(soap, tag, 1))
+		return NULL;
+	if (!a)
+		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
+			return NULL;
+	*a = NULL;
+	if (!soap-&gt;null &amp;&amp; *soap-&gt;href != '#')
+	{	soap_revert(soap);
+		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
+			return NULL;
+	}
+	else
+	{	a = (unsigned char **)soap_id_lookup(soap, soap-&gt;href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
+		if (soap-&gt;body &amp;&amp; soap_element_end_in(soap, tag))
+			return NULL;
+	}
+	return a;
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
+{	soap_default_string(soap, a);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
+{	soap_serialize_string(soap, a);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
+	if (soap_out__QName(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
+{
+	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
+}
+
+SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
+{
+	if ((p = soap_in__QName(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
+{
+	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
+{	(void)soap; /* appease -Wall -Werror */
+#ifdef SOAP_DEFAULT_string
+	*a = SOAP_DEFAULT_string;
+#else
+	*a = (char *)0;
+#endif
+}
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
+{
+	soap_reference(soap, *a, SOAP_TYPE_string);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
+{
+	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
+	if (soap_out_string(soap, tag, id, a, type))
+		return soap-&gt;error;
+	return soap_putindependent(soap);
+}
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
+{
+	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
+}
+
+SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
+{
+	if ((p = soap_in_string(soap, tag, p, type)))
+		soap_getindependent(soap);
+	return p;
+}
+
+SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
+{
+	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
+}
+
+/* End of GAPIC.cpp */

Added: trunk/Search/Google/GAPIClient.cpp
===================================================================
--- trunk/Search/Google/GAPIClient.cpp	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPIClient.cpp	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,185 @@
+/* GAPIClient.cpp
+   Generated by gSOAP 2.7.6e from GoogleSearch.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+#include &quot;GAPIH.h&quot;
+
+SOAP_SOURCE_STAMP(&quot;@(#) GAPIClient.cpp ver 2.7.6e 2006-04-05 04:17:23 GMT&quot;)
+
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_call_gapi1__doGetCachedPage(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string key, std::string url, xsd__base64Binary &amp;return_)
+{	struct gapi1__doGetCachedPage soap_tmp_gapi1__doGetCachedPage;
+	struct gapi1__doGetCachedPageResponse *soap_tmp_gapi1__doGetCachedPageResponse;
+	if (!soap_endpoint)
+		soap_endpoint = &quot;<A HREF="http://api.google.com/search/beta2">http://api.google.com/search/beta2</A>&quot;;
+	if (!soap_action)
+		soap_action = &quot;urn:GoogleSearchAction&quot;;
+	soap-&gt;encodingStyle = &quot;<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>&quot;;
+	soap_tmp_gapi1__doGetCachedPage.key = key;
+	soap_tmp_gapi1__doGetCachedPage.url = url;
+	soap_begin(soap);
+	soap_serializeheader(soap);
+	soap_serialize_gapi1__doGetCachedPage(soap, &amp;soap_tmp_gapi1__doGetCachedPage);
+	if (soap_begin_count(soap))
+		return soap-&gt;error;
+	if (soap-&gt;mode &amp; SOAP_IO_LENGTH)
+	{	if (soap_envelope_begin_out(soap)
+		 || soap_putheader(soap)
+		 || soap_body_begin_out(soap)
+		 || soap_put_gapi1__doGetCachedPage(soap, &amp;soap_tmp_gapi1__doGetCachedPage, &quot;gapi1:doGetCachedPage&quot;, &quot;&quot;)
+		 || soap_body_end_out(soap)
+		 || soap_envelope_end_out(soap))
+			 return soap-&gt;error;
+	}
+	if (soap_end_count(soap))
+		return soap-&gt;error;
+	if (soap_connect(soap, soap_endpoint, soap_action)
+	 || soap_envelope_begin_out(soap)
+	 || soap_putheader(soap)
+	 || soap_body_begin_out(soap)
+	 || soap_put_gapi1__doGetCachedPage(soap, &amp;soap_tmp_gapi1__doGetCachedPage, &quot;gapi1:doGetCachedPage&quot;, &quot;&quot;)
+	 || soap_body_end_out(soap)
+	 || soap_envelope_end_out(soap)
+	 || soap_end_send(soap))
+		return soap_closesock(soap);
+	if (!&amp;return_)
+		return soap_closesock(soap);
+	return_.soap_default(soap);
+	if (soap_begin_recv(soap)
+	 || soap_envelope_begin_in(soap)
+	 || soap_recv_header(soap)
+	 || soap_body_begin_in(soap))
+		return soap_closesock(soap);
+	soap_tmp_gapi1__doGetCachedPageResponse = soap_get_gapi1__doGetCachedPageResponse(soap, NULL, &quot;gapi1:doGetCachedPageResponse&quot;, &quot;&quot;);
+	if (soap-&gt;error)
+	{	if (soap-&gt;error == SOAP_TAG_MISMATCH &amp;&amp; soap-&gt;level == 2)
+			return soap_recv_fault(soap);
+		return soap_closesock(soap);
+	}
+	if (soap_body_end_in(soap)
+	 || soap_envelope_end_in(soap)
+	 || soap_end_recv(soap))
+		return soap_closesock(soap);
+	return_ = soap_tmp_gapi1__doGetCachedPageResponse-&gt;return_;
+	return soap_closesock(soap);
+}
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_call_gapi1__doSpellingSuggestion(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string key, std::string phrase, std::string &amp;return_)
+{	struct gapi1__doSpellingSuggestion soap_tmp_gapi1__doSpellingSuggestion;
+	struct gapi1__doSpellingSuggestionResponse *soap_tmp_gapi1__doSpellingSuggestionResponse;
+	if (!soap_endpoint)
+		soap_endpoint = &quot;<A HREF="http://api.google.com/search/beta2">http://api.google.com/search/beta2</A>&quot;;
+	if (!soap_action)
+		soap_action = &quot;urn:GoogleSearchAction&quot;;
+	soap-&gt;encodingStyle = &quot;<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>&quot;;
+	soap_tmp_gapi1__doSpellingSuggestion.key = key;
+	soap_tmp_gapi1__doSpellingSuggestion.phrase = phrase;
+	soap_begin(soap);
+	soap_serializeheader(soap);
+	soap_serialize_gapi1__doSpellingSuggestion(soap, &amp;soap_tmp_gapi1__doSpellingSuggestion);
+	if (soap_begin_count(soap))
+		return soap-&gt;error;
+	if (soap-&gt;mode &amp; SOAP_IO_LENGTH)
+	{	if (soap_envelope_begin_out(soap)
+		 || soap_putheader(soap)
+		 || soap_body_begin_out(soap)
+		 || soap_put_gapi1__doSpellingSuggestion(soap, &amp;soap_tmp_gapi1__doSpellingSuggestion, &quot;gapi1:doSpellingSuggestion&quot;, &quot;&quot;)
+		 || soap_body_end_out(soap)
+		 || soap_envelope_end_out(soap))
+			 return soap-&gt;error;
+	}
+	if (soap_end_count(soap))
+		return soap-&gt;error;
+	if (soap_connect(soap, soap_endpoint, soap_action)
+	 || soap_envelope_begin_out(soap)
+	 || soap_putheader(soap)
+	 || soap_body_begin_out(soap)
+	 || soap_put_gapi1__doSpellingSuggestion(soap, &amp;soap_tmp_gapi1__doSpellingSuggestion, &quot;gapi1:doSpellingSuggestion&quot;, &quot;&quot;)
+	 || soap_body_end_out(soap)
+	 || soap_envelope_end_out(soap)
+	 || soap_end_send(soap))
+		return soap_closesock(soap);
+	soap_default_std__string(soap, &amp;return_);
+	if (soap_begin_recv(soap)
+	 || soap_envelope_begin_in(soap)
+	 || soap_recv_header(soap)
+	 || soap_body_begin_in(soap))
+		return soap_closesock(soap);
+	soap_tmp_gapi1__doSpellingSuggestionResponse = soap_get_gapi1__doSpellingSuggestionResponse(soap, NULL, &quot;gapi1:doSpellingSuggestionResponse&quot;, &quot;&quot;);
+	if (soap-&gt;error)
+	{	if (soap-&gt;error == SOAP_TAG_MISMATCH &amp;&amp; soap-&gt;level == 2)
+			return soap_recv_fault(soap);
+		return soap_closesock(soap);
+	}
+	if (soap_body_end_in(soap)
+	 || soap_envelope_end_in(soap)
+	 || soap_end_recv(soap))
+		return soap_closesock(soap);
+	return_ = soap_tmp_gapi1__doSpellingSuggestionResponse-&gt;return_;
+	return soap_closesock(soap);
+}
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_call_gapi1__doGoogleSearch(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string key, std::string q, int start, int maxResults, bool filter, std::string restrict_, bool safeSearch, std::string lr, std::string ie, std::string oe, struct gapi1__doGoogleSearchResponse &amp;_param_1)
+{	struct gapi1__doGoogleSearch soap_tmp_gapi1__doGoogleSearch;
+	if (!soap_endpoint)
+		soap_endpoint = &quot;<A HREF="http://api.google.com/search/beta2">http://api.google.com/search/beta2</A>&quot;;
+	if (!soap_action)
+		soap_action = &quot;urn:GoogleSearchAction&quot;;
+	soap-&gt;encodingStyle = &quot;<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>&quot;;
+	soap_tmp_gapi1__doGoogleSearch.key = key;
+	soap_tmp_gapi1__doGoogleSearch.q = q;
+	soap_tmp_gapi1__doGoogleSearch.start = start;
+	soap_tmp_gapi1__doGoogleSearch.maxResults = maxResults;
+	soap_tmp_gapi1__doGoogleSearch.filter = filter;
+	soap_tmp_gapi1__doGoogleSearch.restrict_ = restrict_;
+	soap_tmp_gapi1__doGoogleSearch.safeSearch = safeSearch;
+	soap_tmp_gapi1__doGoogleSearch.lr = lr;
+	soap_tmp_gapi1__doGoogleSearch.ie = ie;
+	soap_tmp_gapi1__doGoogleSearch.oe = oe;
+	soap_begin(soap);
+	soap_serializeheader(soap);
+	soap_serialize_gapi1__doGoogleSearch(soap, &amp;soap_tmp_gapi1__doGoogleSearch);
+	if (soap_begin_count(soap))
+		return soap-&gt;error;
+	if (soap-&gt;mode &amp; SOAP_IO_LENGTH)
+	{	if (soap_envelope_begin_out(soap)
+		 || soap_putheader(soap)
+		 || soap_body_begin_out(soap)
+		 || soap_put_gapi1__doGoogleSearch(soap, &amp;soap_tmp_gapi1__doGoogleSearch, &quot;gapi1:doGoogleSearch&quot;, &quot;&quot;)
+		 || soap_body_end_out(soap)
+		 || soap_envelope_end_out(soap))
+			 return soap-&gt;error;
+	}
+	if (soap_end_count(soap))
+		return soap-&gt;error;
+	if (soap_connect(soap, soap_endpoint, soap_action)
+	 || soap_envelope_begin_out(soap)
+	 || soap_putheader(soap)
+	 || soap_body_begin_out(soap)
+	 || soap_put_gapi1__doGoogleSearch(soap, &amp;soap_tmp_gapi1__doGoogleSearch, &quot;gapi1:doGoogleSearch&quot;, &quot;&quot;)
+	 || soap_body_end_out(soap)
+	 || soap_envelope_end_out(soap)
+	 || soap_end_send(soap))
+		return soap_closesock(soap);
+	soap_default_gapi1__doGoogleSearchResponse(soap, &amp;_param_1);
+	if (soap_begin_recv(soap)
+	 || soap_envelope_begin_in(soap)
+	 || soap_recv_header(soap)
+	 || soap_body_begin_in(soap))
+		return soap_closesock(soap);
+	soap_get_gapi1__doGoogleSearchResponse(soap, &amp;_param_1, &quot;gapi1:doGoogleSearchResponse&quot;, &quot;&quot;);
+	if (soap-&gt;error)
+	{	if (soap-&gt;error == SOAP_TAG_MISMATCH &amp;&amp; soap-&gt;level == 2)
+			return soap_recv_fault(soap);
+		return soap_closesock(soap);
+	}
+	if (soap_body_end_in(soap)
+	 || soap_envelope_end_in(soap)
+	 || soap_end_recv(soap))
+		return soap_closesock(soap);
+	return soap_closesock(soap);
+}
+
+/* End of GAPIClient.cpp */

Added: trunk/Search/Google/GAPIClientLib.cpp
===================================================================
--- trunk/Search/Google/GAPIClientLib.cpp	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPIClientLib.cpp	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,14 @@
+/* GAPIClientLib.cpp
+   Generated by gSOAP 2.7.6e from GoogleSearch.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+#ifndef WITH_NOGLOBAL
+#define WITH_NOGLOBAL
+#endif
+#define SOAP_FMAC3 static
+#include &quot;GAPIC.cpp&quot;
+#include &quot;GAPIClient.cpp&quot;
+
+/* End of GAPIClientLib.cpp */

Added: trunk/Search/Google/GAPIGoogleSearchBindingProxy.h
===================================================================
--- trunk/Search/Google/GAPIGoogleSearchBindingProxy.h	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPIGoogleSearchBindingProxy.h	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,22 @@
+/* GAPIGoogleSearchBindingProxy.h
+   Generated by gSOAP 2.7.6e from GoogleSearch.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+
+#ifndef GAPIGoogleSearchBinding_H
+#define GAPIGoogleSearchBinding_H
+#include &quot;GAPIH.h&quot;
+extern SOAP_NMAC struct Namespace GAPI_namespaces[];
+class GoogleSearchBinding
+{   public:
+	struct soap *soap;
+	const char *endpoint;
+	GoogleSearchBinding() { soap = soap_new(); if (soap) soap-&gt;namespaces = GAPI_namespaces; endpoint = &quot;<A HREF="http://api.google.com/search/beta2">http://api.google.com/search/beta2</A>&quot;; };
+	virtual ~GoogleSearchBinding() { if (soap) { soap_destroy(soap); soap_end(soap); soap_done(soap); soap_del(soap); } };
+	virtual int gapi1__doGetCachedPage(std::string key, std::string url, xsd__base64Binary &amp;return_) { return soap ? soap_call_gapi1__doGetCachedPage(soap, endpoint, NULL, key, url, return_) : SOAP_EOM; };
+	virtual int gapi1__doSpellingSuggestion(std::string key, std::string phrase, std::string &amp;return_) { return soap ? soap_call_gapi1__doSpellingSuggestion(soap, endpoint, NULL, key, phrase, return_) : SOAP_EOM; };
+	virtual int gapi1__doGoogleSearch(std::string key, std::string q, int start, int maxResults, bool filter, std::string restrict_, bool safeSearch, std::string lr, std::string ie, std::string oe, struct gapi1__doGoogleSearchResponse &amp;_param_1) { return soap ? soap_call_gapi1__doGoogleSearch(soap, endpoint, NULL, key, q, start, maxResults, filter, restrict_, safeSearch, lr, ie, oe, _param_1) : SOAP_EOM; };
+};
+#endif

Added: trunk/Search/Google/GAPIH.h
===================================================================
--- trunk/Search/Google/GAPIH.h	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPIH.h	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,490 @@
+/* GAPIH.h
+   Generated by gSOAP 2.7.6e from GoogleSearch.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+
+#ifndef GAPIH_H
+#define GAPIH_H
+#include &quot;GAPIStub.h&quot;
+SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap*);
+#ifndef WITH_NOIDREF
+SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap*, const void*, int);
+SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap*, const void*, const char*, int, int);
+SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap*, int*);
+#endif
+
+SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist*);
+SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap*, const char*, void*, int, size_t, const char*, const char*);
+
+SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap*, const char*, void*, size_t, int, int, size_t, unsigned int);
+
+SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_byte
+#define SOAP_TYPE_byte (2)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap*, char *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap*, const char *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap*, const char*, int, const char *, const char*);
+SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap*, char *, const char*, const char*);
+SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap*, const char*, char *, const char*);
+
+#ifndef SOAP_TYPE_int
+#define SOAP_TYPE_int (1)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap*, int *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap*, const int *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap*, const char*, int, const int *, const char*);
+SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap*, int *, const char*, const char*);
+SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap*, const char*, int *, const char*);
+
+#ifndef SOAP_TYPE_double
+#define SOAP_TYPE_double (23)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap*, double *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap*, const double *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap*, const char*, int, const double *, const char*);
+SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap*, double *, const char*, const char*);
+SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap*, const char*, double *, const char*);
+
+#ifndef SOAP_TYPE_unsignedByte
+#define SOAP_TYPE_unsignedByte (9)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap*, unsigned char *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap*, const unsigned char *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap*, const char*, int, const unsigned char *, const char*);
+SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap*, unsigned char *, const char*, const char*);
+SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap*, const char*, unsigned char *, const char*);
+
+#ifndef SOAP_TYPE_unsignedInt
+#define SOAP_TYPE_unsignedInt (8)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap*, unsigned int *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap*, const unsigned int *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap*, const char*, int, const unsigned int *, const char*);
+SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap*, unsigned int *, const char*, const char*);
+SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap*, const char*, unsigned int *, const char*);
+
+#ifndef SOAP_TYPE_bool
+#define SOAP_TYPE_bool (20)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap*, bool *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap*, const bool *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap*, const char*, int, const bool *, const char*);
+
+SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap*, bool);
+SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap*, bool *, const char*, const char*);
+SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap*, const char*, bool *, const char*);
+
+SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap*, const char*, bool *);
+
+#ifndef SOAP_TYPE_gapi1__DirectoryCategory
+#define SOAP_TYPE_gapi1__DirectoryCategory (19)
+#endif
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__DirectoryCategory(struct soap*, const char*, int, const gapi1__DirectoryCategory *, const char*);
+SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_get_gapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory *, const char*, const char*);
+SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_in_gapi1__DirectoryCategory(struct soap*, const char*, gapi1__DirectoryCategory *, const char*);
+SOAP_FMAC5 gapi1__DirectoryCategory * SOAP_FMAC6 soap_new_gapi1__DirectoryCategory(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory*);
+SOAP_FMAC3 gapi1__DirectoryCategory * SOAP_FMAC4 soap_instantiate_gapi1__DirectoryCategory(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__DirectoryCategory(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1DirectoryCategoryArray
+#define SOAP_TYPE_gapi1DirectoryCategoryArray (18)
+#endif
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1DirectoryCategoryArray(struct soap*, const char*, int, const gapi1DirectoryCategoryArray *, const char*);
+SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_get_gapi1DirectoryCategoryArray(struct soap*, gapi1DirectoryCategoryArray *, const char*, const char*);
+SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_in_gapi1DirectoryCategoryArray(struct soap*, const char*, gapi1DirectoryCategoryArray *, const char*);
+SOAP_FMAC5 gapi1DirectoryCategoryArray * SOAP_FMAC6 soap_new_gapi1DirectoryCategoryArray(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1DirectoryCategoryArray(struct soap*, gapi1DirectoryCategoryArray*);
+SOAP_FMAC3 gapi1DirectoryCategoryArray * SOAP_FMAC4 soap_instantiate_gapi1DirectoryCategoryArray(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1DirectoryCategoryArray(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1ResultElementArray
+#define SOAP_TYPE_gapi1ResultElementArray (17)
+#endif
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1ResultElementArray(struct soap*, const char*, int, const gapi1ResultElementArray *, const char*);
+SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_get_gapi1ResultElementArray(struct soap*, gapi1ResultElementArray *, const char*, const char*);
+SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_in_gapi1ResultElementArray(struct soap*, const char*, gapi1ResultElementArray *, const char*);
+SOAP_FMAC5 gapi1ResultElementArray * SOAP_FMAC6 soap_new_gapi1ResultElementArray(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1ResultElementArray(struct soap*, gapi1ResultElementArray*);
+SOAP_FMAC3 gapi1ResultElementArray * SOAP_FMAC4 soap_instantiate_gapi1ResultElementArray(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1ResultElementArray(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__ResultElement
+#define SOAP_TYPE_gapi1__ResultElement (16)
+#endif
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__ResultElement(struct soap*, const char*, int, const gapi1__ResultElement *, const char*);
+SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_get_gapi1__ResultElement(struct soap*, gapi1__ResultElement *, const char*, const char*);
+SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_in_gapi1__ResultElement(struct soap*, const char*, gapi1__ResultElement *, const char*);
+SOAP_FMAC5 gapi1__ResultElement * SOAP_FMAC6 soap_new_gapi1__ResultElement(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__ResultElement(struct soap*, gapi1__ResultElement*);
+SOAP_FMAC3 gapi1__ResultElement * SOAP_FMAC4 soap_instantiate_gapi1__ResultElement(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__ResultElement(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__GoogleSearchResult
+#define SOAP_TYPE_gapi1__GoogleSearchResult (15)
+#endif
+
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__GoogleSearchResult(struct soap*, const char*, int, const gapi1__GoogleSearchResult *, const char*);
+SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_get_gapi1__GoogleSearchResult(struct soap*, gapi1__GoogleSearchResult *, const char*, const char*);
+SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_in_gapi1__GoogleSearchResult(struct soap*, const char*, gapi1__GoogleSearchResult *, const char*);
+SOAP_FMAC5 gapi1__GoogleSearchResult * SOAP_FMAC6 soap_new_gapi1__GoogleSearchResult(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__GoogleSearchResult(struct soap*, gapi1__GoogleSearchResult*);
+SOAP_FMAC3 gapi1__GoogleSearchResult * SOAP_FMAC4 soap_instantiate_gapi1__GoogleSearchResult(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__GoogleSearchResult(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE__SOAP_ENC__arrayType
+#define SOAP_TYPE__SOAP_ENC__arrayType (14)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__SOAP_ENC__arrayType(struct soap*, std::string const*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default__SOAP_ENC__arrayType(struct soap*, std::string *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put__SOAP_ENC__arrayType(struct soap*, const std::string *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out__SOAP_ENC__arrayType(struct soap*, const char*, int, const std::string*, const char*);
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get__SOAP_ENC__arrayType(struct soap*, std::string *, const char*, const char*);
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in__SOAP_ENC__arrayType(struct soap*, const char*, std::string*, const char*);
+SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new__SOAP_ENC__arrayType(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete__SOAP_ENC__arrayType(struct soap*, std::string*);
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate__SOAP_ENC__arrayType(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy__SOAP_ENC__arrayType(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_std__string
+#define SOAP_TYPE_std__string (13)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap*, const std::string *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap*, std::string *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap*, const std::string *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap*, const char*, int, const std::string*, const char*);
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap*, std::string *, const char*, const char*);
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap*, const char*, std::string*, const char*);
+SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap*, std::string*);
+SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_xsd__base64Binary
+#define SOAP_TYPE_xsd__base64Binary (7)
+#endif
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap*, const char*, int, const xsd__base64Binary *, const char*);
+SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap*, xsd__base64Binary *, const char*, const char*);
+SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap*, const char*, xsd__base64Binary *, const char*);
+SOAP_FMAC5 xsd__base64Binary * SOAP_FMAC6 soap_new_xsd__base64Binary(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__base64Binary(struct soap*, xsd__base64Binary*);
+SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Fault
+#define SOAP_TYPE_SOAP_ENV__Fault (48)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap*, const char*, int, const struct SOAP_ENV__Fault *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap*, const char*, struct SOAP_ENV__Fault *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault*);
+SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Reason
+#define SOAP_TYPE_SOAP_ENV__Reason (47)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap*, const char*, int, const struct SOAP_ENV__Reason *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason*);
+SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Detail
+#define SOAP_TYPE_SOAP_ENV__Detail (46)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap*, const char*, int, const struct SOAP_ENV__Detail *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail*);
+SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Code
+#define SOAP_TYPE_SOAP_ENV__Code (44)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap*, const char*, int, const struct SOAP_ENV__Code *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code*);
+SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_SOAP_ENV__Header
+#define SOAP_TYPE_SOAP_ENV__Header (43)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap*, const char*, int, const struct SOAP_ENV__Header *, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap*, const char*, struct SOAP_ENV__Header *, const char*);
+SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header*);
+SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doGoogleSearch
+#define SOAP_TYPE_gapi1__doGoogleSearch (40)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGoogleSearch(struct soap*, const struct gapi1__doGoogleSearch *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGoogleSearch(struct soap*, struct gapi1__doGoogleSearch *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGoogleSearch(struct soap*, const struct gapi1__doGoogleSearch *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGoogleSearch(struct soap*, const char*, int, const struct gapi1__doGoogleSearch *, const char*);
+SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_get_gapi1__doGoogleSearch(struct soap*, struct gapi1__doGoogleSearch *, const char*, const char*);
+SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_in_gapi1__doGoogleSearch(struct soap*, const char*, struct gapi1__doGoogleSearch *, const char*);
+SOAP_FMAC5 struct gapi1__doGoogleSearch * SOAP_FMAC6 soap_new_gapi1__doGoogleSearch(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGoogleSearch(struct soap*, struct gapi1__doGoogleSearch*);
+SOAP_FMAC3 struct gapi1__doGoogleSearch * SOAP_FMAC4 soap_instantiate_gapi1__doGoogleSearch(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGoogleSearch(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__doGoogleSearchResponse
+#define SOAP_TYPE_gapi1__doGoogleSearchResponse (36)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGoogleSearchResponse(struct soap*, const struct gapi1__doGoogleSearchResponse *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGoogleSearchResponse(struct soap*, struct gapi1__doGoogleSearchResponse *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGoogleSearchResponse(struct soap*, const struct gapi1__doGoogleSearchResponse *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGoogleSearchResponse(struct soap*, const char*, int, const struct gapi1__doGoogleSearchResponse *, const char*);
+SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_get_gapi1__doGoogleSearchResponse(struct soap*, struct gapi1__doGoogleSearchResponse *, const char*, const char*);
+SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_in_gapi1__doGoogleSearchResponse(struct soap*, const char*, struct gapi1__doGoogleSearchResponse *, const char*);
+SOAP_FMAC5 struct gapi1__doGoogleSearchResponse * SOAP_FMAC6 soap_new_gapi1__doGoogleSearchResponse(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGoogleSearchResponse(struct soap*, struct gapi1__doGoogleSearchResponse*);
+SOAP_FMAC3 struct gapi1__doGoogleSearchResponse * SOAP_FMAC4 soap_instantiate_gapi1__doGoogleSearchResponse(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGoogleSearchResponse(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__doSpellingSuggestion
+#define SOAP_TYPE_gapi1__doSpellingSuggestion (35)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doSpellingSuggestion(struct soap*, const struct gapi1__doSpellingSuggestion *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doSpellingSuggestion(struct soap*, struct gapi1__doSpellingSuggestion *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doSpellingSuggestion(struct soap*, const struct gapi1__doSpellingSuggestion *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doSpellingSuggestion(struct soap*, const char*, int, const struct gapi1__doSpellingSuggestion *, const char*);
+SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_get_gapi1__doSpellingSuggestion(struct soap*, struct gapi1__doSpellingSuggestion *, const char*, const char*);
+SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_in_gapi1__doSpellingSuggestion(struct soap*, const char*, struct gapi1__doSpellingSuggestion *, const char*);
+SOAP_FMAC5 struct gapi1__doSpellingSuggestion * SOAP_FMAC6 soap_new_gapi1__doSpellingSuggestion(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doSpellingSuggestion(struct soap*, struct gapi1__doSpellingSuggestion*);
+SOAP_FMAC3 struct gapi1__doSpellingSuggestion * SOAP_FMAC4 soap_instantiate_gapi1__doSpellingSuggestion(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doSpellingSuggestion(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__doSpellingSuggestionResponse
+#define SOAP_TYPE_gapi1__doSpellingSuggestionResponse (34)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doSpellingSuggestionResponse(struct soap*, const struct gapi1__doSpellingSuggestionResponse *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doSpellingSuggestionResponse(struct soap*, struct gapi1__doSpellingSuggestionResponse *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doSpellingSuggestionResponse(struct soap*, const struct gapi1__doSpellingSuggestionResponse *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doSpellingSuggestionResponse(struct soap*, const char*, int, const struct gapi1__doSpellingSuggestionResponse *, const char*);
+SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_get_gapi1__doSpellingSuggestionResponse(struct soap*, struct gapi1__doSpellingSuggestionResponse *, const char*, const char*);
+SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_in_gapi1__doSpellingSuggestionResponse(struct soap*, const char*, struct gapi1__doSpellingSuggestionResponse *, const char*);
+SOAP_FMAC5 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC6 soap_new_gapi1__doSpellingSuggestionResponse(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doSpellingSuggestionResponse(struct soap*, struct gapi1__doSpellingSuggestionResponse*);
+SOAP_FMAC3 struct gapi1__doSpellingSuggestionResponse * SOAP_FMAC4 soap_instantiate_gapi1__doSpellingSuggestionResponse(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doSpellingSuggestionResponse(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__doGetCachedPage
+#define SOAP_TYPE_gapi1__doGetCachedPage (31)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGetCachedPage(struct soap*, const struct gapi1__doGetCachedPage *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGetCachedPage(struct soap*, struct gapi1__doGetCachedPage *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGetCachedPage(struct soap*, const struct gapi1__doGetCachedPage *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGetCachedPage(struct soap*, const char*, int, const struct gapi1__doGetCachedPage *, const char*);
+SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_get_gapi1__doGetCachedPage(struct soap*, struct gapi1__doGetCachedPage *, const char*, const char*);
+SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_in_gapi1__doGetCachedPage(struct soap*, const char*, struct gapi1__doGetCachedPage *, const char*);
+SOAP_FMAC5 struct gapi1__doGetCachedPage * SOAP_FMAC6 soap_new_gapi1__doGetCachedPage(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGetCachedPage(struct soap*, struct gapi1__doGetCachedPage*);
+SOAP_FMAC3 struct gapi1__doGetCachedPage * SOAP_FMAC4 soap_instantiate_gapi1__doGetCachedPage(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGetCachedPage(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef SOAP_TYPE_gapi1__doGetCachedPageResponse
+#define SOAP_TYPE_gapi1__doGetCachedPageResponse (30)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_gapi1__doGetCachedPageResponse(struct soap*, const struct gapi1__doGetCachedPageResponse *);
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_gapi1__doGetCachedPageResponse(struct soap*, struct gapi1__doGetCachedPageResponse *);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_gapi1__doGetCachedPageResponse(struct soap*, const struct gapi1__doGetCachedPageResponse *, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_gapi1__doGetCachedPageResponse(struct soap*, const char*, int, const struct gapi1__doGetCachedPageResponse *, const char*);
+SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_get_gapi1__doGetCachedPageResponse(struct soap*, struct gapi1__doGetCachedPageResponse *, const char*, const char*);
+SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_in_gapi1__doGetCachedPageResponse(struct soap*, const char*, struct gapi1__doGetCachedPageResponse *, const char*);
+SOAP_FMAC5 struct gapi1__doGetCachedPageResponse * SOAP_FMAC6 soap_new_gapi1__doGetCachedPageResponse(struct soap*, int);
+SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gapi1__doGetCachedPageResponse(struct soap*, struct gapi1__doGetCachedPageResponse*);
+SOAP_FMAC3 struct gapi1__doGetCachedPageResponse * SOAP_FMAC4 soap_instantiate_gapi1__doGetCachedPageResponse(struct soap*, int, const char*, const char*, size_t*);
+SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gapi1__doGetCachedPageResponse(struct soap*, int, int, void*, size_t, const void*, size_t);
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
+#define SOAP_TYPE_PointerToSOAP_ENV__Reason (50)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap*, const char *, int, struct SOAP_ENV__Reason *const*, const char *);
+SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason **, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason **, const char*);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
+#define SOAP_TYPE_PointerToSOAP_ENV__Detail (49)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap*, const char *, int, struct SOAP_ENV__Detail *const*, const char *);
+SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail **, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail **, const char*);
+
+#endif
+
+#ifndef WITH_NOGLOBAL
+
+#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
+#define SOAP_TYPE_PointerToSOAP_ENV__Code (45)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap*, const char *, int, struct SOAP_ENV__Code *const*, const char *);
+SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code **, const char*, const char*);
+SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code **, const char*);
+
+#endif
+
+#ifndef SOAP_TYPE_PointerTogapi1__GoogleSearchResult
+#define SOAP_TYPE_PointerTogapi1__GoogleSearchResult (37)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1__GoogleSearchResult(struct soap*, gapi1__GoogleSearchResult *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1__GoogleSearchResult(struct soap*, gapi1__GoogleSearchResult *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1__GoogleSearchResult(struct soap*, const char *, int, gapi1__GoogleSearchResult *const*, const char *);
+SOAP_FMAC3 gapi1__GoogleSearchResult ** SOAP_FMAC4 soap_get_PointerTogapi1__GoogleSearchResult(struct soap*, gapi1__GoogleSearchResult **, const char*, const char*);
+SOAP_FMAC3 gapi1__GoogleSearchResult ** SOAP_FMAC4 soap_in_PointerTogapi1__GoogleSearchResult(struct soap*, const char*, gapi1__GoogleSearchResult **, const char*);
+
+#ifndef SOAP_TYPE_PointerToPointerTogapi1__DirectoryCategory
+#define SOAP_TYPE_PointerToPointerTogapi1__DirectoryCategory (27)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTogapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory **const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTogapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory **const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTogapi1__DirectoryCategory(struct soap*, const char *, int, gapi1__DirectoryCategory **const*, const char *);
+SOAP_FMAC3 gapi1__DirectoryCategory *** SOAP_FMAC4 soap_get_PointerToPointerTogapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory ***, const char*, const char*);
+SOAP_FMAC3 gapi1__DirectoryCategory *** SOAP_FMAC4 soap_in_PointerToPointerTogapi1__DirectoryCategory(struct soap*, const char*, gapi1__DirectoryCategory ***, const char*);
+
+#ifndef SOAP_TYPE_PointerToPointerTogapi1__ResultElement
+#define SOAP_TYPE_PointerToPointerTogapi1__ResultElement (26)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTogapi1__ResultElement(struct soap*, gapi1__ResultElement **const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTogapi1__ResultElement(struct soap*, gapi1__ResultElement **const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTogapi1__ResultElement(struct soap*, const char *, int, gapi1__ResultElement **const*, const char *);
+SOAP_FMAC3 gapi1__ResultElement *** SOAP_FMAC4 soap_get_PointerToPointerTogapi1__ResultElement(struct soap*, gapi1__ResultElement ***, const char*, const char*);
+SOAP_FMAC3 gapi1__ResultElement *** SOAP_FMAC4 soap_in_PointerToPointerTogapi1__ResultElement(struct soap*, const char*, gapi1__ResultElement ***, const char*);
+
+#ifndef SOAP_TYPE_PointerTogapi1__ResultElement
+#define SOAP_TYPE_PointerTogapi1__ResultElement (25)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1__ResultElement(struct soap*, gapi1__ResultElement *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1__ResultElement(struct soap*, gapi1__ResultElement *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1__ResultElement(struct soap*, const char *, int, gapi1__ResultElement *const*, const char *);
+SOAP_FMAC3 gapi1__ResultElement ** SOAP_FMAC4 soap_get_PointerTogapi1__ResultElement(struct soap*, gapi1__ResultElement **, const char*, const char*);
+SOAP_FMAC3 gapi1__ResultElement ** SOAP_FMAC4 soap_in_PointerTogapi1__ResultElement(struct soap*, const char*, gapi1__ResultElement **, const char*);
+
+#ifndef SOAP_TYPE_PointerTogapi1__DirectoryCategory
+#define SOAP_TYPE_PointerTogapi1__DirectoryCategory (24)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1__DirectoryCategory(struct soap*, const char *, int, gapi1__DirectoryCategory *const*, const char *);
+SOAP_FMAC3 gapi1__DirectoryCategory ** SOAP_FMAC4 soap_get_PointerTogapi1__DirectoryCategory(struct soap*, gapi1__DirectoryCategory **, const char*, const char*);
+SOAP_FMAC3 gapi1__DirectoryCategory ** SOAP_FMAC4 soap_in_PointerTogapi1__DirectoryCategory(struct soap*, const char*, gapi1__DirectoryCategory **, const char*);
+
+#ifndef SOAP_TYPE_PointerTogapi1DirectoryCategoryArray
+#define SOAP_TYPE_PointerTogapi1DirectoryCategoryArray (22)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1DirectoryCategoryArray(struct soap*, gapi1DirectoryCategoryArray *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1DirectoryCategoryArray(struct soap*, gapi1DirectoryCategoryArray *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1DirectoryCategoryArray(struct soap*, const char *, int, gapi1DirectoryCategoryArray *const*, const char *);
+SOAP_FMAC3 gapi1DirectoryCategoryArray ** SOAP_FMAC4 soap_get_PointerTogapi1DirectoryCategoryArray(struct soap*, gapi1DirectoryCategoryArray **, const char*, const char*);
+SOAP_FMAC3 gapi1DirectoryCategoryArray ** SOAP_FMAC4 soap_in_PointerTogapi1DirectoryCategoryArray(struct soap*, const char*, gapi1DirectoryCategoryArray **, const char*);
+
+#ifndef SOAP_TYPE_PointerTogapi1ResultElementArray
+#define SOAP_TYPE_PointerTogapi1ResultElementArray (21)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogapi1ResultElementArray(struct soap*, gapi1ResultElementArray *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogapi1ResultElementArray(struct soap*, gapi1ResultElementArray *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogapi1ResultElementArray(struct soap*, const char *, int, gapi1ResultElementArray *const*, const char *);
+SOAP_FMAC3 gapi1ResultElementArray ** SOAP_FMAC4 soap_get_PointerTogapi1ResultElementArray(struct soap*, gapi1ResultElementArray **, const char*, const char*);
+SOAP_FMAC3 gapi1ResultElementArray ** SOAP_FMAC4 soap_in_PointerTogapi1ResultElementArray(struct soap*, const char*, gapi1ResultElementArray **, const char*);
+
+#ifndef SOAP_TYPE_PointerTounsignedByte
+#define SOAP_TYPE_PointerTounsignedByte (10)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap*, unsigned char *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap*, unsigned char *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap*, const char *, int, unsigned char *const*, const char *);
+SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap*, unsigned char **, const char*, const char*);
+SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap*, const char*, unsigned char **, const char*);
+
+#ifndef SOAP_TYPE__QName
+#define SOAP_TYPE__QName (5)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap*, char **);
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap*, char *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap*, char *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap*, const char*, int, char*const*, const char*);
+SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap*, char **, const char*, const char*);
+SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap*, const char*, char **, const char*);
+
+#ifndef SOAP_TYPE_string
+#define SOAP_TYPE_string (3)
+#endif
+SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap*, char **);
+SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap*, char *const*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap*, char *const*, const char*, const char*);
+SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap*, const char*, int, char*const*, const char*);
+SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap*, char **, const char*, const char*);
+SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap*, const char*, char **, const char*);
+
+#endif
+
+/* End of GAPIH.h */

Added: trunk/Search/Google/GAPIStub.h
===================================================================
--- trunk/Search/Google/GAPIStub.h	2006-04-04 15:16:44 UTC (rev 187)
+++ trunk/Search/Google/GAPIStub.h	2006-04-05 13:06:48 UTC (rev 188)
@@ -0,0 +1,404 @@
+/* GAPIStub.h
+   Generated by gSOAP 2.7.6e from GoogleSearch.h
+   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
+   This part of the software is released under one of the following licenses:
+   GPL, the gSOAP public license, or Genivia's license for commercial use.
+*/
+
+#ifndef GAPIStub_H
+#define GAPIStub_H
+#include &lt;vector&gt;
+#define WITH_NONAMESPACES
+#include &quot;stdsoap2.h&quot;
+
+/******************************************************************************\
+ *                                                                            *
+ * Enumerations                                                               *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Classes and Structs                                                        *
+ *                                                                            *
+\******************************************************************************/
+
+
+
+
+#ifndef SOAP_TYPE_xsd__base64Binary
+#define SOAP_TYPE_xsd__base64Binary (7)
+/* Base64 schema type: */
+class SOAP_CMAC xsd__base64Binary
+{
+public:
+	unsigned char *__ptr;
+	int __size;
+	char *id;	/* optional element of type xsd:string */
+	char *type;	/* optional element of type xsd:string */
+	char *options;	/* optional element of type xsd:string */
+	struct soap *soap;	/* transient */
+public:
+	virtual int soap_type() const { return 7; } /* = unique id SOAP_TYPE_xsd__base64Binary */
+	virtual void soap_default(struct soap*);
+	virtual void soap_serialize(struct soap*) const;
+	virtual int soap_put(struct soap*, const char*, const char*) const;
+	virtual int soap_out(struct soap*, const char*, int, const char*) const;
+	virtual void *soap_get(struct soap*, const char*, const char*);
+	virtual void *soap_in(struct soap*, const char*, const char*);
+	         xsd__base64Binary() : __ptr(NULL), id(NULL), type(NULL), options(NULL), soap(NULL) { }
+	virtual ~xsd__base64Binary() { }
+};
+#endif
+
+#if 0 /* volatile type: do no redeclare */
+
+#endif
+
+#ifndef SOAP_TYPE_gapi1__GoogleSearchResult
+#define SOAP_TYPE_gapi1__GoogleSearchResult (15)
+/* gapi1:GoogleSearchResult */
+class SOAP_CMAC gapi1__GoogleSearchResult
+{
+public:
+	bool documentFiltering;	/* required element of type xsd:boolean */
+	std::string searchComments;	/* required element of type xsd:string */
+	int estimatedTotalResultsCount;	/* required element of type xsd:int */
+	bool estimateIsExact;	/* required element of type xsd:boolean */
+	class gapi1ResultElementArray *resultElements;	/* required element of type ArrayOfResultElement */
+	std::string searchQuery;	/* required element of type xsd:string */
+	int startIndex;	/* required element of type xsd:int */
+	int endIndex;	/* required element of type xsd:int */
+	std::string searchTips;	/* required element of type xsd:string */
+	class gapi1DirectoryCategoryArray *directoryCategories;	/* required element of type ArrayOfDirectoryCategory */
+	double searchTime;	/* required element of type xsd:double */
+	struct soap *soap;	/* transient */
+public:
+	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_gapi1__GoogleSearchResult */
+	virtual void soap_default(struct soap*);
+	virtual void soap_serialize(struct soap*) const;
+	virtual int soap_put(struct soap*, const char*, const char*) const;
+	virtual int soap_out(struct soap*, const char*, int, const char*) const;
+	virtual void *soap_get(struct soap*, const char*, const char*);
+	virtual void *soap_in(struct soap*, const char*, const char*);
+	         gapi1__GoogleSearchResult() : resultElements(NULL), directoryCategories(NULL), soap(NULL) { }
+	virtual ~gapi1__GoogleSearchResult() { }
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__ResultElement
+#define SOAP_TYPE_gapi1__ResultElement (16)
+/* gapi1:ResultElement */
+class SOAP_CMAC gapi1__ResultElement
+{
+public:
+	std::string summary;	/* required element of type xsd:string */
+	std::string URL;	/* required element of type xsd:string */
+	std::string snippet;	/* required element of type xsd:string */
+	std::string title;	/* required element of type xsd:string */
+	std::string cachedSize;	/* required element of type xsd:string */
+	bool relatedInformationPresent;	/* required element of type xsd:boolean */
+	std::string hostName;	/* required element of type xsd:string */
+	class gapi1__DirectoryCategory *directoryCategory;	/* required element of type gapi1:DirectoryCategory */
+	std::string directoryTitle;	/* required element of type xsd:string */
+	struct soap *soap;	/* transient */
+public:
+	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_gapi1__ResultElement */
+	virtual void soap_default(struct soap*);
+	virtual void soap_serialize(struct soap*) const;
+	virtual int soap_put(struct soap*, const char*, const char*) const;
+	virtual int soap_out(struct soap*, const char*, int, const char*) const;
+	virtual void *soap_get(struct soap*, const char*, const char*);
+	virtual void *soap_in(struct soap*, const char*, const char*);
+	         gapi1__ResultElement() : directoryCategory(NULL), soap(NULL) { }
+	virtual ~gapi1__ResultElement() { }
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__DirectoryCategory
+#define SOAP_TYPE_gapi1__DirectoryCategory (19)
+/* gapi1:DirectoryCategory */
+class SOAP_CMAC gapi1__DirectoryCategory
+{
+public:
+	std::string fullViewableName;	/* required element of type xsd:string */
+	std::string specialEncoding;	/* required element of type xsd:string */
+	struct soap *soap;	/* transient */
+public:
+	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_gapi1__DirectoryCategory */
+	virtual void soap_default(struct soap*);
+	virtual void soap_serialize(struct soap*) const;
+	virtual int soap_put(struct soap*, const char*, const char*) const;
+	virtual int soap_out(struct soap*, const char*, int, const char*) const;
+	virtual void *soap_get(struct soap*, const char*, const char*);
+	virtual void *soap_in(struct soap*, const char*, const char*);
+	         gapi1__DirectoryCategory() : soap(NULL) { }
+	virtual ~gapi1__DirectoryCategory() { }
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1ResultElementArray
+#define SOAP_TYPE_gapi1ResultElementArray (17)
+/* SOAP encoded array of gapi1:ResultElement schema type: */
+class SOAP_CMAC gapi1ResultElementArray
+{
+public:
+	gapi1__ResultElement **__ptr;
+	int __size;
+	struct soap *soap;	/* transient */
+public:
+	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_gapi1ResultElementArray */
+	virtual void soap_default(struct soap*);
+	virtual void soap_serialize(struct soap*) const;
+	virtual int soap_put(struct soap*, const char*, const char*) const;
+	virtual int soap_out(struct soap*, const char*, int, const char*) const;
+	virtual void *soap_get(struct soap*, const char*, const char*);
+	virtual void *soap_in(struct soap*, const char*, const char*);
+	         gapi1ResultElementArray() : __ptr(NULL), soap(NULL) { }
+	virtual ~gapi1ResultElementArray() { }
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1DirectoryCategoryArray
+#define SOAP_TYPE_gapi1DirectoryCategoryArray (18)
+/* SOAP encoded array of gapi1:DirectoryCategory schema type: */
+class SOAP_CMAC gapi1DirectoryCategoryArray
+{
+public:
+	gapi1__DirectoryCategory **__ptr;
+	int __size;
+	struct soap *soap;	/* transient */
+public:
+	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_gapi1DirectoryCategoryArray */
+	virtual void soap_default(struct soap*);
+	virtual void soap_serialize(struct soap*) const;
+	virtual int soap_put(struct soap*, const char*, const char*) const;
+	virtual int soap_out(struct soap*, const char*, int, const char*) const;
+	virtual void *soap_get(struct soap*, const char*, const char*);
+	virtual void *soap_in(struct soap*, const char*, const char*);
+	         gapi1DirectoryCategoryArray() : __ptr(NULL), soap(NULL) { }
+	virtual ~gapi1DirectoryCategoryArray() { }
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doGetCachedPageResponse
+#define SOAP_TYPE_gapi1__doGetCachedPageResponse (30)
+/* gapi1:doGetCachedPageResponse */
+struct gapi1__doGetCachedPageResponse
+{
+public:
+	xsd__base64Binary return_;	/* RPC return element */	/* required element of type xsd:base64Binary */
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doGetCachedPage
+#define SOAP_TYPE_gapi1__doGetCachedPage (31)
+/* gapi1:doGetCachedPage */
+struct gapi1__doGetCachedPage
+{
+public:
+	std::string key;	/* required element of type xsd:string */
+	std::string url;	/* required element of type xsd:string */
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doSpellingSuggestionResponse
+#define SOAP_TYPE_gapi1__doSpellingSuggestionResponse (34)
+/* gapi1:doSpellingSuggestionResponse */
+struct gapi1__doSpellingSuggestionResponse
+{
+public:
+	std::string return_;	/* RPC return element */	/* required element of type xsd:string */
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doSpellingSuggestion
+#define SOAP_TYPE_gapi1__doSpellingSuggestion (35)
+/* gapi1:doSpellingSuggestion */
+struct gapi1__doSpellingSuggestion
+{
+public:
+	std::string key;	/* required element of type xsd:string */
+	std::string phrase;	/* required element of type xsd:string */
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doGoogleSearchResponse
+#define SOAP_TYPE_gapi1__doGoogleSearchResponse (36)
+/* gapi1:doGoogleSearchResponse */
+struct gapi1__doGoogleSearchResponse
+{
+public:
+	gapi1__GoogleSearchResult *return_;	/* RPC return element */	/* optional element of type gapi1:GoogleSearchResult */
+};
+#endif
+
+#ifndef SOAP_TYPE_gapi1__doGoogleSearch
+#define SOAP_TYPE_gapi1__doGoogleSearch (40)
+/* gapi1:doGoogleSearch */
+struct gapi1__doGoogleSearch
+{
+public:
+	std::string key;	/* required element of type xsd:string */
+	std::string q;	/* required element of type xsd:string */
+	int start;	/* required element of type xsd:int */
+	int maxResults;	/* required element of type xsd:int */
+	bool filter;	/* required element of type xsd:boolean */
+	std::string restrict_;	/* required element of type xsd:string */
+	bool safeSearch;	/* required element of type xsd:boolean */
+	std::string lr;	/* required element of type xsd:string */
+	std::string ie;	/* required element of type xsd:string */
+	std::string oe;	/* required element of type xsd:string */
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Header
+#define SOAP_TYPE_SOAP_ENV__Header (43)
+/* SOAP Header: */
+struct SOAP_ENV__Header
+{
+public:
+	void *dummy;	/* transient */
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Code
+#define SOAP_TYPE_SOAP_ENV__Code (44)
+/* SOAP Fault Code: */
+struct SOAP_ENV__Code
+{
+public:
+	char *SOAP_ENV__Value;	/* optional element of type QName */
+	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Detail
+#define SOAP_TYPE_SOAP_ENV__Detail (46)
+/* SOAP-ENV:Detail */
+struct SOAP_ENV__Detail
+{
+public:
+	int __type;	/* any type of element &lt;fault&gt; (defined below) */
+	void *fault;	/* transient */
+	char *__any;
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Reason
+#define SOAP_TYPE_SOAP_ENV__Reason (47)
+/* SOAP-ENV:Reason */
+struct SOAP_ENV__Reason
+{
+public:
+	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
+};
+#endif
+
+#ifndef SOAP_TYPE_SOAP_ENV__Fault
+#define SOAP_TYPE_SOAP_ENV__Fault (48)
+/* SOAP Fault: */
+struct SOAP_ENV__Fault
+{
+public:
+	char *faultcode;	/* optional element of type QName */
+	char *faultstring;	/* optional element of type xsd:string */
+	char *faultactor;	/* optional element of type xsd:string */
+	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
+	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
+	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
+	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
+	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
+	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
+};
+#endif
+
+/******************************************************************************\
+ *                                                                            *
+ * Types with Custom Serializers                                              *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Typedefs                                                                   *
+ *                                                                            *
+\******************************************************************************/
+
+#ifndef SOAP_TYPE__XML
+#define SOAP_TYPE__XML (4)
+typedef char *_XML;
+#endif
+
+#ifndef SOAP_TYPE__QName
+#define SOAP_TYPE__QName (5)
+typedef char *_QName;
+#endif
+
+#ifndef SOAP_TYPE__SOAP_ENC__arrayType
+#define SOAP_TYPE__SOAP_ENC__arrayType (14)
+typedef std::string _SOAP_ENC__arrayType;
+#endif
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Typedef Synonyms                                                           *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Externals                                                                  *
+ *                                                                            *
+\******************************************************************************/
+
+
+/******************************************************************************\
+ *                                                                            *
+ * Service Operations                                                         *
+ *                                                                            *
+\******************************************************************************/
+
+
+SOAP_FMAC5 int SOAP_FMAC6 gapi1__doGetCachedPage(struct soap*, std::string key, std::string url, xsd__base64Binary &amp;return_);
+
+SOAP_FMAC5 int SOAP_FMAC6 gapi1__doSpellingSuggestion(struct soap*, std::string key, std::string phrase, std::string &amp;return_);
+
+SOAP_FMAC5 int SOAP_FMAC6 gapi1__doGoogleSearch(struct soap*, std::string key, std::string q, int start, int maxResults, bool filter, std::string restrict_, bool safeSearch, std::string lr, std::string ie, std::string oe, struct gapi1__doGoogleSearchResponse &amp;_param_1);
+
+/******************************************************************************\
+ *                                                                            *
+ * Stubs                                                                      *
+ *                                                                            *
+\******************************************************************************/
+
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_call_gapi1__doGetCachedPage(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string key, std::string url, xsd__base64Binary &amp;return_);
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_call_gapi1__doSpellingSuggestion(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string key, std::string phrase, std::string &amp;return_);
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_call_gapi1__doGoogleSearch(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string key, std::string q, int start, int maxResults, bool filter, std::string restrict_, bool safeSearch, std::string lr, std::string ie, std::string oe, struct gapi1__doGoogleSearchResponse &amp;_param_1);
+
+/******************************************************************************\
+ *                                                                            *
+ * Skeletons                                                                  *
+ *                                                                            *
+\******************************************************************************/
+
+SOAP_FMAC5 int SOAP_FMAC6 GAPI_serve(struct soap*);
+
+SOAP_FMAC5 int SOAP_FMAC6 GAPI_serve_request(struct soap*);
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_serve_gapi1__doGetCachedPage(struct soap*);
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_serve_gapi1__doSpellingSuggestion(struct soap*);
+
+SOAP_FMAC5 int SOAP_FMAC6 soap_serve_gapi1__doGoogleSearch(struct soap*);
+
+#endif
+
+/* End of GAPIStub.h */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000185.html">[Pinot-svn] r187 - trunk/UI/GTK2/src
</A></li>
	<LI>Next message: <A HREF="000186.html">[Pinot-svn] r189 - trunk/Search/Google
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#187">[ date ]</a>
              <a href="thread.html#187">[ thread ]</a>
              <a href="subject.html#187">[ subject ]</a>
              <a href="author.html#187">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/pinot-svn">More information about the Pinot-svn
mailing list</a><br>
</body></html>
