From fabricecolin at berlios.de  Thu Dec  8 14:47:15 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Thu, 8 Dec 2005 14:47:15 +0100
Subject: [Pinot-svn] r1 - / trunk trunk/Collect trunk/Index trunk/SQL trunk/Search trunk/Search/Google trunk/Search/ObjectsSearch trunk/Search/Plugins trunk/Tokenize trunk/UI trunk/UI/GTK2 trunk/UI/GTK2/src trunk/UI/RenderHTML trunk/Utils trunk/po
Message-ID: <200512081347.jB8DlFcA029750@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-08 14:46:51 +0100 (Thu, 08 Dec 2005)
New Revision: 1

Added:
   trunk/
   trunk/COPYING
   trunk/ChangeLog
   trunk/Collect/
   trunk/Collect/DownloaderFactory.cpp
   trunk/Collect/DownloaderFactory.h
   trunk/Collect/DownloaderInterface.cpp
   trunk/Collect/DownloaderInterface.h
   trunk/Collect/FileCollector.cpp
   trunk/Collect/FileCollector.h
   trunk/Collect/Makefile
   trunk/Collect/MboxCollector.cpp
   trunk/Collect/MboxCollector.h
   trunk/Collect/NeonDownloader.cpp
   trunk/Collect/NeonDownloader.h
   trunk/Collect/XapianCollector.cpp
   trunk/Collect/XapianCollector.h
   trunk/Collect/dloadtest.cpp
   trunk/Index/
   trunk/Index/IndexInterface.h
   trunk/Index/LanguageDetector.cpp
   trunk/Index/LanguageDetector.h
   trunk/Index/Makefile
   trunk/Index/Summarizer.cpp
   trunk/Index/Summarizer.h
   trunk/Index/XapianIndex.cpp
   trunk/Index/XapianIndex.h
   trunk/Index/indextest.cpp
   trunk/Makefile
   trunk/README
   trunk/SQL/
   trunk/SQL/ActionHistory.cpp
   trunk/SQL/ActionHistory.h
   trunk/SQL/IndexHistory.cpp
   trunk/SQL/IndexHistory.h
   trunk/SQL/LabelManager.cpp
   trunk/SQL/LabelManager.h
   trunk/SQL/Makefile
   trunk/SQL/QueryHistory.cpp
   trunk/SQL/QueryHistory.h
   trunk/SQL/SQLiteBase.cpp
   trunk/SQL/SQLiteBase.h
   trunk/SQL/ViewHistory.cpp
   trunk/SQL/ViewHistory.h
   trunk/SQL/historytest.cpp
   trunk/Search/
   trunk/Search/Google/
   trunk/Search/Google/GoogleAPIEngine.cpp
   trunk/Search/Google/GoogleAPIEngine.h
   trunk/Search/Google/GoogleSearch.h
   trunk/Search/Google/Makefile
   trunk/Search/Makefile
   trunk/Search/ObjectsSearch/
   trunk/Search/ObjectsSearch/Makefile
   trunk/Search/ObjectsSearch/ObjectsSearch.h
   trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.cpp
   trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.h
   trunk/Search/PluginWebEngine.cpp
   trunk/Search/PluginWebEngine.h
   trunk/Search/Plugins/
   trunk/Search/Plugins/A9.src
   trunk/Search/Plugins/Acoona.src
   trunk/Search/Plugins/Altavista.src
   trunk/Search/Plugins/AmazonAPI.src
   trunk/Search/Plugins/AskJeeves.src
   trunk/Search/Plugins/BitTorrent.src
   trunk/Search/Plugins/Clusty.src
   trunk/Search/Plugins/Freshmeat.src
   trunk/Search/Plugins/Google.src
   trunk/Search/Plugins/Koders.src
   trunk/Search/Plugins/Lycos.src
   trunk/Search/Plugins/MSN.src
   trunk/Search/Plugins/Omega.src
   trunk/Search/Plugins/Teoma.src
   trunk/Search/Plugins/Topix.src
   trunk/Search/Plugins/Wikipedia.src
   trunk/Search/Plugins/WiseNut.src
   trunk/Search/Plugins/Yahoo.src
   trunk/Search/Plugins/YahooAPI.src
   trunk/Search/QueryProperties.cpp
   trunk/Search/QueryProperties.h
   trunk/Search/SOAPEnvNS.cpp
   trunk/Search/SearchEngineFactory.cpp
   trunk/Search/SearchEngineFactory.h
   trunk/Search/SearchEngineInterface.cpp
   trunk/Search/SearchEngineInterface.h
   trunk/Search/WebEngine.cpp
   trunk/Search/WebEngine.h
   trunk/Search/XapianEngine.cpp
   trunk/Search/XapianEngine.h
   trunk/Search/senginetest.cpp
   trunk/TODO
   trunk/Tokenize/
   trunk/Tokenize/HtmlTokenizer.cpp
   trunk/Tokenize/HtmlTokenizer.h
   trunk/Tokenize/Makefile
   trunk/Tokenize/PdfTokenizer.cpp
   trunk/Tokenize/PdfTokenizer.h
   trunk/Tokenize/Tokenizer.cpp
   trunk/Tokenize/Tokenizer.h
   trunk/Tokenize/TokenizerFactory.cpp
   trunk/Tokenize/TokenizerFactory.h
   trunk/Tokenize/UnknownTypeTokenizer.cpp
   trunk/Tokenize/UnknownTypeTokenizer.h
   trunk/Tokenize/WordTokenizer.cpp
   trunk/Tokenize/WordTokenizer.h
   trunk/Tokenize/tokenizertest.cpp
   trunk/UI/
   trunk/UI/GTK2/
   trunk/UI/GTK2/config.h
   trunk/UI/GTK2/metase-gtk2.glade
   trunk/UI/GTK2/metase-gtk2.gladep
   trunk/UI/GTK2/pinot.png
   trunk/UI/GTK2/pinot.xcf
   trunk/UI/GTK2/src/
   trunk/UI/GTK2/src/EnginesTree.cpp
   trunk/UI/GTK2/src/EnginesTree.h
   trunk/UI/GTK2/src/HtmlView.cpp
   trunk/UI/GTK2/src/HtmlView.h
   trunk/UI/GTK2/src/IndexTree.cpp
   trunk/UI/GTK2/src/IndexTree.h
   trunk/UI/GTK2/src/Makefile
   trunk/UI/GTK2/src/ModelColumns.cpp
   trunk/UI/GTK2/src/ModelColumns.h
   trunk/UI/GTK2/src/MonitorHandler.cpp
   trunk/UI/GTK2/src/MonitorHandler.h
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/PinotSettings.h
   trunk/UI/GTK2/src/PinotUtils.cpp
   trunk/UI/GTK2/src/PinotUtils.h
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/ResultsTree.h
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
   trunk/UI/GTK2/src/aboutDialog.cc
   trunk/UI/GTK2/src/aboutDialog.hh
   trunk/UI/GTK2/src/aboutDialog_glade.cc
   trunk/UI/GTK2/src/aboutDialog_glade.hh
   trunk/UI/GTK2/src/importDialog.cc
   trunk/UI/GTK2/src/importDialog.hh
   trunk/UI/GTK2/src/importDialog_glade.cc
   trunk/UI/GTK2/src/importDialog_glade.hh
   trunk/UI/GTK2/src/indexDialog.cc
   trunk/UI/GTK2/src/indexDialog.hh
   trunk/UI/GTK2/src/indexDialog_glade.cc
   trunk/UI/GTK2/src/indexDialog_glade.hh
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/mainWindow.hh
   trunk/UI/GTK2/src/mainWindow_glade.cc
   trunk/UI/GTK2/src/mainWindow_glade.hh
   trunk/UI/GTK2/src/pinot.cpp
   trunk/UI/GTK2/src/prefsDialog.cc
   trunk/UI/GTK2/src/prefsDialog.hh
   trunk/UI/GTK2/src/prefsDialog_glade.cc
   trunk/UI/GTK2/src/prefsDialog_glade.hh
   trunk/UI/GTK2/src/propertiesDialog.cc
   trunk/UI/GTK2/src/propertiesDialog.hh
   trunk/UI/GTK2/src/propertiesDialog_glade.cc
   trunk/UI/GTK2/src/propertiesDialog_glade.hh
   trunk/UI/GTK2/src/queryDialog.cc
   trunk/UI/GTK2/src/queryDialog.hh
   trunk/UI/GTK2/src/queryDialog_glade.cc
   trunk/UI/GTK2/src/queryDialog_glade.hh
   trunk/UI/GTK2/xapian-powered.png
   trunk/UI/RenderHTML/
   trunk/UI/RenderHTML/Makefile
   trunk/UI/RenderHTML/MozillaRenderer.cpp
   trunk/UI/RenderHTML/MozillaRenderer.h
   trunk/Utils/
   trunk/Utils/Document.cpp
   trunk/Utils/Document.h
   trunk/Utils/DocumentInfo.cpp
   trunk/Utils/DocumentInfo.h
   trunk/Utils/HtmlDocument.cpp
   trunk/Utils/HtmlDocument.h
   trunk/Utils/IndexedDocument.cpp
   trunk/Utils/IndexedDocument.h
   trunk/Utils/Languages.cpp
   trunk/Utils/Languages.h
   trunk/Utils/MIMEScanner.cpp
   trunk/Utils/MIMEScanner.h
   trunk/Utils/Makefile
   trunk/Utils/MboxParser.cpp
   trunk/Utils/MboxParser.h
   trunk/Utils/NLS.h
   trunk/Utils/PluginParser.cpp
   trunk/Utils/PluginParser.h
   trunk/Utils/Result.cpp
   trunk/Utils/Result.h
   trunk/Utils/StringManip.cpp
   trunk/Utils/StringManip.h
   trunk/Utils/TimeConverter.cpp
   trunk/Utils/TimeConverter.h
   trunk/Utils/Timer.cpp
   trunk/Utils/Timer.h
   trunk/Utils/Url.cpp
   trunk/Utils/Url.h
   trunk/Utils/XapianDatabase.cpp
   trunk/Utils/XapianDatabase.h
   trunk/Utils/XapianDatabaseFactory.cpp
   trunk/Utils/XapianDatabaseFactory.h
   trunk/Utils/plugintest.cpp
   trunk/index.html
   trunk/libxmlpp026.patch
   trunk/pinot.spec
   trunk/po/
   trunk/po/POTFILES
   trunk/po/en_GB.po
   trunk/po/fr_FR.po
   trunk/textcat_conf.txt
   trunk/variables.mk
Log:
v0.30 source

Added: trunk/COPYING
===================================================================
--- trunk/COPYING	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/COPYING	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/ChangeLog	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,2 @@
+2005/12/08 version_0_3_0
+ - first public release

Added: trunk/Collect/DownloaderFactory.cpp
===================================================================
--- trunk/Collect/DownloaderFactory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/DownloaderFactory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,47 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "XapianCollector.h"
+#include "NeonDownloader.h"
+#include "FileCollector.h"
+#include "MboxCollector.h"
+#include "DownloaderFactory.h"
+
+/// Returns a Downloader of the specified type; NULL if unavailable.
+DownloaderInterface *DownloaderFactory::getDownloader(string protocol, string type)
+{
+	DownloaderInterface *myDownloader = NULL;
+
+	// Choice by protocol
+	if (protocol == "http")
+	{
+		myDownloader = new NeonDownloader();
+	}
+	else if (protocol == "xapian")
+	{
+		myDownloader = new XapianCollector();
+	}
+	else if (protocol == "file")
+	{
+		myDownloader = new FileCollector();
+	}
+	else if (protocol == "mailbox")
+	{
+		myDownloader = new MboxCollector();
+	}
+
+	return myDownloader;
+}


Property changes on: trunk/Collect/DownloaderFactory.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/DownloaderFactory.h
===================================================================
--- trunk/Collect/DownloaderFactory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/DownloaderFactory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,44 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DOWNLOADER_FACTORY_H
+#define _DOWNLOADER_FACTORY_H
+
+#include <string>
+
+#include "DownloaderInterface.h"
+
+using std::string;
+
+// Downloader factory class.
+class DownloaderFactory
+{
+	public:
+		virtual ~DownloaderFactory() {};
+
+		/// Returns a Downloader of the specified type; NULL if unavailable.
+		static DownloaderInterface *getDownloader(string protocol, string type);
+
+	protected:
+		DownloaderFactory() {};
+
+	private:
+		DownloaderFactory(const DownloaderFactory &other);
+		DownloaderFactory &operator=(const DownloaderFactory &other);
+
+};
+
+#endif // _DOWNLOADER_FACTORY_H


Property changes on: trunk/Collect/DownloaderFactory.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/DownloaderInterface.cpp
===================================================================
--- trunk/Collect/DownloaderInterface.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/DownloaderInterface.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,47 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "HtmlTokenizer.h"
+#include "DownloaderInterface.h"
+
+using namespace std;
+
+DownloaderInterface::DownloaderInterface()
+{
+	m_timeout = 15000;
+}
+
+DownloaderInterface::~DownloaderInterface()
+{
+}
+
+/// Sets a (name, value) setting; true if success.
+bool DownloaderInterface::setSetting(const string &name, const string &value)
+{
+	return false;
+}
+
+/// Sets timeout.
+void DownloaderInterface::setTimeout(unsigned int milliseconds)
+{
+	m_timeout = milliseconds;
+}
+
+/// Stops the current action.
+bool DownloaderInterface::stop(void)
+{
+	return false;
+}


Property changes on: trunk/Collect/DownloaderInterface.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/DownloaderInterface.h
===================================================================
--- trunk/Collect/DownloaderInterface.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/DownloaderInterface.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DOWNLOADER_INTERFACE_H
+#define _DOWNLOADER_INTERFACE_H
+
+#include <string>
+
+#include "Document.h"
+
+/// Interface implemented by downloaders.
+class DownloaderInterface
+{
+	public:
+		virtual ~DownloaderInterface();
+
+		/// Sets a (name, value) setting; true if success.
+		virtual bool setSetting(const std::string &name, const std::string &value);
+
+		/// Sets timeout.
+		virtual void setTimeout(unsigned int milliseconds);
+
+		/// Retrieves the specified document; NULL if error. Caller deletes.
+		virtual Document *retrieveUrl(const DocumentInfo &docInfo) = 0;
+
+		/// Stops the current action.
+		virtual bool stop(void);
+
+	protected:
+		unsigned int m_timeout;
+
+		DownloaderInterface();
+
+};
+
+#endif // _DOWNLOADER_INTERFACE_H


Property changes on: trunk/Collect/DownloaderInterface.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/FileCollector.cpp
===================================================================
--- trunk/Collect/FileCollector.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/FileCollector.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,74 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+#include <algorithm>
+
+#include "HtmlTokenizer.h"
+#include "MIMEScanner.h"
+#include "Url.h"
+#include "FileCollector.h"
+
+using namespace std;
+
+FileCollector::FileCollector() :
+	DownloaderInterface()
+{
+}
+
+FileCollector::~FileCollector()
+{
+}
+
+//
+// Implementation of DownloaderInterface
+//
+
+/// Retrieves the specified document; NULL if error.
+Document *FileCollector::retrieveUrl(const DocumentInfo &docInfo)
+{
+	Url thisUrl(docInfo.getLocation());
+	string protocol = thisUrl.getProtocol();
+
+	if (protocol != "file")
+	{
+		// We can't handle that type of protocol...
+		return NULL;
+	}
+
+	string directoryName = thisUrl.getLocation();
+	string fileName = thisUrl.getFile();
+	string fileLocation = directoryName;
+	fileLocation += "/";
+	fileLocation += fileName;
+
+	// Determine the file type
+	string fileType = MIMEScanner::scanFile(fileLocation);
+
+	// Use the URL as title
+	Document *fileDocument = new Document(docInfo.getTitle(),
+		docInfo.getLocation(), docInfo.getType(), docInfo.getLanguage());
+	if (fileDocument->setDataFromFile(fileLocation) == false)
+	{
+		delete fileDocument;
+		return NULL;
+	}
+
+	unsigned int fileLength = 0;
+	const char *fileContent = fileDocument->getData(fileLength);
+
+	return fileDocument;
+}

Added: trunk/Collect/FileCollector.h
===================================================================
--- trunk/Collect/FileCollector.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/FileCollector.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,39 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _FILE_COLLECTOR_H
+#define _FILE_COLLECTOR_H
+
+#include <string>
+
+#include "DownloaderInterface.h"
+
+class FileCollector : public DownloaderInterface
+{
+	public:
+		FileCollector();
+		virtual ~FileCollector();
+
+		/// Retrieves the specified document; NULL if error. Caller deletes.
+		virtual Document *retrieveUrl(const DocumentInfo &docInfo);
+
+	private:
+		FileCollector(const FileCollector &other);
+		FileCollector &operator=(const FileCollector &other);
+
+};
+
+#endif // _FILE_COLLECTOR_H

Added: trunk/Collect/Makefile
===================================================================
--- trunk/Collect/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,25 @@
+
+ROOT_DIR = ..
+include ${ROOT_DIR}/variables.mk
+
+DL_SRCS = DownloaderInterface.cpp NeonDownloader.cpp XapianCollector.cpp \
+        FileCollector.cpp MboxCollector.cpp DownloaderFactory.cpp
+DL_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${DL_SRCS})
+DL_TEST = ${BIN_DIR}/dloadtest
+
+targets : dirs ${DL_LIB} ${DL_TEST}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${DL_LIB} ${DL_TEST}
+
+# Downloader tester
+
+${DL_TEST} : ${OBJ_DIR}/dloadtest.o ${DL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB}
+	@echo Building ${DL_TEST}
+	${LINK} -o $@ ${OBJ_DIR}/dloadtest.o ${DL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS}
+
+# Library
+
+${DL_LIB} : ${DL_OBJS}
+	@echo Building ${DL_LIB}
+	${AR} cr ${DL_LIB} ${DL_OBJS}


Property changes on: trunk/Collect/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/MboxCollector.cpp
===================================================================
--- trunk/Collect/MboxCollector.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/MboxCollector.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,80 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+#include <algorithm>
+
+#include "MboxParser.h"
+#include "StringManip.h"
+#include "Url.h"
+#include "MboxCollector.h"
+
+using namespace std;
+
+MboxCollector::MboxCollector() :
+	DownloaderInterface()
+{
+}
+
+MboxCollector::~MboxCollector()
+{
+}
+
+//
+// Implementation of DownloaderInterface
+//
+
+/// Retrieves the specified document; NULL if error.
+Document *MboxCollector::retrieveUrl(const DocumentInfo &docInfo)
+{
+	Url thisUrl(docInfo.getLocation());
+	string protocol = thisUrl.getProtocol();
+
+	if (protocol != "mailbox")
+	{
+		// We can't handle that type of protocol...
+		return NULL;
+	}
+
+	// Extract the offset
+	string offset = StringManip::extractField(thisUrl.getParameters(), "o=", "&p=");
+	if (offset.empty() == true)
+	{
+		return NULL;
+	}
+	off_t messageOffset = (off_t)atol(offset.c_str());
+
+	string directoryName = thisUrl.getLocation();
+	string fileName = thisUrl.getFile();
+	string fileLocation = directoryName;
+	fileLocation += "/";
+	fileLocation += fileName;
+
+	// Get a parser
+	MboxParser boxParser(fileLocation, messageOffset);
+	// The first document should be the message we are interested in
+	// FIXME: don't ignore the part number (p=...)
+	const Document *pMessage = boxParser.getDocument();
+	if (pMessage == NULL)
+	{
+		return NULL;
+	}
+
+	// Copy the message
+	Document *fileDocument = new Document(*pMessage);
+
+	return fileDocument;
+}

Added: trunk/Collect/MboxCollector.h
===================================================================
--- trunk/Collect/MboxCollector.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/MboxCollector.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,39 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MBOX_COLLECTOR_H
+#define _MBOX_COLLECTOR_H
+
+#include <string>
+
+#include "DownloaderInterface.h"
+
+class MboxCollector : public DownloaderInterface
+{
+	public:
+		MboxCollector();
+		virtual ~MboxCollector();
+
+		/// Retrieves the specified document; NULL if error. Caller deletes.
+		virtual Document *retrieveUrl(const DocumentInfo &docInfo);
+
+	private:
+		MboxCollector(const MboxCollector &other);
+		MboxCollector &operator=(const MboxCollector &other);
+
+};
+
+#endif // _MBOX_COLLECTOR_H

Added: trunk/Collect/NeonDownloader.cpp
===================================================================
--- trunk/Collect/NeonDownloader.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/NeonDownloader.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,377 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <cstdio>
+#include <strings.h>
+#include <stdarg.h>
+#include <pthread.h>
+#include <iostream>
+
+#include "HtmlTokenizer.h"
+#include "HtmlDocument.h"
+#include "Url.h"
+#include "NeonDownloader.h"
+
+using namespace std;
+
+static string g_locationHeaderValue;
+static string g_contentTypeHeaderValue;
+static void headerHandler(void *userdata, const char *value)
+{
+	long headerNum = (long)userdata;
+	if (headerNum == 1)
+	{
+		// Location
+		if (value == NULL)
+		{
+			g_locationHeaderValue.clear();
+		}
+		else
+		{
+			g_locationHeaderValue = value;
+		}
+	}
+	else if (headerNum == 2)
+	{
+		// Content-Type
+		if (value == NULL)
+		{
+			g_contentTypeHeaderValue.clear();
+		}
+		else
+		{
+			g_contentTypeHeaderValue = value;
+		}
+	}
+}
+
+bool NeonDownloader::m_initialized = false;
+
+NeonDownloader::NeonDownloader() :
+	m_pSession(NULL), m_pRequest(NULL), DownloaderInterface()
+{
+	// Pretend to be Mozilla
+	m_userAgent = "Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.7.3) Gecko/20041020";
+	if (m_initialized == false)
+	{
+		ne_sock_init();
+		m_initialized = true;
+	}
+}
+
+NeonDownloader::~NeonDownloader()
+{
+	// Cleanup
+	if (m_pRequest != NULL)
+	{
+		ne_request_destroy(m_pRequest);
+	}
+	if (m_pSession != NULL)
+	{
+		ne_session_destroy(m_pSession);
+	}
+}
+
+string NeonDownloader::handleRedirection(const char *pBody, unsigned int length)
+{
+	if ((pBody == NULL) ||
+		(length == 0))
+	{
+		return "";
+	}
+
+	Document doc;
+	doc.setData(pBody, length);
+	HtmlTokenizer tokens(&doc);
+
+	// Extract the link from the 3xx message
+	set<Link> linksSet = tokens.getLinks();
+	// There should be one and only one
+	if (linksSet.size() != 1)
+	{
+#ifdef DEBUG
+		cout << "NeonDownloader::handleRedirection: " << linksSet.size() << " links found in " << length << " bytes" << endl;
+		cout << "NeonDownloader::handleRedirection: redirection message was " << pBody << endl;
+#endif
+		return "";
+	}
+	set<Link>::const_iterator iter = linksSet.begin();
+	if (iter != linksSet.end())
+	{
+		// Update the URL
+		return iter->m_url;
+	}
+
+	return "";
+}
+
+//
+// Implementation of DownloaderInterface
+//
+
+/// Sets a (name, value) setting; true if success.
+bool NeonDownloader::setSetting(const string &name, const string &value)
+{
+	bool goodSetting = true;
+
+	if (name == "User-Agent")
+	{
+		m_userAgent = value;
+	}
+	else
+	{
+		goodSetting = false;
+	}
+
+	return goodSetting;
+}
+
+/// Retrieves the specified document; NULL if error.
+Document *NeonDownloader::retrieveUrl(const DocumentInfo &docInfo)
+{
+	Document *urlDocument = NULL;
+	string url = Url::escapeUrl(docInfo.getLocation());
+	char *content = NULL;
+	size_t contentLen = 0;
+	unsigned int redirectionsCount = 0;
+
+	if (url.empty() == true)
+	{
+#ifdef DEBUG
+		cerr << "NeonDownloader::retrieveUrl: no URL specified !" << endl;
+#endif
+		return NULL;
+	}
+	Url urlObj(url);
+	string protocol = urlObj.getProtocol();
+	string hostName = urlObj.getHost();
+	string location = urlObj.getLocation();
+	string file = urlObj.getFile();
+	string parameters = urlObj.getParameters();
+
+	// Create a session
+	m_pSession = ne_session_create(protocol.c_str(), hostName.c_str(), 80); // urlObj.getPort());
+	if (m_pSession == NULL)
+	{
+#ifdef DEBUG
+		cerr << "NeonDownloader::retrieveUrl: couldn't create session !" << endl;
+#endif
+		return NULL;
+	}
+	// Set the user agent
+	ne_set_useragent(m_pSession, m_userAgent.c_str());
+	// ...and the timeout
+	ne_set_read_timeout(m_pSession, (int)m_timeout);
+
+	string fullLocation = "/";
+	if (location.empty() == false)
+	{
+		fullLocation += location;
+	}
+	if (file.empty() == false)
+	{
+		if (location.empty() == false)
+		{
+			fullLocation += "/";
+		}
+		fullLocation += file;
+	}
+	if (parameters.empty() == false)
+	{
+		fullLocation += "?";
+		fullLocation += parameters;
+	}
+
+	// Create a request for this URL
+	m_pRequest = ne_request_create(m_pSession, "GET", fullLocation.c_str());
+	if (m_pRequest == NULL)
+	{
+#ifdef DEBUG
+		cerr << "NeonDownloader::retrieveUrl: couldn't create request !" << endl;
+#endif
+		ne_session_destroy(m_pSession);
+		m_pSession = NULL;
+		return NULL;
+	}
+#ifdef DEBUG
+	cout << "NeonDownloader::retrieveUrl: request for " << fullLocation << " on " << hostName << endl;
+#endif
+
+	int requestStatus = NE_RETRY;
+	while (requestStatus == NE_RETRY)
+	{
+		// FIXME: this is apparently the only way to get the value of an HTTP header
+		g_locationHeaderValue.clear();
+		ne_add_response_header_handler(m_pRequest, "Location", headerHandler, (void*)1);
+		ne_add_response_header_handler(m_pRequest, "Content-Type", headerHandler, (void*)2);
+
+		// Begin the request
+		requestStatus = ne_begin_request(m_pRequest);
+#ifdef DEBUG
+		cout << "NeonDownloader::retrieveUrl: request begun with status " << requestStatus << endl;
+#endif
+		if (requestStatus == NE_OK)
+		{
+			ssize_t bytesRead = 0;
+			char buffer[1024];
+			int statusCode = 0;
+
+			// Get the status
+			const ne_status *pStatus = ne_get_status(m_pRequest);
+			if (pStatus != NULL)
+			{
+				statusCode = pStatus->code;
+#ifdef DEBUG
+				cout << "NeonDownloader::retrieveUrl: status is " << statusCode << endl;
+#endif
+			}
+
+			// Read the content
+			while ((bytesRead = ne_read_response_block(m_pRequest, buffer, 1024)) > 0)
+			{
+				content = (char*)realloc(content, contentLen + bytesRead);
+				memcpy((void*)(content + contentLen), (const void*)buffer, bytesRead);
+				contentLen += bytesRead;
+			}
+
+			// Redirection ?
+			if ((statusCode >= 300) &&
+				(statusCode < 400) &&
+				(redirectionsCount < 10))
+			{
+				ne_end_request(m_pRequest);
+				ne_request_destroy(m_pRequest);
+				m_pRequest = NULL;
+
+				string documentUrl = handleRedirection(content, contentLen);
+				if (documentUrl.empty() == true)
+				{
+					// Did we find a Location header ?
+					if (g_locationHeaderValue.empty() == true)
+					{
+						// Fail
+						free(content);
+						content = NULL;
+						contentLen = 0;
+						break;
+					}
+					documentUrl = g_locationHeaderValue;
+				}
+
+#ifdef DEBUG
+				cout << "NeonDownloader::retrieveUrl: redirected to " << documentUrl << endl;
+#endif
+				urlObj = Url(documentUrl);
+				location = urlObj.getLocation();
+				file = urlObj.getFile();
+
+				// Is this on the same host ?
+				if (hostName != urlObj.getHost())
+				{
+					// No, it isn't
+					hostName = urlObj.getHost();
+
+					// Create a new session
+					ne_session_destroy(m_pSession);
+					m_pSession = ne_session_create(protocol.c_str(), hostName.c_str(), 80); // urlObj.getPort());
+					if (m_pSession == NULL)
+					{
+#ifdef DEBUG
+						cerr << "NeonDownloader::retrieveUrl: couldn't create session !" << endl;
+#endif
+						return NULL;
+					}
+					ne_set_useragent(m_pSession, m_userAgent.c_str());
+					ne_set_read_timeout(m_pSession, (int)m_timeout);
+				}
+
+				// Try again
+				fullLocation = "/";
+				if (location.empty() == false)
+				{
+					fullLocation += location;
+					fullLocation += "/";
+				}
+				if (file.empty() == false)
+				{
+					fullLocation += file;
+				}
+#ifdef DEBUG
+				cout << "NeonDownloader::retrieveUrl: redirected to " << fullLocation << " on " << hostName << endl;
+#endif
+
+				// Create a new request for this URL
+				m_pRequest = ne_request_create(m_pSession, "GET", fullLocation.c_str());
+				if (m_pRequest == NULL)
+				{
+#ifdef DEBUG
+					cerr << "NeonDownloader::retrieveUrl: couldn't create request !" << endl;
+#endif
+					ne_session_destroy(m_pSession);
+					m_pSession = NULL;
+					return NULL;
+				}
+				redirectionsCount++;
+				requestStatus = NE_RETRY;
+
+				// Discard whatever content we have already got
+				free(content);
+				content = NULL;
+				contentLen = 0;
+				continue;
+			}
+		}
+
+		// End the request
+		requestStatus = ne_end_request(m_pRequest);
+	}
+
+	if ((content != NULL) &&
+		(contentLen > 0))
+	{
+		// Is it an html type ?
+		if (g_contentTypeHeaderValue.find("htm") != string::npos)
+		{
+			urlDocument = new HtmlDocument(docInfo.getTitle(), url,
+				g_contentTypeHeaderValue, docInfo.getLanguage());
+		}
+		else
+		{
+			urlDocument = new Document(docInfo.getTitle(), url,
+				g_contentTypeHeaderValue, docInfo.getLanguage());
+		}
+		// ...and copy the content into it
+		urlDocument->setData(content, contentLen);
+#ifdef DEBUG
+		cout << "NeonDownloader::retrieveUrl: document size is " << contentLen << endl;
+#endif
+		free(content);
+	}
+
+	return urlDocument;
+}
+
+/// Stops the current action.
+bool NeonDownloader::stop(void)
+{
+	if (m_pRequest != NULL)
+	{
+		// End the current request
+		ne_end_request(m_pRequest);
+	}
+
+	return true;
+}


Property changes on: trunk/Collect/NeonDownloader.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/NeonDownloader.h
===================================================================
--- trunk/Collect/NeonDownloader.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/NeonDownloader.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,57 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _NEON_DOWNLOADER_H
+#define _NEON_DOWNLOADER_H
+
+#include <string>
+
+#include <neon/ne_socket.h>
+#include <neon/ne_session.h>
+#include <neon/ne_request.h>
+
+#include "DownloaderInterface.h"
+
+class NeonDownloader : public DownloaderInterface
+{
+	public:
+		NeonDownloader();
+		virtual ~NeonDownloader();
+
+		/// Sets a (name, value) setting; true if success.
+		virtual bool setSetting(const std::string &name, const std::string &value);
+
+		/// Retrieves the specified document; NULL if error. Caller deletes.
+		virtual Document *retrieveUrl(const DocumentInfo &docInfo);
+
+		/// Stops the current action.
+		virtual bool stop(void);
+
+	protected:
+		static bool m_initialized;
+		std::string m_userAgent;
+		ne_session *m_pSession;
+		ne_request *m_pRequest;
+
+		std::string handleRedirection(const char *pBody, unsigned int length);
+
+	private:
+		NeonDownloader(const NeonDownloader &other);
+		NeonDownloader &operator=(const NeonDownloader &other);
+
+};
+
+#endif // _NEON_DOWNLOADER_H


Property changes on: trunk/Collect/NeonDownloader.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/XapianCollector.cpp
===================================================================
--- trunk/Collect/XapianCollector.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/XapianCollector.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,196 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <pthread.h>
+#include <iostream>
+
+#include "IndexedDocument.h"
+#include "StringManip.h"
+#include "Url.h"
+#include "XapianCollector.h"
+
+using namespace std;
+
+XapianCollector::XapianCollector() :
+	DownloaderInterface()
+{
+	m_databaseName = "";
+	// Always get documents data from the index
+	m_getDocData = true;
+	m_pDatabase = NULL;
+}
+
+XapianCollector::XapianCollector(const string &database, bool getDocData) :
+	DownloaderInterface()
+{
+	m_databaseName = database;
+	m_getDocData = getDocData;
+	m_pDatabase = NULL;
+
+	// Try opening this database
+	if (openDatabase() == false)
+	{
+		m_databaseName.clear();
+		m_pDatabase = NULL;
+	}
+	m_getDocData = getDocData;
+}
+
+XapianCollector::~XapianCollector()
+{
+	if (m_pDatabase != NULL)
+	{
+		delete m_pDatabase;
+	}
+}
+
+bool XapianCollector::openDatabase(void)
+{
+	struct stat dbStat;
+
+	if (m_databaseName.empty() == true)
+	{
+		return false;
+	}
+
+	// The specified path must be either a directory or a symlink (to a directory)
+	if (stat(m_databaseName.c_str(), &dbStat) == -1)
+	{
+		// Database directory doesn't exist
+		cerr << "XapianCollector::openDatabase: database doesn't exist: " << m_databaseName << endl;
+		return false;
+	}
+	else if (!S_ISDIR(dbStat.st_mode))
+	{
+		cerr << "XapianCollector::openDatabase: " << m_databaseName << " is not a directory" << endl;
+		return false;
+	}
+
+	// Try opening it now
+	try
+	{
+#ifdef DEBUG
+		cout << "XapianCollector::openDatabase: opening database " << m_databaseName << endl;
+#endif
+		m_pDatabase = new Xapian::Database(m_databaseName);
+
+		return true;
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "XapianCollector::openDatabase: couldn't open database: " << error.get_msg() << endl;
+	}
+
+	return false;
+}
+
+//
+// Implementation of DownloaderInterface
+//
+
+/// Retrieves the specified document; NULL if error.
+Document *XapianCollector::retrieveUrl(const DocumentInfo &docInfo)
+{
+	string url = docInfo.getLocation();
+	Url thisUrl(url);
+
+	if (thisUrl.getProtocol() != "xapian")
+	{
+		// We can't handle that type of protocol...
+		return NULL;
+	}
+
+	// Ignore host portion of the URL as we can only deal with local indexes
+	// Get the database location and document ID out of the location field
+	string database = thisUrl.getLocation();
+	string documentId = thisUrl.getFile();
+	Xapian::docid docId;
+	sscanf(documentId.c_str(), "%u", &docId);
+#ifdef DEBUG
+	cout << "XapianCollector::retrieveUrl: database is " << database << ", document ID is " << docId << endl;
+#endif
+
+	// The constructor may already have opened an index, check this URL corresponds
+	if (database != m_databaseName)
+	{
+		// The requested URL is in some other index
+		if (m_pDatabase != NULL)
+		{
+			delete m_pDatabase;
+			m_pDatabase = NULL;
+		}
+		// Try opening that index then
+		m_databaseName = database;
+		if (openDatabase() == false)
+		{
+			m_pDatabase = NULL;
+			m_databaseName.clear();
+		}
+	}
+
+	if (m_pDatabase == NULL)
+	{
+		return NULL;
+	}
+
+	IndexedDocument *indexDoc = NULL;
+
+	try
+	{
+		// Now retrieve the desired document
+		Xapian::Document doc = m_pDatabase->get_document(docId);
+		// ... and its data
+		string record = doc.get_data();
+
+		// Extract the title, location, summary, type and timestamp
+		string title = StringManip::extractField(record, "caption=", "\n");
+#ifdef DEBUG
+		cout << "XapianCollector::retrieveUrl: found omindex title " << title << endl;
+#endif
+		string location = StringManip::extractField(record, "url=", "\n");
+		string type = StringManip::extractField(record, "type=", "\n");
+		string timestamp = StringManip::extractField(record, "timestamp=", "\n");
+		string language = StringManip::extractField(record, "language=", "\n");
+#ifdef DEBUG
+	cout << "XapianCollector::retrieveUrl: " << docId << " was indexed from " << location << " at " << timestamp << endl;
+#endif
+
+		indexDoc = new IndexedDocument(title, url, location, type, language);
+		indexDoc->setTimestamp(timestamp);
+
+		// Extract document's data ?
+		if (m_getDocData == true)
+		{
+			// The only data we have at hand is the summary
+			string summary = StringManip::extractField(record, "sample=", "\n");
+#ifdef DEBUG
+			cout << "XapianCollector::retrieveUrl: found omindex summary " << summary << endl;
+#endif
+			indexDoc->setData(summary.c_str(), summary.length());
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't retrieve document: " << error.get_msg() << endl;
+	}
+
+	return indexDoc;
+}


Property changes on: trunk/Collect/XapianCollector.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/XapianCollector.h
===================================================================
--- trunk/Collect/XapianCollector.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/XapianCollector.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XAPIAN_COLLECTOR_H
+#define _XAPIAN_COLLECTOR_H
+
+#include <string>
+
+#include <xapian.h>
+
+#include "DownloaderInterface.h"
+
+class XapianCollector : public DownloaderInterface
+{
+	public:
+		XapianCollector();
+		XapianCollector(const std::string &database, bool getDocData);
+		virtual ~XapianCollector();
+
+		/// Retrieves the specified document; NULL if error. Caller deletes.
+		virtual Document *retrieveUrl(const DocumentInfo &docInfo);
+
+	protected:
+		std::string m_databaseName;
+		bool m_getDocData;
+		Xapian::Database *m_pDatabase;
+
+		bool openDatabase(void);
+
+	private:
+		XapianCollector(const XapianCollector &other);
+		XapianCollector &operator=(const XapianCollector &other);
+
+};
+
+#endif // _XAPIAN_COLLECTOR_H


Property changes on: trunk/Collect/XapianCollector.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Collect/dloadtest.cpp
===================================================================
--- trunk/Collect/dloadtest.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Collect/dloadtest.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,115 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string>
+#include <iostream>
+#include <fstream>
+
+#include "HtmlTokenizer.h"
+#include "Url.h"
+#include "DownloaderFactory.h"
+
+using namespace std;
+
+int main(int argc, char **argv)
+{
+	if (argc < 3)
+	{
+		cerr << "Usage: <downloader name> <URL> [STRIP]" << endl;
+		return EXIT_FAILURE;
+	}
+
+	string downloaderName = argv[1];
+	
+	Url thisUrl(argv[2]);
+	cout << "Protocol: " << thisUrl.getProtocol() << endl;
+	cout << "User: " << thisUrl.getUser() << endl;
+	cout << "Password: " << thisUrl.getPassword() << endl;
+	cout << "Host: " << thisUrl.getHost() << endl;
+	cout << "Location: " << thisUrl.getLocation() << endl;
+	cout << "File: " << thisUrl.getFile() << endl;
+	cout << "Parameters: " << thisUrl.getParameters() << endl;
+
+	if (downloaderName == "-")
+	{
+		// Don't go further
+		return EXIT_SUCCESS;
+	}
+
+	// Which Downloader ?
+	DownloaderInterface *myDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol(),
+		downloaderName);
+	if (myDownloader == NULL)
+	{
+		cerr << "Couldn't obtain downloader instance (" << thisUrl.getProtocol() << "," << downloaderName << ")" << endl;
+		return EXIT_FAILURE;
+	}
+
+	unsigned int urlContentLen;
+	string contentType;
+	DocumentInfo docInfo("Test", argv[2], "", "");
+	Document *urlDoc = myDownloader->retrieveUrl(docInfo);
+	if (urlDoc == NULL)
+	{
+		cerr << "Download operation failed !" << endl;
+	}
+	else
+	{
+		cout << "Document type is " << urlDoc->getType() << endl;
+
+		unsigned int urlContentLen;
+		const char *urlContent = urlDoc->getData(urlContentLen);
+
+		if ((urlContent != NULL) &&
+			(urlContentLen > 0))
+		{
+			// Save the content to a file
+			string fileName = thisUrl.getFile();
+			if (fileName.empty() == true)
+			{
+				fileName = "index.html";
+			}
+
+			cout << "Saving " << urlContentLen << " bytes to " << fileName << endl;
+
+			ofstream outputFile(fileName.c_str());
+			//outputFile.open(fileName.c_str(), ofstream::out|ofstream::trunc);
+			// Strip tags ?
+			if ((argc >= 3) &&
+				(strncasecmp(argv[2], "STRIP", 5) == 0))
+			{
+				outputFile << HtmlTokenizer::stripTags(urlContent);
+			}
+			else
+			{
+				outputFile.write(urlContent, urlContentLen);
+			}
+			outputFile.close();
+		}
+		else
+		{
+			cout << "Document is empty" << endl;
+		}
+
+		delete urlDoc;
+	}
+
+	delete myDownloader;
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/Collect/dloadtest.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Index/IndexInterface.h
===================================================================
--- trunk/Index/IndexInterface.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/IndexInterface.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,84 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#ifndef _INDEX_INTERFACE_H
+#define _INDEX_INTERFACE_H
+
+#include <string>
+#include <set>
+
+#include "Tokenizer.h"
+#include "DocumentInfo.h"
+
+/// Interface implemented by indexes.
+class IndexInterface
+{
+	public:
+		virtual ~IndexInterface() {};
+
+		/// Returns false if the index couldn't be opened.
+		bool isGood(void) const { return m_goodIndex; }
+
+		typedef enum { STORE_UNSTEM = 0, STORE_STEM, STORE_BOTH } StemmingMode;
+
+		/// Sets the stemming mode.
+		virtual void setStemmingMode(StemmingMode mode) { m_stemMode = mode; }
+
+		/// Gets the index location.
+		virtual std::string getLocation(void) const = 0;
+
+		/// Indexes the given data.
+		virtual bool indexDocument(Tokenizer &tokens, unsigned int &docId) = 0;
+
+		/// Updates the given document; true if success.
+		virtual bool updateDocument(unsigned int docId, Tokenizer &tokens) = 0;
+
+		/// Returns the ID of the given document.
+		virtual unsigned int hasDocument(const DocumentInfo &docInfo) const = 0;
+
+		/// Unindexes the given document; true if success.
+		virtual bool unindexDocument(unsigned int docId) = 0;
+
+		/// Flushes recent changes to the disk.
+		virtual bool flush(void) = 0;
+
+		/// Returns the number of documents.
+		virtual unsigned int getDocumentsCount(void) const = 0;
+
+		/// Returns a list of document IDs.
+		virtual unsigned int getDocumentIDs(std::set<unsigned int> &docIDList,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0,
+			bool sortByDate = false) const = 0;
+
+		/// Returns a document's properties.
+		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const = 0;
+
+		/// Updates a document's properties.
+		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo) = 0;
+
+	protected:
+		StemmingMode m_stemMode;
+		bool m_goodIndex;
+
+		IndexInterface() { m_stemMode = STORE_UNSTEM; m_goodIndex = false; };
+
+	private:
+		IndexInterface(const IndexInterface &other);
+		IndexInterface &operator=(const IndexInterface &other);
+
+};
+
+#endif // _INDEX_INTERFACE_H


Property changes on: trunk/Index/IndexInterface.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Index/LanguageDetector.cpp
===================================================================
--- trunk/Index/LanguageDetector.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/LanguageDetector.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,145 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/time.h>
+#include <iostream>
+
+extern "C"
+{
+#include <textcat.h>
+}
+
+#include "StringManip.h"
+#include "Timer.h"
+#include "LanguageDetector.h"
+
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+using std::vector;
+
+LanguageDetector::LanguageDetector()
+{
+}
+
+LanguageDetector::~LanguageDetector()
+{
+}
+
+/**
+  * Attempts to guess the language.
+  * Returns a list of candidates, or "unknown" if detection failed.
+  */
+void LanguageDetector::guessLanguage(const char *pData, unsigned int dataLength,
+			std::vector<std::string> &candidates)
+{
+#ifdef HAVE_TEXTCAT_CAT
+	const char *catResults[10];
+#endif
+
+	candidates.clear();
+
+	void *td = textcat_Init("/usr/share/pinot/textcat_conf.txt");
+	if (td == NULL)
+	{
+		candidates.push_back("unknown");
+		return;
+	}
+
+	// Classify
+#ifdef DEBUG
+	Timer timer;
+	timer.start();
+#endif
+#ifdef HAVE_TEXTCAT_CAT
+	unsigned int resultNum = textcat_Cat(td, pData, dataLength, catResults, 10);
+	if (resultNum == 0 )
+	{
+		candidates.push_back("unknown");
+	}
+	else
+	{
+		for (unsigned int i=0; i<resultNum; ++i)
+		{
+			string language = StringManip::toLowerCase(catResults[i]);
+
+			// Remove the charset information
+			string::size_type dashPos = language.find('-');
+			if (dashPos != string::npos)
+			{
+				language.resize(dashPos);
+			}
+#ifdef DEBUG
+			cout << "LanguageDetector::guessLanguage: found language " << language << endl;
+#endif
+			candidates.push_back(language);
+		}
+	}
+#else
+	const char *languages = textcat_Classify(td, pData, dataLength);
+	if (languages == NULL)
+	{
+		candidates.push_back("unknown");
+	}
+	else
+	{
+		// The output will be either SHORT, or UNKNOWN or a list of languages in []
+		if ((strncasecmp(languages, "SHORT", 5) == 0) ||
+			(strncasecmp(languages, "UNKNOWN", 7) == 0))
+		{
+			candidates.push_back("unknown");
+		}
+		else
+		{
+			string languageList = languages;
+			string::size_type lastPos = 0, pos = languageList.find_first_of("[");
+
+			while (pos != string::npos)
+			{
+				++pos;
+				lastPos = languageList.find_first_of("]", pos);
+				if (lastPos == string::npos)
+				{
+					break;
+				}
+
+				string language = StringManip::toLowerCase(languageList.substr(pos, lastPos - pos));
+				// Remove the charset information
+				string::size_type dashPos = language.find('-');
+				if (dashPos != string::npos)
+				{
+					language.resize(dashPos);
+				}
+#ifdef DEBUG
+				cout << "LanguageDetector::guessLanguage: found language " << language << endl;
+#endif
+				candidates.push_back(language);
+
+				// Next
+				pos = languageList.find_first_of("[", lastPos);
+			}
+		}
+	}
+#endif
+#ifdef DEBUG
+	cout << "LanguageDetector::guessLanguage: language guessing with "
+		<< textcat_Version() << " took " << timer.stop() << " us" << endl;
+#endif
+
+	// Close the descriptor
+	textcat_Done(td);
+}

Added: trunk/Index/LanguageDetector.h
===================================================================
--- trunk/Index/LanguageDetector.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/LanguageDetector.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,42 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _LANGUAGE_DETECTOR_H
+#define _LANGUAGE_DETECTOR_H
+
+#include <string>
+#include <vector>
+
+class LanguageDetector
+{
+	public:
+		LanguageDetector();
+		virtual ~LanguageDetector();
+
+		/**
+		  * Attempts to guess the language.
+		  * Returns a list of candidates, or "unknown" if detection failed.
+		  */
+		void guessLanguage(const char *pData, unsigned int dataLength,
+			std::vector<std::string> &candidates);
+
+	private:
+		LanguageDetector(const LanguageDetector &other);
+		LanguageDetector &operator=(const LanguageDetector &other);
+
+};
+
+#endif // _LANGUAGE_DETECTOR_H

Added: trunk/Index/Makefile
===================================================================
--- trunk/Index/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,24 @@
+
+ROOT_DIR = ..
+include ${ROOT_DIR}/variables.mk
+
+IDX_SRCS = Summarizer.cpp LanguageDetector.cpp XapianIndex.cpp
+IDX_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${IDX_SRCS})
+IDX_TEST = ${BIN_DIR}/indextest
+
+targets : dirs ${IDX_LIB} ${IDX_TEST} ${DISCKCAT_APP}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${IDX_LIB} ${IDX_TEST} ${DISCKCAT_APP}
+
+# Index tester
+
+${IDX_TEST} : ${OBJ_DIR}/indextest.o ${IDX_LIB} ${SQL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB}
+	@echo Building ${IDX_TEST}
+	${LINK} -o $@ ${OBJ_DIR}/indextest.o ${IDX_LIB} ${SQL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS}
+
+# Library
+
+${IDX_LIB} : ${IDX_OBJS}
+	@echo Building ${IDX_LIB}
+	${AR} cr ${IDX_LIB} ${IDX_OBJS}


Property changes on: trunk/Index/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Index/Summarizer.cpp
===================================================================
--- trunk/Index/Summarizer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/Summarizer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,128 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/time.h>
+#include <map>
+#include <iostream>
+#include <utility>
+
+#include <ots/libots.h>
+
+#include "Languages.h"
+#include "StringManip.h"
+#include "Timer.h"
+#include "Summarizer.h"
+
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+using std::map;
+using std::min;
+
+unsigned int Summarizer::m_maxTextSize = 500000;
+
+Summarizer::Summarizer(const std::string &language, unsigned int wordsCount) :
+	m_wordsCount(wordsCount),
+	m_dictionaryCode("en")
+{
+	string lang = StringManip::toLowerCase(language);
+
+	// Look up the language code
+	for (unsigned int count = 0; count < Languages::m_count; ++count)
+	{
+		if (lang == Languages::m_names[count])
+		{
+			m_dictionaryCode = Languages::m_codes[count];
+		}
+	}
+}
+
+Summarizer::~Summarizer()
+{
+}
+
+/// Attempts to summarize the document in wordsCount words.
+string Summarizer::summarize(const char *pText, unsigned int textLen)
+{
+	if ((pText == NULL) ||
+		(textLen == 0))
+	{
+		return NULL;
+	}
+
+	m_title.clear();
+
+	// OTS may take too much time with long documents
+	if (textLen < m_maxTextSize)
+	{
+		unsigned char *pSummary = NULL;
+		size_t outputLen = 0;
+#ifdef DEBUG
+		Timer timer;
+		timer.start();
+#endif
+
+		// Create a new article
+		OtsArticle *pArticle = ots_new_article();
+		if ((pArticle != NULL) &&
+			(ots_load_xml_dictionary(pArticle, m_dictionaryCode.c_str())))
+		{
+			ots_parse_stream((const unsigned char*)pText, textLen, pArticle);
+
+			ots_grade_doc(pArticle);
+			ots_highlight_doc_words(pArticle, m_wordsCount);
+
+			// Summarize
+			pSummary = ots_get_doc_text(pArticle, &outputLen);
+#ifdef DEBUG
+			cout << "Summarizer::summarize: summarized to " << outputLen << " bytes in "
+				<< timer.stop() << " us " << endl;
+#endif
+
+			// Get the title before freeing the article
+			if (pArticle->title != NULL)
+			{
+				m_title = pArticle->title;
+			}
+			ots_free_article(pArticle);
+		}
+
+		if (pSummary != NULL)
+		{
+			string sum((const char *)pSummary, outputLen);
+
+			free(pSummary);
+
+			return sum;
+		}
+	}
+	else
+	{
+		unsigned int arbitraryLen = min(5 * m_wordsCount, m_maxTextSize / 1000);
+
+		// This is totally arbitray
+		return string(pText, arbitraryLen);
+	}
+
+	return "";
+}
+
+/// Gets the document's title, as determined by summarize().
+string Summarizer::getTitle(void) const
+{
+	return m_title;
+}

Added: trunk/Index/Summarizer.h
===================================================================
--- trunk/Index/Summarizer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/Summarizer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,46 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _SUMMARIZER_H
+#define _SUMMARIZER_H
+
+#include <string>
+
+class Summarizer
+{
+	public:
+		Summarizer(const std::string &language, unsigned int wordsCount);
+		virtual ~Summarizer();
+
+		/// Attempts to summarize the document in wordsCount words.
+		std::string summarize(const char *pText, unsigned int textLen);
+
+		/// Gets the document's title, as determined by summarize().
+		std::string getTitle(void) const;
+
+	protected:
+		static unsigned int m_maxTextSize;
+		unsigned int m_wordsCount;
+		std::string m_dictionaryCode;
+		std::string m_title;
+
+	private:
+		Summarizer(const Summarizer &other);
+		Summarizer &operator=(const Summarizer &other);
+
+};
+
+#endif // _SUMMARIZER_H

Added: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/XapianIndex.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,621 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <time.h>
+#include <iostream>
+#include <fstream>
+#include <algorithm>
+
+#include "StringManip.h"
+#include "Url.h"
+#include "Summarizer.h"
+#include "TimeConverter.h"
+#include "LanguageDetector.h"
+#include "XapianDatabaseFactory.h"
+#include "XapianIndex.h"
+
+using std::string;
+using std::set;
+
+// This puts a limit to terms length.
+const unsigned int XapianIndex::m_maxTermLength = 64;
+const string XapianIndex::MAGIC_TERM = "X-MetaSE-Doc";
+
+XapianIndex::XapianIndex(const string &indexName) :
+	IndexInterface(),
+	m_databaseName(indexName),
+	m_pHistory(NULL)
+{
+
+	string historyFile = indexName;
+	historyFile += "/history";
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if ((pDatabase != NULL) &&
+		(pDatabase->isOpen() == true) &&
+		(IndexHistory::create(historyFile) == true))
+	{
+		m_pHistory = new IndexHistory(historyFile);
+		m_goodIndex = true;
+	}
+}
+
+XapianIndex::~XapianIndex()
+{
+	if (m_pHistory != NULL)
+	{
+		delete m_pHistory;
+	}
+}
+
+bool XapianIndex::addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,
+	Xapian::termcount &termPos, const string &prefix, StemmingMode mode) const
+{
+	Xapian::Stem *pStemmer = NULL;
+	string term;
+
+	// Do we know what language to use for stemming ?
+	if (m_stemLanguage.empty() == false)
+	{
+		pStemmer = new Xapian::Stem(m_stemLanguage);
+	}
+
+	// Get the terms
+	while (tokens.nextToken(term) == true)
+	{
+		if (term.empty() == true)
+		{
+			continue;
+		}
+
+		// Lower case the term
+		term = StringManip::toLowerCase(term);
+		// Stem the term ?
+		if ((mode == STORE_UNSTEM) ||
+			(pStemmer == NULL))
+		{
+			// Add the term to the document
+			doc.add_posting(prefix + term, termPos);
+		}
+		else if (mode == STORE_STEM)
+		{
+			string stemmedTerm = pStemmer->stem_word(term);
+
+			// Add the stemmed term to the document
+			doc.add_posting(prefix + stemmedTerm, termPos);
+		}
+		else if (mode == STORE_BOTH)
+		{
+			string stemmedTerm = pStemmer->stem_word(term);
+
+			// Add both
+			doc.add_posting(prefix + term, termPos);
+			doc.add_posting(prefix + stemmedTerm, termPos);
+		}
+
+		// Next
+		termPos++;
+	}
+#ifdef DEBUG
+	cout << "XapianIndex::addTermsToDocument: added " << termPos << " terms" << endl;
+#endif
+
+	if (pStemmer != NULL)
+	{
+		delete pStemmer;
+	}
+
+	return true;
+}
+
+bool XapianIndex::prepareDocument(const DocumentInfo &info, Xapian::Document &doc,
+	Xapian::termcount &termPos, const std::string &summary) const
+{
+	// Add a magic term :-)
+	doc.add_posting(MAGIC_TERM, termPos);
+	termPos++;
+
+	// Index the title with and without prefix T
+	string title = info.getTitle();
+	if (title.empty() == false)
+	{
+		Document titleDoc;
+		titleDoc.setData(title.c_str(), title.length());
+		Tokenizer titleTokens(&titleDoc);
+		termPos = addTermsToDocument(titleTokens, doc, termPos, "T", STORE_UNSTEM);
+		titleTokens.rewind();
+		termPos = addTermsToDocument(titleTokens, doc, termPos, "", m_stemMode);
+	}
+
+	// Index the full URL with prefix U
+	string location = info.getLocation();
+	for (string::iterator i = location.begin(); i != location.end(); i++)
+	{
+		*i = tolower(*i);
+	}
+	doc.add_posting(string("U") + location, termPos++);
+
+	Url urlObj(location);
+
+	// ...the host name with prefix H
+	string hostName = urlObj.getHost();
+	doc.add_posting(string("H") + StringManip::toLowerCase(hostName), termPos++);
+	// ...and the file name with prefix F
+	string fileName = urlObj.getFile();
+	doc.add_posting(string("F") + StringManip::toLowerCase(fileName), termPos++);
+	// Finally, add the language with prefix L
+	doc.add_posting(string("L") + StringManip::toLowerCase(m_stemLanguage), termPos++);
+
+	setDocumentData(doc, info, summary, m_stemLanguage);
+
+	return true;
+}
+
+string XapianIndex::scanDocument(const char *pData, unsigned int dataLength,
+	DocumentInfo &info)
+{
+	vector<string> candidates;
+	string language;
+	string summary;
+
+	// Try to determine the document's language
+	LanguageDetector lang;
+	lang.guessLanguage(pData, max(dataLength, (unsigned int)2048), candidates);
+
+	// See which of these languages is suitable for stemming
+	for (vector<string>::iterator langIter = candidates.begin(); langIter != candidates.end(); ++langIter)
+	{
+		if (*langIter == "unknown")
+		{
+			continue;
+		}
+
+		try
+		{
+			Xapian::Stem stemmer(*langIter);
+		}
+		catch (const Xapian::Error &e)
+		{
+#ifdef DEBUG
+			cout << "XapianIndex::scanDocument: no support for " << *langIter << endl;
+#endif
+			continue;
+		}
+
+		language = *langIter;
+		break;
+	}
+	m_stemLanguage = language;
+#ifdef DEBUG
+	cout << "XapianIndex::scanDocument: language now " << m_stemLanguage << endl;
+#endif
+
+	// Get a summary of the document
+	if (language.empty() == true)
+	{
+		// Fall back on English
+		language = "english";
+	}
+	Summarizer sum(language, 100);
+	summary = sum.summarize(pData, dataLength);
+
+	// Update the document's properties
+	string title = info.getTitle();
+	if (title.empty() == true)
+	{
+		// Use the title supplied by the summarizer
+		title = sum.getTitle();
+		// Remove heading spaces
+		while (isspace(title[0]))
+		{
+			title.erase(0, 1);
+		}
+		info.setTitle(title);
+	}
+	info.setLanguage(m_stemLanguage);
+
+	return summary;
+}
+
+void XapianIndex::setDocumentData(Xapian::Document &doc, const DocumentInfo &info, const string &extract,
+	const string &language) const
+{
+	char timeStr[64];
+	string timestamp = info.getTimestamp();
+
+	// Set the document data omindex-style
+	string record = "url=";
+	record += info.getLocation();
+	record += "\nsample=";
+	record += extract;
+	record += "\ncaption=";
+	record += info.getTitle();
+	record += "\ntype=";
+	record += info.getType();
+	// Append a timestamp
+	record += "\ntimestamp=";
+	record += timestamp;
+	// ...and the language
+	record += "\nlanguage=";
+	record += language;
+#ifdef DEBUG
+	cout << "XapianIndex::setDocumentData: document data is " << record << endl;
+#endif
+	doc.set_data(record);
+
+	// Add this value to allow sorting by date
+	snprintf(timeStr, 64, "%d", TimeConverter::fromTimestamp(timestamp));
+	doc.add_value(0, timeStr);
+}
+
+//
+// Implementation of IndexInterface
+//
+
+/// Gets the index location.
+string XapianIndex::getLocation(void) const
+{
+	return m_databaseName;
+}
+
+/// Indexes the given data.
+bool XapianIndex::indexDocument(Tokenizer &tokens, unsigned int &docId)
+{
+	unsigned int dataLength = 0;
+	bool indexed = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if ((pDatabase == NULL) ||
+		(m_pHistory == NULL))
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		// Get the document
+		const Document *pDocument = tokens.getDocument();
+		if (pDocument == NULL)
+		{
+#ifdef DEBUG
+			cout << "XapianIndex::indexDocument: no document" << endl;
+#endif
+			return false;
+		}
+
+		// Obtain a summary
+		const char *pData = pDocument->getData(dataLength);
+		if (pData == NULL)
+		{
+#ifdef DEBUG
+			cout << "XapianIndex::indexDocument: empty document" << endl;
+#endif
+			return false;
+		}
+		// Cache the document's properties
+		DocumentInfo docInfo(pDocument->getTitle(), pDocument->getLocation(),
+			pDocument->getType(), pDocument->getLanguage());
+		docInfo.setTimestamp(pDocument->getTimestamp());
+
+		string summary = scanDocument(pData, dataLength, docInfo);
+
+#ifdef DEBUG
+		cout << "XapianIndex::indexDocument: adding terms" << endl;
+#endif
+		Xapian::Document doc;
+		Xapian::termcount termPos = 0;
+
+		// Add the tokenizer's terms to the Xapian document
+		termPos = addTermsToDocument(tokens, doc, termPos, "", m_stemMode);
+		if (prepareDocument(docInfo, doc, termPos, summary) == true)
+		{
+			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+			if (pIndex != NULL)
+			{
+				// Add this document to the Xapian index
+				docId = pIndex->add_document(doc);
+				// Add an entry in the history file
+				m_pHistory->insertItem(docId, docInfo);
+				indexed = true;
+			}
+			pDatabase->unlock();
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't index document: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't index document, unknown exception occured" << endl;
+	}
+
+	return indexed;
+}
+
+/// Updates the given document; true if success.
+bool XapianIndex::updateDocument(unsigned int docId, Tokenizer &tokens)
+{
+	unsigned int dataLength = 0;
+	bool updated = false;
+
+	const Document *pDocument = tokens.getDocument();
+	if (pDocument == NULL)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	// Obtain a summary
+	const char *pData = pDocument->getData(dataLength);
+	if (pData == NULL)
+	{
+		return false;
+	}
+
+	// Cache the document's properties
+	DocumentInfo docInfo(pDocument->getTitle(), pDocument->getLocation(),
+		pDocument->getType(), pDocument->getLanguage());
+	docInfo.setTimestamp(pDocument->getTimestamp());
+
+	string summary = scanDocument(pData, dataLength, docInfo);
+
+	try
+	{
+		Xapian::Document doc;
+		Xapian::termcount termPos = 0;
+
+		// Add the tokenizer's terms to the document
+		termPos = addTermsToDocument(tokens, doc, termPos, "", m_stemMode);
+		if (prepareDocument(docInfo, doc, termPos, summary) == true)
+		{
+			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+			if (pIndex != NULL)
+			{
+				// Update the document in the database
+				pIndex->replace_document(docId, doc);
+				// FIXME: if the document information has changed, we need to update the history too
+				updated = true;
+			}
+			pDatabase->unlock();
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't update document: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't update document, unknown exception occured" << endl;
+	}
+
+	return updated;
+}
+
+/// Returns the ID of the given document.
+unsigned int XapianIndex::hasDocument(const DocumentInfo &docInfo) const
+{
+	if (m_pHistory == NULL)
+	{
+		return 0;
+	}
+
+	// Is this URL in the history file ?
+	return m_pHistory->hasURL(docInfo.getLocation());
+}
+
+/// Unindexes the given document; true if success.
+bool XapianIndex::unindexDocument(unsigned int docId)
+{
+	bool unindexed = false;
+
+	if (docId == 0)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if ((pDatabase == NULL) ||
+		(m_pHistory == NULL))
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			// Delete the document from the index
+			pIndex->delete_document(docId);
+			// Remove the entry from the history file
+			m_pHistory->deleteItem(docId);
+			unindexed = true;
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't unindex document: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't unindex document, unknown exception occured" << endl;
+	}
+
+	return unindexed;
+}
+
+/// Flushes recent changes to the disk.
+bool XapianIndex::flush(void)
+{
+	bool flushed = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+#ifdef DEBUG
+		cout << "XapianIndex::flush: called" << endl;
+#endif
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			pIndex->flush();
+			flushed = true;
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't flush database: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't flush database, unknown exception occured" << endl;
+	}
+
+	return flushed;
+}
+
+/// Returns the number of documents.
+unsigned int XapianIndex::getDocumentsCount(void) const
+{
+	unsigned int docCount = 0;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return 0;
+	}
+
+	try
+	{
+		Xapian::Database *pIndex = pDatabase->readLock();
+		if (pIndex != NULL)
+		{
+			docCount = pIndex->get_doccount();
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't count documents: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't count documents, unknown exception occured" << endl;
+	}
+
+	return docCount;
+}
+
+/// Returns a list of document IDs.
+unsigned int XapianIndex::getDocumentIDs(set<unsigned int> &docIDList,
+	unsigned int maxDocsCount, unsigned int startDoc, bool sortByDate) const
+{
+	if (m_pHistory == NULL)
+	{
+		return 0;
+	}
+
+	docIDList.clear();
+
+	return m_pHistory->listItems(docIDList, maxDocsCount, startDoc, sortByDate);
+}
+
+/// Returns a document's properties.
+bool XapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
+{
+	if (m_pHistory == NULL)
+	{
+		return false;
+	}
+
+	return m_pHistory->getItem(docId, docInfo);
+}
+
+/// Updates a document's properties.
+bool XapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo)
+{
+	bool updated = false;
+
+	if (docId == 0)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			Xapian::Document doc = pIndex->get_document(docId);
+
+			// Get the current document data
+			string record = doc.get_data();
+			string extract = StringManip::extractField(record, "sample=", "\n");
+			string language = StringManip::extractField(record, "language=", "\n");
+
+			// Update the document data with the new extract
+			setDocumentData(doc, docInfo, extract, language);
+			// Update the document
+			if (m_pHistory->updateItem(docId, docInfo) == true)
+			{
+				pIndex->replace_document(docId, doc);
+				updated = true;
+			}
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't update document: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't update document, unknown exception occured" << endl;
+	}
+
+	return updated;
+}


Property changes on: trunk/Index/XapianIndex.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Index/XapianIndex.h
===================================================================
--- trunk/Index/XapianIndex.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/XapianIndex.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,92 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XAPIAN_INDEX_H
+#define _XAPIAN_INDEX_H
+
+#include <string>
+#include <set>
+
+#include <xapian.h>
+
+#include "DocumentInfo.h"
+#include "IndexHistory.h"
+#include "IndexInterface.h"
+
+class XapianIndex : public IndexInterface
+{
+	public:
+		XapianIndex(const std::string &indexName);
+		virtual ~XapianIndex();
+
+		/// Gets the index location.
+		virtual std::string getLocation(void) const;
+
+		/// Indexes the given data.
+		virtual bool indexDocument(Tokenizer &tokens, unsigned int &docId);
+
+		/// Updates the given document; true if success.
+		virtual bool updateDocument(unsigned int docId, Tokenizer &tokens);
+
+		/// Returns the ID of the given document.
+		virtual unsigned int hasDocument(const DocumentInfo &docInfo) const;
+
+		/// Unindexes the given document; true if success.
+		virtual bool unindexDocument(unsigned int docId);
+
+		/// Flushes recent changes to the disk.
+		virtual bool flush(void);
+
+		/// Returns the number of documents.
+		virtual unsigned int getDocumentsCount(void) const;
+
+		/// Returns a list of document IDs.
+		virtual unsigned int getDocumentIDs(std::set<unsigned int> &docIDList,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0,
+			bool sortByDate = false) const;
+
+		/// Returns a document's properties.
+		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const;
+
+		/// Updates a document's properties.
+		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo);
+
+	protected:
+		static const unsigned int m_maxTermLength;
+		static const std::string MAGIC_TERM;
+		std::string m_databaseName;
+		IndexHistory *m_pHistory;
+		std::string m_stemLanguage;
+
+		bool addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,
+			Xapian::termcount &termPos, const std::string &prefix, StemmingMode mode) const;
+
+		bool prepareDocument(const DocumentInfo &info, Xapian::Document &doc,
+			Xapian::termcount &termPos, const std::string &summary) const;
+
+		std::string scanDocument(const char *pData, unsigned int dataLength,
+			DocumentInfo &info);
+
+		void setDocumentData(Xapian::Document &doc, const DocumentInfo &info, const string &extract,
+			const string &language) const;
+
+	private:
+		XapianIndex(const XapianIndex &other);
+		XapianIndex &operator=(const XapianIndex &other);
+
+};
+
+#endif // _XAPIAN_INDEX_H


Property changes on: trunk/Index/XapianIndex.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Index/indextest.cpp
===================================================================
--- trunk/Index/indextest.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Index/indextest.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,119 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <iostream>
+
+#include "Document.h"
+#include "TokenizerFactory.h"
+#include "XapianDatabaseFactory.h"
+#include "XapianIndex.h"
+
+using namespace std;
+
+int main(int argc, char **argv)
+{
+	if (argc < 4)
+	{
+		cerr << "Usage: " << argv[0] << " <index type> <database name> <file name>|CHECK|CREATE" << endl;
+		return EXIT_FAILURE;
+	}
+
+	// Check database ?
+	if (strncasecmp(argv[3], "CHECK", 5) == 0)
+	{
+		if (XapianDatabaseFactory::getDatabase(argv[2], true) != NULL)
+		{
+			XapianIndex index(argv[2]);
+			cout << "Index has " << index.getDocumentsCount() << " document(s)" << endl;
+
+			return EXIT_SUCCESS;
+		}
+
+		return EXIT_FAILURE;
+	}
+	// Create database ?
+	else if (strncasecmp(argv[3], "CREATE", 6) == 0)
+	{
+		if (XapianDatabaseFactory::getDatabase(argv[2], false) != NULL)
+		{
+			return EXIT_SUCCESS;
+		}
+
+		return EXIT_FAILURE;
+	}
+
+	struct stat fileStat;
+	if ((stat(argv[3], &fileStat) == 0) &&
+		(S_ISREG(fileStat.st_mode)))
+	{
+		char *buffer = new char[fileStat.st_size + 1];
+		int fd = open(argv[3], O_RDONLY);
+		// Read the file
+		ssize_t readBytes = read(fd, buffer, fileStat.st_size);
+		if (readBytes == -1)
+		{
+			cerr << "Couldn't read " << argv[3] << " !" << endl;
+			return EXIT_FAILURE;
+		}
+
+		// Assume file is HTML...
+		Document doc(argv[3], argv[3], "text/html", "");
+		doc.setData(buffer, readBytes);
+		if (doc.isBinary() == true)
+		{
+			cerr << argv[3] << " is binary !" << endl;
+		}
+		else
+		{
+			unsigned int docId = 0;
+
+			Tokenizer *pTokens = TokenizerFactory::getTokenizer(argv[3], &doc);
+			if (pTokens == NULL)
+			{
+				cerr << "Couldn't obtain tokenizer for " << argv[3] << " !" << endl;
+				return EXIT_FAILURE;
+			}
+
+			// Ignore index type, use a XapianIndex
+			XapianIndex index(argv[2]);
+			index.setStemmingMode(IndexInterface::STORE_BOTH);
+			if (index.indexDocument(*pTokens, docId) == false)
+			{
+				cerr << "Couldn't index " << argv[3] << " !" << endl;
+			}
+			else
+			{
+				cout << "Added " << argv[3] << " to index, document" << docId << endl;
+			}
+
+			delete pTokens;
+		}
+
+		delete[] buffer;
+	}
+	else
+	{
+		cerr << "Couldn't stat " << argv[3] << " !" << endl;
+	}
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/Index/indextest.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Makefile
===================================================================
--- trunk/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,56 @@
+
+ROOT_DIR = .
+include ${ROOT_DIR}/variables.mk
+
+INSTALL_TARGETS = install-pinot
+ifeq ($(HAS_GOOGLEAPI),yes)
+SOAP_PROJECTS = Search/Google
+endif
+ifeq ($(HAS_OSAPI),yes)
+SOAP_PROJECTS += Search/ObjectsSearch
+endif
+PROJECTS := Utils Tokenize SQL Collect ${SOAP_PROJECTS} Search Index \
+	UI/RenderHTML UI/GTK2/src ${PLUGIN_PROJECTS}
+TARGETS_ALL := $(patsubst %,%_all,${PROJECTS})
+TARGETS_CLEAN := $(patsubst %,%_clean,${PROJECTS})
+
+targets : ${TARGETS_ALL}
+
+clean : ${TARGETS_CLEAN}
+
+update :
+	@cvs update
+
+pinot_po :
+	@xgettext -d pinot -o po/pinot.po --force-po --keyword=_ -f po/POTFILES
+ 
+pinot_mo :
+	@mkdir -p mo
+	@msgfmt -o mo/en_GB.mo po/en_GB.po
+	@msgfmt -o mo/fr_FR.mo po/fr_FR.po
+
+%_clean :
+	@make -C $(patsubst %_clean, %, $@) clean
+	
+%_all :
+	@make -C $(patsubst %_all, %, $@) all
+
+install: ${INSTALL_TARGETS}
+
+install-pinot:
+	@mkdir -p $(PREFIX)/usr/bin/
+	install -m 755 ${BIN_DIR}/pinot $(PREFIX)/usr/bin/pinot
+	@mkdir -p $(PREFIX)/usr/share/pinot/engines/
+	@mkdir -p $(PREFIX)/usr/share/pinot/tokenizers/
+	install -m 644 index.html $(PREFIX)/usr/share/pinot/
+	install -m 644 Search/Plugins/* $(PREFIX)/usr/share/pinot/engines/
+	install -m 755 ${LIB_DIR}/*.so $(PREFIX)/usr/share/pinot/tokenizers/
+	install -m 644 UI/GTK2/xapian-powered.png $(PREFIX)/usr/share/pinot/
+	install -m 644 UI/GTK2/metase-gtk2.glade $(PREFIX)/usr/share/pinot/
+	install -m 644 UI/GTK2/metase-gtk2.gladep $(PREFIX)/usr/share/pinot/
+	install -m 644 textcat_conf.txt $(PREFIX)/usr/share/pinot/
+	@mkdir -p $(PREFIX)/usr/share/locale/fr/LC_MESSAGES/
+	install -m 644 mo/fr_FR.mo $(PREFIX)/usr/share/locale/fr/LC_MESSAGES/pinot.mo
+	@mkdir -p $(PREFIX)/usr/share/icons/hicolor/48x48/apps/
+	install -m 644 UI/GTK2/pinot.png $(PREFIX)/usr/share/icons/hicolor/48x48/apps/
+


Property changes on: trunk/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/README
===================================================================
--- trunk/README	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/README	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,89 @@
+Pinot, http://pinot.berlios.de/
+
+Pinot is a metasearch tool for the X-Window desktop. It acts as a front-end for
+search engines such as Google (with support for the SOAP API), All The Web,
+Ask Jeeves, etc.. and allows one to index relevant results locally and query
+the index.
+It was developed and tested on GNU/Linux and should work on other Unix-like systems.
+
+Dependencies :
+---------------
+
+Name			Location			Version used
+----			--------			------------
+
+SQLite							sqlite-devel-3.1.2-1
+http://www.sqlite.org/
+
+xapian-core						xapian-core-devel-0.9.0-1
+http://www.xapian.org/
+
+neon							neon-devel-0.24.7-4
+http://www.webdav.org/neon/
+
+Google SOAP API (1)	Search/Google/googleapi		beta2
+
+ GSOAP			$GSOAP_HOME			2.6.2
+ http://www.cs.fsu.edu/~engelen/soap.html
+ eg GSOAP_HOME=/home/fabrice/Projects/gsoap-linux-2.6
+
+ObjectsSearch API (2)	Search/ObjectsSearch		beta
+
+ GSOAP			$GSOAP_HOME			2.6.2
+
+gtkmm >= 2.4.12						gtkmm24-devel-2.6.2-2
+http://www.gtkmm.org/
+
+libxml++ (3)						libxml++-devel-2.10.0-1
+http://libxmlplusplus.sourceforge.net/
+
+ libxml2						libxml2-devel-2.6.16-3
+
+ots							ots-devel-0.4.2-2
+http://libots.sourceforge.net/
+
+libtextcat						libtextcat-devel-2.2-1
+http://software.wise-guys.nl/libtextcat/
+
+fam							fam-devel-2.6.10-9.FC2
+http://oss.sgi.com/projects/fam/
+- OR -
+gamin (4)						gamin-0.1.1-3.FC4
+http://www.gnome.org/~veillard/gamin/
+
+gmime							gmime-devel-2.1.9-3
+http://spruce.sourceforge.net/gmime
+
+Mozilla with gtk-mozembed				mozilla-devel-1.6
+http://www.mozilla.org/
+
+boost (5)						boost-devel-1.32.0-1.fc3
+http://www.boost.org/
+
+pdftohtml						pdftohtml-0.36-4
+http://pdftohtml.sourceforge.net/
+
+antiword						antiword-0.36.1-2
+http://www.winfield.demon.nl/
+
+glademm (6)						glademm-2.6.0_cvs-SNAP
+http://home.wtal.de/petig/Gtk/index.html
+
+(1) enabled with 'make HAS_GOOGLEAPI=yes'
+(2) enabled with 'make HAS_OSAPI=yes'
+(3) or libxml++ 0.26 if HAS_LIBXMLPP026 is defined
+(4) >= 0.1.6 and a recent kernel are required for the inotify backend
+(5) for building only
+(6) to optionally regenerate the GUI code
+
+FAQ :
+-----
+
+- When listing an index or indexing documents, Pinot complains of an
+  "index error". What's going on ?
+
+  This is likely because a previous instance didn't exit properly and one
+  (or more) index is still locked. Quit Pinot and look for a "db_lock" file
+  in "~/.pinot/index" and "~/.pinot/mail". If it's there, delete it and
+  restart Pinot. This will be fixed in the future.
+


Property changes on: trunk/README
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/SQL/ActionHistory.cpp
===================================================================
--- trunk/SQL/ActionHistory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/ActionHistory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,127 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <iostream>
+
+#include "Url.h"
+#include "TimeConverter.h"
+#include "ActionHistory.h"
+
+ActionHistory::ActionHistory(const string &database) :
+	SQLiteBase(database)
+{
+}
+
+ActionHistory::~ActionHistory()
+{
+}
+
+/// Creates the ActionHistory table in the database.
+bool ActionHistory::create(const string &database)
+{
+	bool success = true;
+
+	// The specified path must be a file
+	if (SQLiteBase::check(database) == false)
+	{
+		return false;
+	}
+
+	SQLiteBase db(database);
+
+	// Does ActionHistory exist ?
+	if (db.executeSimpleStatement("SELECT * FROM ActionHistory LIMIT 1;") == false)
+	{
+#ifdef DEBUG
+		cout << "ActionHistory::create: ActionHistory doesn't exist" << endl;
+#endif
+		// Create the table
+		if (db.executeSimpleStatement("CREATE TABLE ActionHistory (Type UNSIGNED INT NOT NULL, Date TIMESTAMP, Option TEXT, PRIMARY KEY(Type, Option));") == false)
+		{
+			success = false;
+		}
+	}
+
+	return success;
+}
+
+/// Inserts an item.
+bool ActionHistory::insertItem(ActionType type, const string &option)
+{
+	string date = TimeConverter::toTimestamp(time(NULL));
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("INSERT INTO ActionHistory \
+		VALUES(%u, '%q', '%q');", (unsigned int)type, date.c_str(), option.c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Gets and deletes the oldest item.
+bool ActionHistory::deleteOldestItem(ActionType &type, string &option)
+{
+	string date;
+	bool success = false;
+
+	if (getOldestItem(type, date, option) == false)
+	{
+		return false;
+	}
+
+	// Delete from ActionHistory
+	SQLiteResults *results = executeStatement("DELETE FROM ActionHistory \
+		WHERE Type=%u AND Option='%q';", (unsigned int)type, option.c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+bool ActionHistory::getOldestItem(ActionType &type, string &date, string &option) const
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("SELECT Type, Date, Option \
+		FROM ActionHistory ORDER BY %s DESC LIMIT 1", "Date");
+	if (results != NULL)
+	{
+		SQLiteRow *row = results->nextRow();
+		if (row != NULL)
+		{
+			type = (ActionType)atoi(row->getColumn(0).c_str());
+			date = row->getColumn(1);
+			option = row->getColumn(2);
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}

Added: trunk/SQL/ActionHistory.h
===================================================================
--- trunk/SQL/ActionHistory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/ActionHistory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,52 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _ACTION_HISTORY_H
+#define _ACTION_HISTORY_H
+
+#include <string>
+
+#include "SQLiteBase.h"
+
+using namespace std;
+
+class ActionHistory : public SQLiteBase
+{
+	public:
+		ActionHistory(const string &database);
+		virtual ~ActionHistory();
+
+		/// Creates the ActionHistory table in the database.
+		static bool create(const string &database);
+
+		typedef enum { ACTION_INDEX = 0, ACTION_UPDATE, ACTION_UNINDEX } ActionType;
+
+		/// Inserts an item.
+		bool insertItem(ActionType type, const string &option);
+
+		/// Gets and deletes the oldest item.
+		bool deleteOldestItem(ActionType &type, string &option);
+
+	protected:
+		bool getOldestItem(ActionType &type, string &date, string &option) const;
+
+	private:
+		ActionHistory(const ActionHistory &other);
+		ActionHistory &operator=(const ActionHistory &other);
+
+};
+
+#endif // _ACTION_HISTORY_H

Added: trunk/SQL/IndexHistory.cpp
===================================================================
--- trunk/SQL/IndexHistory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/IndexHistory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,246 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <iostream>
+
+#include "Url.h"
+#include "TimeConverter.h"
+#include "IndexHistory.h"
+
+IndexHistory::IndexHistory(const string &database) :
+	SQLiteBase(database)
+{
+}
+
+IndexHistory::~IndexHistory()
+{
+}
+
+/// Creates the necessary tables in the database.
+bool IndexHistory::create(const string &database)
+{
+	bool success = true;
+
+	// The specified path must be a file
+	if (SQLiteBase::check(database) == false)
+	{
+		return false;
+	}
+
+	SQLiteBase db(database);
+
+	// Does IndexHistory exist ?
+	if (db.executeSimpleStatement("SELECT * FROM IndexHistory LIMIT 1;") == false)
+	{
+#ifdef DEBUG
+		cout << "IndexHistory::create: IndexHistory doesn't exist" << endl;
+#endif
+		// Create the table
+		if (db.executeSimpleStatement("CREATE TABLE IndexHistory \
+			(DocId BIGINT UNSIGNED NOT NULL PRIMARY KEY, Title VARCHAR(255), \
+			Url VARCHAR(255), Type VARCHAR(255), Language VARCHAR(255), \
+			Date TIMESTAMP, Status INT);") == false)
+		{
+			success = false;
+		}
+	}
+
+	return success;
+}
+
+/// Inserts an item.
+bool IndexHistory::insertItem(unsigned int docId, const DocumentInfo &docInfo)
+{
+	bool success = false;
+
+	// FIXME: make Status configurable
+	SQLiteResults *results = executeStatement("INSERT INTO IndexHistory \
+		VALUES(%u, '%q', '%q', '%q', '%q', '%d', 1);",
+		docId, docInfo.getTitle().c_str(), Url::escapeUrl(docInfo.getLocation()).c_str(),
+		docInfo.getType().c_str(), docInfo.getLanguage().c_str(),
+		TimeConverter::fromTimestamp(docInfo.getTimestamp()));
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Checks if an URL is in the history; returns the document ID.
+unsigned int IndexHistory::hasURL(const string &originalUrl) const
+{
+	unsigned int docId = 0;
+
+	SQLiteResults *results = executeStatement("SELECT DocId FROM IndexHistory \
+		WHERE Url='%q';",
+		Url::escapeUrl(originalUrl).c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row = results->nextRow();
+		if (row != NULL)
+		{
+			docId = (unsigned int)atoi(row->getColumn(0).c_str());
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return docId;
+}
+
+/// Updates an item.
+bool IndexHistory::updateItem(unsigned int docId, const DocumentInfo &docInfo)
+{
+	bool success = false;
+
+	// FIXME: make Status configurable
+	SQLiteResults *results = executeStatement("UPDATE IndexHistory \
+		SET Title='%q', Url='%q', Type='%q', Language='%q', Date='%d' \
+		WHERE DocId=%u;",
+		docInfo.getTitle().c_str(), Url::escapeUrl(docInfo.getLocation()).c_str(),
+		docInfo.getType().c_str(), docInfo.getLanguage().c_str(),
+		TimeConverter::fromTimestamp(docInfo.getTimestamp()), docId);
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Lists document IDs; returns the total count.
+unsigned int IndexHistory::listItems(set<unsigned int> &items,
+	unsigned int maxDocsCount, unsigned int startDoc,
+	bool sortByDate) const
+{
+	string sql;
+	unsigned int total = 0;
+
+	sql = "SELECT DocId FROM IndexHistory";
+	if (sortByDate == true)
+	{
+		sql += " ORDER BY Date";
+	}
+	if (maxDocsCount > 0)
+	{
+		char docsCountStr[64];
+
+		sql += " LIMIT ";
+		if (startDoc > 0)
+		{
+			snprintf(docsCountStr, 64, "%u", startDoc);
+			sql += docsCountStr;
+			sql += ",";
+		}
+		snprintf(docsCountStr, 64, "%u", maxDocsCount);
+		sql += docsCountStr;
+	}
+	sql += ";";
+	SQLiteResults *results = executeStatement(sql.c_str());
+	if (results != NULL)
+	{
+		while (results->hasMoreRows() == true)
+		{
+			SQLiteRow *row = results->nextRow();
+			if (row == NULL)
+			{
+				break;
+			}
+
+			unsigned int docId = (unsigned int)atoi(row->getColumn(0).c_str());
+#ifdef DEBUG
+			cout << "IndexHistory::listItems: item " << docId << endl;
+#endif
+			items.insert(docId);
+			total++;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return total;
+}
+
+/// Gets an item's properties.
+bool IndexHistory::getItem(unsigned int docId, DocumentInfo &docInfo) const
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("SELECT Title, Url, Type, \
+		Language, Date FROM IndexHistory WHERE DocId=%u;", docId);
+	if (results != NULL)
+	{
+		SQLiteRow *row =results->nextRow();
+		if (row != NULL)
+		{
+			docInfo.setTitle(row->getColumn(0));
+			docInfo.setLocation(Url::unescapeUrl(row->getColumn(1)));
+			docInfo.setType(row->getColumn(2));
+			docInfo.setLanguage(row->getColumn(3));
+			docInfo.setTimestamp(TimeConverter::toTimestamp(atoi(row->getColumn(4).c_str())));
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Deletes items.
+bool IndexHistory::deleteByURL(const string &originalUrl)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("DELETE FROM IndexHistory WHERE Url='%q';",
+		Url::escapeUrl(originalUrl).c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Deletes an item.
+bool IndexHistory::deleteItem(unsigned int docId)
+{
+	bool success = false;
+
+	// Delete from both IndexHistory and DocumentLabels
+	SQLiteResults *results = executeStatement("DELETE FROM IndexHistory WHERE DocId=%u;",
+		docId);
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}

Added: trunk/SQL/IndexHistory.h
===================================================================
--- trunk/SQL/IndexHistory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/IndexHistory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,67 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _INDEX_HISTORY_H
+#define _INDEX_HISTORY_H
+
+#include <string>
+#include <map>
+#include <set>
+
+#include "DocumentInfo.h"
+#include "SQLiteBase.h"
+
+using namespace std;
+
+class IndexHistory : public SQLiteBase
+{
+	public:
+		IndexHistory(const string &database);
+		virtual ~IndexHistory();
+
+		/// Creates the necessary tables in the database.
+		static bool create(const string &database);
+
+		/// Inserts an item.
+		bool insertItem(unsigned int docId, const DocumentInfo &docInfo);
+
+		/// Checks if an URL is in the history; returns the document ID.
+		unsigned int hasURL(const string &originalUrl) const;
+
+		/// Updates an item.
+		bool updateItem(unsigned int docId, const DocumentInfo &docInfo);
+
+		/// Lists document IDs; returns the total count.
+		unsigned int listItems(set<unsigned int> &items,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0,
+			bool sortByDate = false) const;
+
+		/// Gets an item's properties.
+		bool getItem(unsigned int docId, DocumentInfo &docInfo) const;
+
+		/// Deletes items.
+		bool deleteByURL(const string &originalUrl);
+
+		/// Deletes an item.
+		bool deleteItem(unsigned int docId);
+
+	private:
+		IndexHistory(const IndexHistory &other);
+		IndexHistory &operator=(const IndexHistory &other);
+
+};
+
+#endif // _INDEX_HISTORY_H

Added: trunk/SQL/LabelManager.cpp
===================================================================
--- trunk/SQL/LabelManager.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/LabelManager.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,350 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <iostream>
+
+#include "Url.h"
+#include "TimeConverter.h"
+#include "LabelManager.h"
+
+LabelManager::LabelManager(const string &database) :
+	SQLiteBase(database)
+{
+}
+
+LabelManager::~LabelManager()
+{
+}
+
+unsigned int LabelManager::getLabelId(const string &labelName) const
+{
+	unsigned int labelId = 0;
+
+	// Get the label ID
+	SQLiteResults *results = executeStatement("SELECT LabelId 	FROM IndexLabels WHERE Name='%q';",
+		labelName.c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row =results->nextRow();
+		if (row != NULL)
+		{
+			labelId = (unsigned int)atoi(row->getColumn(0).c_str());
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return labelId;
+}
+
+unsigned int LabelManager::getNewLabelId(void) const
+{
+	unsigned int labelId = 1;
+
+	// Get the label ID
+	SQLiteResults *results = executeStatement("SELECT ROWID FROM IndexLabels \
+		ORDER BY ROWID DESC LIMIT 1;");
+	if (results != NULL)
+	{
+		SQLiteRow *row =results->nextRow();
+		if (row != NULL)
+		{
+			labelId = (unsigned int)atoi(row->getColumn(0).c_str());
+			++labelId;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return labelId;
+}
+
+/// Creates the necessary tables in the database.
+bool LabelManager::create(const string &database)
+{
+	bool success = true;
+
+	// The specified path must be a file
+	if (SQLiteBase::check(database) == false)
+	{
+		return false;
+	}
+
+	SQLiteBase db(database);
+
+	// Does IndexLabels exist ?
+	if (db.executeSimpleStatement("SELECT * FROM IndexLabels LIMIT 1;") == false)
+	{
+#ifdef DEBUG
+		cout << "LabelManager::create: IndexLabels doesn't exist" << endl;
+#endif
+		// Create the table
+		if (db.executeSimpleStatement("CREATE TABLE IndexLabels \
+			(LabelId BIGINT UNSIGNED NOT NULL PRIMARY KEY, Name VARCHAR(255));") == false)
+		{
+			success = false;
+		}
+	}
+	// Does DocumentLabels exist ?
+	if (db.executeSimpleStatement("SELECT * FROM DocumentLabels LIMIT 1;") == false)
+	{
+#ifdef DEBUG
+		cout << "LabelManager::create: DocumentLabels doesn't exist" << endl;
+#endif
+		// Create the table
+		if (db.executeSimpleStatement("CREATE TABLE DocumentLabels \
+			(LabelId BIGINT UNSIGNED NOT NULL, DocId BIGINT UNSIGNED NOT NULL, \
+			Source VARCHAR(255), PRIMARY KEY(LabelId, DocId, Source));") == false)
+		{
+			success = false;
+		}
+	}
+
+	return success;
+}
+
+/// Gets a list of items with the given label.
+bool LabelManager::getDocumentsWithLabel(const string &labelName, const string &sourceName,
+	set<unsigned int> &items) const
+{
+	bool success = false;
+
+	unsigned int labelId = getLabelId(labelName);
+	if (labelId == 0)
+	{
+		// Label was not found
+		return false;
+	}
+
+	SQLiteResults *results = executeStatement("SELECT DocId FROM DocumentLabels \
+		WHERE LabelId=%u AND Source='%q';",
+		labelId, sourceName.c_str());
+	if (results != NULL)
+	{
+		while (results->hasMoreRows() == true)
+		{
+			SQLiteRow *row =results->nextRow();
+			if (row == NULL)
+			{
+				break;
+			}
+
+			unsigned int docId = (unsigned int)atoi(row->getColumn(0).c_str());
+#ifdef DEBUG
+			cout << "LabelManager::getDocumentsWithLabel: item " << docId << endl;
+#endif
+			items.insert(docId);
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Checks if a document has a label.
+bool LabelManager::hasLabel(unsigned int docId, const string &sourceName,
+	const string &labelName) const
+{
+	bool success = false;
+
+	unsigned int labelId = getLabelId(labelName);
+	if (labelId == 0)
+	{
+		// Label was not found
+		return false;
+	}
+
+	SQLiteResults *results = executeStatement("SELECT DocId FROM DocumentLabels \
+		WHERE LabelId=%u AND DocId=%u AND Source='%q';",
+		labelId, docId, sourceName.c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row =results->nextRow();
+		if (row != NULL)
+		{
+			// Yes, this document has the given label
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Sets a document's labels.
+bool LabelManager::setLabels(unsigned int docId, const string &sourceName,
+	const set<string> &labels)
+{
+	bool success = false;
+
+	// First off, delete all labels for this document
+	SQLiteResults *results = executeStatement("DELETE FROM DocumentLabels \
+		WHERE DocId=%u AND Source='%q';",
+		docId, sourceName.c_str());
+	if (results == NULL)
+	{
+		return false;
+	}
+	delete results;
+
+	for (set<string>::const_iterator iter = labels.begin(); iter != labels.end(); ++iter)
+	{
+		string labelName = (*iter);
+
+#ifdef DEBUG
+		cout << "LabelManager::setLabels: label " << labelName << endl;
+#endif
+		// Does this label exist ?
+		unsigned int labelId = getLabelId(labelName);
+		if (labelId == 0)
+		{
+			// No, it doesn't : create it then
+			labelId = getNewLabelId();
+			results = executeStatement("INSERT INTO IndexLabels VALUES(%u, '%q');",
+				labelId, labelName.c_str());
+			if (results == NULL)
+			{
+#ifdef DEBUG
+				cout << "LabelManager::setLabels: couldn't create label " << labelName << endl;
+#endif
+				continue;
+			}
+			delete results;
+		}
+
+		// Insert this label
+		SQLiteResults *results = executeStatement("INSERT INTO DocumentLabels VALUES(%u, %u, '%q');",
+			labelId, docId, sourceName.c_str());
+		if (results != NULL)
+		{
+			delete results;
+		}
+	}
+
+	return true;
+}
+
+/// Gets the labels for the given document.
+bool LabelManager::getLabels(unsigned int docId, const string &sourceName,
+	set<string> &labels) const
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("SELECT i.Name FROM IndexLabels i, \
+		DocumentLabels d WHERE d.LabelId=i.LabelId AND d.DocId=%u AND d.Source='%q';",
+		docId, sourceName.c_str());
+	if (results != NULL)
+	{
+		while (results->hasMoreRows() == true)
+		{
+			SQLiteRow *row = results->nextRow();
+			if (row == NULL)
+			{
+				break;
+			}
+
+			string labelName = row->getColumn(0);
+#ifdef DEBUG
+			cout << "LabelManager::getLabels: label " << labelName << endl;
+#endif
+			labels.insert(labelName);
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Renames a label.
+bool LabelManager::renameLabel(const string &name, const string &newName)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("UPDATE IndexLabels SET Name='%q' \
+		WHERE Name='%q';",
+		newName.c_str(), name.c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+#ifdef DEBUG
+	cout << "LabelManager::renameLabel: renamed " << name << " to " << newName << endl;
+#endif
+
+	return success;
+}
+
+/// Deletes all references to a label.
+bool LabelManager::deleteLabel(const string &name)
+{
+	bool success = false;
+
+	unsigned int labelId = getLabelId(name);
+	if (labelId == 0)
+	{
+		// Nothing to delete
+		return true;
+	}
+
+	// Delete from both IndexLabels and DocumentLabels
+	SQLiteResults *results = executeStatement("DELETE FROM DocumentLabels \
+		WHERE LabelId=%u; DELETE FROM IndexLabels WHERE LabelId=%u;",
+		labelId, labelId);
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Deletes an item.
+bool LabelManager::deleteItem(unsigned int docId, const string &sourceName)
+{
+	bool success = false;
+
+	// Delete from both IndexHistory and DocumentLabels
+	SQLiteResults *results = executeStatement("DELETE FROM DocumentLabels WHERE DocId=%u \
+		AND Source='%q';",
+		docId, sourceName.c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}

Added: trunk/SQL/LabelManager.h
===================================================================
--- trunk/SQL/LabelManager.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/LabelManager.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,74 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _LABEL_MANAGER_H
+#define _LABEL_MANAGER_H
+
+#include <string>
+#include <map>
+#include <set>
+
+#include "DocumentInfo.h"
+#include "SQLiteBase.h"
+
+using namespace std;
+
+class LabelManager : public SQLiteBase
+{
+	public:
+		LabelManager(const string &database);
+		virtual ~LabelManager();
+
+		/// Creates the necessary tables in the database.
+		static bool create(const string &database);
+
+		/// Gets a list of items with the given label.
+		bool getDocumentsWithLabel(const string &labelName, const string &sourceName,
+			set<unsigned int> &items) const;
+
+		/// Checks if a document has a label.
+		bool hasLabel(unsigned int docId, const string &sourceName,
+			const string &labelName) const;
+
+		/// Sets a document's labels.
+		bool setLabels(unsigned int docId, const string &sourceName,
+			const set<string> &labels);
+
+		/// Gets the labels for the given document.
+		bool getLabels(unsigned int docId, const string &sourceName,
+			set<string> &labels) const;
+
+		/// Renames a label.
+		bool renameLabel(const string &name, const string &newName);
+
+		/// Deletes all references to a label.
+		bool deleteLabel(const string &name);
+
+		/// Deletes an item.
+		bool deleteItem(unsigned int docId, const string &sourceName);
+
+	protected:
+		unsigned int getLabelId(const string &labelName) const;
+
+		unsigned int getNewLabelId(void) const;
+
+	private:
+		LabelManager(const LabelManager &other);
+		LabelManager &operator=(const LabelManager &other);
+
+};
+
+#endif // _LABEL_MANAGER_H

Added: trunk/SQL/Makefile
===================================================================
--- trunk/SQL/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,25 @@
+
+ROOT_DIR = ..
+include ${ROOT_DIR}/variables.mk
+
+SQL_SRCS = SQLiteBase.cpp ActionHistory.cpp IndexHistory.cpp \
+	QueryHistory.cpp ViewHistory.cpp LabelManager.cpp
+SQL_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${SQL_SRCS})
+SQL_TEST = ${BIN_DIR}/historytest
+
+targets : dirs ${SQL_LIB} ${SQL_TEST}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${SQL_LIB} ${SQL_TEST}
+
+# SQL tester
+
+${SQL_TEST} : ${OBJ_DIR}/historytest.o ${SQL_LIB} ${UTILS_LIB}
+	@echo Building ${SQL_TEST}
+	${LINK} -o $@ ${OBJ_DIR}/historytest.o ${SQL_LIB} ${UTILS_LIB} ${LIBS}
+
+# Library
+
+${SQL_LIB} : ${SQL_OBJS}
+	@echo Building ${SQL_LIB}
+	${AR} cr ${SQL_LIB} ${SQL_OBJS}

Added: trunk/SQL/QueryHistory.cpp
===================================================================
--- trunk/SQL/QueryHistory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/QueryHistory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,269 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <iostream>
+
+#include "Url.h"
+#include "TimeConverter.h"
+#include "QueryHistory.h"
+
+QueryHistory::QueryHistory(const string &database) :
+	SQLiteBase(database)
+{
+}
+
+QueryHistory::~QueryHistory()
+{
+}
+
+/// Creates the QueryHistory table in the database.
+bool QueryHistory::create(const string &database)
+{
+	bool success = true;
+
+	// The specified path must be a file
+	if (SQLiteBase::check(database) == false)
+	{
+		return false;
+	}
+
+	SQLiteBase db(database);
+
+	// Does QueryHistory exist ?
+	if (db.executeSimpleStatement("SELECT * FROM QueryHistory LIMIT 1;") == false)
+	{
+#ifdef DEBUG
+		cout << "QueryHistory::create: QueryHistory doesn't exist" << endl;
+#endif
+		// Create the table
+		if (db.executeSimpleStatement("CREATE TABLE QueryHistory (QueryName VARCHAR(255), \
+			EngineName VARCHAR(255), HostName VARCHAR(255), Url VARCHAR(255), Title VARCHAR(255), \
+			Extract VARCHAR(255), Language VARCHAR(255), Score FLOAT, PrevScore FLOAT, Date INTEGER, \
+			PRIMARY KEY(QueryName, EngineName, Url));") == false)
+		{
+			success = false;
+		}
+	}
+
+	return success;
+}
+
+/// Inserts an URL.
+bool QueryHistory::insertItem(const string &queryName, const string &engineName, const string &url,
+	const string &title, const string &extract, const string &language, float score)
+{
+	Url urlObj(url);
+	string hostName = urlObj.getHost();
+	string escapedUrl = Url::escapeUrl(url);
+	bool success = false;
+
+#ifdef DEBUG
+	cout << "QueryHistory::insertItem: called" << endl;
+#endif
+	SQLiteResults *results = executeStatement("INSERT INTO QueryHistory \
+		VALUES('%q', '%q', '%q', '%q', '%q', '%q', '%q', '%f', '0.0', '%d');",
+		queryName.c_str(), engineName.c_str(), hostName.c_str(),
+		escapedUrl.c_str(), title.c_str(), extract.c_str(), language.c_str(),
+		score, time(NULL));
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Checks if an URL is in the history; returns its current score or 0 if not found.
+float QueryHistory::hasItem(const string &queryName, const string &engineName, const string &url,
+	float &previousScore) const
+{
+	float score = 0;
+
+	SQLiteResults *results = executeStatement("SELECT Score, PrevScore FROM QueryHistory \
+		WHERE QueryName='%q' AND EngineName='%q' AND Url='%q';",
+		queryName.c_str(), engineName.c_str(), Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row = results->nextRow();
+		if (row != NULL)
+		{
+			score = (float)atof(row->getColumn(0).c_str());
+			previousScore = (float)atof(row->getColumn(1).c_str());
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return score;
+}
+
+/// Updates an URL's details.
+bool QueryHistory::updateItem(const string &queryName, const string &engineName, const string &url,
+	const string &title, const string &extract, const string &language, float score)
+{
+	bool success = false;
+
+#ifdef DEBUG
+	cout << "QueryHistory::updateItem: called on " << url << endl;
+#endif
+	SQLiteResults *results = executeStatement("UPDATE QueryHistory SET PrevScore=Score, \
+		Score=%f, Date='%d', Title='%q', Extract='%q', Language='%q' \
+		WHERE QueryName='%q' AND EngineName='%q' AND Url='%q';",
+		score, time(NULL), title.c_str(), extract.c_str(), language.c_str(),
+		queryName.c_str(), engineName.c_str(), Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Gets the first max items for the given query, engine pair.
+bool QueryHistory::getItems(const string &queryName, const string &engineName,
+	unsigned int max, vector<Result> &resultsList) const
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("SELECT Url, Title, Extract, Language, Score \
+		FROM QueryHistory WHERE QueryName='%q' AND EngineName='%q' ORDER BY Score DESC \
+		LIMIT %u;", queryName.c_str(), engineName.c_str(), max);
+	if (results != NULL)
+	{
+		while (results->hasMoreRows() == true)
+		{
+			SQLiteRow *row = results->nextRow();
+			if (row == NULL)
+			{
+				break;
+			}
+
+			Result result(Url::unescapeUrl(row->getColumn(0)).c_str(),
+				row->getColumn(1),
+				row->getColumn(2),
+				row->getColumn(3),
+				(float)atof(row->getColumn(4).c_str()));
+			resultsList.push_back(result);
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Gets an item's extract.
+string QueryHistory::getItemExtract(const string &queryName, const string &engineName, const string &url) const
+{
+	string extract;
+
+	SQLiteResults *results = executeStatement("SELECT Extract FROM QueryHistory \
+		WHERE QueryName='%q' AND EngineName='%q' AND Url='%q';",
+		queryName.c_str(), engineName.c_str(), Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row = results->nextRow();
+		if (row != NULL)
+		{
+			extract = row->getColumn(0);
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return extract;
+}
+
+/// Gets a query's last run time.
+string QueryHistory::getLastRun(const string &queryName, const string &engineName) const
+{
+	SQLiteResults *results = NULL;
+	string lastRun;
+
+	if (queryName.empty() == true)
+	{
+		return lastRun;
+	}
+
+	if (engineName.empty() == true)
+	{
+		results = executeStatement("SELECT MAX(Date) FROM QueryHistory \
+			WHERE QueryName='%q';", queryName.c_str());
+	}
+	else
+	{
+		results = executeStatement("SELECT MAX(Date) FROM QueryHistory \
+			WHERE QueryName='%q' AND EngineName='%q';",
+			queryName.c_str(), engineName.c_str());
+	}
+
+	if (results != NULL)
+	{
+		SQLiteRow *row = results->nextRow();
+		if (row != NULL)
+		{
+			int latestDate = atoi(row->getColumn(0).c_str());
+			if (latestDate > 0)
+			{
+				lastRun = TimeConverter::toTimestamp((time_t)latestDate);
+			}
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return lastRun;
+}
+
+/// Deletes items.
+bool QueryHistory::deleteItems(const string &name, bool isQueryName)
+{
+	SQLiteResults *results = NULL;
+
+	if (isQueryName == true)
+	{
+		results = executeStatement("DELETE FROM QueryHistory \
+			WHERE QueryName='%q';", name.c_str());
+	}
+	else
+	{
+		results = executeStatement("DELETE FROM QueryHistory \
+			WHERE EngineName='%q';", name.c_str());
+	}
+
+	if (results != NULL)
+	{
+		delete results;
+
+		return true;
+	}
+
+	return false;
+}

Added: trunk/SQL/QueryHistory.h
===================================================================
--- trunk/SQL/QueryHistory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/QueryHistory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,71 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _QUERY_HISTORY_H
+#define _QUERY_HISTORY_H
+
+#include <string>
+#include <vector>
+
+#include "Result.h"
+#include "SQLiteBase.h"
+
+using namespace std;
+
+class QueryHistory : public SQLiteBase
+{
+	public:
+		QueryHistory(const string &database);
+		virtual ~QueryHistory();
+
+		/// Creates the QueryHistory table in the database.
+		static bool create(const string &database);
+
+		/// Inserts an URL.
+		bool insertItem(const string &queryName, const string &engineName, const string &url,
+			const string &title, const string &extract, const string &language, float score);
+
+		/**
+		  * Checks if an URL is in the query's history.
+		  * If it is, it returns the current and previous scores; returns 0 if not found.
+		  */
+		float hasItem(const string &queryName, const string &engineName, const string &url,
+			float &previousScore) const;
+
+		/// Updates an URL's details.
+		bool updateItem(const string &queryName, const string &engineName, const string &url,
+			const string &title, const string &extract, const string &language, float score);
+
+		/// Gets the first max items for the given query, engine pair.
+		bool getItems(const string &queryName, const string &engineName,
+			unsigned int max, vector<Result> &resultsList) const;
+
+		/// Gets an item's extract.
+		string getItemExtract(const string &queryName, const string &engineName, const string &url) const;
+
+		/// Gets a query's last run time.
+		string getLastRun(const string &queryName, const string &engineName = "") const;
+
+		/// Deletes items.
+		bool deleteItems(const string &name, bool isQueryName);
+
+	private:
+		QueryHistory(const QueryHistory &other);
+		QueryHistory &operator=(const QueryHistory &other);
+
+};
+
+#endif // _QUERY_HISTORY_H

Added: trunk/SQL/SQLiteBase.cpp
===================================================================
--- trunk/SQL/SQLiteBase.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/SQLiteBase.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,331 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <algorithm>
+#include <iostream>
+
+#include "SQLiteBase.h"
+
+SQLiteRow::SQLiteRow(const vector<string> &rowColumns, int nColumns) :
+	m_nColumns(nColumns)
+{
+	if (rowColumns.empty() == true)
+	{
+		m_nColumns = 0;
+	}
+	else
+	{
+#ifdef DEBUG
+		cout << "SQLiteRow::SQLiteRow: " << rowColumns.size() << " columns" << endl;
+#endif
+		m_columns.reserve(rowColumns.size());
+#if 0
+		// FIXME: why does this segfault in string::assign() ?
+		copy(rowColumns.begin(), rowColumns.end(), m_columns.begin());
+#else
+		for (vector<string>::const_iterator colIter = rowColumns.begin(); colIter != rowColumns.end(); ++colIter)
+		{
+			m_columns.push_back(*colIter);
+		}
+#endif
+	}
+}
+
+SQLiteRow::~SQLiteRow()
+{
+}
+
+int SQLiteRow::getColumnsCount(void) const
+{
+	return m_nColumns;
+}
+
+string SQLiteRow::getColumn(int nColumn) const
+{
+	if (nColumn < m_nColumns)
+	{
+		vector<string>::const_iterator colIter = m_columns.begin();
+		for (unsigned int i = 0; (i < m_nColumns) && (colIter != m_columns.end()); ++i)
+		{
+			if (i == nColumn)
+			{
+				string column = *colIter;
+				return column;
+			}
+			++colIter;
+		}
+	}
+
+	return "";
+}
+
+SQLiteResults::SQLiteResults(char **results, int nRows, int nColumns) :
+	m_results(results),
+	m_nRows(nRows),
+	m_nColumns(nColumns),
+	m_nCurrentRow(0)
+{
+	// Check we actually have results
+	if ((m_results == NULL) ||
+		(m_nRows <= 0))
+	{
+		m_nRows = m_nColumns = m_nCurrentRow = 0;
+	}
+}
+
+SQLiteResults::~SQLiteResults()
+{
+	sqlite3_free_table(m_results);
+}
+
+bool SQLiteResults::hasMoreRows(void) const
+{
+	if ((m_nCurrentRow >= 0) &&
+		(m_nCurrentRow < m_nRows))
+	{
+		return true;
+	}
+
+	return false;
+}
+
+string SQLiteResults::getColumnName(int nColumn) const
+{
+	if (nColumn < m_nColumns)
+	{
+		return m_results[nColumn];
+	}
+
+	return "";
+}
+
+SQLiteRow *SQLiteResults::nextRow(void)
+{
+	if ((m_nCurrentRow < 0) ||
+		(m_nCurrentRow >= m_nRows))
+	{
+		return NULL;
+	}
+
+	// The very first row holds the column names
+	unsigned int firstIndex = (m_nCurrentRow  + 1) * m_nColumns;
+	unsigned int lastIndex = firstIndex + m_nColumns - 1;
+	vector<string> rowColumns;
+
+	for (unsigned int i = firstIndex; i <= lastIndex; ++i)
+	{
+		if (m_results[i] == NULL)
+		{
+			rowColumns.push_back("");
+		}
+		else
+		{
+			rowColumns.push_back(m_results[i]);
+		}
+	}
+	++m_nCurrentRow;
+
+	return new SQLiteRow(rowColumns, m_nColumns);
+}
+
+bool SQLiteResults::reset(void)
+{
+	m_nCurrentRow = 0;
+
+	return true;
+}
+
+SQLiteBase::SQLiteBase(const string &database) :
+	m_databaseName("")
+{
+	m_databaseName = database;
+}
+
+SQLiteBase::~SQLiteBase()
+{
+}
+
+bool SQLiteBase::check(const string &database)
+{
+	struct stat dbStat;
+
+	// The specified path must be a file
+	if ((stat(database.c_str(), &dbStat) != -1) &&
+		(!S_ISREG(dbStat.st_mode)))
+	{
+		// It exists, but it's not a file as expected
+		cerr << "SQLiteBase::check: " << database << " is not a file" << endl;
+		return false;
+	}
+
+	return true;
+}
+
+sqlite3 *SQLiteBase::open(const string &database) const
+{
+	sqlite3 *pDatabase = NULL;
+
+	// Open the new database
+	if ((sqlite3_open(database.c_str(), &pDatabase) != SQLITE_OK) ||
+		(pDatabase == NULL))
+	{
+		cerr << "SQLiteBase::open: couldn't open " << database << endl;
+		pDatabase = NULL;
+	}
+#ifdef DEBUG
+	else cout << "SQLiteBase::open: opened " << database << endl;
+#endif
+
+	return pDatabase;
+}
+
+void SQLiteBase::close(sqlite3 *pDatabase) const
+{
+	if (pDatabase != NULL)
+	{
+#ifdef DEBUG
+		cout << "SQLiteBase::close: changed " << sqlite3_total_changes(pDatabase) << " rows" << endl;
+#endif
+		sqlite3_close(pDatabase);
+#ifdef DEBUG
+		cout << "SQLiteBase::close: closed database" << endl;
+#endif
+	}
+}
+
+bool SQLiteBase::executeSimpleStatement(const string &sql) const
+{
+	char *errMsg = NULL;
+	bool success = true;
+
+	if (sql.empty() == true)
+	{
+		return false;
+	}
+
+	sqlite3 *pDatabase = open(m_databaseName);
+	if (pDatabase == NULL)
+	{
+		return false;
+	}
+
+	if (sqlite3_exec(pDatabase,
+		sql.c_str(), 
+		NULL, NULL, // No callback
+		&errMsg) != SQLITE_OK)
+	{
+		if (errMsg != NULL)
+		{
+#ifdef DEBUG
+			cout << "SQLiteBase::executeSimpleStatement: statement <" << sql << "> failed: " << errMsg << endl;
+#endif
+			sqlite3_free(errMsg);
+		}
+
+		success = false;
+	}
+	close(pDatabase);
+
+	return success;
+}
+
+SQLiteResults *SQLiteBase::executeStatement(const char *sqlFormat, ...) const
+{
+	SQLiteResults *pResults = NULL;
+	const char *pzTail = NULL;
+#ifdef _USE_VSNPRINTF
+	char stringBuff[2048];
+#endif
+	va_list ap;
+
+	if (sqlFormat == NULL)
+	{
+		return NULL;
+	}
+
+	sqlite3 *pDatabase = open(m_databaseName);
+	if (pDatabase == NULL)
+	{
+		return NULL;
+	}
+
+	va_start(ap, sqlFormat);
+#ifdef _USE_VSNPRINTF
+	int numChars = vsnprintf(stringBuff, 2048, sqlFormat, ap);
+	if (numChars <= 0)
+	{
+#ifdef DEBUG
+		cout << "SQLiteBase::executeStatement: couldn't format statement" << endl;
+#endif
+		close(pDatabase);
+		return NULL;
+	}
+	if (numChars >= 2048)
+	{
+		// Not enough space
+#ifdef DEBUG
+		cout << "SQLiteBase::executeStatement: not enough space (" << numChars << ")" << endl;
+#endif
+		close(pDatabase);
+		return NULL;
+	}
+	stringBuff[numChars] = '\0';
+#else
+	char *stringBuff = sqlite3_vmprintf(sqlFormat, ap);
+	if (stringBuff == NULL)
+	{
+#ifdef DEBUG
+		cout << "SQLiteBase::executeStatement: couldn't format statement" << endl;
+#endif
+		close(pDatabase);
+		return NULL;
+	}
+#endif
+
+	char **results;
+	char *errMsg;
+	int nRows, nColumns;
+	if (sqlite3_get_table(pDatabase,
+			stringBuff,
+			&results,
+			&nRows,
+			&nColumns,
+			&errMsg) != SQLITE_OK)
+	{
+		if (errMsg != NULL)
+		{
+#ifdef DEBUG
+			cout << "SQLiteBase::executeStatement: statement <" << stringBuff << "> failed: " << errMsg << endl;
+#endif
+			sqlite3_free(errMsg);
+		}
+	}
+	else
+	{
+		pResults = new SQLiteResults(results, nRows, nColumns);
+	}
+	va_end(ap);
+#ifndef _USE_VSNPRINTF
+	sqlite3_free(stringBuff);
+#endif
+	close(pDatabase);
+
+	return pResults;
+}

Added: trunk/SQL/SQLiteBase.h
===================================================================
--- trunk/SQL/SQLiteBase.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/SQLiteBase.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,92 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _SQLITE_BASE_H
+#define _SQLITE_BASE_H
+
+#include <string>
+#include <vector>
+
+#include <sqlite3.h>
+
+using namespace std;
+
+class SQLiteRow
+{
+	public:
+		SQLiteRow(const vector<string> &rowColumns, int nColumns);
+		virtual ~SQLiteRow();
+
+		int getColumnsCount(void) const;
+
+		string getColumn(int nColumn) const;
+
+	protected:
+		vector<string> m_columns;
+		int m_nColumns;
+
+};
+
+class SQLiteResults
+{
+	public:
+		SQLiteResults(char **results, int nRows, int nColumns);
+		virtual ~SQLiteResults();
+
+		bool hasMoreRows(void) const;
+
+		string getColumnName(int nColumn) const;
+
+		SQLiteRow *nextRow(void);
+
+		bool reset(void);
+
+	protected:
+		char **m_results;
+		int m_nRows;
+		int m_nColumns;
+		int m_nCurrentRow;
+
+	private:
+		SQLiteResults(const SQLiteResults &other);
+		SQLiteResults &operator=(const SQLiteResults &other);
+
+};
+
+class SQLiteBase
+{
+	public:
+		SQLiteBase(const string &database);
+		virtual ~SQLiteBase();
+
+		static bool check(const string &database);
+
+		bool executeSimpleStatement(const string &sql) const;
+		SQLiteResults *executeStatement(const char *sqlFormat, ...) const;
+
+	protected:
+		string m_databaseName;
+
+		sqlite3 *open(const string &database) const;
+		void close(sqlite3 *pDatabase) const;
+
+	private:
+		SQLiteBase(const SQLiteBase &other);
+		SQLiteBase &operator=(const SQLiteBase &other);
+
+};
+
+#endif // _SQLITE_BASE_H

Added: trunk/SQL/ViewHistory.cpp
===================================================================
--- trunk/SQL/ViewHistory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/ViewHistory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,120 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <iostream>
+
+#include "Url.h"
+#include "ViewHistory.h"
+
+ViewHistory::ViewHistory(const string &database) :
+	SQLiteBase(database)
+{
+}
+
+ViewHistory::~ViewHistory()
+{
+}
+
+/// Creates the ViewHistory table in the database.
+bool ViewHistory::create(const string &database)
+{
+	bool success = true;
+
+	// The specified path must be a file
+	if (SQLiteBase::check(database) == false)
+	{
+		return false;
+	}
+
+	SQLiteBase db(database);
+
+	// Does ViewHistory exist ?
+	if (db.executeSimpleStatement("SELECT * FROM ViewHistory LIMIT 1;") == false)
+	{
+#ifdef DEBUG
+		cout << "ViewHistory::create: ViewHistory doesn't exist" << endl;
+#endif
+		// Create the table
+		if (db.executeSimpleStatement("CREATE TABLE ViewHistory (Url VARCHAR(255) PRIMARY KEY, Status INT);") == false)
+		{
+			success = false;
+		}
+	}
+
+	return success;
+}
+
+/// Inserts an URL.
+bool ViewHistory::insertItem(const string &url)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("INSERT INTO ViewHistory \
+		VALUES('%q', '1');", Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}
+
+/// Checks if an URL is in the history.
+bool ViewHistory::hasItem(const string &url) const
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("SELECT Url FROM ViewHistory WHERE Url='%q';",
+		Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		SQLiteRow *row = results->nextRow();
+		if (row != NULL)
+		{
+			// If this returns anything, it's the URL we are looking for
+#ifdef DEBUG
+			cout << "ViewHistory::hasItem: URL " << row->getColumn(0) << endl;
+#endif
+			success = true;
+
+			delete row;
+		}
+
+		delete results;
+	}
+
+	return success;
+}
+
+/// Deletes an URL.
+bool ViewHistory::deleteItem(const string &url)
+{
+	bool success = false;
+
+	SQLiteResults *results = executeStatement("DELETE FROM ViewHistory \
+		WHERE Url='%q';", Url::escapeUrl(url).c_str());
+	if (results != NULL)
+	{
+		success = true;
+		delete results;
+	}
+
+	return success;
+}

Added: trunk/SQL/ViewHistory.h
===================================================================
--- trunk/SQL/ViewHistory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/ViewHistory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,50 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _VIEW_HISTORY_H
+#define _VIEW_HISTORY_H
+
+#include <string>
+
+#include "SQLiteBase.h"
+
+using namespace std;
+
+class ViewHistory : public SQLiteBase
+{
+	public:
+		ViewHistory(const string &database);
+		virtual ~ViewHistory();
+
+		/// Creates the ViewHistory table in the database.
+		static bool create(const string &database);
+
+		/// Inserts an URL.
+		bool insertItem(const string &url);
+
+		/// Checks if an URL is in the history.
+		bool hasItem(const string &url) const;
+
+		/// Deletes an URL.
+		bool deleteItem(const string &url);
+
+	private:
+		ViewHistory(const ViewHistory &other);
+		ViewHistory &operator=(const ViewHistory &other);
+
+};
+
+#endif // _VIEW_HISTORY_H

Added: trunk/SQL/historytest.cpp
===================================================================
--- trunk/SQL/historytest.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/SQL/historytest.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,90 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+
+#include "ActionHistory.h"
+#include "IndexHistory.h"
+#include "QueryHistory.h"
+#include "ViewHistory.h"
+
+using namespace std;
+
+int main(int argc, char **argv)
+{
+	if (argc < 3)
+	{
+		cerr << "Usage: " << argv[0] << " <database> CREATE|CHECK=<url>|LISTACTIONS=<max>" << endl;
+		return EXIT_FAILURE;
+	}
+
+	if (strncmp(argv[2], "CREATE", 6) == 0)
+	{
+		if ((ActionHistory::create(argv[1]) == true) &&
+			(IndexHistory::create(argv[1]) == true) &&
+			(QueryHistory::create(argv[1]) == true) &&
+			(ViewHistory::create(argv[1]) == true))
+		{
+			cout << "Created database " << argv[1] << " and its tables" << endl;
+		}
+		else
+		{
+			cout << "Couldn't create database " << argv[1] << endl;
+		}
+	}
+	else if (strncmp(argv[2], "CHECK=", 6) == 0)
+	{
+		IndexHistory history(argv[1]);
+
+		if (history.hasURL(argv[2] + 6) > 0)
+		{
+			cout << "URL exists in IndexHistory" << endl;
+		}
+		else
+		{
+			cout << "URL doesn't exist in IndexHistory" << endl;
+		}
+	}
+	else if (strncmp(argv[2], "LISTACTIONS=", 12) == 0)
+	{
+		ActionHistory actions(argv[1]);
+		SQLiteResults *results = actions.executeStatement("SELECT Option, Date FROM ActionHistory ORDER BY %s DESC LIMIT %s;", "Date", argv[2] + 12);
+		if (results != NULL)
+		{
+			while (results->hasMoreRows() == true)
+			{
+				SQLiteRow *row = results->nextRow();
+				if (row == NULL)
+				{
+					break;
+				}
+
+				for (int i = 0; i < row->getColumnsCount(); ++i)
+				{
+					cout << results->getColumnName(i) << ": " << row->getColumn(i) << endl;
+				}
+				delete row;
+			}
+			delete results;
+		}
+		else
+		{
+			cout << "Couldn't list actions in database " << argv[1] << endl;
+		}
+	}
+
+	return EXIT_SUCCESS;
+}

Added: trunk/Search/Google/GoogleAPIEngine.cpp
===================================================================
--- trunk/Search/Google/GoogleAPIEngine.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Google/GoogleAPIEngine.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,134 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "Url.h"
+#include "MIMEScanner.h"
+
+#include "GoogleAPIEngine.h"
+#include "GAPIGoogleSearchBindingProxy.h"
+#include "GAPI.nsmap"
+
+using namespace GAPI;
+
+GoogleAPIEngine::GoogleAPIEngine() :
+	SearchEngineInterface()
+{
+	// SearchEngineInterface members
+	m_maxResultsCount = 10;
+}
+
+GoogleAPIEngine::~GoogleAPIEngine()
+{
+	m_resultsList.clear();
+}
+
+/// Retrieves the specified URL from the cache; NULL if error. Caller deletes.
+Document *GoogleAPIEngine::retrieveCachedUrl(const string &url)
+{
+	GoogleSearchBinding soapProxy;
+	struct gapi1__doGetCachedPageResponse cacheOut;
+
+	if (soapProxy.gapi1__doGetCachedPage(m_key, url, cacheOut))
+	{
+		return NULL;
+	}
+
+	xsd__base64Binary base64Page = cacheOut.return_;
+	if ((base64Page.__ptr != NULL) &&
+		(base64Page. __size > 0))
+	{
+		Url urlObj(url);
+
+		Document *pDoc = new Document(url, url, MIMEScanner::scanUrl(urlObj), "");
+		pDoc->setData((const char*)base64Page.__ptr, (unsigned int)base64Page. __size);
+
+		return pDoc;
+	}
+	
+	return NULL;
+}
+
+/// Checks spelling.
+string GoogleAPIEngine::checkSpelling(const string &text)
+{
+	GoogleSearchBinding soapProxy;
+	struct gapi1__doSpellingSuggestionResponse spellOut;
+
+	if (soapProxy.gapi1__doSpellingSuggestion(m_key, text, spellOut))
+	{
+		return "";
+	}
+
+	return spellOut.return_;
+}
+
+//
+// Implementation of SearchEngineInterface
+//
+
+/// Runs a query; true if success.
+bool GoogleAPIEngine::runQuery(QueryProperties& queryProps)
+{
+	string andTerms = queryProps.getAndWords();
+	string phrase = queryProps.getPhrase();
+
+	setHostNameFilter(queryProps.getHostNameFilter());
+	setFileNameFilter(queryProps.getFileNameFilter());
+
+	if (m_key.empty() == true)
+	{
+		return false;
+	}
+
+	// FIXME: find out how m_notWords and m_anyWords could be used
+	if (andTerms.empty() == true)
+	{
+		if (phrase.empty() == true)
+		{
+			return false;
+		}
+		// Use the phrase as search terms then...
+		andTerms = phrase;
+		phrase = "";
+	}
+
+	GoogleSearchBinding soapProxy;
+	struct gapi1__doGoogleSearchResponse queryOut;
+
+	// No filter, no safe search
+	if (soapProxy.gapi1__doGoogleSearch(m_key, andTerms, 0, (m_maxResultsCount > 10 ? 10 : m_maxResultsCount),
+		((phrase.empty() == false) ? true : false), phrase, false, "", "latin1", "latin1", queryOut))
+	{
+		return false;
+	}
+
+	struct gapi1__GoogleSearchResult *searchResult = queryOut.return_;
+	float pseudoScore = 100;
+
+	for (int i = 0; i < searchResult->resultElements->__size; i++)
+	{
+		struct gapi1__ResultElement *resultElement = searchResult->resultElements->__ptr[i];
+
+		string resultUrl(resultElement->URL);
+		if (processResult(resultUrl) == true)
+		{
+			m_resultsList.push_back(Result(resultUrl, resultElement->title, resultElement->snippet, "", pseudoScore));
+			--pseudoScore;
+		}
+	}
+
+	return true;
+}


Property changes on: trunk/Search/Google/GoogleAPIEngine.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/Google/GoogleAPIEngine.h
===================================================================
--- trunk/Search/Google/GoogleAPIEngine.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Google/GoogleAPIEngine.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,48 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GOOGLE_API_ENGINE_H
+#define _GOOGLE_API_ENGINE_H
+
+#include <string>
+
+#include "Document.h"
+#include "SearchEngineInterface.h"
+
+using namespace std;
+
+class GoogleAPIEngine : public SearchEngineInterface
+{
+	public:
+		GoogleAPIEngine();
+		virtual ~GoogleAPIEngine();
+
+		/// Runs a query; true if success.
+		virtual bool runQuery(QueryProperties& queryProps);
+
+		/// Retrieves the specified URL from the cache; NULL if error. Caller deletes.
+		Document *retrieveCachedUrl(const string &url);
+
+		/// Checks spelling.
+		string checkSpelling(const string &text);
+
+	private:
+		GoogleAPIEngine(const GoogleAPIEngine &other);
+		GoogleAPIEngine &operator=(const GoogleAPIEngine &other);
+
+};
+
+#endif // _GOOGLE_API_ENGINE_H


Property changes on: trunk/Search/Google/GoogleAPIEngine.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/Google/GoogleSearch.h
===================================================================
--- trunk/Search/Google/GoogleSearch.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Google/GoogleSearch.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,224 @@
+namespace GAPI
+{
+/*  Web Services Definitions urn:GoogleSearch */
+
+/*  Modify this file to customize the generated data type declarations */
+
+/*
+
+**  The gSOAP WSDL parser for C and C++ 1.1.2
+**  Copyright (C) 2001-2004 Robert van Engelen, Genivia, Inc.
+**  All Rights Reserved. This product is provided "as is", without any warranty.
+
+
+--------------------------------------------------------------------------------
+gSOAP XML Web services tools
+Copyright (C) 2001-2004, Robert van Engelen, Genivia, Inc. All Rights Reserved.
+
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen at genivia.com / engelen at acm.org
+--------------------------------------------------------------------------------
+*/
+
+//gsoapopt w
+#import "stl.h"
+// built-in type "xs:base64Binary":
+class xsd__base64Binary { unsigned char *__ptr; int __size; };
+
+/*
+To customize the names of the namespace prefixes generated by wsdl2h, modify
+the prefix names below and add the modified lines to typemap.dat to run wsdl2h:
+
+gapi1 = urn:GoogleSearch
+*/
+
+//gsoap gapi1 schema namespace:	urn:GoogleSearch
+
+// forward declarations
+class gapi1__GoogleSearchResult;
+class gapi1__ResultElement;
+class ResultElementArray;
+class DirectoryCategoryArray;
+class gapi1__DirectoryCategory;
+
+
+class gapi1__GoogleSearchResult
+{ public:
+    bool                                 documentFiltering             ;
+    std::string                          searchComments                ;
+    int                                  estimatedTotalResultsCount    ;
+    bool                                 estimateIsExact               ;
+    ResultElementArray*                  resultElements                ;
+    std::string                          searchQuery                   ;
+    int                                  startIndex                    ;
+    int                                  endIndex                      ;
+    std::string                          searchTips                    ;
+    DirectoryCategoryArray*              directoryCategories           ;
+    double                               searchTime                    ;
+    struct soap                         *soap                          ;
+};
+
+class gapi1__ResultElement
+{ public:
+    std::string                          summary                       ;
+    std::string                          URL                           ;
+    std::string                          snippet                       ;
+    std::string                          title                         ;
+    std::string                          cachedSize                    ;
+    bool                                 relatedInformationPresent     ;
+    std::string                          hostName                      ;
+    gapi1__DirectoryCategory*            directoryCategory             ;
+    std::string                          directoryTitle                ;
+    struct soap                         *soap                          ;
+};
+
+class gapi1__DirectoryCategory
+{ public:
+    std::string                          fullViewableName              ;
+    std::string                          specialEncoding               ;
+    struct soap                         *soap                          ;
+};
+
+// SOAP encoded array ResultElementArray
+class ResultElementArray
+{ public:
+    gapi1__ResultElement*               *__ptr                         ;
+    int                                  __size                        ;
+    struct soap                         *soap                          ;
+};
+
+// SOAP encoded array DirectoryCategoryArray
+class DirectoryCategoryArray
+{ public:
+    gapi1__DirectoryCategory*           *__ptr                         ;
+    int                                  __size                        ;
+    struct soap                         *soap                          ;
+};
+
+/* Service GoogleSearchBinding operations:
+
+  gapi1__doGetCachedPage
+  gapi1__doSpellingSuggestion
+  gapi1__doGoogleSearch
+
+*/
+
+//gsoap gapi1 service name:	GoogleSearchBinding 
+//gsoap gapi1 service type:	GoogleSearchPort 
+//gsoap gapi1 service port:	http://api.google.com/search/beta2 
+//gsoap gapi1 service namespace:	urn:GoogleSearch 
+
+/* Service GoogleSearchBinding operation gapi1__doGetCachedPage
+
+  C stub function (defined in soapClient.c[pp]):
+  int soap_call_gapi1__doGetCachedPage(struct soap *soap,
+    NULL, (char *endpoint = NULL selects default endpoint for this operation)
+    NULL, (char *action = NULL selects default action for this operation)
+    std::string                         key,
+    std::string                         url,
+  struct gapi1__doGetCachedPageResponse {
+    xsd__base64Binary                   return_;
+  } & );
+
+  C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
+  class GoogleSearchBinding;
+
+*/
+
+//gsoap gapi1 service method-style:	doGetCachedPage rpc
+//gsoap gapi1 service method-encoding:	doGetCachedPage http://schemas.xmlsoap.org/soap/encoding/
+//gsoap gapi1 service method-action:	doGetCachedPage urn:GoogleSearchAction
+int gapi1__doGetCachedPage(
+    std::string                         key,
+    std::string                         url,
+  struct gapi1__doGetCachedPageResponse {
+    xsd__base64Binary                   return_;
+  } & );
+
+/* Service GoogleSearchBinding operation gapi1__doSpellingSuggestion
+
+  C stub function (defined in soapClient.c[pp]):
+  int soap_call_gapi1__doSpellingSuggestion(struct soap *soap,
+    NULL, (char *endpoint = NULL selects default endpoint for this operation)
+    NULL, (char *action = NULL selects default action for this operation)
+    std::string                         key,
+    std::string                         phrase,
+  struct gapi1__doSpellingSuggestionResponse {
+    std::string                         return_;
+  } & );
+
+  C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
+  class GoogleSearchBinding;
+
+*/
+
+//gsoap gapi1 service method-style:	doSpellingSuggestion rpc
+//gsoap gapi1 service method-encoding:	doSpellingSuggestion http://schemas.xmlsoap.org/soap/encoding/
+//gsoap gapi1 service method-action:	doSpellingSuggestion urn:GoogleSearchAction
+int gapi1__doSpellingSuggestion(
+    std::string                         key,
+    std::string                         phrase,
+  struct gapi1__doSpellingSuggestionResponse {
+    std::string                         return_;
+  } & );
+
+/* Service GoogleSearchBinding operation gapi1__doGoogleSearch
+
+  C stub function (defined in soapClient.c[pp]):
+  int soap_call_gapi1__doGoogleSearch(struct soap *soap,
+    NULL, (char *endpoint = NULL selects default endpoint for this operation)
+    NULL, (char *action = NULL selects default action for this operation)
+    std::string                         key,
+    std::string                         q,
+    int                                 start,
+    int                                 maxResults,
+    bool                                filter,
+    std::string                         restrict_,
+    bool                                safeSearch,
+    std::string                         lr,
+    std::string                         ie,
+    std::string                         oe,
+  struct gapi1__doGoogleSearchResponse {
+    gapi1__GoogleSearchResult*          return_;
+  } & );
+
+  C++ proxy class (defined in soapGoogleSearchBindingProxy.h):
+  class GoogleSearchBinding;
+
+*/
+
+//gsoap gapi1 service method-style:	doGoogleSearch rpc
+//gsoap gapi1 service method-encoding:	doGoogleSearch http://schemas.xmlsoap.org/soap/encoding/
+//gsoap gapi1 service method-action:	doGoogleSearch urn:GoogleSearchAction
+int gapi1__doGoogleSearch(
+    std::string                         key,
+    std::string                         q,
+    int                                 start,
+    int                                 maxResults,
+    bool                                filter,
+    std::string                         restrict_,
+    bool                                safeSearch,
+    std::string                         lr,
+    std::string                         ie,
+    std::string                         oe,
+  struct gapi1__doGoogleSearchResponse {
+    gapi1__GoogleSearchResult*          return_;
+  } & );
+
+/*  End of Web Services Definitions urn:GoogleSearch */
+}


Property changes on: trunk/Search/Google/GoogleSearch.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/Google/Makefile
===================================================================
--- trunk/Search/Google/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Google/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,28 @@
+
+ROOT_DIR = ../..
+include ${ROOT_DIR}/variables.mk
+
+GAPI_SRCS = GAPIClientLib.cpp GoogleAPIEngine.cpp
+GAPI_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${GAPI_SRCS})
+
+targets : dirs ${GAPI_LIB}
+
+clean : clean-stubs
+	@rm -f ${OBJ_DIR}/* ${GAPI_LIB}
+
+clean-stubs:
+	@rm -f GAPI* ${OBJ_DIR}/GAPI* *.xml
+
+# Google API stuff
+
+GoogleSearch.h : googleapi/GoogleSearch.wsdl
+	${WSDLC} -n gapi -o GoogleSearch.h googleapi/GoogleSearch.wsdl
+
+GAPIClientLib.cpp : GoogleSearch.h
+	${SOAPC} -n -pGAPI GoogleSearch.h
+
+# Library
+
+${GAPI_LIB} : ${GAPI_OBJS}
+	@echo Building ${GAPI_LIB}
+	${AR} cr ${GAPI_LIB} ${GAPI_OBJS}


Property changes on: trunk/Search/Google/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/Makefile
===================================================================
--- trunk/Search/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,56 @@
+
+ROOT_DIR = ..
+include ${ROOT_DIR}/variables.mk
+
+SE_SRCS = PluginWebEngine.cpp QueryProperties.cpp SearchEngineFactory.cpp \
+	SearchEngineInterface.cpp WebEngine.cpp XapianEngine.cpp
+SE_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${SE_SRCS})
+ifeq (${NEEDS_SOAP},yes)
+SOAPENV_OBJS = ${OBJ_DIR}/stdsoap.o ${OBJ_DIR}/SOAPEnvNS.o ${OBJ_DIR}/SOAPEnvC.o
+else
+SOAPENV_OBJS = 
+endif
+SE_TEST = ${BIN_DIR}/senginetest
+
+targets : dirs ${SE_LIB} ${SOAPENV_LIB} ${SE_TEST}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${SE_LIB} ${SOAPENV_LIB} ${SE_TEST}
+
+# SOAP environment
+
+${OBJ_DIR}/stdsoap.o : ${GSOAP_HOME}/stdsoap2.cpp
+	${CXX} -o ${OBJ_DIR}/stdsoap.o -c ${GSOAP_HOME}/stdsoap2.cpp ${CXXFLAGS}
+
+${OBJ_DIR}/SOAPEnvNS.o : SOAPEnvNS.cpp
+	${CXX} -o ${OBJ_DIR}/SOAPEnvNS.o -c SOAPEnvNS.cpp ${CXXFLAGS}
+
+SOAPEnv.h :
+	# Create an empty file, we just want to get global functions
+	@touch SOAPEnv.h
+
+SOAPEnvC.cpp : SOAPEnv.h
+	${SOAPC} -pSOAPEnv SOAPEnv.h
+
+${OBJ_DIR}/SOAPEnvC.o : SOAPEnvC.cpp
+	${CXX} -o ${OBJ_DIR}/SOAPEnvC.o -c SOAPEnvC.cpp ${CXXFLAGS}
+
+# SearchEngine tester
+
+${SE_TEST} : ${OBJ_DIR}/senginetest.o ${SE_LIBS} ${DL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB}
+	@echo Building ${SE_TEST}
+	${LINK} -o $@ ${OBJ_DIR}/senginetest.o ${SE_LIBS} ${DL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS}
+	
+# Libraries
+
+${SE_LIB} : ${SE_OBJS}
+	@echo Building ${SE_LIB}
+	${AR} cr ${SE_LIB} ${SE_OBJS}
+
+${SOAPENV_LIB} : ${SOAPENV_OBJS}
+ifeq (${NEEDS_SOAP},yes)
+	@echo Building ${SOAPENV_LIB}
+	${AR} cr ${SOAPENV_LIB} ${SOAPENV_OBJS}
+else
+	@echo Not building ${SOAPENV_LIB}
+endif


Property changes on: trunk/Search/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/ObjectsSearch/Makefile
===================================================================
--- trunk/Search/ObjectsSearch/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/ObjectsSearch/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,28 @@
+
+ROOT_DIR = ../..
+include ${ROOT_DIR}/variables.mk
+
+OSAPI_SRCS = OSAPIClientLib.cpp ObjectsSearchAPIEngine.cpp
+OSAPI_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${OSAPI_SRCS})
+
+targets : dirs ${OSAPI_LIB}
+
+clean : clean-stubs
+	@rm -f ${OBJ_DIR}/* ${OSAPI_LIB}
+
+clean-stubs:
+	@rm -f OSAPI* ${OBJ_DIR}/OSAPI* *.xml
+
+# ObjectsSearch API stuff
+
+ObjectsSearch.h : ObjectsSearch.wsdl
+	${WSDLC} -n osapi -o ObjectsSearch.h ObjectsSearch.wsdl
+
+OSAPIClientLib.cpp : ObjectsSearch.h
+	${SOAPC} -n -pOSAPI ObjectsSearch.h
+
+# Library
+
+${OSAPI_LIB} : ${OSAPI_OBJS}
+	@echo Building ${OSAPI_LIB}
+	${AR} cr ${OSAPI_LIB} ${OSAPI_OBJS}

Added: trunk/Search/ObjectsSearch/ObjectsSearch.h
===================================================================
--- trunk/Search/ObjectsSearch/ObjectsSearch.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/ObjectsSearch/ObjectsSearch.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,123 @@
+namespace OSAPI
+{
+/*  Web Services Definitions  */
+
+/*  Modify this file to customize the generated data type declarations */
+
+/*
+
+**  The gSOAP WSDL parser for C and C++ 1.1.2
+**  Copyright (C) 2001-2004 Robert van Engelen, Genivia, Inc.
+**  All Rights Reserved. This product is provided "as is", without any warranty.
+
+
+--------------------------------------------------------------------------------
+gSOAP XML Web services tools
+Copyright (C) 2001-2004, Robert van Engelen, Genivia, Inc. All Rights Reserved.
+
+GPL license.
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+This program is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+PARTICULAR PURPOSE. See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+Place, Suite 330, Boston, MA 02111-1307 USA
+
+Author contact information:
+engelen at genivia.com / engelen at acm.org
+--------------------------------------------------------------------------------
+*/
+
+//gsoapopt w
+#import "stl.h"
+
+/*
+To customize the names of the namespace prefixes generated by wsdl2h, modify
+the prefix names below and add the modified lines to typemap.dat to run wsdl2h:
+
+osapi1 = urn:OS_Search
+*/
+
+//gsoap osapi1 schema namespace:	urn:OS_Search
+
+// forward declarations
+class osapi1__OS_USCORESearchResultElement;
+class ArrayOfOS_USCORESearchResultElement;
+class osapi1__OS_USCORESearchResult;
+
+
+class osapi1__OS_USCORESearchResultElement
+{ public:
+    std::string*                         URL                           ;//nillable
+    std::string*                         summary                       ;//nillable
+    std::string*                         title                         ;//nillable
+    struct soap                         *soap                          ;
+};
+
+class osapi1__OS_USCORESearchResult
+{ public:
+    ArrayOfOS_USCORESearchResultElement*  resultElements                ;//nillable
+    int                                  endIndex                      ;
+    int                                  startIndex                    ;
+    std::string*                         searchQuery                   ;//nillable
+    int                                  estimatedTotalResultsCount    ;
+    struct soap                         *soap                          ;
+};
+
+// SOAP encoded array ArrayOfOS_USCORESearchResultElement
+class ArrayOfOS_USCORESearchResultElement
+{ public:
+    osapi1__OS_USCORESearchResultElement* *__ptr                         ;
+    int                                  __size                        ;
+    struct soap                         *soap                          ;
+};
+
+/* Service betaSoapBinding operations:
+
+  osapi2__doSearch
+
+*/
+
+//gsoap osapi2 service name:	betaSoapBinding 
+//gsoap osapi2 service type:	beta 
+//gsoap osapi2 service port:	http://www.objectssearch.com/search/services/beta 
+//gsoap osapi2 service namespace:	http://www.objectssearch.com/search/services/beta 
+
+/* Service betaSoapBinding operation osapi2__doSearch
+
+  C stub function (defined in soapClient.c[pp]):
+  int soap_call_osapi2__doSearch(struct soap *soap,
+    NULL, (char *endpoint = NULL selects default endpoint for this operation)
+    NULL, (char *action = NULL selects default action for this operation)
+    std::string                         queryParameter,
+    int                                 startParameter,
+    int                                 hitsPerPageParameter,
+  struct osapi2__doSearchResponse {
+    osapi1__OS_USCORESearchResult*      doSearchReturn;
+  } & );
+
+  C++ proxy class (defined in soapbetaSoapBindingProxy.h):
+  class betaSoapBinding;
+
+*/
+
+//gsoap osapi2 service method-style:	doSearch rpc
+//gsoap osapi2 service method-encoding:	doSearch http://schemas.xmlsoap.org/soap/encoding/
+//gsoap osapi2 service method-action:	doSearch ""
+int osapi2__doSearch(
+    std::string                         _queryParameter,
+    int                                 _startParameter,
+    int                                 _hitsPerPageParameter,
+  struct osapi2__doSearchResponse {
+    osapi1__OS_USCORESearchResult*      _doSearchReturn;
+  } & );
+
+/*  End of Web Services Definitions  */
+}

Added: trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.cpp
===================================================================
--- trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,128 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+
+#include "Url.h"
+
+#include "ObjectsSearchAPIEngine.h"
+#include "OSAPIbetaSoapBindingProxy.h"
+#include "OSAPI.nsmap"
+
+using std::cout;
+using std::endl;
+using namespace OSAPI;
+
+ObjectsSearchAPIEngine::ObjectsSearchAPIEngine() :
+	SearchEngineInterface()
+{
+	// SearchEngineInterface members
+	m_maxResultsCount = 10;
+}
+
+ObjectsSearchAPIEngine::~ObjectsSearchAPIEngine()
+{
+	m_resultsList.clear();
+}
+
+bool ObjectsSearchAPIEngine::makeCall(const string &query)
+{
+	if (query.empty() == true)
+	{
+		return false;
+	}
+
+	betaSoapBinding soapProxy;
+
+	struct osapi2__doSearchResponse searchResults;
+	searchResults._doSearchReturn = NULL;
+	cout << "ObjectsSearchAPIEngine::makeCall: query is " << query << endl;
+
+	int status = soapProxy.osapi2__doSearch(query, 0, 10, searchResults);
+	cout << "ObjectsSearchAPIEngine::makeCall: doSearch returned " << status << endl;
+	if (status == 0)
+	{
+		if (searchResults._doSearchReturn != NULL)
+		{
+			cout << "ObjectsSearchAPIEngine::makeCall: results !" << endl;
+
+			osapi1__OS_USCORESearchResult *pResult = searchResults._doSearchReturn;
+			unsigned int count = pResult->endIndex - pResult->startIndex;
+			cout << "ObjectsSearchAPIEngine::makeCall: " << count << " results out of " << pResult->estimatedTotalResultsCount << endl;
+
+			if ((pResult->resultElements != NULL) &&
+				(pResult->resultElements->__size > 0))
+			{
+				unsigned int numElements = (unsigned int)pResult->resultElements->__size;
+				float pseudoScore = 100;
+
+				cout << "ObjectsSearchAPIEngine::makeCall: array has " << numElements << " elements" << endl;
+				for (unsigned int currentElement = 0; currentElement < numElements; ++currentElement)
+				{
+					osapi1__OS_USCORESearchResultElement *pElem = pResult->resultElements->__ptr[currentElement];
+
+					if (pElem != NULL)
+					{
+						cout << "ObjectsSearchAPIEngine::makeCall: found result" << endl;
+						cout << "ObjectsSearchAPIEngine::makeCall: " << *(pElem->URL) << endl;
+						cout << "ObjectsSearchAPIEngine::makeCall: " << *(pElem->summary) << endl;
+						cout << "ObjectsSearchAPIEngine::makeCall: " << *(pElem->title) << endl;
+
+						string resultUrl(*(pElem->URL));
+						if (processResult(resultUrl) == true)
+						{
+							m_resultsList.push_back(Result(*(pElem->URL), *(pElem->title), *(pElem->summary), "", pseudoScore));
+							--pseudoScore;
+						}
+					}
+				}
+			}
+		}
+		else cout << "ObjectsSearchAPIEngine::makeCall: no results !" << endl;
+	}
+
+	return true;
+}
+
+//
+// Implementation of SearchEngineInterface
+//
+
+/// Runs a query; true if success.
+bool ObjectsSearchAPIEngine::runQuery(QueryProperties& queryProps)
+{
+	setHostNameFilter(queryProps.getHostNameFilter());
+	setFileNameFilter(queryProps.getFileNameFilter());
+
+	// See http://www.objectssearch.com/en/help.html for a description of queries
+	string query = queryProps.getAndWords();
+	string phrase = queryProps.getPhrase();
+	if (phrase.empty() == false)
+	{
+		query += " \"";
+		query += phrase;
+		query += "\" ";
+	}
+	string notWords = queryProps.getNotWords();
+	if (notWords.empty() == false)
+	{
+		query += " -";
+		query += notWords;
+	}
+	// FIXME: not sure what to do about m_anyWords...
+
+	return makeCall(query);
+}

Added: trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.h
===================================================================
--- trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,44 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _OBJECTSSEARCH_API_ENGINE_H
+#define _OBJECTSSEARCH_API_ENGINE_H
+
+#include <string>
+
+#include "SearchEngineInterface.h"
+
+using namespace std;
+
+class ObjectsSearchAPIEngine : public SearchEngineInterface
+{
+	public:
+		ObjectsSearchAPIEngine();
+		virtual ~ObjectsSearchAPIEngine();
+
+		/// Runs a query; true if success.
+		virtual bool runQuery(QueryProperties& queryProps);
+
+	protected:
+		bool makeCall(const string &query);
+
+	private:
+		ObjectsSearchAPIEngine(const ObjectsSearchAPIEngine &other);
+		ObjectsSearchAPIEngine &operator=(const ObjectsSearchAPIEngine &other);
+
+};
+
+#endif // _OBJECTSSEARCH_API_ENGINE_H

Added: trunk/Search/PluginWebEngine.cpp
===================================================================
--- trunk/Search/PluginWebEngine.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/PluginWebEngine.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,575 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <algorithm>
+#include <fstream>
+#include <iostream>
+
+#include "Document.h"
+#include "HtmlTokenizer.h"
+#include "PluginParser.h"
+#include "StringManip.h"
+#include "Url.h"
+#include "FileCollector.h"
+#include "PluginWebEngine.h"
+
+// A function object to lower case map keys with for_each()
+struct LowerAndCopy
+{
+	public:
+		LowerAndCopy(map<string, string> &other) : m_other(other)
+		{
+		}
+
+		void operator()(map<string, string>::value_type &p)
+		{
+			m_other[StringManip::toLowerCase(p.first)] = p.second;
+		}
+
+		map<string, string> &m_other;
+
+};
+
+PluginWebEngine::PluginWebEngine(const string &fileName) :
+	WebEngine()
+{
+	m_skipLocal = true;
+	m_nextFactor = 10;
+	m_nextBase = 0;
+	// SearchEngineInterface members
+	m_maxResultsCount = 10;
+
+	load(fileName);
+}
+
+PluginWebEngine::~PluginWebEngine()
+{
+}
+
+bool PluginWebEngine::load(const string &fileName)
+{
+	if (fileName.empty() == true)
+	{
+		return false;
+	}
+
+	// Get the definition file
+	FileCollector fileCollect;
+	DocumentInfo docInfo("Plugin", string("file://") + fileName,
+		"text/plain", "");
+	Document *pPluginDoc = fileCollect.retrieveUrl(docInfo);
+	if (pPluginDoc == NULL)
+	{
+#ifdef DEBUG
+		cerr << "PluginWebEngine::load: couldn't load " << fileName << endl;
+#endif
+		return false;
+	}
+
+	PluginParser parser(pPluginDoc);
+	if (parser.parse() == false)
+	{
+		delete pPluginDoc;
+
+		return false;
+	}
+	PluginProperties &properties = parser.getProperties();
+
+	map<string, string> searchParams, interpretParams;
+
+	// Lower case these maps' keys
+	LowerAndCopy lowCopy1(searchParams);
+	for_each(properties.m_searchParams.begin(), properties.m_searchParams.end(), lowCopy1);
+	LowerAndCopy lowCopy2(interpretParams);
+	for_each(properties.m_interpretParams.begin(), properties.m_interpretParams.end(), lowCopy2);
+
+	map<string, string>::iterator mapIter = searchParams.find("name");
+	if (mapIter != searchParams.end())
+	{
+		m_name = mapIter->second;
+	}
+
+	mapIter = searchParams.find("action");
+	if (mapIter != searchParams.end())
+	{
+		m_baseUrl = mapIter->second;
+	}
+
+	mapIter = searchParams.find("routetype");
+	if (mapIter != searchParams.end())
+	{
+		m_channel = mapIter->second;
+	}
+
+	copy(properties.m_inputItems.begin(), properties.m_inputItems.end(), inserter(m_inputTags, m_inputTags.begin()));
+	if (properties.m_userInput.empty() == false)
+	{
+		// Remove the user input tag from the input tags map
+		mapIter = m_inputTags.find(properties.m_userInput);
+		if (mapIter != m_inputTags.end())
+		{
+			m_inputTags.erase(mapIter);
+		}
+		m_userInputTag = properties.m_userInput;
+	}
+
+	mapIter = interpretParams.find("resultliststart");
+	if (mapIter != interpretParams.end())
+	{
+		m_resultListStart = StringManip::replaceSubString(mapIter->second, "\\n", "\n");
+	}
+
+	mapIter = interpretParams.find("resultlistend");
+	if (mapIter != interpretParams.end())
+	{
+		m_resultListEnd = StringManip::replaceSubString(mapIter->second, "\\n", "\n");
+	}
+
+	mapIter = interpretParams.find("resultitemstart");
+	if (mapIter != interpretParams.end())
+	{
+		m_resultItemStart = StringManip::replaceSubString(mapIter->second, "\\n", "\n");
+	}
+
+	mapIter = interpretParams.find("resultitemend");
+	if (mapIter != interpretParams.end())
+	{
+		m_resultItemEnd = StringManip::replaceSubString(mapIter->second, "\\n", "\n");
+	}
+
+	mapIter = interpretParams.find("resulttitlestart");
+	if (mapIter != interpretParams.end())
+	{
+		m_resultTitleStart = mapIter->second;
+	}
+
+	mapIter = interpretParams.find("resulttitleend");
+	if (mapIter != interpretParams.end())
+	{
+		
+		m_resultTitleEnd = mapIter->second;
+	}
+
+	mapIter = interpretParams.find("resultlinkstart");
+	if (mapIter != interpretParams.end())
+	{
+		m_resultLinkStart = mapIter->second;
+	}
+
+	mapIter = interpretParams.find("resultlinkend");
+	if (mapIter != interpretParams.end())
+	{
+		m_resultLinkEnd = mapIter->second;
+	}
+
+	mapIter = interpretParams.find("resultextractstart");
+	if (mapIter != interpretParams.end())
+	{
+		m_resultExtractStart = mapIter->second;
+	}
+
+	mapIter = interpretParams.find("resultextractend");
+	if (mapIter != interpretParams.end())
+	{
+		m_resultExtractEnd = mapIter->second;
+	}
+
+	mapIter = interpretParams.find("skiplocal");
+	if (mapIter != interpretParams.end())
+	{
+		if (mapIter->second == "false")
+		{
+			m_skipLocal = false;
+		}
+	}
+
+	m_nextTag = properties.m_nextInput;
+	// Here we differ from how Mozilla uses these parameters
+	// Normally, either factor or value is used, but we use value
+	// as the parameter's initial value
+	if (properties.m_nextFactor.empty() == false)
+	{
+		m_nextFactor = (unsigned int)atoi(properties.m_nextFactor.c_str());
+	}
+	if (properties.m_nextValue.empty() == false)
+	{
+		m_nextBase = (unsigned int)atoi(properties.m_nextValue.c_str());
+	}
+
+	delete pPluginDoc;
+
+	return true;
+}
+
+bool PluginWebEngine::getPage(const string &formattedQuery)
+{
+	bool foundResult = false;
+
+#ifdef DEBUG
+	cout << "PluginWebEngine::getPage: getting " << formattedQuery << endl;
+#endif
+	DocumentInfo docInfo("Results Page", formattedQuery,
+		"text/html", "");
+	Document *pUrlDoc = downloadPage(docInfo);
+	if (pUrlDoc == NULL)
+	{
+#ifdef DEBUG
+		cerr << "PluginWebEngine::getPage: couldn't download page " << formattedQuery << endl;
+#endif
+		return false;
+	}
+
+	float pseudoScore = 100;
+	unsigned int urlContentLen;
+	const char *urlContent = pUrlDoc->getData(urlContentLen);
+	if ((urlContent == NULL) ||
+		(urlContentLen == 0))
+	{
+#ifdef DEBUG
+		cerr << "PluginWebEngine::getPage: downloaded empty page" << endl;
+#endif
+		delete pUrlDoc;
+		return false;
+	}
+#ifdef DEBUG
+	ofstream pageBackup("PluginWebEngine.html");
+	pageBackup.write(urlContent, urlContentLen);
+	pageBackup.close();
+#endif
+
+	// Extract the results list
+#ifdef DEBUG
+	cout << "PluginWebEngine::getPage: getting results list (" << m_resultListStart << ", " << m_resultListEnd << ")" << endl;
+#endif
+	string resultList = StringManip::extractField(urlContent, m_resultListStart, m_resultListEnd);
+	if (resultList.empty() == true)
+	{
+		resultList = string(urlContent, urlContentLen);
+	}
+
+	// Extract results
+	string::size_type endPos = 0;
+#ifdef DEBUG
+	cout << "PluginWebEngine::getPage: getting first result (" << m_resultItemStart << ", " << m_resultItemEnd << ")" << endl;
+#endif
+	string resultItem = StringManip::extractField(resultList, m_resultItemStart, m_resultItemEnd, endPos);
+	while ((resultItem.empty() == false) &&
+		(m_resultsList.size() <= m_maxResultsCount))
+	{
+		string contentType, url, name, extract;
+
+#ifdef DEBUG
+		cout << "PluginWebEngine::getPage: candidate chunk \"" << resultItem << "\"" << endl;
+#endif
+		contentType = pUrlDoc->getType();
+		if (strncasecmp(contentType.c_str(), "text/html", 9) == 0)
+		{
+			Document chunkDoc("", "", contentType, "");
+			chunkDoc.setData(resultItem.c_str(), resultItem.length());
+			HtmlTokenizer chunkTokens(&chunkDoc);
+			set<Link> &chunkLinks = chunkTokens.getLinks();
+			unsigned int endOfFirstLink = 0, startOfSecondLink = 0, endOfSecondLink = 0, startOfThirdLink = 0;
+
+			// The result's URL and title should be given by the first link
+			for (set<Link>::iterator linkIter = chunkLinks.begin(); linkIter != chunkLinks.end(); ++linkIter)
+			{
+				if (linkIter->m_pos == 0)
+				{
+					url = linkIter->m_url;
+					name = linkIter->m_name;
+#ifdef DEBUG
+					cout << "PluginWebEngine::getPage: first link in chunk is " << url << endl;
+#endif
+					endOfFirstLink = linkIter->m_close;
+				}
+				else if (linkIter->m_pos == 1)
+				{
+					startOfSecondLink = linkIter->m_open;
+					endOfSecondLink = linkIter->m_close;
+				}
+				else if (linkIter->m_pos == 2)
+				{
+					startOfThirdLink = linkIter->m_open;
+				}
+			}
+
+			// Chances are the extract is between the first two links
+			if (endOfFirstLink > 0)
+			{
+				string extractWithMarkup1, extractWithMarkup2;
+				string extractCandidate1, extractCandidate2;
+
+				if (startOfSecondLink > 0)
+				{
+					extractWithMarkup1 = resultItem.substr(endOfFirstLink, startOfSecondLink - endOfFirstLink);
+				}
+				else
+				{
+					extractWithMarkup1 = resultItem.substr(endOfFirstLink);
+				}
+				extractCandidate1 = HtmlTokenizer::stripTags(extractWithMarkup1);
+
+				// ... or between the second and third link :-)
+				if (endOfSecondLink > 0)
+				{
+					if (startOfThirdLink > 0)
+					{
+						extractWithMarkup2 = resultItem.substr(endOfSecondLink, startOfThirdLink - endOfSecondLink);
+					}
+					else
+					{
+						extractWithMarkup2 = resultItem.substr(endOfSecondLink);
+					}
+				}
+				extractCandidate2 = HtmlTokenizer::stripTags(extractWithMarkup2);
+
+				// It seems we can rely on length to determine which is the right one
+				if (extractCandidate1.length() > extractCandidate2.length())
+				{
+					extract = extractCandidate1;
+				}
+				else
+				{
+					extract = extractCandidate2;
+				}
+#ifdef DEBUG
+				cout << "PluginWebEngine::getPage: extract is \"" << extract << "\"" << endl;
+#endif
+			}
+		}
+		else
+		{
+			// This is not HTML
+			// Use extended attributes
+			if ((m_resultTitleStart.empty() == false) &&
+				(m_resultTitleEnd.empty() == false))
+			{
+				name = StringManip::extractField(resultItem, m_resultTitleStart, m_resultTitleEnd);
+			}
+
+			if ((m_resultLinkStart.empty() == false) &&
+				(m_resultLinkEnd.empty() == false))
+			{
+				url = StringManip::extractField(resultItem, m_resultLinkStart, m_resultLinkEnd);
+			}
+
+			if ((m_resultExtractStart.empty() == false) &&
+				(m_resultExtractEnd.empty() == false))
+			{
+				extract = StringManip::extractField(resultItem, m_resultExtractStart, m_resultExtractEnd);
+			}
+		}
+
+		if (url.empty() == false)
+		{
+			Url urlObj(url);
+
+			// Is this URL relative to the search engine's domain ?
+			// FIXME: look for a interpret/baseurl tag, see https://bugzilla.mozilla.org/show_bug.cgi?id=65453
+			// FIXME: obey m_skipLocal
+			if (urlObj.getHost().empty() == true)
+			{
+				Url baseUrlObj(formattedQuery);
+
+				string tmpUrl = baseUrlObj.getProtocol();
+				tmpUrl += "://";
+				tmpUrl += baseUrlObj.getHost();
+				if (url[0] != '/')
+				{
+					tmpUrl += "/";
+				}
+				tmpUrl += url;
+				url = tmpUrl;
+			}
+
+			if (processResult(url) == true)
+			{
+				m_resultsList.push_back(Result(url, name, extract, "", pseudoScore));
+			}
+			--pseudoScore;
+			foundResult = true;
+		}
+
+		// Next
+		endPos += m_resultItemEnd.length();
+		resultItem = StringManip::extractField(resultList, m_resultItemStart, m_resultItemEnd, endPos);
+	}
+	delete pUrlDoc;
+
+	return foundResult;
+}
+
+bool PluginWebEngine::getDetails(const string &fileName, string &name, string &channel)
+{
+	if (fileName.empty() == true)
+	{
+		return false;
+	}
+
+	// Get the definition file
+	FileCollector fileCollect;
+	DocumentInfo docInfo(name, string("file://") + fileName,
+		"text/plain", "");
+	Document *pPluginDoc = fileCollect.retrieveUrl(docInfo);
+	if (pPluginDoc == NULL)
+	{
+#ifdef DEBUG
+		cerr << "PluginWebEngine::getDetails: couldn't load " << fileName << endl;
+#endif
+		return false;
+	}
+
+	PluginParser parser(pPluginDoc);
+	if (parser.parse(true) == false)
+	{
+#ifdef DEBUG
+		cerr << "PluginWebEngine::getDetails: couldn't parse " << fileName << endl;
+#endif
+		delete pPluginDoc;
+
+		return false;
+	}
+	PluginProperties &properties = parser.getProperties();
+
+	map<string, string> searchParams;
+
+	LowerAndCopy lowCopy1(searchParams);
+	for_each(properties.m_searchParams.begin(), properties.m_searchParams.end(), lowCopy1);
+
+	map<string, string>::iterator mapIter = searchParams.find("name");
+	if (mapIter != searchParams.end())
+	{
+		name = mapIter->second;
+	}
+	mapIter = searchParams.find("routetype");
+	if (mapIter != searchParams.end())
+	{
+		channel = mapIter->second;
+	}
+
+	delete pPluginDoc;
+
+	return true;
+}
+
+//
+// Implementation of SearchEngineInterface
+//
+
+/// Runs a query; true if success.
+bool PluginWebEngine::runQuery(QueryProperties& queryProps)
+{
+	string queryString = queryProps.toString(false);
+	unsigned int currentFactor = 0, count = 0;
+
+	m_resultsList.clear();
+
+	if (m_userInputTag.empty() == true)
+	{
+#ifdef DEBUG
+		cout << "PluginWebEngine::runQuery: no user input tag" << endl;
+#endif
+		return false;
+	}
+	if (queryString.empty() == true)
+	{
+#ifdef DEBUG
+		cout << "PluginWebEngine::runQuery: query is empty" << endl;
+#endif
+		return false;
+	}
+
+	string formattedQuery = m_baseUrl;
+	formattedQuery += "?";
+	formattedQuery += m_userInputTag;
+	formattedQuery += "=";
+	formattedQuery += queryString;
+	for (map<string, string>::iterator tagIter = m_inputTags.begin(); tagIter != m_inputTags.end(); ++tagIter)
+	{
+		formattedQuery += "&";
+		formattedQuery += tagIter->first;
+		formattedQuery += "=";
+		formattedQuery += tagIter->second;
+	}
+
+	setHostNameFilter(queryProps.getHostNameFilter());
+	setFileNameFilter(queryProps.getFileNameFilter());
+
+#ifdef DEBUG
+	cout << "PluginWebEngine::runQuery: querying " << m_name << endl;
+#endif
+	while (count < m_maxResultsCount)
+	{
+		string pageQuery = formattedQuery;
+
+		if (m_nextTag.empty() == false)
+		{
+			char factorStr[64];
+
+			// Is the INPUTNEXT FACTOR set to zero ?
+			if (m_nextFactor == 0)
+			{
+				// Assume INPUTNEXT allows to specify a number of results
+				// Not sure if this is how Sherlock/Mozilla interpret this
+				pageQuery += "&";
+				pageQuery += m_nextTag;
+				pageQuery += "=";
+				snprintf(factorStr, 64, "%u", m_maxResultsCount);
+				pageQuery += factorStr;
+			}
+			else
+			{
+				pageQuery += "&";
+				pageQuery += m_nextTag;
+				pageQuery += "=";
+				snprintf(factorStr, 64, "%u", currentFactor + m_nextBase);
+				pageQuery += factorStr;
+			}
+		}
+
+		if (getPage(pageQuery) == false)
+		{
+			break;
+		}
+
+		if (m_nextFactor == 0)
+		{
+			// That one page should have all the results...
+#ifdef DEBUG
+			cout << "PluginWebEngine::runQuery: performed one off call" << endl;
+#endif
+			break;
+		}
+		else
+		{
+			if (m_resultsList.size() < count + m_nextFactor)
+			{
+				// We got less than the maximum number of results per page
+				// so there's no point in requesting the next page
+#ifdef DEBUG
+				cout << "PluginWebEngine::runQuery: last page wasn't full" << endl;
+#endif
+				break;
+			}
+
+			// Increase factor
+			currentFactor += m_nextFactor;
+		}
+		count = m_resultsList.size();
+	}
+
+	return true;
+}

Added: trunk/Search/PluginWebEngine.h
===================================================================
--- trunk/Search/PluginWebEngine.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/PluginWebEngine.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,76 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XML_WEB_ENGINE_H
+#define _XML_WEB_ENGINE_H
+
+#include <string>
+#include <set>
+#include <map>
+
+#include "WebEngine.h"
+
+using namespace std;
+
+/**
+  * A class that implements the Sherlock search plugin standard.
+  * See http://developer.apple.com/technotes/tn/tn1141.html
+  * and http://mycroft.mozdev.org/deepdocs/deepdocs.html
+  */	  
+class PluginWebEngine : public WebEngine
+{
+	public:
+		PluginWebEngine(const string &fileName);
+		virtual ~PluginWebEngine();
+
+		/// Utility method that returns a search plugin's name and channel.
+		static bool getDetails(const string &fileName, string &name, string &channel);
+
+		/// Runs a query; true if success.
+		virtual bool runQuery(QueryProperties& queryProps);
+
+	protected:
+		string m_name;
+		string m_baseUrl;
+		string m_channel;
+		map<string, string> m_inputTags;
+		string m_userInputTag;
+		string m_resultListStart;
+		string m_resultListEnd;
+		string m_resultItemStart;
+		string m_resultItemEnd;
+		string m_resultTitleStart;
+		string m_resultTitleEnd;
+		string m_resultLinkStart;
+		string m_resultLinkEnd;
+		string m_resultExtractStart;
+		string m_resultExtractEnd;
+		bool m_skipLocal;
+		string m_nextTag;
+		unsigned int m_nextFactor;
+		unsigned int m_nextBase;
+
+		bool load(const string &fileName);
+
+		bool getPage(const string &formattedQuery);
+
+	private:
+		PluginWebEngine(const PluginWebEngine &other);
+		PluginWebEngine &operator=(const PluginWebEngine &other);
+
+};
+
+#endif // _XML_WEB_ENGINE_H

Added: trunk/Search/Plugins/A9.src
===================================================================
--- trunk/Search/Plugins/A9.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/A9.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,24 @@
+# A9 Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="A9"
+	description="Amazon A9.com"
+	method="GET"
+	action="http://a9.com/"
+	routeType="The Web"
+>
+
+<INPUT NAME="q" USER>
+<INPUT NAME="p" VALUE="0">
+# The next line sets pw to 1 + results_count/10
+<INPUTNEXT NAME="pw" FACTOR="1" VALUE="1">
+
+<INTERPRET
+resultListStart=""
+resultListEnd=""
+resultItemStart='style="margin-bottom:'
+resultItemEnd='</div>'
+>
+
+</SEARCH>

Added: trunk/Search/Plugins/Acoona.src
===================================================================
--- trunk/Search/Plugins/Acoona.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Acoona.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,31 @@
+# Acoona Plugin
+
+<SEARCH
+	version="1.0"
+	name="Acoona"
+	description="Acoona.com"
+	method="GET"
+	action="http://www.accoona.com/search.jsp"
+	routeType="The Web"
+>
+
+<INPUT NAME="la" VALUE="en">
+<INPUT NAME="col" VALUE="">
+<INPUT NAME="qt" USER>
+<INPUTNEXT NAME="st" FACTOR="10" VALUE="1">
+
+<INTERPRET
+resultListStart=""
+resultListEnd=""
+resultItemStart='<td class="webtitle" valign="top">'
+resultItemEnd='</span> </td></tr>'
+>
+
+</SEARCH>
+
+
+
+
+
+
+

Added: trunk/Search/Plugins/Altavista.src
===================================================================
--- trunk/Search/Plugins/Altavista.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Altavista.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,36 @@
+# Altavista Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="Altavista"
+	description="Altavista.com"
+	method="GET"
+	action="http://www.altavista.com/web/results"
+	routeType="The Web"
+>
+
+<INPUT NAME="pg" VALUE="aq">
+<INPUT NAME="aqmode" VALUE="s">
+<INPUT NAME="aqa" USER>
+<INPUT NAME="aqb" VALUE="">
+<INPUT NAME="kgs" VALUE="1">
+<INPUT NAME="kls" VALUE="0">
+<INPUT NAME="dt" VALUE="tmperiod">
+<INPUT NAME="d2" VALUE="0">
+<INPUT NAME="dfr%5Bd%5D" VALUE="1">
+<INPUT NAME="dfr%5Bm%5D" VALUE="1">
+<INPUT NAME="&dfr%5By%5D" VALUE="1980">
+<INPUT NAME="filetype" VALUE="">
+<INPUT NAME="rc" VALUE="dmn">
+<INPUT NAME="swd" VALUE="">
+<INPUT NAME="lh" VALUE="">
+<INPUTNEXT NAME="nbq" FACTOR="0">
+
+<INTERPRET
+resultListStart=""
+resultListEnd=""
+resultItemStart="<br class='lb'>"
+resultItemEnd="&nbsp;<br><br>"
+>
+
+</SEARCH>

Added: trunk/Search/Plugins/AmazonAPI.src
===================================================================
--- trunk/Search/Plugins/AmazonAPI.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/AmazonAPI.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,35 @@
+# Amazon REST API Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="Amazon API"
+	description="Amazon.com REST API"
+	method="GET"
+	action="http://webservices.amazon.com/onca/xml"
+	routeType="Web Services"
+>
+
+<INPUT NAME="Service" VALUE="AWSECommerceService">
+# Edit this field's value to set to your subscription ID
+<INPUT NAME="SubscriptionId" VALUE="">
+<INPUT NAME="Operation" VALUE="ItemSearch">
+<INPUT NAME="SearchIndex" VALUE="Blended">
+<INPUT NAME="Keywords" USER>
+
+<INTERPRET
+resultListStart="<Items>"
+resultListEnd="</Items>"
+resultItemStart="<Item>"
+resultItemEnd="</Item>"
+# The following attributes are specific to Pinot
+resultTitleStart="<Title>"
+resultTitleEnd="</Title>"
+resultLinkStart="<DetailPageURL>"
+resultLinkEnd="</DetailPageURL>"
+resultExtractStart="<ProductGroup>"
+resultExtractEnd="</ProductGroup>"
+>
+
+</SEARCH>
+
+

Added: trunk/Search/Plugins/AskJeeves.src
===================================================================
--- trunk/Search/Plugins/AskJeeves.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/AskJeeves.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,24 @@
+# Ask Jeeves Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="Ask Jeeves"
+	description="Ask.com Ask Jeeves"
+	method="GET"
+	action="http://www.ask.com/web"
+	routeType="The Web"
+>
+
+<INPUT NAME="q" USER>
+<INPUT NAME="qsrc" VALUE="0">
+<INPUT NAME="o" VALUE="0">
+<INPUTNEXT NAME="page" FACTOR="1" VALUE="1">
+
+<INTERPRET
+resultListStart=""
+resultListEnd=""
+resultItemStart='<div class="m10_0_16">'
+resultItemEnd='Save</a>'
+>
+
+</SEARCH>

Added: trunk/Search/Plugins/BitTorrent.src
===================================================================
--- trunk/Search/Plugins/BitTorrent.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/BitTorrent.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,25 @@
+# BitTorrent Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="BitTorrent"
+	description="bittorrent.com"
+	method="GET"
+	action="http://search.bittorrent.com/search.jsp"
+	routeType="Media"
+>
+
+<INPUT NAME="hitsPerPage" VALUE="10">
+<INPUT NAME="hitsPerSite" VALUE="3">
+<INPUT NAME="query" USER>
+<INPUT NAME="Submit2" VALUE="Search">
+<INPUTNEXT NAME="start" FACTOR="10">
+
+<INTERPRET
+resultListStart=''
+resultListEnd=''
+resultItemStart='<span class="titler">'
+resultItemEnd='</span><p><p></div>'
+>
+
+</SEARCH>

Added: trunk/Search/Plugins/Clusty.src
===================================================================
--- trunk/Search/Plugins/Clusty.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Clusty.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,22 @@
+# Clusty Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="Clusty"
+	description="clusty.com"
+	method="GET"
+	action="http://clusty.com/search"
+	routeType="The Web"
+>
+
+<INPUT NAME="query" USER>
+# INPUTNEXT is too complicated :-)
+
+<INTERPRET
+resultListStart=""
+resultListEnd=""
+resultItemStart='<li class="document">'
+resultItemEnd='<div class="document-footer">'
+>
+
+</SEARCH>

Added: trunk/Search/Plugins/Freshmeat.src
===================================================================
--- trunk/Search/Plugins/Freshmeat.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Freshmeat.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,28 @@
+# Freshmeat Search Plugin
+# Based on the work of rcoscali at rcsnet.net
+
+<search 
+   name="Freshmeat"
+   description="Freshmeat Projects Search"
+   method="GET"
+   action="http://freshmeat.net/search/"
+   update="http://www.rcsnet.net/mozilla/freshmeat.src"
+   updateIcon="http://www.rcsnet.net/mozilla/freshmeat.gif"
+   updateCheckDays=7
+   routeType="Software"
+>
+
+<input name="section" value="projects">
+<input name="q" user>
+<inputnext name="offset" factor="25">
+<inputprev name="offset" factor="25">
+
+<interpret 
+    browserResultType="result" 
+    baseUrl="http://freshmeat.net"
+    resultListStart=""
+    resultListEnd=""
+    resultItemStart='<td valign="top">    <b>'
+    resultItemEnd='</small></b></td>    </tr>'
+>
+</search>

Added: trunk/Search/Plugins/Google.src
===================================================================
--- trunk/Search/Plugins/Google.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Google.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,30 @@
+# Mozilla/Google plugin based on amitp+mozilla at google.com's
+
+<search 
+   name="Google"
+   description="Google Search"
+   method="GET"
+   action="http://www.google.com/search"
+   update="http://www.google.com/mozilla/google.src"
+   updateCheckDays=1   
+   queryEncoding="utf-8"
+   queryCharset="utf-8"
+   routeType="The Web"
+>
+
+<input name="q" user>
+<input name="sourceid" value="mozilla">
+<inputnext name="start" factor="10">
+<inputprev name="start" factor="10">
+<input name="ie" value="utf-8">
+<input name="oe" value="utf-8">
+
+<interpret 
+    browserResultType="result" 
+    charset = "UTF-8"
+    resultListStart="<!--a-->" 
+    resultListEnd="<!--z-->" 
+    resultItemStart="<!--m-->" 
+    resultItemEnd="<!--n-->"
+>
+</search>

Added: trunk/Search/Plugins/Koders.src
===================================================================
--- trunk/Search/Plugins/Koders.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Koders.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,25 @@
+# Koders Plugin
+
+<SEARCH
+	version="1.0"
+	name="Koders"
+	description="Koders.com"
+	method="GET"
+	action="http://koders.com/"
+	routeType="Source Code"
+>
+
+<INPUT NAME="s" USER>
+<INPUT NAME="_%3Abtn" VALUE="Search">
+<INPUT NAME="_%3Ala" VALUE="*">
+<INPUT NAME="_%3Ali" VALUE="*">
+<INPUTNEXT NAME="p" FACTOR="1">
+
+<INTERPRET
+resultListStart=""
+resultListEnd=""
+resultItemStart='class="results_header">'
+resultItemEnd='</tr><tr>'
+>
+
+</SEARCH>

Added: trunk/Search/Plugins/Lycos.src
===================================================================
--- trunk/Search/Plugins/Lycos.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Lycos.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,27 @@
+# Lycos Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="Lycos"
+	description="Lycos.com"
+	method="GET"
+	action="http://search.lycos.com/default.asp"
+	routeType="The Web"
+>
+
+<INPUT NAME="loc" VALUE="searchbox">
+<INPUT NAME="tab" VALUE="web">
+<INPUT NAME="adv" VALUE="1">
+<INPUT NAME="wfc" VALUE="3">
+<INPUT NAME="query" USER>
+<INPUT NAME="adf" VALUE="off">
+<INPUTNEXT NAME="first" FACTOR="10" VALUE="1">
+
+<INTERPRET
+resultListStart=""
+resultListEnd=""
+resultItemStart="<!-- IS -->"
+resultItemEnd="<!-- /IS -->"
+>
+
+</SEARCH>

Added: trunk/Search/Plugins/MSN.src
===================================================================
--- trunk/Search/Plugins/MSN.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/MSN.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,25 @@
+# MSN Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="MSN"
+	description="MSN Search"
+	method="GET"
+	action="http://search.msn.com/results.aspx"
+	routeType="The Web"
+>
+
+<INPUT NAME="q" USER>
+<INPUT NAME="FORM" VALUE="QBHP">
+<INPUT NAME="srch_type" VALUE="0">
+<INPUT NAME="count" VALUE="10">
+<INPUTNEXT NAME="first" FACTOR="10">
+
+<INTERPRET
+resultListStart='<h2>Results</h2>'
+resultListEnd='</html>'
+resultItemStart='><h3>'
+resultItemEnd=' </ul></li>'
+>
+
+</SEARCH>

Added: trunk/Search/Plugins/Omega.src
===================================================================
--- trunk/Search/Plugins/Omega.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Omega.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,35 @@
+# Xapian Omega Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="Xapian Omega"
+	description="Xapian Omega"
+	method="GET"
+	action="http://localhost/cgi-bin/omega"
+	routeType="Local Host"
+>
+
+<INPUT NAME="P" USER>
+<INPUT NAME="DEFAULTOP" VALUE="or">
+<INPUT NAME="DB" VALUE="default">
+<INPUT NAME="FMT" VALUE="query">
+<INPUT NAME="FILTERS" VALUE="--O">
+<INPUTNEXT NAME="%5B" FACTOR="1" VALUE="1">
+
+<INTERPRET
+resultListStart="<hits>"
+resultListEnd="</hits>"
+resultItemStart="<TD VALIGN=top>"
+resultItemEnd="</small><P></TD>"
+# The following attributes are specific to Pinot
+#resultTitleStart='title="'
+#resultTitleEnd='"'
+#resultLinkStart='url="'
+#resultLinkEnd='"'
+#resultExtractStart='sample="'
+#resultExtractEnd='"'
+>
+
+</SEARCH>
+
+

Added: trunk/Search/Plugins/Teoma.src
===================================================================
--- trunk/Search/Plugins/Teoma.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Teoma.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,27 @@
+# Teoma Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="Teoma"
+	description="Teoma.com"
+	method="GET"
+	action="http://s.teoma.com/search"
+	routeType="The Web"
+>
+
+<INPUT NAME="q" USER>
+<INPUT NAME="qcat" VALUE="1">
+<INPUT NAME="qsrc" VALUE="0">
+<INPUT NAME="Search.x" VALUE="45">
+<INPUT NAME="Search.y" VALUE="13">
+<INPUT NAME="Search" VALUE="submitve_vt">
+<INPUTNEXT NAME="page" FACTOR="1">
+
+<INTERPRET
+resultListStart=''
+resultListEnd=''
+resultItemStart='<div id="result">'
+resultItemEnd='<br class="resultSpace" />'
+>
+
+</SEARCH>

Added: trunk/Search/Plugins/Topix.src
===================================================================
--- trunk/Search/Plugins/Topix.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Topix.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,23 @@
+# Topix Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="Topix"
+	description="Topix.net"
+	method="GET"
+	action="http://www.topix.net/search/advanced"
+	routeType="News"
+>
+
+<INPUT NAME="q" USER>
+<INPUT NAME="n" VALUE="search">
+<INPUTNEXT NAME="start" FACTOR="1" VALUE="0">
+
+<INTERPRET
+resultListStart=""
+resultListEnd=""
+resultItemStart='<div class=searchres>'
+resultItemEnd='</div> </div>'
+>
+
+</SEARCH>

Added: trunk/Search/Plugins/Wikipedia.src
===================================================================
--- trunk/Search/Plugins/Wikipedia.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Wikipedia.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,24 @@
+# Wikipedia Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="Wikipedia"
+	description="wikipedia.com"
+	method="GET"
+	action="http://en.wikipedia.org/wiki/Special:Search"
+	routeType="Encyclopedia"
+>
+
+<INPUT NAME="search" USER>
+<INPUT NAME="fulltext" VALUE="Search">
+<INPUT NAME="limit" VALUE="10">
+<INPUTNEXT NAME="offset" FACTOR="1">
+
+<INTERPRET
+resultListStart=""
+resultListEnd=""
+resultItemStart='<li style="padding-bottom: 1em;">'
+resultItemEnd='</span></li>'
+>
+
+</SEARCH>

Added: trunk/Search/Plugins/WiseNut.src
===================================================================
--- trunk/Search/Plugins/WiseNut.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/WiseNut.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,23 @@
+# WiseNut Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="WiseNut"
+	description="WiseNut.com"
+	method="GET"
+	action="http://www.wisenut.com/search/query.dll"
+	routeType="The Web"
+>
+
+<INPUT NAME="q" USER>
+<INPUT NAME="c" VALUE="10">
+<INPUTNEXT NAME="p" FACTOR="1">
+
+<INTERPRET
+resultListStart=""
+resultListEnd=""
+resultItemStart="<TD class=m1> <b>"
+resultItemEnd="</TD></TR>"
+>
+
+</SEARCH>

Added: trunk/Search/Plugins/Yahoo.src
===================================================================
--- trunk/Search/Plugins/Yahoo.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/Yahoo.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,31 @@
+# Yahoo! Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="Yahoo!"
+	description="Yahoo.com"
+	method="GET"
+	action="http://search.yahoo.com/search"
+	routeType="The Web"
+>
+
+<INPUT NAME="x" VALUE="op">
+<INPUT NAME="va" USER>
+<INPUT NAME="ve_vt" VALUE="any">
+<INPUT NAME="vst" VALUE="0">
+<INPUT NAME="vd" VALUE="all">
+<INPUT NAME="fl" VALUE="0">
+<INPUT NAME="vf" VALUE="all">
+<INPUT NAME="ei" VALUE="ISO-8859-1">
+<INPUT NAME="vm" VALUE="p">
+<INPUT NAME="n" VALUE="10">
+<INPUTNEXT NAME="b" FACTOR="10" VALUE="1">
+
+<INTERPRET
+resultListStart=""
+resultListEnd=""
+resultItemStart="<li><div>"
+resultItemEnd="</em> "
+>
+
+</SEARCH>

Added: trunk/Search/Plugins/YahooAPI.src
===================================================================
--- trunk/Search/Plugins/YahooAPI.src	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/Plugins/YahooAPI.src	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,33 @@
+# Yahoo! REST API Search Plugin
+
+<SEARCH
+	version="1.0"
+	name="Yahoo! API"
+	description="Yahoo! REST API"
+	method="GET"
+	action="http://api.search.yahoo.com/WebSearchService/V1/webSearch"
+	routeType="Web Services"
+>
+
+# Edit this field's value to set to your application ID
+<INPUT NAME="appid" VALUE="YahooDemo">
+<INPUT NAME="query" USER>
+<INPUT NAME="results" VALUE="10">
+
+<INTERPRET
+resultListStart="<ResultSet"
+resultListEnd="</ResultSet>"
+resultItemStart="<Result>"
+resultItemEnd="</Result>"
+# The following attributes are specific to Pinot
+resultTitleStart="<Title>"
+resultTitleEnd="</Title>"
+resultLinkStart="<Url>"
+resultLinkEnd="</Url>"
+resultExtractStart="<Summary>"
+resultExtractEnd="</Summary>"
+>
+
+</SEARCH>
+
+

Added: trunk/Search/QueryProperties.cpp
===================================================================
--- trunk/Search/QueryProperties.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/QueryProperties.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,302 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+#include <algorithm>
+
+#include "QueryProperties.h"
+
+QueryProperties::QueryProperties()
+{
+	m_resultsCount = 10;
+	m_indexResults = false;
+}
+
+QueryProperties::QueryProperties(string name, string andWords, string phrase, string anyWords, string notWords)
+{
+	m_name = name;
+	m_andWords = andWords;
+	m_phrase = phrase;
+	m_anyWords = anyWords;
+	m_notWords = notWords;
+	m_resultsCount = 10;
+	m_indexResults = false;
+}
+
+QueryProperties::QueryProperties(const QueryProperties &other) :
+	m_name(other.m_name),
+	m_andWords(other.m_andWords),
+	m_phrase(other.m_phrase),
+	m_anyWords(other.m_anyWords),
+	m_notWords(other.m_notWords),
+	m_language(other.m_language),
+	m_hostName(other.m_hostName),
+	m_fileName(other.m_fileName),
+	m_resultsCount(other.m_resultsCount),
+	m_indexResults(other.m_indexResults),
+	m_labelName(other.m_labelName)
+{
+}
+
+QueryProperties::~QueryProperties()
+{
+}
+
+QueryProperties &QueryProperties::operator=(const QueryProperties &other)
+{
+	m_name = other.m_name;
+	m_andWords = other.m_andWords;
+	m_phrase = other.m_phrase;
+	m_anyWords = other.m_anyWords;
+	m_notWords = other.m_notWords;
+	m_language = other.m_language;
+	m_hostName = other.m_hostName;
+	m_fileName = other.m_fileName;
+	m_resultsCount = other.m_resultsCount;
+	m_indexResults = other.m_indexResults;
+	m_labelName = other.m_labelName;
+
+	return *this;
+}
+
+bool QueryProperties::operator==(const QueryProperties &other) const
+{
+	if (m_name == other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+bool QueryProperties::operator<(const QueryProperties &other) const
+{
+	if (m_name < other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+/// Sets the name.
+void QueryProperties::setName(const string &name)
+{
+	m_name = name;
+}
+
+/// Gets the name.
+string QueryProperties::getName(void) const
+{
+	return m_name;
+}
+
+/// Sets AND words.
+void QueryProperties::setAndWords(const string &words)
+{
+	m_andWords = words;
+}
+
+/// Gets AND words.
+string QueryProperties::getAndWords(void) const
+{
+	return m_andWords;
+}
+
+/// Sets phrase query.
+void QueryProperties::setPhrase(const string &phrase)
+{
+	m_phrase = phrase;
+}
+
+/// Gets phrase query.
+string QueryProperties::getPhrase(void) const
+{
+	return m_phrase;
+}
+
+/// Sets ANY words.
+void QueryProperties::setAnyWords(const string &words)
+{
+	m_anyWords = words;
+}
+
+/// Gets ANY words.
+string QueryProperties::getAnyWords(void) const
+{
+	return m_anyWords;
+}
+
+/// Sets NOT words.
+void QueryProperties::setNotWords(const string &words)
+{
+	m_notWords = words;
+}
+
+/// Gets NOT words.
+string QueryProperties::getNotWords(void) const
+{
+	return m_notWords;
+}
+
+/// Sets the query's language.
+void QueryProperties::setLanguage(const string &language)
+{
+	m_language = language;
+}
+
+/// Gets the query's language.
+string QueryProperties::getLanguage(void) const
+{
+	return m_language;
+}
+
+/// Sets host name filter.
+void QueryProperties::setHostNameFilter(const string &filter)
+{
+	m_hostName = filter;
+}
+
+/// Gets host name filter.
+string QueryProperties::getHostNameFilter(void) const
+{
+	return 	m_hostName;
+}
+
+/// Sets file name filter.
+void QueryProperties::setFileNameFilter(const string &filter)
+{
+	m_fileName = filter;
+}
+
+/// Gets file name filter.
+string QueryProperties::getFileNameFilter(void) const
+{
+	return m_fileName;
+}
+
+/// Sets the maximum number of results.
+void QueryProperties::setMaximumResultsCount(unsigned int count)
+{
+	m_resultsCount = count;
+}
+
+/// Gets the maximum number of results.
+unsigned int QueryProperties::getMaximumResultsCount(void) const
+{
+	return m_resultsCount;
+}
+
+/// Sets whether results should be indexed.
+void QueryProperties::setIndexResults(bool index)
+{
+	m_indexResults = index;
+}
+
+/// Gets whether results should be indexed
+bool QueryProperties::getIndexResults(void) const
+{
+	return m_indexResults;
+}
+
+/// Sets the name of the label to use for indexed documents.
+void QueryProperties::setLabelName(const string &labelName)
+{
+	m_labelName = labelName;
+}
+
+/// Gets the name of the label to use for indexed documents.
+string QueryProperties::getLabelName(void) const
+{
+	return m_labelName;
+}
+
+/// Returns a displayable representation of this query's properties.
+string QueryProperties::toString(bool forPresentation) const
+{
+	string queryString;
+	if (m_andWords.empty() == false)
+	{
+		string tmp = m_andWords;
+		replace(tmp.begin(), tmp.end(), ' ', '+');
+		queryString += tmp;
+	}
+	if (m_anyWords.empty() == false)
+	{
+		if (forPresentation == true)
+		{
+			string tmp = m_anyWords;
+			replace(tmp.begin(), tmp.end(), ' ', '|');
+			queryString += " +(";
+			queryString += tmp;
+			queryString += ")";
+		}
+		else
+		{
+			string tmp = m_anyWords;
+			// FIXME: is this good enough ?
+			replace(tmp.begin(), tmp.end(), ' ', '+');
+			if (queryString.empty() == false)
+			{
+				queryString += "+";
+			}
+			queryString += tmp;
+		}
+	}
+	if (m_notWords.empty() == false)
+	{
+		string tmp = m_notWords;
+		replace(tmp.begin(), tmp.end(), ' ', '-');
+		if (queryString.empty() == false)
+		{
+			queryString += "-";
+		}
+		queryString += tmp;
+		queryString += " ";
+	}
+	if (m_phrase.empty() == false)
+	{
+		string tmp = m_phrase;
+		replace(tmp.begin(), tmp.end(), ' ', '+');
+		if (queryString.empty() == false)
+		{
+			queryString += "+";
+		}
+		queryString += "\"";
+		queryString += tmp;
+		queryString += "\"";
+	}
+	if (forPresentation == true)
+	{
+		if (m_language.empty() == false)
+		{
+			queryString += " +L";
+			queryString += m_language;
+		}
+		if (m_hostName.empty() == false)
+		{
+			queryString += " +H";
+			queryString += m_hostName;
+		}
+		if (m_fileName.empty() == false)
+		{
+			queryString += " +F";
+			queryString += m_fileName;
+		}
+	}
+
+	return queryString;
+}

Added: trunk/Search/QueryProperties.h
===================================================================
--- trunk/Search/QueryProperties.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/QueryProperties.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,111 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _QUERY_PROPERTIES_H
+#define _QUERY_PROPERTIES_H
+
+#include <string>
+
+#include "Result.h"
+
+using namespace std;
+
+class QueryProperties
+{
+	public:
+		QueryProperties();
+		QueryProperties(string name, string andWords, string phrase, string anyWords, string notWords);
+		QueryProperties(const QueryProperties &other);
+		~QueryProperties();
+
+		QueryProperties &operator=(const QueryProperties &other);
+		bool operator==(const QueryProperties &other) const;
+		bool operator<(const QueryProperties &other) const;
+
+		/// Sets the name.
+		void setName(const string &name);
+		/// Gets the name.
+		string getName(void) const;
+
+		/// Sets AND words.
+		void setAndWords(const string &words);
+		/// Gets AND words.
+		string getAndWords(void) const;
+
+		/// Sets phrase query.
+		void setPhrase(const string &phrase);
+		/// Gets phrase query.
+		string getPhrase(void) const;
+
+		/// Sets ANY words.
+		void setAnyWords(const string &words);
+		/// Gets ANY words.
+		string getAnyWords(void) const;
+
+		/// Sets NOT words.
+		void setNotWords(const string &words);
+		/// Gets NOT words.
+		string getNotWords(void) const;
+
+		/// Sets the query's language.
+		void setLanguage(const string &language);
+		/// Gets the query's language.
+		string getLanguage(void) const;
+
+		/// Sets host name filter.
+		void setHostNameFilter(const string &filter);
+		/// Gets host name filter.
+		string getHostNameFilter(void) const;
+
+		/// Sets file name filter.
+		void setFileNameFilter(const string &filter);
+		/// Gets file name filter.
+		string getFileNameFilter(void) const;
+
+		/// Sets the maximum number of results.
+		void setMaximumResultsCount(unsigned int count);
+		/// Gets the maximum number of results.
+		unsigned int getMaximumResultsCount(void) const;
+
+		/// Sets whether results should be indexed.
+		void setIndexResults(bool index);
+		/// Gets whether results should be indexed
+		bool getIndexResults(void) const;
+
+		/// Sets the name of the label to use for indexed documents.
+		void setLabelName(const string &labelName);
+		/// Gets the name of the label to use for indexed documents.
+		string getLabelName(void) const;
+
+		/// Returns a displayable representation of this query's properties.
+		string toString(bool forPresentation = true) const;
+
+	protected:
+		string m_name;
+		string m_andWords;
+		string m_phrase;
+		string m_anyWords;
+		string m_notWords;
+		string m_language;
+		string m_hostName;
+		string m_fileName;
+		unsigned int m_resultsCount;
+		bool m_indexResults;
+		string m_labelName;
+
+};
+
+#endif // _QUERY_PROPERTIES_H

Added: trunk/Search/SOAPEnvNS.cpp
===================================================================
--- trunk/Search/SOAPEnvNS.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/SOAPEnvNS.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1 @@
+struct Namespace *namespaces;

Added: trunk/Search/SearchEngineFactory.cpp
===================================================================
--- trunk/Search/SearchEngineFactory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/SearchEngineFactory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,83 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAS_GOOGLEAPI
+#include "GoogleAPIEngine.h"
+#endif
+#ifdef HAS_OSAPI
+#include "ObjectsSearchAPIEngine.h"
+#endif
+#include "PluginWebEngine.h"
+#include "XapianEngine.h"
+#include "SearchEngineFactory.h"
+
+SearchEngineFactory::SearchEngineFactory()
+{
+}
+
+SearchEngineFactory::~SearchEngineFactory()
+{
+}
+
+/// Returns a SearchEngine of the specified type; NULL if unavailable.
+SearchEngineInterface *SearchEngineFactory::getSearchEngine(const string &type, const string &option)
+{
+	SearchEngineInterface *myEngine = NULL;
+
+	// Choice by type
+	if (type == "sherlock")
+	{
+		myEngine = new PluginWebEngine(option);
+	}
+	else if (type == "xapian")
+	{
+		myEngine = new XapianEngine(option);
+	}
+#ifdef HAS_GOOGLEAPI
+	else if (type == "googleapi")
+	{
+		myEngine = new GoogleAPIEngine();
+		myEngine->setKey(option);
+	}
+#endif
+#ifdef HAS_OSAPI
+	else if (type == "objectssearchapi")
+	{
+		myEngine = new ObjectsSearchAPIEngine();
+	}
+#endif
+
+	return myEngine;
+}
+
+/// Indicates whether a search engine is supported or not.
+bool SearchEngineFactory::isSupported(const string &type)
+{
+	if (
+#ifdef HAS_GOOGLEAPI
+		(type == "googleapi") ||
+#endif
+#ifdef HAS_OSAPI
+		(type == "objectssearchapi") ||
+#endif
+		(type == "sherlock") ||
+		(type == "xapian"))
+	{
+		return true;
+	}
+
+	return false;	
+}


Property changes on: trunk/Search/SearchEngineFactory.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/SearchEngineFactory.h
===================================================================
--- trunk/Search/SearchEngineFactory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/SearchEngineFactory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,50 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _SEARCHENGINE_FACTORY_H
+#define _SEARCHENGINE_FACTORY_H
+
+#include <string>
+#include <map>
+#include <set>
+
+#include "SearchEngineInterface.h"
+
+using std::string;
+using std::map;
+using std::set;
+
+class SearchEngineFactory
+{
+	public:
+		virtual ~SearchEngineFactory();
+
+		/// Returns a SearchEngine of the specified type; NULL if unavailable.
+		static SearchEngineInterface *getSearchEngine(const string &type, const string &option);
+
+		/// Indicates whether a search engine is supported or not.
+		static bool isSupported(const string &type);
+
+	protected:
+		SearchEngineFactory();
+
+	private:
+		SearchEngineFactory(const SearchEngineFactory &other);
+		SearchEngineFactory &operator=(const SearchEngineFactory &other);
+
+};
+
+#endif // _SEARCHENGINE_FACTORY_H


Property changes on: trunk/Search/SearchEngineFactory.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/SearchEngineInterface.cpp
===================================================================
--- trunk/Search/SearchEngineInterface.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/SearchEngineInterface.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,121 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+
+#include "Url.h"
+#include "SearchEngineInterface.h"
+
+using std::cout;
+using std::endl;
+
+SearchEngineInterface::SearchEngineInterface() :
+	m_callsCount(0),
+	m_startTime(time(NULL)),
+	m_maxResultsCount(10)
+{
+}
+
+SearchEngineInterface::~SearchEngineInterface()
+{
+}
+
+/// Indicates if the search engine is available in several languages/countries.
+bool SearchEngineInterface::isInternational(void) const
+{
+	return false;
+}
+
+/// Sets the search engine's key, if applicable.
+void SearchEngineInterface::setKey(const string &key)
+{
+	m_key = key;
+}
+
+/// Sets the number of calls issued since start time.
+void SearchEngineInterface::setCallsCount(unsigned int count, time_t startTime)
+{
+	m_callsCount = count;
+	m_startTime = startTime;
+}
+
+/// Sets the maximum number of results to return.
+void SearchEngineInterface::setMaxResultsCount(unsigned int count)
+{
+	m_maxResultsCount = count;
+}
+
+/// Returns the results for the previous query.
+const vector<Result> &SearchEngineInterface::getResults(void) const
+{
+	return m_resultsList;
+}
+
+void SearchEngineInterface::setHostNameFilter(const string &filter)
+{
+	m_hostFilter = filter;
+}
+
+void SearchEngineInterface::setFileNameFilter(const string &filter)
+{
+	m_fileFilter = filter;
+}
+
+bool SearchEngineInterface::processResult(string &resultUrl)
+{
+	Url urlObj(resultUrl);
+
+	if ((m_hostFilter.empty() == false) &&
+		(urlObj.getHost() != m_hostFilter))
+	{
+#ifdef DEBUG
+		cout << "SearchEngineInterface::processResult: skipping " << resultUrl << endl;
+#endif
+		return false;
+	}
+
+	if ((m_fileFilter.empty() == false) &&
+		(urlObj.getFile() != m_fileFilter))
+	{
+#ifdef DEBUG
+		cout << "SearchEngineInterface::processResult: skipping " << resultUrl << endl;
+#endif
+		return false;
+	}
+
+	// Remove trailing spaces at the end of the URL
+	string trimmedUrl = resultUrl;
+	string::size_type pos = trimmedUrl.find_last_of(" ");
+	while (pos != string::npos)
+	{
+		int len = trimmedUrl.length();
+#ifdef DEBUG
+		cout << "SearchEngineInterface::processResult: trimming space at " << pos << endl;
+#endif
+		if (pos == len - 1)
+		{
+			trimmedUrl.resize(pos);
+			pos = trimmedUrl.find_last_of(" ");
+		}
+		else
+		{
+			break;
+		}
+	}
+	resultUrl = Url::canonicalizeUrl(trimmedUrl);
+
+	return true;
+}


Property changes on: trunk/Search/SearchEngineInterface.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/SearchEngineInterface.h
===================================================================
--- trunk/Search/SearchEngineInterface.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/SearchEngineInterface.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,74 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _SEARCHENGINE_INTERFACE_H
+#define _SEARCHENGINE_INTERFACE_H
+
+#include <time.h>
+#include <string>
+#include <vector>
+
+#include "QueryProperties.h"
+#include "Result.h"
+
+using namespace std;
+
+/**
+  * Interface implemented by search engines.
+  */
+class SearchEngineInterface
+{
+	public:
+		virtual ~SearchEngineInterface();
+
+		/// Indicates if the search engine is available in several languages/countries.
+		virtual bool isInternational(void) const;
+
+		/// Sets the search engine's key, if applicable.
+		virtual void setKey(const string &key);
+
+		/// Sets the number of calls issued since start time.
+		virtual void setCallsCount(unsigned int count, time_t startTime);
+
+		/// Sets the maximum number of results to return.
+		virtual void setMaxResultsCount(unsigned int count);
+
+		/// Runs a query; true if success.
+		virtual bool runQuery(QueryProperties& queryProps) = 0;
+
+		/// Returns the results for the previous query.
+		virtual const vector<Result> &getResults(void) const;
+
+	protected:
+		string m_key;
+		unsigned int m_callsCount;
+		time_t m_startTime;
+		unsigned int m_maxResultsCount;
+		string m_hostFilter;
+		string m_fileFilter;
+		vector<Result> m_resultsList;
+
+		SearchEngineInterface();
+
+		void setHostNameFilter(const string &filter);
+
+		void setFileNameFilter(const string &filter);
+
+		virtual bool processResult(string &resultUrl);
+
+};
+
+#endif // _SEARCHENGINE_INTERFACE_H


Property changes on: trunk/Search/SearchEngineInterface.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/WebEngine.cpp
===================================================================
--- trunk/Search/WebEngine.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/WebEngine.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,51 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <string.h>
+#include <sys/types.h>
+#include <regex.h>
+#include <iostream>
+#include <algorithm>
+
+#include "HtmlTokenizer.h"
+#include "Url.h"
+#include "DownloaderFactory.h"
+#include "WebEngine.h"
+
+WebEngine::WebEngine() :
+	SearchEngineInterface()
+{
+}
+
+WebEngine::~WebEngine()
+{
+	m_resultsList.clear();
+}
+
+Document *WebEngine::downloadPage(const DocumentInfo &docInfo)
+{
+	// Any type of downloader will do...
+	DownloaderInterface *myDownloader = DownloaderFactory::getDownloader("http", "");
+	if (myDownloader == NULL)
+	{
+		return NULL;
+	}
+
+	Document *urlDoc = myDownloader->retrieveUrl(docInfo);
+	delete myDownloader;
+
+	return urlDoc;
+}

Added: trunk/Search/WebEngine.h
===================================================================
--- trunk/Search/WebEngine.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/WebEngine.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,46 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _WEB_ENGINE_H
+#define _WEB_ENGINE_H
+
+#include <string>
+#include <set>
+
+#include "SearchEngineInterface.h"
+#include "Document.h"
+
+using namespace std;
+
+class WebEngine : public SearchEngineInterface
+{
+	public:
+		WebEngine();
+		virtual ~WebEngine();
+
+	protected:
+		string m_hostFilter;
+		string m_fileFilter;
+
+		Document *downloadPage(const DocumentInfo &docInfo);
+
+	private:
+		WebEngine(const WebEngine &other);
+		WebEngine &operator=(const WebEngine &other);
+
+};
+
+#endif // _WEB_ENGINE_H

Added: trunk/Search/XapianEngine.cpp
===================================================================
--- trunk/Search/XapianEngine.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/XapianEngine.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,430 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <string>
+#include <vector>
+#include <iostream>
+
+#include "StringManip.h"
+#include "Tokenizer.h"
+#include "Url.h"
+#include "XapianDatabaseFactory.h"
+#include "XapianEngine.h"
+
+using std::string;
+using std::vector;
+using std::stack;
+using std::cout;
+using std::cerr;
+using std::endl;
+
+static bool extractWords(const string &text, const string &language, vector<string> &wordsList)
+{
+	Xapian::Stem *pStemmer = NULL;
+
+	if (text.empty() == true)
+	{
+		return false;
+	}
+
+	if (language.empty() == false)
+	{
+		pStemmer = new Xapian::Stem(StringManip::toLowerCase(language));
+	}
+
+	Document doc;
+	doc.setData(text.c_str(), text.length());
+	Tokenizer tokens(&doc);
+
+	string token;
+	while (tokens.nextToken(token) == true)
+	{
+		string term = token;
+
+		// Lower case the term
+		term = StringManip::toLowerCase(term);
+		// Stem it ?
+		if (pStemmer != NULL)
+		{
+			string stemmedTerm = pStemmer->stem_word(term);
+			wordsList.push_back(stemmedTerm);
+		}
+		else
+		{
+			wordsList.push_back(term);
+		}
+	}
+
+	if (pStemmer != NULL)
+	{
+		delete pStemmer;
+	}
+
+	return true;
+}
+
+XapianEngine::XapianEngine(const string &database) :
+	SearchEngineInterface()
+{
+	// If the database name ends with a slash, remove it
+	if (database[database.length() - 1] == '/')
+	{
+		m_databaseName = database.substr(0, database.length() - 1);
+	}
+	else
+	{
+		m_databaseName = database;
+	}
+
+	// SearchEngineInterface members
+	m_maxResultsCount = 10;
+	m_resultsList.clear();
+}
+
+XapianEngine::~XapianEngine()
+{
+	m_resultsList.clear();
+}
+
+bool XapianEngine::queryDatabase(Xapian::Query &query)
+{
+	bool bStatus = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, true);
+	if (pDatabase == NULL)
+	{
+		return false;
+	}
+
+	Xapian::Database *pIndex = pDatabase->readLock();
+	if (pIndex != NULL)
+	{
+		try
+		{
+			// Start an enquire session on the database
+			Xapian::Enquire enquire(*pIndex);
+
+			// Give the query object to the enquire session
+			enquire.set_query(query);
+
+			// Get the top N results of the query
+			Xapian::MSet matches = enquire.get_mset(0, m_maxResultsCount);
+
+			// Get the results
+#ifdef DEBUG
+			cout << "XapianEngine::queryDatabase: " << matches.get_matches_estimated() << "/" << m_maxResultsCount << " results found" << endl;
+#endif
+			for (Xapian::MSetIterator i = matches.begin(); i != matches.end(); ++i)
+			{
+				// Get the document data
+				string record = i.get_document().get_data();
+
+				// Get the title
+				string title = StringManip::extractField(record, "caption=", "\n");
+#ifdef DEBUG
+				cout << "XapianEngine::queryDatabase: found omindex title " << title << endl;
+#endif
+				// Get the URL
+				string url = StringManip::extractField(record, "url=", "\n");
+				if (url.empty() == true)
+				{
+					// Hmmm this shouldn't be empty...
+					// Use this instead, even though the document isn't cached in the index
+					url = buildUrl(m_databaseName, *i);
+				}
+				else
+				{
+#ifdef DEBUG
+					cout << "XapianEngine::queryDatabase: found omindex URL " << url << endl;
+#endif
+					url = Url::canonicalizeUrl(url);
+				}
+
+				// Get the summary and the type
+				string summary = StringManip::extractField(record, "sample=", "\n");
+#ifdef DEBUG
+				cout << "XapianEngine::queryDatabase: found omindex summary " << summary << endl;
+#endif
+				string type = StringManip::extractField(record, "type=", "\n");
+				// ...and finally the language, if available
+				string language = StringManip::extractField(record, "language=", "\n");
+
+				// Add this result
+				Result thisResult(url, title, summary, language, (float)i.get_percent());
+				m_resultsList.push_back(thisResult);
+			}
+
+			bStatus = true;
+		}
+		catch (const Xapian::Error &error)
+		{
+			cout << "XapianEngine::queryDatabase: couldn't run query: "  << error.get_msg() << endl;
+		}
+	}
+	pDatabase->unlock();
+
+	return bStatus;
+}
+
+void XapianEngine::stackQuery(const QueryProperties &queryProps,
+	stack<Xapian::Query> &queryStack, bool followOperators)
+{
+	string language = queryProps.getLanguage();
+	Xapian::Query::op queryOp = Xapian::Query::OP_OR;
+	string term;
+
+	// Get the terms to AND together
+	if (queryProps.getAndWords().empty() == false)
+	{
+		vector<string> andTerms;
+
+		if (extractWords(queryProps.getAndWords(), language, andTerms) == true)
+		{
+#ifdef DEBUG
+			cout << "XapianEngine::stackQuery: OP_AND "  << andTerms.size() << endl;
+#endif
+			if (followOperators == true)
+			{
+				queryOp = Xapian::Query::OP_AND;
+			}
+			queryStack.push(Xapian::Query(queryOp, andTerms.begin(), andTerms.end()));
+		}
+	}
+
+	// Get the terms of the phrase
+	if (queryProps.getPhrase().empty() == false)
+	{
+		vector<string> phraseTerms;
+
+		if (extractWords(queryProps.getPhrase(), language, phraseTerms) == true)
+		{
+#ifdef DEBUG
+			cout << "XapianEngine::stackQuery: OP_PHRASE "  << phraseTerms.size() << endl;
+#endif
+			if (followOperators == true)
+			{
+				queryOp = Xapian::Query::OP_PHRASE;
+			}
+			queryStack.push(Xapian::Query(queryOp, phraseTerms.begin(), phraseTerms.end()));
+		}
+	}
+
+	// Get the terms to OR together
+	if (queryProps.getAnyWords().empty() == false)
+	{
+		vector<string> orTerms;
+
+		if (extractWords(queryProps.getAnyWords(), language, orTerms) == true)
+		{
+#ifdef DEBUG
+			cout << "XapianEngine::stackQuery: OP_OR "  << orTerms.size() << endl;
+#endif
+			if (followOperators == true)
+			{
+				queryOp = Xapian::Query::OP_OR;
+			}
+			queryStack.push(Xapian::Query(queryOp, orTerms.begin(), orTerms.end()));
+		}
+	}
+
+	// Get the terms to NOT together
+	if (queryProps.getNotWords().empty() == false)
+	{
+		vector<string> notTerms;
+
+		if (extractWords(queryProps.getNotWords(), language, notTerms) == true)
+		{
+#ifdef DEBUG
+			cout << "XapianEngine::stackQuery: OP_AND_NOT "  << notTerms.size() << endl;
+#endif
+			// An AND_NOT has to have two sub-queries
+			if (followOperators == true)
+			{
+				queryOp = Xapian::Query::OP_AND;
+			}
+			Xapian::Query notQuery(queryOp, notTerms.begin(), notTerms.end());
+			// We need something to AND_NOT these terms against
+			if (queryStack.empty() == false)
+			{
+				Xapian::Query topQuery = queryStack.top();
+				queryStack.pop();
+				if (followOperators == true)
+				{
+					queryOp = Xapian::Query::OP_AND_NOT;
+				}
+				queryStack.push(Xapian::Query(queryOp, topQuery, notQuery));
+			}
+		}
+	}
+
+	// Get the host name filter
+	if (queryProps.getHostNameFilter().empty() == false)
+	{
+		vector<string> hostTerms;
+
+		term = "H";
+		term += StringManip::toLowerCase(queryProps.getHostNameFilter());
+		hostTerms.push_back(term);
+		if (followOperators == true)
+		{
+			queryOp = Xapian::Query::OP_AND;
+		}
+		queryStack.push(Xapian::Query(queryOp, hostTerms.begin(), hostTerms.end()));
+	}
+
+	// Get the file name filter
+	if (queryProps.getFileNameFilter().empty() == false)
+	{
+		vector<string> fileTerms;
+
+		term = "F";
+		term += StringManip::toLowerCase(queryProps.getFileNameFilter());
+		fileTerms.push_back(term);
+		if (followOperators == true)
+		{
+			queryOp = Xapian::Query::OP_AND;
+		}
+		queryStack.push(Xapian::Query(queryOp, fileTerms.begin(), fileTerms.end()));
+	}
+
+	// Get the language filter
+	if (queryProps.getLanguage().empty() == false)
+	{
+		vector<string> languageTerms;
+
+		term = "L";
+		term += StringManip::toLowerCase(queryProps.getLanguage());
+		languageTerms.push_back(term);
+		if (followOperators == true)
+		{
+			queryOp = Xapian::Query::OP_AND;
+		}
+		queryStack.push(Xapian::Query(queryOp, languageTerms.begin(), languageTerms.end()));
+	}
+}
+
+/// Returns the URL for the given document in the given index.
+string XapianEngine::buildUrl(const string &database, unsigned int docId)
+{
+	// Make up a pseudo URL
+	char docIdStr[64];
+	sprintf(docIdStr, "%u", docId);
+	string url = "xapian://localhost/";
+	url += database;
+	url += "/";
+	url += docIdStr;
+
+	return url;
+}
+
+/// Runs a boolean query; true if success.
+bool XapianEngine::runQuery(const string &keyword)
+{
+	// Clear the results list
+	m_resultsList.clear();
+
+	try
+	{
+		vector<string> keywordTerms;
+		keywordTerms.push_back(keyword);
+		Xapian::Query keyworkQuery(Xapian::Query::OP_AND, keywordTerms.begin(), keywordTerms.end());
+
+		// Query the database with the full query
+		return queryDatabase(keyworkQuery);
+	}
+	catch (const Xapian::Error &error)
+	{
+		cout << "XapianEngine::runQuery: couldn't run query: "  << error.get_msg() << endl;
+	}
+
+	return false;
+}
+
+//
+// Implementation of SearchEngineInterface
+//
+
+/// Runs a query; true if success.
+bool XapianEngine::runQuery(QueryProperties& queryProps)
+{
+	// Clear the results list
+	m_resultsList.clear();
+
+	try
+	{
+		stack<Xapian::Query> queryStack;
+		bool followOperators = true;
+
+		stackQuery(queryProps, queryStack, followOperators);
+		while (queryStack.empty() == false)
+		{
+			while (queryStack.size() > 1)
+			{
+				Xapian::Query topQuery = queryStack.top();
+				queryStack.pop();
+#ifdef DEBUG
+				cout << "XapianEngine::runQuery: popped query, left "  << queryStack.size() << endl;
+#endif
+				Xapian::Query query = Xapian::Query(Xapian::Query::OP_AND, queryStack.top(), topQuery);
+				queryStack.pop();
+#ifdef DEBUG
+				cout << "XapianEngine::runQuery: popped query, left "  << queryStack.size() << endl;
+#endif
+				queryStack.push(query);
+			}
+
+			// Query the database with the full query
+			if (queryDatabase(queryStack.top()) == true)
+			{
+#if 0
+				if ((m_resultsList.empty() == true) &&
+					(followOperators == true))
+				{
+					// The search did succeed but didn't return anything
+					// Try again by OR'ing terms together
+					while (queryStack.empty() == false)
+					{
+						queryStack.pop();
+					}
+					followOperators = false;
+#ifdef DEBUG
+					cout << "XapianEngine::runQuery: trying with OR'ed terms" << endl;
+#endif
+					stackQuery(queryProps, queryStack, followOperators);
+					continue;
+				}
+#endif
+
+				return true;
+			}
+		}
+	}
+	catch (const Xapian::Error &error)
+	{
+		cout << "XapianEngine::runQuery: couldn't run query: "  << error.get_msg() << endl;
+	}
+
+	return false;
+}
+
+/// Returns the results for the previous query.
+const vector<Result> &XapianEngine::getResults(void) const
+{
+	return m_resultsList;
+}


Property changes on: trunk/Search/XapianEngine.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/XapianEngine.h
===================================================================
--- trunk/Search/XapianEngine.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/XapianEngine.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,61 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XAPIAN_ENGINE_H
+#define _XAPIAN_ENGINE_H
+
+#include <string>
+#include <vector>
+#include <stack>
+
+#include <xapian.h>
+
+#include "SearchEngineInterface.h"
+#include "DownloaderFactory.h"
+
+class XapianEngine : public SearchEngineInterface
+{
+	public:
+		XapianEngine(const std::string &database);
+		virtual ~XapianEngine();
+
+		/// Runs a boolean query; true if success.
+		virtual bool runQuery(const std::string &keyword);
+
+		/// Runs a query; true if success.
+		virtual bool runQuery(QueryProperties& queryProps);
+
+		/// Returns the results for the previous query.
+		virtual const std::vector<Result> &getResults(void) const;
+
+		/// Returns the URL for the given document in the given index.
+		static std::string buildUrl(const std::string &database, unsigned int docId);
+
+	protected:
+		std::string m_databaseName;
+
+		bool queryDatabase(Xapian::Query &query);
+
+		void stackQuery(const QueryProperties &queryProps,
+			std::stack<Xapian::Query> &queryStack, bool followOperators);
+
+	private:
+		XapianEngine(const XapianEngine &other);
+		XapianEngine &operator=(const XapianEngine &other);
+
+};
+
+#endif // _XAPIAN_ENGINE_H


Property changes on: trunk/Search/XapianEngine.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Search/senginetest.cpp
===================================================================
--- trunk/Search/senginetest.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Search/senginetest.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,198 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <cstdlib>
+#include <cstdio>
+#include <iostream>
+#include <string>
+#include <fstream>
+
+#include "SearchEngineFactory.h"
+#ifdef HAS_GOOGLEAPI
+#include "GoogleAPIEngine.h"
+#endif
+#include "DownloaderFactory.h"
+#include "Url.h"
+#include "HtmlTokenizer.h"
+
+using namespace std;
+
+static void fetchCachedPage(const string &url, const string &file, const string &key)
+{
+#ifdef DEBUG
+	cout << "fetchCachedPage: attempting to save " << url << " to " << file << endl;
+#endif
+
+#ifdef HAS_GOOGLEAPI
+	Url thisUrl(url);
+	GoogleAPIEngine googleApiEngine;
+	googleApiEngine.setKey(key);
+
+	Document *urlDoc = googleApiEngine.retrieveCachedUrl(url);
+	if (urlDoc != NULL)
+	{
+		unsigned int urlContentLen;
+		ofstream outputFile;
+		outputFile.open(file.c_str(), ofstream::out | ofstream::trunc);
+		outputFile << urlDoc->getData(urlContentLen);
+		outputFile.close();
+
+		delete urlDoc;
+	}
+	else
+	{
+		cerr << "fetchCachedPage: couldn't get " << url << " !" << endl;
+	}
+#endif
+}
+
+static void fetchPage(const string &url, const string &file)
+{
+#ifdef DEBUG
+	cout << "fetchPage: attempting to save " << url << " to " << file << endl;
+#endif
+
+	// Any type of downloader will do...
+	Url thisUrl(url);
+	DownloaderInterface *myDownloader = DownloaderFactory::getDownloader(thisUrl.getProtocol(), "");
+	if (myDownloader == NULL)
+	{
+		cerr << "fetchPage: couldn't obtain downloader instance (" << thisUrl.getProtocol() << ")" << endl;
+		return;
+	}
+
+	DocumentInfo docInfo("Page", url, "", "");
+	Document *urlDoc = myDownloader->retrieveUrl(docInfo);
+	if (urlDoc != NULL)
+	{
+		unsigned int urlContentLen;
+		ofstream outputFile;
+		outputFile.open(file.c_str(), ofstream::out | ofstream::trunc);
+		outputFile << urlDoc->getData(urlContentLen);
+		outputFile.close();
+
+		delete urlDoc;
+	}
+	else
+	{
+		cerr << "fetchPage: couldn't get " << url << " !" << endl;
+	}
+
+	delete myDownloader;
+}
+
+int main(int argc, char **argv)
+{
+	string type, option;
+	bool bDownloadResults = false;
+
+	if (argc < 5)
+	{
+		cerr << "Usage: " << argv[0] << " <search engine name> <option> <search string> <max results> [DOWNLOAD]" << endl;
+		return EXIT_FAILURE;
+	}
+	if (argc > 5)
+	{
+		string flag = argv[5];
+		if (flag == "DOWNLOAD")
+		{
+			bDownloadResults = true;
+		}
+	}
+
+	// Which SearchEngine ?
+	type = argv[1];
+	option = argv[2];
+	SearchEngineInterface *myEngine = SearchEngineFactory::getSearchEngine(type, option);
+	if (myEngine == NULL)
+	{
+		cerr << "Couldn't obtain search engine instance" << endl;
+		return EXIT_FAILURE;
+	}
+
+	// How many results ?
+	unsigned int count = atoi(argv[4]);
+	myEngine->setMaxResultsCount(count);
+
+	QueryProperties queryProps("senginetest", argv[3], "", "", "");
+	bool bOK = myEngine->runQuery(queryProps);
+	if (bOK == true)
+	{
+		string resultsPage;
+
+		// Try getting a list of links
+		const vector<Result> resultsList = myEngine->getResults();
+		if (resultsList.empty() == false)
+		{
+			unsigned int count = 0;
+
+			cout << "Matching documents are :" << endl;
+
+			vector<Result>::const_iterator resultIter = resultsList.begin();
+			while (resultIter != resultsList.end())
+			{
+				string rawUrl = (*resultIter).getLocation();
+				Url thisUrl(rawUrl);
+
+				cout << count << " Raw URL  : '" << rawUrl << "'"<< endl;
+				cout << count << " Protocol : " << thisUrl.getProtocol() << endl;
+				cout << count << " Host     : " << thisUrl.getHost() << endl;
+				cout << count << " Location : " << thisUrl.getLocation() << "/" << thisUrl.getFile() << endl;
+				cout << count << " Title    : " << HtmlTokenizer::stripTags((*resultIter).getTitle()) << endl;
+				cout << count << " Extract  : " << HtmlTokenizer::stripTags((*resultIter).getExtract()) << endl;
+				cout << count << " Score    : " << (*resultIter).getScore() << endl;
+
+				if (bDownloadResults == true)
+				{
+					// Set the name of the file to which this page will be saved
+					char num[16];
+					sprintf(num, "%d", count);
+					string url = (*resultIter).getLocation();
+					string file = num;
+					file += "_";
+					file += thisUrl.getHost();
+					file += ".html";
+
+					if (type == "googleapi")
+					{
+						// Fetch the page from the Google cache
+						fetchCachedPage(url, file, option);
+					}
+					else
+					{
+						fetchPage(url, file);
+					}
+				}
+				count++;
+
+				// Next
+				resultIter++;
+			}
+		}
+		else
+		{
+			cerr << "Couldn't get a results list !" << endl;
+		}
+	}
+	else
+	{
+		cerr << "Couldn't run query on search engine " << argv[1] << endl;
+	}
+
+	delete myEngine;
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/Search/senginetest.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/TODO
===================================================================
--- trunk/TODO	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/TODO	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,99 @@
+General
+- Fix dependencies in build system, use autoconf and friends
+- Fix the FIXMEs
+- Get rid of dead code/classes/methods...
+- Advertise service via Rendezvous with Howl (http://www.porchdogsoft.com/products/howl/)
+- Remove hardcoded paths
+- Man page, see help2man (http://www.gnu.org/software/help2man/)
+- Logging should not be all (DEBUG) or nothing (release)
+- Check for leaks with valgrind (eg --tool=memcheck -v --leak-check=yes --show-reachable=yes ...)
+- Change .spec to allow building with Google and ObjectsSearch SOAP APIs support
+- Don't use system(), fork and exec, especially for the external browser
+
+Search
+- Write a Spirit-based parser for extracting results from web pages
+- Allow to use "extended" INTERPRET tags selectively 
+- With engines that provide a redirection URL for results (eg Acoona), it looks like
+  the query hitory is not saved/checked correctly
+- OR terms if AND search on index doesn't return anything
+- Add Creative Commons (http://search.yahoo.com/cc)
+- Add http://beta.exalead.com/search
+- Add csourcesearch.net
+- Add http://www.patentcommons.org/commons/patentsearch.php
+- Apply Pinot specific filters (eg "L" for language) on internal indices only
+
+Collect
+- Comply with robot stuff defined at http://www.robotstxt.org/
+- Harvest mode grabs all pages on a specific site down to a certain depth
+- Make User-Agent string configurable
+- Make download timeout configurable
+- Investigate replacing neon (and gsoap ?) with libsoup
+- Support for HTML frames
+- Write a tokenizer for RFCs that breaks chapters into individual documents
+- Allow to cache documents that had to be converted ? eg PDF, MS Word
+
+Index
+- Get hold of stopwords lists for the languages supported by Xapian's stemmers and don't index stop words
+- Allow to import and use omindex-produced indexes  so that they can be used like pinot's internal indexes
+- Write a pseudo-filesystem for indexes with FUSE (http://fuse.sourceforge.net/) or gnome-vfs ?
+- Interface with libtranslate (http://www.nongnu.org/libtranslate/) ? :-)
+- Xapian lock files can be deleted at startup if no other instance is running
+- Make sure terms are not longer than btree:max_key_len bytes
+- Play around with the XAPIAN_FLUSH_THRESHOLD env var
+- Catch DatabaseModifiedError exceptions, call reopen()
+- Sort index/database back-end, don't replicate what's in the configuration file, etc...
+- Switch to Xapian's new Flint back-end (set XAPIAN_PREFER_FLINT=1)
+- Write a back-end for CLucene (http://clucene.sourceforge.net/)
+- Flush the index before searching not after modification
+- Hash document data to determine on updates whether documents have changed
+- Allow to monitor imported documents for changes
+
+Browser plugin
+- Write Firefox extension that searches Pinot indexes and indexes the cache
+- Borrow code from beagle's Firefox plugin
+- Skip popups and non text documents
+- Use dbus for communication
+- Index browser history in My Web index
+
+RenderHTML
+- Sort out issues with gtk_embed_moz if possible
+- Replace Mozilla GTK embed with GTK WebCore or latest gtkhtml, or drop altogether ?
+- Is it possible to build against Firefox instead of the Mozilla suite ?
+- Highlight search terms
+- Fix crash with documents that link to images with https
+
+Mail
+- Find out what kind of locking scheme Mozilla uses (POSIX lock ?) and use that
+- Index Evolution email (Camel, might be useful for other types actually)
+- Keep track of attachments and avoid indexing the same file twice
+- Append sender to title or use as host name ?
+- Decypher and use Mozilla's mailbox scheme, eg
+  mailbox://mbox_file_name?number=2164959&part=1.2&type=text/plain&filename=portability.txt
+- When parsing email's Date field, take the timezone offset into account, eg in
+    Date: Thu, 25 Aug 2005 11:04:49 +0800
+  +0800 is basically same as SGT. At the moment the date is assumed to be GMT !
+- Mail messages with attachements are not indexed
+- Check that labels are removed when a message is unindexed (eg because it's no longer
+  in the mail account)
+
+UI
+- Switching back and forth between grouping modes messes up results rankings : check scores
+- When sorting results by host name, give better score to results that appear several times
+- Results and index trees should be sorted when clicking on columns
+- Make sure all operations (eg search engines) and threads can be stopped cleanly
+- Show which threads are running, what they are doing, and allow to stop them selectively
+- Add an history window to edit Index and ViewHistory
+- Automatic indexing of a query's results depending on type, source, size, language
+- Non modal status window to display log of operations
+- Display search engines icons (Gtk::IconSource::set_filename() and Gtk::Style::render_icon())
+- Only show documents that have the selected label
+- Replace Combobox objects with ComboboxText's (glademm support required)
+- Replace glademm with libglademm ?
+- Show extract instead of URL in index list
+- At startup, don't switch to the Index tab when listing the documents index
+- Show activity when mail is being indexed
+- Update Last Run after the query has completed
+- Add a Recent Import section that relies on documents timestamps
+- Filter documents by language, similarly to how labels are shown
+- Save query expander and extract field status in config file
+

Added: trunk/Tokenize/HtmlTokenizer.cpp
===================================================================
--- trunk/Tokenize/HtmlTokenizer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/HtmlTokenizer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,490 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <string.h>
+#include <sys/types.h>
+#include <regex.h>
+#include <stack>
+#include <iostream>
+#include <algorithm>
+
+#include "StringManip.h"
+#include "HtmlTokenizer.h"
+
+//#define DEBUG_TOKENIZER
+
+using namespace std;
+
+/// Removes double and single quotes in links or any other attribute.
+static string removeLinkQuotes(const string &quotedLink)
+{
+	string link;
+
+	if (quotedLink[0] == '"')
+	{
+		string::size_type closingQuotePos = quotedLink.find("\"", 1);
+		if (closingQuotePos != string::npos)
+		{
+			link = quotedLink.substr(1, closingQuotePos - 1);
+		}
+	}
+	else if (quotedLink[0] == '\'')
+	{
+		string::size_type closingQuotePos = quotedLink.find("'", 1);
+		if (closingQuotePos != string::npos)
+		{
+			link = quotedLink.substr(1, closingQuotePos - 1);
+		}
+	}
+	else
+	{
+		// There are no quotes, so just look for the first space, if any
+		string::size_type spacePos = quotedLink.find(" ");
+		if (spacePos != string::npos)
+		{
+			link = quotedLink.substr(0, spacePos);
+		}
+		else
+		{
+			link = quotedLink;
+		}
+	}
+
+	return link;
+}
+
+HtmlTokenizer::HtmlTokenizer(const Document *pDocument, unsigned int linksStartAtPos) :
+	Tokenizer(NULL),
+	m_pHtmlDocument(NULL),
+	m_linkPos(linksStartAtPos)
+{
+	initialize(pDocument);
+}
+
+HtmlTokenizer::HtmlTokenizer() :
+	Tokenizer(NULL),
+	m_pHtmlDocument(NULL),
+	m_linkPos(0)
+{
+}
+
+HtmlTokenizer::~HtmlTokenizer()
+{
+	if (m_pDocument != NULL)
+	{
+		// This should have been set by setDocument(),
+		// called in initialize()
+		delete m_pDocument;
+	}
+}
+
+void HtmlTokenizer::initialize(const Document *pDocument)
+{
+	unsigned int length = 0;
+
+	if (pDocument == NULL)
+	{
+		return;
+	}
+
+	const char *data = pDocument->getData(length);
+	if ((data != NULL) &&
+		(length > 0))
+	{
+		// Remove HTML tags
+		string strippedData = parseHTML(data);
+		// Append META keywords, if any were found
+		strippedData += getMetaTag("keywords");
+
+		// Pass the result to the parent class
+		Document *pStrippedDoc = new Document(pDocument->getTitle(),
+			pDocument->getLocation(), pDocument->getType(),
+			pDocument->getLanguage());
+		pStrippedDoc->setData(strippedData.c_str(), strippedData.length());
+		setDocument(pStrippedDoc);
+
+		m_pHtmlDocument = pDocument;
+	}
+}
+
+/// Parses HTML; the string without tags.
+string HtmlTokenizer::parseHTML(const string &str, bool stripAllBlocks)
+{
+	stack<string> tagsStack;
+	string stripped, link, linkName;
+	string::size_type startPos = 0, linkOpenPos = 0;
+	regex_t linksRegex, metaRegex;
+	bool isHtml = false, skip = false, catText = stripAllBlocks;
+	bool extractLinks = true, extractMetaTags = true, getLinkName = false;
+
+#ifdef DEBUG_TOKENIZER
+	cout << "HtmlTokenizer::parseHTML: start" << endl;
+#endif
+	// Prepare the regexps
+	if (regcomp(&linksRegex, "a(.*)href=(.*)", REG_EXTENDED|REG_ICASE) != 0)
+	{
+#ifdef DEBUG_TOKENIZER
+		cout << "HtmlTokenizer::parseHTML: couldn't compile links regexp" << endl;
+#endif
+		extractLinks = false;
+	}
+	if (regcomp(&metaRegex, "meta name=(.*) content=(.*)", REG_EXTENDED|REG_ICASE) != 0)
+	{
+#ifdef DEBUG_TOKENIZER
+		cout << "HtmlTokenizer::parseHTML: couldn't compile meta tag regexp" << endl;
+#endif
+		extractMetaTags = false;
+	}
+
+	// Tag start
+	string::size_type pos = str.find("<");
+	while (pos != string::npos)
+	{
+		isHtml = true;
+
+		if (skip == false)
+		{
+			string text = str.substr(startPos, pos - startPos);
+			if (catText == true)
+			{
+				stripped += replaceEscapedCharacters(text);
+			}
+
+			// Is this part of the name of the last link we found ?
+			if (getLinkName == true)
+			{
+				linkName += text;
+#ifdef DEBUG_TOKENIZER
+				cout << "HtmlTokenizer::parseHTML: adding to name " << text << endl;
+#endif
+			}
+
+			startPos = pos + 1;
+			// Tag end
+			if (str[pos] == '<')
+			{
+				pos = str.find(">", startPos);
+			}
+			// Skip stuff in the tag
+			skip = true;
+		}
+		else
+		{
+			regmatch_t pLinksMatches[3];
+			regmatch_t pMetaMatches[3];
+			int nLinksMatches = 3, nMetaMatches = 3;
+
+			// Found a tag from startPos to pos
+			string tag = str.substr(startPos, pos - startPos);
+			// Lower case the whole thing
+			tag = StringManip::toLowerCase(tag);
+			// Push it onto the stack
+			tagsStack.push(tag);
+#ifdef DEBUG_TOKENIZER
+			cout << "HtmlTokenizer::parseHTML: found " << tag << endl;
+#endif
+
+			if ((extractMetaTags == true) &&
+				(regexec(&metaRegex, tag.c_str(), nMetaMatches, pMetaMatches, 
+					REG_NOTBOL|REG_NOTEOL) == 0) &&
+				(pLinksMatches[nMetaMatches - 1].rm_so != -1))
+			{
+				string tmp, metaName, metaContent;
+
+				// META tag name
+				tmp = tag.substr(pMetaMatches[1].rm_so,
+					pMetaMatches[1].rm_eo - pMetaMatches[1].rm_so);
+				// Remove quotes
+				metaName = removeLinkQuotes(tmp);
+
+				// META tag content
+				tmp = tag.substr(pMetaMatches[2].rm_so,
+					pMetaMatches[2].rm_eo - pMetaMatches[2].rm_so);
+				// Remove quotes
+				metaContent = removeLinkQuotes(tmp);
+#ifdef DEBUG_TOKENIZER
+				cout << "HtmlTokenizer::parseHTML: found META tag " << metaName << ": " << metaContent << endl;
+#endif
+				m_metaTags[metaName] = metaContent;
+			}
+			// See if this tag is an anchor
+			// pLinksMatches[0] will be something like 'a href="blah"', pLinksMatches[1] will be ' ' and [2] will be '"blah"'
+			else if ((extractLinks == true) &&
+				(regexec(&linksRegex, tag.c_str(), nLinksMatches, pLinksMatches, REG_NOTBOL|REG_NOTEOL) == 0) &&
+				(pLinksMatches[nLinksMatches - 1].rm_so != -1))
+			{
+				string quotedLink = tag.substr(pLinksMatches[2].rm_so,
+					pLinksMatches[2].rm_eo - pLinksMatches[2].rm_so);
+
+#ifdef DEBUG_TOKENIZER
+				cout << "HtmlTokenizer::parseHTML: found link start " << tag << endl;
+#endif
+				if (link.empty() == false)
+				{
+					// The previous link's anchor's end couldn't be found ?
+					m_links.insert(Link(stripTags(link), linkName, m_linkPos, linkOpenPos, startPos - 1));
+					m_linkPos++;
+					linkName = "";
+#ifdef DEBUG_TOKENIZER
+					cout << "HtmlTokenizer::parseHTML: previous link wasn't closed properly" << endl;
+#endif
+				}
+
+				// Remove quotes
+				link = removeLinkQuotes(quotedLink);
+				linkOpenPos = startPos - 1;
+
+				// Remember to get the name of the link
+				getLinkName = true;
+			}
+			// Maybe it's the anchor's end ?
+			else if ((extractLinks == true) &&
+				(tag == "/a"))
+			{
+				if (getLinkName == true)
+				{
+#ifdef DEBUG_TOKENIZER
+					cout << "HtmlTokenizer::parseHTML: " << pos << " link " << m_linkPos << " is " << link << ", name " << linkName << endl;
+#endif
+					// New link
+					m_links.insert(Link(stripTags(link), linkName, m_linkPos, linkOpenPos, pos + 1));
+					m_linkPos++;
+					getLinkName = false;
+					link = linkName = "";
+				}
+			}
+			else if (stripAllBlocks == false)
+			{
+				if (textBlockStart(tag) == true)
+				{
+					catText = true;
+#ifdef DEBUG_TOKENIZER
+					cout << "HtmlTokenizer::parseHTML: start text cat" << endl;
+#endif
+				}
+				else if (textBlockEnd(tag) == true)
+				{
+					catText = false;
+#ifdef DEBUG_TOKENIZER
+					cout << "HtmlTokenizer::parseHTML: end text cat" << endl;
+#endif
+				}
+				else
+				{
+					string parentTag = tagsStack.top();
+
+					if ((tag.substr(0, 6) == "script") ||
+						(tag.substr(0, 5) == "style"))
+					{
+#ifdef DEBUG_TOKENIZER
+						cout << "HtmlTokenizer::parseHTML: skip script" << endl;
+#endif
+						catText = false;
+					}
+					else if (((tag.substr(0, 7) == "/script") ||
+						(tag.substr(0, 6) == "/style")) &&
+						(textBlockStart(parentTag) == false))
+					{
+#ifdef DEBUG_TOKENIZER
+						cout << "HtmlTokenizer::parseHTML: stop skip script" << endl;
+#endif
+						catText = true;
+					}
+				}
+			}
+
+			startPos = pos + 1;
+			pos = str.find("<", startPos);
+			skip = false;
+		}
+	}
+	if ((startPos < str.length()) &&
+		(catText == true))
+	{
+		stripped  += replaceEscapedCharacters(str.substr(startPos));
+	}
+
+	// Free the compiled regexps
+	regfree(&linksRegex);
+	regfree(&metaRegex);
+
+	if (isHtml == false)
+	{
+		return str;
+	}
+
+	return stripped;
+}
+
+/// Returns true if the tag corresponds to a text block.
+bool HtmlTokenizer::textBlockStart(const string &tag)
+{
+	if ((tag.substr(0, 4) == "body") ||
+		(tag.substr(0, 5) == "title"))
+	{
+		return true;
+	}
+
+	return false;
+}
+
+/// Returns true if the tag corresponds to the end of a text block.
+bool HtmlTokenizer::textBlockEnd(const string &tag)
+{
+	if ((tag.substr(0, 5) == "/body") ||
+		(tag.substr(0, 6) == "/title"))
+	{
+		return true;
+	}
+
+	return false;
+}
+
+/// Replaces escaped characters
+string HtmlTokenizer::replaceEscapedCharacters(const string &str)
+{
+	// FIXME: replace all escaped characters !
+	static const char *escapedChars[] = { "quot", "amp", "lt", "gt", "nbsp", "eacute", "egrave", "agrave", "ccedil"};
+	static const char *unescapedChars[] = { "\"", "&", "<", ">", " ", "e", "e", "a", "c"};
+	static const unsigned int escapedCharsCount = 9;
+	string unescaped;
+	string::size_type startPos = 0, pos = 0;
+
+#ifdef DEBUG_TOKENIZER
+	cout << "HtmlTokenizer::replaceEscapedCharacters: input " << str << endl;
+#endif
+	pos = str.find("&");
+	while (pos != string::npos)
+	{
+		unescaped += str.substr(startPos, pos - startPos);
+
+		startPos = pos + 1;
+		pos = str.find(";", startPos);
+		if ((pos != string::npos) &&
+			(pos < startPos + 10))
+		{
+			string escapedChar = str.substr(startPos, pos - startPos);
+			bool replacedChar = false;
+
+			// See if we can replace this with an actual character
+			for (unsigned int count = 0; count < escapedCharsCount; ++count)
+			{
+				if (escapedChar == escapedChars[count])
+				{
+					unescaped += unescapedChars[count];
+					replacedChar = true;
+					break;
+				}
+			}
+
+			if (replacedChar == false)
+			{
+				// This couldn't be replaced, leave it as it is...
+				unescaped += "&";
+				unescaped += escapedChar;
+				unescaped += ";";
+			}
+
+			startPos = pos + 1;
+		}
+
+		// Next
+		pos = str.find("&", startPos);
+	}
+	if (startPos < str.length())
+	{
+		unescaped  += str.substr(startPos);
+	}
+#ifdef DEBUG_TOKENIZER
+	cout << "HtmlTokenizer::replaceEscapedCharacters: output " << unescaped << endl;
+#endif
+
+	return unescaped;
+}
+
+/// Gets the specified META tag content.
+string HtmlTokenizer::getMetaTag(const string &name)
+{
+	if (name.empty() == true)
+	{
+		return "";
+	}
+
+	map<string, string>::const_iterator iter = m_metaTags.find(name);
+	if (iter != m_metaTags.end())
+	{
+		return iter->second;
+	}
+
+	return "";
+}
+
+/// Gets the links map.
+set<Link> &HtmlTokenizer::getLinks(void)
+{
+	return m_links;
+}
+
+/// Utility method that strips HTML tags off; the string without tags.
+string HtmlTokenizer::stripTags(const string &str)
+{
+	HtmlTokenizer tokens;
+
+	return tokens.parseHTML(str, true);
+}
+
+Link::Link(const string &url, const string &name, unsigned int pos, unsigned int openPos, unsigned int closePos) :
+	m_url(url),
+	m_name(name),
+	m_pos(pos),
+	m_open(openPos),
+	m_close(closePos)
+{
+}
+
+Link::Link(const Link &other) :
+	m_url(other.m_url),
+	m_name(other.m_name),
+	m_pos(other.m_pos),
+	m_open(other.m_open),
+	m_close(other.m_close)
+{
+}
+
+Link::~Link()
+{
+}
+
+Link& Link::operator=(const Link& other)
+{
+	m_url = other.m_url;
+	m_name = other.m_name;
+	m_pos = other.m_pos;
+	m_open = other.m_open;
+	m_close = other.m_close;
+
+	return *this;
+}
+
+bool Link::operator==(const Link &other) const
+{
+	return m_url == other.m_url;
+}
+
+bool Link::operator<(const Link &other) const
+{
+	return m_pos < other.m_pos;
+}


Property changes on: trunk/Tokenize/HtmlTokenizer.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/HtmlTokenizer.h
===================================================================
--- trunk/Tokenize/HtmlTokenizer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/HtmlTokenizer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,88 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _HTML_TOKENIZER_H
+#define _HTML_TOKENIZER_H
+
+#include <string>
+#include <map>
+#include <utility>
+#include <set>
+
+#include "Document.h"
+#include "Tokenizer.h"
+
+using namespace std;
+
+class Link
+{
+	public:
+		Link(const string &url, const string &name, unsigned int pos, unsigned int openPos, unsigned int closePos);
+		Link(const Link &other);
+		~Link();
+
+		Link& operator=(const Link& other);
+		bool operator==(const Link &other) const;
+		bool operator<(const Link &other) const;
+
+		string m_url;
+		string m_name;
+		unsigned int m_pos;
+		unsigned int m_open;
+		unsigned int m_close;
+
+};
+
+class HtmlTokenizer : public Tokenizer
+{
+	public:
+		HtmlTokenizer(const Document *pDocument, unsigned int linksStartAtPos = 0);
+		virtual ~HtmlTokenizer();
+
+		/// Gets the specified META tag content; an empty string if it wasn't found.
+		string getMetaTag(const string &name);
+
+		/// Gets the links map.
+		set<Link> &getLinks(void);
+
+		/// Utility method that strips HTML tags off; the string without tags.
+		static string stripTags(const string &str);
+
+	protected:
+		const Document *m_pHtmlDocument;
+		unsigned int m_linkPos;
+		map<string, string> m_metaTags;
+		set<Link> m_links;
+
+		HtmlTokenizer();
+
+		void initialize(const Document *pDocument);
+
+		/// Parses HTML; the string without tags.
+		string parseHTML(const string &str, bool stripAllBlocks = false);
+
+		/// Returns true if the tag corresponds to a text block.
+		static bool textBlockStart(const string &tag);
+
+		/// Returns true if the tag corresponds to the end of a text block.
+		static bool textBlockEnd(const string &tag);
+
+		/// Replaces escaped characters
+		static string replaceEscapedCharacters(const string &str);
+
+};
+
+#endif // _HTML_TOKENIZER_H


Property changes on: trunk/Tokenize/HtmlTokenizer.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/Makefile
===================================================================
--- trunk/Tokenize/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,42 @@
+
+ROOT_DIR = ..
+
+include ${ROOT_DIR}/variables.mk
+
+TOKENIZE_SRCS = Tokenizer.cpp HtmlTokenizer.cpp UnknownTypeTokenizer.cpp \
+	TokenizerFactory.cpp
+TOKENIZE_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${TOKENIZE_SRCS})
+
+TOKENIZER_TEST = ${BIN_DIR}/tokenizertest
+PDF_TOKENIZER_DL = ${LIB_DIR}/pdf_tokenizer.so
+WORD_TOKENIZER_DL = ${LIB_DIR}/word_tokenizer.so
+
+targets : dirs ${TOKENIZE_LIB} ${TOKENIZER_TEST} \
+	${PDF_TOKENIZER_DL} ${WORD_TOKENIZER_DL}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${TOKENIZE_LIB} ${TOKENIZER_TEST} \
+	${PDF_TOKENIZER_DL} ${WORD_TOKENIZER_DL}
+
+# Tokenize tester
+
+${TOKENIZER_TEST} : ${OBJ_DIR}/tokenizertest.o ${TOKENIZE_LIB}
+	@echo Building ${TOKENIZER_TEST}
+	${LINK} -o ${TOKENIZER_TEST} ${OBJ_DIR}/tokenizertest.o ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS}
+
+# Library
+
+${TOKENIZE_LIB} : ${TOKENIZE_OBJS}
+	@echo Building ${TOKENIZE_LIB}
+	${AR} cr ${TOKENIZE_LIB} ${TOKENIZE_OBJS}
+
+# Tokenizer libraries
+
+${PDF_TOKENIZER_DL} : ${OBJ_DIR}/PdfTokenizer.o
+	@echo Building ${PDF_TOKENIZER_DL}
+	${LINK} -shared -o ${PDF_TOKENIZER_DL} ${OBJ_DIR}/PdfTokenizer.o ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS} -ldl
+
+${WORD_TOKENIZER_DL} : ${OBJ_DIR}/WordTokenizer.o
+	@echo Building ${WORD_TOKENIZER_DL}
+	${LINK} -shared -o ${WORD_TOKENIZER_DL} ${OBJ_DIR}/WordTokenizer.o ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS} -ldl
+


Property changes on: trunk/Tokenize/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/PdfTokenizer.cpp
===================================================================
--- trunk/Tokenize/PdfTokenizer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/PdfTokenizer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,123 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <iostream>
+
+#include "PdfTokenizer.h"
+
+/**
+  * This returns the MIME type supported by the library's tokenizer.
+  * The character string is allocated with new[].
+  */
+char *getTokenizerType(void)
+{
+	char *pType = new char[16];
+
+	strncpy(pType, "application/pdf", 15);
+	pType[15] = '\0';
+
+	return pType;
+}
+
+/// This returns a pointer to a Tokenizer, allocated with new.
+Tokenizer *getTokenizer(const Document *pDocument)
+{
+	return new PdfTokenizer(pDocument);
+}
+
+PdfTokenizer::PdfTokenizer(const Document *pDocument) :
+	HtmlTokenizer(NULL)
+{
+	char inTemplate[15] = "/tmp/tokXXXXXX";
+	char outTemplate[15] = "/tmp/tokXXXXXX";
+
+	int inFd = mkstemp(inTemplate);
+	int outFd = mkstemp(outTemplate);
+	if ((inFd != -1) &&
+		(outFd != -1))
+	{
+		unsigned int dataLength = 0;
+		const char *pData = pDocument->getData(dataLength);
+
+		// Save the data into a temporary file
+		if (write(inFd, (const void*)pData, dataLength) != -1)
+		{
+			// Run pdftohtml to convert it
+			string cmdLine = "pdftohtml -stdout ";
+			cmdLine += inTemplate;
+			cmdLine += " >";
+			cmdLine += outTemplate;
+			cmdLine += " 2>/dev/null";
+
+			if (system(cmdLine.c_str()) != -1)
+			{
+				struct stat fileStat;
+
+				// Read the output
+				if ((stat(outTemplate, &fileStat) != -1) &&
+					(S_ISREG(fileStat.st_mode)))
+				{
+					unsigned int total, bytes;
+					char *content = new char[fileStat.st_size + 1];
+
+					total = bytes = read(outFd, (void*)content, fileStat.st_size);
+					while ((bytes > 0) &&
+						(total < fileStat.st_size))
+					{
+						bytes = read(outFd, (void*)content, fileStat.st_size - total);
+						total += bytes;
+					}
+
+					// Pass the result to the parent class
+					Document *pHtmlDoc = new Document(pDocument->getTitle(),
+						pDocument->getLocation(), pDocument->getType(),
+						pDocument->getLanguage());
+					pHtmlDoc->setData(content, bytes);
+					initialize(pHtmlDoc);
+#ifdef DEBUG
+					cout << "PdfTokenizer::ctor: set " << bytes << " bytes of data" << endl;
+#endif
+
+					delete[] content;
+				}
+			}
+		}
+	}
+
+	close(outFd);
+	close(inFd);
+
+	if ((unlink(outTemplate) != 0) ||
+		(unlink(inTemplate) != 0))
+	{
+#ifdef DEBUG
+		cerr << "PdfTokenizer::ctor: couldn't delete temporary files" << endl;
+#endif
+	}
+}
+
+PdfTokenizer::PdfTokenizer() :
+	HtmlTokenizer()
+{
+}
+
+PdfTokenizer::~PdfTokenizer()
+{
+}

Added: trunk/Tokenize/PdfTokenizer.h
===================================================================
--- trunk/Tokenize/PdfTokenizer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/PdfTokenizer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,53 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _PDF_TOKENIZER_H
+#define _PDF_TOKENIZER_H
+
+#include <string>
+#include <map>
+#include <utility>
+#include <set>
+
+#include "Document.h"
+#include "HtmlTokenizer.h"
+
+using namespace std;
+
+/**
+  * This returns the MIME type supported by the library's tokenizer.
+  * The character string is allocated with new[].
+  */
+char *getTokenizerType(void);
+/// This returns a pointer to a Tokenizer, allocated with new.
+Tokenizer *getTokenizer(const Document *pDocument);
+
+class PdfTokenizer : public HtmlTokenizer
+{
+	public:
+		PdfTokenizer(const Document *pDocument);
+		virtual ~PdfTokenizer();
+
+	protected:
+		PdfTokenizer();
+
+	private:
+		PdfTokenizer(const PdfTokenizer &other);
+		PdfTokenizer& operator=(const PdfTokenizer& other);
+
+};
+
+#endif // _PDF_TOKENIZER_H

Added: trunk/Tokenize/Tokenizer.cpp
===================================================================
--- trunk/Tokenize/Tokenizer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/Tokenizer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,125 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <ctype.h>
+#include <stdlib.h>
+#include <iostream>
+#include <fstream>
+
+#include "Tokenizer.h"
+
+//#define DEBUG_TOKENIZER
+
+Tokenizer::Tokenizer(const Document *pDocument)
+{
+	setDocument(pDocument);
+	rewind();
+}
+
+Tokenizer::~Tokenizer()
+{
+}
+
+void Tokenizer::setDocument(const Document *pDocument)
+{
+	m_pDocument = pDocument;
+}
+
+/**
+  * Returns a pointer to the document being tokenized.
+  * This may not be the document passed to the constructor.
+  */
+const Document *Tokenizer::getDocument(void)
+{
+	return m_pDocument;
+}
+
+/// Returns the next token; false if all tokens consumed.
+bool Tokenizer::nextToken(string &token)
+{
+	bool bStarted = false;
+	unsigned int dataLength;
+	unsigned int pos = m_currentPos;
+
+	if (m_pDocument == NULL)
+	{
+#ifdef DEBUG_TOKENIZER
+		cout << "Tokenizer::nextToken: no document" << endl;
+#endif
+		return false;
+	}
+
+	const char *pData = m_pDocument->getData(dataLength);
+	if ((pData == NULL) ||
+		(dataLength == 0))
+	{
+#ifdef DEBUG_TOKENIZER
+		cout << "Tokenizer::nextToken: no data" << endl;
+#endif
+		return false;
+	}
+
+#ifdef DEBUG_TOKENIZER
+	if (pos == 0)
+	{
+		ofstream tokData("TokenizerData.txt");
+		tokData << pData << endl;
+		tokData.close();
+	}
+#endif
+	while (pos < dataLength)
+	{
+		if (isalnum(pData[pos]) != 0)
+		{
+			if (bStarted == false)
+			{
+				// This starts the new token
+				token = pData[pos];
+				bStarted = true;
+			}
+			else
+			{
+				// Append to token
+				token += pData[pos];
+			}
+		}
+		else
+		{
+			if (bStarted == true)
+			{
+#ifdef DEBUG_TOKENIZER
+				cout << "Tokenizer::nextToken: returning current token " << token << endl;
+#endif
+				// Return the current token
+				break;
+			}
+			// Else keep going until we find an alnum
+		}
+
+		// Next
+		pos++;
+	}
+	m_currentPos = pos;
+
+	return bStarted;
+}
+
+/// Rewinds the tokenizer.
+void Tokenizer::rewind(void)
+{
+	m_currentPos = 0;
+}
+


Property changes on: trunk/Tokenize/Tokenizer.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/Tokenizer.h
===================================================================
--- trunk/Tokenize/Tokenizer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/Tokenizer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,53 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TOKENIZER_H
+#define _TOKENIZER_H
+
+#include <string>
+
+#include "Document.h"
+
+using namespace std;
+
+class Tokenizer
+{
+	public:
+		Tokenizer(const Document *pDocument);
+		virtual ~Tokenizer();
+
+		/// Returns a pointer to the document being tokenized.
+		virtual const Document *getDocument(void);
+
+		/// Returns the next token; false if all tokens consumed.
+		virtual bool nextToken(string &token);
+
+		/// Rewinds the tokenizer.
+		virtual void rewind(void);
+
+	protected:
+		const Document *m_pDocument;
+		unsigned int m_currentPos;
+
+		void setDocument(const Document *pDocument);
+
+	private:
+		Tokenizer(const Tokenizer &other);
+		Tokenizer& operator=(const Tokenizer& other);
+
+};
+
+#endif // _TOKENIZER_H


Property changes on: trunk/Tokenize/Tokenizer.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/TokenizerFactory.cpp
===================================================================
--- trunk/Tokenize/TokenizerFactory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/TokenizerFactory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,295 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <ctype.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <strings.h>
+#include <dlfcn.h>
+#include <iostream>
+
+#include "MIMEScanner.h"
+#include "Tokenizer.h"
+#include "HtmlTokenizer.h"
+#include "UnknownTypeTokenizer.h"
+#include "Url.h"
+#include "TokenizerFactory.h"
+
+#define GETTOKENIZER		"_Z12getTokenizerPK8Document"
+#define GETTOKENIZERTYPE	"_Z16getTokenizerTypev"
+
+using std::cout;
+using std::endl;
+
+map<string, string> TokenizerFactory::m_types;
+map<string, void *> TokenizerFactory::m_handles;
+
+TokenizerFactory::TokenizerFactory()
+{
+}
+
+TokenizerFactory::~TokenizerFactory()
+{
+}
+
+Tokenizer *TokenizerFactory::getLibraryTokenizer(const string &type, const Document *pDocument)
+{
+	void *pHandle = NULL;
+
+	if (m_handles.empty() == true)
+	{
+#ifdef DEBUG
+		cout << "TokenizerFactory::getLibraryTokenizer: no libraries" << endl;
+#endif
+		return NULL;
+	}
+
+	map<string, string>::iterator typeIter = m_types.find(type);
+	if (typeIter == m_types.end())
+	{
+		// We don't know about this type
+		return NULL;
+	}
+	map<string, void *>::iterator handleIter = m_handles.find(typeIter->second);
+	if (handleIter == m_handles.end())
+	{
+		// We don't know about this library
+		return NULL;
+	}
+	pHandle = handleIter->second;
+	if (pHandle == NULL)
+	{
+		return NULL;
+	}
+
+	// Get a tokenizer object then
+	getTokenizerFunc *pFunc = (getTokenizerFunc *)dlsym(pHandle,
+		GETTOKENIZER);
+	if (pFunc != NULL)
+	{
+		return (*pFunc)(pDocument);
+	}
+#ifdef DEBUG
+	cout << "TokenizerFactory::getLibraryTokenizer: couldn't find export getTokenizer" << endl;
+#endif
+
+	return NULL;
+}
+
+/// Loads the tokenizer libraries in the given directory.
+unsigned int TokenizerFactory::loadTokenizers(const string &dirName)
+{
+	struct stat fileStat;
+	unsigned int count = 0;
+
+	if (dirName.empty() == true)
+	{
+		return 0;
+	}
+
+	if (stat(dirName.c_str(), &fileStat) == -1)
+	{
+#ifdef DEBUG
+		cout << "TokenizerFactory::loadTokenizers: "
+			<< dirName << " doesn't exist" << endl;
+#endif
+		return 0;
+	}
+
+	// Is it a file or a directory ?
+	if (S_ISDIR(fileStat.st_mode))
+	{
+		// A directory : scan it
+		DIR *pDir = opendir(dirName.c_str());
+		if (pDir == NULL)
+		{
+			return 0;
+		}
+
+		// Iterate through this directory's entries
+		struct dirent *pDirEntry = readdir(pDir);
+		while (pDirEntry != NULL)
+		{
+			char *pEntryName = pDirEntry->d_name;
+			if (pEntryName != NULL)
+			{
+				string fileName = pEntryName;
+				string::size_type extPos = fileName.find_last_of(".");
+
+				if ((extPos == string::npos) ||
+					(fileName.substr(extPos) != ".so"))
+				{
+					// Next entry
+					pDirEntry = readdir(pDir);
+					continue;
+				}
+
+				fileName = dirName;
+				fileName += "/";
+				fileName += pEntryName;
+
+				// Check this entry
+				if ((stat(fileName.c_str(), &fileStat) == 0) &&
+					(S_ISREG(fileStat.st_mode)))
+				{
+					void *pHandle = dlopen(fileName.c_str(), RTLD_LAZY);
+					if (pHandle != NULL)
+					{
+						// What type does this support ?
+						getTokenizerTypeFunc *pFunc = (getTokenizerTypeFunc *)dlsym(pHandle,
+								GETTOKENIZERTYPE);
+						if (pFunc != NULL)
+						{
+							char *pSupportedType = (*pFunc)();
+							if (pSupportedType != NULL)
+							{
+								// Add records for this tokenizer
+								m_types[pSupportedType] = fileName;
+								m_handles[fileName] = pHandle;
+								++count;
+
+#ifdef DEBUG
+								cout << "TokenizerFactory::loadTokenizers: type "
+									<< pSupportedType << " supported by " << pEntryName << endl;
+#endif
+
+								// It's supposed to have been allocated with new[]
+								delete[] pSupportedType;
+							}
+						}
+#ifdef DEBUG
+						else cout << "TokenizerFactory::loadTokenizers: couldn't find export getTokenizerType" << endl;
+#endif
+					}
+				}
+#ifdef DEBUG
+				else cout << "TokenizerFactory::loadTokenizers: "
+					<< pEntryName << " is not a file" << endl;
+#endif
+			}
+
+			// Next entry
+			pDirEntry = readdir(pDir);
+		}
+
+		closedir(pDir);
+	}
+#ifdef DEBUG
+	else cout << "TokenizerFactory::loadTokenizers: "
+		<< dirName << " is not a directory" << endl;
+#endif
+
+	return count;
+}
+
+/// Unloads all tokenizer libraries.
+void TokenizerFactory::unloadTokenizers(void)
+{
+	for (map<string, void*>::iterator iter = m_handles.begin(); iter != m_handles.end(); ++iter)
+	{
+		if (dlclose(iter->second) != 0)
+		{
+#ifdef DEBUG
+			cout << "TokenizerFactory::unloadTokenizers: failed on " << iter->first << endl;
+#endif
+		}
+	}
+
+	m_types.clear();
+	m_handles.clear();
+}
+
+/// Returns a Tokenizer that handles the given file's type; NULL if unavailable.
+Tokenizer *TokenizerFactory::getTokenizer(const string &fileName, const Document *pDocument)
+{
+	string type = MIMEScanner::scanFile(fileName);
+
+	return getTokenizerByType(type, pDocument);
+}
+
+/// Returns a Tokenizer that handles the given MIME type; NULL if unavailable.
+Tokenizer *TokenizerFactory::getTokenizerByType(const string &type, const Document *pDocument)
+{
+	string typeOnly = type;
+	string::size_type semiColonPos = type.find(";");
+
+	// Remove the charset, if any
+	if (semiColonPos != string::npos)
+	{
+		typeOnly = type.substr(0, semiColonPos);
+	}
+#ifdef DEBUG
+	cout << "TokenizerFactory::getTokenizerByType: file type is " << typeOnly << endl;
+#endif
+
+	if (typeOnly == "text/html")
+	{
+		return new HtmlTokenizer(pDocument);
+	}
+	else if (typeOnly == "text/plain")
+	{
+		return new Tokenizer(pDocument);
+	}
+
+	Tokenizer *pTokenizer = getLibraryTokenizer(typeOnly, pDocument);
+	if (pTokenizer == NULL)
+	{
+		if (strncasecmp(typeOnly.c_str(), "text", 4) == 0)
+		{
+			// Use this by default for text documents
+			return new Tokenizer(pDocument);
+		}
+
+		return new UnknownTypeTokenizer(pDocument);
+	}
+
+	return pTokenizer;
+}
+
+bool TokenizerFactory::isSupportedType(const string &type)
+{
+	string typeOnly = type;
+	string::size_type semiColonPos = type.find(";");
+
+	// Remove the charset, if any
+	if (semiColonPos != string::npos)
+	{
+		typeOnly = type.substr(0, semiColonPos);
+	}
+#ifdef DEBUG
+	cout << "TokenizerFactory::isSupportedType: file type is " << typeOnly << endl;
+#endif
+
+	// Is it a built-in type ?
+	if ((typeOnly == "text/html") ||
+		(strncasecmp(typeOnly.c_str(), "text", 4) == 0))
+	{
+		return true;
+	}
+
+	// Is it a type supported by a library ?
+	map<string, string>::iterator typeIter = m_types.find(typeOnly);
+	if (typeIter != m_types.end())
+	{
+		return true;
+	}
+
+	return false;
+}
+


Property changes on: trunk/Tokenize/TokenizerFactory.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/TokenizerFactory.h
===================================================================
--- trunk/Tokenize/TokenizerFactory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/TokenizerFactory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,70 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TOKENIZER_FACTORY_H
+#define _TOKENIZER_FACTORY_H
+
+#include <string>
+#include <map>
+
+#include "Tokenizer.h"
+
+#include <string>
+#include <map>
+
+class TokenizerFactory
+{
+	public:
+		virtual ~TokenizerFactory();
+
+		/**
+		  * This returns the MIME type supported by the library's tokenizer.
+		  * The character string is allocated with new[].
+		  */
+		typedef char *(getTokenizerTypeFunc)(void);
+		/// This returns a pointer to a Tokenizer, allocated with new.
+		typedef Tokenizer *(getTokenizerFunc)(const Document *);
+
+		/// Loads the tokenizer libraries in the given directory.
+		static unsigned int loadTokenizers(const string &dirName);
+
+		/// Returns a Tokenizer that handles the given file's type; NULL if unavailable.
+		static Tokenizer *getTokenizer(const string &fileName, const Document *pDocument);
+
+		/// Returns a Tokenizer that handles the given MIME type; NULL if unavailable.
+		static Tokenizer *getTokenizerByType(const string &type, const Document *pDocument);
+
+		/// Indicates whether a MIME type is supported or not.
+		static bool isSupportedType(const string &type);
+
+		/// Unloads all tokenizer libraries.
+		static void unloadTokenizers(void);
+
+	protected:
+		static map<string, string> m_types;
+		static map<string, void *> m_handles;
+
+		TokenizerFactory();
+
+		static Tokenizer *getLibraryTokenizer(const string &type, const Document *pDocument);
+
+	private:
+		TokenizerFactory(const TokenizerFactory &other);
+		TokenizerFactory& operator=(const TokenizerFactory& other);
+
+};
+
+#endif // _TOKENIZER_FACTORY_H


Property changes on: trunk/Tokenize/TokenizerFactory.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/UnknownTypeTokenizer.cpp
===================================================================
--- trunk/Tokenize/UnknownTypeTokenizer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/UnknownTypeTokenizer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,105 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <iostream>
+
+#include "UnknownTypeTokenizer.h"
+
+using namespace std;
+
+UnknownTypeTokenizer::UnknownTypeTokenizer(const Document *pDocument) :
+	Tokenizer(NULL)
+{
+	char inTemplate[15] = "/tmp/tokXXXXXX";
+	char outTemplate[15] = "/tmp/tokXXXXXX";
+
+	int inFd = mkstemp(inTemplate);
+	int outFd = mkstemp(outTemplate);
+	if ((inFd != -1) &&
+		(outFd != -1))
+	{
+		unsigned int dataLength = 0;
+		const char *pData = pDocument->getData(dataLength);
+
+		// Save the data into a temporary file
+		if (write(inFd, (const void*)pData, dataLength) != -1)
+		{
+			// Run strings against it to extract printable characters
+			string cmdLine = "strings --bytes=6 ";
+			cmdLine += inTemplate;
+			cmdLine += ">";
+			cmdLine += outTemplate;
+			
+			if (system(cmdLine.c_str()) != -1)
+			{
+				struct stat fileStat;
+
+				// Read the output
+				if ((stat(outTemplate, &fileStat) != -1) &&
+					(S_ISREG(fileStat.st_mode)))
+				{
+					unsigned int total, bytes;
+					char *content = new char[fileStat.st_size + 1];
+
+					total = bytes = read(outFd, (void*)content, fileStat.st_size);
+					while ((bytes > 0) &&
+						(total < fileStat.st_size))
+					{
+						bytes = read(outFd, (void*)content, fileStat.st_size - total);
+						total += bytes;
+					}
+
+					// Pass the result to the parent class
+					Document *pStrippedDoc = new Document(pDocument->getTitle(),
+						pDocument->getLocation(), pDocument->getType(),
+						pDocument->getLanguage());
+					pStrippedDoc->setData(content, bytes);
+					setDocument(pStrippedDoc);
+#ifdef DEBUG
+					cout << "UnknownTypeTokenizer::ctor: set " << bytes << " bytes of data" << endl;
+#endif
+
+					delete[] content;
+				}
+			}
+		}
+	}
+
+	close(outFd);
+	close(inFd);
+
+	if ((unlink(outTemplate) != 0) ||
+		(unlink(inTemplate) != 0))
+	{
+#ifdef DEBUG
+		cerr << "UnknownTypeTokenizer::ctor: couldn't delete temporary files" << endl;
+#endif
+	}
+}
+
+UnknownTypeTokenizer::~UnknownTypeTokenizer()
+{
+	if (m_pDocument != NULL)
+	{
+		// This should have been set by setDocument(),
+		// called by the constructor
+		delete m_pDocument;
+	}
+}


Property changes on: trunk/Tokenize/UnknownTypeTokenizer.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/UnknownTypeTokenizer.h
===================================================================
--- trunk/Tokenize/UnknownTypeTokenizer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/UnknownTypeTokenizer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,36 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _UNKNOWN_TYPE_TOKENIZER_H
+#define _UNKNOWN_TYPE_TOKENIZER_H
+
+#include "Tokenizer.h"
+
+using namespace std;
+
+class UnknownTypeTokenizer : public Tokenizer
+{
+	public:
+		UnknownTypeTokenizer(const Document *pDocument);
+		virtual ~UnknownTypeTokenizer();
+
+	private:
+		UnknownTypeTokenizer(const UnknownTypeTokenizer &other);
+		UnknownTypeTokenizer& operator=(const UnknownTypeTokenizer& other);
+
+};
+
+#endif // _UNKNOWN_TYPE_TOKENIZER_H


Property changes on: trunk/Tokenize/UnknownTypeTokenizer.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Tokenize/WordTokenizer.cpp
===================================================================
--- trunk/Tokenize/WordTokenizer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/WordTokenizer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,123 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <iostream>
+
+#include "WordTokenizer.h"
+
+/**
+  * This returns the MIME type supported by the library's tokenizer.
+  * The character string is allocated with new[].
+  */
+char *getTokenizerType(void)
+{
+	char *pType = new char[16];
+
+	strncpy(pType, "application/msword", 18);
+	pType[18] = '\0';
+
+	return pType;
+}
+
+/// This returns a pointer to a Tokenizer, allocated with new.
+Tokenizer *getTokenizer(const Document *pDocument)
+{
+	return new WordTokenizer(pDocument);
+}
+
+WordTokenizer::WordTokenizer(const Document *pDocument) :
+	Tokenizer(NULL)
+{
+	char inTemplate[15] = "/tmp/tokXXXXXX";
+	char outTemplate[15] = "/tmp/tokXXXXXX";
+
+	int inFd = mkstemp(inTemplate);
+	int outFd = mkstemp(outTemplate);
+	if ((inFd != -1) &&
+		(outFd != -1))
+	{
+		unsigned int dataLength = 0;
+		const char *pData = pDocument->getData(dataLength);
+
+		// Save the data into a temporary file
+		if (write(inFd, (const void*)pData, dataLength) != -1)
+		{
+			// Run antiword to convert it
+			string cmdLine = "antiword ";
+			cmdLine += inTemplate;
+			cmdLine += " >";
+			cmdLine += outTemplate;
+			cmdLine += " 2>/dev/null";
+			
+			if (system(cmdLine.c_str()) != -1)
+			{
+				struct stat fileStat;
+
+				// Read the output
+				if ((stat(outTemplate, &fileStat) != -1) &&
+					(S_ISREG(fileStat.st_mode)))
+				{
+					unsigned int total, bytes;
+					char *content = new char[fileStat.st_size + 1];
+
+					total = bytes = read(outFd, (void*)content, fileStat.st_size);
+					while ((bytes > 0) &&
+						(total < fileStat.st_size))
+					{
+						bytes = read(outFd, (void*)content, fileStat.st_size - total);
+						total += bytes;
+					}
+
+					// Pass the result to the parent class
+					Document *pDoc = new Document(pDocument->getTitle(),
+						pDocument->getLocation(), pDocument->getType(),
+						pDocument->getLanguage());
+					pDoc->setData(content, bytes);
+					setDocument(pDoc);
+#ifdef DEBUG
+					cout << "WordTokenizer::ctor: set " << bytes << " bytes of data" << endl;
+#endif
+
+					delete[] content;
+				}
+			}
+		}
+	}
+
+	close(outFd);
+	close(inFd);
+
+	if ((unlink(outTemplate) != 0) ||
+		(unlink(inTemplate) != 0))
+	{
+#ifdef DEBUG
+		cerr << "WordTokenizer::ctor: couldn't delete temporary files" << endl;
+#endif
+	}
+}
+
+WordTokenizer::~WordTokenizer()
+{
+	if (m_pDocument != NULL)
+	{
+		// This should have been set by setDocument()
+		delete m_pDocument;
+	}
+}

Added: trunk/Tokenize/WordTokenizer.h
===================================================================
--- trunk/Tokenize/WordTokenizer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/WordTokenizer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,50 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _WORD_TOKENIZER_H
+#define _WORD_TOKENIZER_H
+
+#include <string>
+#include <map>
+#include <utility>
+#include <set>
+
+#include "Document.h"
+#include "Tokenizer.h"
+
+using namespace std;
+
+/**
+  * This returns the MIME type supported by the library's tokenizer.
+  * The character string is allocated with new[].
+  */
+char *getTokenizerType(void);
+/// This returns a pointer to a Tokenizer, allocated with new.
+Tokenizer *getTokenizer(const Document *pDocument);
+
+class WordTokenizer : public Tokenizer
+{
+	public:
+		WordTokenizer(const Document *pDocument);
+		virtual ~WordTokenizer();
+
+	private:
+		WordTokenizer(const WordTokenizer &other);
+		WordTokenizer& operator=(const WordTokenizer& other);
+
+};
+
+#endif // _WORD_TOKENIZER_H

Added: trunk/Tokenize/tokenizertest.cpp
===================================================================
--- trunk/Tokenize/tokenizertest.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Tokenize/tokenizertest.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,136 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <iostream>
+#include <string>
+
+#include "HtmlTokenizer.h"
+#include "UnknownTypeTokenizer.h"
+#include "TokenizerFactory.h"
+#include "StringManip.h"
+
+using namespace std;
+
+int main(int argc, char **argv)
+{
+	if (argc < 3)
+	{
+		cerr << "Usage: " << argv[0] << " <file name> RAWDATA|STRIP|LISTLINKS|LISTTOKENS|META=<meta tag name>|SUBSTR=<sub-string> [TYPE=<type>]" << endl;
+		return EXIT_FAILURE;
+	}
+
+	Document doc;
+	if (doc.setDataFromFile(argv[1]) == false)
+	{
+		cerr << "Couldn't load " << argv[1] << " !" << endl;
+		return EXIT_FAILURE;
+	}
+
+	Tokenizer *pTokens = NULL;
+	// How shall we get the tokenizer ?
+	if ((argc >= 4) &&
+		(strncmp(argv[3], "TYPE=", 5) == 0))
+	{
+		// By type
+		pTokens = TokenizerFactory::getTokenizerByType(argv[3] + 5, &doc);
+	}
+	else
+	{
+		pTokens = TokenizerFactory::getTokenizer(argv[1], &doc);
+	}
+
+	if (pTokens == NULL)
+	{
+		cerr << "Couldn't obtain tokenizer for " << argv[1] << " !" << endl;
+		return EXIT_FAILURE;
+	}
+
+	HtmlTokenizer *pHtmlTokens = dynamic_cast<HtmlTokenizer*>(pTokens);
+
+	const Document *pDoc = NULL;
+	unsigned int length = 0;
+
+	if (strncmp(argv[2], "RAWDATA", 5) == 0)
+	{
+		// Call the base class's method
+		pDoc = pTokens->Tokenizer::getDocument();
+		if (pDoc != NULL)
+		{
+			cout << "Raw text is :" << endl;
+			cout << pDoc->getData(length) << endl;
+		}
+	}
+	else if (strncmp(argv[2], "STRIP", 5) == 0)
+	{
+		const char *pData = doc.getData(length);
+
+		cout << "Stripped text is :" << endl;
+		cout << HtmlTokenizer::stripTags(string(pData, length)) << endl;
+	}
+	else if ((strncmp(argv[2], "LISTLINKS", 9) == 0) &&
+		(pHtmlTokens != NULL))
+	{
+		// Get a list of links
+		set<Link> &links = pHtmlTokens->getLinks();
+		if (links.empty() == false)
+		{
+			set<Link>::iterator iter;
+			for(iter = links.begin(); iter != links.end(); iter++)
+			{
+				cout << "Found link \"" << iter->m_name << "\" to " << iter->m_url << endl;
+			}
+		}
+		else
+		{
+			cout << "No links were found in " << argv[1] << endl;
+		}
+	}
+	else if (strncmp(argv[2], "LISTTOKENS", 10) == 0)
+	{
+		string token;
+		cout << "Tokens are :" << endl;
+		while (pTokens->nextToken(token) == true)
+		{
+			cout << token << endl;
+		}
+	}
+	else if ((strncmp(argv[2], "META=", 5) == 0) &&
+		(pHtmlTokens != NULL))
+	{
+		string metaTag = argv[2] + 5;
+		cout << "Meta tag " << metaTag << " was set to " << pHtmlTokens->getMetaTag(metaTag) << endl;
+	}
+	else if ((strncmp(argv[2], "SUBSTR=", 7) == 0) &&
+		(pHtmlTokens != NULL))
+	{
+		string subString = argv[2] + 7;
+
+		pDoc = pTokens->getDocument();
+		if (pDoc != NULL)
+		{
+			cout << "Replaced sub-string " << subString << " with 'Hello'" << endl;
+			cout << StringManip::replaceSubString(pDoc->getData(length), subString, "Hello") << endl;
+		}
+	}
+
+	delete pTokens;
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/Tokenize/tokenizertest.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/config.h
===================================================================
--- trunk/UI/GTK2/config.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/config.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,91 @@
+/* config.h.  Generated by configure.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
+// generated 2003/5/18 21:15:37 BST by fabrice at amra.dyndns.org.(none)
+// using glademm V2.0.0
+
+/* acconfig.h
+ * This file is in the public domain.
+ *
+ * Descriptive text for the C preprocessor macros that
+ * the distributed Autoconf macros can define.
+ * These entries are sometimes used by macros
+ * which glade-- uses.
+ */
+#define PACKAGE "pinot"
+#define ENABLE_NLS 1
+/* #undef HAVE_CATGETS */
+#define HAVE_GETTEXT 1
+#define HAVE_LC_MESSAGES 1
+/* #undef HAVE_STPCPY */
+/* #undef HAVE_LIBSM */
+#define PACKAGE_LOCALE_DIR "/usr/share/locale"
+#define GETTEXT_PACKAGE "pinot"
+
+/* always defined to indicate that i18n is enabled */
+#define ENABLE_NLS 1
+
+/* Define to 1 if you have the `bind_textdomain_codeset' function. */
+#define HAVE_BIND_TEXTDOMAIN_CODESET 1
+
+/* Define to 1 if you have the `dcgettext' function. */
+#define HAVE_DCGETTEXT 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+#define HAVE_GETTEXT 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define if your <locale.h> file defines LC_MESSAGES. */
+#define HAVE_LC_MESSAGES 1
+
+/* Define to 1 if you have the <locale.h> header file. */
+#define HAVE_LOCALE_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "Pinot"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "Pinot v0.30"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "pinot-0.30.tar.gz"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.30"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "0.30"

Added: trunk/UI/GTK2/metase-gtk2.glade
===================================================================
--- trunk/UI/GTK2/metase-gtk2.glade	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/metase-gtk2.glade	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,4086 @@
+<?xml version="1.0" standalone="no"?> <!--*- mode: xml -*-->
+<!DOCTYPE glade-interface SYSTEM "http://glade.gnome.org/glade-2.0.dtd">
+
+<glade-interface>
+
+<widget class="GtkWindow" id="mainWindow">
+  <property agent="glademm" name="cxx_visibility">public</property>
+  <property name="visible">True</property>
+  <property name="events">GDK_BUTTON_PRESS_MASK</property>
+  <property name="title" translatable="yes">Pinot</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_NONE</property>
+  <property name="modal">False</property>
+  <property name="default_width">400</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+  <signal name="delete_event" handler="on_mainWindow_delete_event" last_modification_time="Sat, 17 May 2003 11:06:56 GMT"/>
+
+  <child>
+    <widget class="GtkVBox" id="vbox1">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child>
+	<widget class="GtkMenuBar" id="mainMenubar">
+	  <property name="visible">True</property>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="sessionMenuitem">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Session</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="sessionMenuitem_menu">
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="configure1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label">gtk-preferences</property>
+		      <property name="use_stock">True</property>
+		      <signal name="activate" handler="on_configure_activate" last_modification_time="Fri, 20 Feb 2004 18:58:55 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separatormenuitem1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="quit1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label">gtk-quit</property>
+		      <property name="use_stock">True</property>
+		      <signal name="activate" handler="on_quit_activate" last_modification_time="Fri, 20 Feb 2004 18:57:09 GMT"/>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="editMenuitem">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Edit</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="editMenuitem_menu">
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="cut1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label">gtk-cut</property>
+		      <property name="use_stock">True</property>
+		      <signal name="activate" handler="on_cut_activate" last_modification_time="Mon, 12 Apr 2004 09:32:03 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="copy1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label">gtk-copy</property>
+		      <property name="use_stock">True</property>
+		      <signal name="activate" handler="on_copy_activate" last_modification_time="Fri, 20 Feb 2004 18:57:09 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="paste1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label">gtk-paste</property>
+		      <property name="use_stock">True</property>
+		      <signal name="activate" handler="on_paste_activate" last_modification_time="Fri, 20 Feb 2004 18:57:09 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="delete1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label">gtk-delete</property>
+		      <property name="use_stock">True</property>
+		      <signal name="activate" handler="on_delete_activate" last_modification_time="Mon, 12 Apr 2004 09:32:03 GMT"/>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="resultsMenuitem">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Results</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="resultsMenuitem_menu">
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="clearresults1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Clear List</property>
+		      <property name="use_underline">True</property>
+		      <signal name="activate" handler="on_clearresults_activate" last_modification_time="Wed, 03 Mar 2004 19:51:48 GMT"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image514">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-clear</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkCheckMenuItem" id="showextract1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Show Extract</property>
+		      <property name="use_underline">True</property>
+		      <property name="active">True</property>
+		      <signal name="activate" handler="on_showextract_activate" last_modification_time="Thu, 03 Jun 2004 17:22:31 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="groupresults1">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Group By</property>
+		      <property name="use_underline">True</property>
+
+		      <child>
+			<widget class="GtkMenu" id="groupresults1_menu">
+
+			  <child>
+			    <widget class="GtkRadioMenuItem" id="searchenginegroup1">
+			      <property agent="glademm" name="cxx_visibility">protected</property>
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Search Engine</property>
+			      <property name="use_underline">True</property>
+			      <property name="active">True</property>
+			      <signal name="activate" handler="on_groupresults_activate" last_modification_time="Sat, 28 Feb 2004 17:56:26 GMT"/>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkRadioMenuItem" id="hostnamegroup1">
+			      <property agent="glademm" name="cxx_visibility">protected</property>
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Host Name</property>
+			      <property name="use_underline">True</property>
+			      <property name="active">False</property>
+			      <property name="group">searchenginegroup1</property>
+			    </widget>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator1">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="viewresults1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Vie_w</property>
+		      <property name="use_underline">True</property>
+		      <signal name="activate" handler="on_viewresults_activate" last_modification_time="Tue, 24 Jun 2003 18:19:21 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="viewcache1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">View Cache</property>
+		      <property name="use_underline">True</property>
+		      <signal name="activate" handler="on_viewcache_activate" last_modification_time="Fri, 18 Mar 2005 19:14:33 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="indexresults1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_Index</property>
+		      <property name="use_underline">True</property>
+		      <signal name="activate" handler="on_indexresults_activate" last_modification_time="Tue, 17 Jun 2003 19:16:56 GMT"/>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="indexMenuitem">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Index</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="indexMenuitem_menu">
+
+		  <child>
+		    <widget class="GtkMenuItem" id="showlabels1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Show Label</property>
+		      <property name="use_underline">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="import1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Import</property>
+		      <property name="use_underline">True</property>
+		      <signal name="activate" handler="on_import_activate" last_modification_time="Tue, 02 Mar 2004 22:13:44 GMT"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image515">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-open</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkSeparatorMenuItem" id="separator3">
+		      <property name="visible">True</property>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkMenuItem" id="viewfromindex1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">View</property>
+		      <property name="use_underline">True</property>
+		      <signal name="activate" handler="on_viewfromindex_activate" last_modification_time="Sat, 21 Feb 2004 13:47:40 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="refreshindex1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Update</property>
+		      <property name="use_underline">True</property>
+		      <signal name="activate" handler="on_refreshindex_activate" last_modification_time="Fri, 20 Feb 2004 18:57:09 GMT"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image516">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-refresh</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="unindex1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Unindex</property>
+		      <property name="use_underline">True</property>
+		      <signal name="activate" handler="on_unindex_activate" last_modification_time="Thu, 28 Jul 2005 12:42:23 GMT"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image517">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-delete</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="showfromindex1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Properties</property>
+		      <property name="use_underline">True</property>
+		      <signal name="activate" handler="on_showfromindex_activate" last_modification_time="Sun, 06 Nov 2005 08:43:05 GMT"/>
+
+		      <child internal-child="image">
+			<widget class="GtkImage" id="image518">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-properties</property>
+			  <property name="icon_size">1</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkMenuItem" id="helpMenuitem">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">_Help</property>
+	      <property name="use_underline">True</property>
+
+	      <child>
+		<widget class="GtkMenu" id="helpMenuitem_menu">
+
+		  <child>
+		    <widget class="GtkMenuItem" id="about1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">_About</property>
+		      <property name="use_underline">True</property>
+		      <signal name="activate" handler="on_about_activate" last_modification_time="Sat, 21 Jun 2003 15:19:32 GMT"/>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">False</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkHPaned" id="mainHpaned">
+	  <property agent="glademm" name="cxx_visibility">protected</property>
+	  <property name="visible">True</property>
+	  <property name="can_focus">True</property>
+	  <property name="position">105</property>
+
+	  <child>
+	    <widget class="GtkVBox" id="leftVbox">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkVBox" id="enginesVbox">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <placeholder/>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHBox" id="indexHbox">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">True</property>
+		  <property name="spacing">4</property>
+
+		  <child>
+		    <widget class="GtkButton" id="addIndexButton">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="on_addIndexButton_clicked" last_modification_time="Mon, 14 Feb 2005 18:15:10 GMT"/>
+
+		      <child>
+			<widget class="GtkImage" id="image439">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-add</property>
+			  <property name="icon_size">4</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="removeIndexButton">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="on_removeIndexButton_clicked" last_modification_time="Mon, 14 Feb 2005 18:15:15 GMT"/>
+
+		      <child>
+			<widget class="GtkImage" id="image438">
+			  <property name="visible">True</property>
+			  <property name="stock">gtk-remove</property>
+			  <property name="icon_size">4</property>
+			  <property name="xalign">0.5</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="shrink">True</property>
+	      <property name="resize">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkVBox" id="rightVbox">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkHBox" id="liveQueryHbox">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkLabel" id="liveQueryLabel">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Query:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">4</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="liveQueryEntry">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">True</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">4</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkVButtonBox" id="findVbuttonbox">
+		      <property name="visible">True</property>
+		      <property name="layout_style">GTK_BUTTONBOX_DEFAULT_STYLE</property>
+		      <property name="spacing">0</property>
+
+		      <child>
+			<widget class="GtkButton" id="findButton">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_default">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="label">gtk-find</property>
+			  <property name="use_stock">True</property>
+			  <property name="relief">GTK_RELIEF_NORMAL</property>
+			  <property name="focus_on_click">True</property>
+			  <signal name="clicked" handler="on_findButton_clicked" last_modification_time="Fri, 25 Feb 2005 23:31:00 GMT"/>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">4</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkExpander" id="queryExpander">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="expanded">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkHBox" id="queryHbox">
+		      <property name="visible">True</property>
+		      <property name="homogeneous">False</property>
+		      <property name="spacing">0</property>
+
+		      <child>
+			<widget class="GtkScrolledWindow" id="queryScrolledwindow">
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="hscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+			  <property name="vscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+			  <property name="shadow_type">GTK_SHADOW_NONE</property>
+			  <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+
+			  <child>
+			    <widget class="GtkTreeView" id="queryTreeview">
+			      <property agent="glademm" name="cxx_visibility">protected</property>
+			      <property name="visible">True</property>
+			      <property name="can_focus">True</property>
+			      <property name="events">GDK_BUTTON_PRESS_MASK</property>
+			      <property name="headers_visible">True</property>
+			      <property name="rules_hint">False</property>
+			      <property name="reorderable">False</property>
+			      <property name="enable_search">False</property>
+			      <property name="fixed_height_mode">False</property>
+			      <property name="hover_selection">False</property>
+			      <property name="hover_expand">False</property>
+			      <signal name="button_press_event" handler="on_queryTreeview_button_press_event" last_modification_time="Sat, 19 Mar 2005 10:05:13 GMT"/>
+			    </widget>
+			  </child>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">True</property>
+			  <property name="fill">True</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkVButtonBox" id="queryVbuttonbox">
+			  <property name="visible">True</property>
+			  <property name="layout_style">GTK_BUTTONBOX_START</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkButton" id="addQueryButton">
+			      <property name="border_width">4</property>
+			      <property agent="glademm" name="cxx_visibility">protected</property>
+			      <property name="visible">True</property>
+			      <property name="can_default">True</property>
+			      <property name="can_focus">True</property>
+			      <property name="label">gtk-add</property>
+			      <property name="use_stock">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <signal name="clicked" handler="on_addQueryButton_clicked" last_modification_time="Fri, 25 Feb 2005 23:22:27 GMT"/>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkButton" id="editQueryButton">
+			      <property name="border_width">4</property>
+			      <property agent="glademm" name="cxx_visibility">protected</property>
+			      <property name="visible">True</property>
+			      <property name="can_default">True</property>
+			      <property name="can_focus">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <signal name="clicked" handler="on_editQueryButton_clicked" last_modification_time="Fri, 25 Feb 2005 23:22:37 GMT"/>
+
+			      <child>
+				<widget class="GtkAlignment" id="alignment26">
+				  <property name="visible">True</property>
+				  <property name="xalign">0.5</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xscale">0</property>
+				  <property name="yscale">0</property>
+				  <property name="top_padding">0</property>
+				  <property name="bottom_padding">0</property>
+				  <property name="left_padding">0</property>
+				  <property name="right_padding">0</property>
+
+				  <child>
+				    <widget class="GtkHBox" id="hbox40">
+				      <property name="visible">True</property>
+				      <property name="homogeneous">False</property>
+				      <property name="spacing">2</property>
+
+				      <child>
+					<widget class="GtkImage" id="image400">
+					  <property name="visible">True</property>
+					  <property name="stock">gtk-open</property>
+					  <property name="icon_size">4</property>
+					  <property name="xalign">0.5</property>
+					  <property name="yalign">0.5</property>
+					  <property name="xpad">0</property>
+					  <property name="ypad">0</property>
+					</widget>
+					<packing>
+					  <property name="padding">0</property>
+					  <property name="expand">False</property>
+					  <property name="fill">False</property>
+					</packing>
+				      </child>
+
+				      <child>
+					<widget class="GtkLabel" id="label47">
+					  <property name="visible">True</property>
+					  <property name="label" translatable="yes">Edit</property>
+					  <property name="use_underline">True</property>
+					  <property name="use_markup">False</property>
+					  <property name="justify">GTK_JUSTIFY_LEFT</property>
+					  <property name="wrap">False</property>
+					  <property name="selectable">False</property>
+					  <property name="xalign">0.5</property>
+					  <property name="yalign">0.5</property>
+					  <property name="xpad">0</property>
+					  <property name="ypad">0</property>
+					  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+					  <property name="width_chars">-1</property>
+					  <property name="single_line_mode">False</property>
+					  <property name="angle">0</property>
+					</widget>
+					<packing>
+					  <property name="padding">0</property>
+					  <property name="expand">False</property>
+					  <property name="fill">False</property>
+					</packing>
+				      </child>
+				    </widget>
+				  </child>
+				</widget>
+			      </child>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkButton" id="removeQueryButton">
+			      <property name="border_width">4</property>
+			      <property agent="glademm" name="cxx_visibility">protected</property>
+			      <property name="visible">True</property>
+			      <property name="can_default">True</property>
+			      <property name="can_focus">True</property>
+			      <property name="label">gtk-remove</property>
+			      <property name="use_stock">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <signal name="clicked" handler="on_removeQueryButton_clicked" last_modification_time="Fri, 25 Feb 2005 23:38:42 GMT"/>
+			    </widget>
+			  </child>
+
+			  <child>
+			    <widget class="GtkButton" id="findQueryButton">
+			      <property name="border_width">4</property>
+			      <property agent="glademm" name="cxx_visibility">protected</property>
+			      <property name="visible">True</property>
+			      <property name="can_default">True</property>
+			      <property name="can_focus">True</property>
+			      <property name="label">gtk-find</property>
+			      <property name="use_stock">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <signal name="clicked" handler="on_findQueryButton_clicked" last_modification_time="Sat, 26 Feb 2005 13:31:59 GMT"/>
+			    </widget>
+			  </child>
+			</widget>
+			<packing>
+			  <property name="padding">0</property>
+			  <property name="expand">False</property>
+			  <property name="fill">True</property>
+			</packing>
+		      </child>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="queryLabel">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Stored queries</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="type">label_item</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkNotebook" id="mainNotebook">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="show_tabs">True</property>
+		  <property name="show_border">True</property>
+		  <property name="tab_pos">GTK_POS_TOP</property>
+		  <property name="scrollable">False</property>
+		  <property name="enable_popup">False</property>
+
+		  <child>
+		    <widget class="GtkVBox" id="resultsVbox">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="homogeneous">False</property>
+		      <property name="spacing">0</property>
+
+		      <child>
+			<placeholder/>
+		      </child>
+
+		      <child>
+			<placeholder/>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="tab_expand">False</property>
+		      <property name="tab_fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="resultsLabel">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Results</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="type">tab</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkVBox" id="indexVbox">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="homogeneous">False</property>
+		      <property name="spacing">0</property>
+
+		      <child>
+			<widget class="GtkHBox" id="indexButtonsHbox">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">0</property>
+
+			  <child>
+			    <widget class="GtkComboBox" id="indexCombobox">
+			      <property agent="glademm" name="cxx_visibility">protected</property>
+			      <property name="visible">True</property>
+			      <property name="items" translatable="yes"></property>
+			      <property name="add_tearoffs">False</property>
+			      <property name="focus_on_click">True</property>
+			      <signal name="changed" handler="on_indexCombobox_changed" last_modification_time="Mon, 18 Jul 2005 12:49:12 GMT"/>
+			    </widget>
+			    <packing>
+			      <property name="padding">4</property>
+			      <property name="expand">False</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkHButtonBox" id="indexHbuttonbox">
+			      <property name="visible">True</property>
+			      <property name="layout_style">GTK_BUTTONBOX_SPREAD</property>
+			      <property name="spacing">0</property>
+
+			      <child>
+				<widget class="GtkButton" id="indexFirstButton">
+				  <property agent="glademm" name="cxx_visibility">protected</property>
+				  <property name="visible">True</property>
+				  <property name="can_default">True</property>
+				  <property name="can_focus">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <signal name="clicked" handler="on_indexFirstButton_clicked" last_modification_time="Tue, 05 Jul 2005 13:26:37 GMT"/>
+
+				  <child>
+				    <widget class="GtkImage" id="image478">
+				      <property name="visible">True</property>
+				      <property name="stock">gtk-goto-first</property>
+				      <property name="icon_size">4</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				    </widget>
+				  </child>
+				</widget>
+			      </child>
+
+			      <child>
+				<widget class="GtkButton" id="indexBackButton">
+				  <property agent="glademm" name="cxx_visibility">protected</property>
+				  <property name="visible">True</property>
+				  <property name="can_default">True</property>
+				  <property name="can_focus">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <signal name="clicked" handler="on_indexBackButton_clicked" last_modification_time="Tue, 05 Jul 2005 13:26:43 GMT"/>
+
+				  <child>
+				    <widget class="GtkImage" id="image479">
+				      <property name="visible">True</property>
+				      <property name="stock">gtk-go-back</property>
+				      <property name="icon_size">4</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				    </widget>
+				  </child>
+				</widget>
+			      </child>
+
+			      <child>
+				<widget class="GtkButton" id="indexForwardButton">
+				  <property agent="glademm" name="cxx_visibility">protected</property>
+				  <property name="visible">True</property>
+				  <property name="can_default">True</property>
+				  <property name="can_focus">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <signal name="clicked" handler="on_indexForwardButton_clicked" last_modification_time="Tue, 05 Jul 2005 13:26:48 GMT"/>
+
+				  <child>
+				    <widget class="GtkImage" id="image480">
+				      <property name="visible">True</property>
+				      <property name="stock">gtk-go-forward</property>
+				      <property name="icon_size">4</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				    </widget>
+				  </child>
+				</widget>
+			      </child>
+
+			      <child>
+				<widget class="GtkButton" id="indexLastButton">
+				  <property agent="glademm" name="cxx_visibility">protected</property>
+				  <property name="visible">True</property>
+				  <property name="can_default">True</property>
+				  <property name="can_focus">True</property>
+				  <property name="relief">GTK_RELIEF_NORMAL</property>
+				  <property name="focus_on_click">True</property>
+				  <signal name="clicked" handler="on_indexLastButton_clicked" last_modification_time="Tue, 05 Jul 2005 13:26:54 GMT"/>
+
+				  <child>
+				    <widget class="GtkImage" id="image481">
+				      <property name="visible">True</property>
+				      <property name="stock">gtk-goto-last</property>
+				      <property name="icon_size">4</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				    </widget>
+				  </child>
+				</widget>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">4</property>
+			      <property name="expand">False</property>
+			      <property name="fill">True</property>
+			    </packing>
+			  </child>
+			</widget>
+			<packing>
+			  <property name="padding">4</property>
+			  <property name="expand">False</property>
+			  <property name="fill">True</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<placeholder/>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="tab_expand">False</property>
+		      <property name="tab_fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="indexLabel">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Index</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="type">tab</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkVBox" id="viewVbox">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="homogeneous">False</property>
+		      <property name="spacing">0</property>
+
+		      <child>
+			<placeholder/>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="tab_expand">False</property>
+		      <property name="tab_fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="viewLabel">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">View</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="type">tab</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">4</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="shrink">True</property>
+	      <property name="resize">True</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">4</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkHBox" id="mainHbox">
+	  <property name="visible">True</property>
+	  <property name="homogeneous">False</property>
+	  <property name="spacing">0</property>
+
+	  <child>
+	    <widget class="GtkProgressBar" id="mainProgressbar">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="orientation">GTK_PROGRESS_LEFT_TO_RIGHT</property>
+	      <property name="fraction">0</property>
+	      <property name="pulse_step">0.10000000149</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkStatusbar" id="mainStatusbar">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="has_resize_grip">True</property>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">True</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">False</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+<widget class="GtkDialog" id="aboutDialog">
+  <property agent="glademm" name="cxx_visibility">public</property>
+  <property name="visible">True</property>
+  <property name="title" translatable="yes">About Pinot</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_NONE</property>
+  <property name="modal">False</property>
+  <property name="resizable">False</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+  <property name="has_separator">True</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="dialog-vbox1">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="dialog-action_area1">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="closebutton1">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-close</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-7</property>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkVBox" id="aboutVbox">
+	  <property name="visible">True</property>
+	  <property name="homogeneous">False</property>
+	  <property name="spacing">0</property>
+
+	  <child>
+	    <widget class="GtkImage" id="pinotImage">
+	      <property name="visible">True</property>
+	      <property name="pixbuf">pinot.png</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">True</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="nameLabel">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Pinot</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">4</property>
+	      <property name="ypad">4</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="descriptionLabel">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">A metasearch tool for the Free Desktop.</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_CENTER</property>
+	      <property name="wrap">True</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">4</property>
+	      <property name="ypad">4</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="copyrightLabel">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Copyright (C) 2005 Fabrice Colin</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_CENTER</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">4</property>
+	      <property name="ypad">4</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkImage" id="xapianImage">
+	      <property name="visible">True</property>
+	      <property name="pixbuf">xapian-powered.png</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">True</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+<widget class="GtkDialog" id="prefsDialog">
+  <property agent="glademm" name="cxx_visibility">public</property>
+  <property name="visible">True</property>
+  <property name="title" translatable="yes">Preferences</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_NONE</property>
+  <property name="modal">False</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+  <property name="has_separator">True</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="dialog-vbox2">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="dialog-action_area2">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="prefsCancelbutton">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-cancel</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-6</property>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="prefsOkbutton">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-ok</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-5</property>
+	      <signal name="clicked" handler="on_prefsOkbutton_clicked" last_modification_time="Sun, 22 Jun 2003 17:37:34 GMT"/>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkNotebook" id="prefsNotebook">
+	  <property agent="glademm" name="cxx_visibility">protected</property>
+	  <property name="visible">True</property>
+	  <property name="can_focus">True</property>
+	  <property name="show_tabs">True</property>
+	  <property name="show_border">True</property>
+	  <property name="tab_pos">GTK_POS_TOP</property>
+	  <property name="scrollable">False</property>
+	  <property name="enable_popup">False</property>
+
+	  <child>
+	    <widget class="GtkTable" id="generalTable">
+	      <property name="visible">True</property>
+	      <property name="n_rows">4</property>
+	      <property name="n_columns">2</property>
+	      <property name="homogeneous">False</property>
+	      <property name="row_spacing">0</property>
+	      <property name="column_spacing">0</property>
+
+	      <child>
+		<widget class="GtkLabel" id="robotsLabel">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">HTTP crawling:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">4</property>
+		  <property name="ypad">4</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="viewLabel">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">View documents:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">4</property>
+		  <property name="ypad">4</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="browserLabel">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Browser:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">4</property>
+		  <property name="ypad">4</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="apiKeyLabel">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Google API Key:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">4</property>
+		  <property name="ypad">4</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">3</property>
+		  <property name="bottom_attach">4</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkEntry" id="apiKeyEntry">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">True</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">3</property>
+		  <property name="bottom_attach">4</property>
+		  <property name="x_padding">4</property>
+		  <property name="y_padding">4</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkComboBox" id="viewCombobox">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="add_tearoffs">False</property>
+		  <property name="focus_on_click">True</property>
+		  <signal name="changed" handler="on_viewCombobox_changed" last_modification_time="Sun, 17 Apr 2005 05:53:46 GMT"/>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_padding">4</property>
+		  <property name="y_padding">4</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkCheckButton" id="ignoreRobotsCheckbutton">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">Ignore robots.txt and Robots META tag</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <property name="active">False</property>
+		  <property name="inconsistent">False</property>
+		  <property name="draw_indicator">True</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_padding">4</property>
+		  <property name="y_padding">4</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHBox" id="browserHbox">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkEntry" id="browserEntry">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">True</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="browserButton">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label" translatable="yes">...</property>
+		      <property name="use_underline">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="on_browserButton_clicked" last_modification_time="Sun, 10 Aug 2003 10:20:18 GMT"/>
+		    </widget>
+		    <packing>
+		      <property name="padding">4</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="x_padding">4</property>
+		  <property name="y_padding">4</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="generalLabel">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">General</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkVBox" id="labelsVbox">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkLabel" id="indexLabelsLabel">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Labels are used to classify indexed documents:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">True</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">4</property>
+		  <property name="ypad">4</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="padding">4</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHBox" id="labelsHbox">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkScrolledWindow" id="labelsScrolledwindow">
+		      <property name="border_width">4</property>
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="hscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		      <property name="vscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		      <property name="shadow_type">GTK_SHADOW_NONE</property>
+		      <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+
+		      <child>
+			<widget class="GtkTreeView" id="labelsTreeview">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="headers_visible">True</property>
+			  <property name="rules_hint">False</property>
+			  <property name="reorderable">False</property>
+			  <property name="enable_search">True</property>
+			  <property name="fixed_height_mode">True</property>
+			  <property name="hover_selection">False</property>
+			  <property name="hover_expand">False</property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkVButtonBox" id="labelsVbuttonbox">
+		      <property name="visible">True</property>
+		      <property name="layout_style">GTK_BUTTONBOX_START</property>
+		      <property name="spacing">0</property>
+
+		      <child>
+			<widget class="GtkButton" id="addLabelButton">
+			  <property name="border_width">4</property>
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_default">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="relief">GTK_RELIEF_NORMAL</property>
+			  <property name="focus_on_click">True</property>
+			  <signal name="clicked" handler="on_addLabelButton_clicked" last_modification_time="Wed, 28 Apr 2004 17:31:55 GMT"/>
+
+			  <child>
+			    <widget class="GtkAlignment" id="alignment17">
+			      <property name="visible">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xscale">0</property>
+			      <property name="yscale">0</property>
+			      <property name="top_padding">0</property>
+			      <property name="bottom_padding">0</property>
+			      <property name="left_padding">0</property>
+			      <property name="right_padding">0</property>
+
+			      <child>
+				<widget class="GtkHBox" id="hbox29">
+				  <property name="visible">True</property>
+				  <property name="homogeneous">False</property>
+				  <property name="spacing">2</property>
+
+				  <child>
+				    <widget class="GtkImage" id="image235">
+				      <property name="visible">True</property>
+				      <property name="stock">gtk-add</property>
+				      <property name="icon_size">4</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkLabel" id="label35">
+				      <property name="visible">True</property>
+				      <property name="label" translatable="yes">Add</property>
+				      <property name="use_underline">True</property>
+				      <property name="use_markup">False</property>
+				      <property name="justify">GTK_JUSTIFY_LEFT</property>
+				      <property name="wrap">False</property>
+				      <property name="selectable">False</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				      <property name="width_chars">-1</property>
+				      <property name="single_line_mode">False</property>
+				      <property name="angle">0</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+				</widget>
+			      </child>
+			    </widget>
+			  </child>
+			</widget>
+		      </child>
+
+		      <child>
+			<widget class="GtkButton" id="editLabelButton">
+			  <property name="border_width">4</property>
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_default">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="relief">GTK_RELIEF_NORMAL</property>
+			  <property name="focus_on_click">True</property>
+			  <signal name="clicked" handler="on_editLabelButton_clicked" last_modification_time="Wed, 28 Apr 2004 17:31:45 GMT"/>
+
+			  <child>
+			    <widget class="GtkAlignment" id="alignment19">
+			      <property name="visible">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xscale">0</property>
+			      <property name="yscale">0</property>
+			      <property name="top_padding">0</property>
+			      <property name="bottom_padding">0</property>
+			      <property name="left_padding">0</property>
+			      <property name="right_padding">0</property>
+
+			      <child>
+				<widget class="GtkHBox" id="hbox31">
+				  <property name="visible">True</property>
+				  <property name="homogeneous">False</property>
+				  <property name="spacing">2</property>
+
+				  <child>
+				    <widget class="GtkImage" id="image237">
+				      <property name="visible">True</property>
+				      <property name="stock">gtk-select-color</property>
+				      <property name="icon_size">4</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkLabel" id="label37">
+				      <property name="visible">True</property>
+				      <property name="label" translatable="yes">Edit</property>
+				      <property name="use_underline">True</property>
+				      <property name="use_markup">False</property>
+				      <property name="justify">GTK_JUSTIFY_LEFT</property>
+				      <property name="wrap">False</property>
+				      <property name="selectable">False</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				      <property name="width_chars">-1</property>
+				      <property name="single_line_mode">False</property>
+				      <property name="angle">0</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+				</widget>
+			      </child>
+			    </widget>
+			  </child>
+			</widget>
+		      </child>
+
+		      <child>
+			<widget class="GtkButton" id="removeLabelButton">
+			  <property name="border_width">4</property>
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_default">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="relief">GTK_RELIEF_NORMAL</property>
+			  <property name="focus_on_click">True</property>
+			  <signal name="clicked" handler="on_removeLabelButton_clicked" last_modification_time="Wed, 28 Apr 2004 17:32:01 GMT"/>
+
+			  <child>
+			    <widget class="GtkAlignment" id="alignment18">
+			      <property name="visible">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xscale">0</property>
+			      <property name="yscale">0</property>
+			      <property name="top_padding">0</property>
+			      <property name="bottom_padding">0</property>
+			      <property name="left_padding">0</property>
+			      <property name="right_padding">0</property>
+
+			      <child>
+				<widget class="GtkHBox" id="hbox30">
+				  <property name="visible">True</property>
+				  <property name="homogeneous">False</property>
+				  <property name="spacing">2</property>
+
+				  <child>
+				    <widget class="GtkImage" id="image236">
+				      <property name="visible">True</property>
+				      <property name="stock">gtk-remove</property>
+				      <property name="icon_size">4</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkLabel" id="label36">
+				      <property name="visible">True</property>
+				      <property name="label" translatable="yes">Remove</property>
+				      <property name="use_underline">True</property>
+				      <property name="use_markup">False</property>
+				      <property name="justify">GTK_JUSTIFY_LEFT</property>
+				      <property name="wrap">False</property>
+				      <property name="selectable">False</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				      <property name="width_chars">-1</property>
+				      <property name="single_line_mode">False</property>
+				      <property name="angle">0</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+				</widget>
+			      </child>
+			    </widget>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">4</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="labelsLabel">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Labels</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkVBox" id="mailVbox">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkLabel" id="mailAccountsLabel">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Mail boxes of type mbox can be monitored and indexed:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">True</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">4</property>
+		  <property name="ypad">4</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="padding">4</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkHBox" id="mailHbox">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkScrolledWindow" id="mailScrolledwindow">
+		      <property name="border_width">4</property>
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="hscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		      <property name="vscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		      <property name="shadow_type">GTK_SHADOW_NONE</property>
+		      <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+
+		      <child>
+			<widget class="GtkTreeView" id="mailTreeview">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="headers_visible">True</property>
+			  <property name="rules_hint">False</property>
+			  <property name="reorderable">False</property>
+			  <property name="enable_search">True</property>
+			  <property name="fixed_height_mode">True</property>
+			  <property name="hover_selection">False</property>
+			  <property name="hover_expand">False</property>
+			  <signal name="button_press_event" handler="on_mailTreeview_button_press_event" last_modification_time="Sat, 19 Mar 2005 10:05:34 GMT"/>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkVButtonBox" id="mailVbuttonbox">
+		      <property name="visible">True</property>
+		      <property name="layout_style">GTK_BUTTONBOX_START</property>
+		      <property name="spacing">0</property>
+
+		      <child>
+			<widget class="GtkButton" id="addAccountButton">
+			  <property name="border_width">4</property>
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_default">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="relief">GTK_RELIEF_NORMAL</property>
+			  <property name="focus_on_click">True</property>
+			  <signal name="clicked" handler="on_addAccountButton_clicked" last_modification_time="Tue, 20 Sep 2005 13:19:44 GMT"/>
+
+			  <child>
+			    <widget class="GtkAlignment" id="alignment28">
+			      <property name="visible">True</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xscale">0</property>
+			      <property name="yscale">0</property>
+			      <property name="top_padding">0</property>
+			      <property name="bottom_padding">0</property>
+			      <property name="left_padding">0</property>
+			      <property name="right_padding">0</property>
+
+			      <child>
+				<widget class="GtkHBox" id="hbox42">
+				  <property name="visible">True</property>
+				  <property name="homogeneous">False</property>
+				  <property name="spacing">2</property>
+
+				  <child>
+				    <widget class="GtkImage" id="image497">
+				      <property name="visible">True</property>
+				      <property name="stock">gtk-add</property>
+				      <property name="icon_size">4</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+
+				  <child>
+				    <widget class="GtkLabel" id="label49">
+				      <property name="visible">True</property>
+				      <property name="label" translatable="yes">Add</property>
+				      <property name="use_underline">True</property>
+				      <property name="use_markup">False</property>
+				      <property name="justify">GTK_JUSTIFY_LEFT</property>
+				      <property name="wrap">False</property>
+				      <property name="selectable">False</property>
+				      <property name="xalign">0.5</property>
+				      <property name="yalign">0.5</property>
+				      <property name="xpad">0</property>
+				      <property name="ypad">0</property>
+				      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				      <property name="width_chars">-1</property>
+				      <property name="single_line_mode">False</property>
+				      <property name="angle">0</property>
+				    </widget>
+				    <packing>
+				      <property name="padding">0</property>
+				      <property name="expand">False</property>
+				      <property name="fill">False</property>
+				    </packing>
+				  </child>
+				</widget>
+			      </child>
+			    </widget>
+			  </child>
+			</widget>
+		      </child>
+
+		      <child>
+			<widget class="GtkButton" id="editAccountButton">
+			  <property name="border_width">4</property>
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_default">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="label">gtk-edit</property>
+			  <property name="use_stock">True</property>
+			  <property name="relief">GTK_RELIEF_NORMAL</property>
+			  <property name="focus_on_click">True</property>
+			  <signal name="clicked" handler="on_editAccountButton_clicked" last_modification_time="Fri, 02 Sep 2005 21:58:38 GMT"/>
+			</widget>
+		      </child>
+
+		      <child>
+			<widget class="GtkButton" id="removeAccountButton">
+			  <property name="border_width">4</property>
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_default">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="label">gtk-remove</property>
+			  <property name="use_stock">True</property>
+			  <property name="relief">GTK_RELIEF_NORMAL</property>
+			  <property name="focus_on_click">True</property>
+			  <signal name="clicked" handler="on_removeAccountButton_clicked" last_modification_time="Fri, 02 Sep 2005 21:58:06 GMT"/>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">4</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="mailLabel">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">My Email</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+<widget class="GtkDialog" id="queryDialog">
+  <property agent="glademm" name="cxx_visibility">public</property>
+  <property name="visible">True</property>
+  <property name="title" translatable="yes">Query properties</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_NONE</property>
+  <property name="modal">False</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+  <property name="has_separator">True</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="dialog-vbox3">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="dialog-action_area3">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="queryCancelbutton">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-cancel</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-6</property>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="queryOkbutton">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-ok</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-5</property>
+	      <signal name="clicked" handler="on_queryOkbutton_clicked" last_modification_time="Sat, 14 Jun 2003 10:48:48 GMT"/>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkVBox" id="queryVbox">
+	  <property name="visible">True</property>
+	  <property name="homogeneous">False</property>
+	  <property name="spacing">0</property>
+
+	  <child>
+	    <widget class="GtkTable" id="table1">
+	      <property name="visible">True</property>
+	      <property name="n_rows">1</property>
+	      <property name="n_columns">2</property>
+	      <property name="homogeneous">False</property>
+	      <property name="row_spacing">0</property>
+	      <property name="column_spacing">0</property>
+
+	      <child>
+		<widget class="GtkLabel" id="nameLabel">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Name:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">4</property>
+		  <property name="ypad">4</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkEntry" id="nameEntry">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">True</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		  <signal name="changed" handler="on_nameEntry_changed" last_modification_time="Fri, 18 Feb 2005 18:20:44 GMT"/>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_padding">4</property>
+		  <property name="y_padding">4</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkNotebook" id="queryNotebook">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="show_tabs">True</property>
+	      <property name="show_border">True</property>
+	      <property name="tab_pos">GTK_POS_TOP</property>
+	      <property name="scrollable">False</property>
+	      <property name="enable_popup">False</property>
+
+	      <child>
+		<widget class="GtkVBox" id="termsVbox">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkTable" id="tersmTable">
+		      <property name="visible">True</property>
+		      <property name="n_rows">5</property>
+		      <property name="n_columns">2</property>
+		      <property name="homogeneous">False</property>
+		      <property name="row_spacing">0</property>
+		      <property name="column_spacing">0</property>
+
+		      <child>
+			<widget class="GtkEntry" id="anyEntry">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="editable">True</property>
+			  <property name="visibility">True</property>
+			  <property name="max_length">0</property>
+			  <property name="text" translatable="yes"></property>
+			  <property name="has_frame">True</property>
+			  <property name="invisible_char">*</property>
+			  <property name="activates_default">False</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">1</property>
+			  <property name="right_attach">2</property>
+			  <property name="top_attach">0</property>
+			  <property name="bottom_attach">1</property>
+			  <property name="x_padding">4</property>
+			  <property name="y_padding">4</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkEntry" id="hostNameEntry">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="editable">True</property>
+			  <property name="visibility">True</property>
+			  <property name="max_length">0</property>
+			  <property name="text" translatable="yes"></property>
+			  <property name="has_frame">True</property>
+			  <property name="invisible_char">*</property>
+			  <property name="activates_default">False</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">1</property>
+			  <property name="right_attach">2</property>
+			  <property name="top_attach">1</property>
+			  <property name="bottom_attach">2</property>
+			  <property name="x_padding">4</property>
+			  <property name="y_padding">4</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkEntry" id="fileNameEntry">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="editable">True</property>
+			  <property name="visibility">True</property>
+			  <property name="max_length">0</property>
+			  <property name="text" translatable="yes"></property>
+			  <property name="has_frame">True</property>
+			  <property name="invisible_char">*</property>
+			  <property name="activates_default">False</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">1</property>
+			  <property name="right_attach">2</property>
+			  <property name="top_attach">2</property>
+			  <property name="bottom_attach">3</property>
+			  <property name="x_padding">4</property>
+			  <property name="y_padding">4</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkSpinButton" id="resultsCountSpinbutton">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="climb_rate">1</property>
+			  <property name="digits">0</property>
+			  <property name="numeric">False</property>
+			  <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+			  <property name="snap_to_ticks">False</property>
+			  <property name="wrap">False</property>
+			  <property name="adjustment">10 10 100 10 20 20</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">1</property>
+			  <property name="right_attach">2</property>
+			  <property name="top_attach">3</property>
+			  <property name="bottom_attach">4</property>
+			  <property name="x_padding">4</property>
+			  <property name="y_padding">4</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkCheckButton" id="indexCheckbutton">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="label" translatable="yes">Index all results with label</property>
+			  <property name="use_underline">True</property>
+			  <property name="relief">GTK_RELIEF_NORMAL</property>
+			  <property name="focus_on_click">True</property>
+			  <property name="active">False</property>
+			  <property name="inconsistent">False</property>
+			  <property name="draw_indicator">True</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">0</property>
+			  <property name="right_attach">1</property>
+			  <property name="top_attach">4</property>
+			  <property name="bottom_attach">5</property>
+			  <property name="x_padding">4</property>
+			  <property name="y_padding">4</property>
+			  <property name="x_options">fill</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="anyLabel">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">Any of the words:</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">4</property>
+			  <property name="ypad">4</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">0</property>
+			  <property name="right_attach">1</property>
+			  <property name="top_attach">0</property>
+			  <property name="bottom_attach">1</property>
+			  <property name="x_options">fill</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="hostLabel">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">Host name:</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">4</property>
+			  <property name="ypad">4</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">0</property>
+			  <property name="right_attach">1</property>
+			  <property name="top_attach">1</property>
+			  <property name="bottom_attach">2</property>
+			  <property name="x_options">fill</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="fileNameLabel">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">File name:</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">4</property>
+			  <property name="ypad">4</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">0</property>
+			  <property name="right_attach">1</property>
+			  <property name="top_attach">2</property>
+			  <property name="bottom_attach">3</property>
+			  <property name="x_options">fill</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="resultsCountLabel">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">Number of results:</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">4</property>
+			  <property name="ypad">4</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">0</property>
+			  <property name="right_attach">1</property>
+			  <property name="top_attach">3</property>
+			  <property name="bottom_attach">4</property>
+			  <property name="x_options">fill</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkComboBox" id="labelCombobox">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="add_tearoffs">False</property>
+			  <property name="focus_on_click">True</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">1</property>
+			  <property name="right_attach">2</property>
+			  <property name="top_attach">4</property>
+			  <property name="bottom_attach">5</property>
+			  <property name="x_padding">4</property>
+			  <property name="y_padding">4</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">4</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="tab_expand">False</property>
+		  <property name="tab_fill">True</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="propertiesLabel">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Properties</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="type">tab</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkVBox" id="advancedVbox">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkLabel" id="filtersLabel">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Limit to documents that match</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">4</property>
+		      <property name="ypad">4</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">4</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkTable" id="advancedTable">
+		      <property name="visible">True</property>
+		      <property name="n_rows">4</property>
+		      <property name="n_columns">2</property>
+		      <property name="homogeneous">False</property>
+		      <property name="row_spacing">0</property>
+		      <property name="column_spacing">0</property>
+
+		      <child>
+			<widget class="GtkEntry" id="phraseEntry">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="editable">True</property>
+			  <property name="visibility">True</property>
+			  <property name="max_length">0</property>
+			  <property name="text" translatable="yes"></property>
+			  <property name="has_frame">True</property>
+			  <property name="invisible_char">*</property>
+			  <property name="activates_default">False</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">1</property>
+			  <property name="right_attach">2</property>
+			  <property name="top_attach">1</property>
+			  <property name="bottom_attach">2</property>
+			  <property name="x_padding">4</property>
+			  <property name="y_padding">4</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkEntry" id="notEntry">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="editable">True</property>
+			  <property name="visibility">True</property>
+			  <property name="max_length">0</property>
+			  <property name="text" translatable="yes"></property>
+			  <property name="has_frame">True</property>
+			  <property name="invisible_char">*</property>
+			  <property name="activates_default">False</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">1</property>
+			  <property name="right_attach">2</property>
+			  <property name="top_attach">2</property>
+			  <property name="bottom_attach">3</property>
+			  <property name="x_padding">4</property>
+			  <property name="y_padding">4</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="phraseLabel">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">the exact phrase:</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">4</property>
+			  <property name="ypad">4</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">0</property>
+			  <property name="right_attach">1</property>
+			  <property name="top_attach">1</property>
+			  <property name="bottom_attach">2</property>
+			  <property name="x_options">fill</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="notLabel">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">none of the words:</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">4</property>
+			  <property name="ypad">4</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">0</property>
+			  <property name="right_attach">1</property>
+			  <property name="top_attach">2</property>
+			  <property name="bottom_attach">3</property>
+			  <property name="x_options">fill</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="label14">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">the language:</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">4</property>
+			  <property name="ypad">4</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">0</property>
+			  <property name="right_attach">1</property>
+			  <property name="top_attach">3</property>
+			  <property name="bottom_attach">4</property>
+			  <property name="x_options">fill</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkComboBox" id="languageCombobox">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="add_tearoffs">False</property>
+			  <property name="focus_on_click">True</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">1</property>
+			  <property name="right_attach">2</property>
+			  <property name="top_attach">3</property>
+			  <property name="bottom_attach">4</property>
+			  <property name="x_padding">4</property>
+			  <property name="y_padding">4</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkEntry" id="andEntry">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="editable">True</property>
+			  <property name="visibility">True</property>
+			  <property name="max_length">0</property>
+			  <property name="text" translatable="yes"></property>
+			  <property name="has_frame">True</property>
+			  <property name="invisible_char">*</property>
+			  <property name="activates_default">False</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">1</property>
+			  <property name="right_attach">2</property>
+			  <property name="top_attach">0</property>
+			  <property name="bottom_attach">1</property>
+			  <property name="x_padding">4</property>
+			  <property name="y_padding">4</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="andLabel">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">all the words:</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">4</property>
+			  <property name="ypad">4</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">0</property>
+			  <property name="right_attach">1</property>
+			  <property name="top_attach">0</property>
+			  <property name="bottom_attach">1</property>
+			  <property name="x_options">fill</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="tab_expand">False</property>
+		  <property name="tab_fill">True</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="advancedLabel">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Advanced</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="type">tab</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">True</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+<widget class="GtkDialog" id="importDialog">
+  <property agent="glademm" name="cxx_visibility">public</property>
+  <property name="visible">True</property>
+  <property name="title" translatable="yes">Import document</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_NONE</property>
+  <property name="modal">False</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+  <property name="has_separator">True</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="dialog-vbox4">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="dialog-action_area4">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="cancelbutton1">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-cancel</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-6</property>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="importOkButton">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-ok</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-5</property>
+	      <signal name="clicked" handler="on_importOkButton_clicked" last_modification_time="Sun, 18 Sep 2005 05:13:29 GMT"/>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkTable" id="docTable">
+	  <property agent="glademm" name="cxx_visibility">protected</property>
+	  <property name="visible">True</property>
+	  <property name="n_rows">4</property>
+	  <property name="n_columns">3</property>
+	  <property name="homogeneous">False</property>
+	  <property name="row_spacing">0</property>
+	  <property name="column_spacing">0</property>
+
+	  <child>
+	    <widget class="GtkHButtonBox" id="hbuttonbox3">
+	      <property name="visible">True</property>
+	      <property name="layout_style">GTK_BUTTONBOX_DEFAULT_STYLE</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkButton" id="selectButton">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="can_default">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <signal name="clicked" handler="on_selectButton_clicked" last_modification_time="Tue, 09 Mar 2004 19:27:45 GMT"/>
+
+		  <child>
+		    <widget class="GtkAlignment" id="alignment9">
+		      <property name="visible">True</property>
+		      <property name="xalign">0.5</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xscale">0</property>
+		      <property name="yscale">0</property>
+		      <property name="top_padding">0</property>
+		      <property name="bottom_padding">0</property>
+		      <property name="left_padding">0</property>
+		      <property name="right_padding">0</property>
+
+		      <child>
+			<widget class="GtkHBox" id="hbox14">
+			  <property name="visible">True</property>
+			  <property name="homogeneous">False</property>
+			  <property name="spacing">2</property>
+
+			  <child>
+			    <widget class="GtkImage" id="image180">
+			      <property name="visible">True</property>
+			      <property name="stock">gtk-open</property>
+			      <property name="icon_size">4</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkLabel" id="label17">
+			      <property name="visible">True</property>
+			      <property name="label" translatable="yes">Select</property>
+			      <property name="use_underline">True</property>
+			      <property name="use_markup">False</property>
+			      <property name="justify">GTK_JUSTIFY_LEFT</property>
+			      <property name="wrap">False</property>
+			      <property name="selectable">False</property>
+			      <property name="xalign">0.5</property>
+			      <property name="yalign">0.5</property>
+			      <property name="xpad">0</property>
+			      <property name="ypad">0</property>
+			      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			      <property name="width_chars">-1</property>
+			      <property name="single_line_mode">False</property>
+			      <property name="angle">0</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+			</widget>
+		      </child>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">2</property>
+	      <property name="right_attach">3</property>
+	      <property name="top_attach">3</property>
+	      <property name="bottom_attach">4</property>
+	      <property name="x_padding">4</property>
+	      <property name="y_padding">4</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkEntry" id="locationEntry">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="editable">True</property>
+	      <property name="visibility">True</property>
+	      <property name="max_length">0</property>
+	      <property name="text" translatable="yes"></property>
+	      <property name="has_frame">True</property>
+	      <property name="invisible_char">*</property>
+	      <property name="activates_default">False</property>
+	      <signal name="changed" handler="on_locationEntry_changed" last_modification_time="Sun, 18 Sep 2005 03:55:37 GMT"/>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">1</property>
+	      <property name="right_attach">2</property>
+	      <property name="top_attach">3</property>
+	      <property name="bottom_attach">4</property>
+	      <property name="x_padding">4</property>
+	      <property name="y_padding">4</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkEntry" id="titleEntry">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="editable">True</property>
+	      <property name="visibility">True</property>
+	      <property name="max_length">0</property>
+	      <property name="text" translatable="yes"></property>
+	      <property name="has_frame">True</property>
+	      <property name="invisible_char">*</property>
+	      <property name="activates_default">False</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">1</property>
+	      <property name="right_attach">2</property>
+	      <property name="top_attach">1</property>
+	      <property name="bottom_attach">2</property>
+	      <property name="x_padding">4</property>
+	      <property name="y_padding">4</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="locationLabel">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Location:</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">4</property>
+	      <property name="ypad">4</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">0</property>
+	      <property name="right_attach">1</property>
+	      <property name="top_attach">3</property>
+	      <property name="bottom_attach">4</property>
+	      <property name="x_options">fill</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="titleLabel">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Title:</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">4</property>
+	      <property name="ypad">4</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">0</property>
+	      <property name="right_attach">1</property>
+	      <property name="top_attach">1</property>
+	      <property name="bottom_attach">2</property>
+	      <property name="x_options">fill</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="depthLabel">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Maximum depth:</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">4</property>
+	      <property name="ypad">4</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">0</property>
+	      <property name="right_attach">1</property>
+	      <property name="top_attach">2</property>
+	      <property name="bottom_attach">3</property>
+	      <property name="x_options">fill</property>
+	      <property name="y_options"></property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkSpinButton" id="depthSpinbutton">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="climb_rate">1</property>
+	      <property name="digits">0</property>
+	      <property name="numeric">False</property>
+	      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+	      <property name="snap_to_ticks">False</property>
+	      <property name="wrap">False</property>
+	      <property name="adjustment">0 0 100 1 5 5</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">1</property>
+	      <property name="right_attach">2</property>
+	      <property name="top_attach">2</property>
+	      <property name="bottom_attach">3</property>
+	      <property name="x_padding">4</property>
+	      <property name="y_padding">4</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkComboBox" id="typeCombobox">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="items" translatable="yes"></property>
+	      <property name="add_tearoffs">False</property>
+	      <property name="focus_on_click">True</property>
+	      <signal name="changed" handler="on_typeCombobox_changed" last_modification_time="Sun, 18 Sep 2005 04:09:29 GMT"/>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">1</property>
+	      <property name="right_attach">2</property>
+	      <property name="top_attach">0</property>
+	      <property name="bottom_attach">1</property>
+	      <property name="x_padding">4</property>
+	      <property name="y_padding">4</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="typeLabel">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Type:</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">4</property>
+	      <property name="ypad">4</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">0</property>
+	      <property name="right_attach">1</property>
+	      <property name="top_attach">0</property>
+	      <property name="bottom_attach">1</property>
+	      <property name="x_options">fill</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+<widget class="GtkDialog" id="propertiesDialog">
+  <property agent="glademm" name="cxx_visibility">public</property>
+  <property name="visible">True</property>
+  <property name="title" translatable="yes">Properties</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_NONE</property>
+  <property name="modal">False</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+  <property name="has_separator">True</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="dialog-vbox5">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="dialog-action_area5">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="cancelbutton2">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-cancel</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-6</property>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="labelOkButton">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-ok</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-5</property>
+	      <signal name="clicked" handler="on_labelOkButton_clicked" last_modification_time="Sun, 05 Sep 2004 10:29:09 GMT"/>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkVBox" id="propertiesVbox">
+	  <property name="visible">True</property>
+	  <property name="homogeneous">False</property>
+	  <property name="spacing">0</property>
+
+	  <child>
+	    <widget class="GtkTable" id="propertiesTable">
+	      <property name="visible">True</property>
+	      <property name="n_rows">4</property>
+	      <property name="n_columns">2</property>
+	      <property name="homogeneous">False</property>
+	      <property name="row_spacing">0</property>
+	      <property name="column_spacing">0</property>
+
+	      <child>
+		<widget class="GtkEntry" id="titleEntry">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">True</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_padding">4</property>
+		  <property name="y_padding">4</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkScrolledWindow" id="extractScrolledwindow">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="hscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		  <property name="vscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		  <property name="shadow_type">GTK_SHADOW_IN</property>
+		  <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+
+		  <child>
+		    <widget class="GtkTextView" id="extractTextview">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">True</property>
+		      <property name="overwrite">False</property>
+		      <property name="accepts_tab">True</property>
+		      <property name="justification">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap_mode">GTK_WRAP_NONE</property>
+		      <property name="cursor_visible">True</property>
+		      <property name="pixels_above_lines">0</property>
+		      <property name="pixels_below_lines">0</property>
+		      <property name="pixels_inside_wrap">0</property>
+		      <property name="left_margin">3</property>
+		      <property name="right_margin">0</property>
+		      <property name="indent">0</property>
+		      <property name="text" translatable="yes"></property>
+		    </widget>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_padding">4</property>
+		  <property name="y_padding">4</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="titleLabel">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Title:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">4</property>
+		  <property name="ypad">4</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="extractLabel">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Extract:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">4</property>
+		  <property name="ypad">4</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="languageLabel">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Language:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">4</property>
+		  <property name="ypad">4</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkEntry" id="languageEntry">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="x_padding">4</property>
+		  <property name="y_padding">4</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="typeLabel">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Type:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">4</property>
+		  <property name="ypad">4</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">3</property>
+		  <property name="bottom_attach">4</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkEntry" id="typeEntry">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">3</property>
+		  <property name="bottom_attach">4</property>
+		  <property name="x_padding">4</property>
+		  <property name="y_padding">4</property>
+		  <property name="y_options">fill</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">False</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkScrolledWindow" id="labelsScrolledwindow">
+	      <property name="border_width">4</property>
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="hscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+	      <property name="vscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+	      <property name="shadow_type">GTK_SHADOW_NONE</property>
+	      <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+
+	      <child>
+		<widget class="GtkViewport" id="viewport1">
+		  <property name="visible">True</property>
+		  <property name="shadow_type">GTK_SHADOW_IN</property>
+
+		  <child>
+		    <widget class="GtkTreeView" id="labelsTreeview">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="headers_visible">True</property>
+		      <property name="rules_hint">False</property>
+		      <property name="reorderable">False</property>
+		      <property name="enable_search">True</property>
+		      <property name="fixed_height_mode">False</property>
+		      <property name="hover_selection">False</property>
+		      <property name="hover_expand">False</property>
+		    </widget>
+		  </child>
+		</widget>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">True</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+<widget class="GtkDialog" id="indexDialog">
+  <property name="visible">True</property>
+  <property name="title" translatable="yes">External index</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_NONE</property>
+  <property name="modal">False</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+  <property name="has_separator">True</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="dialog-vbox6">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="dialog-action_area6">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="indexCancelbutton">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-cancel</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-6</property>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="indexOkbutton">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-ok</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-5</property>
+	      <signal name="clicked" handler="on_indexOkbutton_clicked" last_modification_time="Tue, 15 Feb 2005 18:12:56 GMT"/>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkTable" id="indexTable">
+	  <property name="visible">True</property>
+	  <property name="n_rows">4</property>
+	  <property name="n_columns">2</property>
+	  <property name="homogeneous">False</property>
+	  <property name="row_spacing">0</property>
+	  <property name="column_spacing">0</property>
+
+	  <child>
+	    <widget class="GtkLabel" id="nameLabel">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Name:</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">4</property>
+	      <property name="ypad">4</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">0</property>
+	      <property name="right_attach">1</property>
+	      <property name="top_attach">0</property>
+	      <property name="bottom_attach">1</property>
+	      <property name="x_options">fill</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkHBox" id="locationHbox">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkEntry" id="locationEntry">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">True</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		  <signal name="changed" handler="on_locationEntry_changed" last_modification_time="Tue, 15 Feb 2005 18:12:43 GMT"/>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkButton" id="locationButton">
+		  <property agent="glademm" name="cxx_visibility">protected</property>
+		  <property name="visible">True</property>
+		  <property name="can_default">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label" translatable="yes">...</property>
+		  <property name="use_underline">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <signal name="clicked" handler="on_locationButton_clicked" last_modification_time="Tue, 15 Feb 2005 18:12:48 GMT"/>
+		</widget>
+		<packing>
+		  <property name="padding">4</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">1</property>
+	      <property name="right_attach">2</property>
+	      <property name="top_attach">2</property>
+	      <property name="bottom_attach">3</property>
+	      <property name="x_padding">4</property>
+	      <property name="y_padding">4</property>
+	      <property name="x_options">fill</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="typeLabel">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Type:</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">4</property>
+	      <property name="ypad">4</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">0</property>
+	      <property name="right_attach">1</property>
+	      <property name="top_attach">1</property>
+	      <property name="bottom_attach">2</property>
+	      <property name="x_options">fill</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="locationLabel">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Location:</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">4</property>
+	      <property name="ypad">4</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">0</property>
+	      <property name="right_attach">1</property>
+	      <property name="top_attach">2</property>
+	      <property name="bottom_attach">3</property>
+	      <property name="x_options">fill</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="portLabel">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Port:</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">4</property>
+	      <property name="ypad">4</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">0</property>
+	      <property name="right_attach">1</property>
+	      <property name="top_attach">3</property>
+	      <property name="bottom_attach">4</property>
+	      <property name="x_options">fill</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkEntry" id="nameEntry">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="editable">True</property>
+	      <property name="visibility">True</property>
+	      <property name="max_length">0</property>
+	      <property name="text" translatable="yes"></property>
+	      <property name="has_frame">True</property>
+	      <property name="invisible_char">*</property>
+	      <property name="activates_default">False</property>
+	      <signal name="changed" handler="on_nameEntry_changed" last_modification_time="Tue, 15 Feb 2005 18:12:34 GMT"/>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">1</property>
+	      <property name="right_attach">2</property>
+	      <property name="top_attach">0</property>
+	      <property name="bottom_attach">1</property>
+	      <property name="x_padding">4</property>
+	      <property name="y_padding">4</property>
+	      <property name="y_options"></property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkSpinButton" id="portSpinbutton">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="climb_rate">1</property>
+	      <property name="digits">0</property>
+	      <property name="numeric">False</property>
+	      <property name="update_policy">GTK_UPDATE_ALWAYS</property>
+	      <property name="snap_to_ticks">False</property>
+	      <property name="wrap">False</property>
+	      <property name="adjustment">1024 0 65535 1 10 10</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">1</property>
+	      <property name="right_attach">2</property>
+	      <property name="top_attach">3</property>
+	      <property name="bottom_attach">4</property>
+	      <property name="x_padding">4</property>
+	      <property name="y_padding">4</property>
+	      <property name="y_options"></property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkComboBox" id="typeCombobox">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
+	      <property name="visible">True</property>
+	      <property name="items" translatable="yes"></property>
+	      <property name="add_tearoffs">False</property>
+	      <property name="focus_on_click">True</property>
+	      <signal name="changed" handler="on_typeCombobox_changed" last_modification_time="Sun, 17 Apr 2005 04:13:55 GMT"/>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">1</property>
+	      <property name="right_attach">2</property>
+	      <property name="top_attach">1</property>
+	      <property name="bottom_attach">2</property>
+	      <property name="x_padding">4</property>
+	      <property name="y_padding">4</property>
+	      <property name="y_options"></property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
+</glade-interface>


Property changes on: trunk/UI/GTK2/metase-gtk2.glade
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/metase-gtk2.gladep
===================================================================
--- trunk/UI/GTK2/metase-gtk2.gladep	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/metase-gtk2.gladep	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,10 @@
+<?xml version="1.0" standalone="no"?> <!--*- mode: xml -*-->
+<!DOCTYPE glade-project SYSTEM "http://glade.gnome.org/glade-project-2.0.dtd">
+
+<glade-project>
+  <name>metase-gtk2</name>
+  <program_name>pinot</program_name>
+  <language>C++</language>
+  <gnome_support>FALSE</gnome_support>
+  <output_build_files>FALSE</output_build_files>
+</glade-project>


Property changes on: trunk/UI/GTK2/metase-gtk2.gladep
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/pinot.png
===================================================================
(Binary files differ)


Property changes on: trunk/UI/GTK2/pinot.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/UI/GTK2/pinot.xcf
===================================================================
(Binary files differ)


Property changes on: trunk/UI/GTK2/pinot.xcf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/UI/GTK2/src/EnginesTree.cpp
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/EnginesTree.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,355 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+#include <gtkmm/alignment.h>
+#include <gtkmm/box.h>
+#include <gtkmm/buttonbox.h>
+#include <gtkmm/image.h>
+#include <gtkmm/label.h>
+#include <gtkmm/stock.h>
+#include <gtkmm/textbuffer.h>
+
+#include "HtmlTokenizer.h"
+#include "Url.h"
+#include "QueryHistory.h"
+#include "ViewHistory.h"
+#include "config.h"
+#include "NLS.h"
+#include "PinotSettings.h"
+#include "PinotUtils.h"
+#include "EnginesTree.h"
+
+using namespace std;
+using namespace SigC;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+EnginesTree::EnginesTree(VBox *enginesVbox, PinotSettings &settings) :
+	TreeView(),
+	m_settings(settings)
+{
+	ScrolledWindow *enginesScrolledwindow = manage(new ScrolledWindow());
+
+	// This is the actual engines tree
+	set_events(Gdk::BUTTON_PRESS_MASK);
+	set_flags(CAN_FOCUS);
+	set_headers_visible(true);
+	set_reorderable(false);
+	set_enable_search(false);
+	enginesScrolledwindow->set_flags(CAN_FOCUS);
+	enginesScrolledwindow->set_shadow_type(SHADOW_NONE);
+	enginesScrolledwindow->set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
+	enginesScrolledwindow->property_window_placement().set_value(CORNER_TOP_LEFT);
+	enginesScrolledwindow->add(*this);
+
+	// Position the scrolled window
+	enginesVbox->pack_start(*enginesScrolledwindow, Gtk::PACK_EXPAND_WIDGET, 0);
+
+	// Associate the columns model to the engines tree
+	m_refStore = TreeStore::create(m_enginesColumns);
+	set_model(m_refStore);
+
+	TreeViewColumn *treeColumn = new TreeViewColumn(_("Search Engines"));
+	// Pack an icon renderer for engines icons
+	CellRendererPixbuf *iconRenderer = new CellRendererPixbuf();
+	treeColumn->pack_start(*manage(iconRenderer), false);
+	treeColumn->set_cell_data_func(*iconRenderer, SigC::slot(*this, &EnginesTree::renderEngineIcon));
+	treeColumn->pack_end(m_enginesColumns.m_name, false);
+	append_column(*manage(treeColumn));
+
+	// Make headers clickable
+	set_headers_clickable(true);
+	// Allow multiple selection
+	get_selection()->set_mode(SELECTION_MULTIPLE);
+
+	// Handle button presses
+	signal_button_press_event().connect_notify(SigC::slot(*this, &EnginesTree::onButtonPressEvent));
+	// Control which rows can be selected
+	get_selection()->set_select_function(SigC::slot(*this, &EnginesTree::onSelectionSelect));
+	// Listen for style changes
+	signal_style_changed().connect_notify(SigC::slot(*this, &EnginesTree::onStyleChanged));
+
+	// Render the icons
+	m_engineFolderIconPixbuf = render_icon(Stock::DIRECTORY, ICON_SIZE_MENU, "MetaSE-pinot");
+
+	// Populate
+	populate();
+
+	// Show all
+	show();
+	enginesScrolledwindow->show();
+}
+
+EnginesTree::~EnginesTree()
+{
+}
+
+void EnginesTree::renderEngineIcon(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (renderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *iconRenderer = dynamic_cast<CellRendererPixbuf*>(renderer);
+	if (iconRenderer != NULL)
+	{
+		// Is this an engine folder ?
+		if (row[m_enginesColumns.m_type] == EnginesModelColumns::ENGINE_FOLDER)
+		{
+			iconRenderer->property_pixbuf() = m_engineFolderIconPixbuf;
+		}
+		else
+		{
+			iconRenderer->property_pixbuf().reset_value();
+		}
+	}
+}
+
+//
+// Handles button presses.
+//
+void EnginesTree::onButtonPressEvent(GdkEventButton *ev)
+{
+	list<TreeModel::Path> selectedEngines = get_selection()->get_selected_rows();
+	// If there are more than one row selected, don't bother
+	if (selectedEngines.size() != 1)
+	{
+		return;
+	}
+
+	list<TreeModel::Path>::iterator enginePath = selectedEngines.begin();
+	if (enginePath == selectedEngines.end())
+	{
+		return;
+	}
+
+	TreeModel::iterator engineIter = m_refStore->get_iter(*enginePath);
+	TreeModel::Row engineRow = *engineIter;
+
+	// Check for double clicks
+	if (ev->type == GDK_2BUTTON_PRESS)
+	{
+#ifdef DEBUG
+		cout << "EnginesTree::onButtonPressEvent: double click on button " << ev->button << endl;
+#endif
+		// Make sure the engine is an external index
+		EnginesModelColumns::EngineType engineType = engineRow[m_enginesColumns.m_type];
+		if (engineType == EnginesModelColumns::INDEX_ENGINE)
+		{
+			ustring name = engineRow[m_enginesColumns.m_name];
+			ustring location = engineRow[m_enginesColumns.m_option];
+
+			m_signalEdit(name, location);
+		}
+		else
+		{
+			// Is the row already expanded ?
+			if (row_expanded(*enginePath) == false)
+			{
+				// Expand it
+				expand_row(*enginePath, true);
+			}
+			else
+			{
+				// Collapse it
+				collapse_row(*enginePath);
+			}
+		}
+	}
+}
+
+//
+// Handles attempts to select rows.
+//
+bool EnginesTree::onSelectionSelect(const RefPtr<TreeModel>& model,
+		const TreeModel::Path& path, bool path_currently_selected)
+{
+	// All nodes can be selected
+	return true;
+}
+
+//
+// Handles GTK style changes.
+//
+void EnginesTree::onStyleChanged(const RefPtr<Style> &previous_style)
+{
+#ifdef DEBUG
+	cout << "EnginesTree::onStyleChanged: called" << endl;
+#endif
+	// FIXME: find better icons :-)
+	m_engineFolderIconPixbuf = render_icon(Stock::DIRECTORY, ICON_SIZE_MENU, "MetaSE-pinot");
+}
+
+//
+// Gets a list of selected items.
+//
+list<TreeModel::Path> EnginesTree::getSelection(void)
+{
+	return get_selection()->get_selected_rows();
+}
+
+/// Gets an iterator.
+TreeModel::iterator EnginesTree::getIter(TreeModel::Path enginePath)
+{
+	return m_refStore->get_iter(enginePath);
+}
+
+/// Gets the column record.
+EnginesModelColumns &EnginesTree::getColumnRecord(void)
+{
+	return m_enginesColumns;
+}
+
+//
+// Populate the tree.
+//
+void EnginesTree::populate(bool indexesOnly)
+{
+	set<PinotSettings::Engine> engines;
+	TreeModel::Row row;
+
+	// Reset the whole tree
+	get_selection()->unselect_all();
+	m_refStore->clear();
+
+	// Populate the tree with search engines
+	const set<string> &channels = m_settings.getSearchEnginesChannels();
+	for (set<string>::const_iterator channelIter = channels.begin();
+		channelIter != channels.end(); ++channelIter)
+	{
+		string channelName = *channelIter;
+
+		// Enumerate search engines for this channel
+		engines.clear();
+		m_settings.getSearchEngines(engines, channelName);
+
+		if (engines.empty() == true)
+		{
+			continue;
+		}
+
+		TreeModel::iterator folderIter = m_refStore->append();
+		row = *folderIter;
+
+		row[m_enginesColumns.m_name] = to_utf8(channelName);
+		row[m_enginesColumns.m_engineName] = "internal-folder";
+		row[m_enginesColumns.m_option] = "";
+		row[m_enginesColumns.m_type] = EnginesModelColumns::ENGINE_FOLDER;
+
+		// FIXME: for some reason, without "std::"'s the compiler fails with a parse error before the comma
+		std::set<PinotSettings::Engine>::const_iterator engineIter = engines.begin();
+		for (; engineIter != engines.end(); ++engineIter)
+		{
+			string engineName = engineIter->m_name;
+			string engineType = engineIter->m_type;
+
+			if (engineType == "xapian")
+			{
+				// Skip Xapian, it's only usable through a local engine
+				continue;
+			}
+
+			TreeModel::iterator iter = m_refStore->append(folderIter->children());
+			row = *iter;
+
+			row[m_enginesColumns.m_name] = to_utf8(engineName);
+			row[m_enginesColumns.m_engineName] = to_utf8(engineType);
+			// Is this a Sherlock engine ?
+			if (engineType == "sherlock")
+			{
+				row[m_enginesColumns.m_option] = engineIter->m_option;
+			}
+			else
+			{
+				row[m_enginesColumns.m_option] = "";
+			}
+			row[m_enginesColumns.m_type] = EnginesModelColumns::WEB_ENGINE;
+		}
+	}
+
+	// Local engines
+	TreeModel::iterator localIter = m_refStore->append();
+	row = *localIter;
+	row[m_enginesColumns.m_name] = _("Current User");
+	row[m_enginesColumns.m_engineName] = "internal-folder";
+	row[m_enginesColumns.m_option] = "";
+	row[m_enginesColumns.m_type] = EnginesModelColumns::ENGINE_FOLDER;
+
+	// FIXME: for some reason, without "std::"'s the compiler fails with a parse error before the comma
+	std::map<std::string, std::string>::const_iterator indexIter = m_settings.getIndexes().begin();
+	for (; indexIter != m_settings.getIndexes().end(); ++indexIter)
+	{
+		ustring indexName = to_utf8(indexIter->first);
+		EnginesModelColumns::EngineType indexType = EnginesModelColumns::INDEX_ENGINE;
+
+		if (indexName == _("My Documents"))
+		{
+			indexType = EnginesModelColumns::INTERNAL_INDEX_ENGINE;
+		}
+		else if (indexName == _("My Email"))
+		{
+			indexType = EnginesModelColumns::INTERNAL_INDEX_ENGINE;
+		}
+
+		TreeModel::iterator iter = m_refStore->append(localIter->children());
+		TreeModel::Row row = *iter;
+		row[m_enginesColumns.m_name] = indexName;
+		row[m_enginesColumns.m_engineName] = "xapian";
+		row[m_enginesColumns.m_option] = to_utf8(indexIter->second);
+		row[m_enginesColumns.m_type] = indexType;
+	}
+
+	expand_all();
+}
+
+//
+// Clear the tree.
+//
+void EnginesTree::clear(void)
+{
+	// Unselect engines
+	get_selection()->unselect_all();
+
+	// Remove existing rows in the tree
+	TreeModel::Children children = m_refStore->children();
+	if (children.empty() == false)
+	{
+		TreeModel::Children::iterator iter = children.begin();
+		while (iter != children.end())
+		{
+			// Erase this row
+			m_refStore->erase(*iter);
+
+			// Get the new first row
+			children = m_refStore->children();
+			iter = children.begin();
+		}
+		m_refStore->clear();
+	}
+}
+
+//
+// Returns the edit index signal.
+//
+Signal2<void, string, string>& EnginesTree::getEditIndexSignal(void)
+{
+	return m_signalEdit;
+}

Added: trunk/UI/GTK2/src/EnginesTree.h
===================================================================
--- trunk/UI/GTK2/src/EnginesTree.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/EnginesTree.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,90 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _ENGINESTREE_HH
+#define _ENGINESTREE_HH
+
+#include <string>
+#include <vector>
+#include <set>
+#include <map>
+#include <sigc++/slot.h>
+#include <glibmm/refptr.h>
+#include <glibmm/ustring.h>
+#include <gdkmm/pixbuf.h>
+#include <gtkmm/box.h>
+#include <gtkmm/button.h>
+#include <gtkmm/menu.h>
+#include <gtkmm/scrolledwindow.h>
+#include <gtkmm/textview.h>
+#include <gtkmm/treestore.h>
+#include <gtkmm/treeview.h>
+#include <gtkmm/treeselection.h>
+
+#include "QueryProperties.h"
+#include "ModelColumns.h"
+#include "PinotSettings.h"
+
+class EnginesTree : public Gtk::TreeView
+{
+	public:
+		EnginesTree(Gtk::VBox *enginesVbox, PinotSettings &settings);
+		virtual ~EnginesTree();
+
+		/// Gets a list of selected items.
+		std::list<Gtk::TreeModel::Path> getSelection(void);
+
+		/// Gets an iterator.
+		Gtk::TreeModel::iterator getIter(Gtk::TreeModel::Path enginePath);
+
+		/// Gets the column record.
+		EnginesModelColumns &getColumnRecord(void);
+
+		/// Populate the tree.
+		void populate(bool indexesOnly = false);
+
+		/// Clear the tree.
+		void clear(void);
+
+		/// Returns the index edit signal.
+		SigC::Signal2<void, std::string, std::string>& getEditIndexSignal(void);
+
+	protected:
+		Glib::RefPtr<Gtk::TreeStore> m_refStore;
+		PinotSettings &m_settings;
+		Glib::RefPtr<Gdk::Pixbuf> m_engineFolderIconPixbuf;
+		EnginesModelColumns m_enginesColumns;
+		SigC::Signal2<void, std::string, std::string> m_signalEdit;
+
+		void renderEngineIcon(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &iter);
+
+		/// Handles button presses.
+		void onButtonPressEvent(GdkEventButton *ev);
+
+		/// Handles attempts to select rows.
+		bool onSelectionSelect(const Glib::RefPtr<Gtk::TreeModel>& model,
+			const Gtk::TreeModel::Path& path, bool path_currently_selected);
+
+		/// Handles GTK style changes.
+		void onStyleChanged(const Glib::RefPtr<Gtk::Style> &previous_style);
+
+	private:
+		EnginesTree(const EnginesTree &other);
+		EnginesTree &operator=(const EnginesTree &other);
+
+};
+
+#endif // _ENGINESTREE_HH

Added: trunk/UI/GTK2/src/HtmlView.cpp
===================================================================
--- trunk/UI/GTK2/src/HtmlView.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/HtmlView.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,73 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+
+#include <glibmm/wrap.h>
+
+#include "config.h"
+#include "NLS.h"
+#include "HtmlView.h"
+#include "PinotUtils.h"
+
+using namespace Glib;
+using namespace Gtk;
+
+HtmlView::HtmlView(VBox *viewVbox, Menu *pPopupMenu) :
+	MozillaRenderer(),
+	m_pPopupMenu(pPopupMenu)
+{
+	GtkWidget *view = getWidget();
+	if (view != NULL)
+	{
+		// Wrap this into a gtkmm Widget object
+		// FIXME: need manage(wrap()) ?
+		Widget *pDocHtmlView = wrap(view);
+		if ((pDocHtmlView != NULL) &&
+			(viewVbox != NULL))
+		{
+			viewVbox->pack_start(*pDocHtmlView);
+
+			// Handle button presses
+			pDocHtmlView->signal_button_press_event().connect_notify(SigC::slot(*this, &HtmlView::onButtonPressEvent));
+
+			pDocHtmlView->show();
+		}
+	}
+}
+
+HtmlView::~HtmlView()
+{
+}
+
+//
+// Handles button presses.
+//
+void HtmlView::onButtonPressEvent(GdkEventButton *ev)
+{
+#ifdef DEBUG
+	cout << "HtmlView::onButtonPressEvent: click on button " << ev->button << endl;
+#endif
+	// Check for popup click
+	if ((ev->type == GDK_BUTTON_PRESS) &&
+		(ev->button == 3) )
+	{
+		if (m_pPopupMenu != NULL)
+		{
+			m_pPopupMenu->popup(ev->button, ev->time);
+		}
+	}
+}

Added: trunk/UI/GTK2/src/HtmlView.h
===================================================================
--- trunk/UI/GTK2/src/HtmlView.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/HtmlView.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,44 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _HTMLVIEW_HH
+#define _HTMLVIEW_HH
+
+#include <sigc++/object.h>
+#include <gtkmm/box.h>
+#include <gtkmm/menu.h>
+
+#include "MozillaRenderer.h"
+
+class HtmlView : public MozillaRenderer, public SigC::Object
+{
+	public:
+		HtmlView(Gtk::VBox *viewVbox, Gtk::Menu *pPopupMenu);
+		virtual ~HtmlView();
+
+	protected:
+		Gtk::Menu *m_pPopupMenu;
+
+		/// Handles button presses.
+		void onButtonPressEvent(GdkEventButton *ev);
+
+	private:
+		HtmlView(const HtmlView &other);
+		HtmlView &operator=(const HtmlView &other);
+
+};
+
+#endif // _HTMLVIEW_HH

Added: trunk/UI/GTK2/src/IndexTree.cpp
===================================================================
--- trunk/UI/GTK2/src/IndexTree.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/IndexTree.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,534 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+#include <gtkmm/stock.h>
+#include <gtkmm/textbuffer.h>
+
+#include "HtmlTokenizer.h"
+#include "Url.h"
+#include "QueryHistory.h"
+#include "ViewHistory.h"
+#include "config.h"
+#include "NLS.h"
+#include "PinotSettings.h"
+#include "PinotUtils.h"
+#include "IndexTree.h"
+
+using namespace std;
+using namespace SigC;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+IndexTree::IndexTree(VBox *indexVbox, Menu *pPopupMenu, PinotSettings &settings) :
+	TreeView(),
+	m_pPopupMenu(pPopupMenu),
+	m_settings(settings)
+{
+	ScrolledWindow *indexScrolledwindow = manage(new ScrolledWindow());
+
+	// This is the actual index tree
+	set_events(Gdk::BUTTON_PRESS_MASK);
+	set_flags(CAN_FOCUS);
+	set_headers_visible(true);
+	set_rules_hint(true);
+	set_reorderable(false);
+	set_enable_search(true);
+	indexScrolledwindow->set_flags(Gtk::CAN_FOCUS);
+	indexScrolledwindow->set_border_width(4);
+	indexScrolledwindow->set_shadow_type(Gtk::SHADOW_NONE);
+	indexScrolledwindow->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_ALWAYS);
+	indexScrolledwindow->property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+	indexScrolledwindow->add(*this);
+
+	// Position the scrolled window
+	indexVbox->pack_start(*indexScrolledwindow);
+	
+	// Associate the columns model to the index tree
+	m_refStore = ListStore::create(m_indexColumns);
+	set_model(m_refStore);
+
+	// The score column is used for status icons
+	TreeViewColumn *treeColumn = create_resizable_column_with_icon(_("Title"), m_indexColumns.m_text,
+		SigC::slot(*this, &IndexTree::renderLabel));
+	if (treeColumn != NULL)
+	{
+		append_column(*manage(treeColumn));
+	}
+	treeColumn = create_resizable_column(_("URL"), m_indexColumns.m_liveUrl);
+	if (treeColumn != NULL)
+	{
+		append_column(*manage(treeColumn));
+	}
+	append_column(_("Timestamp"), m_indexColumns.m_timestamp);
+
+	// Make headers clickable
+	set_headers_clickable(true);
+	// Allow multiple selection
+	get_selection()->set_mode(SELECTION_MULTIPLE);
+
+	// Handle button presses
+	signal_button_press_event().connect_notify(SigC::slot(*this, &IndexTree::onButtonPressEvent));
+	// Enable interactive search
+	set_search_column(m_indexColumns.m_text.index());
+	set_search_equal_func(SigC::slot(*this, &IndexTree::onSearchEqual));
+	// Control which rows can be selected
+	get_selection()->set_select_function(SigC::slot(*this, &IndexTree::onSelectionSelect));
+
+	// Initially, don't display the list of indexed documents
+	m_listingIndex = false;
+
+	// By default, no particular label is selected
+	setCurrentLabelColour(0, 0, 0, false);
+
+	// Show all
+	show();
+	indexScrolledwindow->show();
+}
+
+IndexTree::~IndexTree()
+{
+}
+
+void IndexTree::renderLabel(CellRenderer *renderer, const TreeModel::iterator &iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (renderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererText *textRenderer = dynamic_cast<CellRendererText*>(renderer);
+	if (textRenderer != NULL)
+	{
+		if ((m_showingLabel == false) &&
+			(row[m_indexColumns.m_labeled] == true))
+		{
+			// Reset this
+			row[m_indexColumns.m_labeled] = false;
+		}
+		else if (row[m_indexColumns.m_labeled] == true)
+		{
+			// Change the row's background
+			textRenderer->property_background_gdk() = m_currentLabelColour;
+		}
+		else
+		{
+			textRenderer->property_background_gdk().reset_value();
+		}
+	}
+}
+
+//
+// Interactive search equal function.
+//
+bool IndexTree::onSearchEqual(const RefPtr<TreeModel>& model, int column,
+	const ustring& key, const TreeModel::iterator& iter)
+{
+}
+
+//
+// Handles button presses.
+//
+void IndexTree::onButtonPressEvent(GdkEventButton *ev)
+{
+	// Check for popup click
+	if ((ev->type == GDK_BUTTON_PRESS) &&
+		(ev->button == 3) )
+	{
+		if (m_pPopupMenu != NULL)
+		{
+			m_pPopupMenu->popup(ev->button, ev->time);
+		}
+	}
+	// Check for double clicks
+	else if (ev->type == GDK_2BUTTON_PRESS)
+	{
+		m_signalEdit();
+	}
+}
+
+//
+// Handles selection changes.
+//
+bool IndexTree::onSelectionChanged(void)
+{
+#ifdef DEBUG
+	cout << "IndexTree::onSelectionChanged: called" << endl;
+#endif
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+//
+// Handles attempts to select rows.
+//
+bool IndexTree::onSelectionSelect(const RefPtr<TreeModel>& model,
+		const TreeModel::Path& path, bool path_currently_selected)
+{
+	const TreeModel::iterator iter = model->get_iter(path);
+	const TreeModel::Row row = *iter;
+
+	if (path_currently_selected == true)
+	{
+#ifdef DEBUG
+		cout << "IndexTree::onSelectionSelect: unselected entry " << row[m_indexColumns.m_url] << endl;
+#endif
+	}
+	else
+	{
+#ifdef DEBUG
+		cout << "IndexTree::onSelectionSelect: selected entry " << row[m_indexColumns.m_url] << endl;
+#endif
+	}
+
+	return true;
+}
+
+//
+// Appends a new row in the index tree.
+//
+bool IndexTree::appendDocument(const IndexedDocument &docInfo, bool labeled)
+{
+	TreeModel::iterator newRowIter = m_refStore->append();
+	TreeModel::Row childRow = *newRowIter;
+	string title = docInfo.getTitle();
+
+	if (title.empty() == true)
+	{
+		title = _("No title");
+	}
+	else if (title.length() > 50)
+	{
+		string truncatedTitle = title.substr(0, 47);
+		truncatedTitle += "...";
+		title = truncatedTitle;
+	}
+
+	childRow[m_indexColumns.m_text] = to_utf8(title);
+	childRow[m_indexColumns.m_url] = to_utf8(docInfo.getLocation());
+	childRow[m_indexColumns.m_liveUrl] = to_utf8(docInfo.getOriginalLocation());
+	childRow[m_indexColumns.m_type] = to_utf8(docInfo.getType());
+	childRow[m_indexColumns.m_language] = to_utf8(docInfo.getLanguage());
+	childRow[m_indexColumns.m_timestamp] = to_utf8(docInfo.getTimestamp());
+	childRow[m_indexColumns.m_labeled] = labeled;
+	childRow[m_indexColumns.m_id] = docInfo.getID();
+
+	// If the tree was empty, it is no longer
+	m_listingIndex = true;
+
+	return true;
+}
+
+
+//
+// Adds a set of documents.
+//
+bool IndexTree::addDocuments(const vector<IndexedDocument> &documentsList)
+{
+	unsigned int count = 0;
+
+	// Unselect all
+	get_selection()->unselect_all();
+
+	// FIXME: clear the tree ?
+
+	// Get the list of indexed documents
+	for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
+		docIter != documentsList.end(); ++docIter)
+	{
+		// Add a row
+		if (appendDocument(*docIter, false) == true)
+		{
+#ifdef DEBUG
+			cout << "IndexTree::addDocuments: added row for document " << count << endl;
+#endif
+			count++;
+		}
+	}
+
+	// Now we are listing the index contents
+	m_listingIndex = true;
+
+	return true;
+}
+
+//
+// Gets the first selected item's URL.
+//
+ustring IndexTree::getFirstSelectionURL(void)
+{
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return "";
+	}
+
+	list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+	TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+	TreeModel::Row row = *iter;
+	return row[m_indexColumns.m_url];
+}
+
+//
+// Gets the first selected item's URL.
+//
+ustring IndexTree::getFirstSelectionLiveURL(void)
+{
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return "";
+	}
+
+	list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+	TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+	TreeModel::Row row = *iter;
+	return row[m_indexColumns.m_liveUrl];
+}
+
+//
+// Gets a list of selected items.
+//
+bool IndexTree::getSelection(std::vector<IndexedDocument> &documentsList)
+{
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return false;
+	}
+
+	// Go through selected items
+	for (list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+		itemPath != selectedItems.end(); ++itemPath)
+	{
+		TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+
+		documentsList.push_back(IndexedDocument(locale_from_utf8(row[m_indexColumns.m_text]),
+			locale_from_utf8(row[m_indexColumns.m_url]),
+			locale_from_utf8(row[m_indexColumns.m_liveUrl]),
+			locale_from_utf8(row[m_indexColumns.m_type]),
+			locale_from_utf8(row[m_indexColumns.m_language])));
+	}
+#ifdef DEBUG
+	cout << "IndexTree::getSelection: " << documentsList.size() << " documents selected" << endl;
+#endif
+
+	return true;
+}
+
+//
+// Sets the current label colour.
+//
+void IndexTree::setCurrentLabelColour(unsigned short red, unsigned short green, unsigned short blue,
+	bool showingLabel)
+{
+	m_currentLabelColour.set_rgb(red, green, blue);
+	m_showingLabel = showingLabel;
+}
+
+//
+// Sets the documents that match the current label.
+//
+void IndexTree::setLabel(const set<unsigned int> &documentsList)
+{
+	// Unselect all
+	get_selection()->unselect_all();
+
+	// Go through the list of indexed documents
+	TreeModel::Children children = m_refStore->children();
+	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
+	{
+		// Does this document match the label ?
+		TreeModel::Row row = *iter;
+		unsigned int docId = row[m_indexColumns.m_id];
+
+		set<unsigned int>::iterator docIter = documentsList.find(docId);
+		if (docIter != documentsList.end())
+		{
+			// Yes, it does !
+#ifdef DEBUG
+			cout << "IndexTree::setLabel: label is in document " << docId << endl;
+#endif
+			row[m_indexColumns.m_labeled] = true;
+		}
+		else
+		{
+			row[m_indexColumns.m_labeled] = false;
+		}
+	}
+}
+
+//
+// Sets a document's title.
+//
+void IndexTree::setDocumentTitle(unsigned int docId, const string &text)
+{
+	if (docId == 0)
+	{
+		return;
+	}
+
+	// Go through the list of indexed documents
+	TreeModel::Children children = m_refStore->children();
+	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
+	{
+		TreeModel::Row row = *iter;
+
+		if (docId == row[m_indexColumns.m_id])
+		{
+#ifdef DEBUG
+			cout << "IndexTree::setLabel: updating title of document " << docId << endl;
+#endif
+			row[m_indexColumns.m_text] = to_utf8(text);
+			break;
+		}
+	}
+}
+
+//
+// Marks a document as labeled.
+//
+void IndexTree::setDocumentLabeledState(unsigned int docId, bool labeled)
+{
+	if (docId == 0)
+	{
+		return;
+	}
+
+	// Go through the list of indexed documents
+	TreeModel::Children children = m_refStore->children();
+	for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
+	{
+		TreeModel::Row row = *iter;
+
+		if (docId == row[m_indexColumns.m_id])
+		{
+			row[m_indexColumns.m_labeled] = labeled;
+			break;
+		}
+	}
+}
+
+//
+// Deletes the current selection.
+//
+bool IndexTree::deleteSelection(void)
+{
+	bool empty = false;
+
+	// Go through selected items
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+	while (itemPath != selectedItems.end())
+	{
+		TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+
+		// Unselect and erase
+		get_selection()->unselect(iter);
+		m_refStore->erase(row);
+
+		selectedItems = get_selection()->get_selected_rows();
+		itemPath = selectedItems.begin();
+	}
+#ifdef DEBUG
+	cout << "IndexTree::setLabel: deleted " << selectedItems.size() << " documents" << endl;
+#endif
+
+	TreeModel::Children children = m_refStore->children();
+	if (children.empty() == true)
+	{
+		// The index tree is now empty
+		m_listingIndex = false;
+		empty = true;
+	}
+
+	columns_autosize();
+
+	return empty;
+}
+
+//
+// Returns the number of rows.
+//
+unsigned int IndexTree::getRowsCount(void)
+{
+	if (m_listingIndex == false)
+	{
+		return 0;
+	}
+
+	// FIXME: cache this value ?
+	return m_refStore->children().size();
+}
+
+//
+// Returns true if the tree is empty.
+//
+bool IndexTree::isEmpty(void)
+{
+	if (m_listingIndex == true)
+	{
+		return false;
+	}
+
+	return true;
+}
+
+//
+// Clear the tree.
+//
+void IndexTree::clear(void)
+{
+	// Unselect all
+	get_selection()->unselect_all();
+
+	// Remove existing rows in the tree
+	TreeModel::Children children = m_refStore->children();
+	if (children.empty() == false)
+	{
+		TreeModel::Children::iterator iter = children.begin();
+		while (iter != children.end())
+		{
+			// Erase this row
+			m_refStore->erase(*iter);
+
+			// Get the new first row
+			children = m_refStore->children();
+			iter = children.begin();
+		}
+		m_refStore->clear();
+
+		onSelectionChanged();
+	}
+}
+
+//
+// Returns the edit document signal.
+//
+Signal0<void>& IndexTree::getEditDocumentSignal(void)
+{
+	return m_signalEdit;
+}

Added: trunk/UI/GTK2/src/IndexTree.h
===================================================================
--- trunk/UI/GTK2/src/IndexTree.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/IndexTree.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,126 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _INDEXTREE_HH
+#define _INDEXTREE_HH
+
+#include <string>
+#include <vector>
+#include <sigc++/slot.h>
+#include <glibmm/refptr.h>
+#include <glibmm/ustring.h>
+#include <gtkmm/box.h>
+#include <gtkmm/menu.h>
+#include <gdkmm/pixbuf.h>
+#include <gtkmm/scrolledwindow.h>
+#include <gtkmm/textview.h>
+#include <gtkmm/liststore.h>
+#include <gtkmm/treeview.h>
+#include <gtkmm/treeselection.h>
+
+#include "QueryProperties.h"
+#include "IndexedDocument.h"
+#include "ModelColumns.h"
+#include "PinotSettings.h"
+
+class IndexTree : public Gtk::TreeView
+{
+	public:
+		IndexTree(Gtk::VBox *indexVbox, Gtk::Menu *pPopupMenu, PinotSettings &settings);
+		virtual ~IndexTree();
+
+		/**
+		  * Handles selection changes.
+		  * Returns true if a result is selected.
+		  */
+		bool onSelectionChanged(void);
+
+		/// Adds a set of documents.
+		bool addDocuments(const std::vector<IndexedDocument> &documentsList);
+
+		/// Appends a new row in the index tree.
+		bool appendDocument(const IndexedDocument &docInfo, bool labeled);
+
+		/// Gets the first selected item's URL.
+		Glib::ustring getFirstSelectionURL(void);
+
+		/// Gets the first selected item's URL.
+		Glib::ustring getFirstSelectionLiveURL(void);
+
+		/// Gets a list of selected items.
+		bool getSelection(std::vector<IndexedDocument> &documentsList);
+
+		/// Sets the current label colour.
+		void setCurrentLabelColour(unsigned short red, unsigned short green, unsigned short blue,
+			bool showingLabel = true);
+
+		/// Sets the documents that match the current label.
+		void setLabel(const std::set<unsigned int> &documentsList);
+
+		/// Sets a document's title.
+		void setDocumentTitle(unsigned int docId, const std::string &text);
+
+		/// Marks a document as labeled.
+		void setDocumentLabeledState(unsigned int docId, bool labeled);
+
+		/**
+		  * Deletes the current selection.
+		  * Returns true if the tree is then empty.
+		  */
+		bool deleteSelection(void);
+
+		/// Returns the number of rows.
+		unsigned int getRowsCount(void);
+
+		/// Returns true if the tree is empty.
+		bool isEmpty(void);
+
+		/// Clear the tree.
+		void clear(void);
+
+		/// Returns the document edit signal.
+		SigC::Signal0<void>& getEditDocumentSignal(void);
+
+	protected:
+		Glib::RefPtr<Gtk::ListStore> m_refStore;
+		Gtk::Menu *m_pPopupMenu;
+		SigC::Signal0<void> m_signalEdit;
+		PinotSettings &m_settings;
+		IndexModelColumns m_indexColumns;
+		Gdk::Color m_currentLabelColour;
+		bool m_showingLabel;
+		bool m_listingIndex;
+
+		void renderLabel(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &iter);
+
+		/// Interactive search equal function.
+		bool onSearchEqual(const Glib::RefPtr<Gtk::TreeModel>& model, int column,
+			const Glib::ustring& key, const Gtk::TreeModel::iterator& iter);
+
+		/// Handles button presses.
+		void onButtonPressEvent(GdkEventButton *ev);
+
+		/// Handles attempts to select rows.
+		bool onSelectionSelect(const Glib::RefPtr<Gtk::TreeModel>& model,
+			const Gtk::TreeModel::Path& path, bool path_currently_selected);
+
+	private:
+		IndexTree(const IndexTree &other);
+		IndexTree &operator=(const IndexTree &other);
+
+};
+
+#endif // _INDEXTREE_HH

Added: trunk/UI/GTK2/src/Makefile
===================================================================
--- trunk/UI/GTK2/src/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,33 @@
+
+ROOT_DIR = ../../..
+include ${ROOT_DIR}/variables.mk
+
+CXXFLAGS += -DHAVE_CONFIG_H -I. -I.. ${LIBXML_CXXFLAGS} ${GTKMOZ_CXXFLAGS} ${GTKMM_CXXFLAGS}
+
+LIBS += ${LIBXML_LIBS} ${GTKMOZ_LIBS} ${GTKMM_LIBS} -lgthread-2.0 -lfam
+
+UI_GTK2_SRCS = aboutDialog.cc aboutDialog_glade.cc \
+	importDialog.cc importDialog_glade.cc \
+	indexDialog.cc indexDialog_glade.cc \
+	prefsDialog.cc prefsDialog_glade.cc \
+	propertiesDialog.cc propertiesDialog_glade.cc \
+	queryDialog.cc queryDialog_glade.cc \
+	mainWindow.cc mainWindow_glade.cc
+UI_SRCS = pinot.cpp EnginesTree.cpp IndexTree.cpp \
+	HtmlView.cpp ModelColumns.cpp MonitorHandler.cpp \
+	PinotSettings.cpp PinotUtils.cpp ResultsTree.cpp \
+	WorkerThreads.cpp
+UI_GTK2_OBJS := $(patsubst %.cc,${OBJ_DIR}/%.o,${UI_GTK2_SRCS})
+UI_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${UI_SRCS})
+UI_GTK2_BIN = ${BIN_DIR}/pinot
+
+targets : dirs ${UI_GTK2_BIN}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${UI_GTK2_BIN}
+
+# GTK+ user interface
+
+${UI_GTK2_BIN} : ${UI_GTK2_OBJS} ${UI_OBJS} ${HTML_LIB} ${IDX_LIB} ${SE_LIBS} ${DL_LIB} ${SQL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB}
+	@echo Building ${UI_GTK2_BIN}
+	${LINK} -o $@ ${UI_GTK2_OBJS} ${UI_OBJS} ${HTML_LIB} ${IDX_LIB} ${SE_LIBS} ${DL_LIB} ${SQL_LIB} ${TOKENIZE_LIB} ${UTILS_LIB} ${LIBS}


Property changes on: trunk/UI/GTK2/src/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/ModelColumns.cpp
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/ModelColumns.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,121 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+#include "NLS.h"
+#include "ModelColumns.h"
+
+ComboModelColumns::ComboModelColumns()
+{
+	add(m_name);
+}
+
+ComboModelColumns::~ComboModelColumns()
+{
+}
+
+EnginesModelColumns::EnginesModelColumns()
+{
+	add(m_name);
+	add(m_engineName);
+	add(m_option);
+	add(m_type);
+}
+
+EnginesModelColumns::~EnginesModelColumns()
+{
+}
+
+QueryModelColumns::QueryModelColumns()
+{
+	add(m_name);
+	add(m_lastRun);
+	add(m_summary);
+	add(m_properties);
+}
+
+QueryModelColumns::~QueryModelColumns()
+{
+}
+
+ResultsModelColumns::ResultsModelColumns()
+{
+	add(m_text);
+	add(m_url);
+	add(m_indexed);
+	add(m_viewed);
+	add(m_rankDiff);
+	add(m_score);
+	add(m_language);
+	add(m_queryName);
+	add(m_engines);
+	add(m_indexes);
+	add(m_type);
+}
+
+ResultsModelColumns::~ResultsModelColumns()
+{
+}
+
+IndexModelColumns::IndexModelColumns()
+{
+	add(m_text);
+	add(m_url);
+	add(m_liveUrl);
+	add(m_type);
+	add(m_language);
+	add(m_id);
+	add(m_timestamp);
+	add(m_labeled);
+}
+
+IndexModelColumns::~IndexModelColumns()
+{
+}
+
+OtherIndexModelColumns::OtherIndexModelColumns()
+{
+	add(m_name);
+	add(m_location);
+}
+
+OtherIndexModelColumns::~OtherIndexModelColumns()
+{
+}
+
+LabelModelColumns::LabelModelColumns()
+{
+	add(m_enabled);
+	add(m_name);
+	add(m_oldName);
+	add(m_colour);
+}
+
+LabelModelColumns::~LabelModelColumns()
+{
+}
+
+MailAccountModelColumns::MailAccountModelColumns()
+{
+	add(m_location);
+	add(m_type);
+	add(m_mTime);
+	add(m_minDate);
+}
+
+MailAccountModelColumns::~MailAccountModelColumns()
+{
+}

Added: trunk/UI/GTK2/src/ModelColumns.h
===================================================================
--- trunk/UI/GTK2/src/ModelColumns.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/ModelColumns.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,153 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MODELCOLUMNS_HH
+#define _MODELCOLUMNS_HH
+
+#include <time.h>
+#include <glibmm/refptr.h>
+#include <glibmm/ustring.h>
+#include <gdkmm/color.h>
+#include <gdkmm/event.h>
+#include <gtkmm/treemodel.h>
+#include <gtkmm/treemodelcolumn.h>
+#include <gtkmm/optionmenu.h>
+
+#include "QueryProperties.h"
+
+/// Model column for text combo boxes.
+class ComboModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+	public:
+		ComboModelColumns();
+		virtual ~ComboModelColumns();
+
+		Gtk::TreeModelColumn<Glib::ustring> m_name;
+
+};
+
+/// Main window, model column for the search engines tree.
+class EnginesModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+	public:
+		EnginesModelColumns();
+		virtual ~EnginesModelColumns();
+
+		Gtk::TreeModelColumn<Glib::ustring> m_name;
+		Gtk::TreeModelColumn<Glib::ustring> m_engineName;
+		Gtk::TreeModelColumn<Glib::ustring> m_option;
+		typedef enum { ENGINE_SEPARATOR = 0, ENGINE_FOLDER,
+			WEB_ENGINE, INTERNAL_INDEX_ENGINE, INDEX_ENGINE } EngineType;
+		Gtk::TreeModelColumn<EngineType> m_type;
+
+};
+
+/// Main window, model column for the queries tree.
+class QueryModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+public:
+	QueryModelColumns();
+	virtual ~QueryModelColumns();
+
+	Gtk::TreeModelColumn<Glib::ustring> m_name;
+	Gtk::TreeModelColumn<Glib::ustring> m_lastRun;
+	Gtk::TreeModelColumn<Glib::ustring> m_summary;
+	Gtk::TreeModelColumn<QueryProperties> m_properties;
+
+};
+
+/// Main window, model column for the search results tree.
+class ResultsModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+public:
+	ResultsModelColumns();
+	virtual ~ResultsModelColumns();
+
+	Gtk::TreeModelColumn<Glib::ustring> m_text;
+	Gtk::TreeModelColumn<Glib::ustring> m_url;
+	Gtk::TreeModelColumn<bool> m_indexed;
+	Gtk::TreeModelColumn<bool> m_viewed;
+	Gtk::TreeModelColumn<int> m_rankDiff;
+	Gtk::TreeModelColumn<Glib::ustring> m_score;
+	Gtk::TreeModelColumn<Glib::ustring> m_language;
+	Gtk::TreeModelColumn<Glib::ustring> m_queryName;
+	Gtk::TreeModelColumn<unsigned int> m_engines;
+	Gtk::TreeModelColumn<unsigned int> m_indexes;
+	typedef enum { RESULT_ROOT = 0, RESULT_TITLE, RESULT_HOST, RESULT_OTHER } ResultType;
+	Gtk::TreeModelColumn<ResultType> m_type;
+
+};
+
+/// Main window, model column for the index tree.
+class IndexModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+public:
+	IndexModelColumns();
+	virtual ~IndexModelColumns();
+
+	Gtk::TreeModelColumn<Glib::ustring> m_text;
+	Gtk::TreeModelColumn<Glib::ustring> m_url;
+	Gtk::TreeModelColumn<Glib::ustring> m_liveUrl;
+	Gtk::TreeModelColumn<Glib::ustring> m_type;
+	Gtk::TreeModelColumn<Glib::ustring> m_language;
+	Gtk::TreeModelColumn<unsigned int> m_id;
+	Gtk::TreeModelColumn<Glib::ustring> m_timestamp;
+	Gtk::TreeModelColumn<bool> m_labeled;
+
+};
+
+/// Preferences window, model column for the Xapian indexes tree.
+class OtherIndexModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+public:
+	OtherIndexModelColumns();
+	virtual ~OtherIndexModelColumns();
+
+	Gtk::TreeModelColumn<Glib::ustring> m_name;
+	Gtk::TreeModelColumn<Glib::ustring> m_location;
+
+};
+
+/// Preferences window, model column for the labels tree.
+/// Export/import window, model column for the labels tree.
+class LabelModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+public:
+	LabelModelColumns();
+	virtual ~LabelModelColumns();
+
+	Gtk::TreeModelColumn<bool> m_enabled;
+	Gtk::TreeModelColumn<Glib::ustring> m_name;
+	Gtk::TreeModelColumn<Glib::ustring> m_oldName;
+	Gtk::TreeModelColumn<Gdk::Color> m_colour;
+
+};
+
+/// Preferences window, model column for the mail accounts tree.
+class MailAccountModelColumns : public Gtk::TreeModel::ColumnRecord
+{
+public:
+	MailAccountModelColumns();
+	virtual ~MailAccountModelColumns();
+
+	Gtk::TreeModelColumn<Glib::ustring> m_location;
+	Gtk::TreeModelColumn<Glib::ustring> m_type;
+	Gtk::TreeModelColumn<time_t> m_mTime;
+	Gtk::TreeModelColumn<time_t> m_minDate;
+
+};
+
+#endif // _MODELCOLUMNS_HH

Added: trunk/UI/GTK2/src/MonitorHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/MonitorHandler.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/MonitorHandler.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,486 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <iostream>
+#include <fstream>
+
+#include "config.h"
+#include "NLS.h"
+#include "StringManip.h"
+#include "Timer.h"
+#include "TimeConverter.h"
+#include "TokenizerFactory.h"
+#include "Url.h"
+#include "FileCollector.h"
+#include "XapianIndex.h"
+#include "XapianEngine.h"
+#include "PinotUtils.h"
+#include "MonitorHandler.h"
+
+using namespace std;
+using namespace SigC;
+
+MonitorHandler::MonitorHandler()
+{
+}
+
+MonitorHandler::~MonitorHandler()
+{
+}
+
+Signal3<void, IndexedDocument, unsigned int, string>& MonitorHandler::getUpdateSignal(void)
+{
+	return m_signalUpdate;
+}
+
+MboxHandler::MboxHandler() :
+	MonitorHandler()
+{
+	m_locationsCount = 0;
+	m_hasNewLocations = false;
+}
+
+MboxHandler::~MboxHandler()
+{
+}
+
+bool MboxHandler::checkMailAccount(const string &fileName, PinotSettings::MailAccount &mailAccount,
+		off_t &previousSize)
+{
+	struct stat fileStat;
+
+	mailAccount.m_name = to_utf8(fileName);
+
+	// Ensure it's one of our mail accounts
+	set<PinotSettings::MailAccount> &mailAccounts = PinotSettings::getInstance().m_mailAccounts;
+	set<PinotSettings::MailAccount>::iterator mailIter = mailAccounts.find(mailAccount);
+	if (mailIter == mailAccounts.end())
+	{
+		// It doesn't seem to be
+#ifdef DEBUG
+		cout << "MboxHandler::checkMailAccount: not one of " << mailAccounts.size() << " accounts" << endl;
+#endif
+		return false;
+	}
+
+	// Find out when it was last modified
+	if ((stat(fileName.c_str(), &fileStat) == 0) &&
+		(!S_ISREG(fileStat.st_mode)))
+	{
+		// This is not a file !
+		return false;
+	}
+
+	if (fileStat.st_mtime <= mailIter->m_modTime)
+	{
+		// No change since last time...
+#ifdef DEBUG
+		cout << "MboxHandler::checkMailAccount: not modified since last time ("
+			<< mailIter->m_modTime << ">" << fileStat.st_mtime << ")" << endl;
+#endif
+		return false;
+	}
+#ifdef DEBUG
+	cout << "MboxHandler::checkMailAccount: modified since last time ("
+		<< mailIter->m_modTime << "<" << fileStat.st_mtime << ")" << endl;
+#endif
+
+	// Update this mail account's properties
+	mailAccount = (*mailIter);
+	mailAccount.m_modTime = fileStat.st_mtime;
+	previousSize = mailAccount.m_size;
+	mailAccount.m_size = fileStat.st_size;
+
+	return true;
+}
+
+bool MboxHandler::parseMailAccount(MboxParser &boxParser, IndexInterface *pIndex,
+	LabelManager &labelMan, time_t &lastMessageTime,
+	const string &tempSourceLabel, const string &sourceLabel)
+{
+	bool indexedFile = false;
+
+	if (pIndex == NULL)
+	{
+		return false;
+	}
+
+	// Parse the mbox file
+#ifdef DEBUG
+	Timer timer;
+	timer.start();
+#endif
+	const Document *pMessage = boxParser.getDocument();
+	unsigned int docNum = 0;
+
+	while (pMessage != NULL)
+	{
+		// Has this message already been indexed ?
+		unsigned int docId = pIndex->hasDocument(*pMessage);
+		if (docId == 0)
+		{
+			pIndex->setStemmingMode(IndexInterface::STORE_BOTH);
+
+			// Get an ad hoc tokenizer for the message
+			Tokenizer *pTokenizer = TokenizerFactory::getTokenizerByType(pMessage->getType(), pMessage);
+			if (pTokenizer == NULL)
+			{
+#ifdef DEBUG
+				cout << "MboxHandler::parseMailAccount: no tokenizer for message " << docNum << endl;
+#endif
+				break;	
+			}
+
+			unsigned int docId = 0;
+			indexedFile = pIndex->indexDocument(*pTokenizer, docId);
+			if (indexedFile == true)
+			{
+				time_t messageDate = boxParser.getDate();
+
+				if (messageDate > lastMessageTime)
+				{
+					// This is the latest message so far
+					lastMessageTime = messageDate;
+				}
+
+				set<string> labels;
+				labels.insert(tempSourceLabel);
+				labelMan.setLabels(docId, pIndex->getLocation(), labels);
+
+				IndexedDocument docInfo(pMessage->getTitle(),
+					XapianEngine::buildUrl(PinotSettings::getInstance().m_mailIndexLocation, docId),
+					pMessage->getLocation(), pMessage->getType(), pMessage->getLanguage());
+				docInfo.setTimestamp(TimeConverter::toTimestamp(messageDate));
+
+				// Signal
+				m_signalUpdate(docInfo, docId, _("My Email"));
+			}
+#ifdef DEBUG
+			else cout << "MboxHandler::parseMailAccount: couldn't index message " << docNum << endl;
+#endif
+
+			delete pTokenizer;
+		}
+		else
+		{
+#ifdef DEBUG
+			cout << "MboxHandler::parseMailAccount: already indexed message "
+				<< docNum << ", document ID " << docId << endl;
+#endif
+			if (sourceLabel.empty() == false)
+			{
+				set<string> labels;
+
+				// Get the message's labels
+				labelMan.getLabels(docId, pIndex->getLocation(), labels);
+				// The source label must have been applied to the message when originally indexed
+				set<string>::iterator labelIter = labels.find(sourceLabel.c_str());
+				if (labelIter != labels.end())
+				{
+					// Erase it
+					labels.erase(labelIter);
+					// Add the temporary label
+					labels.insert(tempSourceLabel);
+					labelMan.setLabels(docId, pIndex->getLocation(), labels);
+				}
+			}
+		}
+
+		// More messages ?
+		if (boxParser.nextMessage() == false)
+		{
+#ifdef DEBUG
+			cout << "MboxHandler::parseMailAccount: no more messages from parser" << endl;
+#endif
+			break;
+		}
+		pMessage = boxParser.getDocument();
+		++docNum;
+	}
+#ifdef DEBUG
+	long microsecs = timer.stop();
+	cout << "MboxHandler::parseMailAccount: parsed " << docNum << " documents in "
+		<< microsecs/1000000 << " seconds (" << microsecs << ")" << endl;
+#endif
+
+	return indexedFile;
+}
+
+bool MboxHandler::deleteMessages(IndexInterface *pIndex,  LabelManager &labelMan,
+	const string &sourceLabel)
+{
+	set<unsigned int> docIdList;
+	bool unindexedMsgs = false;
+
+	if (pIndex == NULL)
+	{
+		return false;
+	}
+
+	// Unindex all documents labeled with this source label
+	if ((labelMan.getDocumentsWithLabel(sourceLabel, pIndex->getLocation(), docIdList) == true) &&
+		(docIdList.empty() == false))
+	{
+#ifdef DEBUG
+		cout << "MboxHandler::deleteMessages: " << docIdList.size() << " message(s) to unindex" << endl;
+#endif
+		for (set<unsigned int>::iterator docIter = docIdList.begin();
+			docIter != docIdList.end(); ++docIter)
+		{
+#ifdef DEBUG
+			cout << "MboxHandler::deleteMessages: unindexing document ID " << *docIter << endl;
+#endif
+			if (pIndex->unindexDocument(*docIter) == true)
+			{
+				unindexedMsgs = true;
+			}
+		}
+	}
+
+	return unindexedMsgs;
+}
+
+unsigned int MboxHandler::getFileSystemLocations(map<unsigned long, string> &fsLocations)
+{
+	// Reset
+	m_hasNewLocations = false;
+
+	// Get the map of mail accounts
+	set<PinotSettings::MailAccount> &mailAccounts = PinotSettings::getInstance().m_mailAccounts;
+
+	if (fsLocations.empty() == true)
+	{
+		m_hasNewLocations = true;
+	}
+	else
+	{
+		unsigned long fileNum = 0;
+
+		// Do a first pass and look for new accounts
+		for (set<PinotSettings::MailAccount>::iterator mailIter = mailAccounts.begin();
+			mailIter != mailAccounts.end(); ++mailIter)
+		{
+			map<unsigned long, string>::iterator fsIter = fsLocations.find(fileNum);
+			if ((fsIter == fsLocations.end()) ||
+				(fsIter->second != mailIter->m_name))
+			{
+				// The mail accounts map has changed
+				m_hasNewLocations = true;
+			}
+
+			++fileNum;
+		}
+
+		fsLocations.clear();
+	}
+
+	// Update the map
+	unsigned long fileNum = 0;
+	for (set<PinotSettings::MailAccount>::iterator mailIter = mailAccounts.begin();
+		mailIter != mailAccounts.end(); ++mailIter)
+	{
+		fsLocations[fileNum] = mailIter->m_name;
+
+		++fileNum;
+	}
+
+	m_locationsCount = fsLocations.size();
+
+	return fileNum;
+}
+
+bool MboxHandler::hasNewLocations(void) const
+{
+	return m_hasNewLocations;
+}
+
+bool MboxHandler::fileExists(const string &fileName, bool end)
+{
+	LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
+	PinotSettings::MailAccount mailAccount;
+	off_t previousSize = 0;
+
+	if (end == true)
+	{
+		return false;
+	}
+
+#ifdef DEBUG
+	cout << "MboxHandler::fileExists: " << fileName << " exists" << endl;
+#endif
+	if (checkMailAccount(fileName, mailAccount, previousSize) == false)
+	{
+		return false;
+	}
+
+	// Come up with a label for this mbox file's messages
+	string sourceLabel = "mailbox://";
+	sourceLabel += fileName;
+	string tempSourceLabel = "Temp";
+	tempSourceLabel += sourceLabel;
+
+	// Get the mail index
+	string indexLocation = PinotSettings::getInstance().m_mailIndexLocation;
+	XapianIndex index(indexLocation);
+	if (index.isGood() == false)
+	{
+#ifdef DEBUG
+		cout << "MboxHandler::fileExists: couldn't get mail index" << endl;
+#endif
+		return false;
+	}
+
+	// Get a parser
+	MboxParser boxParser(fileName);
+
+	bool indexedFile = parseMailAccount(boxParser, &index, labelMan,
+		mailAccount.m_lastMessageTime, tempSourceLabel, sourceLabel);
+
+	// Any document still labeled with this source label wasn't found
+	// this time around and should be unindexed
+	if (deleteMessages(&index, labelMan, sourceLabel) == true)
+	{
+		indexedFile = true;
+	}
+
+	// Rename the temporary label for next time the mbox is parsed
+	labelMan.deleteLabel(sourceLabel);
+	labelMan.renameLabel(tempSourceLabel, sourceLabel);
+
+	// Flush the index
+	index.flush();
+
+	// Update this mail account in the list
+	set<PinotSettings::MailAccount> &mailAccounts = PinotSettings::getInstance().m_mailAccounts;
+	set<PinotSettings::MailAccount>::iterator mailIter = mailAccounts.find(mailAccount);
+	if (mailIter != mailAccounts.end())
+	{
+		mailAccounts.erase(mailIter);
+	}
+	mailAccounts.insert(mailAccount);
+
+	return indexedFile;
+}
+
+void MboxHandler::fileCreated(const string &fileName)
+{
+	// FIXME: if monitoring a directory, index this file
+}
+
+bool MboxHandler::fileChanged(const string &fileName)
+{
+	LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
+	PinotSettings::MailAccount mailAccount;
+	off_t previousSize = 0, mboxOffset = 0;
+
+#ifdef DEBUG
+	cout << "MboxHandler::fileChanged: " << fileName << " changed" << endl;
+#endif
+	if (checkMailAccount(fileName, mailAccount, previousSize) == false)
+	{
+		return false;
+	}
+
+	if (mailAccount.m_size <= previousSize)
+	{
+		// Parse the file from the beginning...
+#ifdef DEBUG
+		cout << "MboxHandler::fileChanged: file smaller or same size" << endl;
+#endif
+		return fileExists(fileName, false);
+	}
+#ifdef DEBUG
+	else cout << "MboxHandler::fileChanged: file now larger than " << previousSize << endl;
+#endif
+
+	// Chances are new messages were added but none removed
+	mboxOffset = previousSize;
+
+	// Come up with a label for this mbox file's messages
+	string sourceLabel = "mailbox://";
+	sourceLabel += fileName;
+
+	// Get the mail index
+	string indexLocation = PinotSettings::getInstance().m_mailIndexLocation;
+	XapianIndex index(indexLocation);
+	if (index.isGood() == false)
+	{
+#ifdef DEBUG
+		cout << "MboxHandler::fileChanged: couldn't get mail index" << endl;
+#endif
+		return false;
+	}
+
+	// Get a parser
+	MboxParser boxParser(fileName, mboxOffset);
+
+	bool indexedFile = parseMailAccount(boxParser, &index, labelMan,
+		mailAccount.m_lastMessageTime, sourceLabel, "");
+	if (indexedFile == true)
+	{
+		// Do not attempt to find out if some of the messages were removed
+		// Some messages may also be indexed twice now, eg if another message
+		// was inserted and changed offsets
+		// Let the next fileExists() deal with it and clean up the whole thing
+
+		// Flush the index
+		index.flush();
+	}
+
+	// Update this mail account in the list
+	set<PinotSettings::MailAccount> &mailAccounts = PinotSettings::getInstance().m_mailAccounts;
+	set<PinotSettings::MailAccount>::iterator mailIter = mailAccounts.find(mailAccount);
+	if (mailIter != mailAccounts.end())
+	{
+		mailAccounts.erase(mailIter);
+	}
+	mailAccounts.insert(mailAccount);
+
+	return indexedFile;
+}
+
+bool MboxHandler::fileDeleted(const string &fileName)
+{
+	LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
+	string sourceLabel = string("mailbox://") + fileName;
+	bool unindexedFile = false;
+
+	// Get the mail index
+	string indexLocation = PinotSettings::getInstance().m_mailIndexLocation;
+	XapianIndex index(indexLocation);
+	if (index.isGood() == false)
+	{
+#ifdef DEBUG
+		cout << "MboxHandler::fileDeleted: couldn't get mail index" << endl;
+#endif
+		return false;
+	}
+
+	// Unindex all documents labeled with this source label
+	if (deleteMessages(&index, labelMan, sourceLabel) == true)
+	{
+		// Delete the label
+		labelMan.deleteLabel(sourceLabel);
+
+		return true;
+	}
+
+	return false;
+}

Added: trunk/UI/GTK2/src/MonitorHandler.h
===================================================================
--- trunk/UI/GTK2/src/MonitorHandler.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/MonitorHandler.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,106 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#ifndef _MONITORHANDLER_HH
+#define _MONITORHANDLER_HH
+
+#include <time.h>
+#include <string>
+#include <set>
+#include <map>
+#include <sigc++/slot.h>
+
+#include "DocumentInfo.h"
+#include "IndexedDocument.h"
+#include "MboxParser.h"
+#include "LabelManager.h"
+#include "IndexInterface.h"
+#include "PinotSettings.h"
+
+class MonitorHandler
+{
+	public:
+		MonitorHandler();
+		virtual ~MonitorHandler();
+
+		/// Returns a map of locations to monitor.
+		virtual unsigned int getFileSystemLocations(std::map<unsigned long, std::string> &fsLocations) = 0;
+
+		/// Returns true if the locations map has changed since last time.
+		virtual bool hasNewLocations(void) const = 0;
+
+		/// Handles file exists events.
+		virtual bool fileExists(const std::string &fileName, bool end = false) = 0;
+
+		/// Handles file creation events.
+		virtual void fileCreated(const std::string &fileName) = 0;
+
+		/// Handles file changed events.
+		virtual bool fileChanged(const std::string &fileName) = 0;
+
+		/// Handles file deleted events.
+		virtual bool fileDeleted(const std::string &fileName) = 0;
+
+		SigC::Signal3<void, IndexedDocument, unsigned int, std::string>& getUpdateSignal(void);
+
+	protected:
+		SigC::Signal3<void, IndexedDocument, unsigned int, std::string> m_signalUpdate;
+
+	private:
+		MonitorHandler(const MonitorHandler &other);
+		MonitorHandler &operator=(const MonitorHandler &other);
+
+};
+
+class MboxHandler : public MonitorHandler
+{
+	public:
+		MboxHandler();
+		virtual ~MboxHandler();
+
+		virtual unsigned int getFileSystemLocations(std::map<unsigned long, std::string> &fsLocations);
+
+		virtual bool hasNewLocations(void) const;
+
+		virtual bool fileExists(const std::string &fileName, bool end = false);
+
+		virtual void fileCreated(const std::string &fileName);
+
+		virtual bool fileChanged(const std::string &fileName);
+
+		virtual bool fileDeleted(const std::string &fileName);
+
+	protected:
+		unsigned int m_locationsCount;
+		bool m_hasNewLocations;
+
+		bool checkMailAccount(const std::string &fileName, PinotSettings::MailAccount &mailAccount,
+			off_t &previousSize);
+
+		bool parseMailAccount(MboxParser &boxParser, IndexInterface *pIndex,
+			LabelManager &labelMan, time_t &lastMessageTime,
+			const std::string &tempSourceLabel, const std::string &sourceLabel);
+
+		bool deleteMessages(IndexInterface *pIndex, LabelManager &labelMan,
+			const std::string &sourceLabel);
+
+	private:
+		MboxHandler(const MboxHandler &other);
+		MboxHandler &operator=(const MboxHandler &other);
+
+};
+
+#endif	// _MONITORHANDLER_HH

Added: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,1201 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <pwd.h>
+#include <algorithm>
+#include <iostream>
+
+#include <glibmm/convert.h>
+#include <libxml++/parsers/domparser.h>
+#include <libxml++/nodes/node.h>
+#include <libxml++/nodes/textnode.h>
+
+#include "config.h"
+#include "NLS.h"
+#include "PluginWebEngine.h"
+#include "PinotSettings.h"
+
+using namespace std;
+using namespace Glib;
+using namespace xmlpp;
+
+static string getElementContent(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return "";
+	}
+
+#ifdef HAS_LIBXMLPP026
+	const TextNode *pText = pElem->get_child_content();
+#else
+	const TextNode *pText = pElem->get_child_text();
+#endif
+	if (pText == NULL)
+	{
+		return "";
+	}
+
+	return pText->get_content();
+}
+
+static Element *addChildElement(Element *pElem, const string &nodeName, const string &nodeContent)
+{
+	if (pElem == NULL)
+	{
+		return NULL;
+	}
+
+	Element *pSubElem = pElem->add_child(nodeName);
+	if (pSubElem != NULL)
+	{
+#ifdef HAS_LIBXMLPP026
+		pSubElem->set_child_content(nodeContent);
+#else
+		pSubElem->set_child_text(nodeContent);
+#endif
+	}
+
+	return pSubElem;
+}
+
+PinotSettings PinotSettings::m_instance;
+
+PinotSettings::PinotSettings() :
+	m_browseResults(false),
+	m_xPos(0),
+	m_yPos(0),
+	m_width(0),
+	m_height(0),
+	m_panePos(-1),
+	m_ignoreRobotsDirectives(false),
+	m_firstRun(false)
+{
+	// Find out if there is a .pinot directory
+	struct stat fileStat;
+	string directoryName = getConfigurationDirectory();
+	if (stat(directoryName.c_str(), &fileStat) != 0)
+	{
+		// No, create it then
+		if (mkdir(directoryName.c_str(), (mode_t)S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IWGRP|S_IXGRP|S_IROTH|S_IXOTH) == 0)
+		{
+			m_firstRun = true;
+		}
+		else
+		{
+			cerr << _("Couldn't create pinot directory at") << " "
+				<< directoryName << endl;
+		}
+	}
+
+	// This is where the internal indices live
+	m_indexLocation = directoryName;
+	m_indexLocation += "/index";
+	m_mailIndexLocation = directoryName;
+	m_mailIndexLocation += "/mail";
+
+	// The location of the history database is not configurable
+	m_historyDatabase = directoryName;
+	m_historyDatabase += "/history";
+}
+
+PinotSettings::~PinotSettings()
+{
+}
+
+PinotSettings &PinotSettings::getInstance(void)
+{
+	return m_instance;
+}
+
+string PinotSettings::getConfigurationDirectory(void)
+{
+	struct passwd *pPasswd = getpwuid(geteuid());
+	string directoryName;
+
+	if ((pPasswd != NULL) &&
+		(pPasswd->pw_dir != NULL))
+	{
+		directoryName = pPasswd->pw_dir;
+	}
+	else
+	{
+		char *homeDir = getenv("HOME");
+		if (homeDir != NULL)
+		{
+			directoryName = homeDir;
+		}
+		else
+		{
+			return "~/.pinot";
+		}
+	}
+	directoryName += "/.pinot";
+
+	return directoryName;
+}
+
+string PinotSettings::getConfigurationFileName(void)
+{
+	string configFileName = getConfigurationDirectory();
+	configFileName += "/config.xml";
+
+	return configFileName;
+}
+
+string PinotSettings::getCurrentUserName(void)
+{
+	struct passwd *pPasswd = getpwuid(geteuid());
+
+	if ((pPasswd != NULL) &&
+		(pPasswd->pw_name != NULL))
+	{
+		return pPasswd->pw_name;
+	}
+
+	return "";
+}
+
+bool PinotSettings::load(void)
+{
+	// Clear lists
+	m_indexNames.clear();
+	m_indexIds.clear();
+	m_engines.clear();
+	m_engineIds.clear();
+	m_queries.clear();
+	m_labels.clear();
+	m_mailAccounts.clear();
+
+	// Load the configuration file
+	string fileName = getConfigurationFileName();
+	if ((m_firstRun == false) &&
+		(loadConfiguration(fileName) == false))
+	{
+		cerr << _("Failed to parse configuration file") << " "
+			<< fileName << endl;
+	}
+	// Internal indices
+	addIndex(_("My Documents"), m_indexLocation);
+	addIndex(_("My Email"), m_mailIndexLocation);
+	// Add default labels on the first run
+	if (m_firstRun == true)
+	{
+		ustring labelName =_("Red");
+		m_labels.insert(Label(labelName, 65535, 0, 0));
+		labelName =_("Blue");
+		m_labels.insert(Label(labelName, 0, 65535, 0));
+		labelName =_("Green");
+		m_labels.insert(Label(labelName, 0, 0, 65535));
+	}
+
+	// Some search engines are hardcoded
+#ifdef HAS_GOOGLEAPI
+	m_engineIds[1 << m_engines.size()] = "Google API";
+	m_engines.insert(Engine("Google API", "googleapi", "", "Web Services"));
+	m_engineChannels.insert("Web Services");
+#endif
+#ifdef HAS_OSAPI
+	m_engineIds[1 << m_engines.size()] = "ObjectsSearch API";
+	m_engines.insert(Engine("ObjectsSearch API", "objectssearchapi", "", "Web Services"));
+	m_engineChannels.insert("Web Services");
+#endif
+	m_engineIds[1 << m_engines.size()] = "Xapian";
+	m_engines.insert(Engine("Xapian", "xapian", "", ""));
+
+	return true;
+}
+
+bool PinotSettings::loadConfiguration(const std::string &fileName)
+{
+	struct stat fileStat;
+
+	if ((stat(fileName.c_str(), &fileStat) != 0) ||
+		(!S_ISREG(fileStat.st_mode)))
+	{
+		return false;
+	}
+
+	// Parse the configuration file
+	DomParser parser;
+	parser.parse_file(fileName);
+	xmlpp::Document *pDocument = parser.get_document();
+	if (pDocument == NULL)
+	{
+		return false;
+	}
+
+	Element *pRootElem = pDocument->get_root_node();
+	if (pRootElem == NULL)
+	{
+		return false;
+	}
+	string rootNodeName = getElementContent(pRootElem);
+	// FIXME: check the top-level element is okay
+
+	// Go through the subnodes
+	Node::NodeList childNodes = pRootElem->get_children();
+	if (childNodes.empty() == false)
+	{
+		for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+		{
+			Node *pNode = (*iter);
+			// All nodes should be elements
+			Element *pElem = dynamic_cast<Element*>(pNode);
+			if (pElem == NULL)
+			{
+				continue;
+			}
+
+			string nodeName = pElem->get_name();
+			string nodeContent = getElementContent(pElem);
+			if (nodeName == "googleapikey")
+			{
+				m_googleAPIKey = nodeContent;
+			}
+			else if (nodeName == "ui")
+			{
+				if (loadUi(pElem) == false)
+				{
+					cerr << _("Couldn't load ui block") << endl;
+				}
+			}
+			else if (nodeName == "extraindex")
+			{
+				if (loadIndexes(pElem) == false)
+				{
+					cerr << _("Couldn't load extraindex block") << endl;
+				}
+			}
+			else if (nodeName == "storedquery")
+			{
+				if (loadQueries(pElem) == false)
+				{
+					cerr << _("Couldn't load storedquery block") << endl;
+				}
+			}
+			else if (nodeName == "results")
+			{
+				if (loadResults(pElem) == false)
+				{
+					cerr << _("Couldn't load results block") << endl;
+				}
+			}
+			else if (nodeName == "label")
+			{
+				if (loadLabels(pElem) == false)
+				{
+					cerr << _("Couldn't load label block") << endl;
+				}
+			}
+			else if (nodeName == "robots")
+			{
+				if (nodeContent == "IGNORE")
+				{
+					m_ignoreRobotsDirectives = true;
+				}
+				else
+				{
+					m_ignoreRobotsDirectives = false;
+				}
+			}
+			else if (nodeName == "mailaccount")
+			{
+				if (loadMailAccounts(pElem) == false)
+				{
+					cerr << _("Couldn't load mailaccount block") << endl;
+				}
+			}
+		}
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadUi(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return false;
+	}
+
+	Node::NodeList childNodes = pElem->get_children();
+	if (childNodes.empty() == true)
+	{
+		return false;
+	}
+
+	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+	{
+		Node *pNode = (*iter);
+		Element *pElem = dynamic_cast<Element*>(pNode);
+		if (pElem == NULL)
+		{
+			continue;
+		}
+
+		string nodeName = pElem->get_name();
+		string nodeContent = getElementContent(pElem);
+		if (nodeName == "xpos")
+		{
+			m_xPos = atoi(nodeContent.c_str());
+		}
+		else if (nodeName == "ypos")
+		{
+			m_yPos = atoi(nodeContent.c_str());
+		}
+		else if (nodeName == "width")
+		{
+			m_width = atoi(nodeContent.c_str());
+		}
+		else if (nodeName == "height")
+		{
+			m_height = atoi(nodeContent.c_str());
+		}
+		else if (nodeName == "panepos")
+		{
+			m_panePos = atoi(nodeContent.c_str());
+		}
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadIndexes(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return false;
+	}
+
+	Node::NodeList childNodes = pElem->get_children();
+	if (childNodes.empty() == true)
+	{
+		return false;
+	}
+
+	string indexName, indexLocation;
+
+	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+	{
+		Node *pNode = (*iter);
+		Element *pElem = dynamic_cast<Element*>(pNode);
+		if (pElem == NULL)
+		{
+			continue;
+		}
+
+		string nodeName = pElem->get_name();
+		string nodeContent = getElementContent(pElem);
+		if (nodeName == "name")
+		{
+			indexName = nodeContent;
+		}
+		else if (nodeName == "location")
+		{
+			indexLocation = nodeContent;
+		}
+	}
+
+	if ((indexName.empty() == false) &&
+		(indexLocation.empty() == false))
+	{
+		addIndex(indexName, indexLocation);
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadQueries(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return false;
+	}
+
+	Node::NodeList childNodes = pElem->get_children();
+	if (childNodes.empty() == true)
+	{
+		return false;
+	}
+
+	QueryProperties queryProps;
+
+	// Load the query's properties
+	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+	{
+		Node *pNode = (*iter);
+		Element *pElem = dynamic_cast<Element*>(pNode);
+		if (pElem == NULL)
+		{
+			continue;
+		}
+
+		string nodeName = pElem->get_name();
+		string nodeContent = getElementContent(pElem);
+		if (nodeName == "name")
+		{
+			queryProps.setName(nodeContent);
+		}
+		else if (nodeName == "and")
+		{
+			queryProps.setAndWords(nodeContent);
+		}
+		else if (nodeName == "phrase")
+		{
+			queryProps.setPhrase(nodeContent);
+		}
+		else if (nodeName == "any")
+		{
+			queryProps.setAnyWords(nodeContent);
+		}
+		else if (nodeName == "not")
+		{
+			queryProps.setNotWords(nodeContent);
+		}
+		else if (nodeName == "language")
+		{
+			queryProps.setLanguage(nodeContent);
+		}
+		else if (nodeName == "hostname")
+		{
+			queryProps.setHostNameFilter(nodeContent);
+		}
+		else if (nodeName == "filename")
+		{
+			queryProps.setFileNameFilter(nodeContent);
+		}
+		else if (nodeName == "maxresults")
+		{
+			int count = atoi(nodeContent.c_str());
+			queryProps.setMaximumResultsCount((unsigned int)max(count, 10));
+		}
+		else if (nodeName == "index")
+		{
+			if (nodeContent == "ALL")
+			{
+				queryProps.setIndexResults(true);
+			}
+			else
+			{
+				queryProps.setIndexResults(false);
+			}
+		}
+		else if (nodeName == "label")
+		{
+			queryProps.setLabelName(nodeContent);
+		}
+	}
+
+	// We need at least a name
+	if (queryProps.getName().empty() == false)
+	{
+		m_queries[queryProps.getName()] = queryProps;
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadResults(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return false;
+	}
+
+	Node::NodeList childNodes = pElem->get_children();
+	if (childNodes.empty() == true)
+	{
+		return false;
+	}
+
+	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+	{
+		Node *pNode = (*iter);
+		Element *pElem = dynamic_cast<Element*>(pNode);
+		if (pElem == NULL)
+		{
+			continue;
+		}
+
+		string nodeName = pElem->get_name();
+		string nodeContent = getElementContent(pElem);
+		if (nodeName == "viewmode")
+		{
+			if (nodeContent == "SOURCE")
+			{
+				m_browseResults = false;
+			}
+			else
+			{
+				m_browseResults = true;
+			}
+		}
+		else if (nodeName == "browser")
+		{
+			m_browserCommand = nodeContent;
+		}
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadLabels(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return false;
+	}
+
+	Node::NodeList childNodes = pElem->get_children();
+	if (childNodes.empty() == true)
+	{
+		return false;
+	}
+
+	Label label;
+
+	// Load the label's properties
+	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+	{
+		Node *pNode = (*iter);
+		Element *pElem = dynamic_cast<Element*>(pNode);
+		if (pElem == NULL)
+		{
+			continue;
+		}
+
+		string nodeName = pElem->get_name();
+		string nodeContent = getElementContent(pElem);
+
+		if (nodeName == "name")
+		{
+			label.m_name = nodeContent;
+		}
+		else if (nodeName == "red")
+		{
+			label.m_red = (unsigned short)atoi(nodeContent.c_str());
+		}
+		else if (nodeName == "green")
+		{
+			label.m_green = (unsigned short)atoi(nodeContent.c_str());
+		}
+		else if (nodeName == "blue")
+		{
+			label.m_blue = (unsigned short)atoi(nodeContent.c_str());
+		}
+	}
+
+	if (label.m_name.empty() == false)
+	{
+		m_labels.insert(label);
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadMailAccounts(const Element *pElem)
+{
+	if (pElem == NULL)
+	{
+		return false;
+	}
+
+	Node::NodeList childNodes = pElem->get_children();
+	if (childNodes.empty() == true)
+	{
+		return false;
+	}
+
+	MailAccount mailAccount;
+
+	// Load the mail account's properties
+	for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+	{
+		Node *pNode = (*iter);
+		Element *pElem = dynamic_cast<Element*>(pNode);
+		if (pElem == NULL)
+		{
+			continue;
+		}
+
+		string nodeName = pElem->get_name();
+		string nodeContent = getElementContent(pElem);
+
+		if (nodeName == "name")
+		{
+			mailAccount.m_name = nodeContent;
+		}
+		else if (nodeName == "type")
+		{
+			mailAccount.m_type = nodeContent;
+		}
+		else if (nodeName == "mtime")
+		{
+			mailAccount.m_modTime = (time_t)atoi(nodeContent.c_str());
+		}
+		else if (nodeName == "mindate")
+		{
+			mailAccount.m_lastMessageTime = (time_t)atoi(nodeContent.c_str());
+		}
+		else if (nodeName == "size")
+		{
+			mailAccount.m_size = (off_t)atoi(nodeContent.c_str());
+		}
+	}
+
+	if (mailAccount.m_name.empty() == false)
+	{
+		m_mailAccounts.insert(mailAccount);
+	}
+
+	return true;
+}
+
+bool PinotSettings::loadSearchEngines(const string &directoryName)
+{
+	if (directoryName.empty() == true)
+	{
+		return true;
+	}
+
+	DIR *pDir = opendir(directoryName.c_str());
+	if (pDir == NULL)
+	{
+		return false;
+	}
+
+	// Iterate through this directory's entries
+	struct dirent *pDirEntry = readdir(pDir);
+	while (pDirEntry != NULL)
+	{
+		char *pEntryName = pDirEntry->d_name;
+		if (pEntryName != NULL)
+		{
+			struct stat fileStat;
+			string location = directoryName;
+			location += "/";
+			location += pEntryName;
+
+			// Is that a file ?
+			if ((stat(location.c_str(), &fileStat) == 0) &&
+				(S_ISREG(fileStat.st_mode)))
+			{
+				string engineName, engineChannel;
+
+				if ((PluginWebEngine::getDetails(location, engineName, engineChannel) == true) &&
+					(engineName.empty() == false))
+				{
+					m_engineIds[1 << m_engines.size()] = engineName;
+					if (engineChannel.empty() == true)
+					{
+						engineChannel = _("Unclassified");
+					}
+					m_engines.insert(Engine(engineName, "sherlock", location, engineChannel));
+					m_engineChannels.insert(engineChannel);
+				}
+			}
+		}
+
+		// Next entry
+		pDirEntry = readdir(pDir);
+	}
+	closedir(pDir);
+
+	return true;
+}
+
+bool PinotSettings::save(void)
+{
+	Element *pRootElem = NULL;
+	Element *pElem = NULL;
+	char numStr[64];
+
+	xmlpp::Document doc("1.0");
+
+	// Create a new node
+	pRootElem = doc.create_root_node("pinot");
+	if (pRootElem == NULL)
+	{
+		return false;
+	}
+	// ...with text children nodes
+	addChildElement(pRootElem, "googleapikey", m_googleAPIKey);
+	// User interface position and size
+	pElem = pRootElem->add_child("ui");
+	if (pElem == NULL)
+	{
+		return false;
+	}
+	sprintf(numStr, "%d", m_xPos);
+	addChildElement(pElem, "xpos", numStr);
+	sprintf(numStr, "%d", m_yPos);
+	addChildElement(pElem, "ypos", numStr);
+	sprintf(numStr, "%d", m_width);
+	addChildElement(pElem, "width", numStr);
+	sprintf(numStr, "%d", m_height);
+	addChildElement(pElem, "height", numStr);
+	sprintf(numStr, "%d", m_panePos);
+	addChildElement(pElem, "panepos", numStr);
+	// User-defined indexes
+	for (map<string, string>::iterator indexIter = m_indexNames.begin(); indexIter != m_indexNames.end(); ++indexIter)
+	{
+		string indexName = indexIter->first;
+
+		if (isInternalIndex(indexName) == true)
+		{
+			continue;
+		}
+
+		pElem = pRootElem->add_child("extraindex");
+		if (pElem == NULL)
+		{
+			return false;
+		}
+		addChildElement(pElem, "name", indexIter->first);
+		addChildElement(pElem, "location", indexIter->second);
+	}
+	// User-defined queries
+	for (map<string, QueryProperties>::iterator queryIter = m_queries.begin();
+		queryIter != m_queries.end(); ++queryIter)
+	{
+		pElem = pRootElem->add_child("storedquery");
+		if (pElem == NULL)
+		{
+			return false;
+		}
+		addChildElement(pElem, "name", queryIter->first);
+		addChildElement(pElem, "type", "FIXED");
+		addChildElement(pElem, "and", queryIter->second.getAndWords());
+		addChildElement(pElem, "phrase", queryIter->second.getPhrase());
+		addChildElement(pElem, "any", queryIter->second.getAnyWords());
+		addChildElement(pElem, "not", queryIter->second.getNotWords());
+		addChildElement(pElem, "hostname", queryIter->second.getHostNameFilter());
+		addChildElement(pElem, "filename", queryIter->second.getFileNameFilter());
+		addChildElement(pElem, "language", queryIter->second.getLanguage());
+		sprintf(numStr, "%u", queryIter->second.getMaximumResultsCount());
+		addChildElement(pElem, "maxresults", numStr);
+		addChildElement(pElem, "index", (queryIter->second.getIndexResults() ? "ALL" : "NONE"));
+		addChildElement(pElem, "label", queryIter->second.getLabelName());
+	}
+	pElem = pRootElem->add_child("results");
+	if (pElem == NULL)
+	{
+		return false;
+	}
+	// Results view options
+	addChildElement(pElem, "viewmode", (m_browseResults ? "BROWSE" : "SOURCE"));
+	addChildElement(pElem, "browser", m_browserCommand);
+	// Labels
+	for (set<Label>::iterator labelIter = m_labels.begin(); labelIter != m_labels.end(); ++labelIter)
+	{
+		pElem = pRootElem->add_child("label");
+		if (pElem == NULL)
+		{
+			return false;
+		}
+		addChildElement(pElem, "name", labelIter->m_name);
+		sprintf(numStr, "%u", labelIter->m_red);
+		addChildElement(pElem, "red", numStr);
+		sprintf(numStr, "%u", labelIter->m_green);
+		addChildElement(pElem, "green", numStr);
+		sprintf(numStr, "%u", labelIter->m_blue);
+		addChildElement(pElem, "blue", numStr);
+	}
+	// Ignore robots directives
+	addChildElement(pRootElem, "robots", (m_ignoreRobotsDirectives ? "IGNORE" : "OBEY"));
+	// Mail accounts
+	for (set<MailAccount>::iterator mailIter = m_mailAccounts.begin(); mailIter != m_mailAccounts.end(); ++mailIter)
+	{
+		pElem = pRootElem->add_child("mailaccount");
+		if (pElem == NULL)
+		{
+			return false;
+		}
+		addChildElement(pElem, "name", mailIter->m_name);
+		addChildElement(pElem, "type", mailIter->m_type);
+		sprintf(numStr, "%u", mailIter->m_modTime);
+		addChildElement(pElem, "mtime", numStr);
+		sprintf(numStr, "%u", mailIter->m_lastMessageTime);
+		addChildElement(pElem, "mindate", numStr);
+		sprintf(numStr, "%u", mailIter->m_size);
+		addChildElement(pElem, "size", numStr);
+	}
+
+	// Save to file
+	doc.write_to_file_formatted(getConfigurationFileName());
+
+	return true;
+}
+
+/// Returns the indexes map, keyed by name.
+const map<string, string> &PinotSettings::getIndexes(void) const
+{
+	return m_indexNames;
+}
+
+/// Returns true if the given index is internal.
+bool PinotSettings::isInternalIndex(const string &indexName) const
+{
+	if ((indexName == _("My Documents")) ||
+		(indexName == _("My Email")))
+	{
+		return true;
+	}
+
+	return false;		
+}
+
+/// Adds a new index.
+bool PinotSettings::addIndex(const string &name, const string &location)
+{
+	map<string, string>::iterator namesMapIter = m_indexNames.find(name);
+	if (namesMapIter == m_indexNames.end())
+	{
+		// Okay, no such index exists
+		m_indexIds[1 << m_indexNames.size()] = name;
+		m_indexNames[name] = location;
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Removes an index.
+bool PinotSettings::removeIndex(const string &name)
+{
+	// Remove from the names map
+	map<string, string>::iterator namesMapIter = m_indexNames.find(name);
+	if (namesMapIter != m_indexNames.end())
+	{
+		m_indexNames.erase(namesMapIter);
+
+		// Remove from the IDs map
+		for (map<unsigned int, string>::iterator idsMapIter = m_indexIds.begin();
+			idsMapIter != m_indexIds.end(); ++idsMapIter)
+		{
+			if (idsMapIter->second == name)
+			{
+				m_indexIds.erase(idsMapIter);
+			}
+		}
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Clears the indexes map.
+void PinotSettings::clearIndexes(void)
+{
+	// Clear both maps, reinsert the internal index
+	m_indexNames.clear();
+	m_indexIds.clear();
+	addIndex(_("My Documents"), m_indexLocation);
+	addIndex(_("My Email"), m_mailIndexLocation);
+}
+
+/// Returns an ID that identifies the given index.
+unsigned int PinotSettings::getIndexId(const std::string &name)
+{
+	unsigned int indexId = 0;
+	for (map<unsigned int, string>::iterator mapIter = m_indexIds.begin();
+		mapIter != m_indexIds.end(); ++mapIter)
+	{
+		if (mapIter->second == name)
+		{
+			indexId = mapIter->first;
+			break;
+		}
+	}
+
+	return indexId;
+}
+
+/// Returns the name(s) for the given ID.
+void PinotSettings::getIndexNames(unsigned int id, std::set<std::string> &names)
+{
+	names.clear();
+
+	// Make sure there are indexes defined
+	if (m_indexNames.empty() == true)
+	{
+		return;
+	}
+
+	unsigned indexId = 1 << (m_indexNames.size() - 1);
+	do
+	{
+		if (id & indexId)
+		{
+			map<unsigned int, string>::iterator mapIter = m_indexIds.find(indexId);
+			if (mapIter != m_indexIds.end())
+			{
+				// Get the associated name
+				names.insert(mapIter->second);
+			}
+		}
+		// Shift to the right
+		indexId = indexId >> 1;
+	} while (indexId > 0);
+}
+
+/// Returns the search engines set.
+bool PinotSettings::getSearchEngines(set<PinotSettings::Engine> &engines, string channelName) const
+{
+	if (channelName.empty() == true)
+	{
+		// Copy the whole list of search engines
+		copy(m_engines.begin(), m_engines.end(), inserter(engines, engines.begin()));
+	}
+	else
+	{
+		if (m_engineChannels.find(channelName) == m_engineChannels.end())
+		{
+			// Unknown channel name
+			return false;
+		}
+
+		// Copy channels that belong to the given channel
+		for (set<Engine>::iterator engineIter = m_engines.begin(); engineIter != m_engines.end(); ++engineIter)
+		{
+			if (engineIter->m_channel == channelName)
+			{
+				engines.insert(*engineIter);
+			}
+		}
+	}
+
+	return true;
+}
+
+/// Returns an ID that identifies the given engine name.
+unsigned int PinotSettings::getEngineId(const string &name)
+{
+	unsigned int engineId = 0;
+	for (map<unsigned int, string>::iterator mapIter = m_engineIds.begin();
+		mapIter != m_engineIds.end(); ++mapIter)
+	{
+		if (mapIter->second == name)
+		{
+			engineId = mapIter->first;
+			break;
+		}
+	}
+
+	return engineId;
+}
+
+/// Returns the name for the given ID.
+void PinotSettings::getEngineNames(unsigned int id, set<string> &names)
+{
+	names.clear();
+
+	// Make sure there are search engines defined
+	if (m_engines.empty() == true)
+	{
+		return;
+	}
+
+	unsigned engineId = 1 << (m_engines.size() - 1);
+	do
+	{
+		if (id & engineId)
+		{
+			map<unsigned int, string>::iterator mapIter = m_engineIds.find(engineId);
+			if (mapIter != m_engineIds.end())
+			{
+				// Get the associated name
+				names.insert(mapIter->second);
+			}
+		}
+		// Shift to the right
+		engineId = engineId >> 1;
+	} while (engineId > 0);
+}
+
+/// Returns the search engines channels.
+const set<string> &PinotSettings::getSearchEnginesChannels(void) const
+{
+	return m_engineChannels;
+}
+
+/// Returns the queries map, keyed by name.
+const map<string, QueryProperties> &PinotSettings::getQueries(void) const
+{
+	return m_queries;
+}
+
+/// Adds a new query.
+bool PinotSettings::addQuery(const QueryProperties &properties)
+{
+	string name = properties.getName();
+
+	map<string, QueryProperties>::iterator queryIter = m_queries.find(name);
+	if (queryIter == m_queries.end())
+	{
+		// Okay, no such query exists
+		m_queries[name] = properties;
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Removes a query.
+bool PinotSettings::removeQuery(const string &name)
+{
+	// Remove from the map
+	map<string, QueryProperties>::iterator queryIter = m_queries.find(name);
+	if (queryIter != m_queries.end())
+	{
+		m_queries.erase(queryIter);
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Clears the queries map.
+void PinotSettings::clearQueries(void)
+{
+	m_queries.clear();
+}
+
+PinotSettings::Engine::Engine()
+{
+}
+
+PinotSettings::Engine::Engine(string name, string type, string option, string channel)
+{
+	m_name = name;
+	m_type = type;
+	m_option = option;
+	m_channel = channel;
+}
+
+PinotSettings::Engine::~Engine()
+{
+}
+
+bool PinotSettings::Engine::operator<(const PinotSettings::Engine &other) const
+{
+	if (m_name < other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+bool PinotSettings::Engine::operator==(const Engine &other) const
+{
+	if (m_name == other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+PinotSettings::Label::Label() :
+	m_red(0),
+	m_green(0),
+	m_blue(0)
+{
+}
+
+PinotSettings::Label::Label(ustring &name, unsigned short red,
+	unsigned short green, unsigned short blue) :
+	m_name(name),
+	m_red(red),
+	m_green(blue),
+	m_blue(green)
+{
+}
+
+PinotSettings::Label::~Label()
+{
+}
+
+bool PinotSettings::Label::operator<(const PinotSettings::Label &other) const
+{
+	if (m_name < other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+bool PinotSettings::Label::operator==(const Label &other) const
+{
+	if (m_name == other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+PinotSettings::MailAccount::MailAccount()
+{
+	m_modTime = m_lastMessageTime = (time_t)0;
+	m_size = 0;
+}
+
+PinotSettings::MailAccount::MailAccount(const MailAccount &other)
+{
+	m_name = other.m_name;
+	m_type = other.m_type;
+	m_modTime = other.m_modTime;
+	m_lastMessageTime = other.m_lastMessageTime;
+	m_size = other.m_size;
+}
+
+PinotSettings::MailAccount::~MailAccount()
+{
+}
+
+bool PinotSettings::MailAccount::operator<(const MailAccount &other) const
+{
+	if (m_name < other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+bool PinotSettings::MailAccount::operator==(const MailAccount &other) const
+{
+	if (m_name == other.m_name)
+	{
+		return true;
+	}
+
+	return false;
+}


Property changes on: trunk/UI/GTK2/src/PinotSettings.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/PinotSettings.h
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/PinotSettings.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,184 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _PINOTSETTINGS_HH
+#define _PINOTSETTINGS_HH
+
+#include <sys/types.h>
+#include <string>
+#include <map>
+#include <set>
+#include <vector>
+#include <glibmm/ustring.h>
+#include <libxml++/nodes/element.h>
+
+#include "QueryProperties.h"
+
+class PinotSettings
+{
+	public:
+		~PinotSettings();
+
+		static PinotSettings &getInstance(void);
+
+		static std::string getConfigurationDirectory(void);
+
+		static std::string getConfigurationFileName(void);
+
+		static std::string getCurrentUserName(void);
+
+		bool load(void);
+
+		bool loadSearchEngines(const std::string &directoryName);
+
+		bool save(void);
+
+		/// Returns the indexes map, keyed by name.
+		const std::map<std::string, std::string> &getIndexes(void) const;
+
+		/// Returns true if the given index is internal.
+		bool isInternalIndex(const string &indexName) const;
+
+		/// Adds a new index.
+		bool addIndex(const std::string &name, const std::string &location);
+
+		/// Removes an index.
+		bool removeIndex(const std::string &name);
+
+		/// Clears the indexes map.
+		void clearIndexes(void);
+
+		/// Returns an ID that identifies the given index.
+		unsigned int getIndexId(const std::string &name);
+
+		/// Returns the name(s) for the given ID.
+		void getIndexNames(unsigned int id, std::set<std::string> &names);
+
+		class Engine
+		{
+			public:
+				Engine();
+				Engine(std::string name, std::string type, std::string option, std::string channel);
+				~Engine();
+
+				bool operator<(const Engine &other) const;
+				bool operator==(const Engine &other) const;
+
+				std::string m_name;
+				std::string m_type;
+				std::string m_option;
+				std::string m_channel;
+		};
+
+		/// Returns the search engines set.
+		bool getSearchEngines(std::set<Engine> &engines, std::string channelName = "") const;
+
+		/// Returns an ID that identifies the given engine name.
+		unsigned int getEngineId(const std::string &name);
+
+		/// Returns the name(s) for the given ID.
+		void getEngineNames(unsigned int id, std::set<std::string> &names);
+
+		/// Returns the search engines channels.
+		const std::set<std::string> &getSearchEnginesChannels(void) const;
+
+		/// Returns the queries map, keyed by name.
+		const std::map<std::string, QueryProperties> &getQueries(void) const;
+
+		/// Adds a new query.
+		bool addQuery(const QueryProperties &properties);
+
+		/// Removes a query.
+		bool removeQuery(const std::string &name);
+
+		/// Clears the queries map.
+		void clearQueries(void);
+
+		class Label
+		{
+			public:
+				Label();
+				Label(Glib::ustring &name, unsigned short red,
+					unsigned short green, unsigned short blue);
+				~Label();
+
+				bool operator<(const Label &other) const;
+				bool operator==(const Label &other) const;
+
+				Glib::ustring m_name;
+				unsigned short m_red;
+				unsigned short m_green;
+				unsigned short m_blue;
+		};
+
+		class MailAccount
+		{
+			public:
+				MailAccount();
+				MailAccount(const MailAccount &other);
+				~MailAccount();
+
+				bool operator<(const MailAccount &other) const;
+				bool operator==(const MailAccount &other) const;
+
+				Glib::ustring m_name;
+				Glib::ustring m_type;
+				time_t m_modTime;
+				time_t m_lastMessageTime;
+				off_t m_size;
+		};
+
+		Glib::ustring m_googleAPIKey;
+		Glib::ustring m_indexLocation;
+		Glib::ustring m_mailIndexLocation;
+		Glib::ustring m_historyDatabase;
+		bool m_browseResults;
+		Glib::ustring m_browserCommand;
+		int m_xPos;
+		int m_yPos;
+		int m_width;
+		int m_height;
+		int m_panePos;
+		std::set<Label> m_labels;
+		bool m_ignoreRobotsDirectives;
+		std::set<MailAccount> m_mailAccounts;
+
+	protected:
+		static PinotSettings m_instance;
+		bool m_firstRun;
+		std::map<std::string, std::string> m_indexNames;
+		std::map<unsigned int, std::string> m_indexIds;
+		std::set<Engine> m_engines;
+		std::map<unsigned int, std::string> m_engineIds;
+		std::set<std::string> m_engineChannels;
+		std::map<std::string, QueryProperties> m_queries;
+
+		PinotSettings();
+		bool loadConfiguration(const std::string &fileName);
+		bool loadUi(const xmlpp::Element *pElem);
+		bool loadIndexes(const xmlpp::Element *pElem);
+		bool loadQueries(const xmlpp::Element *pElem);
+		bool loadResults(const xmlpp::Element *pElem);
+		bool loadLabels(const xmlpp::Element *pElem);
+		bool loadMailAccounts(const xmlpp::Element *pElem);
+
+	private:
+		PinotSettings(const PinotSettings &other);
+		PinotSettings &operator=(const PinotSettings &other);
+
+};
+
+#endif // _PINOTSETTINGS_HH


Property changes on: trunk/UI/GTK2/src/PinotSettings.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/PinotUtils.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/PinotUtils.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,169 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+#include <gtkmm/stock.h>
+#include <gtkmm/filechooserdialog.h>
+
+#include "config.h"
+#include "NLS.h"
+#include "PinotUtils.h"
+
+using namespace std;
+using namespace Glib;
+using namespace Gtk;
+
+bool select_file_name(Window &parentWindow, const ustring &title,
+	ustring &location, bool openOrCreate, bool directoriesOnly)
+{
+	FileChooserAction chooserAction = FILE_CHOOSER_ACTION_OPEN;
+	StockID okButtonStockId = Stock::OPEN;
+
+	if (title.empty() == true)
+	{
+		return false;
+	}
+
+	// Have we been provided with an initial location ?
+	if (location.empty() == true)
+	{
+		// No, get the location of the home directory then
+		char *homeDir = getenv("HOME");
+		if (homeDir != NULL)
+		{
+			location = homeDir;
+			location += "/";
+		}
+	}
+
+	if (directoriesOnly == false)
+	{
+		if (openOrCreate == true)
+		{
+			chooserAction = FILE_CHOOSER_ACTION_OPEN;
+		}
+		else
+		{
+			chooserAction = FILE_CHOOSER_ACTION_SAVE;
+			okButtonStockId = Stock::SAVE;
+		}
+	}
+	else
+	{
+		if (openOrCreate == true)
+		{
+			chooserAction = FILE_CHOOSER_ACTION_SELECT_FOLDER;
+		}
+		else
+		{
+			chooserAction = FILE_CHOOSER_ACTION_CREATE_FOLDER;
+			okButtonStockId = Stock::SAVE;
+		}
+	}
+
+	FileChooserDialog fileChooser(title, chooserAction);
+	fileChooser.set_filename(filename_from_utf8(location));
+	fileChooser.set_local_only();
+	fileChooser.set_select_multiple(false);
+	fileChooser.set_transient_for(parentWindow);
+	// Add response buttons
+	fileChooser.add_button(Stock::CANCEL, Gtk::RESPONSE_CANCEL);
+	fileChooser.add_button(okButtonStockId, Gtk::RESPONSE_OK);
+	// FIXME: add FileFilter's
+	fileChooser.show();
+	int result = fileChooser.run();
+	if (result == RESPONSE_OK)
+	{
+		// Retrieve the chosen location
+		if (directoriesOnly == false)
+		{
+			location = filename_to_utf8(fileChooser.get_filename());
+		}
+		else
+		{
+			location = filename_to_utf8(fileChooser.get_current_folder());
+		}
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Create a resizable text column.
+TreeViewColumn *create_resizable_column(const ustring &title, const TreeModelColumnBase& modelColumn)
+{
+	TreeViewColumn *treeColumn = new TreeViewColumn(title);
+
+	CellRendererText *textCellRenderer = new CellRendererText();
+	treeColumn->pack_start(*manage(textCellRenderer));
+	treeColumn->add_attribute(textCellRenderer->property_text(), modelColumn);
+	treeColumn->set_resizable(true);
+
+	return treeColumn;
+}
+
+/// Create a resizable text column, rendered by renderTextCell.
+TreeViewColumn *create_resizable_column(const ustring &title, const TreeModelColumnBase& modelColumn,
+	const TreeViewColumn::SlotCellData &renderTextCell)
+{
+	TreeViewColumn *treeColumn = new TreeViewColumn(title);
+
+	CellRendererText *textCellRenderer = new CellRendererText();
+	treeColumn->pack_start(*manage(textCellRenderer));
+	// This will be called to render the text
+	treeColumn->set_cell_data_func(*textCellRenderer, renderTextCell);
+
+	treeColumn->add_attribute(textCellRenderer->property_text(), modelColumn);
+	treeColumn->set_resizable(true);
+
+	return treeColumn;
+}
+
+/// Create a resizable icon and text column, rendered by renderTextAndIconCell.
+TreeViewColumn *create_resizable_column_with_icon(const ustring &title,
+	const TreeModelColumnBase& modelColumn, const TreeViewColumn::SlotCellData &renderTextAndIconCell)
+{
+	TreeViewColumn *treeColumn = new TreeViewColumn(title);
+
+	// Pack an icon renderer in the column
+	CellRendererPixbuf *iconRenderer = new CellRendererPixbuf();
+	treeColumn->pack_start(*manage(iconRenderer), false);
+	treeColumn->set_cell_data_func(*iconRenderer, renderTextAndIconCell);
+	// ...followed by a text renderer
+	CellRendererText *textCellRenderer = new CellRendererText();
+	treeColumn->pack_start(*manage(textCellRenderer));
+	treeColumn->set_cell_data_func(*textCellRenderer, renderTextAndIconCell);
+
+	treeColumn->add_attribute(textCellRenderer->property_text(), modelColumn);
+	treeColumn->set_resizable(true);
+
+	return treeColumn;
+}
+
+/// Converts to UTF-8, catches conversion errors
+ustring to_utf8(string text, ustring fallback)
+{
+	try
+	{
+		return locale_to_utf8(text);
+	}
+	catch (ConvertError &ce)
+	{
+	}
+
+	return fallback;
+}

Added: trunk/UI/GTK2/src/PinotUtils.h
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/PinotUtils.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,82 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#ifndef _PINOTUTILS_HH
+#define _PINOTUTILS_HH
+
+#include <string>
+#include <vector>
+#if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
+#include <sigc++/compatibility.h>
+#endif
+#include <sigc++/signal.h>
+#include <glibmm/ustring.h>
+#include <gtkmm/window.h>
+#include <gtkmm/treeview.h>
+#include <gtkmm/treemodel.h>
+
+/**
+  * DCTreeView subclasses TreeView and handles double clicks.
+  * Handling double-clicks on tree views is not straight-forward, see :
+  * http://bugzilla.gnome.org/show_bug.cgi?id=89780
+  * http://www.gtkmm.org/gtkmm2/docs/tutorial/html/ch08s07.html
+  */
+class DCTreeView : public Gtk::TreeView
+{
+	public:
+		DCTreeView() : Gtk::TreeView() {}
+		virtual ~DCTreeView() {}
+
+		SigC::Signal0<void> signal_double_click_event;
+
+	protected:
+		bool on_button_press_event(GdkEventButton* event)
+		{
+			// Check for double clicks
+			if (event->type == GDK_2BUTTON_PRESS)
+			{
+				signal_double_click_event();
+				return true;
+			}
+
+			// Not handled
+			return TreeView::on_button_press_event(event);
+		}
+
+};
+
+/// Open a FileSelector and request a file. Location can be initialized.
+bool select_file_name(Gtk::Window &parentWindow, const Glib::ustring &title,
+	Glib::ustring &location, bool openOrCreate = true, bool directoriesOnly = false);
+
+/// Create a resizable text column.
+Gtk::TreeViewColumn *create_resizable_column(const Glib::ustring &title,
+	const Gtk::TreeModelColumnBase& modelColumn);
+
+/// Create a resizable text column, rendered by renderTextCell.
+Gtk::TreeViewColumn *create_resizable_column(const Glib::ustring &title,
+	const Gtk::TreeModelColumnBase& modelColumn,
+	const  Gtk::TreeViewColumn::SlotCellData &renderTextCell);
+
+/// Create a resizable icon and text column, rendered by renderTextAndIconCell.
+Gtk::TreeViewColumn *create_resizable_column_with_icon(const Glib::ustring &title,
+	const Gtk::TreeModelColumnBase& modelColumn,
+	const  Gtk::TreeViewColumn::SlotCellData &renderTextAndIconCell);
+
+/// Converts to UTF-8, catches conversion errors
+Glib::ustring to_utf8(std::string text, Glib::ustring fallback = Glib::ustring(""));
+
+#endif // _PINOTUTILS_HH

Added: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,1122 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+#include <gtkmm/alignment.h>
+#include <gtkmm/box.h>
+#include <gtkmm/buttonbox.h>
+#include <gtkmm/image.h>
+#include <gtkmm/label.h>
+#include <gtkmm/stock.h>
+#include <gtkmm/textbuffer.h>
+
+#include "HtmlTokenizer.h"
+#include "Url.h"
+#include "QueryHistory.h"
+#include "ViewHistory.h"
+#include "XapianIndex.h"
+#include "config.h"
+#include "NLS.h"
+#include "PinotSettings.h"
+#include "PinotUtils.h"
+#include "ResultsTree.h"
+
+using namespace std;
+using namespace SigC;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+ResultsTree::ResultsTree(VBox *resultsVbox, Menu *pPopupMenu, PinotSettings &settings) :
+	TreeView(),
+	m_pPopupMenu(pPopupMenu),
+	m_settings(settings),
+	m_extractScrolledwindow(NULL),
+	m_extractTextview(NULL),
+	m_showExtract(true)
+{
+	HBox *extractHbox = manage(new class Gtk::HBox(false, 0));
+	ScrolledWindow *resultsScrolledwindow = manage(new ScrolledWindow());
+	m_extractScrolledwindow = manage(new ScrolledWindow());
+	m_extractTextview = manage(new TextView());
+
+	// This is the actual results tree
+	set_events(Gdk::BUTTON_PRESS_MASK);
+	set_flags(CAN_FOCUS);
+	set_headers_visible(true);
+	set_rules_hint(true);
+	set_reorderable(false);
+	set_enable_search(true);
+	resultsScrolledwindow->set_flags(CAN_FOCUS);
+	resultsScrolledwindow->set_border_width(4);
+	resultsScrolledwindow->set_shadow_type(SHADOW_NONE);
+	resultsScrolledwindow->set_policy(POLICY_AUTOMATIC, POLICY_ALWAYS);
+	resultsScrolledwindow->property_window_placement().set_value(CORNER_TOP_LEFT);
+	resultsScrolledwindow->add(*this);
+
+	// That's for the extract view
+	m_extractTextview->set_flags(CAN_FOCUS);
+	m_extractTextview->set_editable(false);
+	m_extractTextview->set_cursor_visible(false);
+	m_extractTextview->set_pixels_above_lines(0);
+	m_extractTextview->set_pixels_below_lines(0);
+	m_extractTextview->set_pixels_inside_wrap(0);
+	m_extractTextview->set_left_margin(0);
+	m_extractTextview->set_right_margin(0);
+	m_extractTextview->set_indent(0);
+	m_extractTextview->set_wrap_mode(WRAP_WORD);
+	m_extractTextview->set_justification(JUSTIFY_LEFT);
+	m_extractScrolledwindow->set_flags(CAN_FOCUS);
+	m_extractScrolledwindow->set_border_width(4);
+	m_extractScrolledwindow->set_shadow_type(SHADOW_NONE);
+	m_extractScrolledwindow->set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
+	m_extractScrolledwindow->property_window_placement().set_value(CORNER_TOP_LEFT);
+	m_extractScrolledwindow->add(*m_extractTextview);
+
+	// Position the scrolled windows
+	resultsVbox->pack_start(*resultsScrolledwindow, Gtk::PACK_EXPAND_WIDGET, 0);
+	resultsVbox->pack_start(*m_extractScrolledwindow, Gtk::PACK_SHRINK, 0);
+
+	// Associate the columns model to the results tree
+	m_refStore = TreeStore::create(m_resultsColumns);
+	set_model(m_refStore);
+
+	// The title column is also used for status icons
+	TreeViewColumn *treeColumn = new TreeViewColumn(_("Title"));
+	// Pack an icon renderer for the viewed status
+	CellRendererPixbuf *iconRenderer = new CellRendererPixbuf();
+	treeColumn->pack_start(*manage(iconRenderer), false);
+	treeColumn->set_cell_data_func(*iconRenderer, SigC::slot(*this, &ResultsTree::renderViewStatus));
+	// Pack a second icon renderer for the indexed status
+	iconRenderer = new CellRendererPixbuf();
+	treeColumn->pack_start(*manage(iconRenderer), false);
+	treeColumn->set_cell_data_func(*iconRenderer, SigC::slot(*this, &ResultsTree::renderIndexStatus));
+	// And a third one for the ranking
+	iconRenderer = new CellRendererPixbuf();
+	treeColumn->pack_start(*manage(iconRenderer), false);
+	treeColumn->set_cell_data_func(*iconRenderer, SigC::slot(*this, &ResultsTree::renderRanking));
+	treeColumn->pack_end(m_resultsColumns.m_text, false);
+	treeColumn->set_resizable(true);
+	append_column(*manage(treeColumn));
+
+	// The last column is for the URL
+	append_column(_("URL"), m_resultsColumns.m_url);
+
+	// Make headers clickable
+	set_headers_clickable(true);
+	// Allow multiple selection
+	get_selection()->set_mode(SELECTION_MULTIPLE);
+
+	// Handle button presses
+	signal_button_press_event().connect_notify(SigC::slot(*this, &ResultsTree::onButtonPressEvent));
+	// Enable interactive search
+	set_search_column(m_resultsColumns.m_text.index());
+	set_search_equal_func(SigC::slot(*this, &ResultsTree::onSearchEqual));
+	// Control which rows can be selected
+	get_selection()->set_select_function(SigC::slot(*this, &ResultsTree::onSelectionSelect));
+	// Listen for style changes
+	signal_style_changed().connect_notify(SigC::slot(*this, &ResultsTree::onStyleChanged));
+
+	// Render the icons
+	m_indexedIconPixbuf = render_icon(Stock::INDEX, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_viewededIconPixbuf = render_icon(Stock::YES, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_newIconPixbuf = render_icon(Stock::NEW, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_upIconPixbuf = render_icon(Stock::GO_UP, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_downIconPixbuf = render_icon(Stock::GO_DOWN, ICON_SIZE_MENU, "MetaSE-pinot");
+
+	// Show all
+	show();
+	resultsScrolledwindow->show();
+	m_extractTextview->show();
+	m_extractScrolledwindow->show();
+	extractHbox->show();
+}
+
+ResultsTree::~ResultsTree()
+{
+}
+
+void ResultsTree::renderViewStatus(CellRenderer *renderer, const TreeModel::iterator &iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (renderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *iconRenderer = dynamic_cast<CellRendererPixbuf*>(renderer);
+	if (iconRenderer != NULL)
+	{
+		// Has this result been already viewed ?
+		if ((row[m_resultsColumns.m_viewed] == true) &&
+			(m_viewededIconPixbuf))
+		{
+			iconRenderer->property_pixbuf() = m_viewededIconPixbuf;
+		}
+		else
+		{
+			iconRenderer->property_pixbuf().reset_value();
+		}
+	}
+}
+
+void ResultsTree::renderIndexStatus(CellRenderer *renderer, const TreeModel::iterator &iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (renderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *iconRenderer = dynamic_cast<CellRendererPixbuf*>(renderer);
+	if (iconRenderer != NULL)
+	{
+		// Is this result indexed ?
+		if ((row[m_resultsColumns.m_indexed] == true) &&
+			(m_indexedIconPixbuf))
+		{
+			iconRenderer->property_pixbuf() = m_indexedIconPixbuf;
+		}
+		else
+		{
+			iconRenderer->property_pixbuf().reset_value();
+		}
+	}
+}
+
+void ResultsTree::renderRanking(CellRenderer *renderer, const TreeModel::iterator &iter)
+{
+	TreeModel::Row row = *iter;
+
+	if (renderer == NULL)
+	{
+		return;
+	}
+
+	CellRendererPixbuf *iconRenderer = dynamic_cast<CellRendererPixbuf*>(renderer);
+	if (iconRenderer != NULL)
+	{
+		// Is this result new ?
+		if (row[m_resultsColumns.m_rankDiff] == 666)
+		{
+			iconRenderer->property_pixbuf() = m_newIconPixbuf;
+		}
+		// Has its score changed ?
+		else if (row[m_resultsColumns.m_rankDiff] > 0)
+		{
+			iconRenderer->property_pixbuf() = m_upIconPixbuf;
+		}
+		else if (row[m_resultsColumns.m_rankDiff] < 0)
+		{
+			iconRenderer->property_pixbuf() = m_downIconPixbuf;
+		}
+		else
+		{
+			iconRenderer->property_pixbuf().reset_value();
+		}
+	}
+}
+
+//
+// Interactive search equal function.
+//
+bool ResultsTree::onSearchEqual(const RefPtr<TreeModel>& model, int column,
+	const ustring& key, const TreeModel::iterator& iter)
+{
+}
+
+//
+// Handles button presses.
+//
+void ResultsTree::onButtonPressEvent(GdkEventButton *ev)
+{
+	// Check for popup click
+	if ((ev->type == GDK_BUTTON_PRESS) &&
+		(ev->button == 3) )
+	{
+		if (m_pPopupMenu != NULL)
+		{
+			m_pPopupMenu->popup(ev->button, ev->time);
+		}
+	}
+	// Check for double clicks
+	else if (ev->type == GDK_2BUTTON_PRESS)
+	{
+#ifdef DEBUG
+		cout << "ResultsTree::onButtonPressEvent: double click on button " << ev->button << endl;
+#endif
+		// Get the selected result, if any
+		TreeModel::iterator iter = get_selection()->get_selected();
+		if (iter)
+		{
+			TreeModel::Path resultPath = m_refStore->get_path(iter);
+			// Is the row already expanded ?
+			if (row_expanded(resultPath) == false)
+			{
+				// Expand it
+				expand_row(resultPath, true);
+			}
+			else
+			{
+				// Collapse it
+				collapse_row(resultPath);
+			}
+		}
+	}
+}
+
+//
+// Handles selection changes.
+//
+bool ResultsTree::onSelectionChanged(void)
+{
+	bool goodSel = true;
+
+#ifdef DEBUG
+	cout << "ResultsTree::onSelectionChanged: called" << endl;
+#endif
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return false;
+	}
+
+	// Go through selected items
+	for (list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+		itemPath != selectedItems.end(); ++itemPath)
+	{
+		TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+
+		// Check only results are selected
+		ResultsModelColumns::ResultType type = row[m_resultsColumns.m_type];
+		if (type != ResultsModelColumns::RESULT_TITLE)
+		{
+			goodSel = false;
+		}
+	}
+
+	return goodSel;
+}
+
+//
+// Handles attempts to select rows.
+//
+bool ResultsTree::onSelectionSelect(const RefPtr<TreeModel>& model,
+		const TreeModel::Path& path, bool path_currently_selected)
+{
+	const TreeModel::iterator iter = model->get_iter(path);
+	const TreeModel::Row row = *iter;
+
+	m_indexNames.clear();
+
+	if (path_currently_selected == true)
+	{
+#ifdef DEBUG
+		cout << "ResultsTree::onSelectionSelect: unselected entry " << row[m_resultsColumns.m_text] << endl;
+#endif
+	}
+	else
+	{
+#ifdef DEBUG
+		cout << "ResultsTree::onSelectionSelect: selected entry " << row[m_resultsColumns.m_text] << endl;
+#endif
+
+		// Is this an actual result ?
+		ResultsModelColumns::ResultType type = row[m_resultsColumns.m_type];
+		if (type == ResultsModelColumns::RESULT_TITLE)
+		{
+			QueryHistory history(m_settings.m_historyDatabase);
+			set<string> engineNames, indexNames;
+			string extract;
+
+			m_queryName = locale_from_utf8(row[m_resultsColumns.m_queryName]);
+			string url = locale_from_utf8(row[m_resultsColumns.m_url]);
+			unsigned int engineIds = row[m_resultsColumns.m_engines];
+			unsigned int indexIds = row[m_resultsColumns.m_indexes];
+
+#ifdef DEBUG
+			cout << "ResultsTree::onSelectionSelect: selected result (" << engineIds << "," << indexIds << ")" << endl;
+#endif
+			m_settings.getEngineNames(engineIds, engineNames);
+			if (engineNames.empty() == false)
+			{
+				// Get the first engine this result was obtained from
+				string engineName = (*engineNames.begin());
+				if (engineName == "Xapian")
+				{
+					m_settings.getIndexNames(indexIds, indexNames);
+					if (indexNames.empty() == false)
+					{
+						// Use the name of the first index as engine name
+						engineName = (*indexNames.begin());
+
+						// Any internal index in there ?
+						for (set<string>::iterator indexIter = indexNames.begin(); indexIter != indexNames.end(); ++indexIter)
+						{
+							if  (m_settings.isInternalIndex(*indexIter) == true)
+							{
+								m_indexNames.insert(*indexIter);
+							}
+						}
+					}
+				}
+
+#ifdef DEBUG
+				cout << "ResultsTree::onSelectionSelect: first engine for " << url << " was " << engineName << endl;
+#endif
+				extract = history.getItemExtract(m_queryName, engineName, url);
+			}
+
+			RefPtr<TextBuffer> refBuffer = m_extractTextview->get_buffer();
+			refBuffer->set_text(to_utf8(extract));
+			// The extract is not editable
+			m_extractTextview->set_editable(false);
+			m_extractTextview->set_cursor_visible(false);
+		}
+	}
+
+	return true;
+}
+
+//
+// Handles GTK style changes.
+//
+void ResultsTree::onStyleChanged(const RefPtr<Style> &previous_style)
+{
+#ifdef DEBUG
+	cout << "ResultsTree::onStyleChanged: called" << endl;
+#endif
+	// FIXME: find better icons :-)
+	m_indexedIconPixbuf = render_icon(Stock::INDEX, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_viewededIconPixbuf = render_icon(Stock::YES, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_newIconPixbuf = render_icon(Stock::NEW, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_upIconPixbuf = render_icon(Stock::GO_UP, ICON_SIZE_MENU, "MetaSE-pinot");
+	m_downIconPixbuf = render_icon(Stock::GO_DOWN, ICON_SIZE_MENU, "MetaSE-pinot");
+}
+
+//
+// Adds a set of results.
+// Returns true if something was added to the tree.
+//
+bool ResultsTree::addResults(QueryProperties &queryProps, const string &engineName,
+	const vector<Result> &resultsList, bool groupBySearchEngine)
+{
+	std::map<string, TreeModel::iterator> updatedGroups;
+	string registeredEngineName = engineName;
+	unsigned int count = 0;
+	ResultsModelColumns::ResultType rootType;
+
+	string queryName = queryProps.getName();
+	string language = queryProps.getLanguage();
+	string labelName = queryProps.getLabelName();
+
+	// Unselect all
+	get_selection()->unselect_all();
+
+	// This describes the query
+	string queryDetails = "\"";
+	queryDetails += queryName;
+	queryDetails += "\" ";
+	queryDetails += _("on");
+	queryDetails += " ";
+	queryDetails += registeredEngineName;
+
+	// What's the grouping criteria ?
+	if (groupBySearchEngine == true)
+	{
+		// By search engine
+		rootType = ResultsModelColumns::RESULT_ROOT;
+	}
+	else
+	{
+		// By host
+		rootType = ResultsModelColumns::RESULT_HOST;
+	}
+
+	// Find out what the search engine ID is
+	unsigned int indexId = 0;
+	unsigned int engineId = m_settings.getEngineId(registeredEngineName);
+	if (engineId == 0)
+	{
+		// Chances are this engine is an index
+		std::map<string, string>::const_iterator mapIter = m_settings.getIndexes().find(registeredEngineName);
+		if (mapIter != m_settings.getIndexes().end())
+		{
+			// Yes, it is
+			indexId = m_settings.getIndexId(registeredEngineName);
+			engineId = m_settings.getEngineId("Xapian");
+#ifdef DEBUG
+			cout << "ResultsTree::addResults: engine is index " << registeredEngineName << endl;
+#endif
+		}
+#ifdef DEBUG
+		else cout << "ResultsTree::addResults: " << registeredEngineName << " is not an index" <<  endl;
+#endif
+	}
+#ifdef DEBUG
+	cout << "ResultsTree::addResults: ID for engine " << registeredEngineName << " is " << engineId <<  endl;
+#endif
+
+	QueryHistory history(m_settings.m_historyDatabase);
+	bool isNewQuery = false;
+	if (history.getLastRun(queryName, engineName).empty() == true)
+	{
+		isNewQuery = true;
+	}
+
+	// Look at the results list
+#ifdef DEBUG
+	cout << "ResultsTree::addResults: " << resultsList.size() << " results to display" << endl;
+#endif
+	for (vector<Result>::const_iterator resultIter = resultsList.begin();
+		resultIter != resultsList.end(); ++resultIter)
+	{
+		string title = resultIter->getTitle();
+		string location = resultIter->getLocation();
+		string extract = resultIter->getExtract();
+		float currentScore = resultIter->getScore();
+		string score;
+		int rankDiff = 0;
+
+		// What group should the result go to ?
+		string groupName;
+		if (rootType == ResultsModelColumns::RESULT_HOST)
+		{
+			Url urlObj(location);
+			groupName = urlObj.getHost();
+		}
+		else
+		{
+			groupName = queryDetails;
+		}
+
+		// Add the group or get its position if it's already in
+		TreeModel::iterator groupIter;
+		if (appendGroup(groupName, rootType, groupIter) == true)
+		{
+			// OK, add a row for this result within the group
+			TreeModel::iterator titleIter;
+
+			// Has the result's ranking changed ?
+			float oldestScore = 0;
+			float previousScore = history.hasItem(queryName, registeredEngineName, location, oldestScore);
+			if (previousScore > 0)
+			{
+				// Update this result whatever the current and previous rankings were
+				history.updateItem(queryName, registeredEngineName, location, title, extract, language, currentScore);
+				rankDiff = (int)(currentScore - previousScore);
+			}
+			else
+			{
+				// No, this is a new result
+				history.insertItem(queryName, registeredEngineName, location, resultIter->getTitle(), extract, language, currentScore);
+				// New results are displayed as such only if the query has already been run on the engine
+				if (isNewQuery == false)
+				{
+					// This is a magic value :-)
+					rankDiff = 666;
+				}
+			}
+
+			++count;
+			if (appendResult(title, location, currentScore, language, rankDiff,
+				queryName, engineId, indexId, titleIter, &(*groupIter), true) == true)
+			{
+#ifdef DEBUG
+				cout << "ResultsTree::addResults: added row for result " << count << endl;
+#endif
+
+				// Update this map, so that we know which groups need updating
+				updatedGroups[groupName] = groupIter;
+			}
+		}
+	}
+
+	if (count > 0)
+	{
+#ifdef DEBUG
+		cout << "ResultsTree::addResults: " << updatedGroups.size() << " groups to update" << endl;
+#endif
+		// Update the groups to which we have added results
+		for (std::map<string, TreeModel::iterator>::iterator mapIter = updatedGroups.begin();
+			mapIter != updatedGroups.end(); mapIter++)
+		{
+			TreeModel::iterator groupIter = mapIter->second;
+			updateGroup(groupIter);
+		}
+
+		return true;
+	}
+	else
+	{
+		if (rootType == ResultsModelColumns::RESULT_ROOT)
+		{
+			// If this didn't return any result, add an empty group
+			TreeModel::iterator groupIter;
+			appendGroup(queryDetails, rootType, groupIter);
+			updateGroup(groupIter);
+
+			return true;
+		}
+	}
+
+	return false;
+}
+
+//
+// Groups results.
+//
+void ResultsTree::regroupResults(bool groupBySearchEngine)
+{
+	ResultsModelColumns::ResultType currentType, newType;
+
+#ifdef DEBUG
+	cout << "ResultsTree::regroupResults: called" << endl;
+#endif
+	// What's the new grouping criteria ?
+	if (groupBySearchEngine == true)
+	{
+		// By search engine
+		currentType = ResultsModelColumns::RESULT_HOST;
+		newType = ResultsModelColumns::RESULT_ROOT;
+	}
+	else
+	{
+		// By host
+		currentType = ResultsModelColumns::RESULT_ROOT;
+		newType = ResultsModelColumns::RESULT_HOST;
+	}
+
+	// Go through tree rows
+	TreeModel::Children children = m_refStore->children();
+	if (children.empty() == true)
+	{
+		return;
+	}
+
+	// Clear the map
+	m_resultsGroups.clear();
+
+	// Unselect results
+	get_selection()->unselect_all();
+
+	TreeModel::Children::iterator iter = children.begin();
+	while (iter != children.end())
+	{
+		TreeModel::Row row = *iter;
+#ifdef DEBUG
+		cout << "ResultsTree::groupBySearchEngine: looking at " << row[m_resultsColumns.m_text] << endl;
+#endif
+		ResultsModelColumns::ResultType type = row[m_resultsColumns.m_type];
+		// Skip new type rows
+		if (type == newType)
+		{
+			iter++;
+			continue;
+		}
+
+		TreeModel::Children child = iter->children();
+		if (child.empty() == false)
+		{
+			TreeModel::Children::iterator childIter = child.begin();
+			// Type RESULT_TITLE
+			while (childIter != child.end())
+			{
+				TreeModel::Row childRow = *childIter;
+				TreeModel::iterator groupIter, newIter;
+				bool success = false;
+
+				// We will need the URL and engines columns in all cases
+				string url = locale_from_utf8(childRow[m_resultsColumns.m_url]);
+				unsigned int engineIds = childRow[m_resultsColumns.m_engines];
+				unsigned int indexIds = childRow[m_resultsColumns.m_indexes];
+
+				// Get the name of the group this should go into
+				if (newType == ResultsModelColumns::RESULT_HOST)
+				{
+					Url urlObj(url);
+#ifdef DEBUG
+					cout << "ResultsTree::groupBySearchEngine: row " << url << endl;
+#endif
+					string groupName = urlObj.getHost();
+					// Add group
+					if (appendGroup(groupName, newType, groupIter) == true)
+					{
+						// Add result
+						success = appendResult(locale_from_utf8(childRow[m_resultsColumns.m_text]), url,
+							(float)atof(locale_from_utf8(childRow[m_resultsColumns.m_score]).c_str()),
+							locale_from_utf8(childRow[m_resultsColumns.m_language]),
+							childRow[m_resultsColumns.m_rankDiff],
+							locale_from_utf8(childRow[m_resultsColumns.m_queryName]),
+							engineIds, indexIds, newIter, &(*groupIter), true);
+					}
+				}
+				else
+				{
+					// Look at the engines column and see which engines this result is for
+					set<string> engineNames;
+					m_settings.getEngineNames(engineIds, engineNames);
+					if (engineNames.empty() == false)
+					{
+#ifdef DEBUG
+						cout << "ResultsTree::groupBySearchEngine: row is for " << engineNames.size() << endl;
+#endif
+						// Are there indexes in the list ?
+						set<string>::iterator xapianIter = engineNames.find("Xapian");
+						if ((xapianIter != engineNames.end()) &&
+							(indexIds > 0))
+						{
+							// Erase this
+							engineNames.erase(xapianIter);
+
+							// Add entries for each index name so that we can loop once on engine names
+							set<string> indexNames;
+							m_settings.getIndexNames(indexIds, indexNames);
+							for (set<string>::iterator iter = indexNames.begin(); iter != indexNames.end(); ++iter)
+							{
+								string indexName = (*iter);
+								engineNames.insert(indexName);
+#ifdef DEBUG
+								cout << "ResultsTree::groupBySearchEngine: row is for index " << indexName << endl;
+#endif
+							}
+						}
+
+						for (set<string>::iterator iter = engineNames.begin(); iter != engineNames.end(); ++iter)
+						{
+							string engineName = (*iter);
+
+							string groupName = "\"";
+							groupName += locale_from_utf8(childRow[m_resultsColumns.m_queryName]);
+							groupName += "\" ";
+							groupName += _("on");
+							groupName += " ";
+							groupName += engineName;
+
+							unsigned int indexId = 0;
+							unsigned int engineId = m_settings.getEngineId(engineName);
+							if (engineId == 0)
+							{
+								// This is actually an index, not an engine...
+								indexId = m_settings.getIndexId(engineName);
+								if (indexId > 0)
+								{
+									engineId = m_settings.getEngineId("Xapian");
+								}
+							}
+
+							// Add group
+							if (appendGroup(groupName, newType, groupIter) == true)
+							{
+								// Add result
+								appendResult(locale_from_utf8(childRow[m_resultsColumns.m_text]), url,
+									(float)atof(locale_from_utf8(childRow[m_resultsColumns.m_score]).c_str()),
+									locale_from_utf8(childRow[m_resultsColumns.m_language]),
+									childRow[m_resultsColumns.m_rankDiff],
+									locale_from_utf8(childRow[m_resultsColumns.m_queryName]),
+									engineId, indexId,
+									newIter, &(*groupIter), true);
+#ifdef DEBUG
+								cout << "ResultsTree::groupBySearchEngine: row for " << *iter << endl;
+#endif
+							}
+						}
+
+						// FIXME: make sure at least one row was added
+						success = true;
+					}
+				}
+
+				if (success == true)
+				{
+					// Delete it
+					m_refStore->erase(*childIter);
+					childIter = child.begin();
+				}
+				else
+				{
+					// Don't delete anything then, just go to the next child
+					childIter++;
+				}
+			}
+		}
+
+		// Erase this row
+		m_refStore->erase(*iter);
+
+		// Get the new first row, that way we don't have to worry about iterators validity
+		iter = children.begin();
+	}
+
+	for (std::map<string, TreeModel::iterator>::iterator mapIter = m_resultsGroups.begin();
+		mapIter != m_resultsGroups.end(); mapIter++)
+	{
+		TreeModel::iterator groupIter = mapIter->second;
+		updateGroup(groupIter);
+	}
+
+	onSelectionChanged();
+}
+
+//
+// Gets the first selected item's URL.
+//
+ustring ResultsTree::getFirstSelectionURL(void)
+{
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return "";
+	}
+
+	list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+	TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+	TreeModel::Row row = *iter;
+	return row[m_resultsColumns.m_url];
+}
+
+//
+// Gets a list of selected items.
+//
+bool ResultsTree::getSelection(vector<Result> &resultsList)
+{
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return false;
+	}
+
+	// Go through selected items
+	for (list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+		itemPath != selectedItems.end(); ++itemPath)
+	{
+		TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+
+		resultsList.push_back(Result(locale_from_utf8(row[m_resultsColumns.m_url]),
+			locale_from_utf8(row[m_resultsColumns.m_text]),
+			"", locale_from_utf8(row[m_resultsColumns.m_language])));
+	}
+#ifdef DEBUG
+	cout << "ResultsTree::getSelection: " << resultsList.size() << " results selected" << endl;
+#endif
+
+	return true;
+}
+
+//
+// Sets the first selected item's viewed state.
+//
+void ResultsTree::setFirstSelectionViewedState(bool viewed)
+{
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return;
+	}
+
+	list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+	TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+	TreeModel::Row row = *iter;
+	row[m_resultsColumns.m_viewed] = viewed;
+}
+
+//
+// Deletes the current selection.
+//
+bool ResultsTree::deleteSelection(void)
+{
+	bool empty = false;
+
+	// Go through selected items
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+	while (itemPath != selectedItems.end())
+	{
+		TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+		TreeModel::iterator parentIter;
+		bool updateParent = false;
+
+		// This could be a group that's in the map and should be removed first
+		if (row[m_resultsColumns.m_type] != ResultsModelColumns::RESULT_TITLE)
+		{
+			string groupName = locale_from_utf8(row[m_resultsColumns.m_text]);
+			std::map<string, TreeModel::iterator>::iterator mapIter = m_resultsGroups.find(groupName);
+			if (mapIter != m_resultsGroups.end())
+			{
+				m_resultsGroups.erase(mapIter);
+#ifdef DEBUG
+				cout << "ResultsTree::deleteResults: erased group " << groupName << endl;
+#endif
+			}
+		}
+		else
+		{
+			// This item is a result
+			parentIter = row.parent();
+			updateParent = true;
+		}
+
+		// Unselect and erase
+		get_selection()->unselect(iter);
+		m_refStore->erase(row);
+
+		// Update group ?
+		if (updateParent == true)
+		{
+			// Update the group this result belongs to
+			updateGroup(parentIter);
+		}
+
+		selectedItems = get_selection()->get_selected_rows();
+		itemPath = selectedItems.begin();
+	}
+
+	TreeModel::Children children = m_refStore->children();
+	empty = children.empty();
+
+	columns_autosize();
+
+	return empty;
+}
+
+//
+// Clear the tree.
+//
+void ResultsTree::clear(void)
+{
+	// Unselect results
+	get_selection()->unselect_all();
+
+	// Remove existing rows in the tree
+	TreeModel::Children children = m_refStore->children();
+	if (children.empty() == false)
+	{
+		// Clear the groups map
+		m_resultsGroups.clear();
+
+		TreeModel::Children::iterator iter = children.begin();
+		while (iter != children.end())
+		{
+			// Erase this row
+			m_refStore->erase(*iter);
+
+			// Get the new first row
+			children = m_refStore->children();
+			iter = children.begin();
+		}
+		m_refStore->clear();
+
+		// Clear the extract field
+		RefPtr<TextBuffer> refBuffer = m_extractTextview->get_buffer();
+		refBuffer->set_text("");
+		m_extractTextview->set_editable(false);
+		m_extractTextview->set_cursor_visible(false);
+
+		onSelectionChanged();
+	}
+}
+
+//
+// Shows or hides the extract field.
+//
+void ResultsTree::showExtract(bool show)
+{
+	m_showExtract = show;
+	if (m_showExtract == true)
+	{
+		// Show the extract
+		m_extractScrolledwindow->show();
+	}
+	else
+	{
+		// Hide
+		m_extractScrolledwindow->hide();
+	}
+}
+
+//
+// Adds a new row in the results tree.
+//
+bool ResultsTree::appendResult(const string &text, const string &url,
+	float score, const string &language, int rankDiff,
+	const string &queryName, unsigned int engineId, unsigned int indexId,
+	TreeModel::iterator &newRowIter, const TreeModel::Row *parentRow, bool noDuplicates)
+{
+	if (parentRow == NULL)
+	{
+		newRowIter = m_refStore->append();
+	}
+	else
+	{
+		// Merge duplicates within groups ?
+		if (noDuplicates == true)
+		{
+			// Look for a row with the same URL and query. For instance, in group
+			// by host mode, if a page is returned by several search engines, it
+			// should appear only once
+			TreeModel::Children children = parentRow->children();
+			if (children.empty() == false)
+			{
+				TreeModel::Children::iterator childIter = children.begin();
+				for (; childIter != children.end(); ++childIter)
+				{
+					TreeModel::Row row = *childIter;
+					if ((row[m_resultsColumns.m_url] == to_utf8(url)) &&
+						(row[m_resultsColumns.m_queryName] == to_utf8(queryName)))
+					{
+						// Update the engines column...
+						row[m_resultsColumns.m_engines] = row[m_resultsColumns.m_engines] | engineId;
+						// ...and the indexes column too
+						row[m_resultsColumns.m_indexes] = row[m_resultsColumns.m_indexes] | engineId;
+#ifdef DEBUG
+						cout << "ResultsTree::appendResult: merged " << text << " " << engineId << " (" << row[m_resultsColumns.m_engines] << "," << row[m_resultsColumns.m_indexes] << ")" << endl;
+#endif
+
+						newRowIter = childIter;
+						return true;
+					}
+				}
+			}
+		}
+
+		newRowIter = m_refStore->append(parentRow->children());
+#ifdef DEBUG
+		cout << "ResultsTree::appendResult: added " << text << ", " << score << " to "
+			<< (*parentRow)[m_resultsColumns.m_text] << endl;
+#endif
+	}
+
+	string strippedText = HtmlTokenizer::stripTags(text);
+	XapianIndex index(m_settings.m_indexLocation);
+	ViewHistory viewHistory(m_settings.m_historyDatabase);
+	DocumentInfo docInfo(text, url, "", language);
+	bool isIndexed = false;
+
+	// Is this document indexed ?
+	if ((index.isGood() == true) &&
+		(index.hasDocument(docInfo) > 0))
+	{
+		isIndexed = true;
+	}
+
+	// Has it been already viewed ?
+	bool wasViewed = viewHistory.hasItem(url);
+
+	char scoreStr[128];
+	snprintf(scoreStr, 128, "%.f", score);
+
+	TreeModel::Row childRow = *newRowIter;
+	updateRow(childRow, to_utf8(strippedText, "???"),
+		to_utf8(url), scoreStr,
+		to_utf8(language), to_utf8(queryName), engineId, indexId,
+		ResultsModelColumns::RESULT_TITLE, isIndexed,
+		wasViewed, rankDiff);
+
+	return true;
+}
+
+//
+// Adds a results group
+//
+bool ResultsTree::appendGroup(const string &groupName,
+	ResultsModelColumns::ResultType groupType, TreeModel::iterator &groupIter)
+{
+	bool success = false;
+
+	// Is this group already in ?
+	std::map<string, TreeModel::iterator>::iterator mapIter = m_resultsGroups.find(groupName);
+	if (mapIter == m_resultsGroups.end())
+	{
+		// No, it isn't: insert a new group in the tree
+		groupIter = m_refStore->append();
+		TreeModel::Row groupRow = *groupIter;
+		updateRow(groupRow, to_utf8(groupName, "???"),
+				"", "", "", "", 0, 0, groupType,
+				false, false, false);
+
+		// Update the map
+		m_resultsGroups[groupName] = groupIter;
+		success = true;
+#ifdef DEBUG
+		cout << "ResultsTree::appendGroup: updated map with " << groupName << endl;
+#endif
+	}
+	else
+	{
+		// Yes, it is
+		groupIter = mapIter->second;
+#ifdef DEBUG
+		cout << "ResultsTree::appendGroup: found " << groupName << " in map" << endl;
+#endif
+		success = true;
+	}
+
+	return success;
+}
+
+//
+// Updates a results group.
+//
+void ResultsTree::updateGroup(TreeModel::iterator &groupIter)
+{
+	TreeModel::Row groupRow = (*groupIter);
+
+	// Check the iterator doesn't point to a result
+	if (groupRow[m_resultsColumns.m_type] == ResultsModelColumns::RESULT_TITLE)
+	{
+		return;
+	}
+
+	// Modify the "score" column to indicate the number of results in that group
+	TreeModel::Children groupChildren = groupIter->children();
+	char scoreStr[64];
+	snprintf(scoreStr, 64, "%u", groupChildren.size());
+	groupRow[m_resultsColumns.m_score] = scoreStr;
+#ifdef DEBUG
+	cout << "ResultsTree::updateGroup: group " << groupRow[m_resultsColumns.m_text] << " has " << groupChildren.size() << " children" << endl;
+#endif
+
+	// Expand this group
+	TreeModel::Path groupPath = m_refStore->get_path(groupIter);
+	expand_row(groupPath, true);
+}
+
+//
+// Updates a row.
+//
+void ResultsTree::updateRow(TreeModel::Row &row, const ustring &text,
+	const ustring &url, const ustring &score, const ustring &language,
+	const ustring &queryName, unsigned int engineId,  unsigned int indexId,
+	ResultsModelColumns::ResultType type, bool indexed, bool viewed, int rankDiff)
+{
+	row[m_resultsColumns.m_text] = text;
+	row[m_resultsColumns.m_url] = url;
+	row[m_resultsColumns.m_score] = score;
+	row[m_resultsColumns.m_language] = language;
+	row[m_resultsColumns.m_queryName] = queryName;
+	row[m_resultsColumns.m_engines] = engineId;
+	row[m_resultsColumns.m_indexes] = indexId;
+	row[m_resultsColumns.m_type] = type;
+
+	row[m_resultsColumns.m_indexed] = indexed;
+	row[m_resultsColumns.m_viewed] = viewed;
+	row[m_resultsColumns.m_rankDiff] = rankDiff;
+}

Added: trunk/UI/GTK2/src/ResultsTree.h
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/ResultsTree.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,148 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _RESULTSTREE_HH
+#define _RESULTSTREE_HH
+
+#include <string>
+#include <vector>
+#include <set>
+#include <map>
+#include <sigc++/slot.h>
+#include <glibmm/refptr.h>
+#include <glibmm/ustring.h>
+#include <gdkmm/pixbuf.h>
+#include <gtkmm/box.h>
+#include <gtkmm/button.h>
+#include <gtkmm/menu.h>
+#include <gtkmm/scrolledwindow.h>
+#include <gtkmm/textview.h>
+#include <gtkmm/treestore.h>
+#include <gtkmm/treeview.h>
+#include <gtkmm/treeselection.h>
+
+#include "QueryProperties.h"
+#include "Result.h"
+#include "ModelColumns.h"
+#include "PinotSettings.h"
+
+class ResultsTree : public Gtk::TreeView
+{
+	public:
+		ResultsTree(Gtk::VBox *resultsVbox, Gtk::Menu *pPopupMenu, PinotSettings &settings);
+		virtual ~ResultsTree();
+
+		/**
+		  * Handles selection changes.
+		  * Returns true if a result is selected.
+		  */
+		bool onSelectionChanged(void);
+
+		/**
+		  * Adds a set of results.
+		  * Returns true if something was added to the tree.
+		  */
+		bool addResults(QueryProperties &queryProps, const std::string &engineName,
+			const std::vector<Result> &resultsList, bool groupBySearchEngine);
+
+		/// Groups results.
+		void regroupResults(bool groupBySearchEngine);
+
+		/// Gets the first selected item's URL.
+		Glib::ustring getFirstSelectionURL(void);
+
+		/// Gets a list of selected items.
+		bool getSelection(std::vector<Result> &resultsList);
+
+		/// Sets the first selected item's viewed state.
+		void setFirstSelectionViewedState(bool viewed);
+
+		/**
+		  * Deletes the current selection.
+		  * Returns true if the tree is then empty.
+		  */
+		bool deleteSelection(void);
+
+		/// Clear the tree.
+		void clear(void);
+
+		/// Shows or hides the extract field.
+		void showExtract(bool show = true);
+
+	protected:
+		Glib::RefPtr<Gtk::TreeStore> m_refStore;
+		Gtk::Menu *m_pPopupMenu;
+		PinotSettings &m_settings;
+		Glib::RefPtr<Gdk::Pixbuf> m_indexedIconPixbuf;
+		Glib::RefPtr<Gdk::Pixbuf> m_viewededIconPixbuf;
+		Glib::RefPtr<Gdk::Pixbuf> m_newIconPixbuf;
+		Glib::RefPtr<Gdk::Pixbuf> m_upIconPixbuf;
+		Glib::RefPtr<Gdk::Pixbuf> m_downIconPixbuf;
+		std::map<std::string, Gtk::TreeModel::iterator> m_resultsGroups;
+		ResultsModelColumns m_resultsColumns;
+		Gtk::ScrolledWindow *m_extractScrolledwindow;
+		Gtk::TextView *m_extractTextview;
+		std::set<std::string> m_indexNames;
+		bool m_showExtract;
+		std::string m_queryName;
+
+		void renderViewStatus(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &iter);
+
+		void renderIndexStatus(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &iter);
+
+		void renderRanking(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &iter);
+
+		/// Interactive search equal function.
+		bool onSearchEqual(const Glib::RefPtr<Gtk::TreeModel>& model, int column,
+			const Glib::ustring& key, const Gtk::TreeModel::iterator& iter);
+
+		/// Handles button presses.
+		void onButtonPressEvent(GdkEventButton *ev);
+
+		/// Handles attempts to select rows.
+		bool onSelectionSelect(const Glib::RefPtr<Gtk::TreeModel>& model,
+			const Gtk::TreeModel::Path& path, bool path_currently_selected);
+
+		/// Handles GTK style changes.
+		void onStyleChanged(const Glib::RefPtr<Gtk::Style> &previous_style);
+
+		/// Adds a results group.
+		bool appendGroup(const std::string &groupName, ResultsModelColumns::ResultType groupType,
+			Gtk::TreeModel::iterator &groupIter);
+
+		/// Adds a new row in the results tree.
+		bool appendResult(const std::string &text, const std::string &url,
+			float score, const std::string &language, int rankDiff,
+			const std::string &queryName, unsigned int engineId, unsigned int indexId,
+			Gtk::TreeModel::iterator &newRowIter,
+			const Gtk::TreeModel::Row *parentRow = NULL, bool noDuplicates = false);
+
+		/// Updates a results group.
+		void updateGroup(Gtk::TreeModel::iterator &groupIter);
+
+		/// Updates a row.
+		void updateRow(Gtk::TreeModel::Row &row, const Glib::ustring &text,
+			const Glib::ustring &url, const Glib::ustring &score, const Glib::ustring &language,
+			const Glib::ustring &queryName, unsigned int engineId, unsigned int indexId,
+			ResultsModelColumns::ResultType type, bool indexed, bool viewed, int rankDiff);
+
+	private:
+		ResultsTree(const ResultsTree &other);
+		ResultsTree &operator=(const ResultsTree &other);
+
+};
+
+#endif // _RESULTSTREE_HH

Added: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,1366 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <string.h>
+#include <signal.h>
+#include <fam.h>
+#include <iostream>
+#include <fstream>
+#include <sigc++/class_slot.h>
+#include <glibmm/thread.h>
+
+#include "HtmlTokenizer.h"
+#include "MIMEScanner.h"
+#include "TokenizerFactory.h"
+#include "StringManip.h"
+#include "TimeConverter.h"
+#include "Url.h"
+#include "LabelManager.h"
+#include "QueryHistory.h"
+#include "IndexedDocument.h"
+#include "DownloaderFactory.h"
+#include "SearchEngineFactory.h"
+#ifdef HAS_GOOGLEAPI
+#include "GoogleAPIEngine.h"
+#endif
+#include "XapianIndex.h"
+#include "XapianEngine.h"
+#include "config.h"
+#include "NLS.h"
+#include "PinotSettings.h"
+#include "WorkerThreads.h"
+
+using namespace SigC;
+using namespace Glib;
+using namespace std;
+
+// The Dispatcher object used to signal the UI thread
+Dispatcher WorkerThread::m_signalFinished;
+
+WorkerThread::WorkerThread()
+{
+	m_id = 0;
+	m_background = m_done = false;
+	m_status = "";
+}
+
+WorkerThread::~WorkerThread()
+{
+}
+
+void WorkerThread::setId(unsigned int id)
+{
+	m_id = id;
+}
+
+unsigned int WorkerThread::getId(void)
+{
+	return m_id;
+}
+
+void WorkerThread::inBackground(void)
+{
+	m_background = true;
+}
+
+bool WorkerThread::isBackground(void)
+{
+	return m_background;
+}
+
+bool WorkerThread::operator<(const WorkerThread &other) const
+{
+	return m_id < other.m_id;
+}
+
+Dispatcher& WorkerThread::getFinishedSignal()
+{
+	return m_signalFinished;
+}
+
+bool WorkerThread::isDone(void) const
+{
+	return m_done;
+}
+
+void WorkerThread::reset(void)
+{
+	m_done = false;
+}
+
+string WorkerThread::getStatus(void) const
+{
+	return m_status;
+}
+
+void WorkerThread::emitSignal(void)
+{
+#ifdef DEBUG
+	cout << "WorkerThread::emitSignal: end of thread " << m_id << endl;
+#endif
+	m_done = true;
+	m_signalFinished();
+}
+
+IndexBrowserThread::IndexBrowserThread(const string &indexName,
+	unsigned int maxDocsCount, unsigned int startDoc) :
+	WorkerThread()
+{
+	m_indexName = indexName;
+	m_indexDocsCount = 0;
+	m_maxDocsCount = maxDocsCount;
+	m_startDoc = startDoc;
+}
+
+IndexBrowserThread::~IndexBrowserThread()
+{
+}
+
+bool IndexBrowserThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &IndexBrowserThread::do_browsing), false);
+
+	return true;
+}
+
+string IndexBrowserThread::getType(void) const
+{
+	return "IndexBrowserThread";
+}
+
+string IndexBrowserThread::getIndexName(void) const
+{
+	return m_indexName;
+}
+
+unsigned int IndexBrowserThread::getDocumentsCount(void) const
+{
+	return m_indexDocsCount;
+}
+
+bool IndexBrowserThread::stop(void)
+{
+	m_done = true;
+	m_status = _("Stopped browsing");
+	m_status += " ";
+	m_status += m_indexName;
+	return true;
+}
+
+SigC::Signal3<void, IndexedDocument, unsigned int, std::string>& IndexBrowserThread::getUpdateSignal(void)
+{
+	return m_signalUpdate;
+}
+
+void IndexBrowserThread::do_browsing()
+{
+	set<unsigned int> docIDList;
+	set<string> docLabels;
+	unsigned int numDocs = 0;
+
+	const map<string, string> &indexesMap = PinotSettings::getInstance().getIndexes();
+	map<string, string>::const_iterator mapIter = indexesMap.find(m_indexName);
+	if (mapIter == indexesMap.end())
+	{
+		m_status = _("Index");
+		m_status += " ";
+		m_status += m_indexName;
+		m_status += " ";
+		m_status += _("doesn't exist");
+		emitSignal();
+		return;
+	}
+
+	// Get the index at that location
+	XapianIndex index(mapIter->second);
+	if (index.isGood() == false)
+	{
+		m_status = _("Index error on");
+		m_status += " ";
+		m_status += mapIter->second;
+		emitSignal();
+		return;
+	}
+
+	m_indexDocsCount = index.getDocumentsCount();
+	if (m_indexDocsCount == 0)
+	{
+#ifdef DEBUG
+		cout << "IndexBrowserThread::do_browsing: no documents" << endl;
+#endif
+		emitSignal();
+		return;
+	}
+
+#ifdef DEBUG
+	cout << "IndexBrowserThread::do_browsing: " << m_maxDocsCount << " off " << m_indexDocsCount
+		<< " documents to browse, starting at " << m_startDoc << endl;
+#endif
+	index.getDocumentIDs(docIDList, m_maxDocsCount, m_startDoc);
+	for (set<unsigned int>::iterator iter = docIDList.begin(); iter != docIDList.end(); iter++)
+	{
+		if (m_done == true)
+		{
+			break;
+		}
+
+		// Get the document ID
+		unsigned int docId = (*iter);
+		// ...and the document URL
+		string url = XapianEngine::buildUrl(mapIter->second, docId);
+
+		DocumentInfo docInfo;
+		if (index.getDocumentInfo(docId, docInfo) == true)
+		{
+			string type = docInfo.getType();
+			if (type.empty() == true)
+			{
+				type = "text/html";
+			}
+
+			string date = docInfo.getTimestamp();
+			IndexedDocument indexedDoc(docInfo.getTitle(), url, docInfo.getLocation(),
+				type, docInfo.getLanguage());
+			indexedDoc.setTimestamp(date);
+#ifdef DEBUG
+			cout << "IndexBrowserThread::do_browsing: timestamp for " << docId << " is " << date << endl;
+#endif
+			// Signal
+			m_signalUpdate(indexedDoc, docId, m_indexName);
+			++numDocs;
+		}
+#ifdef DEBUG
+		else cout << "IndexBrowserThread::do_browsing: couldn't retrieve document " << docId << endl;
+#endif
+	}
+
+	emitSignal();
+}
+
+QueryingThread::QueryingThread(const string &engineName, const string &engineDisplayableName,
+	const string &engineOption, const QueryProperties &queryProps) :
+	m_queryProps(queryProps), WorkerThread()
+{
+	m_engineName = engineName;
+	m_engineDisplayableName = engineDisplayableName;
+	m_engineOption = engineOption;
+}
+
+QueryingThread::~QueryingThread()
+{
+}
+
+bool QueryingThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &QueryingThread::do_querying), false);
+
+	return true;
+}
+
+string QueryingThread::getType(void) const
+{
+	return "QueryingThread";
+}
+
+string QueryingThread::getEngineName(void) const
+{
+	return m_engineDisplayableName;
+}
+
+QueryProperties QueryingThread::getQuery(void) const
+{
+	return m_queryProps;
+}
+
+const vector<Result> &QueryingThread::getResults(void) const
+{
+	return m_resultsList;
+}
+
+bool QueryingThread::stop(void)
+{
+	m_done = true;
+	m_status = _("Stopped querying");
+	m_status += " ";
+	m_status += m_engineDisplayableName;
+	return true;
+}
+
+void QueryingThread::do_querying()
+{
+	// Get the SearchEngine
+	SearchEngineInterface *engine = SearchEngineFactory::getSearchEngine(m_engineName, m_engineOption);
+	if (engine == NULL)
+	{
+		m_status = _("Couldn't create search engine");
+		m_status += " ";
+		m_status += m_engineDisplayableName;
+		emitSignal();
+		return;
+	}
+	// Set the maximum number of results
+	engine->setMaxResultsCount(m_queryProps.getMaximumResultsCount());
+
+	// Run the query
+	if (engine->runQuery(m_queryProps) == false)
+	{
+		m_status = _("Couldn't run query on search engine");
+		m_status += " ";
+		m_status += m_engineDisplayableName;
+	}
+	else
+	{
+		const vector<Result> &resultsList = engine->getResults();
+
+		// Copy the results list
+		m_resultsList.clear();
+		m_resultsList.reserve(resultsList.size());
+		for (vector<Result>::const_iterator resultIter = resultsList.begin();
+			resultIter != resultsList.end(); ++resultIter)
+		{
+			string title = _("No title");
+			string extract = HtmlTokenizer::stripTags(resultIter->getExtract());
+
+			// The title may contain formatting
+			if (resultIter->getTitle().empty() == false)
+			{
+				title = HtmlTokenizer::stripTags(resultIter->getTitle());
+			}
+
+			string language = resultIter->getLanguage();
+			if (language.empty() == true)
+			{
+				// Use the query's language
+				language = m_queryProps.getLanguage();
+			}
+
+			m_resultsList.push_back(Result(resultIter->getLocation(),
+				title,
+				extract,
+				language,
+				resultIter->getScore()));
+		}
+	}
+	delete engine;
+
+	emitSignal();
+}
+
+LabelQueryThread::LabelQueryThread(const string &indexName, const string &labelName) :
+	WorkerThread()
+{
+	m_indexName = indexName;
+	m_labelName = labelName;
+}
+
+LabelQueryThread::~LabelQueryThread()
+{
+}
+
+bool LabelQueryThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &LabelQueryThread::do_querying), false);
+
+	return true;
+}
+
+string LabelQueryThread::getType(void) const
+{
+	return "LabelQueryThread";
+}
+
+string LabelQueryThread::getLabelName(void) const
+{
+	return m_labelName;
+}
+
+bool LabelQueryThread::stop(void)
+{
+	m_done = true;
+	m_status = _("Stopped querying index labels");
+	return true;
+}
+
+const set<unsigned int> &LabelQueryThread::getDocumentsList(void) const
+{
+	return m_documentsList;
+}
+
+void LabelQueryThread::do_querying()
+{
+	LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
+	const map<string, string> &indexesMap = PinotSettings::getInstance().getIndexes();
+	map<string, string>::const_iterator mapIter = indexesMap.find(m_indexName);
+	if (mapIter == indexesMap.end())
+	{
+		m_status = _("Index");
+		m_status += " ";
+		m_status += m_indexName;
+		m_status += " ";
+		m_status += _("doesn't exist");
+		emitSignal();
+		return;
+	}
+
+	labelMan.getDocumentsWithLabel(m_labelName, mapIter->second, m_documentsList);
+
+	emitSignal();
+}
+
+DownloadingThread::DownloadingThread(const string url, bool fromCache) :
+	WorkerThread()
+{
+	m_url = url;
+	m_fromCache = fromCache;
+	m_pDoc = NULL;
+	// This is for sub-classes that need to things after the document has been downloaded
+	m_signalAfterDownload = true;
+	m_downloader = NULL;
+}
+
+DownloadingThread::~DownloadingThread()
+{
+	if (m_pDoc != NULL)
+	{
+		delete m_pDoc;
+	}
+	if (m_downloader != NULL)
+	{
+		delete m_downloader;
+	}
+}
+
+bool DownloadingThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &DownloadingThread::do_downloading), false);
+
+	return true;
+}
+
+string DownloadingThread::getType(void) const
+{
+	return "DownloadingThread";
+}
+
+string DownloadingThread::getURL(void) const
+{
+	return m_url;
+}
+
+const Document *DownloadingThread::getDocument(void) const
+{
+	return m_pDoc;
+}
+
+bool DownloadingThread::stop(void)
+{
+	if (m_downloader->stop() == true)
+	{
+		m_done = true;
+		m_status = _("Stopped retrieval of");
+		m_status += " ";
+		m_status += m_url;
+		return true;
+	}
+
+	return false;
+}
+
+void DownloadingThread::do_downloading()
+{
+	if (m_downloader != NULL)
+	{
+		delete m_downloader;
+		m_downloader = NULL;
+	}
+
+	Url thisUrl(m_url);
+
+	if (m_fromCache == true)
+	{
+#ifdef HAS_GOOGLEAPI
+		GoogleAPIEngine googleApiEngine;
+		googleApiEngine.setKey(PinotSettings::getInstance().m_googleAPIKey);
+		m_pDoc = googleApiEngine.retrieveCachedUrl(m_url);
+#endif
+#ifdef DEBUG
+		cout << "DownloadingThread::do_downloading: got cached page" << endl;
+#endif
+	}
+	else
+	{
+		// Get a Downloader, the default one will do
+		m_downloader = DownloaderFactory::getDownloader(thisUrl.getProtocol(), "");
+		if (m_downloader == NULL)
+		{
+			m_status = _("Couldn't obtain downloader for protocol");
+			m_status += " ";
+			m_status += thisUrl.getProtocol();
+		}
+		else if (m_done == false)
+		{
+			DocumentInfo docInfo("Document", m_url, "", "");
+
+			m_pDoc = m_downloader->retrieveUrl(docInfo);
+		}
+	}
+
+	if (m_pDoc == NULL)
+	{
+		m_status = _("Couldn't retrieve");
+		m_status += " ";
+		m_status += m_url;
+	}
+
+	// Signal ?
+	if (m_signalAfterDownload == true)
+	{
+		emitSignal();
+	}
+}
+
+IndexingThread::IndexingThread(const DocumentInfo &docInfo, const string &labelName) :
+	DownloadingThread(docInfo.getLocation(), false)
+{
+	m_docInfo = docInfo;
+	m_indexLocation = PinotSettings::getInstance().m_indexLocation;
+	m_ignoreRobotsDirectives = PinotSettings::getInstance().m_ignoreRobotsDirectives;
+	m_labelName = labelName;
+	// This is not an update
+	m_update = false;
+	// Don't trigger signal after the document has been downloaded
+	m_signalAfterDownload = false;
+}
+
+IndexingThread::IndexingThread(const DocumentInfo &docInfo, unsigned int docId) :
+	DownloadingThread(docInfo.getLocation(), false)
+{
+	m_docInfo = docInfo;
+	m_indexLocation = PinotSettings::getInstance().m_indexLocation;
+	// Ignore robots directives on updates
+	m_ignoreRobotsDirectives = true;
+	m_docIdList.insert(docId);
+	m_update = true;
+	// Don't trigger signal after the document has been downloaded
+	m_signalAfterDownload = false;
+}
+
+IndexingThread::~IndexingThread()
+{
+}
+
+bool IndexingThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &IndexingThread::do_indexing), false);
+
+	return true;
+}
+
+string IndexingThread::getType(void) const
+{
+	return "IndexingThread";
+}
+
+const DocumentInfo &IndexingThread::getDocumentInfo(void) const
+{
+	return m_docInfo;
+}
+
+string IndexingThread::getLabelName(void) const
+{
+	return m_labelName;
+}
+
+const std::set<unsigned int> &IndexingThread::getDocumentIDs(void) const
+{
+	return m_docIdList;
+}
+
+bool IndexingThread::isNewDocument(void) const
+{
+	// If the thread is set to perform an update, the document isn't new
+	if (m_update == true)
+	{
+		return false;
+	}
+	return true;
+}
+
+bool IndexingThread::stop(void)
+{
+	if (DownloadingThread::stop() == true)
+	{
+		m_done = true;
+		m_status = _("Stopped indexing");
+		m_status += " ";
+		m_status += m_url;
+		return true;
+	}
+
+	return false;
+}
+
+void IndexingThread::do_indexing()
+{
+	// First things first, get the index
+	XapianIndex index(m_indexLocation);
+	if (index.isGood() == false)
+	{
+		m_status = _("Index error on");
+		m_status += " ";
+		m_status += m_indexLocation;
+		emitSignal();
+		return;
+	}
+
+	do_downloading();
+#ifdef DEBUG
+	cout << "IndexingThread::do_indexing: downloaded !" << endl;
+#endif
+
+	if (m_pDoc == NULL)
+	{
+		m_status = _("Couldn't retrieve");
+		m_status += " ";
+		m_status += m_url;
+	}
+	else
+	{
+		Url urlObj(m_url);
+		unsigned int urlContentLen;
+		string docType = m_pDoc->getType();
+		const char *urlContent = m_pDoc->getData(urlContentLen);
+		bool success = false;
+
+		// The type may have been obtained when downloading
+		if (docType.empty() == false)
+		{
+			m_docInfo.setType(docType);
+		}
+		else
+		{
+			m_pDoc->setType(m_docInfo.getType());
+		}
+
+		// Skip unsupported types
+		if (TokenizerFactory::isSupportedType(m_docInfo.getType()) == false)
+		{
+			m_status = _("Cannot index document type");
+			m_status += " ";
+			m_status += m_docInfo.getType();
+			m_status += " ";
+			m_status += _("at");
+			m_status += " ";
+			m_status += m_url;
+			emitSignal();
+			return;
+		}
+
+		// Use the title we were supplied with ?
+		if ((m_docInfo.getTitle().empty() == false) ||
+			(urlObj.getProtocol() == "file"))
+		{
+			m_pDoc->setTitle(m_docInfo.getTitle());
+		}
+
+		// Tokenize this document
+		Tokenizer *pTokens = TokenizerFactory::getTokenizerByType(m_docInfo.getType(), m_pDoc);
+		if (pTokens == NULL)
+		{
+			m_status = _("Couln't tokenize");
+			m_status += " ";
+			m_status += m_url;
+			emitSignal();
+			return;
+		}
+
+		// Is indexing allowed ?
+		HtmlTokenizer *pHtmlTokens = dynamic_cast<HtmlTokenizer*>(pTokens);
+		if ((m_ignoreRobotsDirectives == false) &&
+			(pHtmlTokens != NULL))
+		{
+			// See if the document has a ROBOTS META tag
+			string robotsDirectives = pHtmlTokens->getMetaTag("robots");
+			string::size_type pos1 = robotsDirectives.find("none");
+			string::size_type pos2 = robotsDirectives.find("noindex");
+			if ((pos1 != string::npos) ||
+				(pos2 != string::npos))
+			{
+				// No, it's not
+				delete pTokens;
+				m_status = _("Robots META tag forbids indexing");
+				m_status += " ";
+				m_status += m_url;
+				emitSignal();
+				return;
+			}
+		}
+
+		if (m_done == false)
+		{
+			index.setStemmingMode(IndexInterface::STORE_BOTH);
+
+			// Update an existing document or add to the index ?
+			if ((m_update == true) &&
+				(m_docIdList.size() == 1))
+			{
+				set<unsigned int>::iterator idIter = m_docIdList.begin();
+				if (idIter != m_docIdList.end())
+				{
+					unsigned int docId = *idIter;
+					success = index.updateDocument(docId, *pTokens);
+#ifdef DEBUG
+					cout << "IndexingThread::do_indexing: updated " << docId << endl;
+#endif
+				}
+			}
+			else
+			{
+				unsigned int docId = 0;
+
+				// Save the new document ID
+				success = index.indexDocument(*pTokens, docId);
+				if (success == true)
+				{
+					LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
+
+					set<string> labels;
+					labels.insert(m_labelName);
+					labelMan.setLabels(docId, index.getLocation(), labels);
+
+					m_docIdList.insert(docId);
+				}
+			}
+
+			if (success == false)
+			{
+				m_status = _("Couldn't index");
+				m_status += " ";
+				m_status += m_url;
+			}
+			else
+			{
+				// Flush the index
+				index.flush();
+			}
+		}
+
+		delete pTokens;
+	}
+
+	emitSignal();
+}
+
+UnindexingThread::UnindexingThread(const set<unsigned int> &docIdList) :
+	WorkerThread(),
+	m_docsCount(0)
+{
+	copy(docIdList.begin(), docIdList.end(), inserter(m_docIdList, m_docIdList.begin()));
+	m_indexLocation = PinotSettings::getInstance().m_indexLocation;
+}
+
+UnindexingThread::UnindexingThread(const set<string> &labelNames, const string &indexLocation) :
+	WorkerThread(),
+	m_docsCount(0)
+{
+	copy(labelNames.begin(), labelNames.end(), inserter(m_labelNames, m_labelNames.begin()));
+	if (indexLocation.empty() == true)
+	{
+		m_indexLocation = PinotSettings::getInstance().m_indexLocation;
+	}
+	else
+	{
+		m_indexLocation = indexLocation;
+	}
+}
+
+UnindexingThread::~UnindexingThread()
+{
+}
+
+bool UnindexingThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &UnindexingThread::do_unindexing), false);
+
+	return true;
+}
+
+string UnindexingThread::getType(void) const
+{
+	return "UnindexingThread";
+}
+
+unsigned int UnindexingThread::getDocumentsCount(void) const
+{
+	return m_docsCount;
+}
+
+bool UnindexingThread::stop(void)
+{
+	m_done = true;
+	m_status = _("Stopped unindexing document(s)");
+	return true;
+}
+
+void UnindexingThread::do_unindexing()
+{
+	if (m_done == false)
+	{
+		LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
+		XapianIndex index(m_indexLocation);
+
+		if (index.isGood() == false)
+		{
+			m_status = _("Index error on");
+			m_status += " ";
+			m_status += m_indexLocation;
+			emitSignal();
+			return;
+		}
+
+		// Be pessimistic and assume something will go wrong ;-)
+		m_status = _("Couldn't unindex document(s)");
+
+		// Are we supposed to remove documents based on labels ?
+		if (m_docIdList.empty() == true)
+		{
+			// Yep
+			// FIXME: better delete documents one label at a time
+			for (set<string>::iterator iter = m_labelNames.begin(); iter != m_labelNames.end(); iter++)
+			{
+				string labelName = (*iter);
+				labelMan.getDocumentsWithLabel(labelName, m_indexLocation, m_docIdList);
+				labelMan.deleteLabel(labelName);
+			}
+#ifdef DEBUG
+			cout << "UnindexingThread::do_unindexing: " << m_docIdList.size() << " documents have one of the labels" << endl;
+#endif
+		}
+
+		for (set<unsigned int>::iterator iter = m_docIdList.begin(); iter != m_docIdList.end(); iter++)
+		{
+			unsigned int docId = (*iter);
+
+			if (index.unindexDocument(docId) == true)
+			{
+				// Delete any label this document may have had
+				if (labelMan.deleteItem(docId, m_indexLocation) == false)
+				{
+#ifdef DEBUG
+					cout << "UnindexingThread::do_unindexing: " << docId
+						<< " may not have had labels" << endl;
+#endif
+				}
+
+				// OK
+				m_status = "";
+				++m_docsCount;
+			}
+#ifdef DEBUG
+			else cout << "UnindexingThread::do_unindexing: couldn't remove " << docId << endl;
+#endif
+		}
+
+		if (m_docIdList.empty() == false)
+		{
+#ifdef DEBUG
+			cout << "UnindexingThread::do_unindexing: removed " << m_docIdList.size() << " documents" << endl;
+#endif
+			// Flush the index
+			index.flush();
+		}
+		else
+		{
+			// Nothing to report
+			m_status = "";
+		}
+	}
+
+	emitSignal();
+}
+
+UpdateDocumentThread::UpdateDocumentThread(const string &indexName,
+	unsigned int docId, const DocumentInfo &docInfo) :
+	WorkerThread()
+{
+	m_indexName = indexName;
+	m_docId = docId;
+	m_docInfo = docInfo;
+}
+
+UpdateDocumentThread::~UpdateDocumentThread()
+{
+}
+
+bool UpdateDocumentThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &UpdateDocumentThread::do_update), false);
+
+	return true;
+}
+
+string UpdateDocumentThread::getType(void) const
+{
+	return "UpdateDocumentThread";
+}
+
+unsigned int UpdateDocumentThread::getDocumentID(void) const
+{
+	return m_docId;
+}
+
+const DocumentInfo &UpdateDocumentThread::getDocumentInfo(void) const
+{
+	return m_docInfo;
+}
+
+bool UpdateDocumentThread::stop(void)
+{
+	m_done = true;
+	m_status = _("Stopped document update for ");
+	m_status += " ";
+	m_status += m_docId;
+
+	return true;
+}
+
+void UpdateDocumentThread::do_update()
+{
+	if (m_done == false)
+	{
+		const map<string, string> &indexesMap = PinotSettings::getInstance().getIndexes();
+		map<string, string>::const_iterator mapIter = indexesMap.find(m_indexName);
+		if (mapIter == indexesMap.end())
+		{
+			m_status = _("Index");
+			m_status += " ";
+			m_status += m_indexName;
+			m_status += " ";
+			m_status += _("doesn't exist");
+			emitSignal();
+			return;
+		}
+
+		// Get the index at that location
+		XapianIndex index(mapIter->second);
+		if (index.isGood() == false)
+		{
+			m_status = _("Index error on");
+			m_status += " ";
+			m_status += mapIter->second;
+			emitSignal();
+			return;
+		}
+
+		if (index.updateDocumentInfo(m_docId, m_docInfo) == false)
+		{
+			m_status = _("Couldn't update document");
+		}
+		else
+		{
+			// OK
+			m_status = "";
+			// Flush the index
+			index.flush();
+		}
+	}
+
+	emitSignal();
+}
+
+ListenerThread::ListenerThread(const string &fifoFileName) :
+	WorkerThread()
+{
+	m_fifoFileName = fifoFileName;
+}
+
+ListenerThread::~ListenerThread()
+{
+}
+
+bool ListenerThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &ListenerThread::do_listening), false);
+
+	return true;
+}
+
+string ListenerThread::getType(void) const
+{
+	return "ListenerThread";
+}
+
+bool ListenerThread::stop(void)
+{
+	m_done = true;
+	m_status = _("Stopped listening on");
+	m_status += " ";
+	m_status += m_fifoFileName;
+
+	return true;
+}
+
+Signal2<void, DocumentInfo, string>& ListenerThread::getReceptionSignal(void)
+{
+	return m_signalReception;
+}
+
+void ListenerThread::do_listening()
+{
+	if (unlink(m_fifoFileName.c_str()) != 0)
+	{
+#ifdef DEBUG
+		cout << "ListenerThread::do_listening: couldn't delete FIFO at " << m_fifoFileName << endl;
+#endif
+	}
+
+	if (mkfifo(m_fifoFileName.c_str(), S_IRUSR|S_IWUSR) != 0)
+	{
+#ifdef DEBUG
+		cout << "ListenerThread::do_listening: couldn't create FIFO at " << m_fifoFileName << endl;
+#endif
+	}
+
+	// Ignore SIGPIPE
+	if (sigset(SIGPIPE, SIG_IGN) == SIG_ERR)
+	{
+#ifdef DEBUG
+		cout << "ListenerThread::do_listening: couldn't ignore SIGPIPE" << endl;
+#endif
+	}
+
+	// Open the FIFO
+	int fd = open(m_fifoFileName.c_str(), O_RDWR);
+	if (fd != -1)
+	{
+		// Set the file in non-blocking mode
+		int flags = fcntl(fd, F_GETFL);
+		flags |= O_NONBLOCK;
+		fcntl(fd, F_SETFL, (long)flags);
+
+		fd_set listenSet;
+		FD_ZERO(&listenSet);
+		FD_SET(fd, &listenSet);
+
+		// Listen and wait for something to read
+		while (m_done == false)
+		{
+			int fdCount = select(fd + 1, &listenSet, NULL, NULL, NULL);
+			if ((fdCount > 0) &&
+				(FD_ISSET(fd, &listenSet)))
+			{
+				string xmlMsg;
+				char buffer[1024];
+
+#ifdef DEBUG
+				cout << "ListenerThread::do_listening: reading..." << endl;
+#endif
+				ssize_t bytes = read(fd, buffer, 1024);
+				while (bytes > 0)
+				{
+					xmlMsg += string(buffer, bytes);
+#ifdef DEBUG
+					cout << "ListenerThread::do_listening: read " << bytes << " bytes" << endl;
+#endif
+					bytes = read(fd, buffer, 1024);
+				}
+
+				// FIXME: ensure the XML is valid, use libxml++ parser
+				string location = StringManip::extractField(xmlMsg, "<location>", "</location>");
+				Url urlObj(location);
+				DocumentInfo docInfo(StringManip::extractField(xmlMsg, "<title>", "</title>"),
+					location, MIMEScanner::scanUrl(urlObj), "");
+				string labelName = StringManip::extractField(xmlMsg, "<label>", "</label>");
+				string content = StringManip::extractField(xmlMsg, "<content>", "</content>");
+#ifdef DEBUG
+				cout << "ListenerThread::do_listening: " << content.length() << " bytes of content" << endl;
+#endif
+
+				// Signal
+				m_signalReception(docInfo, labelName);
+			}
+		}
+
+		close(fd);
+	}
+	else
+	{
+		m_status = _("Couldn't read FIFO at");
+		m_status += " ";
+		m_status += m_fifoFileName;
+	}
+
+	emitSignal();
+}
+
+MonitorThread::MonitorThread(MonitorHandler *pHandler) :
+	WorkerThread()
+{
+	m_pHandler = pHandler;
+	m_numCPUs = sysconf(_SC_NPROCESSORS_ONLN);
+}
+
+MonitorThread::~MonitorThread()
+{
+	// It's our responsability to delete the MonitorHandler object
+	if (m_pHandler != NULL)
+	{
+		delete m_pHandler;
+	}
+}
+
+bool MonitorThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &MonitorThread::do_monitoring), false);
+
+	return true;
+}
+
+string MonitorThread::getType(void) const
+{
+	return "MonitorThread";
+}
+
+bool MonitorThread::stop(void)
+{
+	m_done = true;
+	m_status = _("Stopped monitoring");
+
+	return true;
+}
+
+void MonitorThread::do_monitoring()
+{
+	FAMConnection famConn;
+	FAMRequest famReq;
+	map<unsigned long, string> fsLocations;
+	struct stat fileStat;
+	bool setLocationsToMonitor = true;
+	bool firstTime = true;
+	bool resumeMonitor = false;
+	int famStatus = -1;
+
+	if (m_pHandler == NULL)
+	{
+		m_status = _("No monitoring handler");
+		emitSignal();
+		return;
+	}
+
+	// Wait for something to happen
+	while (m_done == false)
+	{
+#ifdef DEBUG
+		cout << "MonitorThread::do_monitoring: checking locations" << endl;
+#endif
+		if ((setLocationsToMonitor == true) &&
+			(m_pHandler->getFileSystemLocations(fsLocations) > 0) &&
+			(m_pHandler->hasNewLocations() == true))
+		{
+			// Tell FAM what we want to monitor
+#ifdef DEBUG
+			cout << "MonitorThread::do_monitoring: change detected" << endl;
+#endif
+			if (firstTime == false)
+			{
+				// Cancel
+				FAMCancelMonitor(&famConn, &famReq);
+				FAMClose(&famConn);
+			}
+			else
+			{
+				firstTime = false;
+			}
+			resumeMonitor = false;
+
+			// FIXME: opening a new connection every time might be overkill
+			if (FAMOpen(&famConn) != 0)
+			{
+				m_status = _("Couldn't open FAM connection");
+				emitSignal();
+				return;
+			}
+
+			// Go through the locations map
+			for (map<unsigned long, std::string>::const_iterator fsIter = fsLocations.begin(); fsIter != fsLocations.end(); ++fsIter)
+			{
+				string fsLocation = fsIter->second;
+				struct stat fileStat;
+
+				if (stat(fsLocation.c_str(), &fileStat) == -1)
+				{
+					continue;
+				}
+
+				// Is that a file or a directory ?
+				if (S_ISREG(fileStat.st_mode))
+				{
+					famStatus = FAMMonitorFile(&famConn, fsLocation.c_str(), &famReq, NULL);
+				}
+				else if (S_ISDIR(fileStat.st_mode))
+				{
+					// FIXME: FAM works one level deep only: monitor sub-directories if there are any...
+					famStatus = FAMMonitorDirectory(&famConn, fsLocation.c_str(), &famReq, (void*)(fsIter->first + 1));
+				}
+#ifdef DEBUG
+				cout << "MonitorThread::do_monitoring: added " << fsLocation << ", " << famStatus << endl;
+#endif
+			}
+		}
+		setLocationsToMonitor = false;
+
+		int fd = FAMCONNECTION_GETFD(&famConn);
+
+		fd_set listenSet;
+		FD_ZERO(&listenSet);
+		FD_SET(fd, &listenSet);
+
+		struct timeval selectTimeout;
+		selectTimeout.tv_sec = 60;
+		selectTimeout.tv_usec = 0;
+
+		int fdCount = select(fd + 1, &listenSet, NULL, NULL, &selectTimeout);
+		if ((fdCount > 0) &&
+			(FD_ISSET(fd, &listenSet)))
+		{
+#ifdef DEBUG
+			cout << "MonitorThread::do_monitoring: select() returned" << endl;
+#endif
+			// There might be more than one event waiting...
+			while ((FAMPending(&famConn) >= 1) &&
+				(m_done == false))
+			{
+				double averageLoad[3];
+
+				// Get the load averaged over the last minute
+				if (getloadavg(averageLoad, 3) != -1)
+				{
+					// FIXME: is LOADAVG_1MIN Solaris specific ?
+					if (averageLoad[0] >= (double)m_numCPUs * 4)
+					{
+						// Ignore pending events if the load has become too high
+#ifdef DEBUG
+						cout << "MonitorThread::do_monitoring: cancelling monitoring because of load (" << averageLoad[0] << ")" << endl;
+#endif
+						FAMCancelMonitor(&famConn, &famReq);
+						resumeMonitor = true;
+						break;
+					}
+				}
+
+				FAMEvent famEvent;
+				if ((FAMNextEvent(&famConn, &famEvent) == 1) &&
+					(famEvent.filename != NULL) &&
+					(strlen(famEvent.filename) > 0))
+				{
+					string fileName;
+					bool updatedIndex = false;
+
+#ifdef DEBUG
+					cout << "MonitorThread::do_monitoring: event " << famEvent.code
+						<< " on " << famEvent.filename << endl;
+#endif
+					if (famEvent.code == FAMEndExist)
+					{
+						updatedIndex = m_pHandler->fileExists(famEvent.filename, true);
+						// FIXME: accounts for which we didn't receive a FAMExists should
+						// be removed
+					}
+					else
+					{
+						// Are we monitoring a file or a directory ?
+						if (famEvent.userdata != NULL)
+						{
+							// A directory...
+							if (famEvent.filename[0] == '/')
+							{
+								// Not interested in monitored directories...
+								continue;
+							}
+
+							// The event is on a file in that directory
+							map<unsigned long, string>::const_iterator fsIter = fsLocations.find((unsigned long)famEvent.userdata);
+							if (fsIter == fsLocations.end())
+							{
+								continue;
+							}
+							fileName += fsIter->second;
+							fileName += "/";
+						}
+						fileName += famEvent.filename;
+
+						// What's the event code ?
+						if (famEvent.code == FAMExists)
+						{
+							updatedIndex = m_pHandler->fileExists(fileName);
+						}
+						else if (famEvent.code == FAMCreated)
+						{
+							m_pHandler->fileCreated(fileName);
+						}
+						else if (famEvent.code == FAMChanged)
+						{
+							updatedIndex = m_pHandler->fileChanged(fileName);
+						}
+						else if (famEvent.code == FAMDeleted)
+						{
+							updatedIndex = m_pHandler->fileDeleted(fileName);
+						}
+					}
+				}
+			}
+		}
+		else
+		{
+			if (resumeMonitor == true)
+			{
+				// Resume
+#ifdef DEBUG
+				cout << "MonitorThread::do_monitoring: resuming monitoring" << endl;
+#endif
+				FAMResumeMonitor(&famConn, &famReq);
+				resumeMonitor = false;
+			}
+
+			// Chances are the timeout expired
+			// See if the locations to monitor have changed
+			setLocationsToMonitor = true;
+		}
+	}
+#ifdef DEBUG
+	cout << "MonitorThread::do_monitoring: quitting..." << endl;
+#endif
+
+	// Stop monitoring and close the connection
+	FAMCancelMonitor(&famConn, &famReq);
+	FAMClose(&famConn);
+
+	emitSignal();
+}

Added: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,362 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _WORKERTHREADS_HH
+#define _WORKERTHREADS_HH
+
+#include <time.h>
+#include <string>
+#include <vector>
+#include <set>
+#include <map>
+#include <sigc++/slot.h>
+#include <glibmm/dispatcher.h>
+#include <glibmm/ustring.h>
+
+#include "Document.h"
+#include "IndexedDocument.h"
+#include "DownloaderInterface.h"
+#include "QueryProperties.h"
+#include "Result.h"
+#include "MonitorHandler.h"
+
+class WorkerThread
+{
+	public:
+		WorkerThread();
+		virtual ~WorkerThread();
+
+		void setId(unsigned int id);
+
+		unsigned int getId(void);
+
+		void inBackground(void);
+
+		bool isBackground(void);
+
+		bool operator<(const WorkerThread &other) const;
+
+		virtual bool start(void) = 0;
+
+		virtual std::string getType(void) const = 0;
+
+		virtual bool stop(void) = 0;
+
+		/// Only one thread (the GUI thread) should connect to this, before calling start().
+		static Glib::Dispatcher& getFinishedSignal();
+
+		bool isDone(void) const;
+
+		void reset(void);
+
+		std::string getStatus(void) const;
+
+	protected:
+		/// Use a Dispatcher, not a Signal, for thread safety
+		static Glib::Dispatcher m_signalFinished;
+		unsigned int m_id;
+		bool m_background;
+		bool m_done;
+		std::string m_status;
+
+		void emitSignal(void);
+
+	private:
+		WorkerThread(const WorkerThread &other);
+		WorkerThread &operator=(const WorkerThread &other);
+
+};
+
+class IndexBrowserThread : public WorkerThread
+{
+	public:
+		IndexBrowserThread(const std::string &indexName,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0);
+		~IndexBrowserThread();
+
+		virtual bool start(void);
+
+		std::string getType(void) const;
+
+		std::string getIndexName(void) const;
+
+		unsigned int getDocumentsCount(void) const;
+
+		virtual bool stop(void);
+
+		SigC::Signal3<void, IndexedDocument, unsigned int, std::string>& getUpdateSignal(void);
+
+	protected:
+		std::string m_indexName;
+		unsigned int m_indexDocsCount;
+		unsigned int m_maxDocsCount;
+		unsigned int m_startDoc;
+		SigC::Signal3<void, IndexedDocument, unsigned int, std::string> m_signalUpdate;
+
+		void do_browsing();
+
+	private:
+		IndexBrowserThread(const IndexBrowserThread &other);
+		IndexBrowserThread &operator=(const IndexBrowserThread &other);
+
+};
+
+class QueryingThread : public WorkerThread
+{
+	public:
+		QueryingThread(const std::string &engineName, const std::string &engineDisplayableName,
+			const std::string &engineOption, const QueryProperties &queryProps);
+		virtual ~QueryingThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		virtual std::string getEngineName(void) const;
+
+		virtual QueryProperties getQuery(void) const;
+
+		virtual const std::vector<Result> &getResults(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		std::string m_engineName;
+		std::string m_engineDisplayableName;
+		std::string m_engineOption;
+		QueryProperties m_queryProps;
+		std::vector<Result> m_resultsList;
+
+		void do_querying();
+
+	private:
+		QueryingThread(const QueryingThread &other);
+		QueryingThread &operator=(const QueryingThread &other);
+
+};
+
+class LabelQueryThread : public WorkerThread
+{
+	public:
+		LabelQueryThread(const std::string &indexName, const std::string &labelName);
+		virtual ~LabelQueryThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		virtual std::string getLabelName(void) const;
+
+		virtual bool stop(void);
+
+		virtual const std::set<unsigned int> &getDocumentsList(void) const;
+
+	protected:
+		std::string m_indexName;
+		std::string m_labelName;
+		std::set<unsigned int> m_documentsList;
+
+		void do_querying();
+
+	private:
+		LabelQueryThread(const LabelQueryThread &other);
+		LabelQueryThread &operator=(const LabelQueryThread &other);
+
+};
+
+class DownloadingThread : public WorkerThread
+{
+	public:
+		DownloadingThread(const std::string url, bool fromCache);
+		virtual ~DownloadingThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		virtual std::string getURL(void) const;
+
+		virtual const Document *getDocument(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		std::string m_url;
+		bool m_fromCache;
+		Document *m_pDoc;
+		bool m_signalAfterDownload;
+		DownloaderInterface *m_downloader;
+
+		void do_downloading();
+
+	private:
+		DownloadingThread(const DownloadingThread &other);
+		DownloadingThread &operator=(const DownloadingThread &other);
+
+};
+
+class IndexingThread : public DownloadingThread
+{
+	public:
+		/// Index a document.
+		IndexingThread(const DocumentInfo &docInfo, const std::string &labelName);
+		/// Update a document.
+		IndexingThread(const DocumentInfo &docInfo, unsigned int docId);
+		virtual ~IndexingThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		const DocumentInfo &getDocumentInfo(void) const;
+
+		std::string getLabelName(void) const;
+
+		const std::set<unsigned int> &getDocumentIDs(void) const;
+
+		bool isNewDocument(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		DocumentInfo m_docInfo;
+		std::string m_indexLocation;
+		bool m_ignoreRobotsDirectives;
+		std::string m_labelName;
+		std::set<unsigned int> m_docIdList;
+		bool m_update;
+
+		void do_indexing();
+
+	private:
+		IndexingThread(const IndexingThread &other);
+		IndexingThread &operator=(const IndexingThread &other);
+
+};
+
+class UnindexingThread : public WorkerThread
+{
+	public:
+		// Unindex documents from the internal index
+		UnindexingThread(const std::set<unsigned int> &docIdList);
+		// Unindex from the given index documents that have one of the labels
+		UnindexingThread(const std::set<std::string> &labelNames, const std::string &indexLocation);
+		virtual ~UnindexingThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		unsigned int getDocumentsCount(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		std::set<unsigned int> m_docIdList;
+		std::set<std::string> m_labelNames;
+		std::string m_indexLocation;
+		unsigned int m_docsCount;
+
+		void do_unindexing();
+
+	private:
+		UnindexingThread(const UnindexingThread &other);
+		UnindexingThread &operator=(const UnindexingThread &other);
+
+};
+
+class UpdateDocumentThread : public WorkerThread
+{
+	public:
+		// Update a document's properties
+		UpdateDocumentThread(const std::string &indexName,
+			unsigned int docId, const DocumentInfo &docInfo);
+		virtual ~UpdateDocumentThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		unsigned int getDocumentID(void) const;
+
+		const DocumentInfo &getDocumentInfo(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		std::string m_indexName;
+		unsigned int m_docId;
+		DocumentInfo m_docInfo;
+
+		void do_update();
+
+	private:
+		UpdateDocumentThread(const UpdateDocumentThread &other);
+		UpdateDocumentThread &operator=(const UpdateDocumentThread &other);
+
+};
+
+class ListenerThread : public WorkerThread
+{
+	public:
+		ListenerThread(const std::string &fifoFileName);
+		virtual ~ListenerThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		virtual bool stop(void);
+
+		SigC::Signal2<void, DocumentInfo, std::string>& getReceptionSignal(void);
+
+	protected:
+		std::string m_fifoFileName;
+		SigC::Signal2<void, DocumentInfo, std::string> m_signalReception;
+
+		void do_listening();
+
+	private:
+		ListenerThread(const ListenerThread &other);
+		ListenerThread &operator=(const ListenerThread &other);
+
+};
+
+class MonitorThread : public WorkerThread
+{
+	public:
+		MonitorThread(MonitorHandler *pHandler);
+		virtual ~MonitorThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		MonitorHandler *m_pHandler;
+		long m_numCPUs;
+
+		void do_monitoring();
+
+	private:
+		MonitorThread(const MonitorThread &other);
+		MonitorThread &operator=(const MonitorThread &other);
+
+};
+
+#endif // _WORKERTHREADS_HH

Added: trunk/UI/GTK2/src/aboutDialog.cc
===================================================================
--- trunk/UI/GTK2/src/aboutDialog.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/aboutDialog.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,28 @@
+// generated 2003/5/18 11:20:09 BST by fabrice at amra.dyndns.org.(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to aboutDialog.cc_new
+
+// This file is for your program, I won't touch it again!
+
+#include <glibmm/ustring.h>
+
+#include "config.h"
+#include "NLS.h"
+#include "aboutDialog.hh"
+
+using namespace Glib;
+
+aboutDialog::aboutDialog()
+{
+#ifdef VERSION
+	ustring name = nameLabel->get_text();
+	name += " v";
+	name += VERSION;
+	nameLabel->set_text(name);
+#endif
+}
+
+aboutDialog::~aboutDialog()
+{
+}


Property changes on: trunk/UI/GTK2/src/aboutDialog.cc
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/aboutDialog.hh
===================================================================
--- trunk/UI/GTK2/src/aboutDialog.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/aboutDialog.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,22 @@
+// generated 2003/5/18 11:20:09 BST by fabrice at amra.dyndns.org.(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to aboutDialog.hh_new
+
+// you might replace
+//    class foo : public foo_glade { ... };
+// by
+//    typedef foo_glade foo;
+// if you didn't make any modifications to the widget
+
+#ifndef _ABOUTDIALOG_HH
+#  include "aboutDialog_glade.hh"
+#  define _ABOUTDIALOG_HH
+class aboutDialog : public aboutDialog_glade
+{
+public:
+	aboutDialog();
+	virtual ~aboutDialog();
+
+};
+#endif


Property changes on: trunk/UI/GTK2/src/aboutDialog.hh
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/aboutDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/aboutDialog_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/aboutDialog_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,407 @@
+// generated 2005/12/1 23:54:57 SGT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/aboutDialog.cc
+
+
+#if defined __GNUC__ && __GNUC__ < 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include "config.h"
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include <libintl.h>
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include <gtkmmconfig.h>
+#if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
+#include <sigc++/compatibility.h>
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include "aboutDialog_glade.hh"
+#include <gdk/gdkkeysyms.h>
+#include <gtkmm/accelgroup.h>
+#include <gtkmm/buttonbox.h>
+#include <gtkmm/image.h>
+#include <gdkmm/pixbufloader.h>
+
+static const unsigned char pinot_png_data[] = 
+{       	137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,
+	0,0,0,48,0,0,0,48,8,6,0,0,0,87,2,249,
+	135,0,0,0,6,98,75,71,68,0,255,0,255,0,255,160,
+	189,167,147,0,0,0,9,112,72,89,115,0,0,11,19,0,
+	0,11,19,1,0,154,156,24,0,0,0,7,116,73,77,69,
+	7,213,2,11,16,54,2,88,210,160,116,0,0,7,95,73,
+	68,65,84,104,222,237,153,107,108,20,215,21,199,127,243,216,
+	245,218,222,101,109,99,131,29,136,13,133,64,168,11,196,6,
+	213,41,52,136,66,77,243,52,16,68,40,9,81,212,70,137,
+	72,138,210,32,62,244,173,86,106,66,63,68,170,170,180,169,
+	20,169,106,161,161,84,74,210,36,53,45,15,5,66,11,229,
+	17,234,212,70,24,240,3,140,95,187,241,99,119,189,175,217,
+	217,157,217,153,233,7,108,176,193,27,239,218,86,104,37,31,
+	105,62,220,253,159,185,115,254,115,207,252,239,57,119,97,202,
+	166,108,202,166,108,202,166,236,255,216,132,76,156,107,115,16,
+	128,16,224,26,195,53,6,248,129,6,224,16,240,86,77,140,
+	232,255,2,129,5,64,115,166,15,73,88,68,34,22,207,124,
+	59,206,251,147,77,64,204,208,191,98,248,192,180,192,184,229,
+	50,173,219,111,202,18,112,229,9,188,247,45,27,223,155,108,
+	2,242,68,8,188,146,128,58,19,19,24,17,246,52,16,238,
+	147,16,159,180,193,93,131,175,72,22,160,74,226,23,251,117,
+	234,18,112,236,78,173,64,229,240,65,219,245,176,107,6,95,
+	196,141,43,12,242,9,131,25,175,38,120,190,199,68,31,242,
+	191,75,68,88,44,178,7,144,238,248,10,132,44,8,92,39,
+	208,48,138,159,5,244,119,89,236,253,143,96,171,124,24,125,
+	251,16,48,95,100,118,157,96,255,25,134,246,115,128,108,151,
+	123,227,252,170,117,155,165,156,194,47,5,21,131,80,175,167,
+	49,212,122,226,29,51,17,249,123,182,203,253,72,10,236,125,
+	64,203,136,64,109,14,179,129,194,161,241,53,19,128,126,192,
+	147,226,150,210,7,54,172,223,51,111,243,51,171,120,238,241,
+	27,63,22,8,224,94,244,232,15,212,222,182,175,46,175,154,
+	109,175,121,126,103,213,236,5,21,146,79,137,211,242,169,68,
+	227,21,107,97,219,241,183,215,207,80,14,135,158,120,105,87,
+	222,173,88,231,185,143,106,122,254,241,235,163,113,207,153,231,
+	0,143,60,222,252,31,36,112,62,133,175,115,197,227,15,253,
+	233,251,175,238,88,233,206,113,10,129,225,57,43,128,40,137,
+	82,249,138,37,171,127,184,123,27,249,121,211,80,141,139,40,
+	122,27,179,138,20,122,252,85,36,156,205,242,79,118,191,60,
+	253,86,204,175,172,33,52,239,203,182,88,248,197,7,245,184,
+	254,123,195,95,247,152,56,238,252,55,83,166,15,121,37,101,
+	79,63,244,236,119,191,82,88,48,93,112,196,212,17,88,216,
+	2,35,236,97,195,179,91,41,154,94,72,142,205,78,220,80,
+	176,139,160,91,6,253,13,135,121,228,155,143,141,138,217,179,
+	20,236,217,14,108,206,2,65,44,249,198,90,100,215,54,113,
+	130,43,48,42,129,178,229,15,110,43,43,115,72,150,149,36,
+	214,120,105,4,214,107,129,35,75,102,238,220,108,44,43,137,
+	102,104,228,202,14,166,217,93,8,166,130,22,140,49,103,142,
+	99,84,44,161,135,177,76,19,203,178,16,178,102,74,66,222,
+	242,45,227,74,33,205,130,110,43,117,10,37,109,249,203,18,
+	70,63,97,45,15,253,224,161,17,216,121,3,36,135,147,33,
+	28,64,77,170,116,6,7,80,226,171,137,134,15,164,196,18,
+	234,60,226,138,31,61,166,34,103,217,48,178,75,42,229,52,
+	63,224,2,160,116,104,220,105,129,9,113,160,105,52,255,112,
+	84,151,154,188,65,28,237,45,184,222,59,114,67,171,175,154,
+	208,99,65,73,238,44,154,188,65,108,114,12,127,4,52,67,
+	193,167,44,195,31,93,74,56,242,110,74,172,175,55,136,226,
+	235,39,30,10,33,231,218,209,68,187,67,158,64,254,95,4,
+	146,163,22,66,193,64,107,203,17,115,81,213,7,175,33,234,
+	55,93,246,105,144,85,180,16,205,112,112,170,190,20,217,126,
+	142,128,50,151,96,176,15,213,240,227,243,117,17,87,141,148,
+	152,191,115,128,176,215,67,82,75,144,147,151,143,97,36,154,
+	228,201,202,255,218,28,68,160,0,168,104,188,248,103,117,225,
+	165,183,176,153,55,131,63,168,195,39,38,184,230,60,74,164,
+	215,67,247,5,133,99,177,34,230,150,255,139,206,222,92,148,
+	240,105,162,129,38,98,3,129,148,88,164,163,8,165,63,76,
+	110,177,11,93,21,77,203,127,242,29,33,205,20,218,15,108,
+	29,94,3,9,96,10,194,136,18,66,76,85,28,30,77,194,
+	111,52,112,84,185,177,47,89,130,216,115,63,177,150,110,178,
+	75,171,177,79,83,112,221,251,33,148,116,161,132,21,148,139,
+	249,104,117,119,147,93,250,240,109,152,122,109,38,114,168,26,
+	193,156,143,255,220,223,154,204,206,253,43,211,218,210,183,218,
+	120,101,248,38,38,8,32,8,8,131,65,139,169,130,247,154,
+	240,166,6,111,39,193,94,145,69,193,122,55,238,233,58,134,
+	120,9,169,91,39,25,236,34,28,186,27,221,125,129,164,163,
+	21,25,139,188,153,6,201,228,53,162,13,62,98,241,210,17,
+	152,187,64,67,55,234,241,159,104,236,51,59,14,213,0,237,
+	66,26,111,63,23,8,127,86,221,100,89,160,2,138,117,93,
+	38,91,76,104,48,160,193,4,4,41,104,43,203,117,74,247,
+	104,178,36,200,56,77,39,107,151,173,101,205,134,53,92,252,
+	180,133,3,127,12,226,233,253,8,203,217,133,36,200,24,1,
+	129,45,213,155,184,127,101,21,181,31,124,204,217,214,163,168,
+	118,31,146,32,163,13,100,99,4,238,195,12,68,254,201,192,
+	217,213,233,150,18,75,135,7,127,88,135,223,234,163,243,0,
+	162,64,16,184,6,124,12,28,197,50,62,92,80,249,162,250,
+	242,79,151,201,101,249,55,165,177,45,208,143,45,127,35,229,
+	155,230,225,184,236,167,183,241,2,138,207,71,118,252,28,79,
+	189,240,36,106,82,101,93,241,3,44,142,108,167,185,123,30,
+	87,135,124,108,62,18,218,201,114,99,224,108,218,197,92,197,
+	40,21,232,155,192,246,116,55,144,33,89,77,75,26,253,34,
+	23,188,222,49,229,51,147,106,52,237,29,56,101,127,25,12,
+	180,158,170,47,93,148,142,52,230,22,153,52,245,73,99,202,
+	103,38,4,42,135,171,79,251,56,8,132,91,142,255,197,211,
+	88,243,163,99,177,34,97,12,105,196,145,99,16,84,198,150,
+	207,161,185,165,49,62,96,27,240,171,33,63,175,5,127,77,
+	98,2,59,1,61,93,2,102,60,120,57,17,85,55,69,213,
+	242,252,238,171,121,24,206,127,147,44,174,67,205,58,131,150,
+	108,198,225,40,65,20,11,137,54,214,98,185,170,240,180,207,
+	72,233,19,58,127,160,217,242,159,218,193,117,221,248,108,2,
+	91,109,44,1,190,51,188,142,57,109,208,10,252,50,195,70,
+	40,106,132,219,235,52,69,93,19,215,202,220,186,251,130,48,
+	92,26,147,102,61,182,43,94,190,182,222,198,149,186,46,34,
+	161,226,219,228,51,105,214,91,129,147,151,219,140,246,131,155,
+	129,246,116,83,104,68,254,143,39,125,110,46,67,226,148,217,
+	115,104,181,25,109,219,149,176,69,118,36,58,20,65,18,18,
+	104,134,206,170,138,85,44,249,241,10,148,172,21,68,11,236,
+	124,242,238,62,162,245,237,36,58,20,36,33,65,143,175,215,
+	107,116,39,247,210,119,245,117,160,39,147,150,114,180,26,232,
+	252,4,90,216,14,162,205,47,21,21,236,122,225,137,157,247,
+	202,139,75,237,35,85,105,96,41,81,35,136,187,124,35,122,
+	243,23,17,16,136,53,159,140,26,29,123,102,141,183,39,30,
+	169,64,214,4,86,96,156,170,52,92,113,50,58,149,24,60,
+	133,91,154,102,19,79,230,170,20,179,142,29,47,26,84,156,
+	8,237,109,167,233,105,63,64,224,90,51,74,191,159,156,25,
+	183,43,78,166,43,112,15,224,28,165,137,247,78,148,128,30,
+	108,127,163,239,204,31,158,138,246,111,152,219,117,185,252,70,
+	193,150,200,86,48,180,153,56,115,170,17,204,124,162,245,181,
+	45,168,221,191,27,47,129,76,154,248,76,173,39,209,113,228,
+	105,93,213,247,137,51,191,94,22,207,15,11,246,236,78,236,
+	130,131,194,47,244,18,245,236,181,124,135,138,219,204,206,83,
+	91,128,192,68,30,180,101,176,198,25,186,94,155,228,147,193,
+	50,156,11,95,183,85,228,123,29,213,14,43,119,157,211,146,
+	42,101,15,51,216,13,20,127,222,167,220,2,119,192,196,73,
+	156,203,118,39,72,76,22,1,107,48,120,241,243,38,33,77,
+	242,124,214,212,127,70,83,54,101,83,150,145,253,23,118,236,
+	95,208,24,43,190,110,0,0,0,0,73,69,78,68,174,66,
+	96,130,
+
+};
+
+#include <gtkmm/label.h>
+
+static const unsigned char xapian_powered_png_data[] = 
+{       	137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,
+	0,0,0,208,0,0,0,30,8,3,0,0,0,106,152,96,
+	130,0,0,0,4,103,65,77,65,0,0,175,200,55,5,138,
+	233,0,0,0,25,116,69,88,116,83,111,102,116,119,97,114,
+	101,0,65,100,111,98,101,32,73,109,97,103,101,82,101,97,
+	100,121,113,201,101,60,0,0,1,128,80,76,84,69,205,205,
+	205,226,124,52,255,56,7,51,51,177,255,115,101,166,230,102,
+	250,213,180,171,171,171,71,71,157,255,102,82,233,130,54,255,
+	153,56,51,51,202,185,243,102,250,174,121,147,217,102,190,190,
+	190,255,181,115,148,148,214,255,245,22,255,245,179,255,210,118,
+	201,254,102,255,86,56,255,74,39,255,154,155,255,217,56,218,
+	116,51,255,199,85,150,214,124,197,251,102,255,137,134,255,223,
+	46,255,185,104,255,210,146,236,183,148,52,52,154,255,66,24,
+	148,147,183,216,218,228,255,215,213,255,166,133,255,236,233,250,
+	148,74,203,101,51,204,255,103,255,165,167,241,139,55,138,211,
+	102,255,250,245,255,211,69,255,226,220,176,237,102,251,149,66,
+	202,202,218,255,152,66,255,246,236,255,128,122,210,108,51,233,
+	189,165,255,179,172,255,197,197,255,252,250,68,68,191,255,252,
+	13,243,141,66,255,238,28,255,233,34,172,229,124,210,211,218,
+	255,94,68,255,167,156,255,251,248,255,80,43,160,221,124,255,
+	245,244,157,224,102,255,204,78,255,255,255,130,206,102,255,228,
+	39,237,135,62,102,102,102,178,178,178,217,217,217,153,153,153,
+	236,236,236,159,159,159,140,140,140,197,197,197,229,229,229,245,
+	245,245,249,249,249,226,226,226,111,111,111,165,165,165,223,223,
+	223,242,242,242,121,121,121,185,185,185,210,210,210,130,130,130,
+	254,255,254,149,149,149,183,237,124,255,150,139,255,190,182,255,
+	255,250,255,255,254,255,226,65,255,255,157,178,177,198,253,151,
+	73,242,182,134,191,247,102,255,249,218,196,249,103,255,191,96,
+	255,216,95,255,236,42,124,202,102,255,175,175,255,255,127,75,
+	75,130,255,143,143,255,255,193,247,145,60,247,145,71,7,225,
+	45,180,0,0,6,205,73,68,65,84,120,218,98,240,27,102,
+	0,32,128,24,232,105,153,51,16,56,57,9,11,11,59,0,
+	65,30,109,236,0,8,32,26,123,72,23,6,196,74,120,253,
+	252,2,20,20,2,2,160,94,170,202,166,141,141,0,1,68,
+	39,15,137,201,21,153,248,249,41,72,73,73,1,253,4,242,
+	82,94,142,29,109,108,4,8,32,250,120,72,12,24,65,64,
+	15,201,24,1,1,208,79,1,229,181,126,118,130,180,177,17,
+	32,128,104,237,33,49,8,144,43,226,101,245,243,43,149,145,
+	145,241,5,122,41,183,54,219,80,144,59,135,38,54,2,4,
+	16,205,61,36,7,2,37,69,188,38,172,126,57,130,165,165,
+	64,63,249,150,21,251,121,8,114,115,211,198,70,128,0,162,
+	181,135,74,74,138,138,138,120,121,129,254,241,241,243,19,84,
+	4,130,82,81,139,28,67,65,115,90,121,8,32,128,104,237,
+	33,176,103,128,128,213,135,31,24,67,32,32,106,232,7,244,
+	143,185,57,141,60,4,16,64,52,246,80,6,208,55,172,64,
+	224,227,195,111,224,231,167,201,199,199,167,148,3,244,79,65,
+	65,129,185,57,109,108,4,8,32,90,123,8,24,53,64,192,
+	207,207,111,224,15,246,16,155,159,159,29,95,189,54,237,60,
+	4,16,64,52,247,16,196,55,6,6,254,21,64,15,105,178,
+	249,229,120,240,57,214,107,131,124,148,70,19,27,1,2,136,
+	214,30,202,112,113,241,2,2,89,32,240,203,209,20,241,75,
+	179,227,11,12,4,249,200,212,20,162,34,141,61,40,34,34,
+	34,41,60,54,14,68,197,197,226,55,47,154,160,141,0,1,
+	68,99,15,229,164,229,0,65,26,4,128,4,236,248,184,184,
+	64,62,50,53,173,131,42,137,140,8,10,10,138,96,15,139,
+	72,10,10,74,74,199,239,226,72,66,30,246,243,3,8,32,
+	186,54,78,253,114,98,248,184,24,25,65,62,170,171,171,131,
+	139,198,38,5,5,3,3,63,41,40,156,80,4,16,225,33,
+	128,0,162,169,135,132,64,64,13,10,242,65,45,3,187,66,
+	70,70,144,143,244,129,0,161,46,54,46,40,196,47,61,40,
+	28,150,174,34,131,131,131,195,32,50,33,33,209,97,193,17,
+	193,33,96,94,72,72,8,134,138,232,144,144,48,191,216,224,
+	96,152,71,0,2,136,34,15,37,6,7,39,160,50,80,1,
+	15,15,51,16,168,64,128,43,36,142,148,25,165,129,62,226,
+	66,241,144,31,67,80,28,123,80,42,52,126,194,226,130,146,
+	82,131,130,64,113,17,29,7,76,134,64,28,20,20,9,86,
+	21,20,36,0,86,145,4,86,1,246,93,56,80,69,56,72,
+	5,84,59,64,0,81,22,67,41,161,80,253,33,161,12,184,
+	60,4,241,14,71,8,48,130,140,179,188,129,62,146,150,6,
+	123,137,11,185,45,23,28,20,4,79,77,193,65,236,105,126,
+	145,208,248,138,13,2,37,196,144,56,136,235,5,64,105,19,
+	170,130,1,170,34,4,168,53,196,47,58,60,72,0,156,73,
+	1,2,8,230,142,196,168,132,152,20,6,80,44,2,41,134,
+	68,32,25,149,16,21,147,0,162,128,97,31,2,18,242,139,
+	10,137,9,97,136,1,170,101,96,0,25,31,3,20,100,135,
+	233,15,102,136,98,72,137,241,75,72,0,170,79,72,128,68,
+	87,14,15,15,200,75,32,255,84,171,3,249,198,54,54,54,
+	222,126,126,202,86,96,47,49,34,123,61,44,40,40,29,158,
+	0,131,216,129,113,19,20,1,225,5,197,129,51,15,196,245,
+	33,16,15,197,198,33,171,136,0,71,95,24,148,11,16,128,
+	138,50,214,65,16,138,161,104,55,86,86,255,128,201,15,240,
+	7,28,76,186,148,114,237,139,166,194,195,73,126,128,248,243,
+	60,177,16,157,154,52,119,184,39,61,233,86,104,132,186,137,
+	38,238,225,36,72,93,165,78,89,31,162,48,174,97,130,174,
+	23,245,26,153,147,102,43,203,155,59,57,118,32,23,131,148,
+	36,168,133,218,118,161,144,238,221,190,38,110,230,249,120,56,
+	95,166,66,116,250,48,253,126,227,103,88,245,37,186,147,12,
+	59,208,58,163,125,0,253,39,174,171,157,17,228,69,0,193,
+	83,74,8,208,51,126,193,201,126,145,241,192,56,72,78,246,
+	243,99,143,244,11,15,13,73,4,10,135,129,164,216,5,252,
+	98,128,190,97,79,6,75,134,132,2,147,91,12,80,4,238,
+	33,160,77,81,161,97,64,137,24,191,120,6,63,132,135,64,
+	81,196,1,138,31,13,61,61,201,204,26,249,76,45,63,59,
+	107,43,29,160,151,144,60,20,30,20,17,11,201,53,32,39,
+	37,129,114,4,170,135,252,80,60,132,170,34,34,8,89,33,
+	64,0,193,61,20,21,10,226,197,251,5,131,2,42,1,200,
+	73,97,15,11,141,20,8,137,7,73,129,64,36,40,93,249,
+	69,198,0,189,9,4,225,126,12,193,224,148,6,79,114,64,
+	2,148,145,194,67,194,128,126,66,241,16,135,58,176,187,173,
+	33,41,89,35,47,111,201,194,98,169,229,151,99,173,163,163,
+	99,133,104,41,68,6,197,69,3,243,71,18,36,91,199,197,
+	69,198,130,220,23,29,140,43,134,96,42,252,130,49,61,4,
+	16,64,104,30,98,135,120,8,24,1,192,120,73,9,78,136,
+	143,20,0,73,69,69,69,1,11,71,168,243,227,5,128,92,
+	6,172,30,74,1,230,219,96,129,100,63,100,15,241,128,227,
+	199,22,232,25,160,111,56,57,221,220,88,180,114,210,64,62,
+	130,251,39,4,18,57,233,144,130,10,226,104,96,150,8,1,
+	59,52,40,9,212,156,16,0,229,43,152,92,44,170,10,84,
+	15,1,4,16,146,135,162,128,217,66,0,152,153,128,41,137,
+	29,228,166,240,248,200,196,80,118,96,246,79,4,58,20,148,
+	253,65,210,64,144,12,52,59,37,30,232,233,48,160,72,50,
+	82,146,3,137,0,195,33,60,4,197,67,246,160,242,218,22,
+	234,27,113,113,79,79,9,78,173,108,63,107,184,135,66,216,
+	129,5,111,72,180,95,172,0,144,6,22,75,209,65,169,192,
+	148,155,26,20,23,14,241,80,80,120,24,176,66,13,2,149,
+	87,177,193,65,225,32,175,163,168,136,12,10,2,86,73,209,
+	193,96,67,252,252,0,2,8,201,67,225,193,241,241,192,226,
+	141,29,72,135,131,180,3,139,4,191,248,208,68,144,158,208,
+	224,80,129,152,68,246,208,80,144,251,195,194,227,227,227,129,
+	229,88,112,40,80,97,40,212,71,193,225,236,64,53,224,8,
+	12,247,67,246,16,216,63,89,16,223,0,61,35,33,161,170,
+	170,234,102,236,231,103,109,5,143,30,16,96,143,6,87,55,
+	65,169,160,198,29,16,196,1,253,144,4,41,229,32,92,184,
+	210,96,36,21,113,160,120,5,177,253,64,165,10,56,142,0,
+	2,8,238,161,132,208,152,144,4,112,226,143,98,128,208,137,
+	192,162,32,17,82,29,135,165,128,252,5,76,105,96,46,80,
+	33,36,12,66,98,18,33,34,64,133,49,137,9,64,102,100,
+	88,76,120,36,178,135,192,254,177,1,165,52,160,111,84,193,
+	128,137,137,73,28,232,35,54,72,227,14,220,24,0,34,191,
+	176,144,48,16,19,228,240,224,224,72,96,140,65,154,2,65,
+	17,97,2,32,46,180,165,0,105,43,32,169,136,6,137,133,
+	1,117,131,41,63,63,128,0,130,121,8,88,76,39,135,81,
+	220,214,9,11,77,102,15,143,65,242,16,200,63,57,238,226,
+	192,148,6,142,26,38,24,240,52,78,35,178,247,0,43,203,
+	136,5,0,1,4,243,80,20,3,3,67,2,229,173,183,148,
+	96,129,68,164,150,130,189,25,144,212,148,64,245,12,196,71,
+	26,68,13,52,178,167,130,90,226,164,244,156,0,2,136,166,
+	141,83,176,127,208,129,93,14,8,102,19,53,136,149,198,30,
+	17,28,28,193,78,138,157,0,1,68,223,238,3,29,0,64,
+	128,1,0,130,19,32,31,170,173,135,150,0,0,0,0,73,
+	69,78,68,174,66,96,130,
+
+};
+
+#include <gtkmm/box.h>
+
+aboutDialog_glade::aboutDialog_glade(
+)
+{  aboutDialog = this;
+   gmm_data = new GlademmData(get_accel_group());
+   closebutton1 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-close")));
+   
+   Glib::RefPtr<Gdk::PixbufLoader> _pinotImage_loader=Gdk::PixbufLoader::create();
+   _pinotImage_loader->write(pinot_png_data, sizeof pinot_png_data);
+   _pinotImage_loader->close();
+   
+   Gtk::Image *pinotImage = Gtk::manage(new class Gtk::Image(_pinotImage_loader->get_pixbuf()));
+   _pinotImage_loader=Glib::RefPtr<Gdk::PixbufLoader>();
+   nameLabel = Gtk::manage(new class Gtk::Label(_("Pinot")));
+   
+   Gtk::Label *descriptionLabel = Gtk::manage(new class Gtk::Label(_("A metasearch tool for the Free Desktop.")));
+   Gtk::Label *copyrightLabel = Gtk::manage(new class Gtk::Label(_("Copyright (C) 2005 Fabrice Colin")));
+   Glib::RefPtr<Gdk::PixbufLoader> _xapianImage_loader=Gdk::PixbufLoader::create();
+   _xapianImage_loader->write(xapian_powered_png_data, sizeof xapian_powered_png_data);
+   _xapianImage_loader->close();
+   
+   Gtk::Image *xapianImage = Gtk::manage(new class Gtk::Image(_xapianImage_loader->get_pixbuf()));
+   _xapianImage_loader=Glib::RefPtr<Gdk::PixbufLoader>();
+   
+   Gtk::VBox *aboutVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   closebutton1->set_flags(Gtk::CAN_FOCUS);
+   closebutton1->set_flags(Gtk::CAN_DEFAULT);
+   closebutton1->set_relief(Gtk::RELIEF_NORMAL);
+   aboutDialog->get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
+   pinotImage->set_alignment(0.5,0.5);
+   pinotImage->set_padding(0,0);
+   nameLabel->set_alignment(0.5,0.5);
+   nameLabel->set_padding(4,4);
+   nameLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   nameLabel->set_line_wrap(false);
+   nameLabel->set_use_markup(false);
+   nameLabel->set_selectable(false);
+   descriptionLabel->set_alignment(0.5,0.5);
+   descriptionLabel->set_padding(4,4);
+   descriptionLabel->set_justify(Gtk::JUSTIFY_CENTER);
+   descriptionLabel->set_line_wrap(true);
+   descriptionLabel->set_use_markup(false);
+   descriptionLabel->set_selectable(false);
+   copyrightLabel->set_alignment(0.5,0.5);
+   copyrightLabel->set_padding(4,4);
+   copyrightLabel->set_justify(Gtk::JUSTIFY_CENTER);
+   copyrightLabel->set_line_wrap(false);
+   copyrightLabel->set_use_markup(false);
+   copyrightLabel->set_selectable(false);
+   xapianImage->set_alignment(0.5,0.5);
+   xapianImage->set_padding(0,0);
+   aboutVbox->pack_start(*pinotImage);
+   aboutVbox->pack_start(*nameLabel, Gtk::PACK_SHRINK, 0);
+   aboutVbox->pack_start(*descriptionLabel, Gtk::PACK_SHRINK, 0);
+   aboutVbox->pack_start(*copyrightLabel, Gtk::PACK_SHRINK, 0);
+   aboutVbox->pack_start(*xapianImage);
+   aboutDialog->get_vbox()->set_homogeneous(false);
+   aboutDialog->get_vbox()->set_spacing(0);
+   aboutDialog->get_vbox()->pack_start(*aboutVbox, Gtk::PACK_SHRINK, 0);
+   aboutDialog->set_title(_("About Pinot"));
+   aboutDialog->set_modal(false);
+   aboutDialog->property_window_position().set_value(Gtk::WIN_POS_NONE);
+   aboutDialog->set_resizable(false);
+   aboutDialog->property_destroy_with_parent().set_value(false);
+   aboutDialog->set_has_separator(true);
+   aboutDialog->add_action_widget(*closebutton1, -7);
+   closebutton1->show();
+   pinotImage->show();
+   nameLabel->show();
+   descriptionLabel->show();
+   copyrightLabel->show();
+   xapianImage->show();
+   aboutVbox->show();
+   aboutDialog->show();
+}
+
+aboutDialog_glade::~aboutDialog_glade()
+{  delete gmm_data;
+}


Property changes on: trunk/UI/GTK2/src/aboutDialog_glade.cc
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/aboutDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/aboutDialog_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/aboutDialog_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,52 @@
+// generated 2004/7/24 17:45:26 BST by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0_cvs
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.4.0 and gtkmm 2.2.12
+//
+// Please modify the corresponding derived classes in ./src/aboutDialog.hh and./src/aboutDialog.cc
+
+#ifndef _ABOUTDIALOG_GLADE_HH
+#  define _ABOUTDIALOG_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include <gtkmm/accelgroup.h>
+
+class GlademmData
+{  
+        
+        Glib::RefPtr<Gtk::AccelGroup> accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr<Gtk::AccelGroup> ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr<Gtk::AccelGroup>  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include <gtkmm/dialog.h>
+#include <gtkmm/button.h>
+#include <gtkmm/label.h>
+
+class aboutDialog_glade : public Gtk::Dialog
+{  
+        
+        GlademmData *gmm_data;
+public:
+        class Gtk::Dialog * aboutDialog;
+protected:
+        class Gtk::Button * closebutton1;
+        class Gtk::Label * nameLabel;
+        
+        aboutDialog_glade();
+        
+        ~aboutDialog_glade();
+};
+#endif


Property changes on: trunk/UI/GTK2/src/aboutDialog_glade.hh
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/importDialog.cc
===================================================================
--- trunk/UI/GTK2/src/importDialog.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/importDialog.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,324 @@
+// generated 2004/3/6 14:15:21 GMT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to importDialog.cc_new
+
+// This file is for your program, I won't touch it again!
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <iostream>
+#include <glibmm/convert.h>
+
+#include "config.h"
+#include "MIMEScanner.h"
+#include "NLS.h"
+#include "Url.h"
+#include "PinotSettings.h"
+#include "PinotUtils.h"
+#include "importDialog.hh"
+
+using namespace std;
+using namespace SigC;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+string importDialog::m_directory = "";
+
+importDialog::importDialog(const Glib::ustring &title,
+	bool selectTitle, bool selectDepth, bool allowLocalOnly) :
+	importDialog_glade(),
+	m_docsCount(0),
+	m_importDirectory(false),
+	m_maxDirLevel(1)
+{
+	// Associate the columns model to the type combo
+	m_refTypeList = ListStore::create(m_typeColumns);
+	typeCombobox->set_model(m_refTypeList);
+	typeCombobox->pack_start(m_typeColumns.m_name);
+	// Populate
+	populate_combobox(allowLocalOnly);
+
+	// Initialize the default directory
+	if (m_directory.empty() == true)
+	{
+		char *homeDir = getenv("HOME");
+		if (homeDir != NULL)
+		{
+			m_directory = homeDir + string("/");
+		}
+	}
+
+	set_title(title);
+
+	if (selectTitle == false)
+	{
+		titleLabel->hide();
+		titleEntry->hide();
+	}
+
+	if (selectDepth == false)
+	{
+		depthLabel->hide();
+		depthSpinbutton->hide();
+	}
+	else
+	{
+		// The default type is not directory
+		// FIXME: this could also apply to URLs !
+		depthSpinbutton->set_sensitive(false);
+		depthSpinbutton->set_value(m_maxDirLevel);
+	}
+
+	// Disable the OK button as long the location entry field is empty
+	// The title field may remain empty
+	importOkButton->set_sensitive(false);
+}
+
+importDialog::~importDialog()
+{
+}
+
+void importDialog::populate_combobox(bool allowLocalOnly)
+{
+	bool foundLanguage = false;
+
+	TreeModel::iterator iter = m_refTypeList->append();
+	TreeModel::Row row = *iter;
+	row[m_typeColumns.m_name] = _("Single file");
+	iter = m_refTypeList->append();
+	row = *iter;
+	row[m_typeColumns.m_name] = _("Whole directory");
+	if (allowLocalOnly == false)
+	{
+		iter = m_refTypeList->append();
+		row = *iter;
+		row[m_typeColumns.m_name] = _("URL");
+	}
+
+	typeCombobox->set_active(0);
+}
+
+void importDialog::scan_file(const string &fileName, unsigned int &level)
+{
+	struct stat fileStat;
+	Url urlObj("file://" + fileName);
+
+	if ((fileName.empty() == true) ||
+		(urlObj.getFile() == ".") ||
+		(urlObj.getFile() == ".."))
+	{
+		return;
+	}
+
+#ifdef DEBUG
+	cout << "importDialog::scan_file: " << fileName << endl;
+#endif
+	if (lstat(fileName.c_str(), &fileStat) == -1)
+	{
+#ifdef DEBUG
+		cout << "importDialog::scan_file: stat failed" << endl;
+#endif
+		return;
+	}
+
+	// Is it a file or a directory ?
+	if (S_ISLNK(fileStat.st_mode))
+	{
+		cout << "importDialog::scan_file: skipping symlink" << endl;
+		return;
+	}
+	else if (S_ISDIR(fileStat.st_mode))
+	{
+		// A directory : scan it
+		DIR *pDir = opendir(fileName.c_str());
+		if (pDir == NULL)
+		{
+			return;
+		}
+
+		// Iterate through this directory's entries
+		struct dirent *pDirEntry = readdir(pDir);
+		while (pDirEntry != NULL)
+		{
+			char *pEntryName = pDirEntry->d_name;
+			if (pEntryName != NULL)
+			{
+				string location = fileName;
+				location += "/";
+				location += pEntryName;
+
+				// Scan this entry
+				if ((m_maxDirLevel == 0) ||
+					(level < m_maxDirLevel))
+				{
+					++level;
+					scan_file(location, level);
+					--level;
+				}
+#ifdef DEBUG
+				else cout << "importDialog::scan_file: not going deeper than level " << level << endl;
+#endif
+			}
+
+			// Next entry
+			pDirEntry = readdir(pDir);
+		}
+		closedir(pDir);
+	}
+	else	if (S_ISREG(fileStat.st_mode))
+	{
+		// Get the MIME type
+		string mimeType = MIMEScanner::scanFile(fileName);
+		// Build a valid URL
+		string location = "file://";
+		location += fileName;
+		string title = locale_from_utf8(m_title);
+
+		if (m_importDirectory == true)
+		{
+			title += " ";
+			title += urlObj.getFile();
+		}
+
+		// Fire up the signal
+		m_signalImportFile(DocumentInfo(title, location, mimeType, ""));
+		++m_docsCount;
+	}
+}
+
+ustring importDialog::getDocumentTitle(void)
+{
+	return m_title;
+}
+
+unsigned int importDialog::getDocumentsCount(void)
+{
+	return m_docsCount;
+}
+
+Signal1<void, DocumentInfo> &importDialog::getImportFileSignal(void)
+{
+	return m_signalImportFile;
+}
+
+void importDialog::on_importOkButton_clicked()
+{
+	string location = locale_from_utf8(locationEntry->get_text());
+	unsigned int level = 0;
+
+	// Title
+	m_title = titleEntry->get_text();
+	// Type
+	if (typeCombobox->get_active_row_number() <= 1)
+	{
+		string::size_type pos = location.find_last_of("/");
+		if (pos != string::npos)
+		{
+			// Update m_directory
+			m_directory = location.substr(0, pos + 1);
+#ifdef DEBUG
+			cout << "importDialog::on_importOkButton_clicked: directory now " << m_directory << endl;
+#endif
+		}
+
+		// Maximum depth
+		m_maxDirLevel = (unsigned int)depthSpinbutton->get_value();
+
+		scan_file(location, level);
+	}
+	else
+	{
+		Url urlObj(location);
+
+		// Signal now
+		m_signalImportFile(DocumentInfo(locale_from_utf8(m_title), location,
+			MIMEScanner::scanUrl(urlObj), ""));
+		++m_docsCount;
+	}
+}
+
+void importDialog::on_selectButton_clicked()
+{
+	ustring fileName = locale_to_utf8(m_directory);
+
+	if (select_file_name(*this, _("Document To Import"), fileName, true, m_importDirectory) == true)
+	{
+		// Update the location
+#ifdef DEBUG
+		cout << "importDialog::on_selectButton_clicked: location is " << fileName << endl;
+#endif
+		locationEntry->set_text(fileName);
+		ustring::size_type pos = fileName.find_last_of("/");
+		if (pos != string::npos)
+		{
+			// Update m_directory
+		m_directory = locale_from_utf8(fileName.substr(0, pos + 1));
+#ifdef DEBUG
+		cout << "importDialog::on_selectButton_clicked: directory now " << m_directory << endl;
+#endif
+		}
+	}
+}
+
+void importDialog::on_locationEntry_changed()
+{
+	ustring fileName = locationEntry->get_text();
+	bool enableOk = true;
+
+	if (fileName.empty() == false)
+	{
+		unsigned int type = typeCombobox->get_active_row_number();
+
+		// Check the entry makes sense
+		if (type <= 1)
+		{
+			if (fileName[0] != '/')
+			{
+				enableOk = false;
+			}
+		}
+		else
+		{
+			Url urlObj(locale_from_utf8(fileName));
+
+			// Check the URL is valid
+			if (urlObj.getProtocol().empty() == true)
+			{
+				enableOk = false;
+			}
+			// FIXME: be more thorough
+		}
+	}
+	else
+	{
+		enableOk = false;
+	}
+
+	importOkButton->set_sensitive(enableOk);
+}
+
+void importDialog::on_typeCombobox_changed()
+{
+	unsigned int type = typeCombobox->get_active_row_number();
+	bool selectLocation = true;
+
+	m_importDirectory = false;
+	if (type == 1)
+	{
+		m_importDirectory = true;
+	}
+	else if (type > 1)
+	{
+		// Disable the select button only if type is URL
+		selectLocation = false;
+	}
+
+	// FIXME: this could also apply to URLs !
+	depthSpinbutton->set_sensitive(m_importDirectory);
+	selectButton->set_sensitive(selectLocation);
+}

Added: trunk/UI/GTK2/src/importDialog.hh
===================================================================
--- trunk/UI/GTK2/src/importDialog.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/importDialog.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,63 @@
+// generated 2004/3/6 14:15:21 GMT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to importDialog.hh_new
+
+// you might replace
+//    class foo : public foo_glade { ... };
+// by
+//    typedef foo_glade foo;
+// if you didn't make any modifications to the widget
+
+#ifndef _IMPORTDIALOG_HH
+#define _IMPORTDIALOG_HH
+
+#include <string>
+#include <vector>
+#include <sigc++/slot.h>
+#include <glibmm/refptr.h>
+#include <glibmm/ustring.h>
+#include <gtkmm/liststore.h>
+
+#include "DocumentInfo.h"
+#include "ModelColumns.h"
+#include "importDialog_glade.hh"
+
+class importDialog : public importDialog_glade
+{  
+public:
+	/// Open the dialog box in import mode.
+	importDialog(const Glib::ustring &title,
+		bool selectTitle = true, bool selectDepth = true,
+		bool allowLocalOnly = false);
+	virtual ~importDialog();
+
+	Glib::ustring getDocumentTitle(void);
+
+	unsigned int getDocumentsCount(void);
+
+	/// Returns the import file signal.
+	SigC::Signal1<void, DocumentInfo>& getImportFileSignal(void);
+
+protected:
+	void populate_combobox(bool allowLocalOnly);
+	void scan_file(const std::string &fileName, unsigned int &level);
+
+private:
+	ComboModelColumns m_typeColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refTypeList;
+	Glib::ustring m_title;
+	unsigned int m_docsCount;
+	bool m_importDirectory;
+	unsigned int m_maxDirLevel;
+	SigC::Signal1<void, DocumentInfo> m_signalImportFile;
+	static std::string m_directory;
+
+	virtual void on_importOkButton_clicked();
+	virtual void on_selectButton_clicked();
+	virtual void on_locationEntry_changed();
+	virtual void on_typeCombobox_changed();
+
+};
+
+#endif

Added: trunk/UI/GTK2/src/importDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/importDialog_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/importDialog_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,197 @@
+// generated 2005/11/6 16:43:41 SGT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/importDialog.cc
+
+
+#if defined __GNUC__ && __GNUC__ < 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include "config.h"
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include <libintl.h>
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include <gtkmmconfig.h>
+#if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
+#include <sigc++/compatibility.h>
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include "importDialog_glade.hh"
+#include <gdk/gdkkeysyms.h>
+#include <gtkmm/accelgroup.h>
+#include <gtkmm/button.h>
+#include <gtkmm/buttonbox.h>
+#include <gtkmm/image.h>
+#include <gtkmm/label.h>
+#include <gtkmm/box.h>
+#include <gtkmm/alignment.h>
+#include <gtkmm/adjustment.h>
+
+importDialog_glade::importDialog_glade(
+)
+{  importDialog = this;
+   gmm_data = new GlademmData(get_accel_group());
+   
+   Gtk::Button *cancelbutton1 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
+   importOkButton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
+   
+   Gtk::Image *image180 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-open"), Gtk::IconSize(4)));
+   Gtk::Label *label17 = Gtk::manage(new class Gtk::Label(_("Select")));
+   Gtk::HBox *hbox14 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment9 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
+   selectButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::HButtonBox *hbuttonbox3 = Gtk::manage(new class Gtk::HButtonBox(Gtk::BUTTONBOX_DEFAULT_STYLE, 0));
+   locationEntry = Gtk::manage(new class Gtk::Entry());
+   titleEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Label *locationLabel = Gtk::manage(new class Gtk::Label(_("Location:")));
+   titleLabel = Gtk::manage(new class Gtk::Label(_("Title:")));
+   depthLabel = Gtk::manage(new class Gtk::Label(_("Maximum depth:")));
+   
+   Gtk::Adjustment *depthSpinbutton_adj = Gtk::manage(new class Gtk::Adjustment(0, 0, 100, 1, 5, 5));
+   depthSpinbutton = Gtk::manage(new class Gtk::SpinButton(*depthSpinbutton_adj, 1, 0));
+   typeCombobox = Gtk::manage(new class Gtk::ComboBox());
+   
+   Gtk::Label *typeLabel = Gtk::manage(new class Gtk::Label(_("Type:")));
+   docTable = Gtk::manage(new class Gtk::Table(2, 2, false));
+   cancelbutton1->set_flags(Gtk::CAN_FOCUS);
+   cancelbutton1->set_flags(Gtk::CAN_DEFAULT);
+   cancelbutton1->set_relief(Gtk::RELIEF_NORMAL);
+   importOkButton->set_flags(Gtk::CAN_FOCUS);
+   importOkButton->set_flags(Gtk::CAN_DEFAULT);
+   importOkButton->set_relief(Gtk::RELIEF_NORMAL);
+   importDialog->get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
+   image180->set_alignment(0.5,0.5);
+   image180->set_padding(0,0);
+   label17->set_alignment(0.5,0.5);
+   label17->set_padding(0,0);
+   label17->set_justify(Gtk::JUSTIFY_LEFT);
+   label17->set_line_wrap(false);
+   label17->set_use_markup(false);
+   label17->set_selectable(false);
+   hbox14->pack_start(*image180, Gtk::PACK_SHRINK, 0);
+   hbox14->pack_start(*label17, Gtk::PACK_SHRINK, 0);
+   alignment9->add(*hbox14);
+   selectButton->set_flags(Gtk::CAN_FOCUS);
+   selectButton->set_flags(Gtk::CAN_DEFAULT);
+   selectButton->set_relief(Gtk::RELIEF_NORMAL);
+   selectButton->add(*alignment9);
+   hbuttonbox3->pack_start(*selectButton);
+   locationEntry->set_flags(Gtk::CAN_FOCUS);
+   locationEntry->set_visibility(true);
+   locationEntry->set_editable(true);
+   locationEntry->set_max_length(0);
+   locationEntry->set_text(_(""));
+   locationEntry->set_has_frame(true);
+   locationEntry->set_activates_default(false);
+   titleEntry->set_flags(Gtk::CAN_FOCUS);
+   titleEntry->set_visibility(true);
+   titleEntry->set_editable(true);
+   titleEntry->set_max_length(0);
+   titleEntry->set_text(_(""));
+   titleEntry->set_has_frame(true);
+   titleEntry->set_activates_default(false);
+   locationLabel->set_alignment(0,0.5);
+   locationLabel->set_padding(4,4);
+   locationLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   locationLabel->set_line_wrap(false);
+   locationLabel->set_use_markup(false);
+   locationLabel->set_selectable(false);
+   titleLabel->set_alignment(0,0.5);
+   titleLabel->set_padding(4,4);
+   titleLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   titleLabel->set_line_wrap(false);
+   titleLabel->set_use_markup(false);
+   titleLabel->set_selectable(false);
+   depthLabel->set_alignment(0,0.5);
+   depthLabel->set_padding(4,4);
+   depthLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   depthLabel->set_line_wrap(false);
+   depthLabel->set_use_markup(false);
+   depthLabel->set_selectable(false);
+   depthSpinbutton->set_flags(Gtk::CAN_FOCUS);
+   depthSpinbutton->set_update_policy(Gtk::UPDATE_ALWAYS);
+   depthSpinbutton->set_numeric(false);
+   depthSpinbutton->set_digits(0);
+   depthSpinbutton->set_wrap(false);
+   typeLabel->set_alignment(0,0.5);
+   typeLabel->set_padding(4,4);
+   typeLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   typeLabel->set_line_wrap(false);
+   typeLabel->set_use_markup(false);
+   typeLabel->set_selectable(false);
+   docTable->set_row_spacings(0);
+   docTable->set_col_spacings(0);
+   docTable->attach(*hbuttonbox3, 2, 3, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   docTable->attach(*locationEntry, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   docTable->attach(*titleEntry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   docTable->attach(*locationLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   docTable->attach(*titleLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   docTable->attach(*depthLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
+   docTable->attach(*depthSpinbutton, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   docTable->attach(*typeCombobox, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   docTable->attach(*typeLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   importDialog->get_vbox()->set_homogeneous(false);
+   importDialog->get_vbox()->set_spacing(0);
+   importDialog->get_vbox()->pack_start(*docTable);
+   importDialog->set_title(_("Import document"));
+   importDialog->set_modal(false);
+   importDialog->property_window_position().set_value(Gtk::WIN_POS_NONE);
+   importDialog->set_resizable(true);
+   importDialog->property_destroy_with_parent().set_value(false);
+   importDialog->set_has_separator(true);
+   importDialog->add_action_widget(*cancelbutton1, -6);
+   importDialog->add_action_widget(*importOkButton, -5);
+   cancelbutton1->show();
+   importOkButton->show();
+   image180->show();
+   label17->show();
+   hbox14->show();
+   alignment9->show();
+   selectButton->show();
+   hbuttonbox3->show();
+   locationEntry->show();
+   titleEntry->show();
+   locationLabel->show();
+   titleLabel->show();
+   depthLabel->show();
+   depthSpinbutton->show();
+   typeCombobox->show();
+   typeLabel->show();
+   docTable->show();
+   importDialog->show();
+   importOkButton->signal_clicked().connect(SigC::slot(*this, &importDialog_glade::on_importOkButton_clicked), false);
+   selectButton->signal_clicked().connect(SigC::slot(*this, &importDialog_glade::on_selectButton_clicked), false);
+   locationEntry->signal_changed().connect(SigC::slot(*this, &importDialog_glade::on_locationEntry_changed), false);
+   typeCombobox->signal_changed().connect(SigC::slot(*this, &importDialog_glade::on_typeCombobox_changed), false);
+}
+
+importDialog_glade::~importDialog_glade()
+{  delete gmm_data;
+}

Added: trunk/UI/GTK2/src/importDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/importDialog_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/importDialog_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,68 @@
+// generated 2005/11/6 16:25:47 SGT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/importDialog.hh and./src/importDialog.cc
+
+#ifndef _IMPORTDIALOG_GLADE_HH
+#  define _IMPORTDIALOG_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include <gtkmm/accelgroup.h>
+
+class GlademmData
+{  
+        
+        Glib::RefPtr<Gtk::AccelGroup> accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr<Gtk::AccelGroup> ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr<Gtk::AccelGroup>  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include <gtkmm/dialog.h>
+#include <gtkmm/button.h>
+#include <gtkmm/entry.h>
+#include <gtkmm/label.h>
+#include <gtkmm/spinbutton.h>
+#include <gtkmm/combobox.h>
+#include <gtkmm/table.h>
+
+class importDialog_glade : public Gtk::Dialog
+{  
+        
+        GlademmData *gmm_data;
+public:
+        class Gtk::Dialog * importDialog;
+protected:
+        class Gtk::Button * importOkButton;
+        class Gtk::Button * selectButton;
+        class Gtk::Entry * locationEntry;
+        class Gtk::Entry * titleEntry;
+        class Gtk::Label * titleLabel;
+        class Gtk::Label * depthLabel;
+        class Gtk::SpinButton * depthSpinbutton;
+        class Gtk::ComboBox * typeCombobox;
+        class Gtk::Table * docTable;
+        
+        importDialog_glade();
+        
+        ~importDialog_glade();
+private:
+        virtual void on_importOkButton_clicked() = 0;
+        virtual void on_selectButton_clicked() = 0;
+        virtual void on_locationEntry_changed() = 0;
+        virtual void on_typeCombobox_changed() = 0;
+};
+#endif

Added: trunk/UI/GTK2/src/indexDialog.cc
===================================================================
--- trunk/UI/GTK2/src/indexDialog.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/indexDialog.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,243 @@
+// generated 2005/2/14 18:45:02 GMT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// newer (non customized) versions of this file go to indexDialog.cc_new
+
+// This file is for your program, I won't touch it again!
+
+#include <iostream>
+
+#include "config.h"
+#include "NLS.h"
+#include "PinotSettings.h"
+#include "PinotUtils.h"
+#include "indexDialog.hh"
+
+using namespace std;
+using namespace Glib;
+using namespace Gtk;
+
+indexDialog::indexDialog() :
+	indexDialog_glade(),
+	m_editIndex(false),
+	m_badName(true)
+{
+	// Associate the columns model to the type combo
+	m_refTypeTree = ListStore::create(m_typeColumns);
+	typeCombobox->set_model(m_refTypeTree);
+	typeCombobox->pack_start(m_typeColumns.m_name);
+	// Populate
+	populate_typeCombobox();
+
+	// By default, type is set to local
+	typeCombobox->set_active(0);
+	portSpinbutton->set_sensitive(false);
+	// ...and both name and location are empty
+	indexOkbutton->set_sensitive(false);
+}
+
+indexDialog::indexDialog(const ustring &name, const ustring &location) :
+	indexDialog_glade(),
+	m_name(name),
+	m_location(location),
+	m_editIndex(false),
+	m_badName(true)
+{
+	ustring dirName = location;
+	unsigned int port = 1024;
+
+	// Associate the columns model to the type combo
+	m_refTypeTree = ListStore::create(m_typeColumns);
+	typeCombobox->set_model(m_refTypeTree);
+	typeCombobox->pack_start(m_typeColumns.m_name);
+	// Populate
+	populate_typeCombobox();
+
+	// Name
+	nameEntry->set_text(name);
+
+	// Type and location
+	ustring::size_type colonPos = location.find(":");
+	if ((location[0] != '/') &&
+		(colonPos != ustring::npos))
+	{
+		// This is a remote index
+		dirName = location.substr(0, colonPos);
+		port = (unsigned int)atoi(location.substr(colonPos + 1).c_str());
+
+		typeCombobox->set_active(1);
+		locationButton->set_sensitive(false);
+
+		// Port
+		portSpinbutton->set_value((double)port);
+	}
+	else
+	{
+		typeCombobox->set_active(0);
+		portSpinbutton->set_sensitive(false);
+	}
+	locationEntry->set_text(dirName);
+
+	m_editIndex = true;
+}
+
+indexDialog::~indexDialog()
+{
+}
+
+void indexDialog::populate_typeCombobox(void)
+{
+	TreeModel::iterator iter = m_refTypeTree->append();
+	TreeModel::Row row = *iter;
+	row[m_typeColumns.m_name] = "Local";
+	iter = m_refTypeTree->append();
+	row = *iter;
+	row[m_typeColumns.m_name] = "Remote";
+}
+
+void indexDialog::checkFields(void)
+{
+	bool enableOkButton = false;
+
+	ustring name = nameEntry->get_text();
+	ustring location = locationEntry->get_text();
+	if ((name.empty() == false) &&
+		(location.empty() == false))
+	{
+		bool startsWithSlash = false, isLocal = false;
+
+		if (location[0] == '/')
+		{
+			startsWithSlash = true;
+		}
+
+		if (typeCombobox->get_active_row_number() == 0)
+		{
+			isLocal = true;
+		}
+
+		// Disable the OK button if the type+location pair doesn't make sense
+		if (startsWithSlash == isLocal)
+		{
+			enableOkButton = true;
+		}
+	}
+
+	indexOkbutton->set_sensitive(enableOkButton);
+}
+
+bool indexDialog::badName(void) const
+{
+	return m_badName;
+}
+
+ustring indexDialog::getName(void) const
+{
+	return m_name;
+}
+
+ustring indexDialog::getLocation(void) const
+{
+	return m_location;
+}
+
+void indexDialog::on_indexOkbutton_clicked()
+{
+	PinotSettings &settings = PinotSettings::getInstance();
+
+	// The changed() methods ensure name and location are set
+	ustring name = nameEntry->get_text();
+	ustring location = locationEntry->get_text();
+	m_badName = false;
+
+	// Is it a remote index ?
+	if (typeCombobox->get_active_row_number() == 1)
+	{
+		char portStr[64];
+		int port = portSpinbutton->get_value_as_int();
+		snprintf(portStr, 64, "%d", port);
+
+		// Append the port number
+		location += ":";
+		location += portStr;
+	}
+#ifdef DEBUG
+	cout << "indexDialog::on_indexOkbutton_clicked: " << name << ", " << location << endl;
+#endif
+
+	// Look up that index name in the map
+	const std::map<string, string> &indexesMap = settings.getIndexes();
+	std::map<string, string>::const_iterator indexIter = indexesMap.find(locale_from_utf8(name));
+	if (indexIter != indexesMap.end())
+	{
+		// This name is in use
+		m_badName = true;
+#ifdef DEBUG
+		cout << "indexDialog::on_indexOkbutton_clicked: name in use" << endl;
+#endif
+	}
+
+	if ((m_editIndex == true) &&
+		(name == m_name))
+	{
+		// ... but that's okay, because it's the original name
+		m_badName = false;
+#ifdef DEBUG
+		cout << "indexDialog::on_indexOkbutton_clicked: old name" << endl;
+#endif
+	}
+
+	m_name = name;
+	m_location = location;
+}
+
+void indexDialog::on_locationEntry_changed()
+{
+	checkFields();
+}
+
+void indexDialog::on_locationButton_clicked()
+{
+	ustring dirName = locationEntry->get_text();
+	if (select_file_name(*this, _("Index location"), dirName, true, true) == true)
+	{
+		locationEntry->set_text(dirName);
+	}
+}
+
+void indexDialog::on_typeCombobox_changed()
+{
+	bool startsWithSlash = false, isLocal = false;
+
+	ustring location = locationEntry->get_text();
+	if ((location.empty() == false) &&
+		(location[0] == '/'))
+	{
+		startsWithSlash = true;
+	}
+
+	// Enable the browser entry field and button only if browsing is enabled
+	if (typeCombobox->get_active_row_number() == 1)
+	{
+		// Remote index
+		portSpinbutton->set_sensitive(true);
+		locationButton->set_sensitive(false);
+	}
+	else
+	{
+		// Local index
+		portSpinbutton->set_sensitive(false);
+		locationButton->set_sensitive(true);
+		isLocal = true;
+	}
+
+	if (startsWithSlash != isLocal)
+	{
+		indexOkbutton->set_sensitive(false);
+	}
+}
+
+void indexDialog::on_nameEntry_changed()
+{
+	checkFields();
+}

Added: trunk/UI/GTK2/src/indexDialog.hh
===================================================================
--- trunk/UI/GTK2/src/indexDialog.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/indexDialog.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,52 @@
+// generated 2005/2/14 18:45:02 GMT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// newer (non customized) versions of this file go to indexDialog.hh_new
+
+// you might replace
+//    class foo : public foo_glade { ... };
+// by
+//    typedef foo_glade foo;
+// if you didn't make any modifications to the widget
+
+#ifndef _INDEXDIALOG_HH
+#define _INDEXDIALOG_HH
+
+#include <glibmm/ustring.h>
+#include <gtkmm/liststore.h>
+
+#include "ModelColumns.h"
+#include "indexDialog_glade.hh"
+
+class indexDialog : public indexDialog_glade
+{  
+public:
+	indexDialog();
+	indexDialog(const Glib::ustring &name, const Glib::ustring &location);
+	virtual ~indexDialog();
+
+	bool badName(void) const;
+
+	Glib::ustring getName(void) const;
+
+	Glib::ustring getLocation(void) const;
+
+protected:
+	Glib::ustring m_name;
+	Glib::ustring m_location;
+	ComboModelColumns m_typeColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refTypeTree;
+	bool m_editIndex;
+	bool m_badName;
+
+	void populate_typeCombobox(void);
+	void checkFields(void);
+
+	virtual void on_indexOkbutton_clicked();
+	virtual void on_locationEntry_changed();
+	virtual void on_locationButton_clicked();
+	virtual void on_typeCombobox_changed();
+	virtual void on_nameEntry_changed();
+
+};
+#endif

Added: trunk/UI/GTK2/src/indexDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/indexDialog_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/indexDialog_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,176 @@
+// generated 2005/4/17 5:19:13 BST by fabrice at thorgrim.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.4.0 and gtkmm 2.4.8
+//
+// Please modify the corresponding derived classes in ./src/indexDialog.cc
+
+
+#if defined __GNUC__ && __GNUC__ < 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include "config.h"
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include <libintl.h>
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include <gtkmmconfig.h>
+#if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
+#include <sigc++/compatibility.h>
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include "indexDialog_glade.hh"
+#include <gdk/gdkkeysyms.h>
+#include <gtkmm/accelgroup.h>
+#include <gtkmm/buttonbox.h>
+#include <gtkmm/label.h>
+#include <gtkmm/box.h>
+#include <gtkmm/adjustment.h>
+#include <gtkmm/table.h>
+
+indexDialog_glade::indexDialog_glade(
+)
+{  
+   
+   Gtk::Dialog *indexDialog = this;
+   gmm_data = new GlademmData(get_accel_group());
+   indexCancelbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
+   indexOkbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
+   
+   Gtk::Label *nameLabel = Gtk::manage(new class Gtk::Label(_("Name:")));
+   locationEntry = Gtk::manage(new class Gtk::Entry());
+   locationButton = Gtk::manage(new class Gtk::Button(_("...")));
+   
+   Gtk::HBox *locationHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   Gtk::Label *typeLabel = Gtk::manage(new class Gtk::Label(_("Type:")));
+   Gtk::Label *locationLabel = Gtk::manage(new class Gtk::Label(_("Location:")));
+   Gtk::Label *portLabel = Gtk::manage(new class Gtk::Label(_("Port:")));
+   nameEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Adjustment *portSpinbutton_adj = Gtk::manage(new class Gtk::Adjustment(1024, 0, 65535, 1, 10, 10));
+   portSpinbutton = Gtk::manage(new class Gtk::SpinButton(*portSpinbutton_adj, 1, 0));
+   typeCombobox = Gtk::manage(new class Gtk::ComboBox());
+   
+   Gtk::Table *indexTable = Gtk::manage(new class Gtk::Table(2, 2, false));
+   indexCancelbutton->set_flags(Gtk::CAN_FOCUS);
+   indexCancelbutton->set_flags(Gtk::CAN_DEFAULT);
+   indexCancelbutton->set_relief(Gtk::RELIEF_NORMAL);
+   indexOkbutton->set_flags(Gtk::CAN_FOCUS);
+   indexOkbutton->set_flags(Gtk::CAN_DEFAULT);
+   indexOkbutton->set_relief(Gtk::RELIEF_NORMAL);
+   indexDialog->get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
+   nameLabel->set_alignment(0,0.5);
+   nameLabel->set_padding(4,4);
+   nameLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   nameLabel->set_line_wrap(false);
+   nameLabel->set_use_markup(false);
+   nameLabel->set_selectable(false);
+   locationEntry->set_flags(Gtk::CAN_FOCUS);
+   locationEntry->set_visibility(true);
+   locationEntry->set_editable(true);
+   locationEntry->set_max_length(0);
+   locationEntry->set_text(_(""));
+   locationEntry->set_has_frame(true);
+   locationEntry->set_activates_default(false);
+   locationButton->set_flags(Gtk::CAN_FOCUS);
+   locationButton->set_flags(Gtk::CAN_DEFAULT);
+   locationButton->set_relief(Gtk::RELIEF_NORMAL);
+   locationHbox->pack_start(*locationEntry);
+   locationHbox->pack_start(*locationButton, Gtk::PACK_SHRINK, 4);
+   typeLabel->set_alignment(0,0.5);
+   typeLabel->set_padding(4,4);
+   typeLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   typeLabel->set_line_wrap(false);
+   typeLabel->set_use_markup(false);
+   typeLabel->set_selectable(false);
+   locationLabel->set_alignment(0,0.5);
+   locationLabel->set_padding(4,4);
+   locationLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   locationLabel->set_line_wrap(false);
+   locationLabel->set_use_markup(false);
+   locationLabel->set_selectable(false);
+   portLabel->set_alignment(0,0.5);
+   portLabel->set_padding(4,4);
+   portLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   portLabel->set_line_wrap(false);
+   portLabel->set_use_markup(false);
+   portLabel->set_selectable(false);
+   nameEntry->set_flags(Gtk::CAN_FOCUS);
+   nameEntry->set_visibility(true);
+   nameEntry->set_editable(true);
+   nameEntry->set_max_length(0);
+   nameEntry->set_text(_(""));
+   nameEntry->set_has_frame(true);
+   nameEntry->set_activates_default(false);
+   portSpinbutton->set_flags(Gtk::CAN_FOCUS);
+   portSpinbutton->set_update_policy(Gtk::UPDATE_ALWAYS);
+   portSpinbutton->set_numeric(false);
+   portSpinbutton->set_digits(0);
+   portSpinbutton->set_wrap(false);
+   indexTable->set_row_spacings(0);
+   indexTable->set_col_spacings(0);
+   indexTable->attach(*nameLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   indexTable->attach(*locationHbox, 1, 2, 2, 3, Gtk::FILL, Gtk::FILL, 4, 4);
+   indexTable->attach(*typeLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   indexTable->attach(*locationLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
+   indexTable->attach(*portLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   indexTable->attach(*nameEntry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::AttachOptions(), 4, 4);
+   indexTable->attach(*portSpinbutton, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::AttachOptions(), 4, 4);
+   indexTable->attach(*typeCombobox, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::AttachOptions(), 4, 4);
+   indexDialog->get_vbox()->set_homogeneous(false);
+   indexDialog->get_vbox()->set_spacing(0);
+   indexDialog->get_vbox()->pack_start(*indexTable);
+   indexDialog->set_title(_("External index"));
+   indexDialog->set_modal(false);
+   indexDialog->property_window_position().set_value(Gtk::WIN_POS_NONE);
+   indexDialog->set_resizable(true);
+   indexDialog->property_destroy_with_parent().set_value(false);
+   indexDialog->set_has_separator(true);
+   indexDialog->add_action_widget(*indexCancelbutton, -6);
+   indexDialog->add_action_widget(*indexOkbutton, -5);
+   indexCancelbutton->show();
+   indexOkbutton->show();
+   nameLabel->show();
+   locationEntry->show();
+   locationButton->show();
+   locationHbox->show();
+   typeLabel->show();
+   locationLabel->show();
+   portLabel->show();
+   nameEntry->show();
+   portSpinbutton->show();
+   typeCombobox->show();
+   indexTable->show();
+   indexDialog->show();
+   indexOkbutton->signal_clicked().connect(SigC::slot(*this, &indexDialog_glade::on_indexOkbutton_clicked), false);
+   locationEntry->signal_changed().connect(SigC::slot(*this, &indexDialog_glade::on_locationEntry_changed), false);
+   locationButton->signal_clicked().connect(SigC::slot(*this, &indexDialog_glade::on_locationButton_clicked), false);
+   nameEntry->signal_changed().connect(SigC::slot(*this, &indexDialog_glade::on_nameEntry_changed), false);
+   typeCombobox->signal_changed().connect(SigC::slot(*this, &indexDialog_glade::on_typeCombobox_changed), false);
+}
+
+indexDialog_glade::~indexDialog_glade()
+{  delete gmm_data;
+}

Added: trunk/UI/GTK2/src/indexDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/indexDialog_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/indexDialog_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,63 @@
+// generated 2005/4/17 5:19:13 BST by fabrice at thorgrim.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.4.0 and gtkmm 2.4.8
+//
+// Please modify the corresponding derived classes in ./src/indexDialog.hh and./src/indexDialog.cc
+
+#ifndef _INDEXDIALOG_GLADE_HH
+#  define _INDEXDIALOG_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include <gtkmm/accelgroup.h>
+
+class GlademmData
+{  
+        
+        Glib::RefPtr<Gtk::AccelGroup> accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr<Gtk::AccelGroup> ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr<Gtk::AccelGroup>  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include <gtkmm/dialog.h>
+#include <gtkmm/button.h>
+#include <gtkmm/entry.h>
+#include <gtkmm/spinbutton.h>
+#include <gtkmm/combobox.h>
+
+class indexDialog_glade : public Gtk::Dialog
+{  
+        
+        GlademmData *gmm_data;
+protected:
+        class Gtk::Button * indexCancelbutton;
+        class Gtk::Button * indexOkbutton;
+        class Gtk::Entry * locationEntry;
+        class Gtk::Button * locationButton;
+        class Gtk::Entry * nameEntry;
+        class Gtk::SpinButton * portSpinbutton;
+        class Gtk::ComboBox * typeCombobox;
+        
+        indexDialog_glade();
+        
+        ~indexDialog_glade();
+private:
+        virtual void on_indexOkbutton_clicked() = 0;
+        virtual void on_locationEntry_changed() = 0;
+        virtual void on_locationButton_clicked() = 0;
+        virtual void on_nameEntry_changed() = 0;
+        virtual void on_typeCombobox_changed() = 0;
+};
+#endif

Added: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,2916 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdlib.h>
+#include <errno.h>
+#include <time.h>
+#include <string>
+#include <iostream>
+#include <fstream>
+#include <sigc++/class_slot.h>
+#include <glibmm/ustring.h>
+#include <glibmm/stringutils.h>
+#include <glibmm/convert.h>
+#include <glibmm/thread.h>
+#include <gtkmm/stock.h>
+#include <gtkmm/messagedialog.h>
+#include <gtkmm/scrolledwindow.h>
+#include <gtkmm/clipboard.h>
+#include <gtkmm/main.h>
+
+#include "HtmlTokenizer.h"
+#include "IndexedDocument.h"
+#include "TimeConverter.h"
+#include "Url.h"
+#include "ActionHistory.h"
+#include "LabelManager.h"
+#include "QueryHistory.h"
+#include "ViewHistory.h"
+#include "DownloaderFactory.h"
+#include "XapianIndex.h"
+#include "SearchEngineFactory.h"
+#include "XapianEngine.h"
+#include "config.h"
+#include "NLS.h"
+#include "PinotUtils.h"
+#include "mainWindow.hh"
+#include "aboutDialog.hh"
+#include "importDialog.hh"
+#include "indexDialog.hh"
+#include "propertiesDialog.hh"
+#include "prefsDialog.hh"
+#include "queryDialog.hh"
+
+using namespace std;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+// A function object to delete pointers from a set with for_each()
+struct DeleteSetPointer
+{
+	template<typename T>
+	void operator()(const T *ptr) const
+	{
+		delete ptr;
+	}
+};
+
+// FIXME: this ought to be configurable
+unsigned int mainWindow::m_maxDocsCount = 100;
+unsigned int mainWindow::m_maxThreads = 2;
+
+mainWindow::InternalState::InternalState() :
+	m_currentLabelPos(0),
+	m_currentLabelName(_("None")),
+	m_currentIndexName(_("My Documents")),
+	m_indexDocsCount(0),
+	m_startDoc(0),
+	m_backgroundThreads(0),
+	m_browsingIndex(false)
+{
+	pthread_rwlock_init(&m_rwLock, NULL);
+}
+
+mainWindow::InternalState::~InternalState()
+{
+	// Destroy the read/write lock
+	pthread_rwlock_destroy(&m_rwLock);
+}
+
+bool mainWindow::InternalState::readLock(unsigned int where)
+{
+	if (pthread_rwlock_rdlock(&m_rwLock) == 0)
+	{
+#ifdef DEBUG
+		cout << "mainWindow::InternalState::readLock " << where << endl;
+#endif
+		return true;
+	}
+
+	return false;
+}
+
+bool mainWindow::InternalState::writeLock(unsigned int where)
+{
+	if (pthread_rwlock_wrlock(&m_rwLock) == 0)
+	{
+#ifdef DEBUG
+		cout << "mainWindow::InternalState::writeLock " << where << endl;
+#endif
+		return true;
+	}
+
+	return false;
+}
+
+void mainWindow::InternalState::unlock(void)
+{
+#ifdef DEBUG
+	cout << "mainWindow::InternalState::unlock" << endl;
+#endif
+	pthread_rwlock_unlock(&m_rwLock);
+}
+
+unsigned int mainWindow::InternalState::getCurrentLabel(string &labelName)
+{
+	if (readLock(1) == true)
+	{
+		unsigned int labelPos = m_currentLabelPos;
+		labelName = m_currentLabelName;
+		unlock();
+
+		return labelPos;
+	}
+	
+	return 0;
+}
+
+void mainWindow::InternalState::setCurrentLabel(unsigned int labelPos, const string &labelName)
+{
+	if (writeLock(1) == true)
+	{
+		m_currentLabelPos = labelPos;
+		m_currentLabelName = labelName;
+		unlock();
+	}
+}
+
+Glib::ustring mainWindow::InternalState::getCurrentIndex(void)
+{
+	ustring indexName;
+
+	if (readLock(2) == true)
+	{
+		indexName = m_currentIndexName;
+		unlock();
+	}
+
+	return indexName;
+}
+
+void mainWindow::InternalState::setCurrentIndex(const Glib::ustring &indexName)
+{
+	if (writeLock(2) == true)
+	{
+		m_currentIndexName = indexName;
+		unlock();
+	}
+}
+
+//
+// Constructor
+//
+mainWindow::mainWindow() :
+	m_settings(PinotSettings::getInstance()), mainWindow_glade(),
+	m_pEnginesTree(NULL),
+	m_pResultsTree(NULL),
+	m_pIndexTree(NULL),
+	m_pLabelsMenu(NULL)
+{
+	// Reposition and resize the window
+	// Make sure the coordinates and sizes make sense
+	if ((m_settings.m_xPos >= 0) &&
+		(m_settings.m_yPos >= 0))
+	{
+		move(m_settings.m_xPos, m_settings.m_yPos);
+	}
+	if ((m_settings.m_width > 0) &&
+		(m_settings.m_height > 0))
+	{
+		resize(m_settings.m_width, m_settings.m_height);
+	}
+	if (m_settings.m_panePos >= 0)
+	{
+		mainHpaned->set_position(m_settings.m_panePos);
+	}
+
+	// Position the engine tree
+	m_pEnginesTree = manage(new EnginesTree(enginesVbox, m_settings));
+	// Connect to the "changed" signal
+	m_pEnginesTree->get_selection()->signal_changed().connect(SigC::slot(*this,
+		&mainWindow::on_enginesTreeviewSelection_changed));
+	// Connect to the edit index signal
+	m_pEnginesTree->getEditIndexSignal().connect(SigC::slot(*this,
+		&mainWindow::on_editindex));
+
+	// Set an icon for this and other windows
+	set_icon_from_file("/usr/share/icons/hicolor/48x48/apps/pinot.png");
+	set_default_icon_from_file("/usr/share/icons/hicolor/48x48/apps/pinot.png");
+
+	// Associate the columns model to the query tree
+	m_refQueryTree = ListStore::create(m_queryColumns);
+	queryTreeview->set_model(m_refQueryTree);
+	TreeViewColumn *treeColumn = create_resizable_column(_("Query Name"), m_queryColumns.m_name);
+	if (treeColumn != NULL)
+	{
+		queryTreeview->append_column(*manage(treeColumn));
+	}
+	queryTreeview->append_column(_("Last Run"), m_queryColumns.m_lastRun);
+	queryTreeview->append_column(_("Summary"), m_queryColumns.m_summary);
+	// Allow only single selection
+	queryTreeview->get_selection()->set_mode(SELECTION_SINGLE);
+	// Connect to the "changed" signal
+	queryTreeview->get_selection()->signal_changed().connect(SigC::slot(*this, 
+		&mainWindow::on_queryTreeviewSelection_changed));
+	// Populate
+	populate_queryTreeview();
+
+	// Position the results tree
+	m_pResultsTree = manage(new ResultsTree(resultsVbox, resultsMenuitem->get_submenu(), m_settings));
+	// Connect to the "changed" signal
+	m_pResultsTree->get_selection()->signal_changed().connect(SigC::slot(*this,
+		&mainWindow::on_resultsTreeviewSelection_changed));
+
+	// Position the index tree
+	m_pIndexTree = manage(new IndexTree(indexVbox, indexMenuitem->get_submenu(), m_settings));
+	// Connect to the "changed" signal
+	m_pIndexTree->get_selection()->signal_changed().connect(SigC::slot(*this,
+		&mainWindow::on_indexTreeviewSelection_changed));
+	// Connect to the edit document signal
+	m_pIndexTree->getEditDocumentSignal().connect(SigC::slot(*this,
+		&mainWindow::on_showfromindex_activate));
+
+	// Associate the columns model to the index combo
+	m_refIndexNameTree = ListStore::create(m_indexNameColumns);
+	indexCombobox->set_model(m_refIndexNameTree);
+	indexCombobox->pack_start(m_indexNameColumns.m_name);
+	// Populate the index combo
+	populate_indexCombobox();
+
+	// Populate the label menu
+	populate_labelMenu();
+
+	// Add an HTML renderer in the View tab
+	m_pHtmlView = new HtmlView(viewVbox, NULL);
+	if (m_settings.m_browseResults == true)
+	{
+		// Hide this tab
+		Widget *pPage = mainNotebook->get_nth_page(2);
+		if (pPage != NULL)
+		{
+			pPage->hide();
+		}
+	}
+	else
+	{
+		view_document("file:///usr/share/pinot/index.html", true);
+	}
+
+	// Gray out menu items
+	editQueryButton->set_sensitive(false);
+	removeQueryButton->set_sensitive(false);
+	findQueryButton->set_sensitive(false);
+	clearresults1->set_sensitive(false);
+	viewresults1->set_sensitive(false);
+	// Hide the View Cache menu item ?
+	if (SearchEngineFactory::isSupported("googleapi") == false)
+	{
+		viewcache1->hide();
+	}
+	else
+	{
+		viewcache1->set_sensitive(false);
+	}
+	indexresults1->set_sensitive(false);
+	showlabels1->set_sensitive(false);
+	viewfromindex1->set_sensitive(false);
+	refreshindex1->set_sensitive(false);
+	showfromindex1->set_sensitive(false);
+	unindex1->set_sensitive(false);
+	//viewstop1->set_sensitive(false);
+	// ...and buttons
+	removeIndexButton->set_sensitive(false);
+	indexFirstButton->set_sensitive(false);
+	indexBackButton->set_sensitive(false);
+	indexForwardButton->set_sensitive(false);
+	indexLastButton->set_sensitive(false);
+
+	// Set focus on the query entry field
+	set_focus(*liveQueryEntry);
+
+	// Set tooltips
+	m_tooltips.set_tip(*addIndexButton, _("Add index"));
+	m_tooltips.set_tip(*removeIndexButton, _("Remove index"));
+
+	// FIXME: delete all "ignored" threads when exiting !!!
+	// Fire up a listener thread
+	ListenerThread *pListenThread = new ListenerThread(PinotSettings::getConfigurationDirectory() + string("/fifo"));
+	// Connect to its reception signal
+	pListenThread->getReceptionSignal().connect(SigC::slot(*this,
+		&mainWindow::on_message_reception));
+	start_thread(pListenThread, true);
+
+	// Fire up the mail monitor thread
+	MboxHandler *pMbox = new MboxHandler();
+	// Connect to its update signal
+	pMbox->getUpdateSignal().connect(SigC::slot(*this,
+		&mainWindow::on_message_indexupdate));
+	MonitorThread *pMonitorThread = new MonitorThread(pMbox);
+	start_thread(pMonitorThread, true);
+	// The handler object will be deleted when the thread terminates
+
+	// List the documents index
+	browse_index();
+	// There might be queued actions
+	check_queue();
+
+	// Now we are ready
+	set_status(_("Ready"));
+	show();
+}
+
+//
+// Destructor
+//
+mainWindow::~mainWindow()
+{
+	// Save queries
+	save_queryTreeview();
+
+	if (m_state.m_pThreads.empty() == false)
+	{
+		for_each(m_state.m_pThreads.begin(), m_state.m_pThreads.end(), DeleteSetPointer());
+	}
+
+	// This is a hack to avoid segfaults when the View tab hasn't been made visible
+	Widget *pPage = mainNotebook->get_nth_page(2);
+	if (pPage != NULL)
+	{
+		pPage->show();
+	}
+	mainNotebook->set_current_page(2);
+	// Stop if we were loading a page
+	m_pHtmlView->stop();
+	delete m_pHtmlView;
+}
+
+//
+// Load user-defined queries
+//
+void mainWindow::populate_queryTreeview()
+{
+	QueryHistory history(m_settings.m_historyDatabase);
+	const std::map<string, QueryProperties> &queries = m_settings.getQueries();
+
+	// Reset the whole tree
+	queryTreeview->get_selection()->unselect_all();
+	m_refQueryTree->clear();
+
+	// Add all user-defined queries
+	std::map<string, QueryProperties>::const_iterator queryIter = queries.begin();
+	for (; queryIter != queries.end(); ++queryIter)
+	{
+		TreeModel::iterator iter = m_refQueryTree->append();
+		TreeModel::Row row = *iter;
+		string queryName = queryIter->first;
+
+		row[m_queryColumns.m_name] = to_utf8(queryName);
+		string lastRun = history.getLastRun(queryName);
+		if (lastRun.empty() == true)
+		{
+			lastRun = _("N/A");
+		}
+		row[m_queryColumns.m_lastRun] = lastRun;
+		string summary = queryIter->second.toString();
+		if (summary.empty() == false)
+		{
+			row[m_queryColumns.m_summary] = to_utf8(summary);
+		}
+		else
+		{
+			row[m_queryColumns.m_summary] = _("<undefined>");
+		}
+		row[m_queryColumns.m_properties] = queryIter->second;
+	}
+}
+
+//
+// Store defined queries into the settings object
+//
+void mainWindow::save_queryTreeview()
+{
+	// Clear the current queries
+	m_settings.clearQueries();
+
+	// Go through the query tree
+	TreeModel::Children children = m_refQueryTree->children();
+	if (children.empty() == false)
+	{
+		for (TreeModel::Children::iterator iter = children.begin();
+			iter != children.end(); ++iter)
+		{
+			TreeModel::Row row = *iter;
+
+			// Add this query to the settings
+			string name = locale_from_utf8(row[m_queryColumns.m_name]);
+			QueryProperties queryProps = row[m_queryColumns.m_properties];
+#ifdef DEBUG
+			cout << "mainWindow::save_queryTreeview: " << name << endl;
+#endif
+			m_settings.addQuery(queryProps);
+		}
+	}
+}
+
+//
+// Populate the indexes list
+//
+void mainWindow::populate_indexCombobox()
+{
+	TreeModel::iterator iter;
+	TreeModel::Row row;
+
+	const std::map<string, string> &indexes = m_settings.getIndexes();
+#ifdef DEBUG
+	cout << "mainWindow::populate_indexCombobox: " << indexes.size() << " indexes" << endl;
+#endif
+	m_refIndexNameTree->clear();
+	std::map<string, string>::const_iterator indexIter = indexes.begin();
+	for (; indexIter != indexes.end(); ++indexIter)
+	{
+		string indexName = indexIter->first;
+
+		if (m_settings.isInternalIndex(indexName) == true)
+		{
+			// Add this index
+			iter = m_refIndexNameTree->append();
+			row = *iter;
+			row[m_indexNameColumns.m_name] = to_utf8(indexName);
+#ifdef DEBUG
+			cout << "mainWindow::populate_indexCombobox: added " << indexName << endl;
+#endif
+		}
+	}
+
+	indexCombobox->set_active(0);
+}
+
+//
+// Populate the labels menu
+//
+void mainWindow::populate_labelMenu()
+{
+	RadioMenuItem::Group labelsGroup;
+	RadioMenuItem *firstLabelMenuItem = NULL;
+	RadioMenuItem *labelMenuItem = NULL;
+
+#ifdef DEBUG
+	cout << "mainWindow::populate_labels_menu: called" << endl;
+#endif
+	if (m_pLabelsMenu == NULL)
+	{
+		m_pLabelsMenu = new Menu();
+		showlabels1->set_submenu(*m_pLabelsMenu);
+	}
+	else
+	{
+		// Clear the submenu
+		m_pLabelsMenu->items().clear();
+	}
+
+	SigC::Slot1<void, unsigned int> labelsSlot = SigC::slot(*this, &mainWindow::on_labelMenu_changed);
+	unsigned int count = 1;
+                                                                                                                                                             
+	// Initialize the submenu
+	m_pLabelsMenu->items().push_back(Menu_Helpers::RadioMenuElem(labelsGroup, _("None")));
+	firstLabelMenuItem = labelMenuItem = (RadioMenuItem*)&m_pLabelsMenu->items().back();
+	// Bind the callback's parameter to the menuitem's position in the submenu
+	SigC::Slot0<void> labelsSlot0 = sigc::bind(labelsSlot, 0);
+	labelMenuItem->signal_activate().connect(labelsSlot0);
+	for (set<PinotSettings::Label>::const_iterator iter = m_settings.m_labels.begin();
+		iter != m_settings.m_labels.end(); ++iter)
+	{
+		m_pLabelsMenu->items().push_back(Menu_Helpers::RadioMenuElem(labelsGroup, iter->m_name));
+		labelMenuItem = (RadioMenuItem*)&m_pLabelsMenu->items().back();
+		SigC::Slot0<void> labelsSlot0 = sigc::bind(labelsSlot, count);
+		labelMenuItem->signal_activate().connect(labelsSlot0);
+		++count;
+	}
+
+	// Activate the first menuitem
+	firstLabelMenuItem->set_active(true);
+}
+
+//
+// Query list selection changed
+//
+void mainWindow::on_queryTreeviewSelection_changed()
+{
+	TreeModel::iterator iter = queryTreeview->get_selection()->get_selected();
+	// Anything selected ?
+	if (iter)
+	{
+		// Enable those
+		editQueryButton->set_sensitive(true);
+		removeQueryButton->set_sensitive(true);
+		findQueryButton->set_sensitive(true);
+	}
+	else
+	{
+		// Disable those
+		editQueryButton->set_sensitive(false);
+		removeQueryButton->set_sensitive(false);
+		findQueryButton->set_sensitive(false);
+	}
+}
+
+//
+// Engines tree selection changed
+//
+void mainWindow::on_enginesTreeviewSelection_changed()
+{
+	list<TreeModel::Path> selectedEngines = m_pEnginesTree->getSelection();
+	// If there are more than one row selected, don't bother
+	if (selectedEngines.size() != 1)
+	{
+		return;
+	}
+
+	list<TreeModel::Path>::iterator enginePath = selectedEngines.begin();
+	if (enginePath == selectedEngines.end())
+	{
+		return;
+	}
+
+	TreeModel::iterator engineIter = m_pEnginesTree->getIter(*enginePath);
+	TreeModel::Row engineRow = *engineIter;
+	bool enableRemoveIndex = false;
+
+	// Make sure it's a leaf node
+	if (engineIter->children().empty() == true)
+	{
+		TreeModel::Row engineRow = *engineIter;
+
+		// Is it an external index ?
+		EnginesModelColumns &enginesColumns = m_pEnginesTree->getColumnRecord();
+		EnginesModelColumns::EngineType engineType = engineRow[enginesColumns.m_type];
+		if (engineType == EnginesModelColumns::INDEX_ENGINE)
+		{
+			// Yes, enable the remove index button
+			enableRemoveIndex = true;
+		}
+	}
+	removeIndexButton->set_sensitive(enableRemoveIndex);
+}
+
+//
+// Results tree selection changed
+//
+void mainWindow::on_resultsTreeviewSelection_changed()
+{
+	if (m_pResultsTree->onSelectionChanged() == true)
+	{
+		ustring url = m_pResultsTree->getFirstSelectionURL();
+		bool isViewable = true, isIndexable = true, isCached = false;
+
+		Url urlObj(locale_from_utf8(url));
+		string protocol = urlObj.getProtocol();
+		// FIXME: there should be a way to know which protocols can be viewed/indexed
+		if (protocol == "xapian")
+		{
+			isViewable = isIndexable = false;
+		}
+
+		// Enable these menu items
+		viewresults1->set_sensitive(isViewable);
+		if (m_settings.m_browseResults == false)
+		{
+			if ((protocol == "http") ||
+				(protocol == "https"))
+			{
+				isCached = true;
+			}
+		}
+		viewcache1->set_sensitive(isCached);
+		indexresults1->set_sensitive(isIndexable);
+
+		// Show the URL in the status bar
+		ustring statusText = _("Result location is");
+		statusText += " ";
+		statusText += url;
+		set_status(statusText, true);
+	}
+	else
+	{
+		// Disable these menu items
+		viewresults1->set_sensitive(false);
+		viewcache1->set_sensitive(false);
+		indexresults1->set_sensitive(false);
+
+		// Reset
+		set_status("");
+	}
+}
+
+//
+// Index tree selection changed
+//
+void mainWindow::on_indexTreeviewSelection_changed()
+{
+	if (m_pIndexTree->onSelectionChanged() == true)
+	{
+		bool isDocumentsIndex = true;
+		bool canViewDocument = true;
+
+		// Enable these menu items, unless the index is not the documents index
+		ustring currentIndexName = m_state.getCurrentIndex();
+		if (currentIndexName != _("My Documents"))
+		{
+			isDocumentsIndex = false;
+		}
+		if ((currentIndexName == _("My Email")) &&
+			(m_settings.m_browseResults == true))
+		{
+			canViewDocument = false;
+		}
+		viewfromindex1->set_sensitive(canViewDocument);
+		refreshindex1->set_sensitive(isDocumentsIndex);
+		showfromindex1->set_sensitive(true);
+		unindex1->set_sensitive(isDocumentsIndex);
+
+		// Show the URL in the status bar
+		ustring statusText = _("Document location is");
+		statusText += " ";
+		statusText += m_pIndexTree->getFirstSelectionURL();
+		set_status(statusText, true);
+	}
+	else
+	{
+		// No, disable these
+		viewfromindex1->set_sensitive(false);
+		refreshindex1->set_sensitive(false);
+		showfromindex1->set_sensitive(false);
+		unindex1->set_sensitive(false);
+	}
+}
+
+//
+// Index > Show Labels menu selected
+//
+void mainWindow::on_labelMenu_changed(unsigned int pos)
+{
+	string currentLabelName;
+	unsigned int currentLabelPos;
+
+	// Since we listen for signal_activate(), this handler gets called when the
+	// current item is unselected and when the new one is selected
+	currentLabelPos = m_state.getCurrentLabel(currentLabelName);
+	if (currentLabelPos == pos)
+	{
+		// Ignore unselections
+		return;
+	}
+#ifdef DEBUG
+	cout << "mainWindow::on_labelMenu_changed: called on " << pos << endl;
+#endif
+	currentLabelPos = pos;
+	if (currentLabelPos == 0)
+	{
+		// User selected no label
+		currentLabelName = _("None");
+		m_state.setCurrentLabel(currentLabelPos, currentLabelName);
+		m_pIndexTree->setCurrentLabelColour(0, 0, 0, false);
+		set_status(_("No labels"));
+		return;
+	}
+
+	// Get the actual label from the settings object
+	unsigned int labelNum = 1;
+	for (set<PinotSettings::Label>::iterator labelIter = m_settings.m_labels.begin();
+		labelIter != m_settings.m_labels.end(); ++labelIter)
+	{
+		if (labelNum == pos)
+		{
+			// That's the one
+			currentLabelName = locale_from_utf8(labelIter->m_name);
+			m_state.setCurrentLabel(currentLabelPos, currentLabelName);
+#ifdef DEBUG
+			cout << "mainWindow::on_labelMenu_changed: label is " << currentLabelName << endl;
+#endif
+			// Switch temporarily to no label
+			m_pIndexTree->setCurrentLabelColour(0, 0, 0, false);
+
+			// Get the documents that match this label
+			start_thread(new LabelQueryThread(m_state.getCurrentIndex(), currentLabelName));
+			break;
+		}
+		++labelNum;
+	}
+}
+
+//
+// End of worker thread
+//
+void mainWindow::on_thread_end()
+{
+	WorkerThread *pThread = NULL;
+	ustring status;
+
+	// Get the first thread that's finished
+	if (m_state.readLock(3) == true)
+	{
+		for (set<WorkerThread *>::iterator threadIter = m_state.m_pThreads.begin();
+			threadIter != m_state.m_pThreads.end(); ++threadIter)
+		{
+#ifdef DEBUG
+			cout << "mainWindow::on_thread_end: looking for thread" << endl;
+#endif
+			if ((*threadIter)->isDone() == true)
+			{
+				// This one will do...
+				pThread = (*threadIter);
+				// Remove it
+				m_state.m_pThreads.erase(threadIter);
+				break;
+			}
+		}
+
+		m_state.unlock();
+	}
+	if (pThread == NULL)
+	{
+#ifdef DEBUG
+		cout << "mainWindow::on_thread_end: signalled but couldn't find any thread" << endl;
+#endif
+		return;
+	}
+#ifdef DEBUG
+	cout << "mainWindow::on_thread_end: end of thread " << pThread->getId() << endl;
+#endif
+	update_threads_status();
+
+	// What type of thread was it ?
+	string type = pThread->getType();
+	if (pThread->isBackground() == true)
+	{
+		m_state.m_backgroundThreads--;
+	}
+	// Did the thread fail for some reason ?
+	string threadStatus = pThread->getStatus();
+	if (threadStatus.empty() == false)
+	{
+		// Yep, it did
+		set_status(to_utf8(threadStatus));
+		// Better reset that flag if an error occured while browsing an index
+		if (type == "IndexBrowserThread")
+		{
+			m_state.m_browsingIndex = false;
+		}
+	}
+	// Based on type, take the appropriate action...
+	else if (type == "IndexBrowserThread")
+	{
+		char docsCountStr[64];
+		unsigned int count = 0;
+		bool enableIndexOps = false;
+
+		IndexBrowserThread *pBrowseThread = dynamic_cast<IndexBrowserThread *>(pThread);
+		if (pBrowseThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		m_state.m_indexDocsCount = pBrowseThread->getDocumentsCount();
+		count = m_pIndexTree->getRowsCount();
+
+		status = _("Showing");
+		status += " ";
+		snprintf(docsCountStr, 64, "%u", count);
+		status += docsCountStr;
+		status += " ";
+		status += _("off");
+		status += " ";
+		snprintf(docsCountStr, 64, "%u", m_state.m_indexDocsCount);
+		status += docsCountStr;
+		status += " ";
+		status += _("documents from");
+		status += " ";
+		status += m_state.getCurrentIndex();
+		set_status(status);
+
+		if (m_state.m_indexDocsCount > 0)
+		{
+			// Switch to the index page
+			mainNotebook->set_current_page(1);
+			// FIXME: not sure why, but this helps with refreshing the tree
+			m_pIndexTree->columns_autosize();
+			enableIndexOps = true;
+		}
+		showlabels1->set_sensitive(enableIndexOps);
+#ifdef DEBUG
+		cout << "mainWindow::on_thread_end: " << m_state.m_indexDocsCount
+			<< " documents, starting at " << m_state.m_startDoc << endl;
+#endif
+		if (m_state.m_startDoc > 0)
+		{
+			indexFirstButton->set_sensitive(true);
+		}
+		else
+		{
+			indexFirstButton->set_sensitive(false);
+		}
+		if (m_state.m_startDoc >= m_maxDocsCount)
+		{
+			indexBackButton->set_sensitive(true);
+		}
+		else
+		{
+			indexBackButton->set_sensitive(false);
+		}
+		if (m_state.m_indexDocsCount >= m_state.m_startDoc + m_maxDocsCount)
+		{
+			indexForwardButton->set_sensitive(true);
+		}
+		else
+		{
+			indexForwardButton->set_sensitive(false);
+		}
+		if (m_state.m_indexDocsCount > m_state.m_startDoc + count)
+		{
+			indexLastButton->set_sensitive(true);
+		}
+		else
+		{
+			indexLastButton->set_sensitive(false);
+		}
+		m_state.m_browsingIndex = false;
+	}
+	else if (type == "QueryingThread")
+	{
+		std::map<string, TreeModel::iterator> updatedGroups;
+		unsigned int count = 0;
+		ResultsModelColumns::ResultType rootType;
+		bool mergeDuplicates = false;
+
+		QueryingThread *pQueryThread = dynamic_cast<QueryingThread *>(pThread);
+		if (pQueryThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		QueryProperties queryProps = pQueryThread->getQuery();
+		string queryName = queryProps.getName();
+		string engineName = pQueryThread->getEngineName();
+
+		status = _("Query");
+		status += " ";
+		status += to_utf8(queryName);
+		status += " ";
+		status += _("on");
+		status += " ";
+		status += to_utf8(engineName);
+		status += " ";
+		status += _("ended");
+		set_status(status);
+
+		// Switch to the results page
+		mainNotebook->set_current_page(0);
+
+		// Add these results to the tree
+		const vector<Result> &resultsList = pQueryThread->getResults();
+		if (m_pResultsTree->addResults(queryProps, engineName,
+			resultsList, searchenginegroup1->get_active()) == true)
+		{
+#ifdef DEBUG
+			cout << "mainWindow::on_thread_end: added results" << endl;
+#endif
+			// Enable results clearing
+			clearresults1->set_sensitive(true);
+
+			// Index results ?
+			if ((queryProps.getIndexResults() == true) &&
+				(resultsList.empty() == false))
+			{
+				string labelName = queryProps.getLabelName();
+
+#ifdef DEBUG
+				cout << "mainWindow::on_thread_end: indexing results, with label " << labelName << endl;
+#endif
+				for (vector<Result>::const_iterator resultIter = resultsList.begin();
+					resultIter != resultsList.end(); ++resultIter)
+				{
+					// Queue this action
+					queue_index(DocumentInfo(resultIter->getTitle(), resultIter->getLocation(),
+						resultIter->getType(), resultIter->getLanguage()),
+						labelName);
+				}
+			}
+		}
+	}
+	else if (type == "LabelQueryThread")
+	{
+		string currentLabelName;
+		unsigned int currentLabelPos = 0;
+
+		LabelQueryThread *pLabelQueryThread = dynamic_cast<LabelQueryThread *>(pThread);
+		if (pLabelQueryThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		// Don't bother if the index is not being listed, or if the user
+		// changed the label in the meantime
+		currentLabelPos = m_state.getCurrentLabel(currentLabelName);
+		if ((m_pIndexTree->isEmpty() == false) &&
+			(currentLabelPos > 0) &&
+			(currentLabelName == pLabelQueryThread->getLabelName()))
+		{
+			const set<unsigned int> &documentsList = pLabelQueryThread->getDocumentsList();
+			char docsCountStr[64];
+			unsigned int docsCount = documentsList.size();
+			unsigned int labelNum = 1;
+
+			status = _("Label");
+			status += " ";
+			status += to_utf8(pLabelQueryThread->getLabelName());
+			status += " ";
+			status += _("matches");
+			status += " ";
+			snprintf(docsCountStr, 64, "%u", docsCount);
+			status += docsCountStr;
+			status += " ";
+			status += _("document(s)");
+			set_status(status);
+
+#ifdef DEBUG
+			cout << "mainWindow::on_thread_end: current label is " << currentLabelName << endl;
+#endif
+			// Get the actual label colour from the settings
+			for (set<PinotSettings::Label>::iterator labelIter = m_settings.m_labels.begin();
+				labelIter != m_settings.m_labels.end(); ++labelIter)
+			{
+#ifdef DEBUG
+				cout << "mainWindow::on_thread_end: looking at label "
+					<< labelIter->m_name << ", position " << labelNum << endl;
+#endif
+				if (labelNum == currentLabelPos)
+				{
+					// Display the selected label's colour in the index tree
+					m_pIndexTree->setCurrentLabelColour(labelIter->m_red, labelIter->m_green, labelIter->m_blue);
+					m_pIndexTree->setLabel(documentsList);
+
+					// Switch to the index page
+					mainNotebook->set_current_page(1);
+					break;
+				}
+				++labelNum;
+			}
+		}
+	}
+	else if (type == "DownloadingThread")
+	{
+		DownloadingThread *pDownloadThread = dynamic_cast<DownloadingThread *>(pThread);
+		if (pDownloadThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		string url = pDownloadThread->getURL();
+		const Document *pDoc = pDownloadThread->getDocument();
+		if (pDoc != NULL)
+		{
+			unsigned int dataLength = 0;
+
+			const char *pData = pDoc->getData(dataLength);
+			if ((pData != NULL) &&
+				(dataLength > 0))
+			{
+				// Make sure settings haven't changed in the meantime
+				if (m_settings.m_browseResults == false)
+				{
+					// Display the URL in the View tab
+					mainNotebook->set_current_page(2);
+					if (m_pHtmlView->renderData(pData, dataLength, url) == true)
+					{
+						//viewstop1->set_sensitive(true);
+					}
+					set_status(locale_to_utf8(url));
+				}
+			}
+		}
+	}
+	else if (type == "IndexingThread")
+	{
+		char docIdStr[64];
+
+		IndexingThread *pIndexThread = dynamic_cast<IndexingThread *>(pThread);
+		if (pIndexThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		const set<unsigned int> &docIdList = pIndexThread->getDocumentIDs();
+
+		// Did the thread perform an update ?
+		if (pIndexThread->isNewDocument() == false)
+		{
+			// Yes, it did
+			status = _("Updated document");
+		}
+		else
+		{
+			string url = pIndexThread->getURL();
+			bool labeled = false;
+
+			status = _("Indexed");
+			status += " ";
+			status += to_utf8(url);
+
+			// Update the in-progress list
+			if (m_state.writeLock(3) == true)
+			{
+				set<string>::iterator urlIter = m_state.m_beingIndexed.find(url);
+				if (urlIter != m_state.m_beingIndexed.end())
+				{
+					m_state.m_beingIndexed.erase(urlIter);
+				}
+
+				m_state.unlock();
+			}
+
+			// Was the current label applied to that document ?
+			string currentLabelName;
+			if ((m_state.getCurrentLabel(currentLabelName) > 0) &&
+				(pIndexThread->getLabelName() == currentLabelName))
+			{
+				labeled = true;
+			}
+
+			// Is the index still being shown ?
+			if (m_state.getCurrentIndex() == _("My Documents"))
+			{
+				XapianIndex index(m_settings.m_indexLocation);
+				DocumentInfo docInfo;
+				string date;
+
+				// Update the index tree
+				for (set<unsigned int>::iterator idIter = docIdList.begin();
+					idIter != docIdList.end(); ++idIter)
+				{
+					unsigned int docId = *idIter;
+
+					// Get that document's properties
+					if (index.getDocumentInfo(docId, docInfo) == true)
+					{
+						// Append to the index tree
+						IndexedDocument indexedDoc(docInfo.getTitle(),
+							XapianEngine::buildUrl(m_settings.m_indexLocation, docId),
+							docInfo.getLocation(), docInfo.getType(),
+							docInfo.getLanguage());
+						indexedDoc.setTimestamp(docInfo.getTimestamp());
+						m_pIndexTree->appendDocument(indexedDoc, labeled);
+					}
+				}
+
+				showlabels1->set_sensitive(true);
+			}
+		}
+
+		set_status(status);
+	}
+	else if (type == "UnindexingThread")
+	{
+		UnindexingThread *pUnindexThread = dynamic_cast<UnindexingThread *>(pThread);
+		if (pUnindexThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		if (pUnindexThread->getDocumentsCount() > 0)
+		{
+			status = _("Unindexed document(s)");
+			set_status(status);
+		}
+		// Else, stay silent
+	}
+	else if (type == "MonitorThread")
+	{
+		// FIXME: do something about this
+	}
+	else if (type == "UpdateDocumentThread")
+	{
+		UpdateDocumentThread *pUpdateThread = dynamic_cast<UpdateDocumentThread *>(pThread);
+		if (pUpdateThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		m_pIndexTree->setDocumentTitle(pUpdateThread->getDocumentID(),
+			pUpdateThread->getDocumentInfo().getTitle());
+
+		status = _("Updated document");
+		set_status(status);
+	}
+	else if (type == "ListenerThread")
+	{
+		// FIXME: do something about this
+	}
+
+	// Delete the thread
+	delete pThread;;
+
+	// We might be able to run a queued action
+	check_queue();
+
+	// Any threads left to return ?
+	if (get_threads_count() == 0)
+	{
+#ifdef DEBUG
+		cout << "mainWindow::on_thread_end: disconnecting timeout" << endl;
+#endif
+		if (m_timeoutConnection.connected() == true)
+		{
+			m_timeoutConnection.block();
+			m_timeoutConnection.disconnect();
+			mainProgressbar->set_fraction(0.0);
+		}
+#ifdef DEBUG
+		else cout << "mainWindow::on_thread_end: not connected" << endl;
+#endif
+	}
+}
+
+//
+// Message reception by EnginesTree
+//
+void mainWindow::on_editindex(ustring indexName, ustring location)
+{
+#ifdef DEBUG
+	cout << "mainWindow::on_editindex: called" << endl;
+#endif
+	// Open the index properties dialog
+	indexDialog indexBox(indexName, location);
+	indexBox.show();
+	if (indexBox.run() != RESPONSE_OK)
+	{
+		return;
+	}
+
+	if ((indexName != indexBox.getName()) ||
+		(location != indexBox.getLocation()))
+	{
+		ustring newName = indexBox.getName();
+		ustring newLocation = indexBox.getLocation();
+
+		// Is the name okay ?
+		if (indexBox.badName() == true)
+		{
+			ustring statusText = _("Couldn't rename index, name");
+			statusText += " ";
+			statusText += newName;
+			statusText += " ";
+			statusText +=  _("is already in use");
+
+			// Tell user name is bad
+			set_status(statusText);
+			return;
+		}
+
+		// The only way to edit an index right now is to remove it
+		// first, then add it again
+		if ((m_settings.removeIndex(locale_from_utf8(indexName)) == false) ||
+			(m_settings.addIndex(locale_from_utf8(newName),
+				locale_from_utf8(newLocation)) == false))
+		{
+			ustring statusText = _("Couldn't rename index");
+			statusText += " ";
+			statusText += indexName;
+
+			// An error occured
+			set_status(statusText);
+			return;
+		}
+
+		// Refresh the engines list
+		m_pEnginesTree->populate();
+	}
+
+	set_status(_("Edited index"));
+}
+
+//
+// Message reception from ListenerThread
+//
+void mainWindow::on_message_reception(DocumentInfo docInfo, string labelName)
+{
+	string location = docInfo.getLocation();
+
+	if (location.empty() == false)
+	{
+#ifdef DEBUG
+		cout << "mainWindow::on_message_reception: indexing " << location << endl;
+#endif
+		// Queue this
+		queue_index(docInfo, labelName);
+	}
+}
+
+//
+// Message reception from IndexBrowserThread
+//
+void mainWindow::on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, string indexName)
+{
+	LabelManager labelMan(m_settings.m_historyDatabase);
+	bool hasLabel = false;
+
+	if (indexName != locale_from_utf8(m_state.getCurrentIndex()))
+	{
+		// Ignore
+#ifdef DEBUG
+		cout << "mainWindow::on_message_indexupdate: " << indexName << " not current" << endl;
+#endif
+		return;
+	}
+
+	// Is the last page being displayed ?
+	if (m_state.m_startDoc + m_maxDocsCount < m_state.m_indexDocsCount)
+	{
+		// No, so we can't add a new entry for that document
+		// Increment the count
+		++m_state.m_indexDocsCount;
+		// ...and make sure the user can display that last page
+		indexForwardButton->set_sensitive(true);
+		indexLastButton->set_sensitive(true);
+		return;
+	}
+
+	const std::map<string, string> &indexesMap = PinotSettings::getInstance().getIndexes();
+	std::map<string, string>::const_iterator mapIter = indexesMap.find(indexName);
+	if (mapIter == indexesMap.end())
+	{
+		return;
+	}
+
+	// Does that document have the current label ?
+	string currentLabelName;
+	if (m_state.getCurrentLabel(currentLabelName) > 0)
+	{
+		hasLabel = labelMan.hasLabel(docId, mapIter->second, currentLabelName);
+	}
+
+	// Add a row
+	if (m_pIndexTree->appendDocument(docInfo, hasLabel) == true)
+	{
+#ifdef DEBUG
+		cout << "mainWindow::on_message_indexupdate: added document to index list" << endl;
+#endif
+		++m_state.m_indexDocsCount;
+	}
+}
+
+//
+// Message reception from importDialog
+//
+void mainWindow::on_message_import(DocumentInfo docInfo)
+{
+	string location = docInfo.getLocation();
+
+	if (location.empty() == false)
+	{
+		// Index the selected file
+		queue_index(docInfo, "");
+	}
+}
+
+//
+// Session > Configure menu selected
+//
+void mainWindow::on_configure_activate()
+{
+	bool useExternalBrowser = m_settings.m_browseResults;
+
+	prefsDialog prefsBox;
+	prefsBox.show();
+	if (prefsBox.run() != RESPONSE_OK)
+	{
+		return;
+	}
+#ifdef DEBUG
+	cout << "mainWindow::on_configure_activate: settings changed" << endl;
+#endif
+
+	// FIXME: if mail accounts are configured, make sure the MonitorThread
+	// is running and knows about the new accounts
+
+	// Synchronize the labels list with the new settings
+	m_pIndexTree->setCurrentLabelColour(0, 0, 0, false);
+	populate_labelMenu();
+
+	// Do the changes affect the View tab ?
+	if (useExternalBrowser != m_settings.m_browseResults)
+	{
+		int nCurrentPage = mainNotebook->get_current_page();
+		Widget *pPage = mainNotebook->get_nth_page(2);
+		if (pPage != NULL)
+		{
+			// Hide or show ?
+			if (m_settings.m_browseResults == true)
+			{
+				pPage->hide();
+			}
+			else
+			{
+				pPage->show();
+
+				// Make sure we show the same tab
+				mainNotebook->set_current_page(nCurrentPage);
+			}
+		}
+	}
+
+	// Any mail documents we should delete ?
+	const set<string> &labelNames = prefsBox.getMailLabelsToDelete();
+	if (labelNames.empty() == false)
+	{
+		start_thread(new UnindexingThread(labelNames, locale_from_utf8(m_settings.m_mailIndexLocation)));
+	}
+}
+
+//
+// Session > Quit menu selected
+//
+void mainWindow::on_quit_activate()
+{
+	on_mainWindow_delete_event(NULL);
+}
+
+//
+// Edit > Cut menu selected
+//
+void mainWindow::on_cut_activate()
+{
+	// Copy
+	on_copy_activate();
+	// ...and delete
+	on_delete_activate();
+}
+
+//
+// Edit > Copy menu selected
+//
+void mainWindow::on_copy_activate()
+{
+	ustring text;
+
+	if (queryTreeview->is_focus() == true)
+	{
+#ifdef DEBUG
+		cout << "mainWindow::on_copy_activate: query tree" << endl;
+#endif
+		TreeModel::iterator iter = queryTreeview->get_selection()->get_selected();
+		TreeModel::Row row = *iter;
+		// Copy only the query name, not the summary
+		text = row[m_queryColumns.m_name];
+	}
+	else if (m_pResultsTree->is_focus() == true)
+	{
+		bool firstItem = true;
+
+#ifdef DEBUG
+		cout << "mainWindow::on_copy_activate: results tree" << endl;
+#endif
+		// Get the current results selection
+		vector<Result> resultsList;
+		m_pResultsTree->getSelection(resultsList);
+	
+		for (vector<Result>::const_iterator resultIter = resultsList.begin();
+			resultIter != resultsList.end(); ++resultIter)
+		{
+			if (firstItem == false)
+			{
+				text += "\n";
+			}
+			text += resultIter->getTitle();
+			text += " ";
+			text += resultIter->getLocation();
+			firstItem = false;
+		}
+	}
+	else if (m_pIndexTree->is_focus() == true)
+	{
+		bool firstItem = true;
+
+#ifdef DEBUG
+		cout << "mainWindow::on_copy_activate: index tree" << endl;
+#endif
+		// Get the current documents selection
+		vector<IndexedDocument> documentsList;
+		m_pIndexTree->getSelection(documentsList);
+	
+		for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
+			docIter != documentsList.end(); ++docIter)
+		{
+			if (firstItem == false)
+			{
+				text += "\n";
+			}
+			text += docIter->getTitle();
+			text += " ";
+			text += docIter->getLocation();
+			firstItem = false;
+		}
+	}
+	else
+	{
+		// Only rows from the query, results and index trees can be copied
+#ifdef DEBUG
+		cout << "mainWindow::on_copy_activate: other" << endl;
+#endif
+		return;
+	}
+	
+	RefPtr<Clipboard> refClipboard = Clipboard::get();
+	refClipboard->set_text(text);
+}
+
+//
+// Edit > Paste menu selected
+//
+void mainWindow::on_paste_activate()
+{
+	RefPtr<Clipboard> refClipboard = Clipboard::get();
+	if (refClipboard->wait_is_text_available() == false)
+	{
+		return;
+	}
+
+	ustring clipText = refClipboard->wait_for_text();
+	if (queryTreeview->is_focus() == true)
+	{
+#ifdef DEBUG
+		cout << "mainWindow::on_paste_activate: query tree" << endl;
+#endif
+		// Use whatever text is in the clipboard as query name
+		// FIXME: look for \n as query fields separators ?
+		QueryProperties queryProps = QueryProperties(locale_from_utf8(clipText),
+			"", "", "", "");
+		string summary = queryProps.toString();
+
+		// Add a new row to the query tree
+		TreeModel::iterator iter = m_refQueryTree->append();
+		TreeModel::Row row = *iter;
+		row[m_queryColumns.m_name] = clipText;
+		if (summary.empty() == false)
+		{
+			row[m_queryColumns.m_summary] = to_utf8(summary);
+		}
+		else
+		{
+			row[m_queryColumns.m_summary] = _("<undefined>");
+		}
+		row[m_queryColumns.m_properties] = queryProps;
+	}
+	else
+	{
+		// Only the query tree can be pasted into, others are read-only
+#ifdef DEBUG
+		cout << "mainWindow::on_paste_activate: other" << endl;
+#endif
+		return;
+	}
+}
+
+//
+// Edit > Delete menu selected
+//
+void mainWindow::on_delete_activate()
+{
+	if (m_pResultsTree->is_focus() == true)
+	{
+#ifdef DEBUG
+		cout << "mainWindow::on_delete_activate: results tree" << endl;
+#endif
+		if (m_pResultsTree->deleteSelection() == true)
+		{
+			// The results tree is now empty
+			clearresults1->set_sensitive(false);
+		}
+	}
+	// Nothing else can be deleted
+}
+
+//
+// Results > Clear menu selected
+//
+void mainWindow::on_clearresults_activate()
+{
+	m_pResultsTree->clear();
+	clearresults1->set_sensitive(false);
+}
+
+//
+// Results > Show Extract menu selected
+//
+void mainWindow::on_showextract_activate()
+{
+#ifdef DEBUG
+	cout << "mainWindow::on_showextract_activate: called" << endl;
+#endif
+	m_pResultsTree->showExtract(showextract1->get_active());
+}
+
+//
+// Results > Group menu selected
+//
+void mainWindow::on_groupresults_activate()
+{
+	ResultsModelColumns::ResultType currentType, newType;
+
+#ifdef DEBUG
+	cout << "mainWindow::on_groupresults_activate: called" << endl;
+#endif
+	// What's the new grouping criteria ?
+	m_pResultsTree->regroupResults(searchenginegroup1->get_active());
+}
+
+//
+// Results > View menu selected
+//
+void mainWindow::on_viewresults_activate()
+{
+	ustring url = m_pResultsTree->getFirstSelectionURL();
+	if (view_document(locale_from_utf8(url)) == true)
+	{
+		// We can update the row right now
+		m_pResultsTree->setFirstSelectionViewedState(true);
+	}
+}
+
+//
+// Results > View Cache menu selected
+//
+void mainWindow::on_viewcache_activate()
+{
+	ustring url = m_pResultsTree->getFirstSelectionURL();
+
+	start_thread(new DownloadingThread(url, true));
+
+	// Update the row now, even though the cached page may not be retrieved
+	m_pResultsTree->setFirstSelectionViewedState(true);
+}
+
+//
+// Results > Index menu selected
+//
+void mainWindow::on_indexresults_activate()
+{
+	// Make sure this has been configured
+	if (m_settings.m_indexLocation.empty() == true)
+	{
+		set_status(_("Please set a location for the index first"));
+		return;
+	}
+
+	vector<Result> resultsList;
+	m_pResultsTree->getSelection(resultsList);
+
+	// Go through selected results
+	for (vector<Result>::const_iterator resultIter = resultsList.begin();
+		resultIter != resultsList.end(); ++resultIter)
+	{
+		// Get the actual URL to download
+		string url = resultIter->getLocation();
+	
+		if (url.empty() == true)
+		{
+			set_status(_("Result location is unknown"));
+			return;
+		}
+#ifdef DEBUG
+		cout << "mainWindow::on_indexresults_activate: URL is " << url << endl;
+#endif
+		queue_index(DocumentInfo(resultIter->getTitle(), url,
+			resultIter->getType(), resultIter->getLanguage()), "");
+	}
+}
+
+//
+// Index > Import menu selected
+//
+void mainWindow::on_import_activate()
+{
+	importDialog importBox(_("Import Document(s)"));
+
+	importBox.getImportFileSignal().connect(SigC::slot(*this,
+		&mainWindow::on_message_import));
+	importBox.show();
+	importBox.run();
+	// Let the signal handler deal with mporting stuff
+}
+
+//
+// Index > View menu selected
+//
+void mainWindow::on_viewfromindex_activate()
+{
+	// View the first document, don't bother about the rest
+	ustring url = m_pIndexTree->getFirstSelectionLiveURL();
+	view_document(locale_from_utf8(url));
+}
+
+//
+// Index > Refresh menu selected
+//
+void mainWindow::on_refreshindex_activate()
+{
+	// Make sure this has been configured
+	if (m_settings.m_indexLocation.empty() == true)
+	{
+		set_status(_("Please set a location for the index first"));
+		return;
+	}
+
+	// Get the current documents selection
+	vector<IndexedDocument> documentsList;
+	m_pIndexTree->getSelection(documentsList);
+
+	for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
+		docIter != documentsList.end(); ++docIter)
+	{
+		// The URL to download, ie the original location of the document
+		string url = docIter->getOriginalLocation();
+		if (url.empty() == true)
+		{
+			continue;
+		}
+
+		// The document ID
+		unsigned int docId = docIter->getID();
+		if (docId == 0)
+		{
+			continue;
+		}
+
+		// The title
+		string title = docIter->getTitle();
+#ifdef DEBUG
+		cout << "mainWindow::on_refreshindex_activate: URL is " << url << endl;
+#endif
+
+		// Add this action to the queue
+		queue_index(*docIter, "", docId);
+	}
+}
+
+//
+// Index > Show Properties menu selected
+//
+void mainWindow::on_showfromindex_activate()
+{
+	LabelManager labelMan(m_settings.m_historyDatabase);
+	vector<IndexedDocument> documentsList;
+	set<string> docLabels;
+	DocumentInfo docInfo;
+	unsigned int docId = 0;
+	int width, height;
+	bool matchedLabel = false, editTitle = false;
+
+	const std::map<string, string> &indexesMap = PinotSettings::getInstance().getIndexes();
+	std::map<string, string>::const_iterator mapIter = indexesMap.find(m_state.getCurrentIndex());	
+	if (mapIter == indexesMap.end())
+	{
+		ustring statusText = _("Index");
+		statusText += " ";
+		statusText += m_state.getCurrentIndex();
+		statusText += " ";
+		statusText += _("doesn't exist");
+		set_status(statusText);
+		return;
+	}
+
+	// Get the current documents selection
+	m_pIndexTree->getSelection(documentsList);
+
+	// If there's only one document selected, get its labels
+	if (documentsList.size() == 1)
+	{
+		vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
+
+		// Get the document ID
+		Url urlObj(docIter->getLocation());
+		docId = (unsigned int)atoi(urlObj.getFile().c_str());
+		if (docId > 0)
+		{
+			labelMan.getLabels(docId, mapIter->second, docLabels);
+
+			// Does it match the current label ?
+			string currentLabelName;
+			if ((m_state.getCurrentLabel(currentLabelName) > 0) &&
+				(find(docLabels.begin(), docLabels.end(), currentLabelName) != docLabels.end()))
+			{
+				matchedLabel = true;
+			}
+		}
+
+		docInfo.setTitle(docIter->getTitle());
+		docInfo.setLocation(docIter->getOriginalLocation());
+		docInfo.setType(docIter->getType());
+		docInfo.setLanguage(docIter->getLanguage());
+		docInfo.setTimestamp(docIter->getTimestamp());
+		editTitle = true;
+	}
+	// Else, start with a blank list
+
+	// Let the user set the labels
+	get_size(width, height);
+	propertiesDialog propertiesBox(docLabels, docInfo, editTitle);
+	propertiesBox.setHeight(height / 2);
+	propertiesBox.show();
+	if (propertiesBox.run() != RESPONSE_OK)
+	{
+		return;
+	}
+	const set<string> &labels = propertiesBox.getLabels();
+
+	// Now apply these labels to all documents
+	for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
+		docIter != documentsList.end(); ++docIter)
+	{
+		// Check the document ID
+		unsigned int docId = docIter->getID();
+		if (docId == 0)
+		{
+			continue;
+		}
+		// Set the document's labels list
+		labelMan.setLabels(docId, mapIter->second, labels);
+	}
+
+	if ((documentsList.size() == 1) &&
+		(docId > 0))
+	{
+		bool matchesLabel = false;
+
+		// Does the sole selected document match the current label now ?
+		string currentLabelName;
+		if ((m_state.getCurrentLabel(currentLabelName) > 0) &&
+			(find(labels.begin(), labels.end(), currentLabelName) != labels.end()))
+		{
+			matchesLabel = true;
+		}
+
+		// Was there any change ?
+		if (matchesLabel != matchedLabel)
+		{
+			// Update this document to the index tree
+			m_pIndexTree->setDocumentLabeledState(docId, matchesLabel);
+		}
+
+		string newTitle = propertiesBox.getDocumentInfo().getTitle();
+		if (newTitle != docInfo.getTitle())
+		{
+			docInfo.setTitle(newTitle);
+			
+			// Update the document's title
+			start_thread(new UpdateDocumentThread(m_state.getCurrentIndex(), docId, docInfo));
+		}
+	}
+	else
+	{
+		string currentLabelName;
+
+		// Because the current label may have been applied to or removed from
+		// one or more of the selected documents, refresh the list of matching documents
+		m_state.getCurrentLabel(currentLabelName);
+		start_thread(new LabelQueryThread(m_state.getCurrentIndex(), currentLabelName));
+	}
+}
+
+//
+// Index > Unindex menu selected
+//
+void mainWindow::on_unindex_activate()
+{
+	ustring boxTitle = _("Delete this document from the index ?");
+
+	// Get the current documents selection
+	vector<IndexedDocument> documentsList;
+	if (m_pIndexTree->getSelection(documentsList) == false)
+	{
+		return;
+	}
+
+	if (documentsList.size() > 1)
+	{
+		boxTitle = _("Delete these documents from the index ?");
+	}
+
+	// Ask for confirmation
+	MessageDialog msgDialog(boxTitle, false, MESSAGE_QUESTION, BUTTONS_YES_NO);
+	msgDialog.set_transient_for(*this);
+	msgDialog.show();
+	int result = msgDialog.run();
+	if (result == RESPONSE_NO)
+	{
+		return;
+	}
+
+	// Remove these documents from the tree
+	if (m_pIndexTree->deleteSelection() == true)
+	{
+		// The index tree is now empty
+		showlabels1->set_sensitive(false);
+	}
+
+	set<unsigned int> docIdList;
+	for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
+		docIter != documentsList.end(); ++docIter)
+	{
+		// Get the actual URL of the document to delete
+		string url = docIter->getLocation();
+		string liveUrl = docIter->getOriginalLocation();
+		if (url.empty() == true)
+		{
+			continue;
+		}
+
+		unsigned int docId = docIter->getID();
+		if (docId > 0)
+		{
+			docIdList.insert(docId);
+		}
+	}
+
+	if (docIdList.empty() == false)
+	{
+		// Queue this action
+#ifdef DEBUG
+		cout << "mainWindow::on_unindex_activate: " << docIdList.size() << " documents to unindex" << endl;
+#endif
+		queue_unindex(docIdList);
+	}
+}
+
+//
+// Help > About menu selected
+//
+void mainWindow::on_about_activate()
+{
+	aboutDialog aboutBox;
+	aboutBox.show();
+	aboutBox.run();
+}
+
+//
+// Activity timeout elapsed
+//
+bool mainWindow::on_activity_timeout()
+{
+	if (m_timeoutConnection.blocked() == false)
+	{
+		mainProgressbar->pulse();
+	}
+#ifdef DEBUG
+	else cout << "mainWindow::on_activity_timeout: blocked" << endl;
+#endif
+
+	return true;
+}
+
+//
+// Add index button click
+//
+void mainWindow::on_addIndexButton_clicked()
+{
+	// Open the index properties dialog
+	indexDialog indexBox;
+	indexBox.show();
+	if (indexBox.run() != RESPONSE_OK)
+	{
+		return;
+	}
+
+	ustring name = indexBox.getName();
+	ustring location = indexBox.getLocation();
+
+	// Is the name okay ?
+	if (indexBox.badName() == true)
+	{
+		ustring statusText = _("Index name");
+		statusText += " ";
+		statusText += name;
+		statusText += " ";
+		statusText +=  _("is already in use");
+
+		// Tell user name is bad
+		set_status(statusText);
+		return;
+	}
+
+	// Add the new index
+	if (m_settings.addIndex(locale_from_utf8(name),
+			locale_from_utf8(location)) == false)
+	{
+		ustring statusText = _("Couldn't add index");
+		statusText += " ";
+		statusText += name;
+
+		// An error occured
+		set_status(statusText);
+	}
+	else
+	{
+		// Refresh the indexes list
+		removeIndexButton->set_sensitive(false);
+		m_pEnginesTree->populate();
+	}
+
+	set_status(_("Added new index"));
+}
+
+//
+// Remove index button click
+//
+void mainWindow::on_removeIndexButton_clicked()
+{
+	list<TreeModel::Path> selectedEngines = m_pEnginesTree->getSelection();
+	// If there are more than one row selected, don't bother
+	if (selectedEngines.size() != 1)
+	{
+		return;
+	}
+
+	list<TreeModel::Path>::iterator enginePath = selectedEngines.begin();
+	if (enginePath == selectedEngines.end())
+	{
+		return;
+	}
+
+	TreeModel::iterator engineIter = m_pEnginesTree->getIter(*enginePath);
+	TreeModel::Row engineRow = *engineIter;
+
+	// Make sure the engine is an external index
+	EnginesModelColumns &engineColumns = m_pEnginesTree->getColumnRecord();
+	EnginesModelColumns::EngineType engineType = engineRow[engineColumns.m_type];
+	if (engineType == EnginesModelColumns::INDEX_ENGINE)
+	{
+		ustring name = engineRow[engineColumns.m_name];
+
+		// Remove it
+		// FIXME: ask for confirmation ?
+		if (m_settings.removeIndex(locale_from_utf8(name)) == false)
+		{
+			ustring statusText = _("Couldn't remove index");
+			statusText += " ";
+			statusText += name;
+
+			// An error occured
+			set_status(statusText);
+		}
+		else
+		{
+			// Refresh the indexes list
+			removeIndexButton->set_sensitive(false);
+			m_pEnginesTree->populate();
+		}
+	}
+
+}
+
+//
+// Find button click
+//
+void mainWindow::on_findButton_clicked()
+{
+	QueryProperties queryProps;
+
+	queryProps.setName("Live query");
+	// FIXME: parse the query string !
+	queryProps.setAnyWords(locale_from_utf8(liveQueryEntry->get_text()));
+
+	run_search(queryProps);
+}
+
+//
+// Add query button click
+//
+void mainWindow::on_addQueryButton_clicked()
+{
+	QueryProperties queryProps = QueryProperties("", "", "", "", "");
+
+	// Start with editing the new query's properties
+	queryDialog queryBox(queryProps);
+	queryBox.show();
+	if (queryBox.run() == RESPONSE_OK)
+	{
+		// Is the name okay ?
+		if (queryBox.badName() == true)
+		{
+			ustring statusText = _("Query name");
+			statusText += " ";
+			statusText += queryProps.getName();
+			statusText += " ";
+			statusText +=  _("is already in use");
+
+			// Tell user name is bad
+			set_status(statusText);
+			return;
+		}
+
+		// Add the new query
+		if (m_settings.addQuery(queryProps) == false)
+		{
+			ustring statusText = _("Couldn't add query");
+			statusText += " ";
+			statusText += queryProps.getName();
+
+			set_status(statusText);
+			return;
+		}
+
+		populate_queryTreeview();
+		set_status(_("Added new query"));
+	}
+}
+
+//
+// Edit query button click
+//
+void mainWindow::on_editQueryButton_clicked()
+{
+	TreeModel::iterator iter = queryTreeview->get_selection()->get_selected();
+	// Anything selected ?
+	if (iter)
+	{
+		TreeModel::Row row = *iter;
+#ifdef DEBUG
+		cout << "mainWindow::on_editQueryButton_clicked: selected " << row[m_queryColumns.m_name] << endl;
+#endif
+
+		// Backup the current name
+		ustring queryName = row[m_queryColumns.m_name];
+
+		// Edit this query's properties
+		QueryProperties queryProps = row[m_queryColumns.m_properties];
+		queryDialog queryBox(queryProps);
+		queryBox.show();
+		if (queryBox.run() != RESPONSE_OK)
+		{
+			// Nothing to do
+			return;
+		}
+
+		// Is the name okay ?
+		if (queryBox.badName() == true)
+		{
+			ustring statusText = _("Query name");
+			statusText += " ";
+			statusText += queryProps.getName();
+			statusText += " ";
+			statusText +=  _("is already in use");
+
+			// Tell user name is bad
+			set_status(statusText);
+			return;
+		}
+
+		// Did the name change ?
+		ustring newQueryName = to_utf8(queryProps.getName());
+		if (newQueryName != queryName)
+		{
+			// Remove records from QueryHistory
+			string queryName = locale_from_utf8(row[m_queryColumns.m_name]);
+			QueryHistory history(m_settings.m_historyDatabase);
+			history.deleteItems(queryName, true);
+		}
+
+		// Update the query properties
+		if ((m_settings.removeQuery(queryName) == false) ||
+			(m_settings.addQuery(queryProps) == false))
+		{
+			ustring statusText = _("Couldn't update query");
+			statusText += " ";
+			statusText += queryName;
+
+			set_status(statusText);
+			return;
+		}
+
+		populate_queryTreeview();
+		set_status(_("Edited query"));
+	}
+}
+
+//
+// Remove query button click
+//
+void mainWindow::on_removeQueryButton_clicked()
+{
+	TreeModel::iterator iter = queryTreeview->get_selection()->get_selected();
+	// Anything selected ?
+	if (iter)
+	{
+		TreeModel::Row row = *iter;
+		string queryName = locale_from_utf8(row[m_queryColumns.m_name]);
+
+		if (m_settings.removeQuery(queryName) == true)
+		{
+			// Remove records from QueryHistory
+			QueryHistory history(m_settings.m_historyDatabase);
+			history.deleteItems(queryName, true);
+
+			// Select another row
+			queryTreeview->get_selection()->unselect(iter);
+			TreeModel::Path path = m_refQueryTree->get_path(iter);
+			path.next();
+			queryTreeview->get_selection()->select(path);
+			// Erase
+			m_refQueryTree->erase(row);
+
+			queryTreeview->columns_autosize();
+		}
+	}
+}
+
+//
+// Find query button click
+//
+void mainWindow::on_findQueryButton_clicked()
+{
+	TreeModel::iterator queryIter = queryTreeview->get_selection()->get_selected();
+	// Anything selected ?
+	if (queryIter)
+	{
+		TreeModel::Row queryRow = *queryIter;
+
+		QueryProperties queryProps = queryRow[m_queryColumns.m_properties];
+		run_search(queryProps);
+
+		// Update the Last Run column
+		queryRow[m_queryColumns.m_lastRun] = TimeConverter::toTimestamp(time(NULL));
+	}
+}
+
+//
+// Index list mouse click
+//
+void mainWindow::on_indexCombobox_changed()
+{
+	TreeModel::iterator indexIter = indexCombobox->get_active();
+	if (indexIter)
+	{
+		TreeModel::Row row = *indexIter;
+
+		ustring indexName = row[m_indexNameColumns.m_name];
+#ifdef DEBUG
+		cout << "mainWindow::on_indexCombobox_changed: current index now " << indexName << endl;
+#endif
+		ustring currentIndexName = m_state.getCurrentIndex();
+		m_state.setCurrentIndex(indexName);
+		if ((currentIndexName.empty() == false) &&
+			(currentIndexName != indexName))
+		{
+			// Force a refresh if the selected index has changed
+			m_state.m_startDoc = m_state.m_indexDocsCount = 0;
+			on_indexForwardButton_clicked();
+		}
+	}
+}
+
+//
+// Index first button click
+//
+void mainWindow::on_indexFirstButton_clicked()
+{
+	m_state.m_startDoc = 0;
+	browse_index(m_state.m_startDoc);
+}
+
+//
+// Index back button click
+//
+void mainWindow::on_indexBackButton_clicked()
+{
+	if (m_state.m_startDoc >= m_maxDocsCount)
+	{
+		m_state.m_startDoc -= m_maxDocsCount;
+		browse_index(m_state.m_startDoc);
+	}
+}
+
+//
+// Index forward button click
+//
+void mainWindow::on_indexForwardButton_clicked()
+{
+	if (m_state.m_indexDocsCount == 0)
+	{
+		m_state.m_startDoc = 0;
+		browse_index(m_state.m_startDoc);
+	}
+	else if (m_state.m_indexDocsCount >= m_state.m_startDoc + m_maxDocsCount)
+	{
+		m_state.m_startDoc += m_maxDocsCount;
+		browse_index(m_state.m_startDoc);
+	}
+}
+
+//
+// Index last button click
+//
+void mainWindow::on_indexLastButton_clicked()
+{
+	if (m_state.m_indexDocsCount >= m_state.m_startDoc + m_maxDocsCount)
+	{
+		m_state.m_startDoc = m_state.m_indexDocsCount - (m_state.m_indexDocsCount % m_maxDocsCount);
+		browse_index(m_state.m_startDoc);
+	}
+}
+
+//
+// Query list mouse click
+//
+bool mainWindow::on_queryTreeview_button_press_event(GdkEventButton *ev)
+{
+	// Check for double clicks
+	if (ev->type == GDK_2BUTTON_PRESS)
+	{
+		on_editQueryButton_clicked();
+	}
+
+	return false;
+}
+
+//
+// Main window deleted
+//
+bool mainWindow::on_mainWindow_delete_event(GdkEventAny *ev)
+{
+	// Any thread still running ?
+	if (get_threads_count() > 0)
+	{
+		ustring boxTitle = _("At least one background task hasn't been completed yet. Quit now ?");
+		MessageDialog msgDialog(boxTitle, false, MESSAGE_QUESTION, BUTTONS_YES_NO);
+		msgDialog.set_transient_for(*this);
+		msgDialog.show();
+		int result = msgDialog.run();
+		if (result == RESPONSE_NO)
+		{
+			return true;
+		}
+
+		if (m_state.readLock(4) == true)
+		{
+			for (set<WorkerThread *>::iterator threadIter = m_state.m_pThreads.begin();
+				threadIter != m_state.m_pThreads.end(); ++threadIter)
+			{
+#ifdef DEBUG
+				cout << "mainWindow::on_mainWindow_delete_event: stopping thread" << endl;
+#endif
+				// Stop all non-background threads
+				if ((*threadIter)->isBackground() == false)
+				{
+					// FIXME: what if one thread doesn't stop ? can it corrupt anything ?
+					(*threadIter)->stop();
+				}
+			}
+
+			m_state.unlock();
+		}
+	}
+
+	// Save the window's position and dimensions now
+	// Don't worry about the gravity, it hasn't been changed
+	get_position(m_settings.m_xPos, m_settings.m_yPos);
+	get_size(m_settings.m_width, m_settings.m_height);
+	m_settings.m_panePos = mainHpaned->get_position();
+
+	Main::quit();
+	return false;
+}
+
+//
+// Queues additions to the index.
+//
+bool mainWindow::queue_index(const DocumentInfo &docInfo,
+	const string &labelName, unsigned int docId)
+{
+	ActionHistory::ActionType type = ActionHistory::ACTION_INDEX;
+
+	if (docId > 0)
+	{
+		// This is an update
+		type = ActionHistory::ACTION_UPDATE;
+	}
+
+	if (get_threads_count() >= m_maxThreads)
+	{
+		ActionHistory history(m_settings.m_historyDatabase);
+
+		string option = docInfo.getTitle();
+		option += "|";
+		option += Url::escapeUrl(docInfo.getLocation());
+		option += "|";
+		option += docInfo.getType();
+		option += "|";
+		option += labelName;
+		if (type == ActionHistory::ACTION_UPDATE)
+		{
+			option += "|";
+			char docIdStr[64];
+			snprintf(docIdStr, 64, "%d", docId);
+			option += docIdStr;
+		}
+#ifdef DEBUG
+		cout << "mainWindow::queue_index: " << option << endl;
+#endif
+
+		// Add this to ActionHistory and return
+		return history.insertItem(type, option);
+	}
+
+	if (type == ActionHistory::ACTION_UPDATE)
+	{
+		// Update the document
+		index_document(docInfo, labelName, docId);
+	}
+	else
+	{
+		// Index the document
+		index_document(docInfo, labelName);
+	}
+
+	return false;
+}
+
+//
+// Queues index removals.
+//
+bool mainWindow::queue_unindex(set<unsigned int> &docIdList)
+{
+	// Delete the document(s) right away
+	start_thread(new UnindexingThread(docIdList));
+
+	return false;
+}
+
+//
+// Runs a search
+//
+void mainWindow::run_search(const QueryProperties &queryProps)
+{
+	string querySummary = queryProps.toString();
+	if (querySummary.empty() == true)
+	{
+		set_status(_("Query is not set"));
+		return;
+	}
+#ifdef DEBUG
+	cout << "mainWindow::run_search: query name is " << queryProps.getName() << endl;
+#endif
+
+	// Check a search engine has been selected
+	list<TreeModel::Path> selectedEngines = m_pEnginesTree->getSelection();
+	if (selectedEngines.empty() == true)
+	{
+		set_status(_("No search engine selected"));
+		return;
+	}
+
+	// Go through the tree and check selected nodes
+	vector<TreeModel::iterator> engineIters;
+	EnginesModelColumns &engineColumns = m_pEnginesTree->getColumnRecord();
+	for (list<TreeModel::Path>::iterator enginePath = selectedEngines.begin();
+		enginePath != selectedEngines.end(); ++enginePath)
+	{
+		TreeModel::iterator engineIter = m_pEnginesTree->getIter(*enginePath);
+		TreeModel::Row engineRow = *engineIter;
+
+		EnginesModelColumns::EngineType engineType = engineRow[engineColumns.m_type];
+		if (engineType < EnginesModelColumns::ENGINE_FOLDER)
+		{
+			// Skip
+			continue;
+		}
+
+		// Is it a folder ?
+		if (engineType == EnginesModelColumns::ENGINE_FOLDER)
+		{
+			TreeModel::Children children = engineIter->children();
+			for (TreeModel::Children::iterator folderEngineIter = children.begin();
+				folderEngineIter != children.end(); ++folderEngineIter)
+			{
+				TreeModel::Row folderEngineRow = *folderEngineIter;
+
+				EnginesModelColumns::EngineType engineType = engineRow[engineColumns.m_type];
+				if (engineType < EnginesModelColumns::ENGINE_FOLDER)
+				{
+					// Skip
+					continue;
+				}
+
+				engineIters.push_back(folderEngineIter);
+			}
+		}
+		else
+		{
+			engineIters.push_back(engineIter);
+		}
+	}
+#ifdef DEBUG
+	cout << "mainWindow::run_search: selected " << engineIters.size()
+		<< " engines" << endl;
+#endif
+
+	// Now go through the selected search engines
+	set<ustring> engineDisplayableNames;
+	for (vector<TreeModel::iterator>::iterator iter = engineIters.begin();
+		iter != engineIters.end(); ++iter)
+	{
+		TreeModel::Row engineRow = **iter;
+
+		// Check whether this engine has already been done
+		// Using a set<TreeModel::iterator/Row> would be preferable
+		// but is not helpful here
+		ustring engineDisplayableName = engineRow[engineColumns.m_name];
+		if (engineDisplayableNames.find(engineDisplayableName) != engineDisplayableNames.end())
+		{
+			continue;
+		}
+		engineDisplayableNames.insert(engineDisplayableName);
+
+		ustring engineName = engineRow[engineColumns.m_engineName];
+		ustring engineOption = engineRow[engineColumns.m_option];
+		EnginesModelColumns::EngineType engineType = engineRow[engineColumns.m_type];
+#ifdef DEBUG
+		cout << "mainWindow::run_search: engine " << engineDisplayableName << endl;
+#endif
+
+		// Is it a web engine ?
+		if (engineType == EnginesModelColumns::WEB_ENGINE)
+		{
+			// There's a special case for the Google API...
+			if (engineName == "googleapi")
+			{
+				// Make sure this has been configured
+				if (m_settings.m_googleAPIKey.empty() == true)
+				{
+					set_status(_("Please set the Google API key first"));
+					// Skip this engine
+					continue;
+				}
+				// Option is the Google API key
+				engineOption = m_settings.m_googleAPIKey;
+			}
+		}
+
+		ustring status = _("Running query");
+		status += " \"";
+		status += to_utf8(queryProps.getName());
+		status += "\" ";
+		status += _("on");
+		status += " ";
+		status += engineDisplayableName;
+		set_status(status);
+
+		// Spawn a new thread
+		start_thread(new QueryingThread(locale_from_utf8(engineName),
+			locale_from_utf8(engineDisplayableName), engineOption, queryProps));
+	}
+}
+
+//
+// Browse an index
+//
+void mainWindow::browse_index(unsigned int startDoc)
+{
+	bool enableIndexOps = false;
+
+	// Rudimentary lock
+	if (m_state.m_browsingIndex == true)
+	{
+		return;
+	}
+	m_state.m_browsingIndex = true;
+
+	// Remove existing rows in the index tree
+	m_pIndexTree->clear();
+	// Disable this
+	showlabels1->set_sensitive(false);
+	// Reset variables
+	m_state.m_indexDocsCount = 0;
+
+	if (m_state.getCurrentIndex() == _("My Documents"))
+	{
+		enableIndexOps = true;
+	}
+	import1->set_sensitive(enableIndexOps);
+
+	// Spawn a new thread to browse the index
+#ifdef DEBUG
+	cout << "mainWindow::browse_index: indexing " << m_state.getCurrentIndex() << endl;
+#endif
+	IndexBrowserThread *pBrowseThread = new IndexBrowserThread(
+		locale_from_utf8(m_state.getCurrentIndex()), m_maxDocsCount, startDoc);
+	pBrowseThread->getUpdateSignal().connect(SigC::slot(*this,
+		&mainWindow::on_message_indexupdate));
+	start_thread(pBrowseThread);
+}
+
+//
+// Index (or update) a document
+//
+void mainWindow::index_document(const DocumentInfo &docInfo,
+	const string &labelName, unsigned int docId)
+{
+	LabelManager labelMan(m_settings.m_historyDatabase);
+	Url urlObj(docInfo.getLocation());
+	string indexName = m_settings.m_indexLocation;
+
+	// If the document is mail, we need to check My Email
+	if (urlObj.getProtocol() == "mailbox")
+	{
+		indexName = m_settings.m_mailIndexLocation;
+	}
+
+	// Is it an update ?
+	if (docId > 0)
+	{
+		// Yes, it is
+		start_thread(new IndexingThread(docInfo, docId));
+	}
+	else
+	{
+		XapianIndex index(indexName);
+		string url(docInfo.getLocation());
+		bool isNewDocument = false;
+
+		// No : see if the document is already indexed
+		// or is being indexed
+		if (index.isGood() == true)
+		{
+			docId = index.hasDocument(docInfo);
+		}
+		if ((docId == 0) &&
+			(m_state.writeLock(4) == true))
+		{
+			if (m_state.m_beingIndexed.find(url) == m_state.m_beingIndexed.end())
+			{
+				m_state.m_beingIndexed.insert(url);
+				isNewDocument = true;
+			}
+#ifdef DEBUG
+			else cout << "mainWindow::index_document: already indexed " << url << endl;
+#endif
+
+			m_state.unlock();
+		}
+
+		if (isNewDocument == true)
+		{
+			// This is a new document
+			start_thread(new IndexingThread(docInfo, labelName));
+		}
+	}
+
+	// If the document is indexed, we may have to update its labels
+	if ((docId > 0) &&
+		(labelName.empty() == false))
+	{
+		set<string> docLabels;
+
+		// Get the labels for this document
+		labelMan.getLabels(docId, indexName, docLabels);
+
+		// Add this new label if it's not in
+		if (find(docLabels.begin(), docLabels.end(), labelName) == docLabels.end())
+		{
+#ifdef DEBUG
+			cout << "mainWindow::index_document: applying label " << labelName << " to document " << docId << endl;
+#endif
+			// Update the document's labels list
+			docLabels.insert(labelName);
+			labelMan.setLabels(docId, indexName, docLabels);
+
+			// Is this the current label ?
+			string currentLabelName;
+			if ((m_state.getCurrentLabel(currentLabelName) > 0) &&
+				(labelName == currentLabelName))
+			{
+				// Update this document in the index tree
+				m_pIndexTree->setDocumentLabeledState(docId, true);
+			}
+		}
+#ifdef DEBUG
+		else cout << "mainWindow::index_document: label " << labelName << " already applied to document " << docId << endl;
+#endif
+	}
+}
+
+//
+// View a document
+//
+bool mainWindow::view_document(const string &url, bool internalViewerOnly)
+{
+	if (url.empty() == true)
+	{
+		set_status(_("No URL to browse"));
+		return false;
+	}
+#ifdef DEBUG
+	cout << "mainWindow::view_document: URL is " << url << endl;
+#endif
+
+	// Is browsing enabled ?
+	if ((internalViewerOnly == false) &&
+		(m_settings.m_browseResults == true))
+	{
+		// Point user-defined browser to that URL
+		if (m_settings.m_browserCommand.empty() == true)
+		{
+			set_status(_("No browser configured to view results"));
+			return false;
+		}
+
+		string shellCommand = locale_from_utf8(m_settings.m_browserCommand);
+		// FIXME: do substitutions
+		shellCommand += " \"";
+		shellCommand += url;
+		shellCommand += "\" &";
+		if ((url.empty() == true) ||
+			(system(shellCommand.c_str()) == -1))
+		{
+			ustring status = _("Couldn't browse URL:");
+			status == " ";
+			status += Glib::strerror(errno);
+			set_status(status);
+		}
+	}
+	else
+	{
+		Url urlObj(url);
+
+		// FIXME: there should be a way to know which protocols can be viewed/indexed
+		if (urlObj.getProtocol() == "mailbox")
+		{
+			// Get that message
+			start_thread(new DownloadingThread(url, false));
+		}
+		else
+		{
+			// Display the URL in the View tab
+			mainNotebook->set_current_page(2);
+			if (m_pHtmlView->renderUrl(url) == true)
+			{
+				//viewstop1->set_sensitive(true);
+			}
+			set_status(locale_to_utf8(m_pHtmlView->getLocation()));
+		}
+	}
+
+	// Record this into the history
+	ViewHistory viewHistory(m_settings.m_historyDatabase);
+	if (viewHistory.hasItem(url) == false)
+	{
+		viewHistory.insertItem(url);
+	}
+
+	return true;
+}
+
+//
+// Start of worker thread
+//
+void mainWindow::start_thread(WorkerThread *pNewThread, bool inBackground)
+{
+	static unsigned int nextId = 1;
+	bool insertedThread = false;
+
+	if (pNewThread == NULL)
+	{
+		return;
+	}
+
+	pNewThread->setId(nextId);
+	// Connect to the finished signal
+	pNewThread->getFinishedSignal().connect(SigC::slot(*this,
+		&mainWindow::on_thread_end));
+
+	if (m_state.writeLock(5) == true)
+	{
+		pair<set<WorkerThread *>::iterator, bool> insertPair = m_state.m_pThreads.insert(pNewThread);
+		insertedThread = insertPair.second;
+
+		m_state.unlock();
+	}
+
+	// Was it inserted ?
+	if (insertedThread == false)
+	{
+		// No, it wasn't : delete the object and return
+		cerr << "mainWindow::start_thread: couldn't start "
+			<< pNewThread->getType() << " " << pNewThread->getId() << endl;
+		delete pNewThread;
+
+		return;
+	}
+
+	// Start the thread
+#ifdef DEBUG
+	cout << "mainWindow::start_thread: start of " << pNewThread->getType()
+		<< " " << pNewThread->getId() << endl;
+#endif
+	if (inBackground == true)
+	{
+		pNewThread->inBackground();
+		++m_state.m_backgroundThreads;
+	}
+	pNewThread->start();
+
+	if (inBackground == false)
+	{
+		// Enable the activity progress bar
+		m_timeoutConnection.block();
+		m_timeoutConnection.disconnect();
+		m_timeoutConnection = Glib::signal_timeout().connect(SigC::slot(*this,
+			&mainWindow::on_activity_timeout), 1000);
+		m_timeoutConnection.unblock();
+		// Update the status
+		update_threads_status();
+	}
+	++nextId;
+}
+
+//
+// Checks the queue and runs the oldest action if possible.
+//
+bool mainWindow::check_queue(void)
+{
+	if (get_threads_count() >= m_maxThreads)
+	{
+#ifdef DEBUG
+		cout << "mainWindow::check_queue: too many threads" << endl;
+#endif
+		return false;
+	}
+
+	ActionHistory history(m_settings.m_historyDatabase);
+	ActionHistory::ActionType type;
+	string option;
+
+	if (history.deleteOldestItem(type, option) == false)
+	{
+#ifdef DEBUG
+		cout << "mainWindow::check_queue: found no action" << endl;
+#endif
+		return false;
+	}
+
+	if (type == ActionHistory::ACTION_INDEX)
+	{
+		string::size_type lastPos = 0, pos = option.find_first_of("|");
+		if (pos != string::npos)
+		{
+			string title = option.substr(lastPos, pos - lastPos);
+
+			lastPos = pos + 1;
+			pos = option.find_first_of("|", lastPos);
+			if (pos != string::npos)
+			{
+				string url = option.substr(lastPos, pos - lastPos);
+
+				lastPos = pos + 1;
+				pos = option.find_first_of("|", lastPos);
+				if (pos != string::npos)
+				{
+					string type = option.substr(lastPos, pos - lastPos);
+
+					string labelName = option.substr(pos + 1);
+
+					// Index the document
+					index_document(DocumentInfo(title, Url::unescapeUrl(url), type, ""),
+						labelName);
+				}
+			}
+		}
+	}
+	else if (type == ActionHistory::ACTION_UPDATE)
+	{
+		string::size_type lastPos = 0, pos = option.find_first_of("|");
+		if (pos != string::npos)
+		{
+			string title = option.substr(lastPos, pos - lastPos);
+
+			lastPos = pos + 1;
+			pos = option.find_first_of("|", lastPos);
+			if (pos != string::npos)
+			{
+				string url = option.substr(lastPos, pos - lastPos);
+
+				lastPos = pos + 1;
+				pos = option.find_first_of("|", lastPos);
+				if (pos != string::npos)
+				{
+					string type = option.substr(lastPos, pos - lastPos);
+
+					lastPos = pos + 1;
+					pos = option.find_first_of("|", lastPos);
+					if (pos != string::npos)
+					{
+						string labelName = option.substr(lastPos, pos - lastPos);
+
+						unsigned int docId = (unsigned int)atoi(option.substr(pos + 1).c_str());
+
+						// Update the document
+						index_document(DocumentInfo(title, Url::unescapeUrl(url), type, ""),
+							labelName, docId);
+					}
+				}
+			}
+		}
+	}
+
+	return true;
+}
+
+//
+// Returns the number of non-background threads.
+//
+unsigned int mainWindow::get_threads_count(void)
+{
+	int count = 0;
+
+	if (m_state.readLock(5) == true)
+	{
+		count = m_state.m_pThreads.size() - m_state.m_backgroundThreads;
+		m_state.unlock();
+	}
+#ifdef DEBUG
+	cout << "mainWindow::get_threads_count: " << count << " threads left" << endl;
+#endif
+
+	// A negative count would mean that a background thread returned
+	// without the main thread knowing about it
+	return (unsigned int)max(count , 0);
+}
+
+//
+// Updates the threads status text.
+//
+void mainWindow::update_threads_status(void)
+{
+	ustring text;
+	unsigned int threads = get_threads_count();
+
+	// Update the threads status text for the next call to set_status()
+	if (threads > 0)
+	{
+		char countStr[64];
+		snprintf(countStr, 64, "%d", threads);
+		text = countStr;
+		text += " ";
+		text += _("thread(s)");
+		text += " - ";
+		m_threadStatusText = text;
+	}
+	else
+	{
+		m_threadStatusText = "";
+	}
+}
+
+//
+// Sets the status bar text.
+//
+void mainWindow::set_status(const ustring &text, bool canBeSkipped)
+{
+	static time_t lastTime = time(NULL);
+
+	time_t now = time(NULL);
+	if ((difftime(now, lastTime) < 1) &&
+		(canBeSkipped == true))
+	{
+		// Skip this
+		return;
+	}
+	lastTime = now;
+	
+	// Pop the previous message
+	mainStatusbar->pop();
+	// Append the new message to the threads status text
+	ustring newText = m_threadStatusText;
+	newText += text;
+	// Push
+	mainStatusbar->push(newText);
+}


Property changes on: trunk/UI/GTK2/src/mainWindow.cc
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/mainWindow.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/mainWindow.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,197 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MAINWINDOW_HH
+#define _MAINWINDOW_HH
+
+#include <string>
+#include <map>
+#include <set>
+#include <pthread.h>
+#include <glibmm/refptr.h>
+#include <gdkmm/pixbuf.h>
+#include <gdkmm/color.h>
+#include <gtkmm/rc.h>
+#include <gtkmm/liststore.h>
+#include <gtkmm/treestore.h>
+#include <gtkmm/treeselection.h>
+#include <gtkmm/selectiondata.h>
+#include <gtkmm/menu.h>
+#include <gtkmm/tooltips.h>
+
+#include "DocumentInfo.h"
+#include "IndexedDocument.h"
+#include "ActionHistory.h"
+#include "QueryProperties.h"
+#include "HtmlView.h"
+#include "EnginesTree.h"
+#include "IndexTree.h"
+#include "ModelColumns.h"
+#include "PinotSettings.h"
+#include "ResultsTree.h"
+#include "WorkerThreads.h"
+#include "mainWindow_glade.hh"
+
+class mainWindow : public mainWindow_glade
+{
+public:
+	mainWindow();
+	virtual ~mainWindow();
+
+protected:
+	// Utility methods
+	void populate_queryTreeview();
+	void save_queryTreeview();
+	void populate_indexCombobox();
+	void populate_labelMenu();
+
+	// Handlers
+	void on_enginesTreeviewSelection_changed();
+	void on_queryTreeviewSelection_changed();
+	void on_resultsTreeviewSelection_changed();
+	void on_indexTreeviewSelection_changed();
+	void on_labelMenu_changed(unsigned int pos);
+	void on_thread_end();
+	void on_editindex(Glib::ustring indexName, Glib::ustring location);
+	void on_message_reception(DocumentInfo docInfo, std::string labelName);
+	void on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, std::string indexName);
+	void on_message_import(DocumentInfo docInfo);
+
+	// Handlers inherited from the base class
+	virtual void on_configure_activate();
+	virtual void on_quit_activate();
+
+	virtual void on_cut_activate();
+	virtual void on_copy_activate();
+	virtual void on_paste_activate();
+	virtual void on_delete_activate();
+
+	virtual void on_clearresults_activate();
+	virtual void on_showextract_activate();
+	virtual void on_groupresults_activate();
+	virtual void on_viewresults_activate();
+	virtual void on_viewcache_activate();
+	virtual void on_indexresults_activate();
+
+	virtual void on_import_activate();
+	virtual void on_viewfromindex_activate();
+	virtual void on_refreshindex_activate();
+	virtual void on_showfromindex_activate();
+	virtual void on_unindex_activate();
+
+	virtual void on_about_activate();
+
+	virtual void on_addIndexButton_clicked();
+	virtual void on_removeIndexButton_clicked();
+
+	virtual void on_findButton_clicked();
+	virtual void on_addQueryButton_clicked();
+	virtual void on_editQueryButton_clicked();
+	virtual void on_removeQueryButton_clicked();
+	virtual void on_findQueryButton_clicked();
+
+	virtual void on_indexCombobox_changed();
+
+	virtual void on_indexFirstButton_clicked();
+	virtual void on_indexBackButton_clicked();
+	virtual void on_indexForwardButton_clicked();
+	virtual void on_indexLastButton_clicked();
+
+	virtual bool on_queryTreeview_button_press_event(GdkEventButton *ev);
+	virtual bool on_mainWindow_delete_event(GdkEventAny *ev);
+
+	// Action methods
+	bool queue_index(const DocumentInfo &docInfo, const std::string &labelName,
+		unsigned int docId = 0);
+	bool queue_unindex(set<unsigned int> &docIdList);
+	void run_search(const QueryProperties &queryProps);
+	void browse_index(unsigned int startDoc = 0);
+	void index_document(const DocumentInfo &docInfo, const std::string &labelName,
+		unsigned int docId = 0);
+	bool view_document(const std::string &url, bool internalViewerOnly = false);
+	void start_thread(WorkerThread *pNewThread, bool inBackground = false);
+	bool check_queue(void);
+
+	// Status methods
+	bool on_activity_timeout(void);
+	unsigned int get_threads_count(void);
+	void update_threads_status(void);
+	void set_status(const Glib::ustring &text, bool canBeSkipped = false);
+
+private:
+	// Threads status text
+	Glib::ustring m_threadStatusText;
+	// Global settings
+	PinotSettings &m_settings;
+	// Engine
+	EnginesTree *m_pEnginesTree;
+	// Query
+	QueryModelColumns m_queryColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refQueryTree;
+	// Results
+	ResultsTree *m_pResultsTree;
+	// Index
+	IndexTree *m_pIndexTree;
+	Gtk::Menu *m_pLabelsMenu;
+	ComboModelColumns m_indexNameColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refIndexNameTree;
+	// View
+	HtmlView *m_pHtmlView;
+	// Tooltips
+	Gtk::Tooltips m_tooltips;
+	// Activity timeout
+	SigC::Connection m_timeoutConnection;
+	// Internal state
+	struct InternalState
+	{
+		public:
+			InternalState();
+			~InternalState();
+
+			bool readLock(unsigned int where);
+			bool writeLock(unsigned int where);
+			void unlock(void);
+
+			unsigned int getCurrentLabel(std::string &labelName);
+			void setCurrentLabel(unsigned int labelPos, const std::string &labelName);
+			Glib::ustring getCurrentIndex(void);
+			void setCurrentIndex(const Glib::ustring &indexName);
+
+			// Index
+			unsigned int m_indexDocsCount;
+			unsigned int m_startDoc;
+			// Worker threads
+			std::set<WorkerThread *> m_pThreads;
+			unsigned int m_backgroundThreads;
+			// In-progress actions
+			std::set<std::string> m_beingIndexed;
+			bool m_browsingIndex;
+
+		protected:
+			// Read/write lock
+			pthread_rwlock_t m_rwLock;
+			// Index
+			unsigned int m_currentLabelPos;
+			std::string m_currentLabelName;
+			Glib::ustring m_currentIndexName;
+
+	} m_state;
+	static unsigned int m_maxDocsCount;
+	static unsigned int m_maxThreads;
+
+};
+
+#endif


Property changes on: trunk/UI/GTK2/src/mainWindow.hh
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/mainWindow_glade.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,574 @@
+// generated 2005/12/2 19:36:17 SGT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/mainWindow.cc
+
+
+#if defined __GNUC__ && __GNUC__ < 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include "config.h"
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include <libintl.h>
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include <gtkmmconfig.h>
+#if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
+#include <sigc++/compatibility.h>
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include "mainWindow_glade.hh"
+#include <gdk/gdkkeysyms.h>
+#include <gtkmm/accelgroup.h>
+#include <gtk/gtkimagemenuitem.h>
+#include <gtkmm/menu.h>
+#include <gtkmm/image.h>
+#include <gtkmm/menuitem.h>
+#include <gtkmm/menubar.h>
+#include <gtkmm/box.h>
+#include <gtkmm/label.h>
+#include <gtkmm/buttonbox.h>
+#include <gtkmm/scrolledwindow.h>
+#include <gtkmm/alignment.h>
+
+mainWindow_glade::mainWindow_glade(
+) : Gtk::Window(Gtk::WINDOW_TOPLEVEL)
+{  mainWindow = this;
+   gmm_data = new GlademmData(get_accel_group());
+   configure1 = NULL;
+   separatormenuitem1 = NULL;
+   quit1 = NULL;
+   
+   Gtk::Menu *sessionMenuitem_menu = Gtk::manage(new class Gtk::Menu());
+   sessionMenuitem = NULL;
+   cut1 = NULL;
+   copy1 = NULL;
+   paste1 = NULL;
+   delete1 = NULL;
+   Gtk::Menu *editMenuitem_menu = Gtk::manage(new class Gtk::Menu());
+   editMenuitem = NULL;
+   Gtk::Image *image514 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-clear"), Gtk::IconSize(1)));
+   clearresults1 = NULL;
+   showextract1 = NULL;
+   searchenginegroup1 = NULL;
+   Gtk::RadioMenuItem::Group _RadioMIGroup_searchenginegroup1;
+   hostnamegroup1 = NULL;
+   Gtk::Menu *groupresults1_menu = Gtk::manage(new class Gtk::Menu());
+   Gtk::MenuItem *groupresults1 = NULL;
+   Gtk::MenuItem *separator1 = NULL;
+   viewresults1 = NULL;
+   viewcache1 = NULL;
+   indexresults1 = NULL;
+   Gtk::Menu *resultsMenuitem_menu = Gtk::manage(new class Gtk::Menu());
+   resultsMenuitem = NULL;
+   showlabels1 = NULL;
+   Gtk::Image *image515 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-open"), Gtk::IconSize(1)));
+   import1 = NULL;
+   Gtk::MenuItem *separator3 = NULL;
+   viewfromindex1 = NULL;
+   Gtk::Image *image516 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-refresh"), Gtk::IconSize(1)));
+   refreshindex1 = NULL;
+   Gtk::Image *image517 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-delete"), Gtk::IconSize(1)));
+   unindex1 = NULL;
+   Gtk::Image *image518 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-properties"), Gtk::IconSize(1)));
+   showfromindex1 = NULL;
+   Gtk::Menu *indexMenuitem_menu = Gtk::manage(new class Gtk::Menu());
+   indexMenuitem = NULL;
+   about1 = NULL;
+   Gtk::Menu *helpMenuitem_menu = Gtk::manage(new class Gtk::Menu());
+   helpMenuitem = NULL;
+   Gtk::MenuBar *mainMenubar = Gtk::manage(new class Gtk::MenuBar());
+   enginesVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   
+   Gtk::Image *image439 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-add"), Gtk::IconSize(4)));
+   addIndexButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::Image *image438 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-remove"), Gtk::IconSize(4)));
+   removeIndexButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::HBox *indexHbox = Gtk::manage(new class Gtk::HBox(true, 4));
+   Gtk::VBox *leftVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   Gtk::Label *liveQueryLabel = Gtk::manage(new class Gtk::Label(_("Query:")));
+   liveQueryEntry = Gtk::manage(new class Gtk::Entry());
+   findButton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-find")));
+   
+   Gtk::VButtonBox *findVbuttonbox = Gtk::manage(new class Gtk::VButtonBox(Gtk::BUTTONBOX_DEFAULT_STYLE, 0));
+   Gtk::HBox *liveQueryHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   queryTreeview = Gtk::manage(new class Gtk::TreeView());
+   
+   Gtk::ScrolledWindow *queryScrolledwindow = Gtk::manage(new class Gtk::ScrolledWindow());
+   addQueryButton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-add")));
+   
+   Gtk::Image *image400 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-open"), Gtk::IconSize(4)));
+   Gtk::Label *label47 = Gtk::manage(new class Gtk::Label(_("Edit")));
+   Gtk::HBox *hbox40 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment26 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
+   editQueryButton = Gtk::manage(new class Gtk::Button());
+   removeQueryButton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-remove")));
+   findQueryButton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-find")));
+   
+   Gtk::VButtonBox *queryVbuttonbox = Gtk::manage(new class Gtk::VButtonBox(Gtk::BUTTONBOX_START, 0));
+   Gtk::HBox *queryHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   Gtk::Label *queryLabel = Gtk::manage(new class Gtk::Label(_("Stored queries")));
+#if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
+   queryExpander = Gtk::manage(new class Gtk::Expander());
+#else //
+   queryExpander = Gtk::manage(new class Gtk::HandleBox());
+#endif //
+   resultsVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   
+   Gtk::Label *resultsLabel = Gtk::manage(new class Gtk::Label(_("Results")));
+   indexCombobox = Gtk::manage(new class Gtk::ComboBox());
+   
+   Gtk::Image *image478 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-goto-first"), Gtk::IconSize(4)));
+   indexFirstButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::Image *image479 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-go-back"), Gtk::IconSize(4)));
+   indexBackButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::Image *image480 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-go-forward"), Gtk::IconSize(4)));
+   indexForwardButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::Image *image481 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-goto-last"), Gtk::IconSize(4)));
+   indexLastButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::HButtonBox *indexHbuttonbox = Gtk::manage(new class Gtk::HButtonBox(Gtk::BUTTONBOX_SPREAD, 0));
+   Gtk::HBox *indexButtonsHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   indexVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   
+   Gtk::Label *indexLabel = Gtk::manage(new class Gtk::Label(_("Index")));
+   viewVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   
+   Gtk::Label *viewLabel = Gtk::manage(new class Gtk::Label(_("View")));
+   mainNotebook = Gtk::manage(new class Gtk::Notebook());
+   
+   Gtk::VBox *rightVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   mainHpaned = Gtk::manage(new class Gtk::HPaned());
+   mainProgressbar = Gtk::manage(new class Gtk::ProgressBar());
+   mainStatusbar = Gtk::manage(new class Gtk::Statusbar());
+   
+   Gtk::HBox *mainHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   Gtk::VBox *vbox1 = Gtk::manage(new class Gtk::VBox(false, 0));
+   
+   sessionMenuitem_menu->items().push_back(Gtk::Menu_Helpers::StockMenuElem(Gtk::StockID("gtk-preferences")));
+   configure1 = (Gtk::ImageMenuItem *)&sessionMenuitem_menu->items().back();
+   
+   sessionMenuitem_menu->items().push_back(Gtk::Menu_Helpers::SeparatorElem());
+   separatormenuitem1 = (Gtk::MenuItem *)&sessionMenuitem_menu->items().back();
+   
+   sessionMenuitem_menu->items().push_back(Gtk::Menu_Helpers::StockMenuElem(Gtk::StockID("gtk-quit")));
+   quit1 = (Gtk::ImageMenuItem *)&sessionMenuitem_menu->items().back();
+   
+   editMenuitem_menu->items().push_back(Gtk::Menu_Helpers::StockMenuElem(Gtk::StockID("gtk-cut")));
+   cut1 = (Gtk::ImageMenuItem *)&editMenuitem_menu->items().back();
+   
+   editMenuitem_menu->items().push_back(Gtk::Menu_Helpers::StockMenuElem(Gtk::StockID("gtk-copy")));
+   copy1 = (Gtk::ImageMenuItem *)&editMenuitem_menu->items().back();
+   
+   editMenuitem_menu->items().push_back(Gtk::Menu_Helpers::StockMenuElem(Gtk::StockID("gtk-paste")));
+   paste1 = (Gtk::ImageMenuItem *)&editMenuitem_menu->items().back();
+   
+   editMenuitem_menu->items().push_back(Gtk::Menu_Helpers::StockMenuElem(Gtk::StockID("gtk-delete")));
+   delete1 = (Gtk::ImageMenuItem *)&editMenuitem_menu->items().back();
+   
+   groupresults1_menu->items().push_back(Gtk::Menu_Helpers::RadioMenuElem(_RadioMIGroup_searchenginegroup1, _("Search Engine")));
+   searchenginegroup1 = (Gtk::RadioMenuItem *)&groupresults1_menu->items().back();
+   
+   groupresults1_menu->items().push_back(Gtk::Menu_Helpers::RadioMenuElem(_RadioMIGroup_searchenginegroup1, _("Host Name")));
+   hostnamegroup1 = (Gtk::RadioMenuItem *)&groupresults1_menu->items().back();
+   
+   resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Clear List"), *image514));
+   clearresults1 = (Gtk::ImageMenuItem *)&resultsMenuitem_menu->items().back();
+   
+   resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::CheckMenuElem(_("Show Extract")));
+   showextract1 = (Gtk::CheckMenuItem *)&resultsMenuitem_menu->items().back();
+   
+   resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("Group By"), *groupresults1_menu));
+   groupresults1 = (Gtk::MenuItem *)&resultsMenuitem_menu->items().back();
+   
+   resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::SeparatorElem());
+   separator1 = (Gtk::MenuItem *)&resultsMenuitem_menu->items().back();
+   
+   resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("Vie_w")));
+   viewresults1 = (Gtk::MenuItem *)&resultsMenuitem_menu->items().back();
+   
+   resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("View Cache")));
+   viewcache1 = (Gtk::MenuItem *)&resultsMenuitem_menu->items().back();
+   
+   resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("_Index")));
+   indexresults1 = (Gtk::MenuItem *)&resultsMenuitem_menu->items().back();
+   
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("Show Label")));
+   showlabels1 = (Gtk::MenuItem *)&indexMenuitem_menu->items().back();
+   
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Import"), *image515));
+   import1 = (Gtk::ImageMenuItem *)&indexMenuitem_menu->items().back();
+   
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::SeparatorElem());
+   separator3 = (Gtk::MenuItem *)&indexMenuitem_menu->items().back();
+   
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("View")));
+   viewfromindex1 = (Gtk::MenuItem *)&indexMenuitem_menu->items().back();
+   
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Update"), *image516));
+   refreshindex1 = (Gtk::ImageMenuItem *)&indexMenuitem_menu->items().back();
+   
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Unindex"), *image517));
+   unindex1 = (Gtk::ImageMenuItem *)&indexMenuitem_menu->items().back();
+   
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Properties"), *image518));
+   showfromindex1 = (Gtk::ImageMenuItem *)&indexMenuitem_menu->items().back();
+   
+   helpMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("_About")));
+   about1 = (Gtk::MenuItem *)&helpMenuitem_menu->items().back();
+   
+   mainMenubar->items().push_back(Gtk::Menu_Helpers::MenuElem(_("_Session"), *sessionMenuitem_menu));
+   sessionMenuitem = (Gtk::MenuItem *)&mainMenubar->items().back();
+   
+   mainMenubar->items().push_back(Gtk::Menu_Helpers::MenuElem(_("_Edit"), *editMenuitem_menu));
+   editMenuitem = (Gtk::MenuItem *)&mainMenubar->items().back();
+   
+   mainMenubar->items().push_back(Gtk::Menu_Helpers::MenuElem(_("_Results"), *resultsMenuitem_menu));
+   resultsMenuitem = (Gtk::MenuItem *)&mainMenubar->items().back();
+   
+   mainMenubar->items().push_back(Gtk::Menu_Helpers::MenuElem(_("_Index"), *indexMenuitem_menu));
+   indexMenuitem = (Gtk::MenuItem *)&mainMenubar->items().back();
+   
+   mainMenubar->items().push_back(Gtk::Menu_Helpers::MenuElem(_("_Help"), *helpMenuitem_menu));
+   helpMenuitem = (Gtk::MenuItem *)&mainMenubar->items().back();
+   image514->set_alignment(0.5,0.5);
+   image514->set_padding(0,0);
+   showextract1->set_active(true);
+   searchenginegroup1->set_active(true);
+   hostnamegroup1->set_active(false);
+   image515->set_alignment(0.5,0.5);
+   image515->set_padding(0,0);
+   image516->set_alignment(0.5,0.5);
+   image516->set_padding(0,0);
+   image517->set_alignment(0.5,0.5);
+   image517->set_padding(0,0);
+   image518->set_alignment(0.5,0.5);
+   image518->set_padding(0,0);
+   image439->set_alignment(0.5,0.5);
+   image439->set_padding(0,0);
+   addIndexButton->set_flags(Gtk::CAN_FOCUS);
+   addIndexButton->set_flags(Gtk::CAN_DEFAULT);
+   addIndexButton->set_relief(Gtk::RELIEF_NORMAL);
+   addIndexButton->add(*image439);
+   image438->set_alignment(0.5,0.5);
+   image438->set_padding(0,0);
+   removeIndexButton->set_flags(Gtk::CAN_FOCUS);
+   removeIndexButton->set_flags(Gtk::CAN_DEFAULT);
+   removeIndexButton->set_relief(Gtk::RELIEF_NORMAL);
+   removeIndexButton->add(*image438);
+   indexHbox->pack_start(*addIndexButton);
+   indexHbox->pack_start(*removeIndexButton);
+   leftVbox->pack_start(*enginesVbox);
+   leftVbox->pack_start(*indexHbox, Gtk::PACK_SHRINK, 0);
+   liveQueryLabel->set_alignment(0.5,0.5);
+   liveQueryLabel->set_padding(0,0);
+   liveQueryLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   liveQueryLabel->set_line_wrap(false);
+   liveQueryLabel->set_use_markup(false);
+   liveQueryLabel->set_selectable(false);
+   liveQueryEntry->set_flags(Gtk::CAN_FOCUS);
+   liveQueryEntry->set_visibility(true);
+   liveQueryEntry->set_editable(true);
+   liveQueryEntry->set_max_length(0);
+   liveQueryEntry->set_text(_(""));
+   liveQueryEntry->set_has_frame(true);
+   liveQueryEntry->set_activates_default(false);
+   findButton->set_flags(Gtk::CAN_FOCUS);
+   findButton->set_flags(Gtk::CAN_DEFAULT);
+   findButton->set_relief(Gtk::RELIEF_NORMAL);
+   findVbuttonbox->pack_start(*findButton);
+   liveQueryHbox->pack_start(*liveQueryLabel, Gtk::PACK_SHRINK, 4);
+   liveQueryHbox->pack_start(*liveQueryEntry, Gtk::PACK_EXPAND_WIDGET, 4);
+   liveQueryHbox->pack_start(*findVbuttonbox, Gtk::PACK_SHRINK, 4);
+   queryTreeview->set_events(Gdk::BUTTON_PRESS_MASK);
+   queryTreeview->set_flags(Gtk::CAN_FOCUS);
+   queryTreeview->set_headers_visible(true);
+   queryTreeview->set_rules_hint(false);
+   queryTreeview->set_reorderable(false);
+   queryTreeview->set_enable_search(false);
+   queryScrolledwindow->set_flags(Gtk::CAN_FOCUS);
+   queryScrolledwindow->set_shadow_type(Gtk::SHADOW_NONE);
+   queryScrolledwindow->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+   queryScrolledwindow->property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+   queryScrolledwindow->add(*queryTreeview);
+   addQueryButton->set_flags(Gtk::CAN_FOCUS);
+   addQueryButton->set_flags(Gtk::CAN_DEFAULT);
+   addQueryButton->set_border_width(4);
+   addQueryButton->set_relief(Gtk::RELIEF_NORMAL);
+   image400->set_alignment(0.5,0.5);
+   image400->set_padding(0,0);
+   label47->set_alignment(0.5,0.5);
+   label47->set_padding(0,0);
+   label47->set_justify(Gtk::JUSTIFY_LEFT);
+   label47->set_line_wrap(false);
+   label47->set_use_markup(false);
+   label47->set_selectable(false);
+   hbox40->pack_start(*image400, Gtk::PACK_SHRINK, 0);
+   hbox40->pack_start(*label47, Gtk::PACK_SHRINK, 0);
+   alignment26->add(*hbox40);
+   editQueryButton->set_flags(Gtk::CAN_FOCUS);
+   editQueryButton->set_flags(Gtk::CAN_DEFAULT);
+   editQueryButton->set_border_width(4);
+   editQueryButton->set_relief(Gtk::RELIEF_NORMAL);
+   editQueryButton->add(*alignment26);
+   removeQueryButton->set_flags(Gtk::CAN_FOCUS);
+   removeQueryButton->set_flags(Gtk::CAN_DEFAULT);
+   removeQueryButton->set_border_width(4);
+   removeQueryButton->set_relief(Gtk::RELIEF_NORMAL);
+   findQueryButton->set_flags(Gtk::CAN_FOCUS);
+   findQueryButton->set_flags(Gtk::CAN_DEFAULT);
+   findQueryButton->set_border_width(4);
+   findQueryButton->set_relief(Gtk::RELIEF_NORMAL);
+   queryVbuttonbox->pack_start(*addQueryButton);
+   queryVbuttonbox->pack_start(*editQueryButton);
+   queryVbuttonbox->pack_start(*removeQueryButton);
+   queryVbuttonbox->pack_start(*findQueryButton);
+   queryHbox->pack_start(*queryScrolledwindow);
+   queryHbox->pack_start(*queryVbuttonbox, Gtk::PACK_SHRINK, 0);
+   queryLabel->set_alignment(0.5,0.5);
+   queryLabel->set_padding(0,0);
+   queryLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   queryLabel->set_line_wrap(false);
+   queryLabel->set_use_markup(false);
+   queryLabel->set_selectable(false);
+   queryExpander->set_flags(Gtk::CAN_FOCUS);
+#if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
+   queryExpander->set_expanded(false);
+   queryExpander->set_spacing(0);
+#endif //
+   queryExpander->add(*queryHbox);
+#if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
+   queryExpander->set_label_widget(*queryLabel);
+#endif //
+   resultsLabel->set_alignment(0.5,0.5);
+   resultsLabel->set_padding(0,0);
+   resultsLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   resultsLabel->set_line_wrap(false);
+   resultsLabel->set_use_markup(false);
+   resultsLabel->set_selectable(false);
+   image478->set_alignment(0.5,0.5);
+   image478->set_padding(0,0);
+   indexFirstButton->set_flags(Gtk::CAN_FOCUS);
+   indexFirstButton->set_flags(Gtk::CAN_DEFAULT);
+   indexFirstButton->set_relief(Gtk::RELIEF_NORMAL);
+   indexFirstButton->add(*image478);
+   image479->set_alignment(0.5,0.5);
+   image479->set_padding(0,0);
+   indexBackButton->set_flags(Gtk::CAN_FOCUS);
+   indexBackButton->set_flags(Gtk::CAN_DEFAULT);
+   indexBackButton->set_relief(Gtk::RELIEF_NORMAL);
+   indexBackButton->add(*image479);
+   image480->set_alignment(0.5,0.5);
+   image480->set_padding(0,0);
+   indexForwardButton->set_flags(Gtk::CAN_FOCUS);
+   indexForwardButton->set_flags(Gtk::CAN_DEFAULT);
+   indexForwardButton->set_relief(Gtk::RELIEF_NORMAL);
+   indexForwardButton->add(*image480);
+   image481->set_alignment(0.5,0.5);
+   image481->set_padding(0,0);
+   indexLastButton->set_flags(Gtk::CAN_FOCUS);
+   indexLastButton->set_flags(Gtk::CAN_DEFAULT);
+   indexLastButton->set_relief(Gtk::RELIEF_NORMAL);
+   indexLastButton->add(*image481);
+   indexHbuttonbox->pack_start(*indexFirstButton);
+   indexHbuttonbox->pack_start(*indexBackButton);
+   indexHbuttonbox->pack_start(*indexForwardButton);
+   indexHbuttonbox->pack_start(*indexLastButton);
+   indexButtonsHbox->pack_start(*indexCombobox, Gtk::PACK_SHRINK, 4);
+   indexButtonsHbox->pack_start(*indexHbuttonbox, Gtk::PACK_SHRINK, 4);
+   indexVbox->pack_start(*indexButtonsHbox, Gtk::PACK_SHRINK, 4);
+   indexLabel->set_alignment(0.5,0.5);
+   indexLabel->set_padding(0,0);
+   indexLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   indexLabel->set_line_wrap(false);
+   indexLabel->set_use_markup(false);
+   indexLabel->set_selectable(false);
+   viewLabel->set_alignment(0.5,0.5);
+   viewLabel->set_padding(0,0);
+   viewLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   viewLabel->set_line_wrap(false);
+   viewLabel->set_use_markup(false);
+   viewLabel->set_selectable(false);
+   mainNotebook->set_flags(Gtk::CAN_FOCUS);
+   mainNotebook->set_show_tabs(true);
+   mainNotebook->set_show_border(true);
+   mainNotebook->set_tab_pos(Gtk::POS_TOP);
+   mainNotebook->set_scrollable(false);
+   mainNotebook->append_page(*resultsVbox, *resultsLabel);
+   mainNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   mainNotebook->append_page(*indexVbox, *indexLabel);
+   mainNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   mainNotebook->append_page(*viewVbox, *viewLabel);
+   mainNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   rightVbox->pack_start(*liveQueryHbox, Gtk::PACK_SHRINK, 0);
+   rightVbox->pack_start(*queryExpander, Gtk::PACK_SHRINK, 0);
+   rightVbox->pack_start(*mainNotebook, Gtk::PACK_EXPAND_WIDGET, 4);
+   mainHpaned->set_flags(Gtk::CAN_FOCUS);
+   mainHpaned->set_position(105);
+   mainHpaned->pack1(*leftVbox, Gtk::SHRINK);
+   mainHpaned->pack2(*rightVbox, Gtk::EXPAND|Gtk::SHRINK);
+   mainHbox->pack_start(*mainProgressbar, Gtk::PACK_SHRINK, 0);
+   mainHbox->pack_start(*mainStatusbar);
+   vbox1->pack_start(*mainMenubar, Gtk::PACK_SHRINK, 0);
+   vbox1->pack_start(*mainHpaned, Gtk::PACK_EXPAND_WIDGET, 4);
+   vbox1->pack_start(*mainHbox, Gtk::PACK_SHRINK, 0);
+   mainWindow->set_events(Gdk::BUTTON_PRESS_MASK);
+   mainWindow->set_title(_("Pinot"));
+   mainWindow->set_default_size(400,-1);
+   mainWindow->set_modal(false);
+   mainWindow->property_window_position().set_value(Gtk::WIN_POS_NONE);
+   mainWindow->set_resizable(true);
+   mainWindow->property_destroy_with_parent().set_value(false);
+   mainWindow->add(*vbox1);
+   configure1->show();
+   separatormenuitem1->show();
+   quit1->show();
+   sessionMenuitem->show();
+   cut1->show();
+   copy1->show();
+   paste1->show();
+   delete1->show();
+   editMenuitem->show();
+   image514->show();
+   clearresults1->show();
+   showextract1->show();
+   searchenginegroup1->show();
+   hostnamegroup1->show();
+   groupresults1->show();
+   separator1->show();
+   viewresults1->show();
+   viewcache1->show();
+   indexresults1->show();
+   resultsMenuitem->show();
+   showlabels1->show();
+   image515->show();
+   import1->show();
+   separator3->show();
+   viewfromindex1->show();
+   image516->show();
+   refreshindex1->show();
+   image517->show();
+   unindex1->show();
+   image518->show();
+   showfromindex1->show();
+   indexMenuitem->show();
+   about1->show();
+   helpMenuitem->show();
+   mainMenubar->show();
+   enginesVbox->show();
+   image439->show();
+   addIndexButton->show();
+   image438->show();
+   removeIndexButton->show();
+   indexHbox->show();
+   leftVbox->show();
+   liveQueryLabel->show();
+   liveQueryEntry->show();
+   findButton->show();
+   findVbuttonbox->show();
+   liveQueryHbox->show();
+   queryTreeview->show();
+   queryScrolledwindow->show();
+   addQueryButton->show();
+   image400->show();
+   label47->show();
+   hbox40->show();
+   alignment26->show();
+   editQueryButton->show();
+   removeQueryButton->show();
+   findQueryButton->show();
+   queryVbuttonbox->show();
+   queryHbox->show();
+   queryLabel->show();
+   queryExpander->show();
+   resultsVbox->show();
+   resultsLabel->show();
+   indexCombobox->show();
+   image478->show();
+   indexFirstButton->show();
+   image479->show();
+   indexBackButton->show();
+   image480->show();
+   indexForwardButton->show();
+   image481->show();
+   indexLastButton->show();
+   indexHbuttonbox->show();
+   indexButtonsHbox->show();
+   indexVbox->show();
+   indexLabel->show();
+   viewVbox->show();
+   viewLabel->show();
+   mainNotebook->show();
+   rightVbox->show();
+   mainHpaned->show();
+   mainProgressbar->show();
+   mainStatusbar->show();
+   mainHbox->show();
+   vbox1->show();
+   mainWindow->show();
+   configure1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_configure_activate), false);
+   quit1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_quit_activate), false);
+   cut1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_cut_activate), false);
+   copy1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_copy_activate), false);
+   paste1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_paste_activate), false);
+   delete1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_delete_activate), false);
+   clearresults1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_clearresults_activate), false);
+   showextract1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_showextract_activate), false);
+   searchenginegroup1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_groupresults_activate), false);
+   viewresults1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_viewresults_activate), false);
+   viewcache1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_viewcache_activate), false);
+   indexresults1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_indexresults_activate), false);
+   import1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_import_activate), false);
+   viewfromindex1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_viewfromindex_activate), false);
+   refreshindex1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_refreshindex_activate), false);
+   unindex1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_unindex_activate), false);
+   showfromindex1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_showfromindex_activate), false);
+   about1->signal_activate().connect(SigC::slot(*this, &mainWindow_glade::on_about_activate), false);
+   addIndexButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_addIndexButton_clicked), false);
+   removeIndexButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_removeIndexButton_clicked), false);
+   findButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_findButton_clicked), false);
+   queryTreeview->signal_button_press_event().connect(SigC::slot(*this, &mainWindow_glade::on_queryTreeview_button_press_event), false);
+   addQueryButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_addQueryButton_clicked), false);
+   editQueryButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_editQueryButton_clicked), false);
+   removeQueryButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_removeQueryButton_clicked), false);
+   findQueryButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_findQueryButton_clicked), false);
+   indexCombobox->signal_changed().connect(SigC::slot(*this, &mainWindow_glade::on_indexCombobox_changed), false);
+   indexFirstButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_indexFirstButton_clicked), false);
+   indexBackButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_indexBackButton_clicked), false);
+   indexForwardButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_indexForwardButton_clicked), false);
+   indexLastButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_indexLastButton_clicked), false);
+   mainWindow->signal_delete_event().connect(SigC::slot(*this, &mainWindow_glade::on_mainWindow_delete_event), false);
+}
+
+mainWindow_glade::~mainWindow_glade()
+{  delete gmm_data;
+}


Property changes on: trunk/UI/GTK2/src/mainWindow_glade.cc
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/mainWindow_glade.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/mainWindow_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,152 @@
+// generated 2005/11/6 16:50:21 SGT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/mainWindow.hh and./src/mainWindow.cc
+
+#ifndef _MAINWINDOW_GLADE_HH
+#  define _MAINWINDOW_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include <gtkmm/accelgroup.h>
+
+class GlademmData
+{  
+        
+        Glib::RefPtr<Gtk::AccelGroup> accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr<Gtk::AccelGroup> ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr<Gtk::AccelGroup>  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include <gtkmm/window.h>
+#include <gtkmm/imagemenuitem.h>
+#include <gtkmm/menuitem.h>
+#include <gtkmm/checkmenuitem.h>
+#include <gtkmm/radiomenuitem.h>
+#include <gtkmm/box.h>
+#include <gtkmm/button.h>
+#include <gtkmm/entry.h>
+#include <gtkmm/treeview.h>
+#if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
+#include <gtkmm/expander.h>
+#else //
+#include <gtkmm/handlebox.h>
+#endif //
+#include <gtkmm/combobox.h>
+#include <gtkmm/notebook.h>
+#include <gtkmm/paned.h>
+#include <gtkmm/progressbar.h>
+#include <gtkmm/statusbar.h>
+
+class mainWindow_glade : public Gtk::Window
+{  
+        
+        GlademmData *gmm_data;
+public:
+        class Gtk::Window * mainWindow;
+protected:
+        class Gtk::ImageMenuItem * configure1;
+        class Gtk::MenuItem * separatormenuitem1;
+        class Gtk::ImageMenuItem * quit1;
+        class Gtk::MenuItem * sessionMenuitem;
+        class Gtk::ImageMenuItem * cut1;
+        class Gtk::ImageMenuItem * copy1;
+        class Gtk::ImageMenuItem * paste1;
+        class Gtk::ImageMenuItem * delete1;
+        class Gtk::MenuItem * editMenuitem;
+        class Gtk::ImageMenuItem * clearresults1;
+        class Gtk::CheckMenuItem * showextract1;
+        class Gtk::RadioMenuItem * searchenginegroup1;
+        class Gtk::RadioMenuItem * hostnamegroup1;
+        class Gtk::MenuItem * viewresults1;
+        class Gtk::MenuItem * viewcache1;
+        class Gtk::MenuItem * indexresults1;
+        class Gtk::MenuItem * resultsMenuitem;
+        class Gtk::MenuItem * showlabels1;
+        class Gtk::ImageMenuItem * import1;
+        class Gtk::MenuItem * viewfromindex1;
+        class Gtk::ImageMenuItem * refreshindex1;
+        class Gtk::ImageMenuItem * unindex1;
+        class Gtk::ImageMenuItem * showfromindex1;
+        class Gtk::MenuItem * indexMenuitem;
+        class Gtk::MenuItem * about1;
+        class Gtk::MenuItem * helpMenuitem;
+        class Gtk::VBox * enginesVbox;
+        class Gtk::Button * addIndexButton;
+        class Gtk::Button * removeIndexButton;
+        class Gtk::Entry * liveQueryEntry;
+        class Gtk::Button * findButton;
+        class Gtk::TreeView * queryTreeview;
+        class Gtk::Button * addQueryButton;
+        class Gtk::Button * editQueryButton;
+        class Gtk::Button * removeQueryButton;
+        class Gtk::Button * findQueryButton;
+#if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
+        class Gtk::Expander * queryExpander;
+#else //
+        class Gtk::HandleBox * queryExpander;
+#endif //
+        class Gtk::VBox * resultsVbox;
+        class Gtk::ComboBox * indexCombobox;
+        class Gtk::Button * indexFirstButton;
+        class Gtk::Button * indexBackButton;
+        class Gtk::Button * indexForwardButton;
+        class Gtk::Button * indexLastButton;
+        class Gtk::VBox * indexVbox;
+        class Gtk::VBox * viewVbox;
+        class Gtk::Notebook * mainNotebook;
+        class Gtk::HPaned * mainHpaned;
+        class Gtk::ProgressBar * mainProgressbar;
+        class Gtk::Statusbar * mainStatusbar;
+        
+        mainWindow_glade();
+        
+        ~mainWindow_glade();
+private:
+        virtual void on_configure_activate() = 0;
+        virtual void on_quit_activate() = 0;
+        virtual void on_cut_activate() = 0;
+        virtual void on_copy_activate() = 0;
+        virtual void on_paste_activate() = 0;
+        virtual void on_delete_activate() = 0;
+        virtual void on_clearresults_activate() = 0;
+        virtual void on_showextract_activate() = 0;
+        virtual void on_groupresults_activate() = 0;
+        virtual void on_viewresults_activate() = 0;
+        virtual void on_viewcache_activate() = 0;
+        virtual void on_indexresults_activate() = 0;
+        virtual void on_import_activate() = 0;
+        virtual void on_viewfromindex_activate() = 0;
+        virtual void on_refreshindex_activate() = 0;
+        virtual void on_unindex_activate() = 0;
+        virtual void on_showfromindex_activate() = 0;
+        virtual void on_about_activate() = 0;
+        virtual void on_addIndexButton_clicked() = 0;
+        virtual void on_removeIndexButton_clicked() = 0;
+        virtual void on_findButton_clicked() = 0;
+        virtual bool on_queryTreeview_button_press_event(GdkEventButton *ev) = 0;
+        virtual void on_addQueryButton_clicked() = 0;
+        virtual void on_editQueryButton_clicked() = 0;
+        virtual void on_removeQueryButton_clicked() = 0;
+        virtual void on_findQueryButton_clicked() = 0;
+        virtual void on_indexCombobox_changed() = 0;
+        virtual void on_indexFirstButton_clicked() = 0;
+        virtual void on_indexBackButton_clicked() = 0;
+        virtual void on_indexForwardButton_clicked() = 0;
+        virtual void on_indexLastButton_clicked() = 0;
+        virtual bool on_mainWindow_delete_event(GdkEventAny *ev) = 0;
+};
+#endif


Property changes on: trunk/UI/GTK2/src/mainWindow_glade.hh
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/pinot.cpp
===================================================================
--- trunk/UI/GTK2/src/pinot.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/pinot.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,152 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <libintl.h>
+#include <iostream>
+#include <fstream>
+#include <glibmm.h>
+#include <glibmm/thread.h>
+#include <glibmm/ustring.h>
+#include <glibmm/convert.h>
+#include <gtkmm/main.h>
+
+#include "TokenizerFactory.h"
+#include "Languages.h"
+#include "ActionHistory.h"
+#include "LabelManager.h"
+#include "QueryHistory.h"
+#include "ViewHistory.h"
+#include "XapianDatabase.h"
+#include "XapianDatabaseFactory.h"
+#include "config.h"
+#include "NLS.h"
+#include "PinotSettings.h"
+#include "mainWindow.hh"
+
+using namespace std;
+
+ofstream outputFile;
+streambuf *coutbuf = NULL;
+streambuf *cerrbuf = NULL;
+
+void closeAll(void)
+{
+	cout << "Exiting..." << endl;
+
+	// Save the settings
+	PinotSettings &settings = PinotSettings::getInstance();
+	if (settings.save() == false)
+	{
+		cerr << _("Couldn't save configuration file") << endl;
+	}
+
+	// Close all indexes we may have opened
+	XapianDatabaseFactory::closeAll();
+
+	// Close the tokenizer libraries
+	TokenizerFactory::unloadTokenizers();
+
+	// Restore the stream buffers
+	if (coutbuf != NULL)
+	{
+		cout.rdbuf(coutbuf);
+	}
+	if (cerrbuf != NULL)
+	{
+		cerr.rdbuf(cerrbuf);
+	}
+}
+
+int main(int argc, char **argv)
+{
+#if defined(ENABLE_NLS)
+	bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
+	textdomain (GETTEXT_PACKAGE);
+#endif //ENABLE_NLS
+
+	Glib::thread_init();
+	Gtk::Main m(&argc, &argv);
+
+	// This will create the necessary directories on the first run
+	PinotSettings &settings = PinotSettings::getInstance();
+
+	string confDirectory = PinotSettings::getConfigurationDirectory();
+	chdir(confDirectory.c_str());
+
+	// Redirect cout and cerr to a file
+	string logFileName = confDirectory;
+	logFileName += "/pinot.log";
+	outputFile.open(logFileName.c_str());
+	coutbuf = cout.rdbuf();
+	cerrbuf = cerr.rdbuf();
+	cout.rdbuf(outputFile.rdbuf());
+	cerr.rdbuf(outputFile.rdbuf());
+
+	// Load the settings
+	settings.load();
+	settings.loadSearchEngines("/usr/share/pinot/engines");
+	settings.loadSearchEngines(confDirectory + string("/engines"));
+	// Load tokenizer libraries, if any
+	TokenizerFactory::loadTokenizers("/usr/share/pinot/tokenizers");
+	TokenizerFactory::loadTokenizers(confDirectory + string("/tokenizers"));
+
+	// Ensure Xapian will be able to deal with internal indices
+	if (XapianDatabaseFactory::getDatabase(settings.m_indexLocation, false) == NULL)
+	{
+		cerr << _("Index") << " " << settings.m_indexLocation << " "
+			<< _("is not valid, please check") << endl;
+	}
+	if (XapianDatabaseFactory::getDatabase(settings.m_mailIndexLocation, false) == NULL)
+	{
+		cerr << _("Index") << " " << settings.m_mailIndexLocation << " "
+			<< _("is not valid, please check") << endl;
+	}
+
+	// Do the same for the history database
+	if ((settings.m_historyDatabase.empty() == true) ||
+		(ActionHistory::create(settings.m_historyDatabase) == false) ||
+		(LabelManager::create(settings.m_historyDatabase) == false) ||
+		(QueryHistory::create(settings.m_historyDatabase) == false) ||
+		(ViewHistory::create(settings.m_historyDatabase) == false))
+	{
+		cerr << _("History database") << " " << settings.m_historyDatabase << " "
+			<< _("couldn't be created") << endl;
+	}
+
+	atexit(closeAll);
+
+	// Localize language names
+	Languages::setIntlName(0, _("Danish"));
+	Languages::setIntlName(1, _("Dutch"));
+	Languages::setIntlName(2, _("English"));
+	Languages::setIntlName(3, _("Finnish"));
+	Languages::setIntlName(4, _("French"));
+	Languages::setIntlName(5, _("German"));
+	Languages::setIntlName(6, _("Italian"));
+	Languages::setIntlName(7, _("Norwegian"));
+	Languages::setIntlName(8, _("Portuguese"));
+	Languages::setIntlName(9, _("Russian"));
+	Languages::setIntlName(10, _("Spanish"));
+	Languages::setIntlName(11, _("Swedish"));
+
+	// Create and open the main dialog box
+	mainWindow mainBox;
+	m.run(mainBox);
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/UI/GTK2/src/pinot.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/prefsDialog.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/prefsDialog.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,514 @@
+// generated 2003/5/18 21:15:37 BST by fabrice at amra.dyndns.org.(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to prefsDialog.cc_new
+
+// This file is for your program, I won't touch it again!
+
+#include <stdlib.h>
+#include <iostream>
+#include <glibmm/convert.h>
+#include <gdkmm/color.h>
+#include <gtkmm/colorselection.h>
+#include <gtkmm/menu.h>
+#include <gtkmm/messagedialog.h>
+
+#include "MIMEScanner.h"
+#include "SearchEngineFactory.h"
+#include "LabelManager.h"
+#include "QueryHistory.h"
+#include "Url.h"
+#include "config.h"
+#include "NLS.h"
+#include "PinotUtils.h"
+#include "importDialog.hh"
+#include "prefsDialog.hh"
+
+using namespace std;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+unsigned int prefsDialog::m_maxDirLevel = 1;
+
+prefsDialog::prefsDialog() :
+	m_settings(PinotSettings::getInstance()), prefsDialog_glade()
+{
+	// Associate the columns model to the view combo
+	m_refViewTree = ListStore::create(m_viewColumns);
+	viewCombobox->set_model(m_refViewTree);
+	viewCombobox->pack_start(m_viewColumns.m_name);
+	// Populate
+	populate_comboboxes();
+
+	// Initialize widgets
+	// Ignore robots directives
+	ignoreRobotsCheckbutton->set_active(m_settings.m_ignoreRobotsDirectives);
+	if (m_settings.m_googleAPIKey.empty() == false)
+	{
+		apiKeyEntry->set_text(m_settings.m_googleAPIKey);
+	}
+	// Browser command
+	if (m_settings.m_browserCommand.empty() == false)
+	{
+		browserEntry->set_text(m_settings.m_browserCommand);
+	}
+	// Browser entry field and button
+	browserEntry->set_sensitive(m_settings.m_browseResults);
+	browserButton->set_sensitive(m_settings.m_browseResults);
+
+	// Associate the columns model to the labels tree
+	m_refLabelsTree = ListStore::create(m_labelsColumns);
+	labelsTreeview->set_model(m_refLabelsTree);
+	labelsTreeview->append_column_editable(_("Name"), m_labelsColumns.m_name);
+	// Allow only single selection
+	labelsTreeview->get_selection()->set_mode(SELECTION_SINGLE);
+	populate_labelsTreeview();
+
+	// Associate the columns model to the mail accounts tree
+	m_refMailTree = ListStore::create(m_mailColumns);
+	mailTreeview->set_model(m_refMailTree);
+	mailTreeview->append_column(_("Location"), m_mailColumns.m_location);
+	mailTreeview->append_column(_("MIME Type"), m_mailColumns.m_type);
+	// Allow only single selection
+	mailTreeview->get_selection()->set_mode(SELECTION_SINGLE);
+	populate_mailTreeview();
+
+	// Hide the Google API entry field ?
+	if (SearchEngineFactory::isSupported("googleapi") == false)
+	{
+		apiKeyLabel->hide();
+		apiKeyEntry->hide();
+	}
+}
+
+prefsDialog::~prefsDialog()
+{
+}
+
+const set<string> &prefsDialog::getMailLabelsToDelete(void) const
+{
+	// This will have been reset by save_labelsTreeview()
+	// and set by save_mailTreeview() !
+	return m_deletedLabels;
+}
+
+void prefsDialog::populate_comboboxes()
+{
+	TreeModel::iterator iter = m_refViewTree->append();
+	TreeModel::Row row = *iter;
+	row[m_viewColumns.m_name] = _("In internal viewer");
+	iter = m_refViewTree->append();
+	row = *iter;
+	row[m_viewColumns.m_name] = _("In browser");
+	// Default results view
+	if (m_settings.m_browseResults == false)
+	{
+		viewCombobox->set_active(0);
+	}
+	else
+	{
+		viewCombobox->set_active(1);
+	}
+}
+
+void prefsDialog::populate_labelsTreeview()
+{
+	TreeModel::iterator iter;
+	TreeModel::Row row;
+
+	if (m_settings.m_labels.empty() == true)
+	{
+		// These buttons will stay disabled until labels are added to the list
+		editLabelButton->set_sensitive(false);
+		removeLabelButton->set_sensitive(false);
+		return;
+	}
+
+	// Populate the tree
+	for (set<PinotSettings::Label>::iterator labelIter = m_settings.m_labels.begin();
+		labelIter != m_settings.m_labels.end();
+		++labelIter)
+	{
+		// Create a new row
+		iter = m_refLabelsTree->append();
+		row = *iter;
+		// Set its name and colour
+		row[m_labelsColumns.m_name] = labelIter->m_name;
+		row[m_labelsColumns.m_oldName] = labelIter->m_name;
+		Color labelColour;
+		labelColour.set_rgb(labelIter->m_red, labelIter->m_green, labelIter->m_blue);
+		row[m_labelsColumns.m_colour] = labelColour;
+		// This allows to differentiate existing labels from new labels the user may create
+		row[m_labelsColumns.m_enabled] = true;
+	}
+
+	editLabelButton->set_sensitive(true);
+	removeLabelButton->set_sensitive(true);
+}
+
+bool prefsDialog::save_labelsTreeview()
+{
+	LabelManager labelMan(m_settings.m_historyDatabase);
+
+	// Clear the current settings
+	m_settings.m_labels.clear();
+
+	// Go through the labels tree
+	TreeModel::Children children = m_refLabelsTree->children();
+	if (children.empty() == false)
+	{
+		TreeModel::Children::iterator iter = children.begin();
+		for (; iter != children.end(); ++iter)
+		{
+			TreeModel::Row row = *iter;
+
+			// Add this new label to the settings
+			PinotSettings::Label label;
+			label.m_name = row[m_labelsColumns.m_name];
+			ustring oldName = row[m_labelsColumns.m_oldName];
+			// Was this label renamed ?
+			if ((row[m_labelsColumns.m_enabled] == true) &&
+				(label.m_name != oldName))
+			{
+				// Yes, it was
+				labelMan.renameLabel(locale_from_utf8(oldName), locale_from_utf8(label.m_name));
+			}
+			// Check user didn't recreate this label after having deleted it
+			set<string>::iterator labelIter = m_deletedLabels.find(locale_from_utf8(label.m_name));
+			if (labelIter != m_deletedLabels.end())
+			{
+				m_deletedLabels.erase(labelIter);
+			}
+
+			Color labelColour = row[m_labelsColumns.m_colour];
+			label.m_red = labelColour.get_red();
+			label.m_green = labelColour.get_green();
+			label.m_blue = labelColour.get_blue();
+#ifdef DEBUG
+			cout << "prefsDialog::save_labelsTreeview: " << label.m_name << endl;
+#endif
+			m_settings.m_labels.insert(label);
+		}
+	}
+
+	// Remove all references to labels that have been deleted
+	for (set<string>::iterator labelIter = m_deletedLabels.begin(); labelIter != m_deletedLabels.end(); ++labelIter)
+	{
+		labelMan.deleteLabel(*labelIter);
+	}
+	m_deletedLabels.clear();
+
+	return true;
+}
+
+void prefsDialog::populate_mailTreeview()
+{
+	TreeModel::iterator iter;
+	TreeModel::Row row;
+
+	if (m_settings.m_mailAccounts.empty() == true)
+	{
+		// These buttons will stay disabled until labels are added to the list
+		editAccountButton->set_sensitive(false);
+		removeAccountButton->set_sensitive(false);
+		return;
+	}
+
+	// Populate the tree
+	for (set<PinotSettings::MailAccount>::iterator mailIter = m_settings.m_mailAccounts.begin();
+		mailIter != m_settings.m_mailAccounts.end();
+		++mailIter)
+	{
+		// Create a new row
+		iter = m_refMailTree->append();
+		row = *iter;
+		// Set its name, type and minium date
+		row[m_mailColumns.m_location] = mailIter->m_name;
+		row[m_mailColumns.m_type] = mailIter->m_type;
+		row[m_mailColumns.m_mTime] = mailIter->m_modTime;
+		row[m_mailColumns.m_minDate] = mailIter->m_lastMessageTime;
+	}
+
+	editAccountButton->set_sensitive(true);
+	removeAccountButton->set_sensitive(true);
+}
+
+bool prefsDialog::save_mailTreeview()
+{
+	// Clear the current settings
+	m_settings.m_mailAccounts.clear();
+
+	// Go through the mail accounts tree
+	TreeModel::Children children = m_refMailTree->children();
+	if (children.empty() == false)
+	{
+		TreeModel::Children::iterator iter = children.begin();
+		for (; iter != children.end(); ++iter)
+		{
+			TreeModel::Row row = *iter;
+			PinotSettings::MailAccount mailAccount;
+
+			ustring mimeType = row[m_mailColumns.m_type];
+			if (mimeType == "text/x-mail")
+			{
+				// Add this new mail account to the settings
+				mailAccount.m_name = row[m_mailColumns.m_location];
+				mailAccount.m_type = mimeType;
+				mailAccount.m_modTime = row[m_mailColumns.m_mTime];
+				mailAccount.m_lastMessageTime = row[m_mailColumns.m_minDate];
+
+				// Check user didn't recreate this mail account after having deleted it
+				set<ustring>::iterator mailIter = m_deletedMail.find(mailAccount.m_name);
+				if (mailIter != m_deletedMail.end())
+				{
+					m_deletedMail.erase(mailIter);
+				}
+
+#ifdef DEBUG
+				cout << "prefsDialog::save_mailTreeview: " << mailAccount.m_name << endl;
+#endif
+				m_settings.m_mailAccounts.insert(mailAccount);
+			}
+#ifdef DEBUG
+			else cout << "prefsDialog::save_mailTreeview: format " << mimeType
+				<< ", file " << row[m_mailColumns.m_location] << ", is not supported" << endl;
+#endif
+		}
+	}
+
+	// Remove all documents from deleted mail accounts
+	for (set<ustring>::iterator mailIter = m_deletedMail.begin(); mailIter != m_deletedMail.end(); ++mailIter)
+	{
+		string sourceLabel = "mailbox://";
+		sourceLabel += *mailIter;
+
+		// Reuse the labels list
+		m_deletedLabels.insert(sourceLabel);
+#ifdef DEBUG
+		cout << "prefsDialog::save_mailTreeview: will unindex documents from " << *mailIter << endl;
+#endif
+	}
+
+	return true;
+}
+
+void prefsDialog::on_message_import(DocumentInfo docInfo)
+{
+	Url urlObj(docInfo.getLocation());
+	string mimeType = docInfo.getType();
+
+	if ((urlObj.getProtocol() == "file") &&
+		(mimeType == "text/x-mail"))
+	{
+		string fileName = urlObj.getLocation();
+		fileName += "/";
+		fileName += urlObj.getFile();
+
+		// Create a new entry in the mail accounts list
+		TreeModel::iterator iter = m_refMailTree->append();
+		TreeModel::Row row = *iter;
+
+		row[m_mailColumns.m_location] = locale_to_utf8(fileName);
+		row[m_mailColumns.m_type] = locale_to_utf8(mimeType);
+		row[m_mailColumns.m_mTime] = 0;
+		row[m_mailColumns.m_minDate] = 0;
+	}
+
+	// Enable these buttons
+	editAccountButton->set_sensitive(true);
+	removeAccountButton->set_sensitive(true);
+}
+
+void prefsDialog::on_prefsOkbutton_clicked()
+{
+	// Synchronise widgets with settings
+	m_settings.m_ignoreRobotsDirectives = ignoreRobotsCheckbutton->get_active();
+	// Default results view mode
+	int viewMode = viewCombobox->get_active_row_number();
+	if (viewMode == 0)
+	{
+		// Source
+		m_settings.m_browseResults = false;
+	}
+	else
+	{
+		// Browser
+		m_settings.m_browseResults = true;
+	}
+	m_settings.m_browserCommand = browserEntry->get_text();
+	m_settings.m_googleAPIKey = apiKeyEntry->get_text();
+
+	// Validate the current labels and mail accounts
+	save_labelsTreeview();
+	save_mailTreeview();
+}
+
+void prefsDialog::on_viewCombobox_changed()
+{
+	bool browseResults = true;
+
+	// Enable the browser entry field and button only if browsing is enabled
+	if (viewCombobox->get_active_row_number() == 0)
+	{
+		browseResults = false;
+	}
+
+	browserEntry->set_sensitive(browseResults);
+	browserButton->set_sensitive(browseResults);
+}
+
+void prefsDialog::on_browserButton_clicked()
+{
+	ustring browserCmd = browserEntry->get_text();
+	if (select_file_name(*this, _("Browser location"), browserCmd, true) == true)
+	{
+		browserEntry->set_text(browserCmd);
+	}
+}
+
+void prefsDialog::on_addLabelButton_clicked()
+{
+	// Now create a new entry in the labels list
+	TreeModel::iterator iter = m_refLabelsTree->append();
+	TreeModel::Row row = *iter;
+	row[m_labelsColumns.m_name] = locale_to_utf8(_("New Label"));
+	// This marks the label as new
+	row[m_labelsColumns.m_enabled] = false;
+	// FIXME: initialize the colour to something meaningful, depending on the current theme perhaps ?
+	Color labelColour;
+	labelColour.set_rgb(0, 0, 0);
+	row[m_labelsColumns.m_colour] = labelColour;
+
+	// Enable these buttons
+	editLabelButton->set_sensitive(true);
+	removeLabelButton->set_sensitive(true);
+}
+
+void prefsDialog::on_editLabelButton_clicked()
+{
+	// Get the selected label in the list
+	TreeModel::iterator iter = labelsTreeview->get_selection()->get_selected();
+	if (iter)
+	{
+		TreeModel::Row row = *iter;
+		ustring dialogTitle = row[m_labelsColumns.m_name];
+		dialogTitle += " ";
+		dialogTitle += _("Colour");
+		Color labelColour = row[m_labelsColumns.m_colour];
+
+		ColorSelectionDialog colorSelector(dialogTitle);
+		ColorSelection *colorSel = colorSelector.get_colorsel();
+		if (colorSel != NULL)
+		{
+			colorSel->set_has_opacity_control(false);
+			colorSel->set_current_color(labelColour);
+		}
+		colorSelector.set_transient_for(*this);
+		colorSelector.show();
+		int result = colorSelector.run();
+		if (result == RESPONSE_OK)
+		{
+			// Retrieve the chosen colour
+			labelColour = colorSel->get_current_color();
+#ifdef DEBUG
+			cout << "prefsDialog::on_editLabelButton_clicked: selected " << labelColour.get_red() << " " << labelColour.get_green() << " " << labelColour.get_blue() << endl;
+#endif
+
+			row[m_labelsColumns.m_colour] = labelColour;
+		}
+	}
+}
+
+void prefsDialog::on_removeLabelButton_clicked()
+{
+	// Get the selected label in the list
+	TreeModel::iterator iter = labelsTreeview->get_selection()->get_selected();
+	if (iter)
+	{
+		// Unselect
+		labelsTreeview->get_selection()->unselect(iter);
+		// Select another row
+		TreeModel::Path path = m_refLabelsTree->get_path(iter);
+		path.next();
+		labelsTreeview->get_selection()->select(path);
+		// Erase
+		TreeModel::Row row = *iter;
+		m_deletedLabels.insert(locale_from_utf8(row[m_labelsColumns.m_name]));
+		m_refLabelsTree->erase(row);
+
+		TreeModel::Children children = m_refLabelsTree->children();
+		if (children.empty() == true)
+		{
+			// Disable these buttons
+			editLabelButton->set_sensitive(false);
+			removeLabelButton->set_sensitive(false);
+		}
+	}
+}
+
+bool prefsDialog::on_mailTreeview_button_press_event(GdkEventButton *ev)
+{
+	// Check for double clicks
+	if (ev->type == GDK_2BUTTON_PRESS)
+	{
+		on_editAccountButton_clicked();
+	}
+
+	return false;
+}
+
+void prefsDialog::on_addAccountButton_clicked()
+{
+	importDialog importBox(_("Import Mail Box(es)"), false, true, true);
+
+	importBox.getImportFileSignal().connect(SigC::slot(*this,
+		&prefsDialog::on_message_import));
+	importBox.show();
+	importBox.run();
+	// Let the signal handler deal with importing mail accounts
+}
+
+void prefsDialog::on_editAccountButton_clicked()
+{
+	// Get the selected mail account in the list
+	TreeModel::iterator iter = mailTreeview->get_selection()->get_selected();
+	if (iter)
+	{
+		TreeModel::Row row = *iter;
+		ustring fileName = row[m_mailColumns.m_location];
+		// Let the user edit the location
+		if (select_file_name(*this, _("Mbox File Location"), fileName, true) == true)
+		{
+			row[m_mailColumns.m_location] = fileName;
+			row[m_mailColumns.m_type] = locale_to_utf8(MIMEScanner::scanFile(fileName));
+		}
+	}
+}
+
+void prefsDialog::on_removeAccountButton_clicked()
+{
+	// Get the selected mail account in the list
+	TreeModel::iterator iter = mailTreeview->get_selection()->get_selected();
+	if (iter)
+	{
+		// Unselect
+		mailTreeview->get_selection()->unselect(iter);
+		// Select another row
+		TreeModel::Path path = m_refMailTree->get_path(iter);
+		path.next();
+		mailTreeview->get_selection()->select(path);
+		// Erase
+		TreeModel::Row row = *iter;
+		m_deletedMail.insert(row[m_mailColumns.m_location]);
+		m_refMailTree->erase(row);
+
+		TreeModel::Children children = m_refMailTree->children();
+		if (children.empty() == true)
+		{
+			// Disable these buttons
+			editAccountButton->set_sensitive(false);
+			removeAccountButton->set_sensitive(false);
+		}
+	}
+}


Property changes on: trunk/UI/GTK2/src/prefsDialog.cc
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/prefsDialog.hh
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/prefsDialog.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,68 @@
+// generated 2003/5/18 21:15:37 BST by fabrice at amra.dyndns.org.(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to prefsDialog.hh_new
+
+// you might replace
+//    class foo : public foo_glade { ... };
+// by
+//    typedef foo_glade foo;
+// if you didn't make any modifications to the widget
+
+#ifndef _PREFSDIALOG_HH
+#define _PREFSDIALOG_HH
+
+#include <string>
+#include <set>
+#include <glibmm/refptr.h>
+#include <glibmm/ustring.h>
+#include <gtkmm/liststore.h>
+
+#include "ModelColumns.h"
+#include "PinotSettings.h"
+#include "prefsDialog_glade.hh"
+
+class prefsDialog : public prefsDialog_glade
+{  
+public:
+	prefsDialog();
+	virtual ~prefsDialog();
+
+	const std::set<std::string> &getMailLabelsToDelete(void) const;
+
+protected:
+	virtual void on_prefsOkbutton_clicked();
+	virtual void on_viewCombobox_changed();
+	virtual void on_browserButton_clicked();
+	virtual void on_addLabelButton_clicked();
+	virtual void on_editLabelButton_clicked();
+	virtual void on_removeLabelButton_clicked();
+	virtual bool on_mailTreeview_button_press_event(GdkEventButton *ev);
+	virtual void on_addAccountButton_clicked();
+	virtual void on_editAccountButton_clicked();
+	virtual void on_removeAccountButton_clicked();
+
+	void populate_comboboxes();
+	void populate_labelsTreeview();
+	bool save_labelsTreeview();
+	void populate_mailTreeview();
+	bool save_mailTreeview();
+	void on_message_import(DocumentInfo docInfo);
+
+private:
+	PinotSettings &m_settings;
+	ComboModelColumns m_viewColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refViewTree;
+	OtherIndexModelColumns m_otherIndexColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refOtherIndexTree;
+	LabelModelColumns m_labelsColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refLabelsTree;
+	MailAccountModelColumns m_mailColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refMailTree;
+	std::set<Glib::ustring> m_deletedIndexes;
+	std::set<std::string> m_deletedLabels;
+	std::set<Glib::ustring> m_deletedMail;
+	static unsigned int m_maxDirLevel;
+
+};
+#endif


Property changes on: trunk/UI/GTK2/src/prefsDialog.hh
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/prefsDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/prefsDialog_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,408 @@
+// generated 2005/12/1 23:54:57 SGT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/prefsDialog.cc
+
+
+#if defined __GNUC__ && __GNUC__ < 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include "config.h"
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include <libintl.h>
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include <gtkmmconfig.h>
+#if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
+#include <sigc++/compatibility.h>
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include "prefsDialog_glade.hh"
+#include <gdk/gdkkeysyms.h>
+#include <gtkmm/accelgroup.h>
+#include <gtkmm/buttonbox.h>
+#include <gtkmm/label.h>
+#include <gtkmm/box.h>
+#include <gtkmm/table.h>
+#include <gtkmm/scrolledwindow.h>
+#include <gtkmm/image.h>
+#include <gtkmm/alignment.h>
+
+prefsDialog_glade::prefsDialog_glade(
+)
+{  prefsDialog = this;
+   gmm_data = new GlademmData(get_accel_group());
+   prefsCancelbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
+   prefsOkbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
+   
+   Gtk::Label *robotsLabel = Gtk::manage(new class Gtk::Label(_("HTTP crawling:")));
+   Gtk::Label *viewLabel = Gtk::manage(new class Gtk::Label(_("View documents:")));
+   Gtk::Label *browserLabel = Gtk::manage(new class Gtk::Label(_("Browser:")));
+   apiKeyLabel = Gtk::manage(new class Gtk::Label(_("Google API Key:")));
+   apiKeyEntry = Gtk::manage(new class Gtk::Entry());
+   viewCombobox = Gtk::manage(new class Gtk::ComboBox());
+   ignoreRobotsCheckbutton = Gtk::manage(new class Gtk::CheckButton(_("Ignore robots.txt and Robots META tag")));
+   browserEntry = Gtk::manage(new class Gtk::Entry());
+   browserButton = Gtk::manage(new class Gtk::Button(_("...")));
+   
+   Gtk::HBox *browserHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   Gtk::Table *generalTable = Gtk::manage(new class Gtk::Table(2, 2, false));
+   Gtk::Label *generalLabel = Gtk::manage(new class Gtk::Label(_("General")));
+   Gtk::Label *indexLabelsLabel = Gtk::manage(new class Gtk::Label(_("Labels are used to classify indexed documents:")));
+   labelsTreeview = Gtk::manage(new class Gtk::TreeView());
+   
+   Gtk::ScrolledWindow *labelsScrolledwindow = Gtk::manage(new class Gtk::ScrolledWindow());
+   Gtk::Image *image235 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-add"), Gtk::IconSize(4)));
+   Gtk::Label *label35 = Gtk::manage(new class Gtk::Label(_("Add")));
+   Gtk::HBox *hbox29 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment17 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
+   addLabelButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::Image *image237 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-select-color"), Gtk::IconSize(4)));
+   Gtk::Label *label37 = Gtk::manage(new class Gtk::Label(_("Edit")));
+   Gtk::HBox *hbox31 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment19 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
+   editLabelButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::Image *image236 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-remove"), Gtk::IconSize(4)));
+   Gtk::Label *label36 = Gtk::manage(new class Gtk::Label(_("Remove")));
+   Gtk::HBox *hbox30 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment18 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
+   removeLabelButton = Gtk::manage(new class Gtk::Button());
+   
+   Gtk::VButtonBox *labelsVbuttonbox = Gtk::manage(new class Gtk::VButtonBox(Gtk::BUTTONBOX_START, 0));
+   Gtk::HBox *labelsHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   Gtk::VBox *labelsVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   Gtk::Label *labelsLabel = Gtk::manage(new class Gtk::Label(_("Labels")));
+   Gtk::Label *mailAccountsLabel = Gtk::manage(new class Gtk::Label(_("Mail boxes of type mbox can be monitored and indexed:")));
+   mailTreeview = Gtk::manage(new class Gtk::TreeView());
+   
+   Gtk::ScrolledWindow *mailScrolledwindow = Gtk::manage(new class Gtk::ScrolledWindow());
+   Gtk::Image *image497 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-add"), Gtk::IconSize(4)));
+   Gtk::Label *label49 = Gtk::manage(new class Gtk::Label(_("Add")));
+   Gtk::HBox *hbox42 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment28 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
+   addAccountButton = Gtk::manage(new class Gtk::Button());
+   editAccountButton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-edit")));
+   removeAccountButton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-remove")));
+   
+   Gtk::VButtonBox *mailVbuttonbox = Gtk::manage(new class Gtk::VButtonBox(Gtk::BUTTONBOX_START, 0));
+   Gtk::HBox *mailHbox = Gtk::manage(new class Gtk::HBox(false, 0));
+   Gtk::VBox *mailVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   Gtk::Label *mailLabel = Gtk::manage(new class Gtk::Label(_("My Email")));
+   prefsNotebook = Gtk::manage(new class Gtk::Notebook());
+   prefsCancelbutton->set_flags(Gtk::CAN_FOCUS);
+   prefsCancelbutton->set_flags(Gtk::CAN_DEFAULT);
+   prefsCancelbutton->set_relief(Gtk::RELIEF_NORMAL);
+   prefsOkbutton->set_flags(Gtk::CAN_FOCUS);
+   prefsOkbutton->set_flags(Gtk::CAN_DEFAULT);
+   prefsOkbutton->set_relief(Gtk::RELIEF_NORMAL);
+   prefsDialog->get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
+   robotsLabel->set_alignment(0,0.5);
+   robotsLabel->set_padding(4,4);
+   robotsLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   robotsLabel->set_line_wrap(false);
+   robotsLabel->set_use_markup(false);
+   robotsLabel->set_selectable(false);
+   viewLabel->set_alignment(0,0.5);
+   viewLabel->set_padding(4,4);
+   viewLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   viewLabel->set_line_wrap(false);
+   viewLabel->set_use_markup(false);
+   viewLabel->set_selectable(false);
+   browserLabel->set_alignment(0,0.5);
+   browserLabel->set_padding(4,4);
+   browserLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   browserLabel->set_line_wrap(false);
+   browserLabel->set_use_markup(false);
+   browserLabel->set_selectable(false);
+   apiKeyLabel->set_alignment(0,0.5);
+   apiKeyLabel->set_padding(4,4);
+   apiKeyLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   apiKeyLabel->set_line_wrap(false);
+   apiKeyLabel->set_use_markup(false);
+   apiKeyLabel->set_selectable(false);
+   apiKeyEntry->set_flags(Gtk::CAN_FOCUS);
+   apiKeyEntry->set_visibility(true);
+   apiKeyEntry->set_editable(true);
+   apiKeyEntry->set_max_length(0);
+   apiKeyEntry->set_text(_(""));
+   apiKeyEntry->set_has_frame(true);
+   apiKeyEntry->set_activates_default(false);
+   ignoreRobotsCheckbutton->set_flags(Gtk::CAN_FOCUS);
+   ignoreRobotsCheckbutton->set_relief(Gtk::RELIEF_NORMAL);
+   ignoreRobotsCheckbutton->set_mode(true);
+   ignoreRobotsCheckbutton->set_active(false);
+   browserEntry->set_flags(Gtk::CAN_FOCUS);
+   browserEntry->set_visibility(true);
+   browserEntry->set_editable(true);
+   browserEntry->set_max_length(0);
+   browserEntry->set_text(_(""));
+   browserEntry->set_has_frame(true);
+   browserEntry->set_activates_default(false);
+   browserButton->set_flags(Gtk::CAN_FOCUS);
+   browserButton->set_flags(Gtk::CAN_DEFAULT);
+   browserButton->set_relief(Gtk::RELIEF_NORMAL);
+   browserHbox->pack_start(*browserEntry);
+   browserHbox->pack_start(*browserButton, Gtk::PACK_SHRINK, 4);
+   generalTable->set_row_spacings(0);
+   generalTable->set_col_spacings(0);
+   generalTable->attach(*robotsLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   generalTable->attach(*viewLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   generalTable->attach(*browserLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
+   generalTable->attach(*apiKeyLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   generalTable->attach(*apiKeyEntry, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   generalTable->attach(*viewCombobox, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   generalTable->attach(*ignoreRobotsCheckbutton, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   generalTable->attach(*browserHbox, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   generalLabel->set_alignment(0.5,0.5);
+   generalLabel->set_padding(0,0);
+   generalLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   generalLabel->set_line_wrap(false);
+   generalLabel->set_use_markup(false);
+   generalLabel->set_selectable(false);
+   indexLabelsLabel->set_alignment(0,0.5);
+   indexLabelsLabel->set_padding(4,4);
+   indexLabelsLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   indexLabelsLabel->set_line_wrap(true);
+   indexLabelsLabel->set_use_markup(false);
+   indexLabelsLabel->set_selectable(false);
+   labelsTreeview->set_flags(Gtk::CAN_FOCUS);
+   labelsTreeview->set_headers_visible(true);
+   labelsTreeview->set_rules_hint(false);
+   labelsTreeview->set_reorderable(false);
+   labelsTreeview->set_enable_search(true);
+   labelsScrolledwindow->set_flags(Gtk::CAN_FOCUS);
+   labelsScrolledwindow->set_border_width(4);
+   labelsScrolledwindow->set_shadow_type(Gtk::SHADOW_NONE);
+   labelsScrolledwindow->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+   labelsScrolledwindow->property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+   labelsScrolledwindow->add(*labelsTreeview);
+   image235->set_alignment(0.5,0.5);
+   image235->set_padding(0,0);
+   label35->set_alignment(0.5,0.5);
+   label35->set_padding(0,0);
+   label35->set_justify(Gtk::JUSTIFY_LEFT);
+   label35->set_line_wrap(false);
+   label35->set_use_markup(false);
+   label35->set_selectable(false);
+   hbox29->pack_start(*image235, Gtk::PACK_SHRINK, 0);
+   hbox29->pack_start(*label35, Gtk::PACK_SHRINK, 0);
+   alignment17->add(*hbox29);
+   addLabelButton->set_flags(Gtk::CAN_FOCUS);
+   addLabelButton->set_flags(Gtk::CAN_DEFAULT);
+   addLabelButton->set_border_width(4);
+   addLabelButton->set_relief(Gtk::RELIEF_NORMAL);
+   addLabelButton->add(*alignment17);
+   image237->set_alignment(0.5,0.5);
+   image237->set_padding(0,0);
+   label37->set_alignment(0.5,0.5);
+   label37->set_padding(0,0);
+   label37->set_justify(Gtk::JUSTIFY_LEFT);
+   label37->set_line_wrap(false);
+   label37->set_use_markup(false);
+   label37->set_selectable(false);
+   hbox31->pack_start(*image237, Gtk::PACK_SHRINK, 0);
+   hbox31->pack_start(*label37, Gtk::PACK_SHRINK, 0);
+   alignment19->add(*hbox31);
+   editLabelButton->set_flags(Gtk::CAN_FOCUS);
+   editLabelButton->set_flags(Gtk::CAN_DEFAULT);
+   editLabelButton->set_border_width(4);
+   editLabelButton->set_relief(Gtk::RELIEF_NORMAL);
+   editLabelButton->add(*alignment19);
+   image236->set_alignment(0.5,0.5);
+   image236->set_padding(0,0);
+   label36->set_alignment(0.5,0.5);
+   label36->set_padding(0,0);
+   label36->set_justify(Gtk::JUSTIFY_LEFT);
+   label36->set_line_wrap(false);
+   label36->set_use_markup(false);
+   label36->set_selectable(false);
+   hbox30->pack_start(*image236, Gtk::PACK_SHRINK, 0);
+   hbox30->pack_start(*label36, Gtk::PACK_SHRINK, 0);
+   alignment18->add(*hbox30);
+   removeLabelButton->set_flags(Gtk::CAN_FOCUS);
+   removeLabelButton->set_flags(Gtk::CAN_DEFAULT);
+   removeLabelButton->set_border_width(4);
+   removeLabelButton->set_relief(Gtk::RELIEF_NORMAL);
+   removeLabelButton->add(*alignment18);
+   labelsVbuttonbox->pack_start(*addLabelButton);
+   labelsVbuttonbox->pack_start(*editLabelButton);
+   labelsVbuttonbox->pack_start(*removeLabelButton);
+   labelsHbox->pack_start(*labelsScrolledwindow);
+   labelsHbox->pack_start(*labelsVbuttonbox, Gtk::PACK_SHRINK, 0);
+   labelsVbox->pack_start(*indexLabelsLabel, Gtk::PACK_SHRINK, 4);
+   labelsVbox->pack_start(*labelsHbox, Gtk::PACK_EXPAND_WIDGET, 4);
+   labelsLabel->set_alignment(0.5,0.5);
+   labelsLabel->set_padding(0,0);
+   labelsLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   labelsLabel->set_line_wrap(false);
+   labelsLabel->set_use_markup(false);
+   labelsLabel->set_selectable(false);
+   mailAccountsLabel->set_alignment(0,0.5);
+   mailAccountsLabel->set_padding(4,4);
+   mailAccountsLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   mailAccountsLabel->set_line_wrap(true);
+   mailAccountsLabel->set_use_markup(false);
+   mailAccountsLabel->set_selectable(false);
+   mailTreeview->set_flags(Gtk::CAN_FOCUS);
+   mailTreeview->set_headers_visible(true);
+   mailTreeview->set_rules_hint(false);
+   mailTreeview->set_reorderable(false);
+   mailTreeview->set_enable_search(true);
+   mailScrolledwindow->set_flags(Gtk::CAN_FOCUS);
+   mailScrolledwindow->set_border_width(4);
+   mailScrolledwindow->set_shadow_type(Gtk::SHADOW_NONE);
+   mailScrolledwindow->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+   mailScrolledwindow->property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+   mailScrolledwindow->add(*mailTreeview);
+   image497->set_alignment(0.5,0.5);
+   image497->set_padding(0,0);
+   label49->set_alignment(0.5,0.5);
+   label49->set_padding(0,0);
+   label49->set_justify(Gtk::JUSTIFY_LEFT);
+   label49->set_line_wrap(false);
+   label49->set_use_markup(false);
+   label49->set_selectable(false);
+   hbox42->pack_start(*image497, Gtk::PACK_SHRINK, 0);
+   hbox42->pack_start(*label49, Gtk::PACK_SHRINK, 0);
+   alignment28->add(*hbox42);
+   addAccountButton->set_flags(Gtk::CAN_FOCUS);
+   addAccountButton->set_flags(Gtk::CAN_DEFAULT);
+   addAccountButton->set_border_width(4);
+   addAccountButton->set_relief(Gtk::RELIEF_NORMAL);
+   addAccountButton->add(*alignment28);
+   editAccountButton->set_flags(Gtk::CAN_FOCUS);
+   editAccountButton->set_flags(Gtk::CAN_DEFAULT);
+   editAccountButton->set_border_width(4);
+   editAccountButton->set_relief(Gtk::RELIEF_NORMAL);
+   removeAccountButton->set_flags(Gtk::CAN_FOCUS);
+   removeAccountButton->set_flags(Gtk::CAN_DEFAULT);
+   removeAccountButton->set_border_width(4);
+   removeAccountButton->set_relief(Gtk::RELIEF_NORMAL);
+   mailVbuttonbox->pack_start(*addAccountButton);
+   mailVbuttonbox->pack_start(*editAccountButton);
+   mailVbuttonbox->pack_start(*removeAccountButton);
+   mailHbox->pack_start(*mailScrolledwindow);
+   mailHbox->pack_start(*mailVbuttonbox, Gtk::PACK_SHRINK, 0);
+   mailVbox->pack_start(*mailAccountsLabel, Gtk::PACK_SHRINK, 4);
+   mailVbox->pack_start(*mailHbox, Gtk::PACK_EXPAND_WIDGET, 4);
+   mailLabel->set_alignment(0.5,0.5);
+   mailLabel->set_padding(0,0);
+   mailLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   mailLabel->set_line_wrap(false);
+   mailLabel->set_use_markup(false);
+   mailLabel->set_selectable(false);
+   prefsNotebook->set_flags(Gtk::CAN_FOCUS);
+   prefsNotebook->set_show_tabs(true);
+   prefsNotebook->set_show_border(true);
+   prefsNotebook->set_tab_pos(Gtk::POS_TOP);
+   prefsNotebook->set_scrollable(false);
+   prefsNotebook->append_page(*generalTable, *generalLabel);
+   prefsNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   prefsNotebook->append_page(*labelsVbox, *labelsLabel);
+   prefsNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   prefsNotebook->append_page(*mailVbox, *mailLabel);
+   prefsNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   prefsDialog->get_vbox()->set_homogeneous(false);
+   prefsDialog->get_vbox()->set_spacing(0);
+   prefsDialog->get_vbox()->pack_start(*prefsNotebook);
+   prefsDialog->set_title(_("Preferences"));
+   prefsDialog->set_modal(false);
+   prefsDialog->property_window_position().set_value(Gtk::WIN_POS_NONE);
+   prefsDialog->set_resizable(true);
+   prefsDialog->property_destroy_with_parent().set_value(false);
+   prefsDialog->set_has_separator(true);
+   prefsDialog->add_action_widget(*prefsCancelbutton, -6);
+   prefsDialog->add_action_widget(*prefsOkbutton, -5);
+   prefsCancelbutton->show();
+   prefsOkbutton->show();
+   robotsLabel->show();
+   viewLabel->show();
+   browserLabel->show();
+   apiKeyLabel->show();
+   apiKeyEntry->show();
+   viewCombobox->show();
+   ignoreRobotsCheckbutton->show();
+   browserEntry->show();
+   browserButton->show();
+   browserHbox->show();
+   generalTable->show();
+   generalLabel->show();
+   indexLabelsLabel->show();
+   labelsTreeview->show();
+   labelsScrolledwindow->show();
+   image235->show();
+   label35->show();
+   hbox29->show();
+   alignment17->show();
+   addLabelButton->show();
+   image237->show();
+   label37->show();
+   hbox31->show();
+   alignment19->show();
+   editLabelButton->show();
+   image236->show();
+   label36->show();
+   hbox30->show();
+   alignment18->show();
+   removeLabelButton->show();
+   labelsVbuttonbox->show();
+   labelsHbox->show();
+   labelsVbox->show();
+   labelsLabel->show();
+   mailAccountsLabel->show();
+   mailTreeview->show();
+   mailScrolledwindow->show();
+   image497->show();
+   label49->show();
+   hbox42->show();
+   alignment28->show();
+   addAccountButton->show();
+   editAccountButton->show();
+   removeAccountButton->show();
+   mailVbuttonbox->show();
+   mailHbox->show();
+   mailVbox->show();
+   mailLabel->show();
+   prefsNotebook->show();
+   prefsDialog->show();
+   prefsOkbutton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_prefsOkbutton_clicked), false);
+   viewCombobox->signal_changed().connect(SigC::slot(*this, &prefsDialog_glade::on_viewCombobox_changed), false);
+   browserButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_browserButton_clicked), false);
+   addLabelButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_addLabelButton_clicked), false);
+   editLabelButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_editLabelButton_clicked), false);
+   removeLabelButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_removeLabelButton_clicked), false);
+   mailTreeview->signal_button_press_event().connect(SigC::slot(*this, &prefsDialog_glade::on_mailTreeview_button_press_event), false);
+   addAccountButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_addAccountButton_clicked), false);
+   editAccountButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_editAccountButton_clicked), false);
+   removeAccountButton->signal_clicked().connect(SigC::slot(*this, &prefsDialog_glade::on_removeAccountButton_clicked), false);
+}
+
+prefsDialog_glade::~prefsDialog_glade()
+{  delete gmm_data;
+}


Property changes on: trunk/UI/GTK2/src/prefsDialog_glade.cc
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/prefsDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/prefsDialog_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/prefsDialog_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,83 @@
+// generated 2005/11/29 20:59:00 SGT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/prefsDialog.hh and./src/prefsDialog.cc
+
+#ifndef _PREFSDIALOG_GLADE_HH
+#  define _PREFSDIALOG_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include <gtkmm/accelgroup.h>
+
+class GlademmData
+{  
+        
+        Glib::RefPtr<Gtk::AccelGroup> accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr<Gtk::AccelGroup> ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr<Gtk::AccelGroup>  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include <gtkmm/dialog.h>
+#include <gtkmm/button.h>
+#include <gtkmm/label.h>
+#include <gtkmm/entry.h>
+#include <gtkmm/combobox.h>
+#include <gtkmm/checkbutton.h>
+#include <gtkmm/treeview.h>
+#include <gtkmm/notebook.h>
+
+class prefsDialog_glade : public Gtk::Dialog
+{  
+        
+        GlademmData *gmm_data;
+public:
+        class Gtk::Dialog * prefsDialog;
+protected:
+        class Gtk::Button * prefsCancelbutton;
+        class Gtk::Button * prefsOkbutton;
+        class Gtk::Label * apiKeyLabel;
+        class Gtk::Entry * apiKeyEntry;
+        class Gtk::ComboBox * viewCombobox;
+        class Gtk::CheckButton * ignoreRobotsCheckbutton;
+        class Gtk::Entry * browserEntry;
+        class Gtk::Button * browserButton;
+        class Gtk::TreeView * labelsTreeview;
+        class Gtk::Button * addLabelButton;
+        class Gtk::Button * editLabelButton;
+        class Gtk::Button * removeLabelButton;
+        class Gtk::TreeView * mailTreeview;
+        class Gtk::Button * addAccountButton;
+        class Gtk::Button * editAccountButton;
+        class Gtk::Button * removeAccountButton;
+        class Gtk::Notebook * prefsNotebook;
+        
+        prefsDialog_glade();
+        
+        ~prefsDialog_glade();
+private:
+        virtual void on_prefsOkbutton_clicked() = 0;
+        virtual void on_viewCombobox_changed() = 0;
+        virtual void on_browserButton_clicked() = 0;
+        virtual void on_addLabelButton_clicked() = 0;
+        virtual void on_editLabelButton_clicked() = 0;
+        virtual void on_removeLabelButton_clicked() = 0;
+        virtual bool on_mailTreeview_button_press_event(GdkEventButton *ev) = 0;
+        virtual void on_addAccountButton_clicked() = 0;
+        virtual void on_editAccountButton_clicked() = 0;
+        virtual void on_removeAccountButton_clicked() = 0;
+};
+#endif


Property changes on: trunk/UI/GTK2/src/prefsDialog_glade.hh
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/GTK2/src/propertiesDialog.cc
===================================================================
--- trunk/UI/GTK2/src/propertiesDialog.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/propertiesDialog.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,174 @@
+// generated 2004/8/13 22:59:43 BST by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0_cvs
+//
+// newer (non customized) versions of this file go to propertiesDialog.cc_new
+
+// This file is for your program, I won't touch it again!
+
+#include <iostream>
+#include <glibmm/convert.h>
+#include <pangomm/font.h>
+#include <gtkmm/rc.h>
+
+#include "config.h"
+#include "NLS.h"
+#include "PinotSettings.h"
+#include "PinotUtils.h"
+#include "propertiesDialog.hh"
+
+using namespace std;
+using namespace Glib;
+using namespace Gdk;
+using namespace Gtk;
+
+propertiesDialog::propertiesDialog(const std::set<std::string> &docLabels,
+	const DocumentInfo &docInfo, bool editDocument) :
+	propertiesDialog_glade(),
+	m_editDocument(editDocument),
+	m_docInfo(docInfo)
+{
+	// Associate the columns model to the labels tree
+	m_refLabelsTree = ListStore::create(m_labelsColumns);
+	labelsTreeview->set_model(m_refLabelsTree);
+	labelsTreeview->append_column_editable(" ", m_labelsColumns.m_enabled);
+	labelsTreeview->append_column(_("Label"), m_labelsColumns.m_name);
+	// Allow only single selection
+	labelsTreeview->get_selection()->set_mode(SELECTION_SINGLE);
+
+	if (m_editDocument == true)
+	{
+		ustring language = to_utf8(docInfo.getLanguage());
+
+		titleEntry->set_text(to_utf8(docInfo.getTitle()));
+		if (language.empty() == true)
+		{
+			language = _("Unknown");
+		}
+		languageEntry->set_text(language);
+		typeEntry->set_text(to_utf8(docInfo.getType()));
+	}
+	else
+	{
+		titleLabel->hide();
+		titleEntry->hide();
+		languageLabel->hide();
+		languageEntry->hide();
+		typeLabel->hide();
+		typeEntry->hide();
+	}
+	// FIXME: get the extract
+	extractLabel->hide();
+	extractScrolledwindow->hide();
+
+	populate_labelsTreeview(docLabels);
+}
+
+propertiesDialog::~propertiesDialog()
+{
+}
+
+void propertiesDialog::populate_labelsTreeview(const set<string> &docLabels)
+{
+	TreeModel::iterator iter;
+	TreeModel::Row row;
+
+	// Populate the tree
+	const set<PinotSettings::Label> &sysLabels = PinotSettings::getInstance().m_labels;
+	for (set<PinotSettings::Label>::const_iterator labelIter = sysLabels.begin(); labelIter != sysLabels.end(); ++labelIter)
+	{
+		// Create a new row
+		iter = m_refLabelsTree->append();
+		row = *iter;
+
+		row[m_labelsColumns.m_name] = labelIter->m_name;
+		string labelName = locale_from_utf8(labelIter->m_name);
+		// Is it in the document labels list ?
+		set<string>::const_iterator iter = find(docLabels.begin(), docLabels.end(), labelName);
+		if (iter != docLabels.end())
+		{
+			// Yup
+			row[m_labelsColumns.m_enabled] = true;
+		}
+		else
+		{
+			row[m_labelsColumns.m_enabled] = false;
+		}
+	}
+}
+
+void propertiesDialog::setHeight(int maxHeight)
+{
+	// FIXME: there must be a better way to determine how high the tree should be
+	// for all rows to be visible !
+	int labelsCount = m_refLabelsTree->children().size();
+	// By default, the tree is high enough for two rows to be visible
+	if (labelsCount > 2)
+	{
+		int width, height;
+		get_size(width, height);
+
+		RefPtr<Style> refRCStyle = RC::get_style(*labelsTreeview);
+		int fontSize = refRCStyle->get_font().get_size() / Pango::SCALE;
+#ifdef DEBUG
+		cout << "propertiesDialog::setHeight: max " << maxHeight << ", dialog " << height
+			<< ", font " << fontSize << " " << refRCStyle->get_font().get_size() << endl;
+#endif
+		height += fontSize * (labelsCount - 2);
+
+		TreeViewColumn *pColumn = labelsTreeview->get_column(1);
+		if (pColumn != NULL)
+		{
+			Rectangle cell_area;
+			int x_offset, y_offset, cellWidth, cellHeight;
+			pColumn->cell_get_size(cell_area, x_offset, y_offset, cellWidth, cellHeight);
+#ifdef DEBUG
+			cout << "propertiesDialog::setHeight: cell " << cellHeight << " " << y_offset << endl;
+#endif
+			height += cellHeight * (labelsCount - 2);
+		}
+#ifdef DEBUG
+		cout << "propertiesDialog::setHeight: dialog " << height << endl;
+#endif
+
+		if (height > maxHeight)
+		{
+			height = maxHeight;
+		}
+		resize(width, height);
+	}
+}
+
+const DocumentInfo &propertiesDialog::getDocumentInfo(void)
+{
+	return m_docInfo;
+}
+
+const set<string> &propertiesDialog::getLabels(void) const
+{
+	return m_labels;
+}
+
+void propertiesDialog::on_labelOkButton_clicked()
+{
+	if (m_editDocument == true)
+	{
+		// Title
+		m_docInfo.setTitle(locale_from_utf8(titleEntry->get_text()));
+	}
+	// Go through the labels tree
+	TreeModel::Children children = m_refLabelsTree->children();
+	if (children.empty() == false)
+	{
+		for (TreeModel::Children::iterator iter = children.begin(); iter != children.end(); ++iter)
+		{
+			TreeModel::Row row = *iter;
+
+			bool enabled = row[m_labelsColumns.m_enabled];
+			if (enabled == true)
+			{
+				ustring labelName = row[m_labelsColumns.m_name];
+				m_labels.insert(locale_from_utf8(labelName));
+			}
+		}
+	}
+}

Added: trunk/UI/GTK2/src/propertiesDialog.hh
===================================================================
--- trunk/UI/GTK2/src/propertiesDialog.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/propertiesDialog.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+// generated 2004/8/13 22:59:43 BST by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0_cvs
+//
+// newer (non customized) versions of this file go to propertiesDialog.hh_new
+
+// you might replace
+//    class foo : public foo_glade { ... };
+// by
+//    typedef foo_glade foo;
+// if you didn't make any modifications to the widget
+
+#ifndef _LABELDIALOG_HH
+#define _LABELDIALOG_HH
+
+#include <string>
+#include <set>
+#include <glibmm/refptr.h>
+#include <gtkmm/liststore.h>
+
+#include "DocumentInfo.h"
+#include "ModelColumns.h"
+#include "propertiesDialog_glade.hh"
+
+class propertiesDialog : public propertiesDialog_glade
+{  
+public:
+	propertiesDialog(const std::set<std::string> &docLabels,
+		const DocumentInfo &docInfo, bool editDocument = true);
+	virtual ~propertiesDialog();
+
+	void setHeight(int maxHeight);
+
+	const DocumentInfo &getDocumentInfo(void);
+
+	const std::set<std::string> &getLabels(void) const;
+
+protected:
+	LabelModelColumns m_labelsColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refLabelsTree;
+	std::set<std::string> m_labels;
+	bool m_editDocument;
+	DocumentInfo m_docInfo;
+
+	void populate_labelsTreeview(const std::set<std::string> &docLabels);
+
+	void on_labelOkButton_clicked();
+
+};
+#endif // _LABELDIALOG_HH

Added: trunk/UI/GTK2/src/propertiesDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/propertiesDialog_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/propertiesDialog_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,204 @@
+// generated 2005/11/26 18:15:06 SGT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/propertiesDialog.cc
+
+
+#if defined __GNUC__ && __GNUC__ < 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include "config.h"
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include <libintl.h>
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include <gtkmmconfig.h>
+#if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
+#include <sigc++/compatibility.h>
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include "propertiesDialog_glade.hh"
+#include <gdk/gdkkeysyms.h>
+#include <gtkmm/accelgroup.h>
+#include <gtkmm/button.h>
+#include <gtkmm/buttonbox.h>
+#include <gtkmm/table.h>
+#include <gtkmm/viewport.h>
+#include <gtkmm/adjustment.h>
+#include <gtkmm/box.h>
+
+propertiesDialog_glade::propertiesDialog_glade(
+)
+{  propertiesDialog = this;
+   gmm_data = new GlademmData(get_accel_group());
+   
+   Gtk::Button *cancelbutton2 = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
+   labelOkButton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
+   titleEntry = Gtk::manage(new class Gtk::Entry());
+   extractTextview = Gtk::manage(new class Gtk::TextView());
+   extractScrolledwindow = Gtk::manage(new class Gtk::ScrolledWindow());
+   titleLabel = Gtk::manage(new class Gtk::Label(_("Title:")));
+   extractLabel = Gtk::manage(new class Gtk::Label(_("Extract:")));
+   languageLabel = Gtk::manage(new class Gtk::Label(_("Language:")));
+   languageEntry = Gtk::manage(new class Gtk::Entry());
+   typeLabel = Gtk::manage(new class Gtk::Label(_("Type:")));
+   typeEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Table *propertiesTable = Gtk::manage(new class Gtk::Table(2, 2, false));
+   labelsTreeview = Gtk::manage(new class Gtk::TreeView());
+   
+   Gtk::Viewport *viewport1 = Gtk::manage(new class Gtk::Viewport(*manage(new Gtk::Adjustment(0,0,1)), *manage(new Gtk::Adjustment(0,0,1))));
+   labelsScrolledwindow = Gtk::manage(new class Gtk::ScrolledWindow());
+   
+   Gtk::VBox *propertiesVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   cancelbutton2->set_flags(Gtk::CAN_FOCUS);
+   cancelbutton2->set_flags(Gtk::CAN_DEFAULT);
+   cancelbutton2->set_relief(Gtk::RELIEF_NORMAL);
+   labelOkButton->set_flags(Gtk::CAN_FOCUS);
+   labelOkButton->set_flags(Gtk::CAN_DEFAULT);
+   labelOkButton->set_relief(Gtk::RELIEF_NORMAL);
+   propertiesDialog->get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
+   titleEntry->set_flags(Gtk::CAN_FOCUS);
+   titleEntry->set_visibility(true);
+   titleEntry->set_editable(true);
+   titleEntry->set_max_length(0);
+   titleEntry->set_text(_(""));
+   titleEntry->set_has_frame(true);
+   titleEntry->set_activates_default(false);
+   extractTextview->set_flags(Gtk::CAN_FOCUS);
+   extractTextview->set_editable(true);
+   extractTextview->set_cursor_visible(true);
+   extractTextview->set_pixels_above_lines(0);
+   extractTextview->set_pixels_below_lines(0);
+   extractTextview->set_pixels_inside_wrap(0);
+   extractTextview->set_left_margin(3);
+   extractTextview->set_right_margin(0);
+   extractTextview->set_indent(0);
+   extractTextview->set_wrap_mode(Gtk::WRAP_NONE);
+   extractTextview->set_justification(Gtk::JUSTIFY_LEFT);
+   extractScrolledwindow->set_flags(Gtk::CAN_FOCUS);
+   extractScrolledwindow->set_shadow_type(Gtk::SHADOW_IN);
+   extractScrolledwindow->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+   extractScrolledwindow->property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+   extractScrolledwindow->add(*extractTextview);
+   titleLabel->set_alignment(0,0.5);
+   titleLabel->set_padding(4,4);
+   titleLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   titleLabel->set_line_wrap(false);
+   titleLabel->set_use_markup(false);
+   titleLabel->set_selectable(false);
+   extractLabel->set_alignment(0,0.5);
+   extractLabel->set_padding(4,4);
+   extractLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   extractLabel->set_line_wrap(false);
+   extractLabel->set_use_markup(false);
+   extractLabel->set_selectable(false);
+   languageLabel->set_alignment(0,0.5);
+   languageLabel->set_padding(4,4);
+   languageLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   languageLabel->set_line_wrap(false);
+   languageLabel->set_use_markup(false);
+   languageLabel->set_selectable(false);
+   languageEntry->set_flags(Gtk::CAN_FOCUS);
+   languageEntry->set_visibility(true);
+   languageEntry->set_editable(false);
+   languageEntry->set_max_length(0);
+   languageEntry->set_text(_(""));
+   languageEntry->set_has_frame(true);
+   languageEntry->set_activates_default(false);
+   typeLabel->set_alignment(0,0.5);
+   typeLabel->set_padding(4,4);
+   typeLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   typeLabel->set_line_wrap(false);
+   typeLabel->set_use_markup(false);
+   typeLabel->set_selectable(false);
+   typeEntry->set_flags(Gtk::CAN_FOCUS);
+   typeEntry->set_visibility(true);
+   typeEntry->set_editable(false);
+   typeEntry->set_max_length(0);
+   typeEntry->set_text(_(""));
+   typeEntry->set_has_frame(true);
+   typeEntry->set_activates_default(false);
+   propertiesTable->set_row_spacings(0);
+   propertiesTable->set_col_spacings(0);
+   propertiesTable->attach(*titleEntry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   propertiesTable->attach(*extractScrolledwindow, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   propertiesTable->attach(*titleLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   propertiesTable->attach(*extractLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   propertiesTable->attach(*languageLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
+   propertiesTable->attach(*languageEntry, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   propertiesTable->attach(*typeLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   propertiesTable->attach(*typeEntry, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   labelsTreeview->set_flags(Gtk::CAN_FOCUS);
+   labelsTreeview->set_headers_visible(true);
+   labelsTreeview->set_rules_hint(false);
+   labelsTreeview->set_reorderable(false);
+   labelsTreeview->set_enable_search(true);
+   viewport1->set_shadow_type(Gtk::SHADOW_IN);
+   viewport1->add(*labelsTreeview);
+   labelsScrolledwindow->set_flags(Gtk::CAN_FOCUS);
+   labelsScrolledwindow->set_border_width(4);
+   labelsScrolledwindow->set_shadow_type(Gtk::SHADOW_NONE);
+   labelsScrolledwindow->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);
+   labelsScrolledwindow->property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+   labelsScrolledwindow->add(*viewport1);
+   propertiesVbox->pack_start(*propertiesTable, Gtk::PACK_SHRINK, 0);
+   propertiesVbox->pack_start(*labelsScrolledwindow);
+   propertiesDialog->get_vbox()->set_homogeneous(false);
+   propertiesDialog->get_vbox()->set_spacing(0);
+   propertiesDialog->get_vbox()->pack_start(*propertiesVbox);
+   propertiesDialog->set_title(_("Properties"));
+   propertiesDialog->set_modal(false);
+   propertiesDialog->property_window_position().set_value(Gtk::WIN_POS_NONE);
+   propertiesDialog->set_resizable(true);
+   propertiesDialog->property_destroy_with_parent().set_value(false);
+   propertiesDialog->set_has_separator(true);
+   propertiesDialog->add_action_widget(*cancelbutton2, -6);
+   propertiesDialog->add_action_widget(*labelOkButton, -5);
+   cancelbutton2->show();
+   labelOkButton->show();
+   titleEntry->show();
+   extractTextview->show();
+   extractScrolledwindow->show();
+   titleLabel->show();
+   extractLabel->show();
+   languageLabel->show();
+   languageEntry->show();
+   typeLabel->show();
+   typeEntry->show();
+   propertiesTable->show();
+   labelsTreeview->show();
+   viewport1->show();
+   labelsScrolledwindow->show();
+   propertiesVbox->show();
+   propertiesDialog->show();
+   labelOkButton->signal_clicked().connect(SigC::slot(*this, &propertiesDialog_glade::on_labelOkButton_clicked), false);
+}
+
+propertiesDialog_glade::~propertiesDialog_glade()
+{  delete gmm_data;
+}

Added: trunk/UI/GTK2/src/propertiesDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/propertiesDialog_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/propertiesDialog_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,68 @@
+// generated 2005/11/26 18:15:06 SGT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/propertiesDialog.hh and./src/propertiesDialog.cc
+
+#ifndef _PROPERTIESDIALOG_GLADE_HH
+#  define _PROPERTIESDIALOG_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include <gtkmm/accelgroup.h>
+
+class GlademmData
+{  
+        
+        Glib::RefPtr<Gtk::AccelGroup> accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr<Gtk::AccelGroup> ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr<Gtk::AccelGroup>  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include <gtkmm/dialog.h>
+#include <gtkmm/button.h>
+#include <gtkmm/entry.h>
+#include <gtkmm/textview.h>
+#include <gtkmm/scrolledwindow.h>
+#include <gtkmm/label.h>
+#include <gtkmm/treeview.h>
+
+class propertiesDialog_glade : public Gtk::Dialog
+{  
+        
+        GlademmData *gmm_data;
+public:
+        class Gtk::Dialog * propertiesDialog;
+protected:
+        class Gtk::Button * labelOkButton;
+        class Gtk::Entry * titleEntry;
+        class Gtk::TextView * extractTextview;
+        class Gtk::ScrolledWindow * extractScrolledwindow;
+        class Gtk::Label * titleLabel;
+        class Gtk::Label * extractLabel;
+        class Gtk::Label * languageLabel;
+        class Gtk::Entry * languageEntry;
+        class Gtk::Label * typeLabel;
+        class Gtk::Entry * typeEntry;
+        class Gtk::TreeView * labelsTreeview;
+        class Gtk::ScrolledWindow * labelsScrolledwindow;
+        
+        propertiesDialog_glade();
+        
+        ~propertiesDialog_glade();
+private:
+        virtual void on_labelOkButton_clicked() = 0;
+};
+#endif

Added: trunk/UI/GTK2/src/queryDialog.cc
===================================================================
--- trunk/UI/GTK2/src/queryDialog.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/queryDialog.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,221 @@
+// generated 2003/6/13 20:26:49 BST by fabrice at amra.dyndns.org.(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to queryDialog.cc_new
+
+// This file is for your program, I won't touch it again!
+
+#include <iostream>
+#include <glibmm/ustring.h>
+#include <glibmm/convert.h>
+#include <gtkmm/menu.h>
+
+#include "config.h"
+#include "Languages.h"
+#include "NLS.h"
+#include "queryDialog.hh"
+
+using namespace std;
+using namespace Glib;
+using namespace Gtk;
+
+queryDialog::queryDialog(QueryProperties &properties) :
+	queryDialog_glade(),
+	m_name(properties.getName()),
+	m_properties(properties),
+	m_labels(PinotSettings::getInstance().m_labels),
+	m_badName(true)
+{
+	string name = m_properties.getName();
+
+	// Associate the columns model to the label combo
+	m_refLabelTree = ListStore::create(m_labelColumns);
+	labelCombobox->set_model(m_refLabelTree);
+	labelCombobox->pack_start(m_labelColumns.m_name);
+	// Associate the columns model to the language combo
+	m_refLanguageTree = ListStore::create(m_languageColumns);
+	languageCombobox->set_model(m_refLanguageTree);
+	languageCombobox->pack_start(m_languageColumns.m_name);
+	// Populate
+	populate_comboboxes();
+
+	// Name
+	if (name.empty() == true)
+	{
+		queryOkbutton->set_sensitive(false);
+	}
+	else
+	{
+		nameEntry->set_text(locale_to_utf8(name));
+	}
+	// Query terms
+	andEntry->set_text(locale_to_utf8(m_properties.getAndWords()));
+	phraseEntry->set_text(locale_to_utf8(m_properties.getPhrase()));
+	anyEntry->set_text(locale_to_utf8(m_properties.getAnyWords()));
+	notEntry->set_text(locale_to_utf8(m_properties.getNotWords()));
+
+	// Host name
+	hostNameEntry->set_text(locale_to_utf8(m_properties.getHostNameFilter()));
+	// File name
+	fileNameEntry->set_text(locale_to_utf8(m_properties.getFileNameFilter()));
+	// Maximum number of results
+	resultsCountSpinbutton->set_value((double)m_properties.getMaximumResultsCount());
+	// Index all results
+	indexCheckbutton->set_active(m_properties.getIndexResults());
+}
+
+queryDialog::~queryDialog()
+{
+}
+
+void queryDialog::populate_comboboxes()
+{
+	unsigned int labelNum = 1;
+	bool foundLanguage = false;
+
+	TreeModel::iterator iter = m_refLabelTree->append();
+	TreeModel::Row row = *iter;
+	row[m_labelColumns.m_name] = "None";
+	labelCombobox->set_active(0);
+
+#ifdef DEBUG
+	cout << "queryDialog::populate_comboboxes: looking for " << m_properties.getLabelName() << endl;
+#endif
+	// Add all labels to the combo and select the one defined for the query
+	for (set<PinotSettings::Label>::const_iterator labelIter = m_labels.begin(); labelIter != m_labels.end(); ++labelIter)
+	{
+		string labelName = labelIter->m_name;
+
+		iter = m_refLabelTree->append();
+		row = *iter;
+		row[m_labelColumns.m_name] = locale_to_utf8(labelName);
+#ifdef DEBUG
+	cout << "queryDialog::populate_comboboxes: added label " << labelName << endl;
+#endif
+
+		if (labelName == m_properties.getLabelName())
+		{
+			labelCombobox->set_active(labelNum);
+			// Keep going
+		}
+		++labelNum;
+	}
+
+	string queryLanguage = m_properties.getLanguage();
+	iter = m_refLanguageTree->append();
+	row = *iter;
+	row[m_languageColumns.m_name] = _("Any");
+
+	// Add all supported languages and select the one defined for the query
+#ifdef DEBUG
+	cout << "queryDialog::populate_comboboxes: looking for " << queryLanguage << endl;
+#endif
+	for (unsigned int languageNum = 0; languageNum < Languages::m_count; ++languageNum)
+	{
+		string languageName = Languages::getIntlName(languageNum);
+		iter = m_refLanguageTree->append();
+		row = *iter;
+		row[m_languageColumns.m_name] = languageName;
+
+		if ((foundLanguage == false) &&
+			(queryLanguage.empty() == false) &&
+			(queryLanguage == languageName))
+		{
+#ifdef DEBUG
+			cout << "queryDialog::populate_comboboxes: found at " << languageNum << endl;
+#endif
+			languageCombobox->set_active(languageNum + 1);
+			foundLanguage = true;
+		}
+	}
+	if (foundLanguage == false)
+	{
+		languageCombobox->set_active(0);
+	}
+}
+
+bool queryDialog::badName(void) const
+{
+	return m_badName;
+}
+void queryDialog::on_queryOkbutton_clicked()
+{
+	// Name
+	m_properties.setName(locale_from_utf8(nameEntry->get_text()));
+	m_badName = false;
+	// Did the name change ?
+	if (m_name != m_properties.getName())
+	{
+		const std::map<string, QueryProperties> &queries = PinotSettings::getInstance().getQueries();
+
+		// Is it already used ?
+		std::map<string, QueryProperties>::const_iterator queryIter = queries.find(m_properties.getName());
+		if (queryIter != queries.end())
+		{
+			// Yes, it is
+			m_badName = true;
+#ifdef DEBUG
+			cout << "queryDialog::on_queryOkbutton_clicked: name in use" << endl;
+#endif
+		}
+	}
+
+	// Query terms
+	m_properties.setAndWords(locale_from_utf8(andEntry->get_text()));
+	m_properties.setPhrase(locale_from_utf8(phraseEntry->get_text()));
+	m_properties.setAnyWords(locale_from_utf8(anyEntry->get_text()));
+	m_properties.setNotWords(locale_from_utf8(notEntry->get_text()));
+	// Language
+	m_properties.setLanguage("");
+	int chosenLanguage = languageCombobox->get_active_row_number();
+	if (chosenLanguage < Languages::m_count + 1)
+	{
+		if (chosenLanguage > 0)
+		{
+			--chosenLanguage;
+			m_properties.setLanguage(Languages::getIntlName(chosenLanguage));
+		}
+	}
+	// Host name
+	m_properties.setHostNameFilter(locale_from_utf8(hostNameEntry->get_text()));
+	// File name
+	m_properties.setFileNameFilter(locale_from_utf8(fileNameEntry->get_text()));
+	// Maximum number of results
+	m_properties.setMaximumResultsCount((unsigned int)resultsCountSpinbutton->get_value());
+	// Index all results
+	m_properties.setIndexResults(indexCheckbutton->get_active());
+	// Label
+	int chosenLabel = labelCombobox->get_active_row_number();
+#ifdef DEBUG
+	cout << "queryDialog::on_queryOkbutton_clicked: chosen label " << chosenLabel << endl;
+#endif
+	if (chosenLabel == 0)
+	{
+		// No label
+		m_properties.setLabelName("");
+	}
+	else
+	{
+		TreeModel::iterator iter = labelCombobox->get_active();
+		TreeModel::Row row = *iter;
+		string labelName = locale_from_utf8(row[m_labelColumns.m_name]);
+
+#ifdef DEBUG
+		cout << "queryDialog::on_queryOkbutton_clicked: label is " << labelName << endl;
+#endif
+		m_properties.setLabelName(labelName);
+	}
+}
+
+void queryDialog::on_nameEntry_changed()
+{
+	ustring name = nameEntry->get_text();
+	if (name.empty() == false)
+	{
+		queryOkbutton->set_sensitive(true);
+	}
+	else
+	{
+		queryOkbutton->set_sensitive(false);
+	}
+}

Added: trunk/UI/GTK2/src/queryDialog.hh
===================================================================
--- trunk/UI/GTK2/src/queryDialog.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/queryDialog.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,48 @@
+// generated 2003/6/13 20:26:49 BST by fabrice at amra.dyndns.org.(none)
+// using glademm V2.0.0
+//
+// newer (non customized) versions of this file go to queryDialog.hh_new
+
+// you might replace
+//    class foo : public foo_glade { ... };
+// by
+//    typedef foo_glade foo;
+// if you didn't make any modifications to the widget
+
+#ifndef _QUERYDIALOG_HH
+#define _QUERYDIALOG_HH
+
+#include <string>
+#include <set>
+#include <gtkmm/liststore.h>
+
+#include "QueryProperties.h"
+#include "ModelColumns.h"
+#include "PinotSettings.h"
+#include "queryDialog_glade.hh"
+
+class queryDialog : public queryDialog_glade
+{
+public:
+	queryDialog(QueryProperties &properties);
+	virtual ~queryDialog();
+
+	bool badName(void) const;
+
+protected:
+	std::string m_name;
+	QueryProperties& m_properties;
+	const std::set<PinotSettings::Label> &m_labels;
+	ComboModelColumns m_labelColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refLabelTree;
+	ComboModelColumns m_languageColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refLanguageTree;
+	bool m_badName;
+
+	void populate_comboboxes();
+
+	virtual void on_queryOkbutton_clicked();
+	virtual void on_nameEntry_changed();
+
+};
+#endif

Added: trunk/UI/GTK2/src/queryDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/queryDialog_glade.cc	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/queryDialog_glade.cc	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,325 @@
+// generated 2005/11/26 12:46:55 SGT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/queryDialog.cc
+
+
+#if defined __GNUC__ && __GNUC__ < 3
+#error This program will crash if compiled with g++ 2.x
+// see the dynamic_cast bug in the gtkmm FAQ
+#endif //
+#include "config.h"
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include <libintl.h>
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+#include <gtkmmconfig.h>
+#if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
+#include <sigc++/compatibility.h>
+#define GMM_GTKMM_22_24(a,b) b
+#else //gtkmm 2.2
+#define GMM_GTKMM_22_24(a,b) a
+#endif //
+#include "queryDialog_glade.hh"
+#include <gdk/gdkkeysyms.h>
+#include <gtkmm/accelgroup.h>
+#include <gtkmm/buttonbox.h>
+#include <gtkmm/label.h>
+#include <gtkmm/table.h>
+#include <gtkmm/adjustment.h>
+#include <gtkmm/box.h>
+
+queryDialog_glade::queryDialog_glade(
+)
+{  queryDialog = this;
+   gmm_data = new GlademmData(get_accel_group());
+   queryCancelbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-cancel")));
+   queryOkbutton = Gtk::manage(new class Gtk::Button(Gtk::StockID("gtk-ok")));
+   
+   Gtk::Label *nameLabel = Gtk::manage(new class Gtk::Label(_("Name:")));
+   nameEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Table *table1 = Gtk::manage(new class Gtk::Table(2, 2, false));
+   anyEntry = Gtk::manage(new class Gtk::Entry());
+   hostNameEntry = Gtk::manage(new class Gtk::Entry());
+   fileNameEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Adjustment *resultsCountSpinbutton_adj = Gtk::manage(new class Gtk::Adjustment(10, 10, 100, 10, 20, 20));
+   resultsCountSpinbutton = Gtk::manage(new class Gtk::SpinButton(*resultsCountSpinbutton_adj, 1, 0));
+   indexCheckbutton = Gtk::manage(new class Gtk::CheckButton(_("Index all results with label")));
+   
+   Gtk::Label *anyLabel = Gtk::manage(new class Gtk::Label(_("Any of the words:")));
+   Gtk::Label *hostLabel = Gtk::manage(new class Gtk::Label(_("Host name:")));
+   Gtk::Label *fileNameLabel = Gtk::manage(new class Gtk::Label(_("File name:")));
+   Gtk::Label *resultsCountLabel = Gtk::manage(new class Gtk::Label(_("Number of results:")));
+   labelCombobox = Gtk::manage(new class Gtk::ComboBox());
+   
+   Gtk::Table *tersmTable = Gtk::manage(new class Gtk::Table(2, 2, false));
+   Gtk::VBox *termsVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   Gtk::Label *propertiesLabel = Gtk::manage(new class Gtk::Label(_("Properties")));
+   Gtk::Label *filtersLabel = Gtk::manage(new class Gtk::Label(_("Limit to documents that match")));
+   phraseEntry = Gtk::manage(new class Gtk::Entry());
+   notEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Label *phraseLabel = Gtk::manage(new class Gtk::Label(_("the exact phrase:")));
+   Gtk::Label *notLabel = Gtk::manage(new class Gtk::Label(_("none of the words:")));
+   Gtk::Label *label14 = Gtk::manage(new class Gtk::Label(_("the language:")));
+   languageCombobox = Gtk::manage(new class Gtk::ComboBox());
+   andEntry = Gtk::manage(new class Gtk::Entry());
+   
+   Gtk::Label *andLabel = Gtk::manage(new class Gtk::Label(_("all the words:")));
+   Gtk::Table *advancedTable = Gtk::manage(new class Gtk::Table(2, 2, false));
+   Gtk::VBox *advancedVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   Gtk::Label *advancedLabel = Gtk::manage(new class Gtk::Label(_("Advanced")));
+   queryNotebook = Gtk::manage(new class Gtk::Notebook());
+   
+   Gtk::VBox *queryVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   queryCancelbutton->set_flags(Gtk::CAN_FOCUS);
+   queryCancelbutton->set_flags(Gtk::CAN_DEFAULT);
+   queryCancelbutton->set_relief(Gtk::RELIEF_NORMAL);
+   queryOkbutton->set_flags(Gtk::CAN_FOCUS);
+   queryOkbutton->set_flags(Gtk::CAN_DEFAULT);
+   queryOkbutton->set_relief(Gtk::RELIEF_NORMAL);
+   queryDialog->get_action_area()->property_layout_style().set_value(Gtk::BUTTONBOX_END);
+   nameLabel->set_alignment(0.5,0.5);
+   nameLabel->set_padding(4,4);
+   nameLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   nameLabel->set_line_wrap(false);
+   nameLabel->set_use_markup(false);
+   nameLabel->set_selectable(false);
+   nameEntry->set_flags(Gtk::CAN_FOCUS);
+   nameEntry->set_visibility(true);
+   nameEntry->set_editable(true);
+   nameEntry->set_max_length(0);
+   nameEntry->set_text(_(""));
+   nameEntry->set_has_frame(true);
+   nameEntry->set_activates_default(false);
+   table1->set_row_spacings(0);
+   table1->set_col_spacings(0);
+   table1->attach(*nameLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::AttachOptions(), 0, 0);
+   table1->attach(*nameEntry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::AttachOptions(), 4, 4);
+   anyEntry->set_flags(Gtk::CAN_FOCUS);
+   anyEntry->set_visibility(true);
+   anyEntry->set_editable(true);
+   anyEntry->set_max_length(0);
+   anyEntry->set_text(_(""));
+   anyEntry->set_has_frame(true);
+   anyEntry->set_activates_default(false);
+   hostNameEntry->set_flags(Gtk::CAN_FOCUS);
+   hostNameEntry->set_visibility(true);
+   hostNameEntry->set_editable(true);
+   hostNameEntry->set_max_length(0);
+   hostNameEntry->set_text(_(""));
+   hostNameEntry->set_has_frame(true);
+   hostNameEntry->set_activates_default(false);
+   fileNameEntry->set_flags(Gtk::CAN_FOCUS);
+   fileNameEntry->set_visibility(true);
+   fileNameEntry->set_editable(true);
+   fileNameEntry->set_max_length(0);
+   fileNameEntry->set_text(_(""));
+   fileNameEntry->set_has_frame(true);
+   fileNameEntry->set_activates_default(false);
+   resultsCountSpinbutton->set_flags(Gtk::CAN_FOCUS);
+   resultsCountSpinbutton->set_update_policy(Gtk::UPDATE_ALWAYS);
+   resultsCountSpinbutton->set_numeric(false);
+   resultsCountSpinbutton->set_digits(0);
+   resultsCountSpinbutton->set_wrap(false);
+   indexCheckbutton->set_flags(Gtk::CAN_FOCUS);
+   indexCheckbutton->set_relief(Gtk::RELIEF_NORMAL);
+   indexCheckbutton->set_mode(true);
+   indexCheckbutton->set_active(false);
+   anyLabel->set_alignment(0,0.5);
+   anyLabel->set_padding(4,4);
+   anyLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   anyLabel->set_line_wrap(false);
+   anyLabel->set_use_markup(false);
+   anyLabel->set_selectable(false);
+   hostLabel->set_alignment(0,0.5);
+   hostLabel->set_padding(4,4);
+   hostLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   hostLabel->set_line_wrap(false);
+   hostLabel->set_use_markup(false);
+   hostLabel->set_selectable(false);
+   fileNameLabel->set_alignment(0,0.5);
+   fileNameLabel->set_padding(4,4);
+   fileNameLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   fileNameLabel->set_line_wrap(false);
+   fileNameLabel->set_use_markup(false);
+   fileNameLabel->set_selectable(false);
+   resultsCountLabel->set_alignment(0,0.5);
+   resultsCountLabel->set_padding(4,4);
+   resultsCountLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   resultsCountLabel->set_line_wrap(false);
+   resultsCountLabel->set_use_markup(false);
+   resultsCountLabel->set_selectable(false);
+   tersmTable->set_row_spacings(0);
+   tersmTable->set_col_spacings(0);
+   tersmTable->attach(*anyEntry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable->attach(*hostNameEntry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable->attach(*fileNameEntry, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable->attach(*resultsCountSpinbutton, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable->attach(*indexCheckbutton, 0, 1, 4, 5, Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable->attach(*anyLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   tersmTable->attach(*hostLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   tersmTable->attach(*fileNameLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
+   tersmTable->attach(*resultsCountLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   tersmTable->attach(*labelCombobox, 1, 2, 4, 5, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   termsVbox->pack_start(*tersmTable, Gtk::PACK_SHRINK, 4);
+   propertiesLabel->set_alignment(0.5,0.5);
+   propertiesLabel->set_padding(0,0);
+   propertiesLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   propertiesLabel->set_line_wrap(false);
+   propertiesLabel->set_use_markup(false);
+   propertiesLabel->set_selectable(false);
+   filtersLabel->set_alignment(0,0.5);
+   filtersLabel->set_padding(4,4);
+   filtersLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   filtersLabel->set_line_wrap(false);
+   filtersLabel->set_use_markup(false);
+   filtersLabel->set_selectable(false);
+   phraseEntry->set_flags(Gtk::CAN_FOCUS);
+   phraseEntry->set_visibility(true);
+   phraseEntry->set_editable(true);
+   phraseEntry->set_max_length(0);
+   phraseEntry->set_text(_(""));
+   phraseEntry->set_has_frame(true);
+   phraseEntry->set_activates_default(false);
+   notEntry->set_flags(Gtk::CAN_FOCUS);
+   notEntry->set_visibility(true);
+   notEntry->set_editable(true);
+   notEntry->set_max_length(0);
+   notEntry->set_text(_(""));
+   notEntry->set_has_frame(true);
+   notEntry->set_activates_default(false);
+   phraseLabel->set_alignment(0,0.5);
+   phraseLabel->set_padding(4,4);
+   phraseLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   phraseLabel->set_line_wrap(false);
+   phraseLabel->set_use_markup(false);
+   phraseLabel->set_selectable(false);
+   notLabel->set_alignment(0,0.5);
+   notLabel->set_padding(4,4);
+   notLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   notLabel->set_line_wrap(false);
+   notLabel->set_use_markup(false);
+   notLabel->set_selectable(false);
+   label14->set_alignment(0,0.5);
+   label14->set_padding(4,4);
+   label14->set_justify(Gtk::JUSTIFY_LEFT);
+   label14->set_line_wrap(false);
+   label14->set_use_markup(false);
+   label14->set_selectable(false);
+   andEntry->set_flags(Gtk::CAN_FOCUS);
+   andEntry->set_visibility(true);
+   andEntry->set_editable(true);
+   andEntry->set_max_length(0);
+   andEntry->set_text(_(""));
+   andEntry->set_has_frame(true);
+   andEntry->set_activates_default(false);
+   andLabel->set_alignment(0,0.5);
+   andLabel->set_padding(4,4);
+   andLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   andLabel->set_line_wrap(false);
+   andLabel->set_use_markup(false);
+   andLabel->set_selectable(false);
+   advancedTable->set_row_spacings(0);
+   advancedTable->set_col_spacings(0);
+   advancedTable->attach(*phraseEntry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   advancedTable->attach(*notEntry, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   advancedTable->attach(*phraseLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   advancedTable->attach(*notLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
+   advancedTable->attach(*label14, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   advancedTable->attach(*languageCombobox, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   advancedTable->attach(*andEntry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   advancedTable->attach(*andLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   advancedVbox->pack_start(*filtersLabel, Gtk::PACK_SHRINK, 4);
+   advancedVbox->pack_start(*advancedTable, Gtk::PACK_SHRINK, 0);
+   advancedLabel->set_alignment(0.5,0.5);
+   advancedLabel->set_padding(0,0);
+   advancedLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   advancedLabel->set_line_wrap(false);
+   advancedLabel->set_use_markup(false);
+   advancedLabel->set_selectable(false);
+   queryNotebook->set_flags(Gtk::CAN_FOCUS);
+   queryNotebook->set_show_tabs(true);
+   queryNotebook->set_show_border(true);
+   queryNotebook->set_tab_pos(Gtk::POS_TOP);
+   queryNotebook->set_scrollable(false);
+   queryNotebook->append_page(*termsVbox, *propertiesLabel);
+   queryNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   queryNotebook->append_page(*advancedVbox, *advancedLabel);
+   queryNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+   queryVbox->pack_start(*table1, Gtk::PACK_SHRINK, 0);
+   queryVbox->pack_start(*queryNotebook);
+   queryDialog->get_vbox()->set_homogeneous(false);
+   queryDialog->get_vbox()->set_spacing(0);
+   queryDialog->get_vbox()->pack_start(*queryVbox);
+   queryDialog->set_title(_("Query properties"));
+   queryDialog->set_modal(false);
+   queryDialog->property_window_position().set_value(Gtk::WIN_POS_NONE);
+   queryDialog->set_resizable(true);
+   queryDialog->property_destroy_with_parent().set_value(false);
+   queryDialog->set_has_separator(true);
+   queryDialog->add_action_widget(*queryCancelbutton, -6);
+   queryDialog->add_action_widget(*queryOkbutton, -5);
+   queryCancelbutton->show();
+   queryOkbutton->show();
+   nameLabel->show();
+   nameEntry->show();
+   table1->show();
+   anyEntry->show();
+   hostNameEntry->show();
+   fileNameEntry->show();
+   resultsCountSpinbutton->show();
+   indexCheckbutton->show();
+   anyLabel->show();
+   hostLabel->show();
+   fileNameLabel->show();
+   resultsCountLabel->show();
+   labelCombobox->show();
+   tersmTable->show();
+   termsVbox->show();
+   propertiesLabel->show();
+   filtersLabel->show();
+   phraseEntry->show();
+   notEntry->show();
+   phraseLabel->show();
+   notLabel->show();
+   label14->show();
+   languageCombobox->show();
+   andEntry->show();
+   andLabel->show();
+   advancedTable->show();
+   advancedVbox->show();
+   advancedLabel->show();
+   queryNotebook->show();
+   queryVbox->show();
+   queryDialog->show();
+   queryOkbutton->signal_clicked().connect(SigC::slot(*this, &queryDialog_glade::on_queryOkbutton_clicked), false);
+   nameEntry->signal_changed().connect(SigC::slot(*this, &queryDialog_glade::on_nameEntry_changed), false);
+}
+
+queryDialog_glade::~queryDialog_glade()
+{  delete gmm_data;
+}

Added: trunk/UI/GTK2/src/queryDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/queryDialog_glade.hh	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/GTK2/src/queryDialog_glade.hh	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,71 @@
+// generated 2005/11/26 12:46:55 SGT by fabrice at amra.dyndns.org.(none)
+// using glademm V2.6.0
+//
+// DO NOT EDIT THIS FILE ! It was created using
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
+// for gtk 2.6.10 and gtkmm 2.6.2
+//
+// Please modify the corresponding derived classes in ./src/queryDialog.hh and./src/queryDialog.cc
+
+#ifndef _QUERYDIALOG_GLADE_HH
+#  define _QUERYDIALOG_GLADE_HH
+
+
+#if !defined(GLADEMM_DATA)
+#define GLADEMM_DATA 
+#include <gtkmm/accelgroup.h>
+
+class GlademmData
+{  
+        
+        Glib::RefPtr<Gtk::AccelGroup> accgrp;
+public:
+        
+        GlademmData(Glib::RefPtr<Gtk::AccelGroup> ag) : accgrp(ag)
+        {  
+        }
+        
+        Glib::RefPtr<Gtk::AccelGroup>  getAccelGroup()
+        {  return accgrp;
+        }
+};
+#endif //GLADEMM_DATA
+
+#include <gtkmm/dialog.h>
+#include <gtkmm/button.h>
+#include <gtkmm/entry.h>
+#include <gtkmm/spinbutton.h>
+#include <gtkmm/checkbutton.h>
+#include <gtkmm/combobox.h>
+#include <gtkmm/notebook.h>
+
+class queryDialog_glade : public Gtk::Dialog
+{  
+        
+        GlademmData *gmm_data;
+public:
+        class Gtk::Dialog * queryDialog;
+protected:
+        class Gtk::Button * queryCancelbutton;
+        class Gtk::Button * queryOkbutton;
+        class Gtk::Entry * nameEntry;
+        class Gtk::Entry * anyEntry;
+        class Gtk::Entry * hostNameEntry;
+        class Gtk::Entry * fileNameEntry;
+        class Gtk::SpinButton * resultsCountSpinbutton;
+        class Gtk::CheckButton * indexCheckbutton;
+        class Gtk::ComboBox * labelCombobox;
+        class Gtk::Entry * phraseEntry;
+        class Gtk::Entry * notEntry;
+        class Gtk::ComboBox * languageCombobox;
+        class Gtk::Entry * andEntry;
+        class Gtk::Notebook * queryNotebook;
+        
+        queryDialog_glade();
+        
+        ~queryDialog_glade();
+private:
+        virtual void on_queryOkbutton_clicked() = 0;
+        virtual void on_nameEntry_changed() = 0;
+};
+#endif

Added: trunk/UI/GTK2/xapian-powered.png
===================================================================
(Binary files differ)


Property changes on: trunk/UI/GTK2/xapian-powered.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/UI/RenderHTML/Makefile
===================================================================
--- trunk/UI/RenderHTML/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/RenderHTML/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,21 @@
+
+ROOT_DIR = ../..
+include ${ROOT_DIR}/variables.mk
+
+CXXFLAGS += -DHAVE_CONFIG_H -I. -I.. ${GTKMOZ_CXXFLAGS} 
+
+LIBS += ${GTKMOZ_LIBS}
+
+HTML_SRCS = MozillaRenderer.cpp
+HTML_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${HTML_SRCS})
+
+targets : dirs ${HTML_LIB}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${HTML_LIB}
+
+# Library
+ 
+${HTML_LIB} : ${HTML_OBJS}
+	@echo Building ${HTML_LIB}
+	${AR} cr ${HTML_LIB} ${HTML_OBJS}


Property changes on: trunk/UI/RenderHTML/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/UI/RenderHTML/MozillaRenderer.cpp
===================================================================
--- trunk/UI/RenderHTML/MozillaRenderer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/RenderHTML/MozillaRenderer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,223 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+#include <iostream>
+#include <gtkmozembed.h>
+
+#include "MozillaRenderer.h"
+
+MozillaRenderer::MozillaRenderer()
+{
+	gtk_moz_embed_push_startup();
+
+	// Create our web browser component
+	m_htmlWidget = gtk_moz_embed_new();
+	if (m_htmlWidget != NULL)
+	{
+		// Turn off all features
+		gtk_moz_embed_set_chrome_mask(GTK_MOZ_EMBED(m_htmlWidget), 0);
+#ifdef DEBUG
+		cout << "MozillaRenderer::ctor: embedded Mozilla" << endl;
+#endif
+	}
+#ifdef DEBUG
+	else cerr << "MozillaRenderer::ctor: failed to embed Mozilla" << endl;
+#endif
+	m_rendering = false;
+}
+
+MozillaRenderer::~MozillaRenderer()
+{
+	gtk_moz_embed_pop_startup();
+}
+
+/// Returns the GTK widget.
+GtkWidget *MozillaRenderer::getWidget(void)
+{
+	return m_htmlWidget;
+}
+
+/// Renders HTML held in a buffer.
+bool MozillaRenderer::renderData(const char *data, unsigned int length, const string &baseUrl)
+{
+	if ((m_htmlWidget == NULL) ||
+		(data == NULL) ||
+		(length == 0))
+	{
+		return false;
+	}
+
+#ifdef DEBUG
+	cout << "MozillaRenderer::renderData: data length " << strlen(data) << "/" << length << " at " << baseUrl << endl;
+#endif
+	gtk_moz_embed_open_stream(GTK_MOZ_EMBED(m_htmlWidget), baseUrl.c_str(), "text/html");
+	// Append data to stream in medium-sized chunks
+	const char *where = data;
+	unsigned int total = length, chunk = 0;
+	while (total > 0)
+	{
+		if (total > 15000)
+		{
+			chunk = 15000;
+		}
+		else
+		{
+			chunk = total;
+		}
+#ifdef DEBUG
+		cout << "MozillaRenderer::renderData: appending " << chunk << " to stream" << endl;
+#endif
+		gtk_moz_embed_append_data(GTK_MOZ_EMBED(m_htmlWidget), where, chunk);
+
+		where += chunk;
+		total = total - chunk;
+	}
+	gtk_moz_embed_close_stream(GTK_MOZ_EMBED(m_htmlWidget));
+	m_rendering = true;
+
+	return true;
+}
+
+/// Renders the given URL.
+bool MozillaRenderer::renderUrl(const string &url)
+{
+	if (m_htmlWidget != NULL)
+	{
+#ifdef DEBUG
+		cout << "MozillaRenderer::renderUrl: url " << url << endl;
+#endif
+		gtk_moz_embed_load_url(GTK_MOZ_EMBED(m_htmlWidget), url.c_str());
+		m_rendering = true;
+	}
+
+	return m_rendering;
+}
+
+/// Returns the current location.
+string MozillaRenderer::getLocation(void)
+{
+	if ((m_htmlWidget == NULL) ||
+		(m_rendering == false))
+	{
+		return "";
+	}
+
+	char *location = gtk_moz_embed_get_location(GTK_MOZ_EMBED(m_htmlWidget));
+	if (location == NULL)
+	{
+		return "";
+	}
+	string locationStr = location;
+	free(location);
+
+	return locationStr;
+}
+
+/// Returns the currently displayed document's title.
+string MozillaRenderer::getTitle(void)
+{
+	if ((m_htmlWidget == NULL) ||
+		(m_rendering == false))
+	{
+		return "";
+	}
+
+	char *title = gtk_moz_embed_get_title(GTK_MOZ_EMBED(m_htmlWidget));
+	if (title == NULL)
+	{
+		return "";
+	}
+	string titleStr = title;
+	free(title);
+
+	return titleStr;
+}
+
+/// Goes forward.
+bool MozillaRenderer::goForward(void)
+{
+	if (canGoForward() == true)
+	{
+		gtk_moz_embed_go_forward(GTK_MOZ_EMBED(m_htmlWidget));
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Goes back.
+bool MozillaRenderer::goBack(void)
+{
+	if (canGoForward() == true)
+	{
+		gtk_moz_embed_go_back(GTK_MOZ_EMBED(m_htmlWidget));
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Reloads the current page.
+bool MozillaRenderer::reload(void)
+{
+	if ((m_htmlWidget == NULL) ||
+		(m_rendering == false))
+	{
+		return false;
+	}
+
+	gtk_moz_embed_reload(GTK_MOZ_EMBED(m_htmlWidget), GTK_MOZ_EMBED_FLAG_RELOADNORMAL);
+
+	return true;	
+}
+
+/// Stops loading.
+bool MozillaRenderer::stop(void)
+{
+	if ((m_htmlWidget == NULL) ||
+		(m_rendering == false))
+	{
+		return false;
+	}
+
+	gtk_moz_embed_stop_load(GTK_MOZ_EMBED(m_htmlWidget));
+
+	return true;	
+}
+
+bool MozillaRenderer::canGoForward(void)
+{
+	if ((m_htmlWidget == NULL) ||
+		(m_rendering == false))
+	{
+		return false;
+	}
+
+	return gtk_moz_embed_can_go_forward(GTK_MOZ_EMBED(m_htmlWidget));
+}
+
+bool MozillaRenderer::canGoBack(void)
+{
+	if ((m_htmlWidget == NULL) ||
+		(m_rendering == false))
+	{
+		return false;
+	}
+
+	return gtk_moz_embed_can_go_back(GTK_MOZ_EMBED(m_htmlWidget));
+}

Added: trunk/UI/RenderHTML/MozillaRenderer.h
===================================================================
--- trunk/UI/RenderHTML/MozillaRenderer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/UI/RenderHTML/MozillaRenderer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,78 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MOZILLARENDERER_H
+#define _MOZILLARENDERER_H
+
+#include <string>
+#include <gtk/gtkwidget.h>
+
+using namespace std;
+
+/**
+  * A class that renders HTML using gtk-mozembed.
+  * See documentation at http://www.mozilla.org/unix/gtk-embedding.html
+  */
+class MozillaRenderer
+{
+	public:
+		MozillaRenderer();
+		virtual ~MozillaRenderer();
+
+		/// Returns the GTK widget.
+		GtkWidget *getWidget(void);
+
+		/// Renders HTML held in a buffer.
+		bool renderData(const char *data, unsigned int length, const string &baseUrl);
+
+		/// Renders the given URL.
+		bool renderUrl(const string &url);
+
+		/// Returns the current location.
+		string getLocation(void);
+
+		/// Returns the currently displayed document's title.
+		string getTitle(void);
+
+		/// Goes forward.
+		bool goForward(void);
+
+		/// Goes back.
+		bool goBack(void);
+
+		/// Reloads the current page.
+		bool reload(void);
+
+		/// Stops loading.
+		bool stop(void);
+
+		/// Returns true if renderer can go forward.
+		bool canGoForward(void);
+
+		/// Returns true if renderer can go back.
+		bool canGoBack(void);
+
+	protected:
+		GtkWidget *m_htmlWidget;
+		bool m_rendering;
+
+	private:
+		MozillaRenderer(const MozillaRenderer &other);
+		MozillaRenderer &operator=(const MozillaRenderer &other);
+
+};
+
+#endif // _MOZILLARENDERER_H

Added: trunk/Utils/Document.cpp
===================================================================
--- trunk/Utils/Document.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Document.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,218 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <iostream>
+
+#include "Document.h"
+
+using std::cout;
+using std::endl;
+using std::string;
+
+Document::Document() :
+	DocumentInfo(),
+	m_pData(NULL),
+	m_dataLength(0),
+	m_isMapped(false)
+{
+}
+
+Document::Document(const string &title, const string &location,
+	const string &type, const string &language) :
+	DocumentInfo(title, location, type, language),
+	m_pData(NULL),
+	m_dataLength(0),
+	m_isMapped(false)
+{
+}
+
+Document::Document(const Document &other) :
+	DocumentInfo(other),
+	m_pData(NULL),
+	m_dataLength(0),
+	m_isMapped(false)
+{
+	setData(other.m_pData, other.m_dataLength);
+}
+
+Document::~Document()
+{
+	freeData();
+}
+
+Document& Document::operator=(const Document& other)
+{
+	DocumentInfo::operator=(other);
+	setData(other.m_pData, other.m_dataLength);
+
+	return *this;
+}
+
+bool Document::operator<(const Document& other) const
+{
+	if (DocumentInfo::operator<(other) == false)
+	{
+		if (m_dataLength < other.m_dataLength)
+		{
+			return true;
+		}
+
+		return false;
+	}
+
+	return true;
+}
+
+void Document::freeData(void)
+{
+	if (m_pData != NULL)
+	{
+		if (m_isMapped == false)
+		{
+			// Free
+			free(m_pData);
+		}
+		else
+		{
+			// Unmap
+			munmap((void*)m_pData, m_dataLength);
+		}
+	}
+
+	m_pData = NULL;
+	m_dataLength = 0;
+	m_isMapped = false;
+}
+
+/// Copies the given data in the document.
+bool Document::setData(const char *data, unsigned int length)
+{
+	if ((data == NULL) ||
+		(length == 0))
+	{
+		return false;
+	}
+
+	// Discard existing data
+	freeData();
+
+	m_pData = (char *)malloc(sizeof(char) * (length + 1));
+	if (m_pData != NULL)
+	{
+		memcpy(m_pData, data, length);
+		m_pData[length] = '\0';
+		m_dataLength = length;
+
+		return true;
+	}
+
+	return false;
+}
+
+/// Maps the given file.
+bool Document::setDataFromFile(const string &fileName)
+{
+	struct stat fileStat;
+
+	if (fileName.empty() == true)
+	{
+		return false;
+	}
+
+	// Make sure the file exists
+	if ((stat(fileName.c_str(), &fileStat) != 0) ||
+		(!S_ISREG(fileStat.st_mode)))
+	{
+#ifdef DEBUG
+		cout << "Document::setDataFromFile: " << fileName << " is not a file" << endl;
+#endif
+		return false;
+	}
+
+	// Open the file in read-only mode
+	int fd = open(fileName.c_str(), O_RDONLY);
+	if (fd == -1)
+	{
+#ifdef DEBUG
+		cout << "Document::setDataFromFile: " << fileName << " couldn't be opened" << endl;
+#endif
+		return false;
+	}
+
+	// Discard existing data
+	freeData();
+
+	// Request a private mapping of the whole file
+	void *mapSpace = mmap(NULL, fileStat.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
+	if (mapSpace != MAP_FAILED)
+	{
+		m_pData = (char*)mapSpace;
+		m_dataLength = fileStat.st_size;
+		m_isMapped = true;
+	}
+#ifdef DEBUG
+	else	cout << "Document::setDataFromFile: mapping failed" << endl;
+#endif
+
+	// Close the file
+	if (close(fd) == -1)
+	{
+#ifdef DEBUG
+		cout << "Document::setDataFromFile: close failed" << endl;
+#endif
+	}
+
+	return m_isMapped;
+}
+
+/// Returns the document's data; NULL if document is empty.
+const char *Document::getData(unsigned int &length) const
+{
+	length = m_dataLength;
+	return m_pData;
+}
+
+/// Checks whether the document is binary.
+bool Document::isBinary(void) const
+{
+	unsigned int maxLen = 100;
+
+	// Look at the first 100 bytes or so
+	if (m_dataLength < 100)
+	{
+		maxLen = m_dataLength;
+	}
+	for (unsigned int i = 0; i < maxLen; ++i)
+	{
+		if (isascii(m_pData[i]) == 0)
+		{
+#ifdef DEBUG
+			cout << "Document::isBinary: " << m_pData[i] << endl;
+#endif
+			return true;
+		}
+	}
+
+	return false;
+}

Added: trunk/Utils/Document.h
===================================================================
--- trunk/Utils/Document.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Document.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,58 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DOCUMENT_H
+#define _DOCUMENT_H
+
+#include <string>
+
+#include "DocumentInfo.h"
+
+class Document : public DocumentInfo
+{
+	public:
+		Document();
+		Document(const std::string &title, const std::string &location,
+			const std::string &type, const std::string &language);
+		Document(const Document &other);
+		virtual ~Document();
+
+		Document& operator=(const Document& other);
+
+		bool operator<(const Document& other) const;
+
+		/// Copies the given data in the document.
+		virtual bool setData(const char *data, unsigned int length);
+
+		/// Maps the given file.
+		virtual bool setDataFromFile(const std::string &fileName);
+
+		/// Returns the document's data; NULL if document is empty.
+		virtual const char *getData(unsigned int &length) const;
+
+		/// Checks whether the document is binary.
+		virtual bool isBinary(void) const;
+
+	protected:
+		char *m_pData;
+		unsigned int m_dataLength;
+		bool m_isMapped;
+
+		void freeData(void);
+
+};
+	
+#endif // _DOCUMENT_H

Added: trunk/Utils/DocumentInfo.cpp
===================================================================
--- trunk/Utils/DocumentInfo.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/DocumentInfo.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,129 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "TimeConverter.h"
+#include "DocumentInfo.h"
+
+using std::string;
+
+DocumentInfo::DocumentInfo()
+{
+	m_timestamp = TimeConverter::toTimestamp(time(NULL));
+}
+
+DocumentInfo::DocumentInfo(const string &title, const string &location,
+	const string &type, const string &language)
+{
+	m_title = title;
+	m_location = location;
+	m_type = type;
+	m_language = language;
+	m_timestamp = TimeConverter::toTimestamp(time(NULL));
+}
+
+DocumentInfo::DocumentInfo(const DocumentInfo &other)
+{
+	m_title = other.m_title;
+	m_location = other.m_location;
+	m_type = other.m_type;
+	m_language = other.m_language;
+	m_timestamp = other.m_timestamp;
+}
+
+DocumentInfo::~DocumentInfo()
+{
+}
+
+DocumentInfo& DocumentInfo::operator=(const DocumentInfo& other)
+{
+	m_title = other.m_title;
+	m_location = other.m_location;
+	m_type = other.m_type;
+	m_language = other.m_language;
+	m_timestamp = other.m_timestamp;
+
+	return *this;
+}
+
+bool DocumentInfo::operator<(const DocumentInfo& other) const
+{
+	if (m_title < other.m_title)
+	{
+		return true;
+	}
+
+	return false;
+}
+
+/// Sets the title of the document.
+void DocumentInfo::setTitle(const string &title)
+{
+	m_title = title;
+}
+
+/// Returns the title of the document.
+string DocumentInfo::getTitle(void) const
+{
+	return m_title;
+}
+
+/// Sets the original location of the document.
+void DocumentInfo::setLocation(const string &location)
+{
+	m_location = location;
+}
+
+/// Returns the original location of the document.
+string DocumentInfo::getLocation(void) const
+{
+	return m_location;
+}
+
+/// Sets the type of the document.
+void DocumentInfo::setType(const string &type)
+{
+	m_type = type;
+}
+
+/// Returns the type of the document.
+string DocumentInfo::getType(void) const
+{
+	return m_type;
+}
+
+/// Sets the language of the document.
+void DocumentInfo::setLanguage(const string &language)
+{
+	m_language = language;
+}
+
+/// Returns the document's language.
+string DocumentInfo::getLanguage(void) const
+{
+	return m_language;
+}
+
+/// Sets the document's timestamp.
+void DocumentInfo::setTimestamp(const string &timestamp)
+{
+	m_timestamp = timestamp;
+}
+
+/// Returns the document's timestamp.
+string DocumentInfo::getTimestamp(void) const
+{
+	return m_timestamp;
+}

Added: trunk/Utils/DocumentInfo.h
===================================================================
--- trunk/Utils/DocumentInfo.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/DocumentInfo.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,74 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _DOCUMENT_INFO_H
+#define _DOCUMENT_INFO_H
+
+#include <string>
+
+class DocumentInfo
+{
+	public:
+		DocumentInfo();
+		DocumentInfo(const std::string &title, const std::string &location,
+			const std::string &type, const std::string &language);
+		DocumentInfo(const DocumentInfo &other);
+		virtual ~DocumentInfo();
+
+		DocumentInfo& operator=(const DocumentInfo& other);
+
+		bool operator<(const DocumentInfo& other) const;
+
+		/// Sets the title of the document.
+		virtual void setTitle(const std::string &title);
+
+		/// Returns the title of the document.
+		virtual std::string getTitle(void) const;
+
+		/// Sets the original location of the document.
+		virtual void setLocation(const std::string &location);
+
+		/// Returns the original location of the document.
+		virtual std::string getLocation(void) const;
+
+		/// Sets the type of the document.
+		virtual void setType(const std::string &type);
+
+		/// Returns the type of the document.
+		virtual std::string getType(void) const;
+
+		/// Sets the language of the document.
+		virtual void setLanguage(const std::string &language);
+
+		/// Returns the document's language.
+		virtual std::string getLanguage(void) const;
+
+		/// Sets the document's timestamp.
+		virtual void setTimestamp(const std::string &timestamp);
+
+		/// Returns the document's timestamp.
+		virtual std::string getTimestamp(void) const;
+
+	protected:
+		std::string m_title;
+		std::string m_location;
+		std::string m_type;
+		std::string m_language;
+		std::string m_timestamp;
+
+};
+	
+#endif // _DOCUMENT_INFO_H

Added: trunk/Utils/HtmlDocument.cpp
===================================================================
--- trunk/Utils/HtmlDocument.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/HtmlDocument.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,72 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <ctype.h>
+#include <stdlib.h>
+
+#include "HtmlDocument.h"
+
+using std::string;
+
+HtmlDocument::HtmlDocument(const string &title, const string &location,
+	const string &type, const string &language) :
+	Document(title, location, type, language)
+{
+}
+
+HtmlDocument::HtmlDocument(const HtmlDocument &other) :
+	Document(other)
+{
+}
+
+HtmlDocument::~HtmlDocument()
+{
+}
+
+/// Copies the given data in the document.
+bool HtmlDocument::setData(const char *data, unsigned int length)
+{
+	if ((data == NULL) ||
+		(length == 0))
+	{
+		return false;
+	}
+
+	// Discard existing data
+	freeData();
+
+	// FIXME: there must be a way of getting rid of this
+	m_pData = (char *)calloc(length + 1, sizeof(char));
+	if (m_pData != NULL)
+	{
+		// Removing non-printable characters, as found in pages from alltheweb sometimes
+		// They prevent us from using strstr() and mess up the regexps
+		for (unsigned int i = 0; i < length; ++i)
+		{
+			if (isprint(data[i]) == 0)
+			{
+				m_pData[i] = ' ';
+			}
+			else
+			{
+				m_pData[i] = data[i];
+			}
+		}
+		m_dataLength = length;
+	}
+
+	return true;
+}

Added: trunk/Utils/HtmlDocument.h
===================================================================
--- trunk/Utils/HtmlDocument.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/HtmlDocument.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,37 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _HTML_DOCUMENT_H
+#define _HTML_DOCUMENT_H
+
+#include <string>
+
+#include "Document.h"
+
+class HtmlDocument : public Document
+{
+	public:
+		HtmlDocument(const std::string &title, const std::string &location,
+			const std::string &type, const std::string &language);
+		HtmlDocument(const HtmlDocument &other);
+		virtual ~HtmlDocument();
+
+		/// Copies the given data in the document.
+		virtual bool setData(const char *data, unsigned int length);
+
+};
+	
+#endif // _HTML_DOCUMENT_H

Added: trunk/Utils/IndexedDocument.cpp
===================================================================
--- trunk/Utils/IndexedDocument.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/IndexedDocument.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,75 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "Url.h"
+#include "IndexedDocument.h"
+
+using std::string;
+
+IndexedDocument::IndexedDocument(const string &title, const string &location,
+	const string &originalLocation, const string &type, const string &language) :
+	Document(title, location, type, language)
+{
+	m_originalLocation = originalLocation;
+}
+
+IndexedDocument::IndexedDocument(const IndexedDocument &other) :
+	Document(other)
+{
+	m_originalLocation = other.m_originalLocation;
+}
+
+IndexedDocument::~IndexedDocument()
+{
+}
+
+IndexedDocument& IndexedDocument::operator=(const IndexedDocument& other)
+{
+	m_originalLocation = other.m_originalLocation;
+}
+
+/// Returns the document ID.
+unsigned int IndexedDocument::getID(void) const
+{
+	unsigned int docId = 0;
+
+	// Double-check the URL
+	Url urlObj(m_location);
+	if ((urlObj.getProtocol() == "xapian") ||
+		(urlObj.getFile() != ""))
+	{
+		// The document ID is the final part of the URL, ie the file
+		int val = atoi(urlObj.getFile().c_str());
+		if (val > 0)
+		{
+			docId = (unsigned int)val;
+		}
+	}
+
+	return docId;
+}
+
+/// Sets the original location of the document.
+void IndexedDocument::setOriginalLocation(const string &originalLocation)
+{
+	m_originalLocation = originalLocation;
+}
+
+/// Returns the original location of the document.
+string IndexedDocument::getOriginalLocation(void) const
+{
+	return m_originalLocation;
+}

Added: trunk/Utils/IndexedDocument.h
===================================================================
--- trunk/Utils/IndexedDocument.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/IndexedDocument.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _INDEXED_DOCUMENT_H
+#define _INDEXED_DOCUMENT_H
+
+#include <string>
+
+#include "Document.h"
+
+class IndexedDocument : public Document
+{
+	public:
+		IndexedDocument(const std::string &title, const std::string &location,
+			const std::string &originalLocation, const std::string &type,
+			const std::string &language);
+		IndexedDocument(const IndexedDocument &other);
+		virtual ~IndexedDocument();
+
+		IndexedDocument& operator=(const IndexedDocument& other);
+
+		/// Returns the document ID.
+		virtual unsigned int getID(void) const;
+
+		/// Sets the original location of the document.
+		virtual void setOriginalLocation(const std::string &originalLocation);
+
+		/// Returns the original location of the document.
+		virtual std::string getOriginalLocation(void) const;
+
+	protected:
+		std::string m_originalLocation;
+
+};
+	
+#endif // _INDEXED_DOCUMENT_H

Added: trunk/Utils/Languages.cpp
===================================================================
--- trunk/Utils/Languages.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Languages.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,58 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "Languages.h"
+
+using std::string;
+using std::map;
+using std::pair;
+
+unsigned int Languages::m_count = 12;
+
+char *Languages::m_names[] = {"Danish", "Dutch", "English", "Finnish", \
+	"French", "German", "Italian", "Norwegian", "Portuguese", "Russian", \
+	"Spanish", "Swedish" };
+
+char *Languages::m_codes[] = { "da", "nl", "en", "fi", "fr", "de", \
+	"it", "nn", "pt", "ru", "es", "sv" };
+
+map<unsigned int, string> Languages::m_intlNames;
+
+Languages::Languages()
+{
+}
+
+Languages::~Languages()
+{
+}
+
+bool Languages::setIntlName(unsigned int num, const string &name)
+{
+		pair<map<unsigned int, string>::iterator, bool> insertPair = m_intlNames.insert(pair<unsigned int, string>(num, name));
+		// Was it inserted ?
+		return insertPair.second;
+}
+
+string Languages::getIntlName(unsigned int num)
+{
+	map<unsigned int, string>::iterator iter = m_intlNames.find(num);
+	if (iter == m_intlNames.end())
+	{
+		return "";
+	}
+
+	return iter->second;
+}


Property changes on: trunk/Utils/Languages.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/Languages.h
===================================================================
--- trunk/Utils/Languages.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Languages.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _LANGUAGES_H
+#define _LANGUAGES_H
+
+#include <string>
+#include <map>
+
+class Languages
+{
+	public:
+		virtual ~Languages();
+
+		/// Sets the name for the given code.
+		static bool setIntlName(unsigned int num, const std::string &name);
+
+		/// Gets the name for the given code.
+		static std::string getIntlName(unsigned int num);
+
+		static unsigned int m_count;
+		static char *m_codes[];
+		static char *m_names[];
+
+	protected:
+		static std::map<unsigned int, std::string> m_intlNames;
+
+		Languages();
+
+	private:
+		Languages(const Languages &other);
+		Languages &operator=(const Languages &other);
+
+};
+
+#endif // _LANGUAGES_H


Property changes on: trunk/Utils/Languages.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/MIMEScanner.cpp
===================================================================
--- trunk/Utils/MIMEScanner.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/MIMEScanner.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,120 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <strings.h>
+#include <magic.h>
+
+#include "Url.h"
+#include "MIMEScanner.h"
+
+using std::string;
+
+MIMEScanner::MIMEScanner()
+{
+}
+
+string MIMEScanner::scanFileType(const std::string &fileName)
+{
+	string::size_type fileExtPos = fileName.find_last_of(".");
+	if (fileExtPos != string::npos)
+	{
+		string fileExt = fileName.substr(fileExtPos);
+
+		if (strncasecmp(fileExt.c_str(), ".txt", 4) == 0)
+		{
+			return "text/plain";
+		}
+		else if (strncasecmp(fileExt.c_str(), ".html", 5) == 0)
+		{
+			return "text/html";
+		}
+		else if (strncasecmp(fileExt.c_str(), ".xml", 4) == 0)
+		{
+			return "text/xml";
+		}
+		else if (strncasecmp(fileExt.c_str(), ".pdf", 4) == 0)
+		{
+			return "application/pdf";
+		}
+		else if (strncasecmp(fileExt.c_str(), ".ps", 3) == 0)
+		{
+			return "application/postscript";
+		}
+	}
+
+	// Unknown type
+	return "";
+}
+
+/// Finds out the given file's MIME type.
+string MIMEScanner::scanFile(const string &fileName)
+{
+	if (fileName.empty() == true)
+	{
+		return "";
+	}
+
+	// Does it have an obvious extension ?
+	string mimeType = scanFileType(fileName);
+	if (mimeType.empty() == false)
+	{
+		return mimeType;
+	}
+
+	// Open
+	magic_t magicCookie = magic_open(MAGIC_SYMLINK|MAGIC_MIME);
+	if (magicCookie == NULL)
+	{
+		return "";
+	}
+	if (magic_load(magicCookie, NULL) == -1)
+	{
+		magic_close(magicCookie);
+		return "";
+	}
+
+	const char *type = magic_file(magicCookie, fileName.c_str());
+	if (type != NULL)
+	{
+		mimeType = type;
+
+		// The MIME string might be of the form "mime_type; charset=..."
+		string::size_type mimeTypeEnd = mimeType.find(";");
+		if (mimeTypeEnd != string::npos)
+		{
+			mimeType.resize(mimeTypeEnd);
+		}
+	}
+
+	// Close
+	magic_close(magicCookie);
+
+	return mimeType;
+}
+
+/// Finds out the given URL's MIME type.
+string MIMEScanner::scanUrl(const Url &urlObj)
+{
+	string fileName = urlObj.getFile();
+
+	string mimeType = scanFileType(fileName);
+	if (mimeType.empty() == true)
+	{
+		mimeType = "text/plain";
+	}
+
+	return mimeType;
+}

Added: trunk/Utils/MIMEScanner.h
===================================================================
--- trunk/Utils/MIMEScanner.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/MIMEScanner.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,44 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MIME_SCANNER_H
+#define _MIME_SCANNER_H
+
+#include <string>
+
+#include "Url.h"
+
+class MIMEScanner
+{
+	public:
+		/// Finds out the given file's MIME type.
+		static std::string scanFile(const std::string &fileName);
+
+		/// Finds out the given URL's MIME type.
+		static std::string scanUrl(const Url &urlObj);
+
+	protected:
+		MIMEScanner();
+
+		static std::string scanFileType(const std::string &fileName);
+
+	private:
+		MIMEScanner(const MIMEScanner &other);
+		MIMEScanner& operator=(const MIMEScanner& other);
+
+};
+
+#endif // _MIME_SCANNER_H

Added: trunk/Utils/Makefile
===================================================================
--- trunk/Utils/Makefile	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Makefile	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,32 @@
+
+ROOT_DIR = ..
+
+include ${ROOT_DIR}/variables.mk
+
+UTILS_SRCS = DocumentInfo.cpp Document.cpp HtmlDocument.cpp \
+	IndexedDocument.cpp Languages.cpp MIMEScanner.cpp MboxParser.cpp \
+	PluginParser.cpp Result.cpp StringManip.cpp TimeConverter.cpp \
+	Timer.cpp Url.cpp XapianDatabase.cpp XapianDatabaseFactory.cpp
+UTILS_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${UTILS_SRCS})
+
+PLUGIN_TEST = ${BIN_DIR}/plugintest
+
+targets : dirs ${UTILS_LIB} ${TOKENIZER_TEST} ${PLUGIN_TEST} \
+	${PDF_TOKENIZER_DL} ${WORD_TOKENIZER_DL}
+
+clean :
+	@rm -f ${OBJ_DIR}/* ${UTILS_LIB} ${TOKENIZER_TEST} \
+	${PLUGIN_TEST} ${PDF_TOKENIZER_DL} ${WORD_TOKENIZER_DL}
+
+# Utils tester
+
+${PLUGIN_TEST} : ${OBJ_DIR}/plugintest.o ${UTILS_LIB}
+	@echo Building ${PLUGIN_TEST}
+	${LINK} -o ${PLUGIN_TEST} ${OBJ_DIR}/plugintest.o ${UTILS_LIB} ${LIBS}
+
+# Library
+
+${UTILS_LIB} : ${UTILS_OBJS}
+	@echo Building ${UTILS_LIB}
+	${AR} cr ${UTILS_LIB} ${UTILS_OBJS}
+


Property changes on: trunk/Utils/Makefile
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/MboxParser.cpp
===================================================================
--- trunk/Utils/MboxParser.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/MboxParser.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,402 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <regex.h>
+#include <iostream>
+#include <algorithm>
+
+#include <gmime/gmime.h>
+
+#include "StringManip.h"
+#include "TimeConverter.h"
+#include "Url.h"
+#include "MboxParser.h"
+
+using namespace std;
+
+MboxParser::MboxParser(const string &fileName, off_t mboxOffset)
+{
+	m_fileName = fileName;
+	m_fd = -1;
+	m_pMboxStream = NULL;
+	m_pParser = NULL;
+	m_partsCount = m_partNum = -1;
+	m_messageStart = mboxOffset;
+	m_pCurrentMessage = NULL;
+	m_messageDate = 0;
+
+	if (initialize() == true)
+	{
+		// Extract the first message
+		extractMessage();
+	}
+}
+
+MboxParser::~MboxParser()
+{
+	if (m_pCurrentMessage != NULL)
+	{
+		delete m_pCurrentMessage;
+	}
+
+	finalize();
+}
+
+bool MboxParser::initialize(void)
+{
+	// Open the mbox file
+	m_fd = open(m_fileName.c_str(), O_RDONLY);
+	if (m_fd < 0)
+	{
+		return false;
+	}
+
+	// Initialize gmime
+	g_mime_init(GMIME_INIT_FLAG_UTF8);
+
+	// Create a stream
+	if (m_messageStart > 0)
+	{
+		struct stat fileStat;
+
+		if ((fstat(m_fd, &fileStat) == 0) &&
+			(!S_ISREG(fileStat.st_mode)))
+		{
+			// This is not a file !
+			return false;
+		}
+
+		if (m_messageStart > fileStat.st_size)
+		{
+			// This offset doesn't make sense !
+			m_messageStart = 0;
+		}
+
+		m_pMboxStream = g_mime_stream_fs_new_with_bounds(m_fd, m_messageStart, fileStat.st_size);
+#ifdef DEBUG
+		cout << "MboxParser::initialize: stream starts at offset " << m_messageStart << endl;
+#endif
+	}
+	else
+	{
+		m_pMboxStream = g_mime_stream_fs_new(m_fd);
+	}
+
+	// And a parser
+	m_pParser = g_mime_parser_new();
+	if ((m_pMboxStream != NULL) &&
+		(m_pParser != NULL))
+	{
+		g_mime_parser_init_with_stream(m_pParser, m_pMboxStream);
+		g_mime_parser_set_respect_content_length(m_pParser, TRUE);
+		// Scan for mbox From-lines
+		g_mime_parser_set_scan_from(m_pParser, TRUE);
+
+		return true;
+	}
+
+	return false;
+}
+
+void MboxParser::finalize(void)
+{
+	if (m_pParser != NULL)
+	{
+		// FIXME: does the parser close the stream ?
+		g_object_unref(G_OBJECT(m_pParser));
+	}
+	else if (m_pMboxStream != NULL)
+	{
+		g_object_unref(G_OBJECT(m_pMboxStream));
+	}
+	if (m_fd >= 0)
+	{
+		close(m_fd);
+	}
+	g_mime_shutdown();
+}
+
+char *MboxParser::extractPart(GMimeObject *part, string &contentType, ssize_t &partLen)
+{
+	char *pBuffer = NULL;
+
+	if (part == NULL)
+	{
+		return NULL;
+	}
+
+	// Message parts may be nested
+	while (GMIME_IS_MESSAGE_PART(part))
+	{
+#ifdef DEBUG
+		cout << "MboxParser::extractPart: nested message part" << endl;
+#endif
+		GMimeMessage *partMessage = g_mime_message_part_get_message(GMIME_MESSAGE_PART(part));
+		part = g_mime_message_get_mime_part(partMessage);
+		g_mime_object_unref(GMIME_OBJECT(partMessage));
+	}
+
+	// Is this a multipart ?
+	if (GMIME_IS_MULTIPART(part))
+	{
+		ssize_t allPartsLen = 0;
+
+		m_partsCount = g_mime_multipart_get_number(GMIME_MULTIPART(part));
+#ifdef DEBUG
+		cout << "MboxParser::extractPart: message has " << m_partsCount << " parts" << endl;
+#endif
+		for (int partNum = max(m_partNum, 0); partNum < m_partsCount; ++partNum)
+		{
+#ifdef DEBUG
+			cout << "MboxParser::extractPart: extracting part " << partNum << endl;
+#endif
+			
+			GMimeObject *multiMimePart = g_mime_multipart_get_part(GMIME_MULTIPART(part), partNum);
+			if (multiMimePart == NULL)
+			{
+				continue;
+			}
+
+			char *pPart = extractPart(multiMimePart, contentType, partLen);
+			g_mime_object_unref(multiMimePart);
+			if (pPart != NULL)
+			{
+				m_partNum = ++partNum;
+				return NULL;
+			}
+		}
+
+		// None of the parts were suitable
+		m_partsCount = m_partNum = -1;
+	}
+
+	if (!GMIME_IS_PART(part))
+	{
+#ifdef DEBUG
+		cout << "MboxParser::extractPart: not a part" << endl;
+#endif
+		return NULL;
+	}
+	GMimePart *mimePart = GMIME_PART(part);
+
+	// Check the content type
+	const GMimeContentType *mimeType = g_mime_part_get_content_type(mimePart);
+	if (g_mime_content_type_is_type(mimeType, "text", "*") == TRUE)
+	{
+		// Set this for caller
+		char *partType = g_mime_content_type_to_string(mimeType);
+		if (partType != NULL)
+		{
+			contentType = partType;
+			g_free(partType);
+		}
+
+		GMimePartEncodingType encodingType = g_mime_part_get_encoding(mimePart);
+#ifdef DEBUG
+		cout << "MboxParser::extractPart: encoding is " << encodingType << endl;
+#endif
+
+		// Write the part to memory
+		g_mime_part_set_encoding(mimePart, GMIME_PART_ENCODING_QUOTEDPRINTABLE);
+		GMimeStream *memStream = g_mime_stream_mem_new();
+		GMimeDataWrapper *dataWrapper = g_mime_part_get_content_object(mimePart);
+		if (dataWrapper != NULL)
+		{
+			ssize_t writeLen = g_mime_data_wrapper_write_to_stream(dataWrapper, memStream);
+#ifdef DEBUG
+			cout << "MboxParser::extractPart: wrote " << writeLen << " bytes" << endl;
+#endif
+			g_object_unref(dataWrapper);
+		}
+		g_mime_stream_flush(memStream);
+		partLen = g_mime_stream_length(memStream);
+#ifdef DEBUG
+		cout << "MboxParser::extractPart: part is " << partLen << " bytes long" << endl;
+#endif
+
+		pBuffer = (char*)malloc(partLen + 1);
+		pBuffer[partLen] = '\0';
+		g_mime_stream_reset(memStream);
+		ssize_t readLen = g_mime_stream_read(memStream, pBuffer, partLen);
+#ifdef DEBUG
+		cout << "MboxParser::extractPart: read " << readLen << " bytes" << endl;
+#endif
+		g_mime_stream_unref(memStream);
+	}
+#ifdef DEBUG
+	else	cout << "MboxParser::extractPart: part is not text" << endl;
+#endif
+
+	return pBuffer;
+}
+
+bool MboxParser::extractMessage(void)
+{
+	string fromLine, contentType;
+
+	while (g_mime_stream_eos(m_pMboxStream) == FALSE)
+	{
+		if (m_partsCount != -1)
+		{
+			// FIXME: the previous message has parts left to parse
+			// The parser doesn't allow to poke at the stream
+			// See g_mime_parser_init_with_stream() here :
+			// http://spruce.sourceforge.net/gmime/doc/gmime-gmime-parser.html
+#ifdef DEBUG
+			cout << "MboxParser::extractMessage: skipping parts..." << endl;
+#endif
+			m_partsCount = m_partNum = -1;
+		}
+		// Get the next message
+		GMimeMessage *mimeMessage = g_mime_parser_construct_message(m_pParser);
+
+		m_messageStart = g_mime_parser_get_from_offset(m_pParser);
+		off_t messageEnd = g_mime_parser_tell(m_pParser);
+
+#ifdef DEBUG
+		cout << "MboxParser::extractMessage: message between offsets " << m_messageStart
+			<< " and " << messageEnd << endl;
+#endif
+		if (messageEnd > m_messageStart)
+		{
+			char *msgFromLine = g_mime_parser_get_from(m_pParser);
+			if (msgFromLine != NULL)
+			{
+				fromLine = msgFromLine;
+				g_free(msgFromLine);
+			}
+
+			// FIXME: this only applies to Mozilla
+			const char *msgMozStatus = g_mime_message_get_header(mimeMessage, "X-Mozilla-Status");
+			if (msgMozStatus != NULL)
+			{
+				long int mozStatus = strtol(msgMozStatus, NULL, 16);
+				// Watch out for Mozilla specific flags :
+				// MSG_FLAG_EXPUNGED, MSG_FLAG_EXPIRED
+				// They are defined in mailnews/MailNewsTypes.h and msgbase/nsMsgMessageFlags.h
+				if ((mozStatus & 0x0008) ||
+					(mozStatus & 0x0040))
+				{
+#ifdef DEBUG
+					cout << "MboxParser::extractMessage: flagged by Mozilla" << endl;
+#endif
+					g_mime_object_unref(GMIME_OBJECT(mimeMessage));
+					continue;
+				}
+			}
+
+			// How old is this message ?
+			const char *msgDate = g_mime_message_get_header(mimeMessage, "Date");
+			if (msgDate != NULL)
+			{
+				m_messageDate = TimeConverter::fromTimestamp(msgDate);
+			}
+			else
+			{
+				m_messageDate = 0;
+			}
+#ifdef DEBUG
+			cout << "MboxParser::extractMessage: message date is " << m_messageDate << endl;
+#endif
+
+			// Extract the subject and source address
+			const char *msgSubject = g_mime_message_get_header(mimeMessage, "Subject");
+			const char *msgFrom = g_mime_message_get_header(mimeMessage, "From");
+
+			// Get the top-level MIME part in the message
+			GMimeObject *mimePart = g_mime_message_get_mime_part(mimeMessage);
+
+			// Extract the part's text
+			ssize_t partLength = 0;
+			char *pPart = extractPart(mimePart, contentType, partLength);
+			if (pPart != NULL)
+			{
+				string location, subject;
+				char posStr[64];
+
+				// New location
+				// FIXME: use the same scheme as Mozilla
+				location = "mailbox://";
+				location += m_fileName;
+				location += "?o=";
+				snprintf(posStr, 64, "%u", m_messageStart);
+				location += posStr;
+				location += "&p=";
+				snprintf(posStr, 64, "%d", max(m_partNum, 0));
+				location += posStr;
+				location += "&h=";
+				location += StringManip::hashString(fromLine);
+#ifdef DEBUG
+				cout << "MboxParser::extractMessage: message location is " << location << endl;
+#endif
+
+				if (msgSubject != NULL)
+				{
+					subject = msgSubject;
+#ifdef DEBUG
+					cout << "MboxParser::extractMessage: message subject is " << subject << endl;
+#endif
+				}
+#ifdef DEBUG
+				else cout << "MboxParser::extractMessage: message has no subject" << endl;
+#endif
+
+				// New message
+				m_pCurrentMessage = new Document(subject, location, contentType, "");
+				m_pCurrentMessage->setData(pPart, (unsigned int)partLength);
+
+				free(pPart);
+				g_mime_object_unref(mimePart);
+				g_mime_object_unref(GMIME_OBJECT(mimeMessage));
+
+				return true;
+			}
+
+			g_mime_object_unref(mimePart);
+		}
+
+		g_mime_object_unref(GMIME_OBJECT(mimeMessage));
+	}
+
+	return false;
+}
+
+/// Gets the current message's date.
+time_t MboxParser::getDate(void) const
+{
+	return m_messageDate;
+}
+
+/// Jumps to the next message.
+bool MboxParser::nextMessage(void)
+{
+	delete m_pCurrentMessage;
+	m_pCurrentMessage = NULL;
+	// Get the next message from the original document
+	return extractMessage();
+}
+
+/// Returns a pointer to the current message's document.
+const Document *MboxParser::getDocument(void)
+{
+	// FIXME: this object can be invalidated by nextMessage() at any time;
+	// use auto_ptr all the way ?
+	return m_pCurrentMessage;
+}


Property changes on: trunk/Utils/MboxParser.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/MboxParser.h
===================================================================
--- trunk/Utils/MboxParser.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/MboxParser.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,81 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _MBOX_PARSER_H
+#define _MBOX_PARSER_H
+
+#include <time.h>
+#include <string>
+#include <map>
+#include <utility>
+#include <set>
+
+#include <gmime/gmime-object.h>
+#include <gmime/gmime-stream.h>
+#include <gmime/gmime-parser.h>
+
+#include "Document.h"
+
+using namespace std;
+
+/**
+  * A parser for mbox files. Each message is extracted and
+  * returned in a separate document by getDocument(). The value
+  * returned by getDocumentIncrement() enables to determine a new
+  * message has been extracted and is ready to be tokenized.
+  * See http://en.wikipedia.org/wiki/Mbox for details about the format.
+  */
+class MboxParser
+{
+	public:
+		MboxParser(const string &fileName, off_t mboxOffset = 0);
+		virtual ~MboxParser();
+
+		/// Gets the current message's date.
+		time_t getDate(void) const;
+
+		/// Jumps to the next message.
+		bool nextMessage(void);
+
+		/// Returns a pointer to the current message's document.
+		virtual const Document *getDocument(void);
+
+	protected:
+		string m_fileName;
+		int m_fd;
+		GMimeStream *m_pMboxStream;
+		GMimeParser *m_pParser;
+		int m_partsCount;
+		int m_partNum;
+		off_t m_messageStart;
+		Document *m_pCurrentMessage;
+		time_t m_messageDate;
+
+		bool initialize(void);
+
+		void finalize(void);
+
+		bool extractMessage(void);
+
+		char *extractPart(GMimeObject *mimeObject, string &contentType, ssize_t &partLen);
+
+	private:
+		MboxParser(const MboxParser &other);
+		MboxParser& operator=(const MboxParser& other);
+
+};
+
+#endif // _MBOX_PARSER_H


Property changes on: trunk/Utils/MboxParser.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/NLS.h
===================================================================
--- trunk/Utils/NLS.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/NLS.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,42 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _NLS_H
+#define _NLS_H
+
+/*
+ * Standard gettext macros.
+ */
+#ifdef ENABLE_NLS
+#  include <libintl.h>
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+
+#endif // _NLS_H

Added: trunk/Utils/PluginParser.cpp
===================================================================
--- trunk/Utils/PluginParser.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/PluginParser.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,272 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdlib.h>
+#include <string>
+#include <map>
+#include <iostream>
+#include <boost/spirit/core.hpp>
+#include <boost/spirit/actor/push_back_actor.hpp>
+#include <boost/spirit/actor/insert_at_actor.hpp>
+#include <boost/spirit/utility/confix.hpp>
+
+#include "PluginParser.h"
+
+using namespace std;
+using namespace boost::spirit;
+
+struct skip_grammar : public grammar<skip_grammar>
+{
+	template <typename ScannerT>
+	struct definition
+	{
+		definition(skip_grammar const &self)
+		{
+			// Skip all spaces and comments, starting with a #
+			// FIXME: make sure comments start at the beginning of the line !
+			skip = space_p | (ch_p('#') >> *(anychar_p - ch_p('\n')) >> ch_p('\n'));
+		}
+	
+		rule<ScannerT> skip;
+	
+		rule<ScannerT> const& start() const
+		{
+			return skip;
+		}
+	};
+};
+
+/**
+  * A minimal grammar for Sherlock plugins.
+  * This only checks for the existence of the SEARCH tag.
+  * It is used to quickly extract SEARCH attributes.
+  */
+struct plugin_min_grammar : public grammar<plugin_min_grammar>
+{
+	 plugin_min_grammar(PluginProperties &properties)
+        : m_properties(properties)
+	{
+	}
+
+	template <typename ScannerT>
+	struct definition
+	{
+		definition(plugin_min_grammar const &self)
+		{
+			// Start
+			search_plugin = search_header >> rest;
+
+			// All items have a name and an optionally-quoted value, separated by =
+			end_of_name = ch_p('=');
+			any_name = *(~ch_p('>') - end_of_name);
+			any_value_without_quotes = lexeme_d[*(~ch_p('>') - ch_p('\n'))];
+			any_value = ch_p('\'') >> (*(~ch_p('\'')))[assign_a(unquotedValue)] >> ch_p('\'') |
+				ch_p('"') >> (*(~ch_p('"')))[assign_a(unquotedValue)] >> ch_p('"') |
+				any_value_without_quotes[assign_a(unquotedValue)];
+
+			// SEARCH attributes are items
+			// There should be only one SEARCH tag
+			search_item = (any_name[assign_a(itemName)]
+				>> ch_p('=') >> any_value[assign_a(itemValue, unquotedValue)])
+				[insert_at_a(self.m_properties.m_searchParams, itemName, itemValue)];
+
+			// SEARCH may have any number of attributes
+			search_header = ch_p('<') >> as_lower_d[str_p("search")] >> *search_item >> ch_p('>');
+
+			// Rest
+			rest = *anychar_p;
+		}
+
+		string unquotedValue, itemName, itemValue;		
+		rule<ScannerT> search_plugin, search_header, rest;
+		rule<ScannerT> end_of_name, any_name, any_value_without_quotes, any_value, search_item;
+
+		rule<ScannerT> const& start() const
+		{
+			return search_plugin;
+		}
+	};
+
+	PluginProperties &m_properties;
+
+};
+
+/**
+  * A complete but lax grammar for Sherlock plugins.
+  * For instance, it doesn't mind if INPUT has a NAME but no VALUE.
+  * More importantly, it doesn't enforce types, eg FACTOR should be an integer.
+  */
+struct plugin_grammar : public grammar<plugin_grammar>
+{
+	 plugin_grammar(PluginProperties &properties)
+        : m_properties(properties)
+	{
+	}
+
+	template <typename ScannerT>
+	struct definition
+	{
+		definition(plugin_grammar const &self)
+		{
+			// Start
+			search_plugin = search_header >> input_elements >> search_footer;
+
+			// All items have a name and an optionally-quoted value, separated by =
+			end_of_name = ch_p('=');
+			any_name = *(~ch_p('>') - end_of_name);
+			any_value_without_quotes = lexeme_d[*(~ch_p('>') - ch_p('\n'))];
+			any_value = ch_p('\'') >> (*(~ch_p('\'')))[assign_a(unquotedValue)] >> ch_p('\'') |
+				ch_p('"') >> (*(~ch_p('"')))[assign_a(unquotedValue)] >> ch_p('"') |
+				any_value_without_quotes[assign_a(unquotedValue)];
+
+			// SEARCH attributes are items
+			// There should be only one SEARCH tag
+			search_item = (any_name[assign_a(itemName)]
+				>> ch_p('=') >> any_value[assign_a(itemValue, unquotedValue)])
+				[insert_at_a(self.m_properties.m_searchParams, itemName, itemValue)];
+
+			// SEARCH may have any number of attributes
+			search_header = ch_p('<') >> as_lower_d[str_p("search")] >> *search_item >> ch_p('>');
+
+			// INPUT
+			input_item_name = as_lower_d[str_p("name")] >> ch_p('=')
+				>> any_value[assign_a(itemName, unquotedValue)];
+			input_item_value = as_lower_d[str_p("value")] >> ch_p('=')
+				>> any_value[assign_a(itemValue, unquotedValue)];
+			input_item_user = as_lower_d[str_p("user")];
+			input_item_factor = as_lower_d[str_p("factor")]
+				>> ch_p('=') >> any_value[assign_a(itemValue, unquotedValue)];
+
+			// INPUT tags have name and value items; one is marked with USER
+			input_item = input_item_name |
+				input_item_value |
+				input_item_user[assign_a(self.m_properties.m_userInput, itemName)];
+
+			input_element = (ch_p('<') >> as_lower_d[str_p("input")] >> *input_item >> ch_p('>'))
+				[insert_at_a(self.m_properties.m_inputItems, itemName, itemValue)];
+
+			// INPUTPREV tags have name and either factor or value items
+			// There should be only one INPUTPREV tag
+			// FIXME: save those
+			inputprev_item = input_item_name |
+				input_item_factor |
+				input_item_value;
+
+			inputprev_element = ch_p('<') >> as_lower_d[str_p("inputprev")] >> *inputprev_item >> ch_p('>');
+
+			// INPUTNEXT tags have name and either factor or value items
+			// There should be only one INPUTNEXT tag
+			inputnext_item = input_item_name[assign_a(self.m_properties.m_nextInput, itemName)] |
+				input_item_factor[assign_a(self.m_properties.m_nextFactor, itemValue)] |
+				input_item_value[assign_a(self.m_properties.m_nextValue, itemValue)];
+
+			inputnext_element = ch_p('<') >> as_lower_d[str_p("inputnext")] >> *inputnext_item >> ch_p('>');
+
+			// INTERPRET tags have varied types of items
+			// There should be only one INTERPRET tag
+			interpret_item = (any_name[assign_a(itemName)]
+				>> ch_p('=') >> any_value[assign_a(itemValue, unquotedValue)])
+				[insert_at_a(self.m_properties.m_interpretParams, itemName, itemValue)];
+
+			interpret_element = ch_p('<') >> as_lower_d[str_p("interpret")] >> *interpret_item >> ch_p('>');
+
+			// INPUT, INPUTNEXT and INTERPRET may appear in any order
+			input_elements = *(input_element |
+				inputprev_element |
+				inputnext_element |
+				interpret_element);
+
+			// SEARCH has a closing tag
+			search_footer =  ch_p('<') >> ch_p('/') >> as_lower_d[str_p("search")] >> ch_p('>');
+		}
+
+		string unquotedValue, itemName, itemValue;		
+		rule<ScannerT> search_plugin, search_header, search_footer;
+		rule<ScannerT> end_of_name, any_name, any_value_without_quotes, any_value, search_item;
+		rule<ScannerT> input_elements, input_element, inputprev_element, inputnext_element, interpret_element;
+		rule<ScannerT> input_item_name, input_item_value, input_item_user, input_item_factor;
+		rule<ScannerT> input_item, inputprev_item, inputnext_item, interpret_item;
+
+		rule<ScannerT> const& start() const
+		{
+			return search_plugin;
+		}
+	};
+
+	PluginProperties &m_properties;
+
+};
+
+PluginParser::PluginParser(const Document *pDocument)
+{
+	m_pDocument = pDocument;
+}
+
+PluginParser::~PluginParser()
+{
+}
+
+bool PluginParser::parse(bool extractSearchParams)
+{
+	if (m_pDocument == NULL)
+	{
+		return false;
+	}
+
+	unsigned int dataLength;
+	const char *pData = m_pDocument->getData(dataLength);
+	if ((pData == NULL) ||
+		(dataLength == 0))
+	{
+		return false;
+	}
+
+	skip_grammar skip;
+	parse_info<> parseInfo;
+
+	if (extractSearchParams == false)
+	{
+		plugin_grammar plugin(m_properties);
+
+		parseInfo = boost::spirit::parse(pData, plugin, skip);
+	}
+	else
+	{
+		plugin_min_grammar plugin(m_properties);
+
+		parseInfo = boost::spirit::parse(pData, plugin, skip);
+	}
+#ifdef DEBUG
+	if (parseInfo.full == false)
+	{
+		cout << "PluginParser::parse: syntax error near " << parseInfo.stop << endl;
+	}
+#endif
+
+	return parseInfo.hit;
+}
+
+/// Returns the plugin's properties.
+PluginProperties &PluginParser::getProperties(void)
+{
+	return m_properties;
+}
+
+/// Returns a pointer to the plugin file's document.
+const Document *PluginParser::getDocument(void)
+{
+	return m_pDocument;
+}

Added: trunk/Utils/PluginParser.h
===================================================================
--- trunk/Utils/PluginParser.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/PluginParser.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,78 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _PLUGIN_PARSER_H
+#define _PLUGIN_PARSER_H
+
+#include <string>
+#include <map>
+
+#include "Document.h"
+
+using namespace std;
+
+class PluginProperties
+{
+	public:
+		PluginProperties()
+		{
+		}
+		virtual ~PluginProperties()
+		{
+		}
+
+
+		map<string, string> m_searchParams;
+		map<string, string> m_inputItems;
+		string m_userInput;
+		string m_nextInput;
+		string m_nextFactor;
+		string m_nextValue;
+		map<string, string> m_interpretParams;
+
+	private:
+		PluginProperties(const PluginProperties &other);
+		PluginProperties& operator=(const PluginProperties& other);
+
+};
+
+/// A parser for Sherlock plugin files.
+class PluginParser
+{
+	public:
+		PluginParser(const Document *pDocument);
+		virtual ~PluginParser();
+
+		/// Parses the plugin; false if not all could be parsed.
+		bool parse(bool extractSearchParams = false);
+
+		/// Returns the plugin's properties.
+		virtual PluginProperties &getProperties(void);
+
+		/// Returns a pointer to the plugin file's document.
+		virtual const Document *getDocument(void);
+
+	protected:
+		const Document *m_pDocument;
+		PluginProperties m_properties;
+
+	private:
+		PluginParser(const PluginParser &other);
+		PluginParser& operator=(const PluginParser& other);
+
+};
+
+#endif // _PLUGIN_PARSER_H

Added: trunk/Utils/Result.cpp
===================================================================
--- trunk/Utils/Result.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Result.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,74 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "Result.h"
+
+using std::string;
+
+Result::Result(const string &location, const string &title, const string &extract,
+	const string &language, float percentageScore) :
+	DocumentInfo(title, location, "", language),
+	m_extract(extract),
+	m_score(percentageScore)
+{
+}
+
+Result::Result(const Result &other) :
+	DocumentInfo(other),
+	m_extract(other.m_extract),
+	m_score(other.m_score)
+{
+}
+
+Result::~Result()
+{
+}
+
+Result &Result::operator=(const Result &other)
+{
+	DocumentInfo::operator=(other);
+	m_extract = other.m_extract;
+	m_score = other.m_score;
+
+	return *this;
+}
+
+bool Result::operator<(const Result& other) const
+{
+	if (DocumentInfo::operator<(other) == false)
+	{
+		if (m_score < other.m_score)
+		{
+			return true;
+		}
+
+		return false;
+	}
+
+	return true;
+}
+
+/// Returns the result extract.
+string Result::getExtract(void) const
+{
+	return m_extract;
+}
+
+/// Returns the result score.
+float Result::getScore(void) const
+{
+	return m_score;
+}


Property changes on: trunk/Utils/Result.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/Result.h
===================================================================
--- trunk/Utils/Result.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Result.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _RESULT_H
+#define _RESULT_H
+
+#include <string>
+
+#include "DocumentInfo.h"
+
+class Result : public DocumentInfo
+{
+	public:
+		Result(const std::string &location, const std::string &title,
+			const std::string &extract, const std::string &language,
+			float percentageScore = 0.0);
+		Result(const Result &other);
+		virtual ~Result();
+
+		Result &operator=(const Result &other);
+
+		bool operator<(const Result& other) const;
+
+		/// Returns the result extract.
+		std::string getExtract(void) const;
+
+		/// Returns the result score.
+		float getScore(void) const;
+
+	protected:
+		std::string m_extract;
+		float m_score;
+
+};
+
+#endif // _RESULT_H


Property changes on: trunk/Utils/Result.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/StringManip.cpp
===================================================================
--- trunk/Utils/StringManip.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/StringManip.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,146 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#define _XOPEN_SOURCE
+#include <unistd.h>
+#undef _XOPEN_SOURCE
+#include <ctype.h>
+#include <algorithm>
+
+#include "StringManip.h"
+
+using std::string;
+using std::for_each;
+
+#define CRYPT_SALT "$1$ajfpehom$"
+
+// A function object to lower case strings with for_each()
+struct ToLower
+{
+	public:
+		void operator()(char &c)
+		{
+			c = (char)tolower((int)c);
+		}
+};
+
+StringManip::StringManip()
+{
+}
+
+/// Converts to lowercase.
+string StringManip::toLowerCase(const string &str)
+{
+	string tmp = str;
+
+	for_each(tmp.begin(), tmp.end(), ToLower());
+
+	return tmp;
+}
+
+/// Extracts the sub-string between start and end.
+string StringManip::extractField(const string &str, const string &start, const string &end)
+{
+	string::size_type endPos = 0;
+
+	return extractField(str, start, end, endPos);
+}
+
+/// Extracts the sub-string between start and end.
+string StringManip::extractField(const string &str, const string &start, const string &end, string::size_type &endPos)
+{
+	string fieldValue;
+
+	string::size_type startPos = str.find(start, endPos);
+	if (startPos != string::npos)
+	{
+		startPos += start.length();
+		endPos = str.find(end, startPos);
+		if (endPos != string::npos)
+		{
+			fieldValue = str.substr(startPos, endPos - startPos);
+		}
+	}
+
+	return fieldValue;
+}
+
+/// Replaces a sub-string.
+string StringManip::replaceSubString(const string &str, const std::string &substr, const std::string &rep)
+{
+	string cleanStr = str;
+
+	string::size_type startPos = cleanStr.find(substr);
+	while (startPos != string::npos)
+	{
+		string::size_type endPos = startPos + substr.length();
+
+		string tmp = cleanStr.substr(0, startPos);
+		tmp += rep;
+		tmp += cleanStr.substr(endPos);
+		cleanStr = tmp;
+
+		startPos += rep.length();
+		if (startPos > cleanStr.length())
+		{
+			break;
+		}
+
+		startPos = cleanStr.find(substr, startPos);
+	}
+
+	return cleanStr;
+}
+
+/// Removes characters from a string.
+unsigned int StringManip::removeCharacters(string &str, const string &characters)
+{
+	unsigned int count = 0;
+
+	string::size_type charPos = str.find_first_of(characters.c_str());
+	while (charPos != string::npos)
+	{
+		str.erase(charPos, 1);
+		charPos = str.find_first_of(characters.c_str(), charPos - 1);
+	}
+
+	return count;	
+}
+
+/// Hashes a string.
+string StringManip::hashString(string &str)
+{
+	if (str.empty() == true)
+	{
+		return "";
+	}
+
+	char *hashedString = crypt(str.c_str(), CRYPT_SALT);
+	if (hashedString == NULL)
+	{
+		return NULL;
+	}
+
+	if (strlen(hashedString) > strlen(CRYPT_SALT))
+	{
+		if (strncmp(hashedString, CRYPT_SALT, strlen(CRYPT_SALT)) == 0)
+		{
+			return hashedString + strlen(CRYPT_SALT);
+		}
+	}
+
+	return hashedString;
+}

Added: trunk/Utils/StringManip.h
===================================================================
--- trunk/Utils/StringManip.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/StringManip.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,55 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _STRING_MANIP_H
+#define _STRING_MANIP_H
+
+#include <string>
+
+class StringManip
+{
+	public:
+		/// Converts to lowercase.
+		static std::string toLowerCase(const std::string &str);
+
+		/// Extracts the sub-string between start and end.
+		static std::string extractField(const std::string &str, const std::string &start,
+			const std::string &end);
+
+		/// Extracts the sub-string between start and end.
+		static std::string extractField(const std::string &str, const std::string &start,
+			const std::string &end, std::string::size_type &endPos);
+
+		/// Replaces a sub-string.
+		static std::string replaceSubString(const std::string &str, const std::string &substr,
+			const std::string &rep);
+
+		/// Removes characters from a string.
+		static unsigned int removeCharacters(std::string &str, const std::string &characters);
+
+		/// Hashes a string.
+		static std::string hashString(std::string &str);
+
+	protected:
+		StringManip();
+
+	private:
+		StringManip(const StringManip &other);
+		StringManip& operator=(const StringManip& other);
+
+};
+
+#endif // _STRING_MANIP_H

Added: trunk/Utils/TimeConverter.cpp
===================================================================
--- trunk/Utils/TimeConverter.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/TimeConverter.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,157 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#define _XOPEN_SOURCE	// glibc2 needs this
+#include <time.h>
+#include <iostream>
+
+#include "TimeConverter.h"
+
+using std::cout;
+using std::endl;
+
+TimeConverter::TimeConverter()
+{
+}
+
+/// Converts into an RFC 822 timestamp.
+string TimeConverter::toTimestamp(time_t aTime, bool inGMTime)
+{
+	struct tm timeTm;
+
+	if (((inGMTime == true) &&
+		(gmtime_r(&aTime, &timeTm) != NULL)) ||
+		(localtime_r(&aTime, &timeTm) != NULL))
+	{
+		char timeStr[64];
+
+		if (strftime(timeStr, 64, "%a, %d %b %Y %H:%M:%S %Z", &timeTm) > 0)
+		{
+			return timeStr;
+		}
+	}
+
+	return "";
+}
+
+/// Converts from a RFC 822 timestamp.
+time_t TimeConverter::fromTimestamp(const string &timestamp, bool inGMTime)
+{
+	struct tm timeTm;
+	string formatString;
+#ifndef _STRPTIME_COPES_WITH_TIMEZONE
+	bool fixTimezone = false;
+#endif
+
+	if (timestamp.empty() == true)
+	{
+		return 0;
+	}
+
+	// Find out if the date has an RFC-822/ISO 8601 time zone specification
+	// or a time zone name
+	// FIXME: it looks like strptime() can't diffentiate between %Z and %z
+	// and that the value extracted with %z is ignored
+	char *remainder = strptime(timestamp.c_str(), "%a, %d %b %Y %H:%M:%S ", &timeTm);
+	if (remainder != NULL)
+	{
+		if ((remainder[0] == '+') ||
+			(remainder[0] == '-'))
+		{
+#ifdef _STRPTIME_COPES_WITH_TIMEZONE
+			formatString = "%a, %d %b %Y %H:%M:%S %z";
+#else
+			formatString = "%a, %d %b %Y %H:%M:%S ";
+			fixTimezone = true;
+#endif
+		}
+		else
+		{
+			formatString = "%a, %d %b %Y %H:%M:%S %Z";
+		}
+	}
+	else
+	{
+		remainder = strptime(timestamp.c_str(), "%Y %b %d %H:%M:%S ", &timeTm);
+		if (remainder == NULL)
+		{
+			// How is it formatted then ?
+			return 0;
+		}
+
+		if ((remainder[0] == '+') ||
+			(remainder[0] == '-'))
+		{
+#ifdef _STRPTIME_COPES_WITH_TIMEZONE
+			formatString = "%Y %b %d %H:%M:%S %z";
+#else
+			formatString = "%Y %b %d %H:%M:%S ";
+			fixTimezone = true;
+#endif
+		}
+		else
+		{
+			formatString = "%Y %b %d %H:%M:%S %Z";
+		}
+	}
+
+	if ((formatString.empty() == false) &&
+		(strptime(timestamp.c_str(), formatString.c_str(), &timeTm) != NULL))
+	{
+		time_t gmTime = 0;
+
+		if (inGMTime == true)
+		{
+			gmTime = timegm(&timeTm);
+		}
+		else
+		{
+			gmTime = timelocal(&timeTm);
+		}
+
+#ifndef _STRPTIME_COPES_WITH_TIMEZONE
+		if ((fixTimezone == true) &&
+			(remainder != NULL))
+		{
+			unsigned int tzDiff = 0;
+
+			if ((sscanf(remainder + 1, "%u", &tzDiff) != 0) &&
+				(tzDiff < 1200))
+			{
+				unsigned int hourDiff = tzDiff / 100;
+				unsigned int minDiff = tzDiff % 100;
+
+#ifdef DEBUG
+				cout << "TimeConverter::fromTimestamp: diff is " << remainder[0] << hourDiff << ":" << minDiff << endl;
+#endif
+				if (remainder[0] == '+')
+				{
+					// Ahead of GMT
+					gmTime -= (hourDiff * 3600) + (minDiff * 60);
+				}
+				else
+				{
+					// Behind GMT
+					gmTime += (hourDiff * 3600) + (minDiff * 60);
+				}
+			}
+		}
+#endif
+		return gmTime;
+	}
+
+	return 0;
+}

Added: trunk/Utils/TimeConverter.h
===================================================================
--- trunk/Utils/TimeConverter.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/TimeConverter.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,42 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TIME_CONVERTER_H
+#define _TIME_CONVERTER_H
+
+#include <string>
+
+using namespace std;
+
+class TimeConverter
+{
+	public:
+		/// Converts into an RFC 822 timestamp.
+		static string toTimestamp(time_t aTime, bool inGMTime = false);
+
+		/// Converts from a RFC 822 timestamp.
+		static time_t fromTimestamp(const string &timestamp, bool inGMTime = false);
+	
+	protected:
+		TimeConverter();
+
+	private:
+		TimeConverter(const TimeConverter &other);
+		TimeConverter& operator=(const TimeConverter& other);
+
+};
+
+#endif // _TIME_CONVERTER_H

Added: trunk/Utils/Timer.cpp
===================================================================
--- trunk/Utils/Timer.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Timer.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,59 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "Timer.h"
+
+Timer::Timer()
+{
+	gettimeofday(&m_start, NULL);
+	gettimeofday(&m_stop, NULL);
+}
+
+Timer::Timer(const Timer &other) :
+	m_start(other.m_start),
+	m_stop(other.m_stop)
+{
+}
+
+
+Timer &Timer::operator=(const Timer &other)
+{
+	m_start = other.m_start;
+	m_stop = other.m_stop;
+
+	return *this;
+}
+
+Timer::~Timer()
+{
+}
+
+/// Starts the timer.
+void Timer::start(void)
+{
+	gettimeofday(&m_start, NULL);
+}
+
+/// Stops the timer and returns the number of microseconds elapsed.
+long Timer::stop(void)
+{
+	gettimeofday(&m_stop, NULL);
+
+	long timeDiff = (m_stop.tv_sec - m_start.tv_sec) * 1000000
+		+ (m_stop.tv_usec - m_start.tv_usec);
+
+	return timeDiff;
+}


Property changes on: trunk/Utils/Timer.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/Timer.h
===================================================================
--- trunk/Utils/Timer.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Timer.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,44 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TIMER_H
+#define _TIMER_H
+
+#include <time.h>
+#include <sys/time.h>
+
+class Timer
+{
+	public:
+		Timer();
+		Timer(const Timer &other);
+		virtual ~Timer();
+
+		Timer &operator=(const Timer &other);
+
+		/// Starts the timer.
+		void start(void);
+
+		/// Stops the timer and returns the number of microseconds elapsed.
+		long stop(void);
+
+	protected:
+		struct timeval m_start;
+		struct timeval m_stop;
+
+};
+
+#endif // _TIMER_H


Property changes on: trunk/Utils/Timer.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/Url.cpp
===================================================================
--- trunk/Utils/Url.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Url.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,330 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <neon/ne_uri.h>
+
+#include "Url.h"
+
+Url::Url(const string &url)
+{
+	parse(url);
+}
+
+Url::~Url()
+{
+}
+
+Url::Url(const Url &other) :
+	m_protocol(other.m_protocol),
+	m_user(other.m_user),
+	m_password(other.m_password),
+	m_host(other.m_host),
+	m_location(other.m_location),
+	m_file(other.m_file),
+	m_parameters(other.m_parameters)
+{
+}
+
+Url& Url::operator=(const Url& other)
+{
+	m_protocol = other.m_protocol;
+	m_user = other.m_user;
+	m_password = other.m_password;
+	m_host = other.m_host;
+	m_location = other.m_location;
+	m_file = other.m_file;
+	m_parameters = other.m_parameters;
+
+	return *this;
+}
+
+void Url::parse(const string &url)
+{
+	string::size_type pos1 =0, pos2 = 0;
+	bool hasHostName = true;
+
+	// If the URL starts with a slash, don't parse and consider it local
+	if (url[0] == '/')
+	{
+		m_location = url;
+		return;
+	}
+
+	// Protocol
+	pos1 = url.find("://");
+	if (pos1 != string::npos)
+	{
+		m_protocol = url.substr(0, pos1);
+		pos1 += 3;
+
+		if ((m_protocol == "file") ||
+			(m_protocol == "mailbox"))
+		{
+			hasHostName = false;
+		}
+	}
+	else
+	{
+		// Assume default protocol
+		m_protocol = "http";
+		pos1 = 0;
+	}
+
+	if (hasHostName == true)
+	{
+		// User and password
+		pos2 = url.find_first_of(":", pos1);
+		if (pos2 != string::npos)
+		{
+			bool isPartOfLocation = false;
+
+			string::size_type firstSlash = url.find_first_of("/", pos1);
+			if (firstSlash != string::npos)
+			{
+				// The : is part of the location if it follows the /, eg like in this URL :
+				// http://216.239.39.100/search?q=cache:X8L8R9AazsAJ:eastenwest.free.fr/site/php/download.php%3Ftype%3Darticles%26ID%3D193+fabrice+colin&hl=en&ie=UTF-8
+				if (pos2 > firstSlash)
+				{
+					isPartOfLocation = true;
+				}
+			}
+
+			if (isPartOfLocation == false)
+			{
+				m_user = url.substr(pos1, pos2 - pos1);
+				pos1 = pos2 + 1;
+
+				pos2 = url.find_first_of("@", pos1);
+				if (pos2 != string::npos)
+				{
+					m_password = url.substr(pos1, pos2 - pos1);
+					pos1 = pos2 + 1;
+				}
+			}
+		}
+
+		// Host name
+		pos2 = url.find_first_of("/", pos1);
+		if (pos2 != string::npos)
+		{
+			m_host = url.substr(pos1, pos2 - pos1);
+			pos2++;
+		}
+		else
+		{
+			m_host = url.substr(pos1);
+			return;
+		}
+		// FIXME: what about the port number ?
+	}
+	else
+	{
+		m_host = "localhost";
+		pos2 = pos1;
+	}
+
+	string locationAndFile = url.substr(pos2);
+	pos2 = locationAndFile.find("?");
+	// Parameters
+	if (pos2 != string::npos)
+	{
+		m_parameters = locationAndFile.substr(pos2+1);
+		locationAndFile.resize(pos2);
+	}
+
+	// Location and file
+	pos1 = locationAndFile.find_last_of("/");
+	if (pos1 != string::npos)
+	{
+		m_location = locationAndFile.substr(0, pos1);
+		m_file = locationAndFile.substr(pos1+1);
+	}
+	else
+	{
+		// No slash found, what we have got is either a directory
+		// directly under the root or a file name
+		// Assume this is a directory unless there's a dot
+		if (locationAndFile.find('.') == string::npos)
+		{
+			m_location = locationAndFile;
+			m_file = "";
+		}
+		else
+		{
+			m_location = "";
+			m_file = locationAndFile;
+		}
+	}
+}
+
+string Url::getProtocol(void) const
+{
+	return m_protocol;
+}
+
+string Url::getUser(void) const
+{
+	return m_user;
+}
+
+string Url::getPassword(void) const
+{
+	return m_password;
+}
+
+string Url::getHost(void) const
+{
+	return m_host;
+}
+
+string Url::getLocation(void) const
+{
+	return m_location;
+}
+
+string Url::getFile(void) const
+{
+	return m_file;
+}
+
+string Url::getParameters(void) const
+{
+	return m_parameters;
+}
+
+/// Canonicalizes an URL.
+string Url::canonicalizeUrl(const string &url)
+{
+	if (url.empty() == true)
+	{
+		return "";
+	}
+
+	Url urlObj(url);
+	string location = urlObj.getLocation();
+	string file = urlObj.getFile();
+
+	// Get rid of the last directory's slash
+	if ((file.empty() == true) &&
+		(location.empty() == false) &&
+		(url[url.length() - 1] == '/'))
+	{
+		return url.substr(0, url.length() - 1);
+	}
+
+	return url;
+}
+
+/// Truncates an URL to the given length by discarding characters in the middle.
+string Url::prettifyUrl(const string &url, unsigned int maxLen)
+{
+	if (maxLen >= url.length())
+	{
+		// Don't change anything...
+		return url;
+	}
+
+	unsigned int diffLen = url.length() - maxLen;
+	Url urlObj(url);
+	string protocol = urlObj.getProtocol();
+	string user = urlObj.getUser();
+	string password = urlObj.getPassword();
+	string host = urlObj.getHost();
+	string location = urlObj.getLocation();
+	string file = urlObj.getFile();
+	
+	string prettyUrl = protocol;
+	prettyUrl += "://";
+	if (user.empty() == false)
+	{
+		prettyUrl += user;
+		prettyUrl += ":";
+		prettyUrl += password;
+	}
+	prettyUrl += host;
+	prettyUrl += "/";
+
+	if (url.length() <= diffLen)
+	{
+		// That's the bare minimum...
+		prettyUrl = protocol;
+		prettyUrl += "://";
+		prettyUrl += host;
+		prettyUrl += "/...";
+	}
+	else if (location.length() > diffLen + 3)
+	{
+		// Truncate the location and keep the rest intact
+		prettyUrl += location.substr(0, location.length() - (diffLen + 3));
+		prettyUrl += ".../";
+		prettyUrl += file;
+	}
+	else
+	{
+		// Cut somewhere in the middle of the URL then
+		prettyUrl += location;
+		prettyUrl += "/";
+		prettyUrl += file;
+		unsigned int urlLen = prettyUrl.length();
+		string::size_type startPos = 0;
+		if (urlLen - diffLen > 0)
+		{
+			startPos = (urlLen - diffLen) / 2;
+		}
+		string tmp = prettyUrl;
+		prettyUrl = tmp.substr(0, startPos);
+		prettyUrl += "...";
+		prettyUrl += tmp.substr(startPos + diffLen);
+	}
+
+	return prettyUrl;
+}
+
+/// Escapes an URL.
+string Url::escapeUrl(const string &url)
+{
+	string escapedUrlStr = "";
+
+	if (url.empty() == false)
+	{
+		char *escapedUrl = ne_path_escape(url.c_str());
+		if (escapedUrl != NULL)
+		{
+			escapedUrlStr = escapedUrl;
+			free(escapedUrl);
+		}
+	}
+
+	return escapedUrlStr;
+}
+
+/// Unescapes an URL.
+string Url::unescapeUrl(const string &escapedUrl)
+{
+	string unescapedUrlStr = "";
+
+	if (escapedUrl.empty() == false)
+	{
+		char *unescapedUrl = ne_path_unescape(escapedUrl.c_str());
+		if (unescapedUrl != NULL)
+		{
+			unescapedUrlStr = unescapedUrl;
+			free(unescapedUrl);
+		}
+	}
+
+	return unescapedUrlStr;
+}

Added: trunk/Utils/Url.h
===================================================================
--- trunk/Utils/Url.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/Url.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,66 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _URL_H
+#define _URL_H
+
+#include <string>
+
+using std::string;
+
+class Url
+{
+	public:
+		Url(const string &url);
+		Url(const Url &other);
+		virtual ~Url();
+
+		Url& operator=(const Url& other);
+
+		string getProtocol(void) const;
+		string getUser(void) const;
+		string getPassword(void) const;
+		string getHost(void) const;
+		string getLocation(void) const;
+		string getFile(void) const;
+		string getParameters(void) const;
+
+		/// Canonicalizes an URL.
+		static string canonicalizeUrl(const string &url);
+
+		/// Truncates an URL to the given length by discarding characters in the middle.
+		static string prettifyUrl(const string &url, unsigned int maxLen);
+
+		/// Escapes an URL.
+		static string escapeUrl(const string &url);
+
+		/// Unescapes an URL.
+		static string unescapeUrl(const string &escapedUrl);
+
+	protected:
+		string m_protocol;
+		string m_user;
+		string m_password;
+		string m_host;
+		string m_location;
+		string m_file;
+		string m_parameters;
+
+		void parse(const string &url);
+
+};
+
+#endif // _URL_H

Added: trunk/Utils/XapianDatabase.cpp
===================================================================
--- trunk/Utils/XapianDatabase.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/XapianDatabase.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,192 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <iostream>
+
+#include "XapianDatabase.h"
+
+using std::cout;
+using std::cerr;
+using std::endl;
+using std::string;
+
+XapianDatabase::XapianDatabase(const string &databaseName, bool readOnly) :
+	m_databaseName(databaseName),
+	m_readOnly(readOnly),
+	m_pDatabase(NULL),
+	m_isOpen(false)
+{
+	pthread_rwlock_init(&m_rwLock, NULL);
+	m_isOpen = openDatabase();
+}
+
+XapianDatabase::~XapianDatabase()
+{
+	if (m_pDatabase != NULL)
+	{
+		delete m_pDatabase;
+	}
+	pthread_rwlock_destroy(&m_rwLock);
+}
+
+bool XapianDatabase::openDatabase(void)
+{
+	struct stat dbStat;
+
+	if (m_databaseName.empty() == true)
+	{
+		return false;
+	}
+
+	// Is it a remote database ?
+	string::size_type colonPos = m_databaseName.find(":");
+	if ((m_databaseName[0] != '/') &&
+		(colonPos != string::npos))
+	{
+		string hostName = m_databaseName.substr(0, colonPos);
+		unsigned int port = (unsigned int)atoi(m_databaseName.substr(colonPos + 1).c_str());
+
+		if (m_readOnly == false)
+		{
+#ifdef DEBUG
+			cout << "XapianDatabase::openDatabase: remote databases are read-only" << endl;
+#endif
+			return false;
+		}
+
+		try
+		{
+#ifdef DEBUG
+			cout << "XapianDatabase::openDatabase: remote database at "
+				<< hostName << ":" << port << endl;
+#endif
+			Xapian::Database remoteDatabase = Xapian::Remote::open(hostName, port);
+			m_pDatabase = new Xapian::Database(remoteDatabase);
+
+			return true;
+		}
+		catch (const Xapian::Error &error)
+		{
+			cerr << "XapianDatabase::openDatabase: couldn't open remote database: "
+				<< error.get_msg() << endl;
+		}
+
+		return false;		
+	}
+
+	// It's a local database : the specified path must be a directory
+	if (stat(m_databaseName.c_str(), &dbStat) == -1)
+	{
+		if (m_readOnly == true)
+		{
+			cerr << "XapianDatabase::openDatabase: database " << m_databaseName
+				<< " doesn't exist" << endl;
+			return false;
+		}
+
+		// Database directory doesn't exist, create it (mode 755)
+		if (mkdir(m_databaseName.c_str(), (mode_t)S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) != 0)
+		{
+			cerr << "XapianDatabase::openDatabase: couldn't create database directory "
+				<< m_databaseName << endl;
+			return false;
+		}
+	}
+	else if (!S_ISDIR(dbStat.st_mode))
+	{
+		cerr << "XapianDatabase::openDatabase: " << m_databaseName
+			<< " is not a directory" << endl;
+		return false;
+	}
+
+	// Try opening it now, creating if if necessary
+	try
+	{
+		if (m_readOnly == true)
+		{
+			m_pDatabase = new Xapian::Database(m_databaseName);
+		}
+		else
+		{
+			m_pDatabase = new Xapian::WritableDatabase(m_databaseName, Xapian::DB_CREATE_OR_OPEN);
+		}
+
+		return true;
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "XapianDatabase::openDatabase: couldn't open database: "
+			<< error.get_msg() << endl;
+	}
+
+	return false;
+}
+
+/// Returns false if the database couldn't be opened.
+bool XapianDatabase::isOpen(void) const
+{
+	return m_isOpen;
+}
+
+/// Attempts to lock and retrieve the database.
+Xapian::Database *XapianDatabase::readLock(void)
+{
+#ifdef DEBUG
+	cout << "XapianDatabase::readLock: " << m_databaseName << endl;
+#endif
+	if (pthread_rwlock_rdlock(&m_rwLock) == 0)
+	{
+		return m_pDatabase;
+	}
+
+	return NULL;
+}
+
+/// Attempts to lock and retrieve the database.
+Xapian::WritableDatabase *XapianDatabase::writeLock(void)
+{
+	if (m_readOnly == true)
+	{
+		// FIXME: close and reopen in write mode
+		cerr << "Couldn't open read-only database " << m_databaseName
+			<< " for writing" << endl;
+		return NULL;
+	}
+
+#ifdef DEBUG
+	cout << "XapianDatabase::writeLock: " << m_databaseName << endl;
+#endif
+	if (pthread_rwlock_wrlock(&m_rwLock) == 0)
+	{
+		return dynamic_cast<Xapian::WritableDatabase *>(m_pDatabase);
+	}
+
+	return NULL;
+}
+
+/// Unlocks the database.
+void XapianDatabase::unlock(void)
+{
+#ifdef DEBUG
+	cout << "XapianDatabase::unlock: " << m_databaseName << endl;
+#endif
+	pthread_rwlock_unlock(&m_rwLock);
+}


Property changes on: trunk/Utils/XapianDatabase.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/XapianDatabase.h
===================================================================
--- trunk/Utils/XapianDatabase.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/XapianDatabase.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,62 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XAPIAN_DATABASE_H
+#define _XAPIAN_DATABASE_H
+
+#include <string>
+#include <set>
+#include <pthread.h>
+
+#include <xapian.h>
+
+#include "DocumentInfo.h"
+#include "IndexHistory.h"
+#include "IndexInterface.h"
+
+class XapianDatabase
+{
+	public:
+		XapianDatabase(const std::string &databaseName, bool readOnly = true);
+		XapianDatabase(const XapianDatabase &other);
+		virtual ~XapianDatabase();
+
+		XapianDatabase &operator=(const XapianDatabase &other);
+
+		/// Returns false if the database couldn't be opened.
+		bool isOpen(void) const;
+
+		/// Attempts to lock and retrieve the database.
+		Xapian::Database *readLock(void);
+
+		/// Attempts to lock and retrieve the database.
+		Xapian::WritableDatabase *writeLock(void);
+
+		/// Unlocks the database.
+		void unlock(void);
+
+	protected:
+		std::string m_databaseName;
+		bool m_readOnly;
+		pthread_rwlock_t m_rwLock;
+		Xapian::Database *m_pDatabase;
+		bool m_isOpen;
+
+		bool openDatabase(void);
+
+};
+
+#endif // _XAPIAN_DATABASE_H


Property changes on: trunk/Utils/XapianDatabase.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/XapianDatabaseFactory.cpp
===================================================================
--- trunk/Utils/XapianDatabaseFactory.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/XapianDatabaseFactory.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,117 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+
+#include "XapianDatabaseFactory.h"
+
+using std::cout;
+using std::endl;
+using std::string;
+using std::map;
+using std::pair;
+
+pthread_mutex_t XapianDatabaseFactory::m_mutex = PTHREAD_MUTEX_INITIALIZER;
+map<string, XapianDatabase *> XapianDatabaseFactory::m_databases;
+
+XapianDatabaseFactory::XapianDatabaseFactory()
+{
+}
+
+XapianDatabaseFactory::~XapianDatabaseFactory()
+{
+}
+
+/// Returns a XapianDatabase pointer; NULL if unavailable.
+XapianDatabase *XapianDatabaseFactory::getDatabase(const string &location, bool readOnly)
+{
+	XapianDatabase *pDb = NULL;
+
+	if (location.empty() == true)
+	{
+		return NULL;
+	}
+
+	// Lock the map
+	if (pthread_mutex_lock(&m_mutex) != 0)
+	{
+		return NULL;
+	}
+
+	map<string, XapianDatabase *>::iterator dbIter = m_databases.find(location);
+	if (dbIter != m_databases.end())
+	{
+#ifdef DEBUG
+		cout << "XapianDatabaseFactory::getDatabase: found " << location << endl;
+#endif
+		pDb = dbIter->second;
+	}
+	else
+	{
+#ifdef DEBUG
+		cout << "XapianDatabaseFactory::getDatabase: opening " << location
+			<< " in mode " << readOnly << endl;
+#endif
+		// Create a new instance
+		pDb = new XapianDatabase(location, readOnly);
+		// Insert it into the map
+		pair<map<string, XapianDatabase *>::iterator, bool> insertPair = m_databases.insert(pair<string, XapianDatabase *>(location, pDb));
+		// Was it inserted ?
+		if (insertPair.second == false)
+		{
+			// No, it wasn't : delete the object
+			delete pDb;
+			pDb = NULL;
+		}
+	}
+
+	// Unlock the map
+	pthread_mutex_unlock(&m_mutex);
+
+	return pDb;
+}
+
+/// Closes all databases.
+void XapianDatabaseFactory::closeAll(void)
+{
+	if (m_databases.empty() == true)
+	{
+		return;
+	}
+
+	// Lock the map
+	if (pthread_mutex_lock(&m_mutex) != 0)
+	{
+		return;
+	}
+
+	std::map<std::string, XapianDatabase *>::iterator dbIter = m_databases.begin();
+	while (dbIter != m_databases.end())
+	{
+		XapianDatabase *pDb = dbIter->second;
+		dbIter->second = NULL;
+#ifdef DEBUG
+		cout << "XapianDatabaseFactory::closeAll: closing " << dbIter->first << endl;
+#endif
+		m_databases.erase(dbIter);
+		delete pDb;
+
+		dbIter = m_databases.begin();
+	}
+
+	// Unlock the map
+	pthread_mutex_unlock(&m_mutex);
+}


Property changes on: trunk/Utils/XapianDatabaseFactory.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/XapianDatabaseFactory.h
===================================================================
--- trunk/Utils/XapianDatabaseFactory.h	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/XapianDatabaseFactory.h	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,49 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XAPIAN_DATABASE_FACTORY_H
+#define _XAPIAN_DATABASE_FACTORY_H
+
+#include <string>
+#include <map>
+#include <pthread.h>
+
+#include "XapianDatabase.h"
+
+class XapianDatabaseFactory
+{
+	public:
+		virtual ~XapianDatabaseFactory();
+
+		/// Returns a XapianDatabase pointer; NULL if unavailable.
+		static XapianDatabase *getDatabase(const std::string &location, bool readOnly = true);
+
+		/// Closes all databases.
+		static void closeAll(void);
+
+	protected:
+		static pthread_mutex_t m_mutex;
+		static std::map<std::string, XapianDatabase *> m_databases;
+
+		XapianDatabaseFactory();
+
+	private:
+		XapianDatabaseFactory(const XapianDatabaseFactory &other);
+		XapianDatabaseFactory &operator=(const XapianDatabaseFactory &other);
+
+};
+
+#endif // _XAPIAN_DATABASE_FACTORY_H


Property changes on: trunk/Utils/XapianDatabaseFactory.h
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/Utils/plugintest.cpp
===================================================================
--- trunk/Utils/plugintest.cpp	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/Utils/plugintest.cpp	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,111 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <strings.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <iostream>
+#include <string>
+
+#include "PluginParser.h"
+
+using namespace std;
+
+int main(int argc, char **argv)
+{
+	if (argc < 2)
+	{
+		cerr << "Usage: " << argv[0] << " <file name> [MIN]" << endl;
+		return EXIT_FAILURE;
+	}
+
+	struct stat fileStat;
+	if ((stat(argv[1], &fileStat) == 0) &&
+		(S_ISREG(fileStat.st_mode)))
+	{
+		char *buffer = new char[fileStat.st_size + 1];
+		int fd = open(argv[1], O_RDONLY);
+		// Read the file
+		ssize_t readBytes = read(fd, buffer, fileStat.st_size);
+		if (readBytes == -1)
+		{
+			cerr << "Couldn't read " << argv[1] << " !" << endl;
+			return EXIT_FAILURE;
+		}
+
+		// Put that data into a document
+		Document doc;
+		doc.setData(buffer, readBytes);
+		delete[] buffer;
+
+		bool minParser = false;
+		PluginParser parser(&doc);
+
+		if ((argc >= 3) &&
+			(strncasecmp(argv[2], "MIN", 3) == 0))
+		{
+			minParser = true;
+		}
+
+		if (parser.parse(minParser) == true)
+		{
+			cout << "Successfully parsed " << argv[1] << endl;
+		}
+
+		PluginProperties &properties = parser.getProperties();
+
+		cout << "SEARCH parameters are :" << endl;
+		for (map<string, string>::iterator iter = properties.m_searchParams.begin();
+			iter != properties.m_searchParams.end(); ++iter)
+		{
+			cout << iter->first << "=" << iter->second << endl;
+		}
+		cout << "End of SEARCH parameters" << endl;
+
+		cout << "INPUT items are :" << endl;
+		for (map<string, string>::iterator iter = properties.m_inputItems.begin();
+			iter != properties.m_inputItems.end(); ++iter)
+		{
+			if (iter->first != properties.m_userInput)
+			{
+				cout << iter->first << "=" << iter->second << endl;
+			}
+			else
+			{
+				cout << iter->first << " USER" << endl;
+			}
+		}
+		cout << "NEXT " << properties.m_nextInput << "=" << properties.m_nextFactor << endl;
+		cout << "End of INPUT items" << endl;
+
+		cout << "INTERPRET parameters are :" << endl;
+		for (map<string, string>::iterator iter = properties.m_interpretParams.begin();
+			iter != properties.m_interpretParams.end(); ++iter)
+		{
+			cout << iter->first << "=" << iter->second << endl;
+		}
+		cout << "End of INTERPRET parameters" << endl;
+
+	}
+	else
+	{
+		cerr << "Couldn't stat " << argv[1] << " !" << endl;
+	}
+
+	return EXIT_SUCCESS;
+}


Property changes on: trunk/Utils/plugintest.cpp
___________________________________________________________________
Name: svn:executable
   + 

Added: trunk/index.html
===================================================================
--- trunk/index.html	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/index.html	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,34 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+<HTML>
+<html>
+<head><title>Welcome to Pinot !</title>
+</head>
+<body bgcolor="#ffffff" text="#000000" link="#c80000" vlink="#900000" alink="#ea5b1a">
+
+<table width="100%">
+<tr>
+<td colspan="3" align="center">
+<strong>Welcome to Pinot !</strong>
+</td>
+</tr>
+
+<tr>
+<td colspan="3" align="center">
+The official Pinot <a href="http://pinot.berlios.de/">web site</a>.
+</td>
+</tr>
+
+<tr>
+<td colspan="3" align="center">
+Pinot is powered by <a href="http://www.xapian.org/">Xapian</a>.<br>
+</td>
+</tr>
+
+<tr>
+<td valign="top" align="center">
+<img src="xapian-powered.png" alt="Powered By Xapian Logo" width="208" height="30">
+</td>
+</tr>
+
+</body>
+</html>

Added: trunk/libxmlpp026.patch
===================================================================
--- trunk/libxmlpp026.patch	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/libxmlpp026.patch	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,13 @@
+--- pinot-0.20/variables.mk_bak    2005-07-17 19:55:39.549604896 +0800
++++ pinot-0.20/variables.mk        2005-07-17 20:01:56.493300744 +0800
+@@ -72,8 +72,8 @@
+ SQLITE_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags sqlite3)
+ SQLITE_LIBS = $(shell /usr/bin/pkg-config --libs sqlite3)
+ # LibXML 2.0
+-LIBXML_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags libxml++-2.6)
+-LIBXML_LIBS = $(shell /usr/bin/pkg-config --libs libxml++-2.6)
++LIBXML_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags libxml++-1.0) -DHAS_LIBXMLPP026
++LIBXML_LIBS = $(shell /usr/bin/pkg-config --libs libxml++-1.0)
+ # Mozilla
+ MOZILLA_LIB_DIR = $(shell dirname `find /usr/lib*/mozilla* -name libgtkembedmoz.so | head -1`)
+ ifeq ($(MOZILLA_LIB_DIR),)

Added: trunk/pinot.spec
===================================================================
--- trunk/pinot.spec	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/pinot.spec	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,138 @@
+# We need an explicit dependency on mozilla as the so files don't have a version number 
+%define mozilla_ver %(/usr/bin/mozilla-config --version)
+
+Summary: Metasearch tool
+Name: pinot
+Version: 0.30
+Release: 1
+License: GPL
+Group: Applications/Internet 
+Source: %{name}-%{version}.tar.gz
+Patch0: libxmlpp026.patch
+URL: http://pinot.berlios.de/
+BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
+Requires: xapian-core-libs >= 0.9.0, neon >= 0.24, gtkmm24 >= 2.4.12, mozilla >= %{mozilla_ver}, sqlite >= 3.1.2, ots >= 0.4.2, libtextcat >= 2.2, fam >= 2.6.10, gmime >= 2.1, file
+BuildRequires: xapian-core-devel >= 0.9.0, neon-devel >= 0.24, gtkmm24-devel >= 2.4.12, mozilla-devel >= %{mozilla_ver}, sqlite-devel >= 3.1.2, ots-devel >= 0.4.2, libtextcat-devel >= 2.2, fam-devel >= 2.6.10, gmime-devel >= 2.1, file, boost-devel >= 1.32, desktop-file-utils
+%if 0%{?_with_libxmlpp026:1}
+Requires: libxml++ >= 0.26
+BuildRequires: libxml++-devel >= 0.26
+%else
+Requires: libxml++ >= 2.6 
+BuildRequires: libxml++-devel >= 2.6
+%endif
+
+%description
+Pinot is a metasearch tool for the Free Desktop.  It enables one to query
+sources, display as well as analyze and locally index the returned results.
+It may also be used as a lightweight personal space search tool.
+
+%package pdf
+Summary: PDF tokenizer for Pinot that uses pdftohtml
+Group: Applications/Internet
+Requires: %{name} = %{version}
+Requires: pdftohtml
+
+%description pdf
+The included tokenizer enables Pinot to index PDF documents.
+
+%package word 
+Summary: MS Word tokenizer for Pinot that uses antiword
+Group: Applications/Internet
+Requires: %{name} = %{version}
+Requires: antiword
+
+%description word
+The included tokenizer enables Pinot to index MS Word documents.
+
+%package omega 
+Summary: Xapian Omega plugin for Pinot
+Group: Applications/Internet
+Requires: %{name} = %{version}
+Requires: xapian-omega
+
+%description omega
+The included plugin enables Pinot to use Xapian Omega as a search engine.
+
+%prep
+%setup -q
+%if 0%{?_with_libxmlpp026:1}
+%patch0 -p1 -b .xml026
+%endif
+
+%build
+make DEBUG=yes
+make DEBUG=yes pinot_mo
+
+%install
+[ -n "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf $RPM_BUILD_ROOT
+make install PREFIX=$RPM_BUILD_ROOT
+# This engine is not usable as it is
+mv $RPM_BUILD_ROOT/%{_datadir}/pinot/engines/AmazonAPI.src $RPM_BUILD_ROOT/%{_datadir}/pinot/
+# Desktop file
+cat >%{name}.desktop << EOF
+[Desktop Entry]
+Name=Pinot Metasearch tool
+Comment=Search the Web and your documents
+Exec=%{_bindir}/pinot
+Icon=pinot.png
+Terminal=false
+Type=Application
+Categories=Application;Network;
+Encoding=UTF-8
+EOF
+mkdir -p $RPM_BUILD_ROOT/%{_datadir}/applications
+desktop-file-install --vendor Amra \
+	--dir $RPM_BUILD_ROOT/%{_datadir}/applications  \
+	%{name}.desktop
+
+%post
+gtk-update-icon-cache -q -f %{_datadir}/icons/hicolor || :
+
+%clean
+[ -n "$RPM_BUILD_ROOT" -a "$RPM_BUILD_ROOT" != / ] && rm -rf $RPM_BUILD_ROOT
+
+%files
+%defattr(-, root, root, -)
+%doc ChangeLog COPYING README TODO
+%{_bindir}/pinot
+%{_datadir}/pinot/index.html
+%{_datadir}/pinot/xapian-powered.png
+%{_datadir}/pinot/metase-gtk2.glade
+%{_datadir}/pinot/metase-gtk2.gladep
+%{_datadir}/pinot/textcat_conf.txt
+%{_datadir}/pinot/*.src
+%dir %{_datadir}/pinot/engines/
+%config(noreplace) %{_datadir}/pinot/engines/A9.src
+%config(noreplace) %{_datadir}/pinot/engines/Acoona.src
+%config(noreplace) %{_datadir}/pinot/engines/Altavista.src
+%config(noreplace) %{_datadir}/pinot/engines/AskJeeves.src
+%config(noreplace) %{_datadir}/pinot/engines/BitTorrent.src
+%config(noreplace) %{_datadir}/pinot/engines/Clusty.src
+%config(noreplace) %{_datadir}/pinot/engines/Freshmeat.src
+%config(noreplace) %{_datadir}/pinot/engines/Koders.src
+%config(noreplace) %{_datadir}/pinot/engines/Google.src
+%config(noreplace) %{_datadir}/pinot/engines/Lycos.src
+%config(noreplace) %{_datadir}/pinot/engines/MSN.src
+%config(noreplace) %{_datadir}/pinot/engines/Teoma.src
+%config(noreplace) %{_datadir}/pinot/engines/Topix.src
+%config(noreplace) %{_datadir}/pinot/engines/WiseNut.src
+%config(noreplace) %{_datadir}/pinot/engines/Yahoo.src
+%config(noreplace) %{_datadir}/pinot/engines/YahooAPI.src
+%config(noreplace) %{_datadir}/pinot/engines/Wikipedia.src
+%{_datadir}/locale/fr/LC_MESSAGES/pinot.mo
+%{_datadir}/icons/hicolor/48x48/apps/pinot.png
+%{_datadir}/applications/Amra-%{name}.desktop
+
+%files pdf
+%defattr(-, root, root, -)
+%dir %{_datadir}/pinot/tokenizers/pdf_tokenizer.so
+
+%files word
+%defattr(-, root, root, -)
+%dir %{_datadir}/pinot/tokenizers/word_tokenizer.so
+
+%files omega
+%defattr(-, root, root, -)
+%config(noreplace) %{_datadir}/pinot/engines/Omega.src
+
+%changelog

Added: trunk/po/POTFILES
===================================================================
--- trunk/po/POTFILES	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/po/POTFILES	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,24 @@
+UI/GTK2/src/aboutDialog.cc
+UI/GTK2/src/aboutDialog_glade.cc
+UI/GTK2/src/EnginesTree.cpp
+UI/GTK2/src/HtmlView.cpp
+UI/GTK2/src/importDialog.cc
+UI/GTK2/src/importDialog_glade.cc
+UI/GTK2/src/indexDialog.cc
+UI/GTK2/src/indexDialog_glade.cc
+UI/GTK2/src/IndexTree.cpp
+UI/GTK2/src/mainWindow.cc
+UI/GTK2/src/mainWindow_glade.cc
+UI/GTK2/src/ModelColumns.cpp
+UI/GTK2/src/MonitorHandler.cpp
+UI/GTK2/src/pinot.cpp
+UI/GTK2/src/PinotSettings.cpp
+UI/GTK2/src/PinotUtils.cpp
+UI/GTK2/src/prefsDialog.cc
+UI/GTK2/src/prefsDialog_glade.cc
+UI/GTK2/src/propertiesDialog.cc
+UI/GTK2/src/propertiesDialog_glade.cc
+UI/GTK2/src/queryDialog.cc
+UI/GTK2/src/queryDialog_glade.cc
+UI/GTK2/src/ResultsTree.cpp
+UI/GTK2/src/WorkerThreads.cpp

Added: trunk/po/en_GB.po
===================================================================
--- trunk/po/en_GB.po	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/po/en_GB.po	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,815 @@
+# en_GB PO file for pinot.
+# Copyright (C) 2005 Fabrice Colin
+# This file is distributed under the same license as the pinot package.
+# Fabrice Colin <colinf at chez.com>, 2005.
+#
+#: UI/GTK2/src/importDialog_glade.cc:110 UI/GTK2/src/importDialog_glade.cc:117
+#: UI/GTK2/src/indexDialog_glade.cc:94 UI/GTK2/src/indexDialog_glade.cc:124
+#: UI/GTK2/src/mainWindow_glade.cc:302 UI/GTK2/src/prefsDialog_glade.cc:153
+#: UI/GTK2/src/prefsDialog_glade.cc:164
+#: UI/GTK2/src/propertiesDialog_glade.cc:89
+#: UI/GTK2/src/propertiesDialog_glade.cc:130
+#: UI/GTK2/src/propertiesDialog_glade.cc:143
+#: UI/GTK2/src/queryDialog_glade.cc:115 UI/GTK2/src/queryDialog_glade.cc:126
+#: UI/GTK2/src/queryDialog_glade.cc:133 UI/GTK2/src/queryDialog_glade.cc:140
+#: UI/GTK2/src/queryDialog_glade.cc:205 UI/GTK2/src/queryDialog_glade.cc:212
+#: UI/GTK2/src/queryDialog_glade.cc:237
+#, fuzzy
+msgid ""
+msgstr ""
+"Project-Id-Version: pinot 0.20\n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2005-12-08 19:20+0800\n"
+"PO-Revision-Date: 2005-12-08 19:20+0800\n"
+"Last-Translator: Fabrice Colin <colinf at chez.com>\n"
+"Language-Team: en_GB <colinf at chez.com>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=utf-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: UI/GTK2/src/aboutDialog_glade.cc:342 UI/GTK2/src/mainWindow_glade.cc:445
+msgid "Pinot"
+msgstr ""
+
+#: UI/GTK2/src/aboutDialog_glade.cc:344
+msgid "A metasearch tool for the Free Desktop."
+msgstr ""
+
+#: UI/GTK2/src/aboutDialog_glade.cc:345
+msgid "Copyright (C) 2005 Fabrice Colin"
+msgstr ""
+
+#: UI/GTK2/src/aboutDialog_glade.cc:388
+msgid "About Pinot"
+msgstr ""
+
+#: UI/GTK2/src/EnginesTree.cpp:67
+msgid "Search Engines"
+msgstr ""
+
+#: UI/GTK2/src/EnginesTree.cpp:291
+msgid "Current User"
+msgstr ""
+
+#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:79
+#: UI/GTK2/src/mainWindow.cc:631 UI/GTK2/src/mainWindow.cc:1059
+#: UI/GTK2/src/mainWindow.cc:2514 UI/GTK2/src/PinotSettings.cpp:198
+#: UI/GTK2/src/PinotSettings.cpp:859 UI/GTK2/src/PinotSettings.cpp:915
+msgid "My Documents"
+msgstr ""
+
+#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:635
+#: UI/GTK2/src/MonitorHandler.cpp:173 UI/GTK2/src/PinotSettings.cpp:199
+#: UI/GTK2/src/PinotSettings.cpp:860 UI/GTK2/src/PinotSettings.cpp:916
+#: UI/GTK2/src/prefsDialog_glade.cc:116
+msgid "My Email"
+msgstr ""
+
+#: UI/GTK2/src/importDialog.cc:92
+msgid "Single file"
+msgstr ""
+
+#: UI/GTK2/src/importDialog.cc:95
+msgid "Whole directory"
+msgstr ""
+
+#: UI/GTK2/src/importDialog.cc:100 UI/GTK2/src/IndexTree.cpp:72
+#: UI/GTK2/src/ResultsTree.cpp:116
+msgid "URL"
+msgstr ""
+
+#: UI/GTK2/src/importDialog.cc:249
+msgid "Document To Import"
+msgstr ""
+
+#: UI/GTK2/src/importDialog_glade.cc:64
+msgid "Select"
+msgstr ""
+
+#: UI/GTK2/src/importDialog_glade.cc:73 UI/GTK2/src/indexDialog_glade.cc:68
+msgid "Location:"
+msgstr ""
+
+#: UI/GTK2/src/importDialog_glade.cc:74
+#: UI/GTK2/src/propertiesDialog_glade.cc:64
+msgid "Title:"
+msgstr ""
+
+#: UI/GTK2/src/importDialog_glade.cc:75
+msgid "Maximum depth:"
+msgstr ""
+
+#: UI/GTK2/src/importDialog_glade.cc:81 UI/GTK2/src/indexDialog_glade.cc:67
+#: UI/GTK2/src/propertiesDialog_glade.cc:68
+msgid "Type:"
+msgstr ""
+
+#: UI/GTK2/src/importDialog_glade.cc:163
+msgid "Import document"
+msgstr ""
+
+#: UI/GTK2/src/indexDialog.cc:202
+msgid "Index location"
+msgstr ""
+
+#: UI/GTK2/src/indexDialog_glade.cc:62 UI/GTK2/src/queryDialog_glade.cc:60
+msgid "Name:"
+msgstr ""
+
+#: UI/GTK2/src/indexDialog_glade.cc:64 UI/GTK2/src/prefsDialog_glade.cc:70
+msgid "..."
+msgstr ""
+
+#: UI/GTK2/src/indexDialog_glade.cc:69
+msgid "Port:"
+msgstr ""
+
+#: UI/GTK2/src/indexDialog_glade.cc:145
+msgid "External index"
+msgstr ""
+
+#: UI/GTK2/src/IndexTree.cpp:66 UI/GTK2/src/ResultsTree.cpp:98
+msgid "Title"
+msgstr ""
+
+#: UI/GTK2/src/IndexTree.cpp:77
+msgid "Timestamp"
+msgstr ""
+
+#: UI/GTK2/src/IndexTree.cpp:219 UI/GTK2/src/WorkerThreads.cpp:341
+msgid "No title"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:78 UI/GTK2/src/mainWindow.cc:489
+#: UI/GTK2/src/mainWindow.cc:684
+msgid "None"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:217
+msgid "Query Name"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:222
+msgid "Last Run"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:223
+msgid "Summary"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:306
+msgid "Add index"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:307
+msgid "Remove index"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:332
+msgid "Ready"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:385
+msgid "N/A"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:395 UI/GTK2/src/mainWindow.cc:1480
+msgid "<undefined>"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:602
+msgid "Result location is"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:646
+msgid "Document location is"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:687
+msgid "No labels"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:791
+msgid "Showing"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:796
+msgid "off"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:801
+msgid "documents from"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:871
+msgid "Query"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:875 UI/GTK2/src/mainWindow.cc:2482
+#: UI/GTK2/src/ResultsTree.cpp:436 UI/GTK2/src/ResultsTree.cpp:708
+msgid "on"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:879
+msgid "ended"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:940 UI/GTK2/src/propertiesDialog.cc:34
+msgid "Label"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:944
+msgid "matches"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:949
+msgid "document(s)"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1027 UI/GTK2/src/mainWindow.cc:1122
+msgid "Updated document"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1034
+msgid "Indexed"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1101
+msgid "Unindexed document(s)"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1179
+msgid "Couldn't rename index, name"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1183 UI/GTK2/src/mainWindow.cc:1914
+#: UI/GTK2/src/mainWindow.cc:2024 UI/GTK2/src/mainWindow.cc:2081
+msgid "is already in use"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1196
+msgid "Couldn't rename index"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1209
+msgid "Edited index"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1581 UI/GTK2/src/mainWindow.cc:1640
+msgid "Please set a location for the index first"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1597
+msgid "Result location is unknown"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1613
+msgid "Import Document(s)"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1693 UI/GTK2/src/mainWindow_glade.cc:163
+#: UI/GTK2/src/pinot.cpp:111 UI/GTK2/src/pinot.cpp:116
+#: UI/GTK2/src/WorkerThreads.cpp:184 UI/GTK2/src/WorkerThreads.cpp:417
+#: UI/GTK2/src/WorkerThreads.cpp:960
+msgid "Index"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1697 UI/GTK2/src/WorkerThreads.cpp:188
+#: UI/GTK2/src/WorkerThreads.cpp:421 UI/GTK2/src/WorkerThreads.cpp:964
+msgid "doesn't exist"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1805
+msgid "Delete this document from the index ?"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1816
+msgid "Delete these documents from the index ?"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1910
+msgid "Index name"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1925
+msgid "Couldn't add index"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1939
+msgid "Added new index"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1974
+msgid "Couldn't remove index"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2020 UI/GTK2/src/mainWindow.cc:2077
+msgid "Query name"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2034
+msgid "Couldn't add query"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2043
+msgid "Added new query"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2102
+msgid "Couldn't update query"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2111
+msgid "Edited query"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2263
+msgid "At least one background task hasn't been completed yet. Quit now ?"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2376
+msgid "Query is not set"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2387
+msgid "No search engine selected"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2469
+msgid "Please set the Google API key first"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2478
+msgid "Running query"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2628
+msgid "No URL to browse"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2642
+msgid "No browser configured to view results"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2654
+msgid "Couldn't browse URL:"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2883
+msgid "thread(s)"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:115
+msgid "Query:"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:127 UI/GTK2/src/prefsDialog_glade.cc:86
+msgid "Edit"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:136
+msgid "Stored queries"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:144
+msgid "Results"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:166 UI/GTK2/src/mainWindow_glade.cc:234
+msgid "View"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:198
+msgid "Search Engine"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:201
+msgid "Host Name"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:204
+msgid "Clear List"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:207
+msgid "Show Extract"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:210
+msgid "Group By"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:216
+msgid "Vie_w"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:219
+msgid "View Cache"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:222 UI/GTK2/src/mainWindow_glade.cc:258
+msgid "_Index"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:225
+msgid "Show Label"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:228
+msgid "Import"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:237
+msgid "Update"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:240
+msgid "Unindex"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:243
+#: UI/GTK2/src/propertiesDialog_glade.cc:174
+#: UI/GTK2/src/queryDialog_glade.cc:80
+msgid "Properties"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:246
+msgid "_About"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:249
+msgid "_Session"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:252
+msgid "_Edit"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:255
+msgid "_Results"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:261
+msgid "_Help"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:55
+msgid "Couldn't save configuration file"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:112 UI/GTK2/src/pinot.cpp:117
+msgid "is not valid, please check"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:127
+msgid "History database"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:128
+msgid "couldn't be created"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:134
+msgid "Danish"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:135
+msgid "Dutch"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:136
+msgid "English"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:137
+msgid "Finnish"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:138
+msgid "French"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:139
+msgid "German"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:140
+msgid "Italian"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:141
+msgid "Norwegian"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:142
+msgid "Portuguese"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:143
+msgid "Russian"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:144
+msgid "Spanish"
+msgstr ""
+
+#: UI/GTK2/src/pinot.cpp:145
+msgid "Swedish"
+msgstr ""
+
+#: UI/GTK2/src/PinotSettings.cpp:105
+msgid "Couldn't create pinot directory at"
+msgstr ""
+
+#: UI/GTK2/src/PinotSettings.cpp:194
+msgid "Failed to parse configuration file"
+msgstr ""
+
+#: UI/GTK2/src/PinotSettings.cpp:203
+msgid "Red"
+msgstr ""
+
+#: UI/GTK2/src/PinotSettings.cpp:205
+msgid "Blue"
+msgstr ""
+
+#: UI/GTK2/src/PinotSettings.cpp:207
+msgid "Green"
+msgstr ""
+
+#: UI/GTK2/src/PinotSettings.cpp:279
+msgid "Couldn't load ui block"
+msgstr ""
+
+#: UI/GTK2/src/PinotSettings.cpp:286
+msgid "Couldn't load extraindex block"
+msgstr ""
+
+#: UI/GTK2/src/PinotSettings.cpp:293
+msgid "Couldn't load storedquery block"
+msgstr ""
+
+#: UI/GTK2/src/PinotSettings.cpp:300
+msgid "Couldn't load results block"
+msgstr ""
+
+#: UI/GTK2/src/PinotSettings.cpp:307
+msgid "Couldn't load label block"
+msgstr ""
+
+#: UI/GTK2/src/PinotSettings.cpp:325
+msgid "Couldn't load mailaccount block"
+msgstr ""
+
+#: UI/GTK2/src/PinotSettings.cpp:711
+msgid "Unclassified"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog.cc:63
+msgid "Name"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog.cc:71
+msgid "Location"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog.cc:72
+msgid "MIME Type"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog.cc:100
+msgid "In internal viewer"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog.cc:103
+msgid "In browser"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog.cc:364
+msgid "Browser location"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog.cc:375
+msgid "New Label"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog.cc:397
+msgid "Colour"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog.cc:463
+msgid "Import Mail Box(es)"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog.cc:481
+msgid "Mbox File Location"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog_glade.cc:62
+msgid "HTTP crawling:"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog_glade.cc:63
+msgid "View documents:"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog_glade.cc:64
+msgid "Browser:"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog_glade.cc:65
+msgid "Google API Key:"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog_glade.cc:68
+msgid "Ignore robots.txt and Robots META tag"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog_glade.cc:74
+msgid "General"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog_glade.cc:75
+msgid "Labels are used to classify indexed documents:"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog_glade.cc:80 UI/GTK2/src/prefsDialog_glade.cc:106
+msgid "Add"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog_glade.cc:92
+msgid "Remove"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog_glade.cc:100
+msgid "Labels"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog_glade.cc:101
+msgid "Mail boxes of type mbox can be monitored and indexed:"
+msgstr ""
+
+#: UI/GTK2/src/prefsDialog_glade.cc:334
+msgid "Preferences"
+msgstr ""
+
+#: UI/GTK2/src/propertiesDialog.cc:45
+msgid "Unknown"
+msgstr ""
+
+#: UI/GTK2/src/propertiesDialog_glade.cc:65
+msgid "Extract:"
+msgstr ""
+
+#: UI/GTK2/src/propertiesDialog_glade.cc:66
+msgid "Language:"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog.cc:107
+msgid "Any"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:70
+msgid "Index all results with label"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:72
+msgid "Any of the words:"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:73
+msgid "Host name:"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:74
+msgid "File name:"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:75
+msgid "Number of results:"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:81
+msgid "Limit to documents that match"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:85
+msgid "the exact phrase:"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:86
+msgid "none of the words:"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:87
+msgid "the language:"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:91
+msgid "all the words:"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:94
+msgid "Advanced"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:278
+msgid "Query properties"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:163
+msgid "Stopped browsing"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:197 UI/GTK2/src/WorkerThreads.cpp:632
+#: UI/GTK2/src/WorkerThreads.cpp:838 UI/GTK2/src/WorkerThreads.cpp:973
+msgid "Index error on"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:303
+msgid "Stopped querying"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:315
+msgid "Couldn't create search engine"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:327
+msgid "Couldn't run query on search engine"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:401
+msgid "Stopped querying index labels"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:482
+msgid "Stopped retrieval of"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:518
+msgid "Couldn't obtain downloader for protocol"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:532 UI/GTK2/src/WorkerThreads.cpp:646
+msgid "Couldn't retrieve"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:617
+msgid "Stopped indexing"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:671
+msgid "Cannot index document type"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:675
+msgid "at"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:693
+msgid "Couln't tokenize"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:714
+msgid "Robots META tag forbids indexing"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:760
+msgid "Couldn't index"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:825
+msgid "Stopped unindexing document(s)"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:846
+msgid "Couldn't unindex document(s)"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:945
+msgid "Stopped document update for "
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:982
+msgid "Couldn't update document"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:1022
+msgid "Stopped listening on"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:1114
+msgid "Couldn't read FIFO at"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:1154
+msgid "Stopped monitoring"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:1172
+msgid "No monitoring handler"
+msgstr ""
+
+#: UI/GTK2/src/WorkerThreads.cpp:1206
+msgid "Couldn't open FAM connection"
+msgstr ""

Added: trunk/po/fr_FR.po
===================================================================
--- trunk/po/fr_FR.po	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/po/fr_FR.po	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,815 @@
+# fr_FR PO file for pinot.
+# Copyright (C) 2005 Fabrice Colin
+# This file is distributed under the same license as the pinot package.
+# Fabrice Colin <colinf at chez.com>, 2005.
+#
+#: UI/GTK2/src/importDialog_glade.cc:110 UI/GTK2/src/importDialog_glade.cc:117
+#: UI/GTK2/src/indexDialog_glade.cc:94 UI/GTK2/src/indexDialog_glade.cc:124
+#: UI/GTK2/src/mainWindow_glade.cc:302 UI/GTK2/src/prefsDialog_glade.cc:153
+#: UI/GTK2/src/prefsDialog_glade.cc:164
+#: UI/GTK2/src/propertiesDialog_glade.cc:89
+#: UI/GTK2/src/propertiesDialog_glade.cc:130
+#: UI/GTK2/src/propertiesDialog_glade.cc:143
+#: UI/GTK2/src/queryDialog_glade.cc:115 UI/GTK2/src/queryDialog_glade.cc:126
+#: UI/GTK2/src/queryDialog_glade.cc:133 UI/GTK2/src/queryDialog_glade.cc:140
+#: UI/GTK2/src/queryDialog_glade.cc:205 UI/GTK2/src/queryDialog_glade.cc:212
+#: UI/GTK2/src/queryDialog_glade.cc:237
+#, fuzzy
+msgid ""
+msgstr ""
+"Project-Id-Version: pinot 0.20\n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2005-12-08 19:20+0800\n"
+"PO-Revision-Date: 2005-12-08 19:20+0800\n"
+"Last-Translator: Fabrice Colin <colinf at chez.com>\n"
+"Language-Team: en_GB <colinf at chez.com>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=utf-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: UI/GTK2/src/aboutDialog_glade.cc:342 UI/GTK2/src/mainWindow_glade.cc:445
+msgid "Pinot"
+msgstr "Pinot"
+
+#: UI/GTK2/src/aboutDialog_glade.cc:344
+msgid "A metasearch tool for the Free Desktop."
+msgstr "Un outil de recherche pour le Bureau Libre"
+
+#: UI/GTK2/src/aboutDialog_glade.cc:345
+msgid "Copyright (C) 2005 Fabrice Colin"
+msgstr "Copyright (C) 2005 Fabrice Colin"
+
+#: UI/GTK2/src/aboutDialog_glade.cc:388
+msgid "About Pinot"
+msgstr "A Propos de Pinot"
+
+#: UI/GTK2/src/EnginesTree.cpp:67
+msgid "Search Engines"
+msgstr "Moteurs"
+
+#: UI/GTK2/src/EnginesTree.cpp:291
+msgid "Current User"
+msgstr "Utilisateur"
+
+#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:79
+#: UI/GTK2/src/mainWindow.cc:631 UI/GTK2/src/mainWindow.cc:1059
+#: UI/GTK2/src/mainWindow.cc:2514 UI/GTK2/src/PinotSettings.cpp:198
+#: UI/GTK2/src/PinotSettings.cpp:859 UI/GTK2/src/PinotSettings.cpp:915
+msgid "My Documents"
+msgstr "Mes Documents"
+
+#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:635
+#: UI/GTK2/src/MonitorHandler.cpp:173 UI/GTK2/src/PinotSettings.cpp:199
+#: UI/GTK2/src/PinotSettings.cpp:860 UI/GTK2/src/PinotSettings.cpp:916
+#: UI/GTK2/src/prefsDialog_glade.cc:116
+msgid "My Email"
+msgstr "Mon Courrier"
+
+#: UI/GTK2/src/importDialog.cc:92
+msgid "Single file"
+msgstr "Un fichier"
+
+#: UI/GTK2/src/importDialog.cc:95
+msgid "Whole directory"
+msgstr "Un repertoire"
+
+#: UI/GTK2/src/importDialog.cc:100 UI/GTK2/src/IndexTree.cpp:72
+#: UI/GTK2/src/ResultsTree.cpp:116
+msgid "URL"
+msgstr "URL"
+
+#: UI/GTK2/src/importDialog.cc:249
+msgid "Document To Import"
+msgstr "Document A Importer"
+
+#: UI/GTK2/src/importDialog_glade.cc:64
+msgid "Select"
+msgstr "Selectionner"
+
+#: UI/GTK2/src/importDialog_glade.cc:73 UI/GTK2/src/indexDialog_glade.cc:68
+msgid "Location:"
+msgstr "Location:"
+
+#: UI/GTK2/src/importDialog_glade.cc:74
+#: UI/GTK2/src/propertiesDialog_glade.cc:64
+msgid "Title:"
+msgstr "Titre:"
+
+#: UI/GTK2/src/importDialog_glade.cc:75
+msgid "Maximum depth:"
+msgstr "Profondeur maximum:"
+
+#: UI/GTK2/src/importDialog_glade.cc:81 UI/GTK2/src/indexDialog_glade.cc:67
+#: UI/GTK2/src/propertiesDialog_glade.cc:68
+msgid "Type:"
+msgstr "Type:"
+
+#: UI/GTK2/src/importDialog_glade.cc:163
+msgid "Import document"
+msgstr "Importation de document"
+
+#: UI/GTK2/src/indexDialog.cc:202
+msgid "Index location"
+msgstr "Location de l'index"
+
+#: UI/GTK2/src/indexDialog_glade.cc:62 UI/GTK2/src/queryDialog_glade.cc:60
+msgid "Name:"
+msgstr "Nom:"
+
+#: UI/GTK2/src/indexDialog_glade.cc:64 UI/GTK2/src/prefsDialog_glade.cc:70
+msgid "..."
+msgstr "..."
+
+#: UI/GTK2/src/indexDialog_glade.cc:69
+msgid "Port:"
+msgstr "Port:"
+
+#: UI/GTK2/src/indexDialog_glade.cc:145
+msgid "External index"
+msgstr "Index externe"
+
+#: UI/GTK2/src/IndexTree.cpp:66 UI/GTK2/src/ResultsTree.cpp:98
+msgid "Title"
+msgstr "Titre"
+
+#: UI/GTK2/src/IndexTree.cpp:77
+msgid "Timestamp"
+msgstr "Date"
+
+#: UI/GTK2/src/IndexTree.cpp:219 UI/GTK2/src/WorkerThreads.cpp:341
+msgid "No title"
+msgstr "Pas de titre"
+
+#: UI/GTK2/src/mainWindow.cc:78 UI/GTK2/src/mainWindow.cc:489
+#: UI/GTK2/src/mainWindow.cc:684
+msgid "None"
+msgstr "Aucune"
+
+#: UI/GTK2/src/mainWindow.cc:217
+msgid "Query Name"
+msgstr "Nom de la Recherche"
+
+#: UI/GTK2/src/mainWindow.cc:222
+msgid "Last Run"
+msgstr "Derniere Utilisation"
+
+#: UI/GTK2/src/mainWindow.cc:223
+msgid "Summary"
+msgstr "Sommaire"
+
+#: UI/GTK2/src/mainWindow.cc:306
+msgid "Add index"
+msgstr "Ajouter un index"
+
+#: UI/GTK2/src/mainWindow.cc:307
+msgid "Remove index"
+msgstr "Enlever un index"
+
+#: UI/GTK2/src/mainWindow.cc:332
+msgid "Ready"
+msgstr "Pret"
+
+#: UI/GTK2/src/mainWindow.cc:385
+msgid "N/A"
+msgstr "Inconnue"
+
+#: UI/GTK2/src/mainWindow.cc:395 UI/GTK2/src/mainWindow.cc:1480
+msgid "<undefined>"
+msgstr "<inconnu>"
+
+#: UI/GTK2/src/mainWindow.cc:602
+msgid "Result location is"
+msgstr "La location du resultat est"
+
+#: UI/GTK2/src/mainWindow.cc:646
+msgid "Document location is"
+msgstr "La location du document is"
+
+#: UI/GTK2/src/mainWindow.cc:687
+msgid "No labels"
+msgstr "Pas d'etiquettes"
+
+#: UI/GTK2/src/mainWindow.cc:791
+msgid "Showing"
+msgstr "Listant"
+
+#: UI/GTK2/src/mainWindow.cc:796
+msgid "off"
+msgstr "de"
+
+#: UI/GTK2/src/mainWindow.cc:801
+msgid "documents from"
+msgstr "documents venant de"
+
+#: UI/GTK2/src/mainWindow.cc:871
+msgid "Query"
+msgstr "La recherche"
+
+#: UI/GTK2/src/mainWindow.cc:875 UI/GTK2/src/mainWindow.cc:2482
+#: UI/GTK2/src/ResultsTree.cpp:436 UI/GTK2/src/ResultsTree.cpp:708
+msgid "on"
+msgstr "sur"
+
+#: UI/GTK2/src/mainWindow.cc:879
+msgid "ended"
+msgstr "est terminee"
+
+#: UI/GTK2/src/mainWindow.cc:940 UI/GTK2/src/propertiesDialog.cc:34
+msgid "Label"
+msgstr "L'etiquette"
+
+#: UI/GTK2/src/mainWindow.cc:944
+msgid "matches"
+msgstr "correspond a"
+
+#: UI/GTK2/src/mainWindow.cc:949
+msgid "document(s)"
+msgstr "document(s)"
+
+#: UI/GTK2/src/mainWindow.cc:1027 UI/GTK2/src/mainWindow.cc:1122
+msgid "Updated document"
+msgstr "Mis a jour le document"
+
+#: UI/GTK2/src/mainWindow.cc:1034
+msgid "Indexed"
+msgstr "Indexe"
+
+#: UI/GTK2/src/mainWindow.cc:1101
+msgid "Unindexed document(s)"
+msgstr "Desindexe le(s) document(s)"
+
+#: UI/GTK2/src/mainWindow.cc:1179
+msgid "Couldn't rename index, name"
+msgstr "N'a pas pu renommer l'index"
+
+#: UI/GTK2/src/mainWindow.cc:1183 UI/GTK2/src/mainWindow.cc:1914
+#: UI/GTK2/src/mainWindow.cc:2024 UI/GTK2/src/mainWindow.cc:2081
+msgid "is already in use"
+msgstr "est deja utilise"
+
+#: UI/GTK2/src/mainWindow.cc:1196
+msgid "Couldn't rename index"
+msgstr "N'a pas pu renommer l'index"
+
+#: UI/GTK2/src/mainWindow.cc:1209
+msgid "Edited index"
+msgstr "Edite l'index"
+
+#: UI/GTK2/src/mainWindow.cc:1581 UI/GTK2/src/mainWindow.cc:1640
+msgid "Please set a location for the index first"
+msgstr "Donnez une location a l'index"
+
+#: UI/GTK2/src/mainWindow.cc:1597
+msgid "Result location is unknown"
+msgstr "La location du resultat est inconnue"
+
+#: UI/GTK2/src/mainWindow.cc:1613
+msgid "Import Document(s)"
+msgstr "Importation de Document(s)"
+
+#: UI/GTK2/src/mainWindow.cc:1693 UI/GTK2/src/mainWindow_glade.cc:163
+#: UI/GTK2/src/pinot.cpp:111 UI/GTK2/src/pinot.cpp:116
+#: UI/GTK2/src/WorkerThreads.cpp:184 UI/GTK2/src/WorkerThreads.cpp:417
+#: UI/GTK2/src/WorkerThreads.cpp:960
+msgid "Index"
+msgstr "L'index"
+
+#: UI/GTK2/src/mainWindow.cc:1697 UI/GTK2/src/WorkerThreads.cpp:188
+#: UI/GTK2/src/WorkerThreads.cpp:421 UI/GTK2/src/WorkerThreads.cpp:964
+msgid "doesn't exist"
+msgstr "n'existe pas"
+
+#: UI/GTK2/src/mainWindow.cc:1805
+msgid "Delete this document from the index ?"
+msgstr "Enlever ce document de l'index ?"
+
+#: UI/GTK2/src/mainWindow.cc:1816
+msgid "Delete these documents from the index ?"
+msgstr "Enlever ces documents de l'index ?"
+
+#: UI/GTK2/src/mainWindow.cc:1910
+msgid "Index name"
+msgstr "Nom de l'index"
+
+#: UI/GTK2/src/mainWindow.cc:1925
+msgid "Couldn't add index"
+msgstr "N'a pas pu ajouter l'index"
+
+#: UI/GTK2/src/mainWindow.cc:1939
+msgid "Added new index"
+msgstr "Ajouter un nouvel index"
+
+#: UI/GTK2/src/mainWindow.cc:1974
+msgid "Couldn't remove index"
+msgstr "N'a pas pu enlever l'index"
+
+#: UI/GTK2/src/mainWindow.cc:2020 UI/GTK2/src/mainWindow.cc:2077
+msgid "Query name"
+msgstr "Nom de la recherche"
+
+#: UI/GTK2/src/mainWindow.cc:2034
+msgid "Couldn't add query"
+msgstr "N'a pas pu ajouter la recherche"
+
+#: UI/GTK2/src/mainWindow.cc:2043
+msgid "Added new query"
+msgstr "Ajoute une nouvelle recherche"
+
+#: UI/GTK2/src/mainWindow.cc:2102
+msgid "Couldn't update query"
+msgstr "N'a pas pu mettre a jour la recherche"
+
+#: UI/GTK2/src/mainWindow.cc:2111
+msgid "Edited query"
+msgstr "Edite la recherche"
+
+#: UI/GTK2/src/mainWindow.cc:2263
+msgid "At least one background task hasn't been completed yet. Quit now ?"
+msgstr "Au moins une tache n'est pas terminee. Quitter maintenant ?"
+
+#: UI/GTK2/src/mainWindow.cc:2376
+msgid "Query is not set"
+msgstr "Recherche indefinie"
+
+#: UI/GTK2/src/mainWindow.cc:2387
+msgid "No search engine selected"
+msgstr "Pas de moteur selectionne"
+
+#: UI/GTK2/src/mainWindow.cc:2469
+msgid "Please set the Google API key first"
+msgstr "Configurez la clef de l'API Google "
+
+#: UI/GTK2/src/mainWindow.cc:2478
+msgid "Running query"
+msgstr "Recherche en cours"
+
+#: UI/GTK2/src/mainWindow.cc:2628
+msgid "No URL to browse"
+msgstr "Pas d'URL a brouter"
+
+#: UI/GTK2/src/mainWindow.cc:2642
+msgid "No browser configured to view results"
+msgstr "Pas de brouter configure"
+
+#: UI/GTK2/src/mainWindow.cc:2654
+msgid "Couldn't browse URL:"
+msgstr "N'a pas pu brouter l'URL"
+
+#: UI/GTK2/src/mainWindow.cc:2883
+msgid "thread(s)"
+msgstr "tache(s)"
+
+#: UI/GTK2/src/mainWindow_glade.cc:115
+msgid "Query:"
+msgstr "Recherche:"
+
+#: UI/GTK2/src/mainWindow_glade.cc:127 UI/GTK2/src/prefsDialog_glade.cc:86
+msgid "Edit"
+msgstr "Editer"
+
+#: UI/GTK2/src/mainWindow_glade.cc:136
+msgid "Stored queries"
+msgstr "Recherches Sauvees"
+
+#: UI/GTK2/src/mainWindow_glade.cc:144
+msgid "Results"
+msgstr "Resultats"
+
+#: UI/GTK2/src/mainWindow_glade.cc:166 UI/GTK2/src/mainWindow_glade.cc:234
+msgid "View"
+msgstr "Voir"
+
+#: UI/GTK2/src/mainWindow_glade.cc:198
+msgid "Search Engine"
+msgstr "Moteurs"
+
+#: UI/GTK2/src/mainWindow_glade.cc:201
+msgid "Host Name"
+msgstr "Nom de machine"
+
+#: UI/GTK2/src/mainWindow_glade.cc:204
+msgid "Clear List"
+msgstr "Nettoyer la Liste"
+
+#: UI/GTK2/src/mainWindow_glade.cc:207
+msgid "Show Extract"
+msgstr "Montrer l'Extrait"
+
+#: UI/GTK2/src/mainWindow_glade.cc:210
+msgid "Group By"
+msgstr "Grouper Par"
+
+#: UI/GTK2/src/mainWindow_glade.cc:216
+msgid "Vie_w"
+msgstr "Voir"
+
+#: UI/GTK2/src/mainWindow_glade.cc:219
+msgid "View Cache"
+msgstr "Voir le Cache"
+
+#: UI/GTK2/src/mainWindow_glade.cc:222 UI/GTK2/src/mainWindow_glade.cc:258
+msgid "_Index"
+msgstr "Indexer"
+
+#: UI/GTK2/src/mainWindow_glade.cc:225
+msgid "Show Label"
+msgstr "Montrer l'Etiquette"
+
+#: UI/GTK2/src/mainWindow_glade.cc:228
+msgid "Import"
+msgstr "Importer"
+
+#: UI/GTK2/src/mainWindow_glade.cc:237
+msgid "Update"
+msgstr "Mettre a Jour"
+
+#: UI/GTK2/src/mainWindow_glade.cc:240
+msgid "Unindex"
+msgstr "Desindexer"
+
+#: UI/GTK2/src/mainWindow_glade.cc:243
+#: UI/GTK2/src/propertiesDialog_glade.cc:174
+#: UI/GTK2/src/queryDialog_glade.cc:80
+msgid "Properties"
+msgstr "Proprietes"
+
+#: UI/GTK2/src/mainWindow_glade.cc:246
+msgid "_About"
+msgstr "A Propos"
+
+#: UI/GTK2/src/mainWindow_glade.cc:249
+msgid "_Session"
+msgstr "Session"
+
+#: UI/GTK2/src/mainWindow_glade.cc:252
+msgid "_Edit"
+msgstr "Editer"
+
+#: UI/GTK2/src/mainWindow_glade.cc:255
+msgid "_Results"
+msgstr "Resultats"
+
+#: UI/GTK2/src/mainWindow_glade.cc:261
+msgid "_Help"
+msgstr "Aide"
+
+#: UI/GTK2/src/pinot.cpp:55
+msgid "Couldn't save configuration file"
+msgstr "N'a pas pu sauver la configuration"
+
+#: UI/GTK2/src/pinot.cpp:112 UI/GTK2/src/pinot.cpp:117
+msgid "is not valid, please check"
+msgstr "n'est pas valide, veuillez verifier"
+
+#: UI/GTK2/src/pinot.cpp:127
+msgid "History database"
+msgstr "La base des historiques"
+
+#: UI/GTK2/src/pinot.cpp:128
+msgid "couldn't be created"
+msgstr "n'a pas pu etre creee"
+
+#: UI/GTK2/src/pinot.cpp:134
+msgid "Danish"
+msgstr "Danois"
+
+#: UI/GTK2/src/pinot.cpp:135
+msgid "Dutch"
+msgstr "Hollandais"
+
+#: UI/GTK2/src/pinot.cpp:136
+msgid "English"
+msgstr "Anglais"
+
+#: UI/GTK2/src/pinot.cpp:137
+msgid "Finnish"
+msgstr "Finlandais"
+
+#: UI/GTK2/src/pinot.cpp:138
+msgid "French"
+msgstr "Francais"
+
+#: UI/GTK2/src/pinot.cpp:139
+msgid "German"
+msgstr "Allemand"
+
+#: UI/GTK2/src/pinot.cpp:140
+msgid "Italian"
+msgstr "Italien"
+
+#: UI/GTK2/src/pinot.cpp:141
+msgid "Norwegian"
+msgstr "Norvegien"
+
+#: UI/GTK2/src/pinot.cpp:142
+msgid "Portuguese"
+msgstr "Portugais"
+
+#: UI/GTK2/src/pinot.cpp:143
+msgid "Russian"
+msgstr "Russe"
+
+#: UI/GTK2/src/pinot.cpp:144
+msgid "Spanish"
+msgstr "Espagnol"
+
+#: UI/GTK2/src/pinot.cpp:145
+msgid "Swedish"
+msgstr "Suedois"
+
+#: UI/GTK2/src/PinotSettings.cpp:105
+msgid "Couldn't create pinot directory at"
+msgstr "N'a pas pu creer le repertoire a"
+
+#: UI/GTK2/src/PinotSettings.cpp:194
+msgid "Failed to parse configuration file"
+msgstr "N'a pas pu lire le fichier de configuration"
+
+#: UI/GTK2/src/PinotSettings.cpp:203
+msgid "Red"
+msgstr "Rouge"
+
+#: UI/GTK2/src/PinotSettings.cpp:205
+msgid "Blue"
+msgstr "Bleu"
+
+#: UI/GTK2/src/PinotSettings.cpp:207
+msgid "Green"
+msgstr "Vert"
+
+#: UI/GTK2/src/PinotSettings.cpp:279
+msgid "Couldn't load ui block"
+msgstr "N'a pas pu charger le bloc ui"
+
+#: UI/GTK2/src/PinotSettings.cpp:286
+msgid "Couldn't load extraindex block"
+msgstr "N'a pas pu charger le bloc extraindex"
+
+#: UI/GTK2/src/PinotSettings.cpp:293
+msgid "Couldn't load storedquery block"
+msgstr "N'a pas pu charger le bloc storedquery"
+
+#: UI/GTK2/src/PinotSettings.cpp:300
+msgid "Couldn't load results block"
+msgstr "N'a pas pu charger le bloc results"
+
+#: UI/GTK2/src/PinotSettings.cpp:307
+msgid "Couldn't load label block"
+msgstr "N'a pas pu charger le bloc label"
+
+#: UI/GTK2/src/PinotSettings.cpp:325
+msgid "Couldn't load mailaccount block"
+msgstr "N'a pas pu charger le bloc mailaccount"
+
+#: UI/GTK2/src/PinotSettings.cpp:711
+msgid "Unclassified"
+msgstr "Non classifie"
+
+#: UI/GTK2/src/prefsDialog.cc:63
+msgid "Name"
+msgstr "Nom"
+
+#: UI/GTK2/src/prefsDialog.cc:71
+msgid "Location"
+msgstr "Location"
+
+#: UI/GTK2/src/prefsDialog.cc:72
+msgid "MIME Type"
+msgstr "Type MIME"
+
+#: UI/GTK2/src/prefsDialog.cc:100
+msgid "In internal viewer"
+msgstr "Dans le brouteur interne"
+
+#: UI/GTK2/src/prefsDialog.cc:103
+msgid "In browser"
+msgstr "Dans le brouteur"
+
+#: UI/GTK2/src/prefsDialog.cc:364
+msgid "Browser location"
+msgstr "Brouter la location"
+
+#: UI/GTK2/src/prefsDialog.cc:375
+msgid "New Label"
+msgstr "Nouvelle Etiquette"
+
+#: UI/GTK2/src/prefsDialog.cc:397
+msgid "Colour"
+msgstr "Couleur"
+
+#: UI/GTK2/src/prefsDialog.cc:463
+msgid "Import Mail Box(es)"
+msgstr "Impoter des Boites de Courrier"
+
+#: UI/GTK2/src/prefsDialog.cc:481
+msgid "Mbox File Location"
+msgstr "Location du Fichier mbox"
+
+#: UI/GTK2/src/prefsDialog_glade.cc:62
+msgid "HTTP crawling:"
+msgstr "Brouteur HTTP:"
+
+#: UI/GTK2/src/prefsDialog_glade.cc:63
+msgid "View documents:"
+msgstr "Voir les documents"
+
+#: UI/GTK2/src/prefsDialog_glade.cc:64
+msgid "Browser:"
+msgstr "Brouteur:"
+
+#: UI/GTK2/src/prefsDialog_glade.cc:65
+msgid "Google API Key:"
+msgstr "Clef de l'API Google"
+
+#: UI/GTK2/src/prefsDialog_glade.cc:68
+msgid "Ignore robots.txt and Robots META tag"
+msgstr "Ignorer robots.txt et le META tag Robots"
+
+#: UI/GTK2/src/prefsDialog_glade.cc:74
+msgid "General"
+msgstr "General"
+
+#: UI/GTK2/src/prefsDialog_glade.cc:75
+msgid "Labels are used to classify indexed documents:"
+msgstr "Les etiquettes servent a classer les documents:"
+
+#: UI/GTK2/src/prefsDialog_glade.cc:80 UI/GTK2/src/prefsDialog_glade.cc:106
+msgid "Add"
+msgstr "Ajouter"
+
+#: UI/GTK2/src/prefsDialog_glade.cc:92
+msgid "Remove"
+msgstr "Enlever"
+
+#: UI/GTK2/src/prefsDialog_glade.cc:100
+msgid "Labels"
+msgstr "Etiquettes"
+
+#: UI/GTK2/src/prefsDialog_glade.cc:101
+msgid "Mail boxes of type mbox can be monitored and indexed:"
+msgstr "Les boites de type mbox peuvent etre indexees"
+
+#: UI/GTK2/src/prefsDialog_glade.cc:334
+msgid "Preferences"
+msgstr "Preferences"
+
+#: UI/GTK2/src/propertiesDialog.cc:45
+msgid "Unknown"
+msgstr "Inconnu"
+
+#: UI/GTK2/src/propertiesDialog_glade.cc:65
+msgid "Extract:"
+msgstr "Extrait:"
+
+#: UI/GTK2/src/propertiesDialog_glade.cc:66
+msgid "Language:"
+msgstr "Langue:"
+
+#: UI/GTK2/src/queryDialog.cc:107
+msgid "Any"
+msgstr "N'importe"
+
+#: UI/GTK2/src/queryDialog_glade.cc:70
+msgid "Index all results with label"
+msgstr "Indexer tous les resultats avec l'etiquette"
+
+#: UI/GTK2/src/queryDialog_glade.cc:72
+msgid "Any of the words:"
+msgstr "N'importe lequel des mots:"
+
+#: UI/GTK2/src/queryDialog_glade.cc:73
+msgid "Host name:"
+msgstr "Nom de machine:"
+
+#: UI/GTK2/src/queryDialog_glade.cc:74
+msgid "File name:"
+msgstr "Nom de fichier:"
+
+#: UI/GTK2/src/queryDialog_glade.cc:75
+msgid "Number of results:"
+msgstr "Nombre de resultats:"
+
+#: UI/GTK2/src/queryDialog_glade.cc:81
+msgid "Limit to documents that match"
+msgstr "Limiter aux documents qui ont"
+
+#: UI/GTK2/src/queryDialog_glade.cc:85
+msgid "the exact phrase:"
+msgstr "la phrase"
+
+#: UI/GTK2/src/queryDialog_glade.cc:86
+msgid "none of the words:"
+msgstr "aucun des mots"
+
+#: UI/GTK2/src/queryDialog_glade.cc:87
+msgid "the language:"
+msgstr "la langue"
+
+#: UI/GTK2/src/queryDialog_glade.cc:91
+msgid "all the words:"
+msgstr "tous les mots"
+
+#: UI/GTK2/src/queryDialog_glade.cc:94
+msgid "Advanced"
+msgstr "Avance"
+
+#: UI/GTK2/src/queryDialog_glade.cc:278
+msgid "Query properties"
+msgstr "Proprietes de la recherche"
+
+#: UI/GTK2/src/WorkerThreads.cpp:163
+msgid "Stopped browsing"
+msgstr "Arrete le brouteur"
+
+#: UI/GTK2/src/WorkerThreads.cpp:197 UI/GTK2/src/WorkerThreads.cpp:632
+#: UI/GTK2/src/WorkerThreads.cpp:838 UI/GTK2/src/WorkerThreads.cpp:973
+msgid "Index error on"
+msgstr "Erreur d'index sur"
+
+#: UI/GTK2/src/WorkerThreads.cpp:303
+msgid "Stopped querying"
+msgstr "Arrete la recherche"
+
+#: UI/GTK2/src/WorkerThreads.cpp:315
+msgid "Couldn't create search engine"
+msgstr "N'a pas pu creer le moteur"
+
+#: UI/GTK2/src/WorkerThreads.cpp:327
+msgid "Couldn't run query on search engine"
+msgstr "N'a pas pu lancer la recherche sur le moteur"
+
+#: UI/GTK2/src/WorkerThreads.cpp:401
+msgid "Stopped querying index labels"
+msgstr "Arrete la recherche d'etiquettes"
+
+#: UI/GTK2/src/WorkerThreads.cpp:482
+msgid "Stopped retrieval of"
+msgstr "Arrete le telechargement de"
+
+#: UI/GTK2/src/WorkerThreads.cpp:518
+msgid "Couldn't obtain downloader for protocol"
+msgstr "N'a pas pu obtenir un brouteur pour ="
+
+#: UI/GTK2/src/WorkerThreads.cpp:532 UI/GTK2/src/WorkerThreads.cpp:646
+msgid "Couldn't retrieve"
+msgstr "N'a pas pu telecharger"
+
+#: UI/GTK2/src/WorkerThreads.cpp:617
+msgid "Stopped indexing"
+msgstr "Arrete l'indexation"
+
+#: UI/GTK2/src/WorkerThreads.cpp:671
+msgid "Cannot index document type"
+msgstr "Impossible d'indexer de type de documents"
+
+#: UI/GTK2/src/WorkerThreads.cpp:675
+msgid "at"
+msgstr "a"
+
+#: UI/GTK2/src/WorkerThreads.cpp:693
+msgid "Couln't tokenize"
+msgstr "N'a pas pu tokenise"
+
+#: UI/GTK2/src/WorkerThreads.cpp:714
+msgid "Robots META tag forbids indexing"
+msgstr "Le META tag Robots empeche d'indexer"
+
+#: UI/GTK2/src/WorkerThreads.cpp:760
+msgid "Couldn't index"
+msgstr "N'a pas pu indexer"
+
+#: UI/GTK2/src/WorkerThreads.cpp:825
+msgid "Stopped unindexing document(s)"
+msgstr "Arrete d'indexer les document(s)"
+
+#: UI/GTK2/src/WorkerThreads.cpp:846
+msgid "Couldn't unindex document(s)"
+msgstr "N'a pas pu desindexer le(s) document(s)"
+
+#: UI/GTK2/src/WorkerThreads.cpp:945
+msgid "Stopped document update for "
+msgstr "Arrete la mise a jour pour "
+
+#: UI/GTK2/src/WorkerThreads.cpp:982
+msgid "Couldn't update document"
+msgstr "N'a pas pu mettre a jour le document"
+
+#: UI/GTK2/src/WorkerThreads.cpp:1022
+msgid "Stopped listening on"
+msgstr "Arrete l'ecoute sur"
+
+#: UI/GTK2/src/WorkerThreads.cpp:1114
+msgid "Couldn't read FIFO at"
+msgstr "N'a pas pu lire la FIFO a"
+
+#: UI/GTK2/src/WorkerThreads.cpp:1154
+msgid "Stopped monitoring"
+msgstr "Arrete la surveillance"
+
+#: UI/GTK2/src/WorkerThreads.cpp:1172
+msgid "No monitoring handler"
+msgstr "Pas de moniteur"
+
+#: UI/GTK2/src/WorkerThreads.cpp:1206
+msgid "Couldn't open FAM connection"
+msgstr "N'a pas pu ouvrir la connection FAM"

Added: trunk/textcat_conf.txt
===================================================================
--- trunk/textcat_conf.txt	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/textcat_conf.txt	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,18 @@
+#
+# libtextcat 2.2 config file
+# The following languages are supported by Xapian::Stem
+#
+/usr/share/libtextcat/LM/english.lm                     english
+/usr/share/libtextcat/LM/spanish.lm                     spanish
+/usr/share/libtextcat/LM/french.lm                      french
+/usr/share/libtextcat/LM/german.lm                      german
+/usr/share/libtextcat/LM/danish.lm			danish
+/usr/share/libtextcat/LM/dutch.lm			dutch
+/usr/share/libtextcat/LM/finnish.lm			finnish
+/usr/share/libtextcat/LM/italian.lm			italian
+/usr/share/libtextcat/LM/norwegian.lm			norwegian
+/usr/share/libtextcat/LM/portuguese.lm			portuguese
+/usr/share/libtextcat/LM/russian-iso8859_5.lm		russian-iso8859_5
+/usr/share/libtextcat/LM/russian-koi8_r.lm		russian-koi8_r
+/usr/share/libtextcat/LM/russian-windows1251.lm		russian-windows1251
+/usr/share/libtextcat/LM/swedish.lm			swedish

Added: trunk/variables.mk
===================================================================
--- trunk/variables.mk	2005-12-04 19:42:01 UTC (rev 0)
+++ trunk/variables.mk	2005-12-08 13:46:51 UTC (rev 1)
@@ -0,0 +1,113 @@
+CXX := @g++
+LINK := @libtool --mode=link g++
+AR := @ar
+WSDLC := @${GSOAP_HOME}/wsdl2h
+SOAPC := @${GSOAP_HOME}/soapcpp2 -I${GSOAP_HOME}
+
+HW_NAME := $(shell uname -i)
+OBJ_DIR := obj-${HW_NAME}
+LIB_DIR := ${ROOT_DIR}/lib-${HW_NAME}
+BIN_DIR := ${ROOT_DIR}/bin-${HW_NAME}
+
+# Libraries
+
+UTILS_LIB := ${LIB_DIR}/libutils.a
+TOKENIZE_LIB := ${LIB_DIR}/libtokenize.a
+SQL_LIB := ${LIB_DIR}/libsql.a
+DL_LIB := ${LIB_DIR}/libcollect.a
+GAPI_LIB := ${LIB_DIR}/libgoogleapi.a
+OSAPI_LIB := ${LIB_DIR}/libosapi.a
+SE_LIB := ${LIB_DIR}/libsearch.a
+SE_LIBS := ${SE_LIB}
+SOAPENV_LIB := ${LIB_DIR}/libsoapenv.a
+IDX_LIB := ${LIB_DIR}/libindex.a
+HTML_LIB := ${LIB_DIR}/libhtml.a
+
+# Flags
+
+PROJECT_CXXFLAGS := -I${ROOT_DIR}/Utils -I${ROOT_DIR}/Tokenize -I${ROOT_DIR}/SQL \
+	-I${ROOT_DIR}/Collect -I${ROOT_DIR}/Search -I${ROOT_DIR}/Index \
+	-I${ROOT_DIR}/UI/RenderHTML
+
+# SOAP
+NEEDS_SOAP := no
+# Google SOAP API is optional
+ifeq ($(HAS_GOOGLEAPI),yes)
+GOOGLEAPI_CXXFLAGS := -I${GSOAP_HOME} -I${ROOT_DIR}/Search/Google -DHAS_GOOGLEAPI
+SE_LIBS += ${GAPI_LIB}
+NEEDS_SOAP := yes
+else
+GOOGLEAPI_CXXFLAGS :=
+endif
+# ObjectsSearch SOAP API is also optional
+ifeq ($(HAS_OSAPI),yes)
+OSAPI_CXXFLAGS := -I${GSOAP_HOME} -I${ROOT_DIR}/Search/ObjectsSearch -DHAS_OSAPI
+SE_LIBS += ${OSAPI_LIB}
+NEEDS_SOAP := yes
+else
+OSAPI_CXXFLAGS :=
+endif
+ifeq ($(NEEDS_SOAP),yes)
+SE_LIBS += ${SOAPENV_LIB}
+endif
+
+# NEON
+NEON_CXXFLAGS = $(shell neon-config --cflags)
+NEON_LIBS = $(shell neon-config --libs)
+# OTS
+OTS_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags libots-1)
+OTS_LIBS = $(shell /usr/bin/pkg-config --libs libots-1)
+# GMime
+GMIME_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags gmime-2.0)
+GMIME_LIBS = $(shell /usr/bin/pkg-config --libs gmime-2.0)
+# Libtextcat
+TEXTCAT_CXXFLAGS =
+TEXTCAT_LIBS = -ltextcat
+# Xapian
+XAPIAN_CXXFLAGS = $(shell xapian-config --cxxflags)
+XAPIAN_LIBS = $(shell xapian-config --libs)
+# SQLite
+SQLITE_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags sqlite3)
+SQLITE_LIBS = $(shell /usr/bin/pkg-config --libs sqlite3)
+# LibXML 2.0
+LIBXML_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags libxml++-2.6)
+LIBXML_LIBS = $(shell /usr/bin/pkg-config --libs libxml++-2.6)
+# Mozilla
+MOZILLA_LIB_DIR = $(shell dirname `find /usr/lib*/mozilla* -name libgtkembedmoz.so | head -1`)
+ifeq ($(MOZILLA_LIB_DIR),)
+MOZILLA_LIB_DIR = /usr/lib/mozilla
+endif
+MOZILLA_INC_DIR = $(shell dirname `find /usr/include/mozilla* -name mozilla-config.h | head -1`)
+ifeq ($(MOZILLA_INC_DIR),)
+MOZILLA_INC_DIR = /usr/include/mozilla
+endif
+MOZILLA_XPCOM_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags mozilla-xpcom)
+MOZILLA_XPCOM_LIBS = -Xlinker -rpath -Xlinker ${MOZILLA_LIB_DIR} $(shell /usr/bin/pkg-config --libs mozilla-xpcom)
+GTKMOZ_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags mozilla-gtkmozembed gtk+-2.0)
+GTKMOZ_LIBS = -Xlinker -rpath -Xlinker ${MOZILLA_LIB_DIR} $(shell /usr/bin/pkg-config --libs mozilla-gtkmozembed gtk+-2.0)
+# GTKmm 2.0
+GTKMM_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags gtkmm-2.4)
+GTKMM_LIBS = $(shell /usr/bin/pkg-config --libs gtkmm-2.4)
+
+CXXFLAGS = -DENABLE_NLS ${PROJECT_CXXFLAGS} ${GOOGLEAPI_CXXFLAGS} ${OSAPI_CXXFLAGS} \
+	${NEON_CXXFLAGS} ${OTS_CXXFLAGS} ${GMIME_CXXFLAGS} ${TEXTCAT_CXXFLAGS} \
+	${LIBXML_CXXFLAGS} ${XAPIAN_CXXFLAGS} ${SQLITE_CXXFLAGS}
+ifeq ($(DEBUG),yes)
+CXXFLAGS += -g -DDEBUG
+endif
+LIBS := -lmagic -lpthread -lcrypt ${NEON_LIBS} ${OTS_LIBS} ${GMIME_LIBS} ${TEXTCAT_LIBS} \
+	${LIBXML_LIBS} ${XAPIAN_LIBS} ${SQLITE_LIBS} ${MOZILLA_XPCOM_LIBS}
+
+# Common targets
+
+all : targets
+
+dirs :
+	@mkdir -p ${OBJ_DIR} ${LIB_DIR} ${BIN_DIR}
+
+${OBJ_DIR}/%.o : %.cpp
+	${CXX} -c $< -o $@ ${CXXFLAGS}
+
+${OBJ_DIR}/%.o : %.cc
+	${CXX} -c $< -o $@ ${CXXFLAGS}
+


Property changes on: trunk/variables.mk
___________________________________________________________________
Name: svn:executable
   + 



From fabricecolin at berlios.de  Fri Dec  9 15:48:34 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 9 Dec 2005 15:48:34 +0100
Subject: [Pinot-svn] r2 - /
Message-ID: <200512091448.jB9EmYZe018194@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-09 15:48:00 +0100 (Fri, 09 Dec 2005)
New Revision: 2

Added:
   tags/
Log:
Creating the tags directory.




From fabricecolin at berlios.de  Fri Dec  9 15:50:07 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 9 Dec 2005 15:50:07 +0100
Subject: [Pinot-svn] r3 - tags
Message-ID: <200512091450.jB9Eo7gD018964@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-09 15:49:20 +0100 (Fri, 09 Dec 2005)
New Revision: 3

Added:
   tags/version_0_3_0/
Log:
Tagging v0.30.


Copied: tags/version_0_3_0 (from rev 2, trunk)



From fabricecolin at berlios.de  Mon Dec 12 17:16:38 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Mon, 12 Dec 2005 17:16:38 +0100
Subject: [Pinot-svn] r4 - trunk/Collect
Message-ID: <200512121616.jBCGGcFj031248@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-12 17:16:37 +0100 (Mon, 12 Dec 2005)
New Revision: 4

Modified:
   trunk/Collect/NeonDownloader.cpp
Log:
Don't return a document if an error occured.


Modified: trunk/Collect/NeonDownloader.cpp
===================================================================
--- trunk/Collect/NeonDownloader.cpp	2005-12-09 14:49:20 UTC (rev 3)
+++ trunk/Collect/NeonDownloader.cpp	2005-12-12 16:16:37 UTC (rev 4)
@@ -146,6 +146,7 @@
 	string url = Url::escapeUrl(docInfo.getLocation());
 	char *content = NULL;
 	size_t contentLen = 0;
+	int statusCode = 200;
 	unsigned int redirectionsCount = 0;
 
 	if (url.empty() == true)
@@ -227,7 +228,6 @@
 		{
 			ssize_t bytesRead = 0;
 			char buffer[1024];
-			int statusCode = 0;
 
 			// Get the status
 			const ne_status *pStatus = ne_get_status(m_pRequest);
@@ -238,6 +238,11 @@
 				cout << "NeonDownloader::retrieveUrl: status is " << statusCode << endl;
 #endif
 			}
+			else
+			{
+				// Assume all is well
+				statusCode = 200;
+			}
 
 			// Read the content
 			while ((bytesRead = ne_read_response_block(m_pRequest, buffer, 1024)) > 0)
@@ -342,22 +347,25 @@
 	if ((content != NULL) &&
 		(contentLen > 0))
 	{
-		// Is it an html type ?
-		if (g_contentTypeHeaderValue.find("htm") != string::npos)
+		if (statusCode < 400)
 		{
-			urlDocument = new HtmlDocument(docInfo.getTitle(), url,
-				g_contentTypeHeaderValue, docInfo.getLanguage());
-		}
-		else
-		{
-			urlDocument = new Document(docInfo.getTitle(), url,
-				g_contentTypeHeaderValue, docInfo.getLanguage());
-		}
-		// ...and copy the content into it
-		urlDocument->setData(content, contentLen);
+			// Is it an html type ?
+			if (g_contentTypeHeaderValue.find("htm") != string::npos)
+			{
+				urlDocument = new HtmlDocument(docInfo.getTitle(), url,
+					g_contentTypeHeaderValue, docInfo.getLanguage());
+			}
+			else
+			{
+				urlDocument = new Document(docInfo.getTitle(), url,
+					g_contentTypeHeaderValue, docInfo.getLanguage());
+			}
+			// ...and copy the content into it
+			urlDocument->setData(content, contentLen);
 #ifdef DEBUG
-		cout << "NeonDownloader::retrieveUrl: document size is " << contentLen << endl;
+			cout << "NeonDownloader::retrieveUrl: document size is " << contentLen << endl;
 #endif
+		}
 		free(content);
 	}
 



From fabricecolin at berlios.de  Mon Dec 12 17:20:24 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Mon, 12 Dec 2005 17:20:24 +0100
Subject: [Pinot-svn] r5 - trunk/UI/GTK2/src
Message-ID: <200512121620.jBCGKOPL031916@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-12 17:20:24 +0100 (Mon, 12 Dec 2005)
New Revision: 5

Modified:
   trunk/UI/GTK2/src/mainWindow.cc
Log:
Always check that IndexTree::getSelection() actually returns something.


Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-12 16:16:37 UTC (rev 4)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-12 16:20:24 UTC (rev 5)
@@ -1385,13 +1385,13 @@
 	}
 	else if (m_pResultsTree->is_focus() == true)
 	{
+		vector<Result> resultsList;
 		bool firstItem = true;
 
 #ifdef DEBUG
 		cout << "mainWindow::on_copy_activate: results tree" << endl;
 #endif
 		// Get the current results selection
-		vector<Result> resultsList;
 		m_pResultsTree->getSelection(resultsList);
 	
 		for (vector<Result>::const_iterator resultIter = resultsList.begin();
@@ -1409,13 +1409,13 @@
 	}
 	else if (m_pIndexTree->is_focus() == true)
 	{
+		vector<IndexedDocument> documentsList;
 		bool firstItem = true;
 
 #ifdef DEBUG
 		cout << "mainWindow::on_copy_activate: index tree" << endl;
 #endif
 		// Get the current documents selection
-		vector<IndexedDocument> documentsList;
 		m_pIndexTree->getSelection(documentsList);
 	
 		for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
@@ -1634,6 +1634,8 @@
 //
 void mainWindow::on_refreshindex_activate()
 {
+	vector<IndexedDocument> documentsList;
+
 	// Make sure this has been configured
 	if (m_settings.m_indexLocation.empty() == true)
 	{
@@ -1642,8 +1644,12 @@
 	}
 
 	// Get the current documents selection
-	vector<IndexedDocument> documentsList;
-	m_pIndexTree->getSelection(documentsList);
+	if ((m_pIndexTree->getSelection(documentsList) == false) ||
+		(documentsList.empty() == true))
+	{
+		// No selection
+		return;
+	}
 
 	for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
 		docIter != documentsList.end(); ++docIter)
@@ -1700,7 +1706,12 @@
 	}
 
 	// Get the current documents selection
-	m_pIndexTree->getSelection(documentsList);
+	if ((m_pIndexTree->getSelection(documentsList) == false) ||
+		(documentsList.empty() == true))
+	{
+		// No selection
+		return;
+	}
 
 	// If there's only one document selected, get its labels
 	if (documentsList.size() == 1)
@@ -1802,11 +1813,12 @@
 //
 void mainWindow::on_unindex_activate()
 {
+	vector<IndexedDocument> documentsList;
 	ustring boxTitle = _("Delete this document from the index ?");
 
 	// Get the current documents selection
-	vector<IndexedDocument> documentsList;
-	if (m_pIndexTree->getSelection(documentsList) == false)
+	if ((m_pIndexTree->getSelection(documentsList) == false) ||
+		(documentsList.empty() == true))
 	{
 		return;
 	}



From fabricecolin at berlios.de  Mon Dec 12 17:21:44 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Mon, 12 Dec 2005 17:21:44 +0100
Subject: [Pinot-svn] r6 - trunk/UI/GTK2/src
Message-ID: <200512121621.jBCGLiCW032167@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-12 17:21:44 +0100 (Mon, 12 Dec 2005)
New Revision: 6

Modified:
   trunk/UI/GTK2/src/WorkerThreads.cpp
Log:
Check select() return value and break on errors !


Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-12 16:20:24 UTC (rev 5)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-12 16:21:44 UTC (rev 6)
@@ -1072,9 +1072,15 @@
 		while (m_done == false)
 		{
 			int fdCount = select(fd + 1, &listenSet, NULL, NULL, NULL);
-			if ((fdCount > 0) &&
-				(FD_ISSET(fd, &listenSet)))
+			if (fdCount < 0)
 			{
+#ifdef DEBUG
+				perror("ListenerThread::do_listening: select() failed");
+#endif
+				break;
+			}
+			else if (FD_ISSET(fd, &listenSet))
+			{
 				string xmlMsg;
 				char buffer[1024];
 
@@ -1247,10 +1253,16 @@
 		selectTimeout.tv_usec = 0;
 
 		int fdCount = select(fd + 1, &listenSet, NULL, NULL, &selectTimeout);
-		if ((fdCount > 0) &&
-			(FD_ISSET(fd, &listenSet)))
+		if (fdCount < 0)
 		{
 #ifdef DEBUG
+			perror("MonitorThread::do_monitoring: select() failed");
+#endif
+			break;
+		}
+		else if (FD_ISSET(fd, &listenSet))
+		{
+#ifdef DEBUG
 			cout << "MonitorThread::do_monitoring: select() returned" << endl;
 #endif
 			// There might be more than one event waiting...



From fabricecolin at berlios.de  Tue Dec 13 13:34:55 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Tue, 13 Dec 2005 13:34:55 +0100
Subject: [Pinot-svn] r7 - trunk/UI/GTK2/src
Message-ID: <200512131234.jBDCYtFJ021238@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-13 13:34:52 +0100 (Tue, 13 Dec 2005)
New Revision: 7

Modified:
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/mainWindow.hh
Log:
When pasting into the stored queries tree, pop up a queryDialog.


Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-12 16:21:44 UTC (rev 6)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-13 12:34:52 UTC (rev 7)
@@ -1465,21 +1465,7 @@
 		// FIXME: look for \n as query fields separators ?
 		QueryProperties queryProps = QueryProperties(locale_from_utf8(clipText),
 			"", "", "", "");
-		string summary = queryProps.toString();
-
-		// Add a new row to the query tree
-		TreeModel::iterator iter = m_refQueryTree->append();
-		TreeModel::Row row = *iter;
-		row[m_queryColumns.m_name] = clipText;
-		if (summary.empty() == false)
-		{
-			row[m_queryColumns.m_summary] = to_utf8(summary);
-		}
-		else
-		{
-			row[m_queryColumns.m_summary] = _("<undefined>");
-		}
-		row[m_queryColumns.m_properties] = queryProps;
+		edit_query(queryProps, true);
 	}
 	else
 	{
@@ -2021,39 +2007,7 @@
 {
 	QueryProperties queryProps = QueryProperties("", "", "", "", "");
 
-	// Start with editing the new query's properties
-	queryDialog queryBox(queryProps);
-	queryBox.show();
-	if (queryBox.run() == RESPONSE_OK)
-	{
-		// Is the name okay ?
-		if (queryBox.badName() == true)
-		{
-			ustring statusText = _("Query name");
-			statusText += " ";
-			statusText += queryProps.getName();
-			statusText += " ";
-			statusText +=  _("is already in use");
-
-			// Tell user name is bad
-			set_status(statusText);
-			return;
-		}
-
-		// Add the new query
-		if (m_settings.addQuery(queryProps) == false)
-		{
-			ustring statusText = _("Couldn't add query");
-			statusText += " ";
-			statusText += queryProps.getName();
-
-			set_status(statusText);
-			return;
-		}
-
-		populate_queryTreeview();
-		set_status(_("Added new query"));
-	}
+	edit_query(queryProps, true);
 }
 
 //
@@ -2070,57 +2024,9 @@
 		cout << "mainWindow::on_editQueryButton_clicked: selected " << row[m_queryColumns.m_name] << endl;
 #endif
 
-		// Backup the current name
-		ustring queryName = row[m_queryColumns.m_name];
-
 		// Edit this query's properties
 		QueryProperties queryProps = row[m_queryColumns.m_properties];
-		queryDialog queryBox(queryProps);
-		queryBox.show();
-		if (queryBox.run() != RESPONSE_OK)
-		{
-			// Nothing to do
-			return;
-		}
-
-		// Is the name okay ?
-		if (queryBox.badName() == true)
-		{
-			ustring statusText = _("Query name");
-			statusText += " ";
-			statusText += queryProps.getName();
-			statusText += " ";
-			statusText +=  _("is already in use");
-
-			// Tell user name is bad
-			set_status(statusText);
-			return;
-		}
-
-		// Did the name change ?
-		ustring newQueryName = to_utf8(queryProps.getName());
-		if (newQueryName != queryName)
-		{
-			// Remove records from QueryHistory
-			string queryName = locale_from_utf8(row[m_queryColumns.m_name]);
-			QueryHistory history(m_settings.m_historyDatabase);
-			history.deleteItems(queryName, true);
-		}
-
-		// Update the query properties
-		if ((m_settings.removeQuery(queryName) == false) ||
-			(m_settings.addQuery(queryProps) == false))
-		{
-			ustring statusText = _("Couldn't update query");
-			statusText += " ";
-			statusText += queryName;
-
-			set_status(statusText);
-			return;
-		}
-
-		populate_queryTreeview();
-		set_status(_("Edited query"));
+		edit_query(queryProps, false);
 	}
 }
 
@@ -2378,6 +2284,87 @@
 }
 
 //
+// Edits a query
+//
+void mainWindow::edit_query(QueryProperties &queryProps, bool newQuery)
+{
+	string queryName;
+
+	if (newQuery == false)
+	{
+		// Backup the current name
+		queryName = queryProps.getName();
+	}
+
+	// Edit the query's properties
+	queryDialog queryBox(queryProps);
+	queryBox.show();
+	if (queryBox.run() != RESPONSE_OK)
+	{
+		// Nothing to do
+		return;
+	}
+
+	// Is the name okay ?
+	if (queryBox.badName() == true)
+	{
+		ustring statusText = _("Query name");
+		statusText += " ";
+		statusText += queryProps.getName();
+		statusText += " ";
+		statusText +=  _("is already in use");
+
+		// Tell user the name is bad
+		set_status(statusText);
+		return;
+	}
+
+	if (newQuery == false)
+	{
+		// Did the name change ?
+		string newQueryName = queryProps.getName();
+		if (newQueryName != queryName)
+		{
+			QueryHistory history(m_settings.m_historyDatabase);
+
+			// Remove records from QueryHistory
+			history.deleteItems(queryName, true);
+		}
+
+		// Update the query properties
+		if ((m_settings.removeQuery(queryName) == false) ||
+			(m_settings.addQuery(queryProps) == false))
+		{
+			ustring statusText = _("Couldn't update query");
+			statusText += " ";
+			statusText += queryName;
+	
+			set_status(statusText);
+			return;
+		}
+
+		set_status(_("Edited query"));
+	}
+	else
+	{
+		// Add the new query
+		if (m_settings.addQuery(queryProps) == false)
+		{
+			ustring statusText = _("Couldn't add query");
+			statusText += " ";
+			statusText += queryProps.getName();
+
+			set_status(statusText);
+			return;
+		}
+
+		set_status(_("Added new query"));
+	}
+
+	populate_queryTreeview();
+}
+
+//
 // Runs a search
 //
 void mainWindow::run_search(const QueryProperties &queryProps)
@@ -2769,6 +2756,9 @@
 //
 bool mainWindow::check_queue(void)
 {
+#ifdef DEBUG
+	cout << "mainWindow::check_queue: called" << endl;
+#endif
 	if (get_threads_count() >= m_maxThreads)
 	{
 #ifdef DEBUG

Modified: trunk/UI/GTK2/src/mainWindow.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow.hh	2005-12-12 16:21:44 UTC (rev 6)
+++ trunk/UI/GTK2/src/mainWindow.hh	2005-12-13 12:34:52 UTC (rev 7)
@@ -117,6 +117,7 @@
 	bool queue_index(const DocumentInfo &docInfo, const std::string &labelName,
 		unsigned int docId = 0);
 	bool queue_unindex(set<unsigned int> &docIdList);
+	void edit_query(QueryProperties &queryProps, bool newQuery);
 	void run_search(const QueryProperties &queryProps);
 	void browse_index(unsigned int startDoc = 0);
 	void index_document(const DocumentInfo &docInfo, const std::string &labelName,



From fabricecolin at berlios.de  Thu Dec 15 15:44:30 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Thu, 15 Dec 2005 15:44:30 +0100
Subject: [Pinot-svn] r8 - in trunk: Index SQL Search Search/Google Search/ObjectsSearch
Message-ID: <200512151444.jBFEiUkt032368@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-15 15:44:29 +0100 (Thu, 15 Dec 2005)
New Revision: 8

Modified:
   trunk/Index/IndexInterface.h
   trunk/Index/XapianIndex.cpp
   trunk/Index/XapianIndex.h
   trunk/Index/indextest.cpp
   trunk/SQL/Makefile
   trunk/Search/Google/GoogleAPIEngine.cpp
   trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.cpp
   trunk/Search/PluginWebEngine.cpp
   trunk/Search/QueryProperties.cpp
   trunk/Search/QueryProperties.h
   trunk/Search/XapianEngine.cpp
Log:
First step towards rationalizing the index back-end : pushed labels into the
index so that they can be used as filters by queries.


Modified: trunk/Index/IndexInterface.h
===================================================================
--- trunk/Index/IndexInterface.h	2005-12-13 12:34:52 UTC (rev 7)
+++ trunk/Index/IndexInterface.h	2005-12-15 14:44:29 UTC (rev 8)
@@ -41,17 +41,43 @@
 		virtual std::string getLocation(void) const = 0;
 
 		/// Indexes the given data.
-		virtual bool indexDocument(Tokenizer &tokens, unsigned int &docId) = 0;
+		virtual bool indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
+			unsigned int &docId) = 0;
 
-		/// Updates the given document; true if success.
+		/// Returns a document's properties.
+		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const = 0;
+
+		/// Returns a document's labels.
+		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const = 0;
+
+		/// Returns documents that have a label.
+		virtual bool getDocumentsWithLabel(const std::string &name, std::set<unsigned int> &docIds) const = 0;
+
+		/// Updates the given document.
 		virtual bool updateDocument(unsigned int docId, Tokenizer &tokens) = 0;
 
-		/// Returns the ID of the given document.
-		virtual unsigned int hasDocument(const DocumentInfo &docInfo) const = 0;
+		/// Updates a document's properties.
+		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo) = 0;
 
-		/// Unindexes the given document; true if success.
+		/// Sets a document's labels.
+		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
+			bool resetLabels = true) = 0;
+
+		/// Checks whether the given URL is in the index.
+		virtual unsigned int hasDocument(const std::string &url) const = 0;
+
+		/// Unindexes the given document.
 		virtual bool unindexDocument(unsigned int docId) = 0;
 
+		/// Unindexes documents with the given label.
+		virtual bool unindexDocuments(const std::string &labelName) = 0;
+
+		/// Renames a label.
+		virtual bool renameLabel(const std::string &name, const std::string &newName) = 0;
+
+		/// Deletes all references to a label.
+		virtual bool deleteLabel(const std::string &name) = 0;
+
 		/// Flushes recent changes to the disk.
 		virtual bool flush(void) = 0;
 
@@ -63,12 +89,6 @@
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0,
 			bool sortByDate = false) const = 0;
 
-		/// Returns a document's properties.
-		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const = 0;
-
-		/// Updates a document's properties.
-		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo) = 0;
-
 	protected:
 		StemmingMode m_stemMode;
 		bool m_goodIndex;

Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2005-12-13 12:34:52 UTC (rev 7)
+++ trunk/Index/XapianIndex.cpp	2005-12-15 14:44:29 UTC (rev 8)
@@ -67,8 +67,8 @@
 	}
 }
 
-bool XapianIndex::addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,
-	Xapian::termcount &termPos, const string &prefix, StemmingMode mode) const
+void XapianIndex::addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,
+	const string &prefix, Xapian::termcount &termPos, StemmingMode mode) const
 {
 	Xapian::Stem *pStemmer = NULL;
 	string term;
@@ -86,34 +86,30 @@
 		{
 			continue;
 		}
-
 		// Lower case the term
 		term = StringManip::toLowerCase(term);
+
 		// Stem the term ?
 		if ((mode == STORE_UNSTEM) ||
 			(pStemmer == NULL))
 		{
-			// Add the term to the document
-			doc.add_posting(prefix + term, termPos);
+			doc.add_posting(prefix + term,  termPos++);
 		}
 		else if (mode == STORE_STEM)
 		{
 			string stemmedTerm = pStemmer->stem_word(term);
 
-			// Add the stemmed term to the document
-			doc.add_posting(prefix + stemmedTerm, termPos);
+			doc.add_posting(prefix + stemmedTerm,  termPos++);
 		}
 		else if (mode == STORE_BOTH)
 		{
 			string stemmedTerm = pStemmer->stem_word(term);
 
 			// Add both
-			doc.add_posting(prefix + term, termPos);
-			doc.add_posting(prefix + stemmedTerm, termPos);
+			doc.add_posting(prefix + term,  termPos);
+			// ...at the same position
+			doc.add_posting(prefix + stemmedTerm,  termPos++);
 		}
-
-		// Next
-		termPos++;
 	}
 #ifdef DEBUG
 	cout << "XapianIndex::addTermsToDocument: added " << termPos << " terms" << endl;
@@ -123,16 +119,13 @@
 	{
 		delete pStemmer;
 	}
-
-	return true;
 }
 
 bool XapianIndex::prepareDocument(const DocumentInfo &info, Xapian::Document &doc,
 	Xapian::termcount &termPos, const std::string &summary) const
 {
 	// Add a magic term :-)
-	doc.add_posting(MAGIC_TERM, termPos);
-	termPos++;
+	doc.add_posting(MAGIC_TERM, termPos++);
 
 	// Index the title with and without prefix T
 	string title = info.getTitle();
@@ -141,9 +134,9 @@
 		Document titleDoc;
 		titleDoc.setData(title.c_str(), title.length());
 		Tokenizer titleTokens(&titleDoc);
-		termPos = addTermsToDocument(titleTokens, doc, termPos, "T", STORE_UNSTEM);
+		addTermsToDocument(titleTokens, doc, "T", termPos, STORE_UNSTEM);
 		titleTokens.rewind();
-		termPos = addTermsToDocument(titleTokens, doc, termPos, "", m_stemMode);
+		addTermsToDocument(titleTokens, doc, "", termPos, m_stemMode);
 	}
 
 	// Index the full URL with prefix U
@@ -158,12 +151,12 @@
 
 	// ...the host name with prefix H
 	string hostName = urlObj.getHost();
-	doc.add_posting(string("H") + StringManip::toLowerCase(hostName), termPos++);
+	doc.add_term(string("H") + StringManip::toLowerCase(hostName));
 	// ...and the file name with prefix F
 	string fileName = urlObj.getFile();
-	doc.add_posting(string("F") + StringManip::toLowerCase(fileName), termPos++);
+	doc.add_term(string("F") + StringManip::toLowerCase(fileName));
 	// Finally, add the language with prefix L
-	doc.add_posting(string("L") + StringManip::toLowerCase(m_stemLanguage), termPos++);
+	doc.add_term(string("L") + StringManip::toLowerCase(m_stemLanguage));
 
 	setDocumentData(doc, info, summary, m_stemLanguage);
 
@@ -278,7 +271,8 @@
 }
 
 /// Indexes the given data.
-bool XapianIndex::indexDocument(Tokenizer &tokens, unsigned int &docId)
+bool XapianIndex::indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
+			unsigned int &docId)
 {
 	unsigned int dataLength = 0;
 	bool indexed = false;
@@ -326,7 +320,13 @@
 		Xapian::termcount termPos = 0;
 
 		// Add the tokenizer's terms to the Xapian document
-		termPos = addTermsToDocument(tokens, doc, termPos, "", m_stemMode);
+		addTermsToDocument(tokens, doc, "", termPos, m_stemMode);
+		// Add labels
+		for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
+			++labelIter)
+		{
+			doc.add_term(string("C") + *labelIter);
+		}
 		if (prepareDocument(docInfo, doc, termPos, summary) == true)
 		{
 			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
@@ -353,6 +353,105 @@
 	return indexed;
 }
 
+/// Returns a document's properties.
+bool XapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
+{
+	if (m_pHistory == NULL)
+	{
+		return false;
+	}
+
+	return m_pHistory->getItem(docId, docInfo);
+}
+
+/// Returns a document's labels.
+bool XapianIndex::getDocumentLabels(unsigned int docId, set<string> &labels) const
+{
+	bool gotLabels = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	labels.clear();
+	try
+	{
+		Xapian::Database *pIndex = pDatabase->readLock();
+		if (pIndex != NULL)
+		{
+			for (Xapian::TermIterator termIter = pIndex->termlist_begin(docId);
+				termIter != pIndex->termlist_end(docId); ++termIter)
+			{
+				// Is this a label ?
+				if ((*termIter)[0] == 'C')
+				{
+					labels.insert((*termIter).substr(1));
+				}
+			}
+			gotLabels = true;
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't get document's labels: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't get document's labels, unknown exception occured" << endl;
+	}
+
+	return gotLabels;
+}
+
+/// Returns documents that have a label.
+bool XapianIndex::getDocumentsWithLabel(const string &name, set<unsigned int> &docIds) const
+{
+	bool lookedForLabel = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	docIds.clear();
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			string term("C");
+
+			// Get documents that have this label
+			term += name;
+			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
+				postingIter != pIndex->postlist_end(term); ++postingIter)
+			{
+				Xapian::docid docId = *postingIter;
+
+				docIds.insert(docId);
+			}
+			lookedForLabel = true;
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't get documents: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't get documents, unknown exception occured" << endl;
+	}
+
+	return lookedForLabel;
+}
+
 /// Updates the given document; true if success.
 bool XapianIndex::updateDocument(unsigned int docId, Tokenizer &tokens)
 {
@@ -388,11 +487,22 @@
 
 	try
 	{
+		set<string> labels;
 		Xapian::Document doc;
 		Xapian::termcount termPos = 0;
 
 		// Add the tokenizer's terms to the document
-		termPos = addTermsToDocument(tokens, doc, termPos, "", m_stemMode);
+		 addTermsToDocument(tokens, doc, "", termPos, m_stemMode);
+		// Get the document's labels
+		if (getDocumentLabels(docId, labels) == true)
+		{
+			// Add labels
+			for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
+				++labelIter)
+			{
+				doc.add_term(string("C") + *labelIter);
+			}
+		}
 		if (prepareDocument(docInfo, doc, termPos, summary) == true)
 		{
 			Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
@@ -418,16 +528,126 @@
 	return updated;
 }
 
-/// Returns the ID of the given document.
-unsigned int XapianIndex::hasDocument(const DocumentInfo &docInfo) const
+/// Updates a document's properties.
+bool XapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo)
 {
+	bool updated = false;
+
+	if (docId == 0)
+	{
+		return false;
+	}
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			Xapian::Document doc = pIndex->get_document(docId);
+
+			// Get the current document data
+			string record = doc.get_data();
+			string extract = StringManip::extractField(record, "sample=", "\n");
+			string language = StringManip::extractField(record, "language=", "\n");
+
+			// Update the document data with the new extract
+			setDocumentData(doc, docInfo, extract, language);
+			// Update the document
+			if (m_pHistory->updateItem(docId, docInfo) == true)
+			{
+				pIndex->replace_document(docId, doc);
+				updated = true;
+			}
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't update document: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't update document, unknown exception occured" << endl;
+	}
+
+	return updated;
+}
+
+/// Sets a document's labels.
+bool XapianIndex::setDocumentLabels(unsigned int docId, const set<string> &labels,
+	bool resetLabels)
+{
+	bool updatedLabels = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			Xapian::Document doc = pIndex->get_document(docId);
+
+			// Reset existing labels ?
+			if (resetLabels == true)
+			{
+				for (Xapian::TermIterator termIter = doc.termlist_begin();
+					termIter != doc.termlist_end(); ++termIter)
+				{
+					// Is this a label ?
+					if ((*termIter)[0] == 'C')
+					{
+						doc.remove_term(*termIter);
+					}
+				}
+			}
+
+			// Set new labels
+			for (set<string>::const_iterator labelIter = labels.begin(); labelIter != labels.end();
+				++labelIter)
+			{
+				doc.add_term(string("C") + *labelIter);
+			}
+
+			pIndex->replace_document(docId, doc);
+			updatedLabels = true;
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't update document's labels: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't update document's labels, unknown exception occured" << endl;
+	}
+
+	return updatedLabels;
+}
+
+/// Checks whether the given URL is in the index.
+unsigned int XapianIndex::hasDocument(const string &url) const
+{
 	if (m_pHistory == NULL)
 	{
 		return 0;
 	}
 
 	// Is this URL in the history file ?
-	return m_pHistory->hasURL(docInfo.getLocation());
+	return m_pHistory->hasURL(url);
 }
 
 /// Unindexes the given document; true if success.
@@ -473,13 +693,19 @@
 	return unindexed;
 }
 
-/// Flushes recent changes to the disk.
-bool XapianIndex::flush(void)
+/// Unindexes documents with the given label.
+bool XapianIndex::unindexDocuments(const string &labelName)
 {
-	bool flushed = false;
+	bool unindexed = false;
 
+	if (labelName.empty() == true)
+	{
+		return false;
+	}
+
 	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if (pDatabase == NULL)
+	if ((pDatabase == NULL) ||
+		(m_pHistory == NULL))
 	{
 		cerr << "Bad index " << m_databaseName << endl;
 		return false;
@@ -487,135 +713,213 @@
 
 	try
 	{
-#ifdef DEBUG
-		cout << "XapianIndex::flush: called" << endl;
-#endif
 		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
 		if (pIndex != NULL)
 		{
-			pIndex->flush();
-			flushed = true;
+			string term("C");
+
+			// Delete documents from the index
+			term += labelName;
+			pIndex->delete_document(term);
+			// FIXME: remove entries from the history file
+			//m_pHistory->deleteItem(docId);
+			unindexed = true;
 		}
 		pDatabase->unlock();
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't flush database: " << error.get_msg() << endl;
+		cerr << "Couldn't unindex documents: " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
-		cerr << "Couldn't flush database, unknown exception occured" << endl;
+		cerr << "Couldn't unindex documents, unknown exception occured" << endl;
 	}
 
-	return flushed;
+	return unindexed;
 }
 
-/// Returns the number of documents.
-unsigned int XapianIndex::getDocumentsCount(void) const
+/// Renames a label.
+bool XapianIndex::renameLabel(const string &name, const string &newName)
 {
-	unsigned int docCount = 0;
+	bool renamedLabel = false;
 
 	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
 	if (pDatabase == NULL)
 	{
 		cerr << "Bad index " << m_databaseName << endl;
-		return 0;
+		return false;
 	}
 
 	try
 	{
-		Xapian::Database *pIndex = pDatabase->readLock();
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
 		if (pIndex != NULL)
 		{
-			docCount = pIndex->get_doccount();
+			string term("C");
+
+			// Get documents that have this label
+			term += name;
+			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
+				postingIter != pIndex->postlist_end(term); ++postingIter)
+			{
+				Xapian::docid docId = *postingIter;
+
+				// Get the document
+				Xapian::Document doc = pIndex->get_document(docId);
+				// Remove the term
+				doc.remove_term(term);
+				// ...add the new one
+				doc.add_term(string("C") + newName);
+				// ...and update the document
+				pIndex->replace_document(docId, doc);
+			}
+
+			renamedLabel = true;
 		}
 		pDatabase->unlock();
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't count documents: " << error.get_msg() << endl;
+		cerr << "Couldn't delete label: " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
-		cerr << "Couldn't count documents, unknown exception occured" << endl;
+		cerr << "Couldn't delete label, unknown exception occured" << endl;
 	}
 
-	return docCount;
+	return renamedLabel;
 }
 
-/// Returns a list of document IDs.
-unsigned int XapianIndex::getDocumentIDs(set<unsigned int> &docIDList,
-	unsigned int maxDocsCount, unsigned int startDoc, bool sortByDate) const
+/// Deletes all references to a label.
+bool XapianIndex::deleteLabel(const string &name)
 {
-	if (m_pHistory == NULL)
+	bool deletedLabel = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
 	{
-		return 0;
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
 	}
 
-	docIDList.clear();
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			string term("C");
 
-	return m_pHistory->listItems(docIDList, maxDocsCount, startDoc, sortByDate);
-}
+			// Get documents that have this label
+			term += name;
+			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
+				postingIter != pIndex->postlist_end(term); ++postingIter)
+			{
+				Xapian::docid docId = *postingIter;
 
-/// Returns a document's properties.
-bool XapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
-{
-	if (m_pHistory == NULL)
+				// Get the document
+				Xapian::Document doc = pIndex->get_document(docId);
+				// Remove the term
+				doc.remove_term(term);
+				// ...and update the document
+				pIndex->replace_document(docId, doc);
+			}
+			deletedLabel = true;
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
 	{
-		return false;
+		cerr << "Couldn't delete label: " << error.get_msg() << endl;
 	}
+	catch (...)
+	{
+		cerr << "Couldn't delete label, unknown exception occured" << endl;
+	}
 
-	return m_pHistory->getItem(docId, docInfo);
+	return deletedLabel;
 }
 
-/// Updates a document's properties.
-bool XapianIndex::updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo)
+/// Flushes recent changes to the disk.
+bool XapianIndex::flush(void)
 {
-	bool updated = false;
+	bool flushed = false;
 
-	if (docId == 0)
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
 	{
+		cerr << "Bad index " << m_databaseName << endl;
 		return false;
 	}
 
+	try
+	{
+#ifdef DEBUG
+		cout << "XapianIndex::flush: called" << endl;
+#endif
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			pIndex->flush();
+			flushed = true;
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't flush database: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't flush database, unknown exception occured" << endl;
+	}
+
+	return flushed;
+}
+
+/// Returns the number of documents.
+unsigned int XapianIndex::getDocumentsCount(void) const
+{
+	unsigned int docCount = 0;
+
 	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
 	if (pDatabase == NULL)
 	{
 		cerr << "Bad index " << m_databaseName << endl;
-		return false;
+		return 0;
 	}
 
 	try
 	{
-		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		Xapian::Database *pIndex = pDatabase->readLock();
 		if (pIndex != NULL)
 		{
-			Xapian::Document doc = pIndex->get_document(docId);
-
-			// Get the current document data
-			string record = doc.get_data();
-			string extract = StringManip::extractField(record, "sample=", "\n");
-			string language = StringManip::extractField(record, "language=", "\n");
-
-			// Update the document data with the new extract
-			setDocumentData(doc, docInfo, extract, language);
-			// Update the document
-			if (m_pHistory->updateItem(docId, docInfo) == true)
-			{
-				pIndex->replace_document(docId, doc);
-				updated = true;
-			}
+			docCount = pIndex->get_doccount();
 		}
 		pDatabase->unlock();
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't update document: " << error.get_msg() << endl;
+		cerr << "Couldn't count documents: " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
-		cerr << "Couldn't update document, unknown exception occured" << endl;
+		cerr << "Couldn't count documents, unknown exception occured" << endl;
 	}
 
-	return updated;
+	return docCount;
 }
+
+/// Returns a list of document IDs.
+unsigned int XapianIndex::getDocumentIDs(set<unsigned int> &docIDList,
+	unsigned int maxDocsCount, unsigned int startDoc, bool sortByDate) const
+{
+	if (m_pHistory == NULL)
+	{
+		return 0;
+	}
+
+	docIDList.clear();
+
+	return m_pHistory->listItems(docIDList, maxDocsCount, startDoc, sortByDate);
+}

Modified: trunk/Index/XapianIndex.h
===================================================================
--- trunk/Index/XapianIndex.h	2005-12-13 12:34:52 UTC (rev 7)
+++ trunk/Index/XapianIndex.h	2005-12-15 14:44:29 UTC (rev 8)
@@ -36,17 +36,43 @@
 		virtual std::string getLocation(void) const;
 
 		/// Indexes the given data.
-		virtual bool indexDocument(Tokenizer &tokens, unsigned int &docId);
+		virtual bool indexDocument(Tokenizer &tokens, const std::set<std::string> &labels,
+			unsigned int &docId);
 
-		/// Updates the given document; true if success.
+		/// Returns a document's properties.
+		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const;
+
+		/// Returns a document's labels.
+		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const;
+
+		/// Returns documents that have a label.
+		virtual bool getDocumentsWithLabel(const std::string &name, std::set<unsigned int> &docIds) const;
+
+		/// Updates the given document.
 		virtual bool updateDocument(unsigned int docId, Tokenizer &tokens);
 
-		/// Returns the ID of the given document.
-		virtual unsigned int hasDocument(const DocumentInfo &docInfo) const;
+		/// Updates a document's properties.
+		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo);
 
-		/// Unindexes the given document; true if success.
+		/// Sets a document's labels.
+		virtual bool setDocumentLabels(unsigned int docId, const std::set<std::string> &labels,
+			bool resetLabels = true);
+
+		/// Checks whether the given URL is in the index.
+		virtual unsigned int hasDocument(const std::string &url) const;
+
+		/// Unindexes the given document.
 		virtual bool unindexDocument(unsigned int docId);
 
+		/// Unindexes documents with the given label.
+		virtual bool unindexDocuments(const std::string &labelName);
+
+		/// Renames a label.
+		virtual bool renameLabel(const std::string &name, const std::string &newName);
+
+		/// Deletes all references to a label.
+		virtual bool deleteLabel(const std::string &name);
+
 		/// Flushes recent changes to the disk.
 		virtual bool flush(void);
 
@@ -58,12 +84,6 @@
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0,
 			bool sortByDate = false) const;
 
-		/// Returns a document's properties.
-		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const;
-
-		/// Updates a document's properties.
-		virtual bool updateDocumentInfo(unsigned int docId, const DocumentInfo &docInfo);
-
 	protected:
 		static const unsigned int m_maxTermLength;
 		static const std::string MAGIC_TERM;
@@ -71,8 +91,8 @@
 		IndexHistory *m_pHistory;
 		std::string m_stemLanguage;
 
-		bool addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,
-			Xapian::termcount &termPos, const std::string &prefix, StemmingMode mode) const;
+		void addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,
+			const std::string &prefix, Xapian::termcount &termPos, StemmingMode mode) const;
 
 		bool prepareDocument(const DocumentInfo &info, Xapian::Document &doc,
 			Xapian::termcount &termPos, const std::string &summary) const;
@@ -80,8 +100,8 @@
 		std::string scanDocument(const char *pData, unsigned int dataLength,
 			DocumentInfo &info);
 
-		void setDocumentData(Xapian::Document &doc, const DocumentInfo &info, const string &extract,
-			const string &language) const;
+		void setDocumentData(Xapian::Document &doc, const DocumentInfo &info,
+			const std::string &extract, const std::string &language) const;
 
 	private:
 		XapianIndex(const XapianIndex &other);

Modified: trunk/Index/indextest.cpp
===================================================================
--- trunk/Index/indextest.cpp	2005-12-13 12:34:52 UTC (rev 7)
+++ trunk/Index/indextest.cpp	2005-12-15 14:44:29 UTC (rev 8)
@@ -20,6 +20,8 @@
 #include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
+#include <string>
+#include <set>
 #include <iostream>
 
 #include "Document.h"
@@ -84,6 +86,7 @@
 		}
 		else
 		{
+			set<string> labels;
 			unsigned int docId = 0;
 
 			Tokenizer *pTokens = TokenizerFactory::getTokenizer(argv[3], &doc);
@@ -96,7 +99,7 @@
 			// Ignore index type, use a XapianIndex
 			XapianIndex index(argv[2]);
 			index.setStemmingMode(IndexInterface::STORE_BOTH);
-			if (index.indexDocument(*pTokens, docId) == false)
+			if (index.indexDocument(*pTokens, labels, docId) == false)
 			{
 				cerr << "Couldn't index " << argv[3] << " !" << endl;
 			}

Modified: trunk/SQL/Makefile
===================================================================
--- trunk/SQL/Makefile	2005-12-13 12:34:52 UTC (rev 7)
+++ trunk/SQL/Makefile	2005-12-15 14:44:29 UTC (rev 8)
@@ -3,7 +3,7 @@
 include ${ROOT_DIR}/variables.mk
 
 SQL_SRCS = SQLiteBase.cpp ActionHistory.cpp IndexHistory.cpp \
-	QueryHistory.cpp ViewHistory.cpp LabelManager.cpp
+	QueryHistory.cpp ViewHistory.cpp
 SQL_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${SQL_SRCS})
 SQL_TEST = ${BIN_DIR}/historytest
 

Modified: trunk/Search/Google/GoogleAPIEngine.cpp
===================================================================
--- trunk/Search/Google/GoogleAPIEngine.cpp	2005-12-13 12:34:52 UTC (rev 7)
+++ trunk/Search/Google/GoogleAPIEngine.cpp	2005-12-15 14:44:29 UTC (rev 8)
@@ -85,8 +85,8 @@
 	string andTerms = queryProps.getAndWords();
 	string phrase = queryProps.getPhrase();
 
-	setHostNameFilter(queryProps.getHostNameFilter());
-	setFileNameFilter(queryProps.getFileNameFilter());
+	setHostNameFilter(queryProps.getHostFilter());
+	setFileNameFilter(queryProps.getFileFilter());
 
 	if (m_key.empty() == true)
 	{

Modified: trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.cpp
===================================================================
--- trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.cpp	2005-12-13 12:34:52 UTC (rev 7)
+++ trunk/Search/ObjectsSearch/ObjectsSearchAPIEngine.cpp	2005-12-15 14:44:29 UTC (rev 8)
@@ -104,8 +104,8 @@
 /// Runs a query; true if success.
 bool ObjectsSearchAPIEngine::runQuery(QueryProperties& queryProps)
 {
-	setHostNameFilter(queryProps.getHostNameFilter());
-	setFileNameFilter(queryProps.getFileNameFilter());
+	setHostNameFilter(queryProps.getHostFilter());
+	setFileNameFilter(queryProps.getFileFilter());
 
 	// See http://www.objectssearch.com/en/help.html for a description of queries
 	string query = queryProps.getAndWords();

Modified: trunk/Search/PluginWebEngine.cpp
===================================================================
--- trunk/Search/PluginWebEngine.cpp	2005-12-13 12:34:52 UTC (rev 7)
+++ trunk/Search/PluginWebEngine.cpp	2005-12-15 14:44:29 UTC (rev 8)
@@ -505,8 +505,8 @@
 		formattedQuery += tagIter->second;
 	}
 
-	setHostNameFilter(queryProps.getHostNameFilter());
-	setFileNameFilter(queryProps.getFileNameFilter());
+	setHostNameFilter(queryProps.getHostFilter());
+	setFileNameFilter(queryProps.getFileFilter());
 
 #ifdef DEBUG
 	cout << "PluginWebEngine::runQuery: querying " << m_name << endl;

Modified: trunk/Search/QueryProperties.cpp
===================================================================
--- trunk/Search/QueryProperties.cpp	2005-12-13 12:34:52 UTC (rev 7)
+++ trunk/Search/QueryProperties.cpp	2005-12-15 14:44:29 UTC (rev 8)
@@ -43,8 +43,9 @@
 	m_anyWords(other.m_anyWords),
 	m_notWords(other.m_notWords),
 	m_language(other.m_language),
-	m_hostName(other.m_hostName),
-	m_fileName(other.m_fileName),
+	m_hostFilter(other.m_hostFilter),
+	m_fileFilter(other.m_fileFilter),
+	m_labelFilter(other.m_labelFilter),
 	m_resultsCount(other.m_resultsCount),
 	m_indexResults(other.m_indexResults),
 	m_labelName(other.m_labelName)
@@ -63,8 +64,9 @@
 	m_anyWords = other.m_anyWords;
 	m_notWords = other.m_notWords;
 	m_language = other.m_language;
-	m_hostName = other.m_hostName;
-	m_fileName = other.m_fileName;
+	m_hostFilter = other.m_hostFilter;
+	m_fileFilter = other.m_fileFilter;
+	m_labelFilter = other.m_labelFilter;
 	m_resultsCount = other.m_resultsCount;
 	m_indexResults = other.m_indexResults;
 	m_labelName = other.m_labelName;
@@ -164,30 +166,42 @@
 	return m_language;
 }
 
-/// Sets host name filter.
-void QueryProperties::setHostNameFilter(const string &filter)
+/// Sets host filter.
+void QueryProperties::setHostFilter(const string &filter)
 {
-	m_hostName = filter;
+	m_hostFilter = filter;
 }
 
-/// Gets host name filter.
-string QueryProperties::getHostNameFilter(void) const
+/// Gets host filter.
+string QueryProperties::getHostFilter(void) const
 {
-	return 	m_hostName;
+	return 	m_hostFilter;
 }
 
-/// Sets file name filter.
-void QueryProperties::setFileNameFilter(const string &filter)
+/// Sets file filter.
+void QueryProperties::setFileFilter(const string &filter)
 {
-	m_fileName = filter;
+	m_fileFilter = filter;
 }
 
-/// Gets file name filter.
-string QueryProperties::getFileNameFilter(void) const
+/// Gets file filter.
+string QueryProperties::getFileFilter(void) const
 {
-	return m_fileName;
+	return m_fileFilter;
 }
 
+/// Sets label filter.
+void QueryProperties::setLabelFilter(const string &filter)
+{
+	m_labelFilter = filter;
+}
+
+/// Gets label filter.
+string QueryProperties::getLabelFilter(void) const
+{
+	return m_labelFilter;
+}
+
 /// Sets the maximum number of results.
 void QueryProperties::setMaximumResultsCount(unsigned int count)
 {
@@ -286,16 +300,21 @@
 			queryString += " +L";
 			queryString += m_language;
 		}
-		if (m_hostName.empty() == false)
+		if (m_hostFilter.empty() == false)
 		{
 			queryString += " +H";
-			queryString += m_hostName;
+			queryString += m_hostFilter;
 		}
-		if (m_fileName.empty() == false)
+		if (m_fileFilter.empty() == false)
 		{
 			queryString += " +F";
-			queryString += m_fileName;
+			queryString += m_fileFilter;
 		}
+		if (m_labelFilter.empty() == false)
+		{
+			queryString += " +C";
+			queryString += m_labelFilter;
+		}
 	}
 
 	return queryString;

Modified: trunk/Search/QueryProperties.h
===================================================================
--- trunk/Search/QueryProperties.h	2005-12-13 12:34:52 UTC (rev 7)
+++ trunk/Search/QueryProperties.h	2005-12-15 14:44:29 UTC (rev 8)
@@ -65,16 +65,21 @@
 		/// Gets the query's language.
 		string getLanguage(void) const;
 
-		/// Sets host name filter.
-		void setHostNameFilter(const string &filter);
-		/// Gets host name filter.
-		string getHostNameFilter(void) const;
+		/// Sets host filter.
+		void setHostFilter(const string &filter);
+		/// Gets host filter.
+		string getHostFilter(void) const;
 
-		/// Sets file name filter.
-		void setFileNameFilter(const string &filter);
-		/// Gets file name filter.
-		string getFileNameFilter(void) const;
+		/// Sets file filter.
+		void setFileFilter(const string &filter);
+		/// Gets file filter.
+		string getFileFilter(void) const;
 
+		/// Sets label filter.
+		void setLabelFilter(const string &filter);
+		/// Gets label filter.
+		string getLabelFilter(void) const;
+
 		/// Sets the maximum number of results.
 		void setMaximumResultsCount(unsigned int count);
 		/// Gets the maximum number of results.
@@ -100,8 +105,9 @@
 		string m_anyWords;
 		string m_notWords;
 		string m_language;
-		string m_hostName;
-		string m_fileName;
+		string m_hostFilter;
+		string m_fileFilter;
+		string m_labelFilter;
 		unsigned int m_resultsCount;
 		bool m_indexResults;
 		string m_labelName;

Modified: trunk/Search/XapianEngine.cpp
===================================================================
--- trunk/Search/XapianEngine.cpp	2005-12-13 12:34:52 UTC (rev 7)
+++ trunk/Search/XapianEngine.cpp	2005-12-15 14:44:29 UTC (rev 8)
@@ -274,12 +274,12 @@
 	}
 
 	// Get the host name filter
-	if (queryProps.getHostNameFilter().empty() == false)
+	if (queryProps.getHostFilter().empty() == false)
 	{
 		vector<string> hostTerms;
 
 		term = "H";
-		term += StringManip::toLowerCase(queryProps.getHostNameFilter());
+		term += StringManip::toLowerCase(queryProps.getHostFilter());
 		hostTerms.push_back(term);
 		if (followOperators == true)
 		{
@@ -289,12 +289,12 @@
 	}
 
 	// Get the file name filter
-	if (queryProps.getFileNameFilter().empty() == false)
+	if (queryProps.getFileFilter().empty() == false)
 	{
 		vector<string> fileTerms;
 
 		term = "F";
-		term += StringManip::toLowerCase(queryProps.getFileNameFilter());
+		term += StringManip::toLowerCase(queryProps.getFileFilter());
 		fileTerms.push_back(term);
 		if (followOperators == true)
 		{
@@ -303,6 +303,21 @@
 		queryStack.push(Xapian::Query(queryOp, fileTerms.begin(), fileTerms.end()));
 	}
 
+	// Get the label name filter
+	if (queryProps.getLabelFilter().empty() == false)
+	{
+		vector<string> labelTerms;
+
+		term = "C";
+		term += queryProps.getLabelFilter();
+		labelTerms.push_back(term);
+		if (followOperators == true)
+		{
+			queryOp = Xapian::Query::OP_AND;
+		}
+		queryStack.push(Xapian::Query(queryOp, labelTerms.begin(), labelTerms.end()));
+	}
+
 	// Get the language filter
 	if (queryProps.getLanguage().empty() == false)
 	{



From fabricecolin at berlios.de  Thu Dec 15 15:46:52 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Thu, 15 Dec 2005 15:46:52 +0100
Subject: [Pinot-svn] r9 - in trunk/UI/GTK2: . src
Message-ID: <200512151446.jBFEkqI1032719@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-15 15:46:50 +0100 (Thu, 15 Dec 2005)
New Revision: 9

Modified:
   trunk/UI/GTK2/metase-gtk2.glade
   trunk/UI/GTK2/src/MonitorHandler.cpp
   trunk/UI/GTK2/src/MonitorHandler.h
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/pinot.cpp
   trunk/UI/GTK2/src/prefsDialog.cc
   trunk/UI/GTK2/src/prefsDialog.hh
   trunk/UI/GTK2/src/queryDialog.cc
   trunk/UI/GTK2/src/queryDialog.hh
   trunk/UI/GTK2/src/queryDialog_glade.cc
   trunk/UI/GTK2/src/queryDialog_glade.hh
Log:
"None of the words" is in the queries first properties tab, as it should work
with all engines. Added a label filter in Advanced. All labels operations are
handled by the index now, LabelManager is obsolete.


Modified: trunk/UI/GTK2/metase-gtk2.glade
===================================================================
--- trunk/UI/GTK2/metase-gtk2.glade	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/metase-gtk2.glade	2005-12-15 14:46:50 UTC (rev 9)
@@ -2423,7 +2423,7 @@
 		  <child>
 		    <widget class="GtkTable" id="tersmTable">
 		      <property name="visible">True</property>
-		      <property name="n_rows">5</property>
+		      <property name="n_rows">6</property>
 		      <property name="n_columns">2</property>
 		      <property name="homogeneous">False</property>
 		      <property name="row_spacing">0</property>
@@ -2469,8 +2469,8 @@
 			<packing>
 			  <property name="left_attach">1</property>
 			  <property name="right_attach">2</property>
-			  <property name="top_attach">1</property>
-			  <property name="bottom_attach">2</property>
+			  <property name="top_attach">2</property>
+			  <property name="bottom_attach">3</property>
 			  <property name="x_padding">4</property>
 			  <property name="y_padding">4</property>
 			  <property name="y_options">fill</property>
@@ -2493,8 +2493,8 @@
 			<packing>
 			  <property name="left_attach">1</property>
 			  <property name="right_attach">2</property>
-			  <property name="top_attach">2</property>
-			  <property name="bottom_attach">3</property>
+			  <property name="top_attach">3</property>
+			  <property name="bottom_attach">4</property>
 			  <property name="x_padding">4</property>
 			  <property name="y_padding">4</property>
 			  <property name="y_options">fill</property>
@@ -2517,8 +2517,8 @@
 			<packing>
 			  <property name="left_attach">1</property>
 			  <property name="right_attach">2</property>
-			  <property name="top_attach">3</property>
-			  <property name="bottom_attach">4</property>
+			  <property name="top_attach">4</property>
+			  <property name="bottom_attach">5</property>
 			  <property name="x_padding">4</property>
 			  <property name="y_padding">4</property>
 			  <property name="y_options">fill</property>
@@ -2541,8 +2541,8 @@
 			<packing>
 			  <property name="left_attach">0</property>
 			  <property name="right_attach">1</property>
-			  <property name="top_attach">4</property>
-			  <property name="bottom_attach">5</property>
+			  <property name="top_attach">5</property>
+			  <property name="bottom_attach">6</property>
 			  <property name="x_padding">4</property>
 			  <property name="y_padding">4</property>
 			  <property name="x_options">fill</property>
@@ -2579,9 +2579,9 @@
 		      </child>
 
 		      <child>
-			<widget class="GtkLabel" id="hostLabel">
+			<widget class="GtkLabel" id="fileNameLabel">
 			  <property name="visible">True</property>
-			  <property name="label" translatable="yes">Host name:</property>
+			  <property name="label" translatable="yes">File name:</property>
 			  <property name="use_underline">False</property>
 			  <property name="use_markup">False</property>
 			  <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -2599,17 +2599,17 @@
 			<packing>
 			  <property name="left_attach">0</property>
 			  <property name="right_attach">1</property>
-			  <property name="top_attach">1</property>
-			  <property name="bottom_attach">2</property>
+			  <property name="top_attach">3</property>
+			  <property name="bottom_attach">4</property>
 			  <property name="x_options">fill</property>
 			  <property name="y_options">fill</property>
 			</packing>
 		      </child>
 
 		      <child>
-			<widget class="GtkLabel" id="fileNameLabel">
+			<widget class="GtkLabel" id="resultsCountLabel">
 			  <property name="visible">True</property>
-			  <property name="label" translatable="yes">File name:</property>
+			  <property name="label" translatable="yes">Number of results:</property>
 			  <property name="use_underline">False</property>
 			  <property name="use_markup">False</property>
 			  <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -2627,6 +2627,52 @@
 			<packing>
 			  <property name="left_attach">0</property>
 			  <property name="right_attach">1</property>
+			  <property name="top_attach">4</property>
+			  <property name="bottom_attach">5</property>
+			  <property name="x_options">fill</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkComboBox" id="labelNameCombobox">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="add_tearoffs">False</property>
+			  <property name="focus_on_click">True</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">1</property>
+			  <property name="right_attach">2</property>
+			  <property name="top_attach">5</property>
+			  <property name="bottom_attach">6</property>
+			  <property name="x_padding">4</property>
+			  <property name="y_padding">4</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="hostLabel">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">Host name:</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">4</property>
+			  <property name="ypad">4</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">0</property>
+			  <property name="right_attach">1</property>
 			  <property name="top_attach">2</property>
 			  <property name="bottom_attach">3</property>
 			  <property name="x_options">fill</property>
@@ -2635,9 +2681,9 @@
 		      </child>
 
 		      <child>
-			<widget class="GtkLabel" id="resultsCountLabel">
+			<widget class="GtkLabel" id="notLabel">
 			  <property name="visible">True</property>
-			  <property name="label" translatable="yes">Number of results:</property>
+			  <property name="label" translatable="yes">None of the words:</property>
 			  <property name="use_underline">False</property>
 			  <property name="use_markup">False</property>
 			  <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -2655,25 +2701,31 @@
 			<packing>
 			  <property name="left_attach">0</property>
 			  <property name="right_attach">1</property>
-			  <property name="top_attach">3</property>
-			  <property name="bottom_attach">4</property>
+			  <property name="top_attach">1</property>
+			  <property name="bottom_attach">2</property>
 			  <property name="x_options">fill</property>
 			  <property name="y_options">fill</property>
 			</packing>
 		      </child>
 
 		      <child>
-			<widget class="GtkComboBox" id="labelCombobox">
+			<widget class="GtkEntry" id="notEntry">
 			  <property agent="glademm" name="cxx_visibility">protected</property>
 			  <property name="visible">True</property>
-			  <property name="add_tearoffs">False</property>
-			  <property name="focus_on_click">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="editable">True</property>
+			  <property name="visibility">True</property>
+			  <property name="max_length">0</property>
+			  <property name="text" translatable="yes"></property>
+			  <property name="has_frame">True</property>
+			  <property name="invisible_char">*</property>
+			  <property name="activates_default">False</property>
 			</widget>
 			<packing>
 			  <property name="left_attach">1</property>
 			  <property name="right_attach">2</property>
-			  <property name="top_attach">4</property>
-			  <property name="bottom_attach">5</property>
+			  <property name="top_attach">1</property>
+			  <property name="bottom_attach">2</property>
 			  <property name="x_padding">4</property>
 			  <property name="y_padding">4</property>
 			  <property name="y_options">fill</property>
@@ -2781,30 +2833,6 @@
 		      </child>
 
 		      <child>
-			<widget class="GtkEntry" id="notEntry">
-			  <property agent="glademm" name="cxx_visibility">protected</property>
-			  <property name="visible">True</property>
-			  <property name="can_focus">True</property>
-			  <property name="editable">True</property>
-			  <property name="visibility">True</property>
-			  <property name="max_length">0</property>
-			  <property name="text" translatable="yes"></property>
-			  <property name="has_frame">True</property>
-			  <property name="invisible_char">*</property>
-			  <property name="activates_default">False</property>
-			</widget>
-			<packing>
-			  <property name="left_attach">1</property>
-			  <property name="right_attach">2</property>
-			  <property name="top_attach">2</property>
-			  <property name="bottom_attach">3</property>
-			  <property name="x_padding">4</property>
-			  <property name="y_padding">4</property>
-			  <property name="y_options">fill</property>
-			</packing>
-		      </child>
-
-		      <child>
 			<widget class="GtkLabel" id="phraseLabel">
 			  <property name="visible">True</property>
 			  <property name="label" translatable="yes">the exact phrase:</property>
@@ -2833,9 +2861,9 @@
 		      </child>
 
 		      <child>
-			<widget class="GtkLabel" id="notLabel">
+			<widget class="GtkLabel" id="languageLabel">
 			  <property name="visible">True</property>
-			  <property name="label" translatable="yes">none of the words:</property>
+			  <property name="label" translatable="yes">the language:</property>
 			  <property name="use_underline">False</property>
 			  <property name="use_markup">False</property>
 			  <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -2861,34 +2889,6 @@
 		      </child>
 
 		      <child>
-			<widget class="GtkLabel" id="label14">
-			  <property name="visible">True</property>
-			  <property name="label" translatable="yes">the language:</property>
-			  <property name="use_underline">False</property>
-			  <property name="use_markup">False</property>
-			  <property name="justify">GTK_JUSTIFY_LEFT</property>
-			  <property name="wrap">False</property>
-			  <property name="selectable">False</property>
-			  <property name="xalign">0</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">4</property>
-			  <property name="ypad">4</property>
-			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-			  <property name="width_chars">-1</property>
-			  <property name="single_line_mode">False</property>
-			  <property name="angle">0</property>
-			</widget>
-			<packing>
-			  <property name="left_attach">0</property>
-			  <property name="right_attach">1</property>
-			  <property name="top_attach">3</property>
-			  <property name="bottom_attach">4</property>
-			  <property name="x_options">fill</property>
-			  <property name="y_options">fill</property>
-			</packing>
-		      </child>
-
-		      <child>
 			<widget class="GtkComboBox" id="languageCombobox">
 			  <property agent="glademm" name="cxx_visibility">protected</property>
 			  <property name="visible">True</property>
@@ -2898,8 +2898,8 @@
 			<packing>
 			  <property name="left_attach">1</property>
 			  <property name="right_attach">2</property>
-			  <property name="top_attach">3</property>
-			  <property name="bottom_attach">4</property>
+			  <property name="top_attach">2</property>
+			  <property name="bottom_attach">3</property>
 			  <property name="x_padding">4</property>
 			  <property name="y_padding">4</property>
 			  <property name="y_options">fill</property>
@@ -2957,6 +2957,52 @@
 			  <property name="y_options">fill</property>
 			</packing>
 		      </child>
+
+		      <child>
+			<widget class="GtkLabel" id="labelLabel">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">the label:</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">4</property>
+			  <property name="ypad">4</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">0</property>
+			  <property name="right_attach">1</property>
+			  <property name="top_attach">3</property>
+			  <property name="bottom_attach">4</property>
+			  <property name="x_options">fill</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkComboBox" id="labelFilterCombobox">
+			  <property agent="glademm" name="cxx_visibility">protected</property>
+			  <property name="visible">True</property>
+			  <property name="add_tearoffs">False</property>
+			  <property name="focus_on_click">True</property>
+			</widget>
+			<packing>
+			  <property name="left_attach">1</property>
+			  <property name="right_attach">2</property>
+			  <property name="top_attach">3</property>
+			  <property name="bottom_attach">4</property>
+			  <property name="x_padding">4</property>
+			  <property name="y_padding">4</property>
+			  <property name="y_options">fill</property>
+			</packing>
+		      </child>
 		    </widget>
 		    <packing>
 		      <property name="padding">0</property>

Modified: trunk/UI/GTK2/src/MonitorHandler.cpp
===================================================================
--- trunk/UI/GTK2/src/MonitorHandler.cpp	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/MonitorHandler.cpp	2005-12-15 14:46:50 UTC (rev 9)
@@ -112,7 +112,7 @@
 }
 
 bool MboxHandler::parseMailAccount(MboxParser &boxParser, IndexInterface *pIndex,
-	LabelManager &labelMan, time_t &lastMessageTime,
+	time_t &lastMessageTime,
 	const string &tempSourceLabel, const string &sourceLabel)
 {
 	bool indexedFile = false;
@@ -133,7 +133,7 @@
 	while (pMessage != NULL)
 	{
 		// Has this message already been indexed ?
-		unsigned int docId = pIndex->hasDocument(*pMessage);
+		unsigned int docId = pIndex->hasDocument(pMessage->getLocation());
 		if (docId == 0)
 		{
 			pIndex->setStemmingMode(IndexInterface::STORE_BOTH);
@@ -148,8 +148,11 @@
 				break;	
 			}
 
+			set<string> labels;
+			labels.insert(tempSourceLabel);
+
 			unsigned int docId = 0;
-			indexedFile = pIndex->indexDocument(*pTokenizer, docId);
+			indexedFile = pIndex->indexDocument(*pTokenizer, labels, docId);
 			if (indexedFile == true)
 			{
 				time_t messageDate = boxParser.getDate();
@@ -160,9 +163,7 @@
 					lastMessageTime = messageDate;
 				}
 
-				set<string> labels;
-				labels.insert(tempSourceLabel);
-				labelMan.setLabels(docId, pIndex->getLocation(), labels);
+				pIndex->setDocumentLabels(docId, labels);
 
 				IndexedDocument docInfo(pMessage->getTitle(),
 					XapianEngine::buildUrl(PinotSettings::getInstance().m_mailIndexLocation, docId),
@@ -189,7 +190,7 @@
 				set<string> labels;
 
 				// Get the message's labels
-				labelMan.getLabels(docId, pIndex->getLocation(), labels);
+				pIndex->getDocumentLabels(docId, labels);
 				// The source label must have been applied to the message when originally indexed
 				set<string>::iterator labelIter = labels.find(sourceLabel.c_str());
 				if (labelIter != labels.end())
@@ -198,7 +199,7 @@
 					labels.erase(labelIter);
 					// Add the temporary label
 					labels.insert(tempSourceLabel);
-					labelMan.setLabels(docId, pIndex->getLocation(), labels);
+					pIndex->setDocumentLabels(docId, labels);
 				}
 			}
 		}
@@ -223,8 +224,7 @@
 	return indexedFile;
 }
 
-bool MboxHandler::deleteMessages(IndexInterface *pIndex,  LabelManager &labelMan,
-	const string &sourceLabel)
+bool MboxHandler::deleteMessages(IndexInterface *pIndex, const string &sourceLabel)
 {
 	set<unsigned int> docIdList;
 	bool unindexedMsgs = false;
@@ -235,7 +235,7 @@
 	}
 
 	// Unindex all documents labeled with this source label
-	if ((labelMan.getDocumentsWithLabel(sourceLabel, pIndex->getLocation(), docIdList) == true) &&
+	if ((pIndex->getDocumentsWithLabel(sourceLabel, docIdList) == true) &&
 		(docIdList.empty() == false))
 	{
 #ifdef DEBUG
@@ -313,7 +313,6 @@
 
 bool MboxHandler::fileExists(const string &fileName, bool end)
 {
-	LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
 	PinotSettings::MailAccount mailAccount;
 	off_t previousSize = 0;
 
@@ -350,19 +349,19 @@
 	// Get a parser
 	MboxParser boxParser(fileName);
 
-	bool indexedFile = parseMailAccount(boxParser, &index, labelMan,
+	bool indexedFile = parseMailAccount(boxParser, &index, 
 		mailAccount.m_lastMessageTime, tempSourceLabel, sourceLabel);
 
 	// Any document still labeled with this source label wasn't found
 	// this time around and should be unindexed
-	if (deleteMessages(&index, labelMan, sourceLabel) == true)
+	if (deleteMessages(&index, sourceLabel) == true)
 	{
 		indexedFile = true;
 	}
 
 	// Rename the temporary label for next time the mbox is parsed
-	labelMan.deleteLabel(sourceLabel);
-	labelMan.renameLabel(tempSourceLabel, sourceLabel);
+	index.deleteLabel(sourceLabel);
+	index.renameLabel(tempSourceLabel, sourceLabel);
 
 	// Flush the index
 	index.flush();
@@ -386,7 +385,6 @@
 
 bool MboxHandler::fileChanged(const string &fileName)
 {
-	LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
 	PinotSettings::MailAccount mailAccount;
 	off_t previousSize = 0, mboxOffset = 0;
 
@@ -431,7 +429,7 @@
 	// Get a parser
 	MboxParser boxParser(fileName, mboxOffset);
 
-	bool indexedFile = parseMailAccount(boxParser, &index, labelMan,
+	bool indexedFile = parseMailAccount(boxParser, &index,
 		mailAccount.m_lastMessageTime, sourceLabel, "");
 	if (indexedFile == true)
 	{
@@ -458,7 +456,6 @@
 
 bool MboxHandler::fileDeleted(const string &fileName)
 {
-	LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
 	string sourceLabel = string("mailbox://") + fileName;
 	bool unindexedFile = false;
 
@@ -474,10 +471,10 @@
 	}
 
 	// Unindex all documents labeled with this source label
-	if (deleteMessages(&index, labelMan, sourceLabel) == true)
+	if (deleteMessages(&index, sourceLabel) == true)
 	{
 		// Delete the label
-		labelMan.deleteLabel(sourceLabel);
+		index.deleteLabel(sourceLabel);
 
 		return true;
 	}

Modified: trunk/UI/GTK2/src/MonitorHandler.h
===================================================================
--- trunk/UI/GTK2/src/MonitorHandler.h	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/MonitorHandler.h	2005-12-15 14:46:50 UTC (rev 9)
@@ -26,7 +26,6 @@
 #include "DocumentInfo.h"
 #include "IndexedDocument.h"
 #include "MboxParser.h"
-#include "LabelManager.h"
 #include "IndexInterface.h"
 #include "PinotSettings.h"
 
@@ -91,12 +90,11 @@
 			off_t &previousSize);
 
 		bool parseMailAccount(MboxParser &boxParser, IndexInterface *pIndex,
-			LabelManager &labelMan, time_t &lastMessageTime,
-			const std::string &tempSourceLabel, const std::string &sourceLabel);
-
-		bool deleteMessages(IndexInterface *pIndex, LabelManager &labelMan,
+			time_t &lastMessageTime, const std::string &tempSourceLabel,
 			const std::string &sourceLabel);
 
+		bool deleteMessages(IndexInterface *pIndex, const std::string &sourceLabel);
+
 	private:
 		MboxHandler(const MboxHandler &other);
 		MboxHandler &operator=(const MboxHandler &other);

Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2005-12-15 14:46:50 UTC (rev 9)
@@ -476,14 +476,18 @@
 		{
 			queryProps.setLanguage(nodeContent);
 		}
-		else if (nodeName == "hostname")
+		else if (nodeName == "hostfilter")
 		{
-			queryProps.setHostNameFilter(nodeContent);
+			queryProps.setHostFilter(nodeContent);
 		}
-		else if (nodeName == "filename")
+		else if (nodeName == "filefilter")
 		{
-			queryProps.setFileNameFilter(nodeContent);
+			queryProps.setFileFilter(nodeContent);
 		}
+		else if (nodeName == "labelfilter")
+		{
+			queryProps.setLabelFilter(nodeContent);
+		}
 		else if (nodeName == "maxresults")
 		{
 			int count = atoi(nodeContent.c_str());
@@ -789,8 +793,9 @@
 		addChildElement(pElem, "phrase", queryIter->second.getPhrase());
 		addChildElement(pElem, "any", queryIter->second.getAnyWords());
 		addChildElement(pElem, "not", queryIter->second.getNotWords());
-		addChildElement(pElem, "hostname", queryIter->second.getHostNameFilter());
-		addChildElement(pElem, "filename", queryIter->second.getFileNameFilter());
+		addChildElement(pElem, "hostfilter", queryIter->second.getHostFilter());
+		addChildElement(pElem, "filefilter", queryIter->second.getFileFilter());
+		addChildElement(pElem, "labelfilter", queryIter->second.getLabelFilter());
 		addChildElement(pElem, "language", queryIter->second.getLanguage());
 		sprintf(numStr, "%u", queryIter->second.getMaximumResultsCount());
 		addChildElement(pElem, "maxresults", numStr);

Modified: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-15 14:46:50 UTC (rev 9)
@@ -1007,12 +1007,11 @@
 	string strippedText = HtmlTokenizer::stripTags(text);
 	XapianIndex index(m_settings.m_indexLocation);
 	ViewHistory viewHistory(m_settings.m_historyDatabase);
-	DocumentInfo docInfo(text, url, "", language);
 	bool isIndexed = false;
 
 	// Is this document indexed ?
 	if ((index.isGood() == true) &&
-		(index.hasDocument(docInfo) > 0))
+		(index.hasDocument(url) > 0))
 	{
 		isIndexed = true;
 	}

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-15 14:46:50 UTC (rev 9)
@@ -33,7 +33,6 @@
 #include "StringManip.h"
 #include "TimeConverter.h"
 #include "Url.h"
-#include "LabelManager.h"
 #include "QueryHistory.h"
 #include "IndexedDocument.h"
 #include "DownloaderFactory.h"
@@ -166,7 +165,7 @@
 	return true;
 }
 
-SigC::Signal3<void, IndexedDocument, unsigned int, std::string>& IndexBrowserThread::getUpdateSignal(void)
+SigC::Signal3<void, IndexedDocument, unsigned int, string>& IndexBrowserThread::getUpdateSignal(void)
 {
 	return m_signalUpdate;
 }
@@ -216,7 +215,7 @@
 		<< " documents to browse, starting at " << m_startDoc << endl;
 #endif
 	index.getDocumentIDs(docIDList, m_maxDocsCount, m_startDoc);
-	for (set<unsigned int>::iterator iter = docIDList.begin(); iter != docIDList.end(); iter++)
+	for (set<unsigned int>::iterator iter = docIDList.begin(); iter != docIDList.end(); ++iter)
 	{
 		if (m_done == true)
 		{
@@ -409,8 +408,8 @@
 
 void LabelQueryThread::do_querying()
 {
-	LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
 	const map<string, string> &indexesMap = PinotSettings::getInstance().getIndexes();
+
 	map<string, string>::const_iterator mapIter = indexesMap.find(m_indexName);
 	if (mapIter == indexesMap.end())
 	{
@@ -423,11 +422,90 @@
 		return;
 	}
 
-	labelMan.getDocumentsWithLabel(m_labelName, mapIter->second, m_documentsList);
+	XapianIndex index(mapIter->second);
+	if (index.isGood() == false)
+	{
+		m_status = _("Index error on");
+		m_status += " ";
+		m_status += mapIter->second;
+		emitSignal();
+		return;
+	}
 
+	index.getDocumentsWithLabel(m_labelName, m_documentsList);
+
 	emitSignal();
 }
 
+LabelUpdateThread::LabelUpdateThread(const set<string> &labelsToDelete,
+	const map<string, string> &labelsToRename)
+{
+	copy(labelsToDelete.begin(), labelsToDelete.end(), inserter(m_labelsToDelete, m_labelsToDelete.begin()));
+	copy(labelsToRename.begin(), labelsToRename.end(), inserter(m_labelsToRename, m_labelsToRename.begin()));
+}
+
+LabelUpdateThread::~LabelUpdateThread()
+{
+}
+
+bool LabelUpdateThread::start(void)
+{
+	// Create a non-joinable thread
+	Thread::create(slot_class(*this, &LabelUpdateThread::do_update), false);
+
+	return true;
+}
+
+string LabelUpdateThread::getType(void) const
+{
+	return "LabelUpdateThread";
+}
+
+bool LabelUpdateThread::stop(void)
+{
+	m_done = true;
+	m_status = _("Stopped querying index labels");
+	return true;
+}
+
+void LabelUpdateThread::do_update()
+{
+	XapianIndex docsIndex(PinotSettings::getInstance().m_indexLocation);
+	if (docsIndex.isGood() == false)
+	{
+		m_status = _("Index error on");
+		m_status += " ";
+		m_status += PinotSettings::getInstance().m_indexLocation;
+		emitSignal();
+		return;
+	}
+
+	XapianIndex mailIndex(PinotSettings::getInstance().m_mailIndexLocation);
+	if (mailIndex.isGood() == false)
+	{
+		m_status = _("Index error on");
+		m_status += " ";
+		m_status += PinotSettings::getInstance().m_mailIndexLocation;
+		emitSignal();
+		return;
+	}
+
+	// Delete labels
+	for (set<string>::iterator iter = m_labelsToDelete.begin(); iter != m_labelsToDelete.end(); ++iter)
+	{
+		docsIndex.deleteLabel(*iter);
+		mailIndex.deleteLabel(*iter);
+	}
+	// Rename labels
+	for (map<string, string>::iterator iter = m_labelsToRename.begin(); iter != m_labelsToRename.end(); ++iter)
+	{
+		docsIndex.renameLabel(iter->first, iter->second);
+		mailIndex.renameLabel(iter->first, iter->second);
+	}
+
+	emitSignal();
+}
+
 DownloadingThread::DownloadingThread(const string url, bool fromCache) :
 	WorkerThread()
 {
@@ -594,7 +672,7 @@
 	return m_labelName;
 }
 
-const std::set<unsigned int> &IndexingThread::getDocumentIDs(void) const
+const set<unsigned int> &IndexingThread::getDocumentIDs(void) const
 {
 	return m_docIdList;
 }
@@ -739,18 +817,14 @@
 			}
 			else
 			{
+				set<string> labels;
 				unsigned int docId = 0;
 
 				// Save the new document ID
-				success = index.indexDocument(*pTokens, docId);
+				labels.insert(m_labelName);
+				success = index.indexDocument(*pTokens, labels, docId);
 				if (success == true)
 				{
-					LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
-
-					set<string> labels;
-					labels.insert(m_labelName);
-					labelMan.setLabels(docId, index.getLocation(), labels);
-
 					m_docIdList.insert(docId);
 				}
 			}
@@ -830,7 +904,6 @@
 {
 	if (m_done == false)
 	{
-		LabelManager labelMan(PinotSettings::getInstance().m_historyDatabase);
 		XapianIndex index(m_indexLocation);
 
 		if (index.isGood() == false)
@@ -850,51 +923,47 @@
 		{
 			// Yep
 			// FIXME: better delete documents one label at a time
-			for (set<string>::iterator iter = m_labelNames.begin(); iter != m_labelNames.end(); iter++)
+			for (set<string>::iterator iter = m_labelNames.begin(); iter != m_labelNames.end(); ++iter)
 			{
 				string labelName = (*iter);
-				labelMan.getDocumentsWithLabel(labelName, m_indexLocation, m_docIdList);
-				labelMan.deleteLabel(labelName);
+
+				// By unindexing all documents that match the label,
+				// we effectively delete the label from the index
+				if (index.unindexDocuments(labelName) == true)
+				{
+					// OK
+					++m_docsCount;
+				}
 			}
-#ifdef DEBUG
-			cout << "UnindexingThread::do_unindexing: " << m_docIdList.size() << " documents have one of the labels" << endl;
-#endif
+
+			// Nothing to report
+			m_status = "";
 		}
-
-		for (set<unsigned int>::iterator iter = m_docIdList.begin(); iter != m_docIdList.end(); iter++)
+		else
 		{
-			unsigned int docId = (*iter);
+			for (set<unsigned int>::iterator iter = m_docIdList.begin(); iter != m_docIdList.end(); ++iter)
+			{
+				unsigned int docId = (*iter);
 
-			if (index.unindexDocument(docId) == true)
-			{
-				// Delete any label this document may have had
-				if (labelMan.deleteItem(docId, m_indexLocation) == false)
+				if (index.unindexDocument(docId) == true)
 				{
+					// OK
+					++m_docsCount;
+				}
 #ifdef DEBUG
-					cout << "UnindexingThread::do_unindexing: " << docId
-						<< " may not have had labels" << endl;
+				else cout << "UnindexingThread::do_unindexing: couldn't remove " << docId << endl;
 #endif
-				}
-
-				// OK
-				m_status = "";
-				++m_docsCount;
 			}
 #ifdef DEBUG
-			else cout << "UnindexingThread::do_unindexing: couldn't remove " << docId << endl;
+			cout << "UnindexingThread::do_unindexing: removed " << m_docsCount << " documents" << endl;
 #endif
 		}
 
-		if (m_docIdList.empty() == false)
+		if (m_docsCount > 0)
 		{
-#ifdef DEBUG
-			cout << "UnindexingThread::do_unindexing: removed " << m_docIdList.size() << " documents" << endl;
-#endif
 			// Flush the index
 			index.flush();
-		}
-		else
-		{
+
 			// Nothing to report
 			m_status = "";
 		}
@@ -1215,7 +1284,7 @@
 			}
 
 			// Go through the locations map
-			for (map<unsigned long, std::string>::const_iterator fsIter = fsLocations.begin(); fsIter != fsLocations.end(); ++fsIter)
+			for (map<unsigned long, string>::const_iterator fsIter = fsLocations.begin(); fsIter != fsLocations.end(); ++fsIter)
 			{
 				string fsLocation = fsIter->second;
 				struct stat fileStat;
@@ -1266,7 +1335,15 @@
 			cout << "MonitorThread::do_monitoring: select() returned" << endl;
 #endif
 			// There might be more than one event waiting...
-			while ((FAMPending(&famConn) >= 1) &&
+			int pendingEvents = FAMPending(&famConn);
+			if (pendingEvents < 0)
+			{
+#ifdef DEBUG
+				perror("MonitorThread::do_monitoring: FAMPending() failed");
+#endif
+				break;
+			}
+			while ((pendingEvents >= 1) &&
 				(m_done == false))
 			{
 				double averageLoad[3];
@@ -1347,6 +1424,9 @@
 						}
 					}
 				}
+
+				// Anything else pending ?
+				pendingEvents = FAMPending(&famConn);
 			}
 		}
 		else

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2005-12-15 14:46:50 UTC (rev 9)
@@ -177,6 +177,31 @@
 
 };
 
+class LabelUpdateThread : public WorkerThread
+{
+	public:
+		LabelUpdateThread(const std::set<std::string> &labelsToDelete,
+			const std::map<std::string, std::string> &labelsToRename);
+		virtual ~LabelUpdateThread();
+
+		virtual bool start(void);
+
+		virtual std::string getType(void) const;
+
+		virtual bool stop(void);
+
+	protected:
+		std::set<std::string> m_labelsToDelete;
+		std::map<std::string, std::string> m_labelsToRename;
+
+		void do_update();
+
+	private:
+		LabelUpdateThread(const LabelUpdateThread &other);
+		LabelUpdateThread &operator=(const LabelUpdateThread &other);
+
+};
+
 class DownloadingThread : public WorkerThread
 {
 	public:

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-15 14:46:50 UTC (rev 9)
@@ -36,7 +36,6 @@
 #include "TimeConverter.h"
 #include "Url.h"
 #include "ActionHistory.h"
-#include "LabelManager.h"
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "DownloaderFactory.h"
@@ -974,6 +973,18 @@
 			}
 		}
 	}
+	else if (type == "LabelUpdateThread")
+	{
+		LabelQueryThread *pLabelQueryThread = dynamic_cast<LabelQueryThread *>(pThread);
+		if (pLabelQueryThread == NULL)
+		{
+			delete pThread;
+			return;
+		}
+
+		status = _("Updated label(s)");
+		set_status(status);
+	}
 	else if (type == "DownloadingThread")
 	{
 		DownloadingThread *pDownloadThread = dynamic_cast<DownloadingThread *>(pThread);
@@ -1059,25 +1070,27 @@
 			if (m_state.getCurrentIndex() == _("My Documents"))
 			{
 				XapianIndex index(m_settings.m_indexLocation);
-				DocumentInfo docInfo;
-				string date;
 
-				// Update the index tree
-				for (set<unsigned int>::iterator idIter = docIdList.begin();
-					idIter != docIdList.end(); ++idIter)
+				if (index.isGood() == true)
 				{
-					unsigned int docId = *idIter;
-
-					// Get that document's properties
-					if (index.getDocumentInfo(docId, docInfo) == true)
+					// Update the index tree
+					for (set<unsigned int>::iterator idIter = docIdList.begin();
+						idIter != docIdList.end(); ++idIter)
 					{
-						// Append to the index tree
-						IndexedDocument indexedDoc(docInfo.getTitle(),
-							XapianEngine::buildUrl(m_settings.m_indexLocation, docId),
-							docInfo.getLocation(), docInfo.getType(),
-							docInfo.getLanguage());
-						indexedDoc.setTimestamp(docInfo.getTimestamp());
-						m_pIndexTree->appendDocument(indexedDoc, labeled);
+						DocumentInfo docInfo;
+						unsigned int docId = *idIter;
+
+						// Get that document's properties
+						if (index.getDocumentInfo(docId, docInfo) == true)
+						{
+							// Append to the index tree
+							IndexedDocument indexedDoc(docInfo.getTitle(),
+								XapianEngine::buildUrl(m_settings.m_indexLocation, docId),
+								docInfo.getLocation(), docInfo.getType(),
+								docInfo.getLanguage());
+							indexedDoc.setTimestamp(docInfo.getTimestamp());
+							m_pIndexTree->appendDocument(indexedDoc, labeled);
+						}
 					}
 				}
 
@@ -1231,9 +1244,6 @@
 //
 void mainWindow::on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, string indexName)
 {
-	LabelManager labelMan(m_settings.m_historyDatabase);
-	bool hasLabel = false;
-
 	if (indexName != locale_from_utf8(m_state.getCurrentIndex()))
 	{
 		// Ignore
@@ -1262,15 +1272,8 @@
 		return;
 	}
 
-	// Does that document have the current label ?
-	string currentLabelName;
-	if (m_state.getCurrentLabel(currentLabelName) > 0)
-	{
-		hasLabel = labelMan.hasLabel(docId, mapIter->second, currentLabelName);
-	}
-
 	// Add a row
-	if (m_pIndexTree->appendDocument(docInfo, hasLabel) == true)
+	if (m_pIndexTree->appendDocument(docInfo, true) == true)
 	{
 #ifdef DEBUG
 		cout << "mainWindow::on_message_indexupdate: added document to index list" << endl;
@@ -1339,11 +1342,20 @@
 		}
 	}
 
+	// Any labels to delete or rename ?
+	const set<string> &labelsToDelete = prefsBox.getLabelsToDelete();
+	const std::map<string, string> &labelsToRename = prefsBox.getLabelsToRename();
+	if ((labelsToDelete.empty() == false) ||
+		(labelsToRename.empty() == false))
+	{
+		start_thread(new LabelUpdateThread(labelsToDelete, labelsToRename));
+	}
+
 	// Any mail documents we should delete ?
-	const set<string> &labelNames = prefsBox.getMailLabelsToDelete();
-	if (labelNames.empty() == false)
+	const set<string> &mailLabelsToDelete = prefsBox.getMailLabelsToDelete();
+	if (mailLabelsToDelete.empty() == false)
 	{
-		start_thread(new UnindexingThread(labelNames, locale_from_utf8(m_settings.m_mailIndexLocation)));
+		start_thread(new UnindexingThread(mailLabelsToDelete, locale_from_utf8(m_settings.m_mailIndexLocation)));
 	}
 }
 
@@ -1670,13 +1682,12 @@
 //
 void mainWindow::on_showfromindex_activate()
 {
-	LabelManager labelMan(m_settings.m_historyDatabase);
 	vector<IndexedDocument> documentsList;
 	set<string> docLabels;
 	DocumentInfo docInfo;
 	unsigned int docId = 0;
 	int width, height;
-	bool matchedLabel = false, editTitle = false;
+	bool editTitle = false;
 
 	const std::map<string, string> &indexesMap = PinotSettings::getInstance().getIndexes();
 	std::map<string, string>::const_iterator mapIter = indexesMap.find(m_state.getCurrentIndex());	
@@ -1691,6 +1702,8 @@
 		return;
 	}
 
+	XapianIndex index(mapIter->second);
+
 	// Get the current documents selection
 	if ((m_pIndexTree->getSelection(documentsList) == false) ||
 		(documentsList.empty() == true))
@@ -1707,23 +1720,14 @@
 		// Get the document ID
 		Url urlObj(docIter->getLocation());
 		docId = (unsigned int)atoi(urlObj.getFile().c_str());
-		if (docId > 0)
-		{
-			labelMan.getLabels(docId, mapIter->second, docLabels);
 
-			// Does it match the current label ?
-			string currentLabelName;
-			if ((m_state.getCurrentLabel(currentLabelName) > 0) &&
-				(find(docLabels.begin(), docLabels.end(), currentLabelName) != docLabels.end()))
-			{
-				matchedLabel = true;
-			}
+		if (index.isGood() == true)
+		{
+			index.getDocumentLabels(docId, docLabels);
 		}
 
-		docInfo.setTitle(docIter->getTitle());
-		docInfo.setLocation(docIter->getOriginalLocation());
-		docInfo.setType(docIter->getType());
-		docInfo.setLanguage(docIter->getLanguage());
+		docInfo = DocumentInfo(docIter->getTitle(), docIter->getOriginalLocation(),
+			docIter->getType(), docIter->getLanguage());
 		docInfo.setTimestamp(docIter->getTimestamp());
 		editTitle = true;
 	}
@@ -1740,40 +1744,20 @@
 	}
 	const set<string> &labels = propertiesBox.getLabels();
 
-	// Now apply these labels to all documents
-	for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
-		docIter != documentsList.end(); ++docIter)
+	if (index.isGood() == true)
 	{
-		// Check the document ID
-		unsigned int docId = docIter->getID();
-		if (docId == 0)
+		// Now apply these labels to all the documents
+		for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
+			docIter != documentsList.end(); ++docIter)
 		{
-			continue;
+			// Set the document's labels list
+			index.setDocumentLabels(docIter->getID(), labels);
 		}
-		// Set the document's labels list
-		labelMan.setLabels(docId, mapIter->second, labels);
 	}
 
 	if ((documentsList.size() == 1) &&
 		(docId > 0))
 	{
-		bool matchesLabel = false;
-
-		// Does the sole selected document match the current label now ?
-		string currentLabelName;
-		if ((m_state.getCurrentLabel(currentLabelName) > 0) &&
-			(find(labels.begin(), labels.end(), currentLabelName) != labels.end()))
-		{
-			matchesLabel = true;
-		}
-
-		// Was there any change ?
-		if (matchesLabel != matchedLabel)
-		{
-			// Update this document to the index tree
-			m_pIndexTree->setDocumentLabeledState(docId, matchesLabel);
-		}
-
 		string newTitle = propertiesBox.getDocumentInfo().getTitle();
 		if (newTitle != docInfo.getTitle())
 		{
@@ -1787,10 +1771,12 @@
 	{
 		string currentLabelName;
 
-		// Because the current label may have been applied to or removed from
-		// one or more of the selected documents, refresh the list of matching documents
-		m_state.getCurrentLabel(currentLabelName);
-		start_thread(new LabelQueryThread(m_state.getCurrentIndex(), currentLabelName));
+		if (m_state.getCurrentLabel(currentLabelName) > 0)
+		{
+			// The current label may have been applied to or removed from
+			// one or more of the selected documents, so refresh the list
+			start_thread(new LabelQueryThread(m_state.getCurrentIndex(), currentLabelName));
+		}
 	}
 }
 
@@ -2533,16 +2519,17 @@
 void mainWindow::index_document(const DocumentInfo &docInfo,
 	const string &labelName, unsigned int docId)
 {
-	LabelManager labelMan(m_settings.m_historyDatabase);
 	Url urlObj(docInfo.getLocation());
-	string indexName = m_settings.m_indexLocation;
+	string indexLocation = m_settings.m_indexLocation;
 
 	// If the document is mail, we need to check My Email
 	if (urlObj.getProtocol() == "mailbox")
 	{
-		indexName = m_settings.m_mailIndexLocation;
+		indexLocation = m_settings.m_mailIndexLocation;
 	}
 
+	XapianIndex index(indexLocation);
+
 	// Is it an update ?
 	if (docId > 0)
 	{
@@ -2551,7 +2538,6 @@
 	}
 	else
 	{
-		XapianIndex index(indexName);
 		string url(docInfo.getLocation());
 		bool isNewDocument = false;
 
@@ -2559,7 +2545,7 @@
 		// or is being indexed
 		if (index.isGood() == true)
 		{
-			docId = index.hasDocument(docInfo);
+			docId = index.hasDocument(url);
 		}
 		if ((docId == 0) &&
 			(m_state.writeLock(4) == true))
@@ -2589,31 +2575,12 @@
 	{
 		set<string> docLabels;
 
-		// Get the labels for this document
-		labelMan.getLabels(docId, indexName, docLabels);
-
-		// Add this new label if it's not in
-		if (find(docLabels.begin(), docLabels.end(), labelName) == docLabels.end())
-		{
+		// Add this new label
 #ifdef DEBUG
-			cout << "mainWindow::index_document: applying label " << labelName << " to document " << docId << endl;
+		cout << "mainWindow::index_document: applying label " << labelName << " to document " << docId << endl;
 #endif
-			// Update the document's labels list
-			docLabels.insert(labelName);
-			labelMan.setLabels(docId, indexName, docLabels);
-
-			// Is this the current label ?
-			string currentLabelName;
-			if ((m_state.getCurrentLabel(currentLabelName) > 0) &&
-				(labelName == currentLabelName))
-			{
-				// Update this document in the index tree
-				m_pIndexTree->setDocumentLabeledState(docId, true);
-			}
-		}
-#ifdef DEBUG
-		else cout << "mainWindow::index_document: label " << labelName << " already applied to document " << docId << endl;
-#endif
+		docLabels.insert(labelName);
+		index.setDocumentLabels(docId, docLabels, false);
 	}
 }
 

Modified: trunk/UI/GTK2/src/pinot.cpp
===================================================================
--- trunk/UI/GTK2/src/pinot.cpp	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/pinot.cpp	2005-12-15 14:46:50 UTC (rev 9)
@@ -28,7 +28,6 @@
 #include "TokenizerFactory.h"
 #include "Languages.h"
 #include "ActionHistory.h"
-#include "LabelManager.h"
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "XapianDatabase.h"
@@ -120,7 +119,6 @@
 	// Do the same for the history database
 	if ((settings.m_historyDatabase.empty() == true) ||
 		(ActionHistory::create(settings.m_historyDatabase) == false) ||
-		(LabelManager::create(settings.m_historyDatabase) == false) ||
 		(QueryHistory::create(settings.m_historyDatabase) == false) ||
 		(ViewHistory::create(settings.m_historyDatabase) == false))
 	{

Modified: trunk/UI/GTK2/src/prefsDialog.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.cc	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/prefsDialog.cc	2005-12-15 14:46:50 UTC (rev 9)
@@ -15,7 +15,6 @@
 
 #include "MIMEScanner.h"
 #include "SearchEngineFactory.h"
-#include "LabelManager.h"
 #include "QueryHistory.h"
 #include "Url.h"
 #include "config.h"
@@ -86,13 +85,21 @@
 {
 }
 
-const set<string> &prefsDialog::getMailLabelsToDelete(void) const
+const set<string> &prefsDialog::getLabelsToDelete(void) const
 {
-	// This will have been reset by save_labelsTreeview()
-	// and set by save_mailTreeview() !
 	return m_deletedLabels;
 }
 
+const map<string, string> &prefsDialog::getLabelsToRename(void) const
+{
+	return m_renamedLabels;
+}
+
+const set<string> &prefsDialog::getMailLabelsToDelete(void) const
+{
+	return m_deletedMail;
+}
+
 void prefsDialog::populate_comboboxes()
 {
 	TreeModel::iterator iter = m_refViewTree->append();
@@ -149,8 +156,6 @@
 
 bool prefsDialog::save_labelsTreeview()
 {
-	LabelManager labelMan(m_settings.m_historyDatabase);
-
 	// Clear the current settings
 	m_settings.m_labels.clear();
 
@@ -172,7 +177,7 @@
 				(label.m_name != oldName))
 			{
 				// Yes, it was
-				labelMan.renameLabel(locale_from_utf8(oldName), locale_from_utf8(label.m_name));
+				m_renamedLabels[locale_from_utf8(oldName)] = locale_from_utf8(label.m_name);
 			}
 			// Check user didn't recreate this label after having deleted it
 			set<string>::iterator labelIter = m_deletedLabels.find(locale_from_utf8(label.m_name));
@@ -192,13 +197,6 @@
 		}
 	}
 
-	// Remove all references to labels that have been deleted
-	for (set<string>::iterator labelIter = m_deletedLabels.begin(); labelIter != m_deletedLabels.end(); ++labelIter)
-	{
-		labelMan.deleteLabel(*labelIter);
-	}
-	m_deletedLabels.clear();
-
 	return true;
 }
 
@@ -258,8 +256,11 @@
 				mailAccount.m_modTime = row[m_mailColumns.m_mTime];
 				mailAccount.m_lastMessageTime = row[m_mailColumns.m_minDate];
 
+				string mailLabel("mailbox://");
+				mailLabel += locale_from_utf8(mailAccount.m_name);
+
 				// Check user didn't recreate this mail account after having deleted it
-				set<ustring>::iterator mailIter = m_deletedMail.find(mailAccount.m_name);
+				set<string>::iterator mailIter = m_deletedMail.find(mailLabel);
 				if (mailIter != m_deletedMail.end())
 				{
 					m_deletedMail.erase(mailIter);
@@ -277,19 +278,6 @@
 		}
 	}
 
-	// Remove all documents from deleted mail accounts
-	for (set<ustring>::iterator mailIter = m_deletedMail.begin(); mailIter != m_deletedMail.end(); ++mailIter)
-	{
-		string sourceLabel = "mailbox://";
-		sourceLabel += *mailIter;
-
-		// Reuse the labels list
-		m_deletedLabels.insert(sourceLabel);
-#ifdef DEBUG
-		cout << "prefsDialog::save_mailTreeview: will unindex documents from " << *mailIter << endl;
-#endif
-	}
-
 	return true;
 }
 
@@ -492,15 +480,19 @@
 	TreeModel::iterator iter = mailTreeview->get_selection()->get_selected();
 	if (iter)
 	{
+		string mailLabel("mailbox://");
+
 		// Unselect
 		mailTreeview->get_selection()->unselect(iter);
 		// Select another row
 		TreeModel::Path path = m_refMailTree->get_path(iter);
 		path.next();
 		mailTreeview->get_selection()->select(path);
+
 		// Erase
 		TreeModel::Row row = *iter;
-		m_deletedMail.insert(row[m_mailColumns.m_location]);
+		mailLabel += locale_from_utf8(row[m_mailColumns.m_location]);
+		m_deletedMail.insert(mailLabel);
 		m_refMailTree->erase(row);
 
 		TreeModel::Children children = m_refMailTree->children();

Modified: trunk/UI/GTK2/src/prefsDialog.hh
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.hh	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/prefsDialog.hh	2005-12-15 14:46:50 UTC (rev 9)
@@ -13,6 +13,7 @@
 #define _PREFSDIALOG_HH
 
 #include <string>
+#include <map>
 #include <set>
 #include <glibmm/refptr.h>
 #include <glibmm/ustring.h>
@@ -28,6 +29,10 @@
 	prefsDialog();
 	virtual ~prefsDialog();
 
+	const std::set<std::string> &getLabelsToDelete(void) const;
+
+	const std::map<std::string, std::string> &getLabelsToRename(void) const;
+
 	const std::set<std::string> &getMailLabelsToDelete(void) const;
 
 protected:
@@ -59,9 +64,9 @@
 	Glib::RefPtr<Gtk::ListStore> m_refLabelsTree;
 	MailAccountModelColumns m_mailColumns;
 	Glib::RefPtr<Gtk::ListStore> m_refMailTree;
-	std::set<Glib::ustring> m_deletedIndexes;
 	std::set<std::string> m_deletedLabels;
-	std::set<Glib::ustring> m_deletedMail;
+	std::map<std::string, std::string> m_renamedLabels;
+	std::set<std::string> m_deletedMail;
 	static unsigned int m_maxDirLevel;
 
 };

Modified: trunk/UI/GTK2/src/queryDialog.cc
===================================================================
--- trunk/UI/GTK2/src/queryDialog.cc	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/queryDialog.cc	2005-12-15 14:46:50 UTC (rev 9)
@@ -28,10 +28,14 @@
 {
 	string name = m_properties.getName();
 
-	// Associate the columns model to the label combo
-	m_refLabelTree = ListStore::create(m_labelColumns);
-	labelCombobox->set_model(m_refLabelTree);
-	labelCombobox->pack_start(m_labelColumns.m_name);
+	// Associate the columns model to the index label combo
+	m_refLabelNameTree = ListStore::create(m_labelNameColumns);
+	labelNameCombobox->set_model(m_refLabelNameTree);
+	labelNameCombobox->pack_start(m_labelNameColumns.m_name);
+	// ...and the label filter combo
+	m_refLabelFilterTree = ListStore::create(m_labelFilterColumns);
+	labelFilterCombobox->set_model(m_refLabelFilterTree);
+	labelFilterCombobox->pack_start(m_labelFilterColumns.m_name);
 	// Associate the columns model to the language combo
 	m_refLanguageTree = ListStore::create(m_languageColumns);
 	languageCombobox->set_model(m_refLanguageTree);
@@ -55,9 +59,9 @@
 	notEntry->set_text(locale_to_utf8(m_properties.getNotWords()));
 
 	// Host name
-	hostNameEntry->set_text(locale_to_utf8(m_properties.getHostNameFilter()));
+	hostNameEntry->set_text(locale_to_utf8(m_properties.getHostFilter()));
 	// File name
-	fileNameEntry->set_text(locale_to_utf8(m_properties.getFileNameFilter()));
+	fileNameEntry->set_text(locale_to_utf8(m_properties.getFileFilter()));
 	// Maximum number of results
 	resultsCountSpinbutton->set_value((double)m_properties.getMaximumResultsCount());
 	// Index all results
@@ -71,45 +75,47 @@
 void queryDialog::populate_comboboxes()
 {
 	unsigned int labelNum = 1;
-	bool foundLanguage = false;
 
-	TreeModel::iterator iter = m_refLabelTree->append();
+	TreeModel::iterator iter = m_refLabelNameTree->append();
 	TreeModel::Row row = *iter;
-	row[m_labelColumns.m_name] = "None";
-	labelCombobox->set_active(0);
+	row[m_labelNameColumns.m_name] = _("None");
+	labelNameCombobox->set_active(0);
 
-#ifdef DEBUG
-	cout << "queryDialog::populate_comboboxes: looking for " << m_properties.getLabelName() << endl;
-#endif
-	// Add all labels to the combo and select the one defined for the query
+	iter = m_refLabelFilterTree->append();
+	row = *iter;
+	row[m_labelFilterColumns.m_name] = _("Any");
+	labelFilterCombobox->set_active(0);
+
+	// Add all labels to both label combos and select the one defined for the query
 	for (set<PinotSettings::Label>::const_iterator labelIter = m_labels.begin(); labelIter != m_labels.end(); ++labelIter)
 	{
 		string labelName = labelIter->m_name;
 
-		iter = m_refLabelTree->append();
+		iter = m_refLabelNameTree->append();
 		row = *iter;
-		row[m_labelColumns.m_name] = locale_to_utf8(labelName);
-#ifdef DEBUG
-	cout << "queryDialog::populate_comboboxes: added label " << labelName << endl;
-#endif
-
+		row[m_labelNameColumns.m_name] = locale_to_utf8(labelName);
 		if (labelName == m_properties.getLabelName())
 		{
-			labelCombobox->set_active(labelNum);
-			// Keep going
+			labelNameCombobox->set_active(labelNum);
 		}
+
+		iter = m_refLabelFilterTree->append();
+		row = *iter;
+		row[m_labelFilterColumns.m_name] = locale_to_utf8(labelName);
+		if (labelName == m_properties.getLabelFilter())
+		{
+			labelFilterCombobox->set_active(labelNum);
+		}
+
 		++labelNum;
 	}
 
-	string queryLanguage = m_properties.getLanguage();
 	iter = m_refLanguageTree->append();
 	row = *iter;
 	row[m_languageColumns.m_name] = _("Any");
+	languageCombobox->set_active(0);
 
 	// Add all supported languages and select the one defined for the query
-#ifdef DEBUG
-	cout << "queryDialog::populate_comboboxes: looking for " << queryLanguage << endl;
-#endif
 	for (unsigned int languageNum = 0; languageNum < Languages::m_count; ++languageNum)
 	{
 		string languageName = Languages::getIntlName(languageNum);
@@ -117,21 +123,14 @@
 		row = *iter;
 		row[m_languageColumns.m_name] = languageName;
 
-		if ((foundLanguage == false) &&
-			(queryLanguage.empty() == false) &&
-			(queryLanguage == languageName))
+		if (languageName == m_properties.getLanguage())
 		{
 #ifdef DEBUG
 			cout << "queryDialog::populate_comboboxes: found at " << languageNum << endl;
 #endif
 			languageCombobox->set_active(languageNum + 1);
-			foundLanguage = true;
 		}
 	}
-	if (foundLanguage == false)
-	{
-		languageCombobox->set_active(0);
-	}
 }
 
 bool queryDialog::badName(void) const
@@ -176,34 +175,34 @@
 			m_properties.setLanguage(Languages::getIntlName(chosenLanguage));
 		}
 	}
-	// Host name
-	m_properties.setHostNameFilter(locale_from_utf8(hostNameEntry->get_text()));
-	// File name
-	m_properties.setFileNameFilter(locale_from_utf8(fileNameEntry->get_text()));
 	// Maximum number of results
 	m_properties.setMaximumResultsCount((unsigned int)resultsCountSpinbutton->get_value());
 	// Index all results
 	m_properties.setIndexResults(indexCheckbutton->get_active());
-	// Label
-	int chosenLabel = labelCombobox->get_active_row_number();
-#ifdef DEBUG
-	cout << "queryDialog::on_queryOkbutton_clicked: chosen label " << chosenLabel << endl;
-#endif
-	if (chosenLabel == 0)
+	// Index label
+	int chosenLabel = labelNameCombobox->get_active_row_number();
+	m_properties.setLabelName("");
+	if (chosenLabel > 0)
 	{
-		// No label
-		m_properties.setLabelName("");
+		TreeModel::iterator iter = labelNameCombobox->get_active();
+		TreeModel::Row row = *iter;
+		string labelName = locale_from_utf8(row[m_labelNameColumns.m_name]);
+
+		m_properties.setLabelName(labelName);
 	}
-	else
+	// Filters
+	m_properties.setHostFilter(locale_from_utf8(hostNameEntry->get_text()));
+	m_properties.setFileFilter(locale_from_utf8(fileNameEntry->get_text()));
+	// Label filter
+	chosenLabel = labelFilterCombobox->get_active_row_number();
+	m_properties.setLabelFilter("");
+	if (chosenLabel > 0)
 	{
-		TreeModel::iterator iter = labelCombobox->get_active();
+		TreeModel::iterator iter = labelFilterCombobox->get_active();
 		TreeModel::Row row = *iter;
-		string labelName = locale_from_utf8(row[m_labelColumns.m_name]);
+		string labelName = locale_from_utf8(row[m_labelFilterColumns.m_name]);
 
-#ifdef DEBUG
-		cout << "queryDialog::on_queryOkbutton_clicked: label is " << labelName << endl;
-#endif
-		m_properties.setLabelName(labelName);
+		m_properties.setLabelFilter(labelName);
 	}
 }
 

Modified: trunk/UI/GTK2/src/queryDialog.hh
===================================================================
--- trunk/UI/GTK2/src/queryDialog.hh	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/queryDialog.hh	2005-12-15 14:46:50 UTC (rev 9)
@@ -33,10 +33,12 @@
 	std::string m_name;
 	QueryProperties& m_properties;
 	const std::set<PinotSettings::Label> &m_labels;
-	ComboModelColumns m_labelColumns;
-	Glib::RefPtr<Gtk::ListStore> m_refLabelTree;
+	ComboModelColumns m_labelNameColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refLabelNameTree;
 	ComboModelColumns m_languageColumns;
 	Glib::RefPtr<Gtk::ListStore> m_refLanguageTree;
+	ComboModelColumns m_labelFilterColumns;
+	Glib::RefPtr<Gtk::ListStore> m_refLabelFilterTree;
 	bool m_badName;
 
 	void populate_comboboxes();

Modified: trunk/UI/GTK2/src/queryDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/queryDialog_glade.cc	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/queryDialog_glade.cc	2005-12-15 14:46:50 UTC (rev 9)
@@ -1,4 +1,4 @@
-// generated 2005/11/26 12:46:55 SGT by fabrice at amra.dyndns.org.(none)
+// generated 2005/12/15 22:39:14 SGT by fabrice at amra.dyndns.org.(none)
 // using glademm V2.6.0
 //
 // DO NOT EDIT THIS FILE ! It was created using
@@ -70,25 +70,29 @@
    indexCheckbutton = Gtk::manage(new class Gtk::CheckButton(_("Index all results with label")));
    
    Gtk::Label *anyLabel = Gtk::manage(new class Gtk::Label(_("Any of the words:")));
-   Gtk::Label *hostLabel = Gtk::manage(new class Gtk::Label(_("Host name:")));
    Gtk::Label *fileNameLabel = Gtk::manage(new class Gtk::Label(_("File name:")));
    Gtk::Label *resultsCountLabel = Gtk::manage(new class Gtk::Label(_("Number of results:")));
-   labelCombobox = Gtk::manage(new class Gtk::ComboBox());
+   labelNameCombobox = Gtk::manage(new class Gtk::ComboBox());
    
+   Gtk::Label *hostLabel = Gtk::manage(new class Gtk::Label(_("Host name:")));
+   Gtk::Label *notLabel = Gtk::manage(new class Gtk::Label(_("None of the words:")));
+   notEntry = Gtk::manage(new class Gtk::Entry());
+   
    Gtk::Table *tersmTable = Gtk::manage(new class Gtk::Table(2, 2, false));
    Gtk::VBox *termsVbox = Gtk::manage(new class Gtk::VBox(false, 0));
    Gtk::Label *propertiesLabel = Gtk::manage(new class Gtk::Label(_("Properties")));
    Gtk::Label *filtersLabel = Gtk::manage(new class Gtk::Label(_("Limit to documents that match")));
    phraseEntry = Gtk::manage(new class Gtk::Entry());
-   notEntry = Gtk::manage(new class Gtk::Entry());
    
    Gtk::Label *phraseLabel = Gtk::manage(new class Gtk::Label(_("the exact phrase:")));
-   Gtk::Label *notLabel = Gtk::manage(new class Gtk::Label(_("none of the words:")));
-   Gtk::Label *label14 = Gtk::manage(new class Gtk::Label(_("the language:")));
+   Gtk::Label *languageLabel = Gtk::manage(new class Gtk::Label(_("the language:")));
    languageCombobox = Gtk::manage(new class Gtk::ComboBox());
    andEntry = Gtk::manage(new class Gtk::Entry());
    
    Gtk::Label *andLabel = Gtk::manage(new class Gtk::Label(_("all the words:")));
+   Gtk::Label *labelLabel = Gtk::manage(new class Gtk::Label(_("the label:")));
+   labelFilterCombobox = Gtk::manage(new class Gtk::ComboBox());
+   
    Gtk::Table *advancedTable = Gtk::manage(new class Gtk::Table(2, 2, false));
    Gtk::VBox *advancedVbox = Gtk::manage(new class Gtk::VBox(false, 0));
    Gtk::Label *advancedLabel = Gtk::manage(new class Gtk::Label(_("Advanced")));
@@ -155,12 +159,6 @@
    anyLabel->set_line_wrap(false);
    anyLabel->set_use_markup(false);
    anyLabel->set_selectable(false);
-   hostLabel->set_alignment(0,0.5);
-   hostLabel->set_padding(4,4);
-   hostLabel->set_justify(Gtk::JUSTIFY_LEFT);
-   hostLabel->set_line_wrap(false);
-   hostLabel->set_use_markup(false);
-   hostLabel->set_selectable(false);
    fileNameLabel->set_alignment(0,0.5);
    fileNameLabel->set_padding(4,4);
    fileNameLabel->set_justify(Gtk::JUSTIFY_LEFT);
@@ -173,18 +171,39 @@
    resultsCountLabel->set_line_wrap(false);
    resultsCountLabel->set_use_markup(false);
    resultsCountLabel->set_selectable(false);
+   hostLabel->set_alignment(0,0.5);
+   hostLabel->set_padding(4,4);
+   hostLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   hostLabel->set_line_wrap(false);
+   hostLabel->set_use_markup(false);
+   hostLabel->set_selectable(false);
+   notLabel->set_alignment(0,0.5);
+   notLabel->set_padding(4,4);
+   notLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   notLabel->set_line_wrap(false);
+   notLabel->set_use_markup(false);
+   notLabel->set_selectable(false);
+   notEntry->set_flags(Gtk::CAN_FOCUS);
+   notEntry->set_visibility(true);
+   notEntry->set_editable(true);
+   notEntry->set_max_length(0);
+   notEntry->set_text(_(""));
+   notEntry->set_has_frame(true);
+   notEntry->set_activates_default(false);
    tersmTable->set_row_spacings(0);
    tersmTable->set_col_spacings(0);
    tersmTable->attach(*anyEntry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
-   tersmTable->attach(*hostNameEntry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
-   tersmTable->attach(*fileNameEntry, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
-   tersmTable->attach(*resultsCountSpinbutton, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
-   tersmTable->attach(*indexCheckbutton, 0, 1, 4, 5, Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable->attach(*hostNameEntry, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable->attach(*fileNameEntry, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable->attach(*resultsCountSpinbutton, 1, 2, 4, 5, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable->attach(*indexCheckbutton, 0, 1, 5, 6, Gtk::FILL, Gtk::FILL, 4, 4);
    tersmTable->attach(*anyLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
-   tersmTable->attach(*hostLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
-   tersmTable->attach(*fileNameLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
-   tersmTable->attach(*resultsCountLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
-   tersmTable->attach(*labelCombobox, 1, 2, 4, 5, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable->attach(*fileNameLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   tersmTable->attach(*resultsCountLabel, 0, 1, 4, 5, Gtk::FILL, Gtk::FILL, 0, 0);
+   tersmTable->attach(*labelNameCombobox, 1, 2, 5, 6, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   tersmTable->attach(*hostLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
+   tersmTable->attach(*notLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
+   tersmTable->attach(*notEntry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
    termsVbox->pack_start(*tersmTable, Gtk::PACK_SHRINK, 4);
    propertiesLabel->set_alignment(0.5,0.5);
    propertiesLabel->set_padding(0,0);
@@ -205,31 +224,18 @@
    phraseEntry->set_text(_(""));
    phraseEntry->set_has_frame(true);
    phraseEntry->set_activates_default(false);
-   notEntry->set_flags(Gtk::CAN_FOCUS);
-   notEntry->set_visibility(true);
-   notEntry->set_editable(true);
-   notEntry->set_max_length(0);
-   notEntry->set_text(_(""));
-   notEntry->set_has_frame(true);
-   notEntry->set_activates_default(false);
    phraseLabel->set_alignment(0,0.5);
    phraseLabel->set_padding(4,4);
    phraseLabel->set_justify(Gtk::JUSTIFY_LEFT);
    phraseLabel->set_line_wrap(false);
    phraseLabel->set_use_markup(false);
    phraseLabel->set_selectable(false);
-   notLabel->set_alignment(0,0.5);
-   notLabel->set_padding(4,4);
-   notLabel->set_justify(Gtk::JUSTIFY_LEFT);
-   notLabel->set_line_wrap(false);
-   notLabel->set_use_markup(false);
-   notLabel->set_selectable(false);
-   label14->set_alignment(0,0.5);
-   label14->set_padding(4,4);
-   label14->set_justify(Gtk::JUSTIFY_LEFT);
-   label14->set_line_wrap(false);
-   label14->set_use_markup(false);
-   label14->set_selectable(false);
+   languageLabel->set_alignment(0,0.5);
+   languageLabel->set_padding(4,4);
+   languageLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   languageLabel->set_line_wrap(false);
+   languageLabel->set_use_markup(false);
+   languageLabel->set_selectable(false);
    andEntry->set_flags(Gtk::CAN_FOCUS);
    andEntry->set_visibility(true);
    andEntry->set_editable(true);
@@ -243,16 +249,22 @@
    andLabel->set_line_wrap(false);
    andLabel->set_use_markup(false);
    andLabel->set_selectable(false);
+   labelLabel->set_alignment(0,0.5);
+   labelLabel->set_padding(4,4);
+   labelLabel->set_justify(Gtk::JUSTIFY_LEFT);
+   labelLabel->set_line_wrap(false);
+   labelLabel->set_use_markup(false);
+   labelLabel->set_selectable(false);
    advancedTable->set_row_spacings(0);
    advancedTable->set_col_spacings(0);
    advancedTable->attach(*phraseEntry, 1, 2, 1, 2, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
-   advancedTable->attach(*notEntry, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
    advancedTable->attach(*phraseLabel, 0, 1, 1, 2, Gtk::FILL, Gtk::FILL, 0, 0);
-   advancedTable->attach(*notLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
-   advancedTable->attach(*label14, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
-   advancedTable->attach(*languageCombobox, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
+   advancedTable->attach(*languageLabel, 0, 1, 2, 3, Gtk::FILL, Gtk::FILL, 0, 0);
+   advancedTable->attach(*languageCombobox, 1, 2, 2, 3, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
    advancedTable->attach(*andEntry, 1, 2, 0, 1, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
    advancedTable->attach(*andLabel, 0, 1, 0, 1, Gtk::FILL, Gtk::FILL, 0, 0);
+   advancedTable->attach(*labelLabel, 0, 1, 3, 4, Gtk::FILL, Gtk::FILL, 0, 0);
+   advancedTable->attach(*labelFilterCombobox, 1, 2, 3, 4, Gtk::EXPAND|Gtk::FILL, Gtk::FILL, 4, 4);
    advancedVbox->pack_start(*filtersLabel, Gtk::PACK_SHRINK, 4);
    advancedVbox->pack_start(*advancedTable, Gtk::PACK_SHRINK, 0);
    advancedLabel->set_alignment(0.5,0.5);
@@ -294,22 +306,24 @@
    resultsCountSpinbutton->show();
    indexCheckbutton->show();
    anyLabel->show();
-   hostLabel->show();
    fileNameLabel->show();
    resultsCountLabel->show();
-   labelCombobox->show();
+   labelNameCombobox->show();
+   hostLabel->show();
+   notLabel->show();
+   notEntry->show();
    tersmTable->show();
    termsVbox->show();
    propertiesLabel->show();
    filtersLabel->show();
    phraseEntry->show();
-   notEntry->show();
    phraseLabel->show();
-   notLabel->show();
-   label14->show();
+   languageLabel->show();
    languageCombobox->show();
    andEntry->show();
    andLabel->show();
+   labelLabel->show();
+   labelFilterCombobox->show();
    advancedTable->show();
    advancedVbox->show();
    advancedLabel->show();

Modified: trunk/UI/GTK2/src/queryDialog_glade.hh
===================================================================
--- trunk/UI/GTK2/src/queryDialog_glade.hh	2005-12-15 14:44:29 UTC (rev 8)
+++ trunk/UI/GTK2/src/queryDialog_glade.hh	2005-12-15 14:46:50 UTC (rev 9)
@@ -1,4 +1,4 @@
-// generated 2005/11/26 12:46:55 SGT by fabrice at amra.dyndns.org.(none)
+// generated 2005/12/15 22:39:14 SGT by fabrice at amra.dyndns.org.(none)
 // using glademm V2.6.0
 //
 // DO NOT EDIT THIS FILE ! It was created using
@@ -54,11 +54,12 @@
         class Gtk::Entry * fileNameEntry;
         class Gtk::SpinButton * resultsCountSpinbutton;
         class Gtk::CheckButton * indexCheckbutton;
-        class Gtk::ComboBox * labelCombobox;
+        class Gtk::ComboBox * labelNameCombobox;
+        class Gtk::Entry * notEntry;
         class Gtk::Entry * phraseEntry;
-        class Gtk::Entry * notEntry;
         class Gtk::ComboBox * languageCombobox;
         class Gtk::Entry * andEntry;
+        class Gtk::ComboBox * labelFilterCombobox;
         class Gtk::Notebook * queryNotebook;
         
         queryDialog_glade();



From fabricecolin at berlios.de  Thu Dec 15 15:56:46 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Thu, 15 Dec 2005 15:56:46 +0100
Subject: [Pinot-svn] r10 - trunk/SQL
Message-ID: <200512151456.jBFEukdj001113@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-15 15:56:45 +0100 (Thu, 15 Dec 2005)
New Revision: 10

Removed:
   trunk/SQL/LabelManager.cpp
   trunk/SQL/LabelManager.h
Log:
Obsolete.


Deleted: trunk/SQL/LabelManager.cpp
===================================================================
--- trunk/SQL/LabelManager.cpp	2005-12-15 14:46:50 UTC (rev 9)
+++ trunk/SQL/LabelManager.cpp	2005-12-15 14:56:45 UTC (rev 10)
@@ -1,350 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <iostream>
-
-#include "Url.h"
-#include "TimeConverter.h"
-#include "LabelManager.h"
-
-LabelManager::LabelManager(const string &database) :
-	SQLiteBase(database)
-{
-}
-
-LabelManager::~LabelManager()
-{
-}
-
-unsigned int LabelManager::getLabelId(const string &labelName) const
-{
-	unsigned int labelId = 0;
-
-	// Get the label ID
-	SQLiteResults *results = executeStatement("SELECT LabelId 	FROM IndexLabels WHERE Name='%q';",
-		labelName.c_str());
-	if (results != NULL)
-	{
-		SQLiteRow *row =results->nextRow();
-		if (row != NULL)
-		{
-			labelId = (unsigned int)atoi(row->getColumn(0).c_str());
-
-			delete row;
-		}
-
-		delete results;
-	}
-
-	return labelId;
-}
-
-unsigned int LabelManager::getNewLabelId(void) const
-{
-	unsigned int labelId = 1;
-
-	// Get the label ID
-	SQLiteResults *results = executeStatement("SELECT ROWID FROM IndexLabels \
-		ORDER BY ROWID DESC LIMIT 1;");
-	if (results != NULL)
-	{
-		SQLiteRow *row =results->nextRow();
-		if (row != NULL)
-		{
-			labelId = (unsigned int)atoi(row->getColumn(0).c_str());
-			++labelId;
-
-			delete row;
-		}
-
-		delete results;
-	}
-
-	return labelId;
-}
-
-/// Creates the necessary tables in the database.
-bool LabelManager::create(const string &database)
-{
-	bool success = true;
-
-	// The specified path must be a file
-	if (SQLiteBase::check(database) == false)
-	{
-		return false;
-	}
-
-	SQLiteBase db(database);
-
-	// Does IndexLabels exist ?
-	if (db.executeSimpleStatement("SELECT * FROM IndexLabels LIMIT 1;") == false)
-	{
-#ifdef DEBUG
-		cout << "LabelManager::create: IndexLabels doesn't exist" << endl;
-#endif
-		// Create the table
-		if (db.executeSimpleStatement("CREATE TABLE IndexLabels \
-			(LabelId BIGINT UNSIGNED NOT NULL PRIMARY KEY, Name VARCHAR(255));") == false)
-		{
-			success = false;
-		}
-	}
-	// Does DocumentLabels exist ?
-	if (db.executeSimpleStatement("SELECT * FROM DocumentLabels LIMIT 1;") == false)
-	{
-#ifdef DEBUG
-		cout << "LabelManager::create: DocumentLabels doesn't exist" << endl;
-#endif
-		// Create the table
-		if (db.executeSimpleStatement("CREATE TABLE DocumentLabels \
-			(LabelId BIGINT UNSIGNED NOT NULL, DocId BIGINT UNSIGNED NOT NULL, \
-			Source VARCHAR(255), PRIMARY KEY(LabelId, DocId, Source));") == false)
-		{
-			success = false;
-		}
-	}
-
-	return success;
-}
-
-/// Gets a list of items with the given label.
-bool LabelManager::getDocumentsWithLabel(const string &labelName, const string &sourceName,
-	set<unsigned int> &items) const
-{
-	bool success = false;
-
-	unsigned int labelId = getLabelId(labelName);
-	if (labelId == 0)
-	{
-		// Label was not found
-		return false;
-	}
-
-	SQLiteResults *results = executeStatement("SELECT DocId FROM DocumentLabels \
-		WHERE LabelId=%u AND Source='%q';",
-		labelId, sourceName.c_str());
-	if (results != NULL)
-	{
-		while (results->hasMoreRows() == true)
-		{
-			SQLiteRow *row =results->nextRow();
-			if (row == NULL)
-			{
-				break;
-			}
-
-			unsigned int docId = (unsigned int)atoi(row->getColumn(0).c_str());
-#ifdef DEBUG
-			cout << "LabelManager::getDocumentsWithLabel: item " << docId << endl;
-#endif
-			items.insert(docId);
-			success = true;
-
-			delete row;
-		}
-
-		delete results;
-	}
-
-	return success;
-}
-
-/// Checks if a document has a label.
-bool LabelManager::hasLabel(unsigned int docId, const string &sourceName,
-	const string &labelName) const
-{
-	bool success = false;
-
-	unsigned int labelId = getLabelId(labelName);
-	if (labelId == 0)
-	{
-		// Label was not found
-		return false;
-	}
-
-	SQLiteResults *results = executeStatement("SELECT DocId FROM DocumentLabels \
-		WHERE LabelId=%u AND DocId=%u AND Source='%q';",
-		labelId, docId, sourceName.c_str());
-	if (results != NULL)
-	{
-		SQLiteRow *row =results->nextRow();
-		if (row != NULL)
-		{
-			// Yes, this document has the given label
-			success = true;
-
-			delete row;
-		}
-
-		delete results;
-	}
-
-	return success;
-}
-
-/// Sets a document's labels.
-bool LabelManager::setLabels(unsigned int docId, const string &sourceName,
-	const set<string> &labels)
-{
-	bool success = false;
-
-	// First off, delete all labels for this document
-	SQLiteResults *results = executeStatement("DELETE FROM DocumentLabels \
-		WHERE DocId=%u AND Source='%q';",
-		docId, sourceName.c_str());
-	if (results == NULL)
-	{
-		return false;
-	}
-	delete results;
-
-	for (set<string>::const_iterator iter = labels.begin(); iter != labels.end(); ++iter)
-	{
-		string labelName = (*iter);
-
-#ifdef DEBUG
-		cout << "LabelManager::setLabels: label " << labelName << endl;
-#endif
-		// Does this label exist ?
-		unsigned int labelId = getLabelId(labelName);
-		if (labelId == 0)
-		{
-			// No, it doesn't : create it then
-			labelId = getNewLabelId();
-			results = executeStatement("INSERT INTO IndexLabels VALUES(%u, '%q');",
-				labelId, labelName.c_str());
-			if (results == NULL)
-			{
-#ifdef DEBUG
-				cout << "LabelManager::setLabels: couldn't create label " << labelName << endl;
-#endif
-				continue;
-			}
-			delete results;
-		}
-
-		// Insert this label
-		SQLiteResults *results = executeStatement("INSERT INTO DocumentLabels VALUES(%u, %u, '%q');",
-			labelId, docId, sourceName.c_str());
-		if (results != NULL)
-		{
-			delete results;
-		}
-	}
-
-	return true;
-}
-
-/// Gets the labels for the given document.
-bool LabelManager::getLabels(unsigned int docId, const string &sourceName,
-	set<string> &labels) const
-{
-	bool success = false;
-
-	SQLiteResults *results = executeStatement("SELECT i.Name FROM IndexLabels i, \
-		DocumentLabels d WHERE d.LabelId=i.LabelId AND d.DocId=%u AND d.Source='%q';",
-		docId, sourceName.c_str());
-	if (results != NULL)
-	{
-		while (results->hasMoreRows() == true)
-		{
-			SQLiteRow *row = results->nextRow();
-			if (row == NULL)
-			{
-				break;
-			}
-
-			string labelName = row->getColumn(0);
-#ifdef DEBUG
-			cout << "LabelManager::getLabels: label " << labelName << endl;
-#endif
-			labels.insert(labelName);
-			success = true;
-
-			delete row;
-		}
-
-		delete results;
-	}
-
-	return success;
-}
-
-/// Renames a label.
-bool LabelManager::renameLabel(const string &name, const string &newName)
-{
-	bool success = false;
-
-	SQLiteResults *results = executeStatement("UPDATE IndexLabels SET Name='%q' \
-		WHERE Name='%q';",
-		newName.c_str(), name.c_str());
-	if (results != NULL)
-	{
-		success = true;
-		delete results;
-	}
-#ifdef DEBUG
-	cout << "LabelManager::renameLabel: renamed " << name << " to " << newName << endl;
-#endif
-
-	return success;
-}
-
-/// Deletes all references to a label.
-bool LabelManager::deleteLabel(const string &name)
-{
-	bool success = false;
-
-	unsigned int labelId = getLabelId(name);
-	if (labelId == 0)
-	{
-		// Nothing to delete
-		return true;
-	}
-
-	// Delete from both IndexLabels and DocumentLabels
-	SQLiteResults *results = executeStatement("DELETE FROM DocumentLabels \
-		WHERE LabelId=%u; DELETE FROM IndexLabels WHERE LabelId=%u;",
-		labelId, labelId);
-	if (results != NULL)
-	{
-		success = true;
-		delete results;
-	}
-
-	return success;
-}
-
-/// Deletes an item.
-bool LabelManager::deleteItem(unsigned int docId, const string &sourceName)
-{
-	bool success = false;
-
-	// Delete from both IndexHistory and DocumentLabels
-	SQLiteResults *results = executeStatement("DELETE FROM DocumentLabels WHERE DocId=%u \
-		AND Source='%q';",
-		docId, sourceName.c_str());
-	if (results != NULL)
-	{
-		success = true;
-		delete results;
-	}
-
-	return success;
-}

Deleted: trunk/SQL/LabelManager.h
===================================================================
--- trunk/SQL/LabelManager.h	2005-12-15 14:46:50 UTC (rev 9)
+++ trunk/SQL/LabelManager.h	2005-12-15 14:56:45 UTC (rev 10)
@@ -1,74 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _LABEL_MANAGER_H
-#define _LABEL_MANAGER_H
-
-#include <string>
-#include <map>
-#include <set>
-
-#include "DocumentInfo.h"
-#include "SQLiteBase.h"
-
-using namespace std;
-
-class LabelManager : public SQLiteBase
-{
-	public:
-		LabelManager(const string &database);
-		virtual ~LabelManager();
-
-		/// Creates the necessary tables in the database.
-		static bool create(const string &database);
-
-		/// Gets a list of items with the given label.
-		bool getDocumentsWithLabel(const string &labelName, const string &sourceName,
-			set<unsigned int> &items) const;
-
-		/// Checks if a document has a label.
-		bool hasLabel(unsigned int docId, const string &sourceName,
-			const string &labelName) const;
-
-		/// Sets a document's labels.
-		bool setLabels(unsigned int docId, const string &sourceName,
-			const set<string> &labels);
-
-		/// Gets the labels for the given document.
-		bool getLabels(unsigned int docId, const string &sourceName,
-			set<string> &labels) const;
-
-		/// Renames a label.
-		bool renameLabel(const string &name, const string &newName);
-
-		/// Deletes all references to a label.
-		bool deleteLabel(const string &name);
-
-		/// Deletes an item.
-		bool deleteItem(unsigned int docId, const string &sourceName);
-
-	protected:
-		unsigned int getLabelId(const string &labelName) const;
-
-		unsigned int getNewLabelId(void) const;
-
-	private:
-		LabelManager(const LabelManager &other);
-		LabelManager &operator=(const LabelManager &other);
-
-};
-
-#endif // _LABEL_MANAGER_H



From fabricecolin at berlios.de  Thu Dec 15 17:49:31 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Thu, 15 Dec 2005 17:49:31 +0100
Subject: [Pinot-svn] r11 - in trunk: Index SQL Search
Message-ID: <200512151649.jBFGnVFL016454@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-15 17:49:31 +0100 (Thu, 15 Dec 2005)
New Revision: 11

Removed:
   trunk/SQL/IndexHistory.cpp
   trunk/SQL/IndexHistory.h
Modified:
   trunk/Index/XapianIndex.cpp
   trunk/Index/XapianIndex.h
   trunk/SQL/Makefile
   trunk/SQL/historytest.cpp
   trunk/Search/QueryProperties.cpp
Log:
Second step : got rid of IndexHistory and rely exclusively on the index. 


Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2005-12-15 14:56:45 UTC (rev 10)
+++ trunk/Index/XapianIndex.cpp	2005-12-15 16:49:31 UTC (rev 11)
@@ -42,8 +42,7 @@
 
 XapianIndex::XapianIndex(const string &indexName) :
 	IndexInterface(),
-	m_databaseName(indexName),
-	m_pHistory(NULL)
+	m_databaseName(indexName)
 {
 
 	string historyFile = indexName;
@@ -51,20 +50,14 @@
 
 	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
 	if ((pDatabase != NULL) &&
-		(pDatabase->isOpen() == true) &&
-		(IndexHistory::create(historyFile) == true))
+		(pDatabase->isOpen() == true))
 	{
-		m_pHistory = new IndexHistory(historyFile);
 		m_goodIndex = true;
 	}
 }
 
 XapianIndex::~XapianIndex()
 {
-	if (m_pHistory != NULL)
-	{
-		delete m_pHistory;
-	}
 }
 
 void XapianIndex::addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,
@@ -125,7 +118,7 @@
 	Xapian::termcount &termPos, const std::string &summary) const
 {
 	// Add a magic term :-)
-	doc.add_posting(MAGIC_TERM, termPos++);
+	doc.add_term(MAGIC_TERM);
 
 	// Index the title with and without prefix T
 	string title = info.getTitle();
@@ -139,16 +132,11 @@
 		addTermsToDocument(titleTokens, doc, "", termPos, m_stemMode);
 	}
 
-	// Index the full URL with prefix U
 	string location = info.getLocation();
-	for (string::iterator i = location.begin(); i != location.end(); i++)
-	{
-		*i = tolower(*i);
-	}
-	doc.add_posting(string("U") + location, termPos++);
-
 	Url urlObj(location);
 
+	// Index the full URL with prefix U
+	doc.add_term(string("U") + location);
 	// ...the host name with prefix H
 	string hostName = urlObj.getHost();
 	doc.add_term(string("H") + StringManip::toLowerCase(hostName));
@@ -278,8 +266,7 @@
 	bool indexed = false;
 
 	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if ((pDatabase == NULL) ||
-		(m_pHistory == NULL))
+	if (pDatabase == NULL)
 	{
 		cerr << "Bad index " << m_databaseName << endl;
 		return false;
@@ -334,8 +321,6 @@
 			{
 				// Add this document to the Xapian index
 				docId = pIndex->add_document(doc);
-				// Add an entry in the history file
-				m_pHistory->insertItem(docId, docInfo);
 				indexed = true;
 			}
 			pDatabase->unlock();
@@ -356,12 +341,51 @@
 /// Returns a document's properties.
 bool XapianIndex::getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const
 {
-	if (m_pHistory == NULL)
+	bool foundDocument = false;
+
+	if (docId == 0)
 	{
 		return false;
 	}
 
-	return m_pHistory->getItem(docId, docInfo);
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::Database *pIndex = pDatabase->readLock();
+		if (pIndex != NULL)
+		{
+			Xapian::Document doc = pIndex->get_document(docId);
+
+			// Get the current document data
+			string record = doc.get_data();
+			if (record.empty() == false)
+			{
+				docInfo = DocumentInfo(StringManip::extractField(record, "caption=", "\n"),
+					StringManip::extractField(record, "url=", "\n"),
+					StringManip::extractField(record, "type=", "\n"),
+					StringManip::extractField(record, "language=", "\n"));
+				docInfo.setTimestamp(StringManip::extractField(record, "timestamp=", "\n"));
+				foundDocument = true;
+			}
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't get document properties: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't get document properties, unknown exception occured" << endl;
+	}
+
+	return foundDocument;
 }
 
 /// Returns a document's labels.
@@ -557,24 +581,20 @@
 			string extract = StringManip::extractField(record, "sample=", "\n");
 			string language = StringManip::extractField(record, "language=", "\n");
 
-			// Update the document data with the new extract
+			// Update the document data with the current extract and language
 			setDocumentData(doc, docInfo, extract, language);
-			// Update the document
-			if (m_pHistory->updateItem(docId, docInfo) == true)
-			{
-				pIndex->replace_document(docId, doc);
-				updated = true;
-			}
+			pIndex->replace_document(docId, doc);
+			updated = true;
 		}
 		pDatabase->unlock();
 	}
 	catch (const Xapian::Error &error)
 	{
-		cerr << "Couldn't update document: " << error.get_msg() << endl;
+		cerr << "Couldn't update document properties: " << error.get_msg() << endl;
 	}
 	catch (...)
 	{
-		cerr << "Couldn't update document, unknown exception occured" << endl;
+		cerr << "Couldn't update document properties, unknown exception occured" << endl;
 	}
 
 	return updated;
@@ -641,13 +661,44 @@
 /// Checks whether the given URL is in the index.
 unsigned int XapianIndex::hasDocument(const string &url) const
 {
-	if (m_pHistory == NULL)
+	unsigned int docId = 0;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
 	{
+		cerr << "Bad index " << m_databaseName << endl;
 		return 0;
 	}
 
-	// Is this URL in the history file ?
-	return m_pHistory->hasURL(url);
+	try
+	{
+		Xapian::Database *pIndex = pDatabase->readLock();
+		if (pIndex != NULL)
+		{
+			string term("U");
+
+			// Get documents that have this term
+			term += url;
+			Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
+			if (postingIter != pIndex->postlist_end(term))
+			{
+				// This URL was indexed
+				docId = *postingIter;
+			}
+			// FIXME: what if the term exist in more than one document ?
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't delete label: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't delete label, unknown exception occured" << endl;
+	}
+
+	return docId;
 }
 
 /// Unindexes the given document; true if success.
@@ -661,8 +712,7 @@
 	}
 
 	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if ((pDatabase == NULL) ||
-		(m_pHistory == NULL))
+	if (pDatabase == NULL)
 	{
 		cerr << "Bad index " << m_databaseName << endl;
 		return false;
@@ -675,8 +725,6 @@
 		{
 			// Delete the document from the index
 			pIndex->delete_document(docId);
-			// Remove the entry from the history file
-			m_pHistory->deleteItem(docId);
 			unindexed = true;
 		}
 		pDatabase->unlock();
@@ -704,8 +752,7 @@
 	}
 
 	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
-	if ((pDatabase == NULL) ||
-		(m_pHistory == NULL))
+	if (pDatabase == NULL)
 	{
 		cerr << "Bad index " << m_databaseName << endl;
 		return false;
@@ -721,8 +768,6 @@
 			// Delete documents from the index
 			term += labelName;
 			pIndex->delete_document(term);
-			// FIXME: remove entries from the history file
-			//m_pHistory->deleteItem(docId);
 			unindexed = true;
 		}
 		pDatabase->unlock();
@@ -911,15 +956,49 @@
 }
 
 /// Returns a list of document IDs.
-unsigned int XapianIndex::getDocumentIDs(set<unsigned int> &docIDList,
+unsigned int XapianIndex::getDocumentIDs(set<unsigned int> &docIds,
 	unsigned int maxDocsCount, unsigned int startDoc, bool sortByDate) const
 {
-	if (m_pHistory == NULL)
+	unsigned int docCount = 0;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
 	{
+		cerr << "Bad index " << m_databaseName << endl;
 		return 0;
 	}
 
-	docIDList.clear();
+	docIds.clear();
+	try
+	{
+		Xapian::Database *pIndex = pDatabase->readLock();
+		if (pIndex != NULL)
+		{
+			// Get a list of documents that have the magic term
+			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(MAGIC_TERM);
+				(postingIter != pIndex->postlist_end(MAGIC_TERM)) && (docCount < maxDocsCount);
+				++postingIter)
+			{
+				Xapian::docid docId = *postingIter;
 
-	return m_pHistory->listItems(docIDList, maxDocsCount, startDoc, sortByDate);
+				// We cannot use postingIter->skip_to() because startDoc isn't an ID
+				if (docCount >= startDoc)
+				{
+					docIds.insert(docId);
+				}
+				++docCount;
+			}
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't get document list: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't get document list, unknown exception occured" << endl;
+	}
+
+	return docIds.size();
 }

Modified: trunk/Index/XapianIndex.h
===================================================================
--- trunk/Index/XapianIndex.h	2005-12-15 14:56:45 UTC (rev 10)
+++ trunk/Index/XapianIndex.h	2005-12-15 16:49:31 UTC (rev 11)
@@ -23,7 +23,6 @@
 #include <xapian.h>
 
 #include "DocumentInfo.h"
-#include "IndexHistory.h"
 #include "IndexInterface.h"
 
 class XapianIndex : public IndexInterface
@@ -80,7 +79,7 @@
 		virtual unsigned int getDocumentsCount(void) const;
 
 		/// Returns a list of document IDs.
-		virtual unsigned int getDocumentIDs(std::set<unsigned int> &docIDList,
+		virtual unsigned int getDocumentIDs(std::set<unsigned int> &docIds,
 			unsigned int maxDocsCount = 0, unsigned int startDoc = 0,
 			bool sortByDate = false) const;
 
@@ -88,7 +87,6 @@
 		static const unsigned int m_maxTermLength;
 		static const std::string MAGIC_TERM;
 		std::string m_databaseName;
-		IndexHistory *m_pHistory;
 		std::string m_stemLanguage;
 
 		void addTermsToDocument(Tokenizer &tokens, Xapian::Document &doc,

Deleted: trunk/SQL/IndexHistory.cpp
===================================================================
--- trunk/SQL/IndexHistory.cpp	2005-12-15 14:56:45 UTC (rev 10)
+++ trunk/SQL/IndexHistory.cpp	2005-12-15 16:49:31 UTC (rev 11)
@@ -1,246 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <iostream>
-
-#include "Url.h"
-#include "TimeConverter.h"
-#include "IndexHistory.h"
-
-IndexHistory::IndexHistory(const string &database) :
-	SQLiteBase(database)
-{
-}
-
-IndexHistory::~IndexHistory()
-{
-}
-
-/// Creates the necessary tables in the database.
-bool IndexHistory::create(const string &database)
-{
-	bool success = true;
-
-	// The specified path must be a file
-	if (SQLiteBase::check(database) == false)
-	{
-		return false;
-	}
-
-	SQLiteBase db(database);
-
-	// Does IndexHistory exist ?
-	if (db.executeSimpleStatement("SELECT * FROM IndexHistory LIMIT 1;") == false)
-	{
-#ifdef DEBUG
-		cout << "IndexHistory::create: IndexHistory doesn't exist" << endl;
-#endif
-		// Create the table
-		if (db.executeSimpleStatement("CREATE TABLE IndexHistory \
-			(DocId BIGINT UNSIGNED NOT NULL PRIMARY KEY, Title VARCHAR(255), \
-			Url VARCHAR(255), Type VARCHAR(255), Language VARCHAR(255), \
-			Date TIMESTAMP, Status INT);") == false)
-		{
-			success = false;
-		}
-	}
-
-	return success;
-}
-
-/// Inserts an item.
-bool IndexHistory::insertItem(unsigned int docId, const DocumentInfo &docInfo)
-{
-	bool success = false;
-
-	// FIXME: make Status configurable
-	SQLiteResults *results = executeStatement("INSERT INTO IndexHistory \
-		VALUES(%u, '%q', '%q', '%q', '%q', '%d', 1);",
-		docId, docInfo.getTitle().c_str(), Url::escapeUrl(docInfo.getLocation()).c_str(),
-		docInfo.getType().c_str(), docInfo.getLanguage().c_str(),
-		TimeConverter::fromTimestamp(docInfo.getTimestamp()));
-	if (results != NULL)
-	{
-		success = true;
-		delete results;
-	}
-
-	return success;
-}
-
-/// Checks if an URL is in the history; returns the document ID.
-unsigned int IndexHistory::hasURL(const string &originalUrl) const
-{
-	unsigned int docId = 0;
-
-	SQLiteResults *results = executeStatement("SELECT DocId FROM IndexHistory \
-		WHERE Url='%q';",
-		Url::escapeUrl(originalUrl).c_str());
-	if (results != NULL)
-	{
-		SQLiteRow *row = results->nextRow();
-		if (row != NULL)
-		{
-			docId = (unsigned int)atoi(row->getColumn(0).c_str());
-
-			delete row;
-		}
-
-		delete results;
-	}
-
-	return docId;
-}
-
-/// Updates an item.
-bool IndexHistory::updateItem(unsigned int docId, const DocumentInfo &docInfo)
-{
-	bool success = false;
-
-	// FIXME: make Status configurable
-	SQLiteResults *results = executeStatement("UPDATE IndexHistory \
-		SET Title='%q', Url='%q', Type='%q', Language='%q', Date='%d' \
-		WHERE DocId=%u;",
-		docInfo.getTitle().c_str(), Url::escapeUrl(docInfo.getLocation()).c_str(),
-		docInfo.getType().c_str(), docInfo.getLanguage().c_str(),
-		TimeConverter::fromTimestamp(docInfo.getTimestamp()), docId);
-	if (results != NULL)
-	{
-		success = true;
-		delete results;
-	}
-
-	return success;
-}
-
-/// Lists document IDs; returns the total count.
-unsigned int IndexHistory::listItems(set<unsigned int> &items,
-	unsigned int maxDocsCount, unsigned int startDoc,
-	bool sortByDate) const
-{
-	string sql;
-	unsigned int total = 0;
-
-	sql = "SELECT DocId FROM IndexHistory";
-	if (sortByDate == true)
-	{
-		sql += " ORDER BY Date";
-	}
-	if (maxDocsCount > 0)
-	{
-		char docsCountStr[64];
-
-		sql += " LIMIT ";
-		if (startDoc > 0)
-		{
-			snprintf(docsCountStr, 64, "%u", startDoc);
-			sql += docsCountStr;
-			sql += ",";
-		}
-		snprintf(docsCountStr, 64, "%u", maxDocsCount);
-		sql += docsCountStr;
-	}
-	sql += ";";
-	SQLiteResults *results = executeStatement(sql.c_str());
-	if (results != NULL)
-	{
-		while (results->hasMoreRows() == true)
-		{
-			SQLiteRow *row = results->nextRow();
-			if (row == NULL)
-			{
-				break;
-			}
-
-			unsigned int docId = (unsigned int)atoi(row->getColumn(0).c_str());
-#ifdef DEBUG
-			cout << "IndexHistory::listItems: item " << docId << endl;
-#endif
-			items.insert(docId);
-			total++;
-
-			delete row;
-		}
-
-		delete results;
-	}
-
-	return total;
-}
-
-/// Gets an item's properties.
-bool IndexHistory::getItem(unsigned int docId, DocumentInfo &docInfo) const
-{
-	bool success = false;
-
-	SQLiteResults *results = executeStatement("SELECT Title, Url, Type, \
-		Language, Date FROM IndexHistory WHERE DocId=%u;", docId);
-	if (results != NULL)
-	{
-		SQLiteRow *row =results->nextRow();
-		if (row != NULL)
-		{
-			docInfo.setTitle(row->getColumn(0));
-			docInfo.setLocation(Url::unescapeUrl(row->getColumn(1)));
-			docInfo.setType(row->getColumn(2));
-			docInfo.setLanguage(row->getColumn(3));
-			docInfo.setTimestamp(TimeConverter::toTimestamp(atoi(row->getColumn(4).c_str())));
-			success = true;
-
-			delete row;
-		}
-
-		delete results;
-	}
-
-	return success;
-}
-
-/// Deletes items.
-bool IndexHistory::deleteByURL(const string &originalUrl)
-{
-	bool success = false;
-
-	SQLiteResults *results = executeStatement("DELETE FROM IndexHistory WHERE Url='%q';",
-		Url::escapeUrl(originalUrl).c_str());
-	if (results != NULL)
-	{
-		success = true;
-		delete results;
-	}
-
-	return success;
-}
-
-/// Deletes an item.
-bool IndexHistory::deleteItem(unsigned int docId)
-{
-	bool success = false;
-
-	// Delete from both IndexHistory and DocumentLabels
-	SQLiteResults *results = executeStatement("DELETE FROM IndexHistory WHERE DocId=%u;",
-		docId);
-	if (results != NULL)
-	{
-		success = true;
-		delete results;
-	}
-
-	return success;
-}

Deleted: trunk/SQL/IndexHistory.h
===================================================================
--- trunk/SQL/IndexHistory.h	2005-12-15 14:56:45 UTC (rev 10)
+++ trunk/SQL/IndexHistory.h	2005-12-15 16:49:31 UTC (rev 11)
@@ -1,67 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _INDEX_HISTORY_H
-#define _INDEX_HISTORY_H
-
-#include <string>
-#include <map>
-#include <set>
-
-#include "DocumentInfo.h"
-#include "SQLiteBase.h"
-
-using namespace std;
-
-class IndexHistory : public SQLiteBase
-{
-	public:
-		IndexHistory(const string &database);
-		virtual ~IndexHistory();
-
-		/// Creates the necessary tables in the database.
-		static bool create(const string &database);
-
-		/// Inserts an item.
-		bool insertItem(unsigned int docId, const DocumentInfo &docInfo);
-
-		/// Checks if an URL is in the history; returns the document ID.
-		unsigned int hasURL(const string &originalUrl) const;
-
-		/// Updates an item.
-		bool updateItem(unsigned int docId, const DocumentInfo &docInfo);
-
-		/// Lists document IDs; returns the total count.
-		unsigned int listItems(set<unsigned int> &items,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0,
-			bool sortByDate = false) const;
-
-		/// Gets an item's properties.
-		bool getItem(unsigned int docId, DocumentInfo &docInfo) const;
-
-		/// Deletes items.
-		bool deleteByURL(const string &originalUrl);
-
-		/// Deletes an item.
-		bool deleteItem(unsigned int docId);
-
-	private:
-		IndexHistory(const IndexHistory &other);
-		IndexHistory &operator=(const IndexHistory &other);
-
-};
-
-#endif // _INDEX_HISTORY_H

Modified: trunk/SQL/Makefile
===================================================================
--- trunk/SQL/Makefile	2005-12-15 14:56:45 UTC (rev 10)
+++ trunk/SQL/Makefile	2005-12-15 16:49:31 UTC (rev 11)
@@ -2,8 +2,7 @@
 ROOT_DIR = ..
 include ${ROOT_DIR}/variables.mk
 
-SQL_SRCS = SQLiteBase.cpp ActionHistory.cpp IndexHistory.cpp \
-	QueryHistory.cpp ViewHistory.cpp
+SQL_SRCS = SQLiteBase.cpp ActionHistory.cpp QueryHistory.cpp ViewHistory.cpp
 SQL_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${SQL_SRCS})
 SQL_TEST = ${BIN_DIR}/historytest
 

Modified: trunk/SQL/historytest.cpp
===================================================================
--- trunk/SQL/historytest.cpp	2005-12-15 14:56:45 UTC (rev 10)
+++ trunk/SQL/historytest.cpp	2005-12-15 16:49:31 UTC (rev 11)
@@ -17,7 +17,6 @@
 #include <iostream>
 
 #include "ActionHistory.h"
-#include "IndexHistory.h"
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 
@@ -27,14 +26,13 @@
 {
 	if (argc < 3)
 	{
-		cerr << "Usage: " << argv[0] << " <database> CREATE|CHECK=<url>|LISTACTIONS=<max>" << endl;
+		cerr << "Usage: " << argv[0] << " <database> CREATE|LISTACTIONS=<max>" << endl;
 		return EXIT_FAILURE;
 	}
 
 	if (strncmp(argv[2], "CREATE", 6) == 0)
 	{
 		if ((ActionHistory::create(argv[1]) == true) &&
-			(IndexHistory::create(argv[1]) == true) &&
 			(QueryHistory::create(argv[1]) == true) &&
 			(ViewHistory::create(argv[1]) == true))
 		{
@@ -45,19 +43,6 @@
 			cout << "Couldn't create database " << argv[1] << endl;
 		}
 	}
-	else if (strncmp(argv[2], "CHECK=", 6) == 0)
-	{
-		IndexHistory history(argv[1]);
-
-		if (history.hasURL(argv[2] + 6) > 0)
-		{
-			cout << "URL exists in IndexHistory" << endl;
-		}
-		else
-		{
-			cout << "URL doesn't exist in IndexHistory" << endl;
-		}
-	}
 	else if (strncmp(argv[2], "LISTACTIONS=", 12) == 0)
 	{
 		ActionHistory actions(argv[1]);

Modified: trunk/Search/QueryProperties.cpp
===================================================================
--- trunk/Search/QueryProperties.cpp	2005-12-15 14:56:45 UTC (rev 10)
+++ trunk/Search/QueryProperties.cpp	2005-12-15 16:49:31 UTC (rev 11)
@@ -276,7 +276,7 @@
 		replace(tmp.begin(), tmp.end(), ' ', '-');
 		if (queryString.empty() == false)
 		{
-			queryString += "-";
+			queryString += " -";
 		}
 		queryString += tmp;
 		queryString += " ";



From fabricecolin at berlios.de  Thu Dec 15 17:50:35 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Thu, 15 Dec 2005 17:50:35 +0100
Subject: [Pinot-svn] r12 - in trunk/UI/GTK2: . src
Message-ID: <200512151650.jBFGoZM2016602@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-15 17:50:35 +0100 (Thu, 15 Dec 2005)
New Revision: 12

Modified:
   trunk/UI/GTK2/metase-gtk2.glade
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/mainWindow.hh
   trunk/UI/GTK2/src/mainWindow_glade.cc
   trunk/UI/GTK2/src/mainWindow_glade.hh
Log:
In the index tab, dropped the First and Last buttons.


Modified: trunk/UI/GTK2/metase-gtk2.glade
===================================================================
--- trunk/UI/GTK2/metase-gtk2.glade	2005-12-15 16:49:31 UTC (rev 11)
+++ trunk/UI/GTK2/metase-gtk2.glade	2005-12-15 16:50:35 UTC (rev 12)
@@ -907,48 +907,76 @@
 			      <property name="spacing">0</property>
 
 			      <child>
-				<widget class="GtkButton" id="indexFirstButton">
+				<widget class="GtkButton" id="indexBackButton">
 				  <property agent="glademm" name="cxx_visibility">protected</property>
 				  <property name="visible">True</property>
 				  <property name="can_default">True</property>
 				  <property name="can_focus">True</property>
 				  <property name="relief">GTK_RELIEF_NORMAL</property>
 				  <property name="focus_on_click">True</property>
-				  <signal name="clicked" handler="on_indexFirstButton_clicked" last_modification_time="Tue, 05 Jul 2005 13:26:37 GMT"/>
+				  <signal name="clicked" handler="on_indexBackButton_clicked" last_modification_time="Tue, 05 Jul 2005 13:26:43 GMT"/>
 
 				  <child>
-				    <widget class="GtkImage" id="image478">
+				    <widget class="GtkAlignment" id="alignment31">
 				      <property name="visible">True</property>
-				      <property name="stock">gtk-goto-first</property>
-				      <property name="icon_size">4</property>
 				      <property name="xalign">0.5</property>
 				      <property name="yalign">0.5</property>
-				      <property name="xpad">0</property>
-				      <property name="ypad">0</property>
-				    </widget>
-				  </child>
-				</widget>
-			      </child>
+				      <property name="xscale">0</property>
+				      <property name="yscale">0</property>
+				      <property name="top_padding">0</property>
+				      <property name="bottom_padding">0</property>
+				      <property name="left_padding">0</property>
+				      <property name="right_padding">0</property>
 
-			      <child>
-				<widget class="GtkButton" id="indexBackButton">
-				  <property agent="glademm" name="cxx_visibility">protected</property>
-				  <property name="visible">True</property>
-				  <property name="can_default">True</property>
-				  <property name="can_focus">True</property>
-				  <property name="relief">GTK_RELIEF_NORMAL</property>
-				  <property name="focus_on_click">True</property>
-				  <signal name="clicked" handler="on_indexBackButton_clicked" last_modification_time="Tue, 05 Jul 2005 13:26:43 GMT"/>
+				      <child>
+					<widget class="GtkHBox" id="hbox45">
+					  <property name="visible">True</property>
+					  <property name="homogeneous">False</property>
+					  <property name="spacing">2</property>
 
-				  <child>
-				    <widget class="GtkImage" id="image479">
-				      <property name="visible">True</property>
-				      <property name="stock">gtk-go-back</property>
-				      <property name="icon_size">4</property>
-				      <property name="xalign">0.5</property>
-				      <property name="yalign">0.5</property>
-				      <property name="xpad">0</property>
-				      <property name="ypad">0</property>
+					  <child>
+					    <widget class="GtkImage" id="image521">
+					      <property name="visible">True</property>
+					      <property name="stock">gtk-media-rewind</property>
+					      <property name="icon_size">4</property>
+					      <property name="xalign">0.5</property>
+					      <property name="yalign">0.5</property>
+					      <property name="xpad">0</property>
+					      <property name="ypad">0</property>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">False</property>
+					      <property name="fill">False</property>
+					    </packing>
+					  </child>
+
+					  <child>
+					    <widget class="GtkLabel" id="label52">
+					      <property name="visible">True</property>
+					      <property name="label" translatable="yes">Show Previous</property>
+					      <property name="use_underline">True</property>
+					      <property name="use_markup">False</property>
+					      <property name="justify">GTK_JUSTIFY_LEFT</property>
+					      <property name="wrap">False</property>
+					      <property name="selectable">False</property>
+					      <property name="xalign">0.5</property>
+					      <property name="yalign">0.5</property>
+					      <property name="xpad">0</property>
+					      <property name="ypad">0</property>
+					      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+					      <property name="width_chars">-1</property>
+					      <property name="single_line_mode">False</property>
+					      <property name="angle">0</property>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">False</property>
+					      <property name="fill">False</property>
+					    </packing>
+					  </child>
+					</widget>
+				      </child>
 				    </widget>
 				  </child>
 				</widget>
@@ -965,38 +993,66 @@
 				  <signal name="clicked" handler="on_indexForwardButton_clicked" last_modification_time="Tue, 05 Jul 2005 13:26:48 GMT"/>
 
 				  <child>
-				    <widget class="GtkImage" id="image480">
+				    <widget class="GtkAlignment" id="alignment32">
 				      <property name="visible">True</property>
-				      <property name="stock">gtk-go-forward</property>
-				      <property name="icon_size">4</property>
 				      <property name="xalign">0.5</property>
 				      <property name="yalign">0.5</property>
-				      <property name="xpad">0</property>
-				      <property name="ypad">0</property>
-				    </widget>
-				  </child>
-				</widget>
-			      </child>
+				      <property name="xscale">0</property>
+				      <property name="yscale">0</property>
+				      <property name="top_padding">0</property>
+				      <property name="bottom_padding">0</property>
+				      <property name="left_padding">0</property>
+				      <property name="right_padding">0</property>
 
-			      <child>
-				<widget class="GtkButton" id="indexLastButton">
-				  <property agent="glademm" name="cxx_visibility">protected</property>
-				  <property name="visible">True</property>
-				  <property name="can_default">True</property>
-				  <property name="can_focus">True</property>
-				  <property name="relief">GTK_RELIEF_NORMAL</property>
-				  <property name="focus_on_click">True</property>
-				  <signal name="clicked" handler="on_indexLastButton_clicked" last_modification_time="Tue, 05 Jul 2005 13:26:54 GMT"/>
+				      <child>
+					<widget class="GtkHBox" id="hbox46">
+					  <property name="visible">True</property>
+					  <property name="homogeneous">False</property>
+					  <property name="spacing">2</property>
 
-				  <child>
-				    <widget class="GtkImage" id="image481">
-				      <property name="visible">True</property>
-				      <property name="stock">gtk-goto-last</property>
-				      <property name="icon_size">4</property>
-				      <property name="xalign">0.5</property>
-				      <property name="yalign">0.5</property>
-				      <property name="xpad">0</property>
-				      <property name="ypad">0</property>
+					  <child>
+					    <widget class="GtkImage" id="image522">
+					      <property name="visible">True</property>
+					      <property name="stock">gtk-media-forward</property>
+					      <property name="icon_size">4</property>
+					      <property name="xalign">0.5</property>
+					      <property name="yalign">0.5</property>
+					      <property name="xpad">0</property>
+					      <property name="ypad">0</property>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">False</property>
+					      <property name="fill">False</property>
+					    </packing>
+					  </child>
+
+					  <child>
+					    <widget class="GtkLabel" id="label53">
+					      <property name="visible">True</property>
+					      <property name="label" translatable="yes">Show Next</property>
+					      <property name="use_underline">True</property>
+					      <property name="use_markup">False</property>
+					      <property name="justify">GTK_JUSTIFY_LEFT</property>
+					      <property name="wrap">False</property>
+					      <property name="selectable">False</property>
+					      <property name="xalign">0.5</property>
+					      <property name="yalign">0.5</property>
+					      <property name="xpad">0</property>
+					      <property name="ypad">0</property>
+					      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+					      <property name="width_chars">-1</property>
+					      <property name="single_line_mode">False</property>
+					      <property name="angle">0</property>
+					    </widget>
+					    <packing>
+					      <property name="padding">0</property>
+					      <property name="expand">False</property>
+					      <property name="fill">False</property>
+					    </packing>
+					  </child>
+					</widget>
+				      </child>
 				    </widget>
 				  </child>
 				</widget>

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-15 16:49:31 UTC (rev 11)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-15 16:50:35 UTC (rev 12)
@@ -293,10 +293,8 @@
 	//viewstop1->set_sensitive(false);
 	// ...and buttons
 	removeIndexButton->set_sensitive(false);
-	indexFirstButton->set_sensitive(false);
 	indexBackButton->set_sensitive(false);
 	indexForwardButton->set_sensitive(false);
-	indexLastButton->set_sensitive(false);
 
 	// Set focus on the query entry field
 	set_focus(*liveQueryEntry);
@@ -815,14 +813,6 @@
 		cout << "mainWindow::on_thread_end: " << m_state.m_indexDocsCount
 			<< " documents, starting at " << m_state.m_startDoc << endl;
 #endif
-		if (m_state.m_startDoc > 0)
-		{
-			indexFirstButton->set_sensitive(true);
-		}
-		else
-		{
-			indexFirstButton->set_sensitive(false);
-		}
 		if (m_state.m_startDoc >= m_maxDocsCount)
 		{
 			indexBackButton->set_sensitive(true);
@@ -839,14 +829,6 @@
 		{
 			indexForwardButton->set_sensitive(false);
 		}
-		if (m_state.m_indexDocsCount > m_state.m_startDoc + count)
-		{
-			indexLastButton->set_sensitive(true);
-		}
-		else
-		{
-			indexLastButton->set_sensitive(false);
-		}
 		m_state.m_browsingIndex = false;
 	}
 	else if (type == "QueryingThread")
@@ -1261,7 +1243,6 @@
 		++m_state.m_indexDocsCount;
 		// ...and make sure the user can display that last page
 		indexForwardButton->set_sensitive(true);
-		indexLastButton->set_sensitive(true);
 		return;
 	}
 
@@ -2093,15 +2074,6 @@
 }
 
 //
-// Index first button click
-//
-void mainWindow::on_indexFirstButton_clicked()
-{
-	m_state.m_startDoc = 0;
-	browse_index(m_state.m_startDoc);
-}
-
-//
 // Index back button click
 //
 void mainWindow::on_indexBackButton_clicked()
@@ -2131,18 +2103,6 @@
 }
 
 //
-// Index last button click
-//
-void mainWindow::on_indexLastButton_clicked()
-{
-	if (m_state.m_indexDocsCount >= m_state.m_startDoc + m_maxDocsCount)
-	{
-		m_state.m_startDoc = m_state.m_indexDocsCount - (m_state.m_indexDocsCount % m_maxDocsCount);
-		browse_index(m_state.m_startDoc);
-	}
-}
-
-//
 // Query list mouse click
 //
 bool mainWindow::on_queryTreeview_button_press_event(GdkEventButton *ev)

Modified: trunk/UI/GTK2/src/mainWindow.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow.hh	2005-12-15 16:49:31 UTC (rev 11)
+++ trunk/UI/GTK2/src/mainWindow.hh	2005-12-15 16:50:35 UTC (rev 12)
@@ -105,10 +105,8 @@
 
 	virtual void on_indexCombobox_changed();
 
-	virtual void on_indexFirstButton_clicked();
 	virtual void on_indexBackButton_clicked();
 	virtual void on_indexForwardButton_clicked();
-	virtual void on_indexLastButton_clicked();
 
 	virtual bool on_queryTreeview_button_press_event(GdkEventButton *ev);
 	virtual bool on_mainWindow_delete_event(GdkEventAny *ev);

Modified: trunk/UI/GTK2/src/mainWindow_glade.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-15 16:49:31 UTC (rev 11)
+++ trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-15 16:50:35 UTC (rev 12)
@@ -1,4 +1,4 @@
-// generated 2005/12/2 19:36:17 SGT by fabrice at amra.dyndns.org.(none)
+// generated 2005/12/16 0:48:33 SGT by fabrice at amra.dyndns.org.(none)
 // using glademm V2.6.0
 //
 // DO NOT EDIT THIS FILE ! It was created using
@@ -144,18 +144,18 @@
    Gtk::Label *resultsLabel = Gtk::manage(new class Gtk::Label(_("Results")));
    indexCombobox = Gtk::manage(new class Gtk::ComboBox());
    
-   Gtk::Image *image478 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-goto-first"), Gtk::IconSize(4)));
-   indexFirstButton = Gtk::manage(new class Gtk::Button());
-   
-   Gtk::Image *image479 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-go-back"), Gtk::IconSize(4)));
+   Gtk::Image *image521 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-media-rewind"), Gtk::IconSize(4)));
+   Gtk::Label *label52 = Gtk::manage(new class Gtk::Label(_("Show Previous")));
+   Gtk::HBox *hbox45 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment31 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
    indexBackButton = Gtk::manage(new class Gtk::Button());
    
-   Gtk::Image *image480 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-go-forward"), Gtk::IconSize(4)));
+   Gtk::Image *image522 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-media-forward"), Gtk::IconSize(4)));
+   Gtk::Label *label53 = Gtk::manage(new class Gtk::Label(_("Show Next")));
+   Gtk::HBox *hbox46 = Gtk::manage(new class Gtk::HBox(false, 2));
+   Gtk::Alignment *alignment32 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
    indexForwardButton = Gtk::manage(new class Gtk::Button());
    
-   Gtk::Image *image481 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-goto-last"), Gtk::IconSize(4)));
-   indexLastButton = Gtk::manage(new class Gtk::Button());
-   
    Gtk::HButtonBox *indexHbuttonbox = Gtk::manage(new class Gtk::HButtonBox(Gtk::BUTTONBOX_SPREAD, 0));
    Gtk::HBox *indexButtonsHbox = Gtk::manage(new class Gtk::HBox(false, 0));
    indexVbox = Gtk::manage(new class Gtk::VBox(false, 0));
@@ -375,34 +375,38 @@
    resultsLabel->set_line_wrap(false);
    resultsLabel->set_use_markup(false);
    resultsLabel->set_selectable(false);
-   image478->set_alignment(0.5,0.5);
-   image478->set_padding(0,0);
-   indexFirstButton->set_flags(Gtk::CAN_FOCUS);
-   indexFirstButton->set_flags(Gtk::CAN_DEFAULT);
-   indexFirstButton->set_relief(Gtk::RELIEF_NORMAL);
-   indexFirstButton->add(*image478);
-   image479->set_alignment(0.5,0.5);
-   image479->set_padding(0,0);
+   image521->set_alignment(0.5,0.5);
+   image521->set_padding(0,0);
+   label52->set_alignment(0.5,0.5);
+   label52->set_padding(0,0);
+   label52->set_justify(Gtk::JUSTIFY_LEFT);
+   label52->set_line_wrap(false);
+   label52->set_use_markup(false);
+   label52->set_selectable(false);
+   hbox45->pack_start(*image521, Gtk::PACK_SHRINK, 0);
+   hbox45->pack_start(*label52, Gtk::PACK_SHRINK, 0);
+   alignment31->add(*hbox45);
    indexBackButton->set_flags(Gtk::CAN_FOCUS);
    indexBackButton->set_flags(Gtk::CAN_DEFAULT);
    indexBackButton->set_relief(Gtk::RELIEF_NORMAL);
-   indexBackButton->add(*image479);
-   image480->set_alignment(0.5,0.5);
-   image480->set_padding(0,0);
+   indexBackButton->add(*alignment31);
+   image522->set_alignment(0.5,0.5);
+   image522->set_padding(0,0);
+   label53->set_alignment(0.5,0.5);
+   label53->set_padding(0,0);
+   label53->set_justify(Gtk::JUSTIFY_LEFT);
+   label53->set_line_wrap(false);
+   label53->set_use_markup(false);
+   label53->set_selectable(false);
+   hbox46->pack_start(*image522, Gtk::PACK_SHRINK, 0);
+   hbox46->pack_start(*label53, Gtk::PACK_SHRINK, 0);
+   alignment32->add(*hbox46);
    indexForwardButton->set_flags(Gtk::CAN_FOCUS);
    indexForwardButton->set_flags(Gtk::CAN_DEFAULT);
    indexForwardButton->set_relief(Gtk::RELIEF_NORMAL);
-   indexForwardButton->add(*image480);
-   image481->set_alignment(0.5,0.5);
-   image481->set_padding(0,0);
-   indexLastButton->set_flags(Gtk::CAN_FOCUS);
-   indexLastButton->set_flags(Gtk::CAN_DEFAULT);
-   indexLastButton->set_relief(Gtk::RELIEF_NORMAL);
-   indexLastButton->add(*image481);
-   indexHbuttonbox->pack_start(*indexFirstButton);
+   indexForwardButton->add(*alignment32);
    indexHbuttonbox->pack_start(*indexBackButton);
    indexHbuttonbox->pack_start(*indexForwardButton);
-   indexHbuttonbox->pack_start(*indexLastButton);
    indexButtonsHbox->pack_start(*indexCombobox, Gtk::PACK_SHRINK, 4);
    indexButtonsHbox->pack_start(*indexHbuttonbox, Gtk::PACK_SHRINK, 4);
    indexVbox->pack_start(*indexButtonsHbox, Gtk::PACK_SHRINK, 4);
@@ -513,14 +517,16 @@
    resultsVbox->show();
    resultsLabel->show();
    indexCombobox->show();
-   image478->show();
-   indexFirstButton->show();
-   image479->show();
+   image521->show();
+   label52->show();
+   hbox45->show();
+   alignment31->show();
    indexBackButton->show();
-   image480->show();
+   image522->show();
+   label53->show();
+   hbox46->show();
+   alignment32->show();
    indexForwardButton->show();
-   image481->show();
-   indexLastButton->show();
    indexHbuttonbox->show();
    indexButtonsHbox->show();
    indexVbox->show();
@@ -562,10 +568,8 @@
    removeQueryButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_removeQueryButton_clicked), false);
    findQueryButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_findQueryButton_clicked), false);
    indexCombobox->signal_changed().connect(SigC::slot(*this, &mainWindow_glade::on_indexCombobox_changed), false);
-   indexFirstButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_indexFirstButton_clicked), false);
    indexBackButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_indexBackButton_clicked), false);
    indexForwardButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_indexForwardButton_clicked), false);
-   indexLastButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_indexLastButton_clicked), false);
    mainWindow->signal_delete_event().connect(SigC::slot(*this, &mainWindow_glade::on_mainWindow_delete_event), false);
 }
 

Modified: trunk/UI/GTK2/src/mainWindow_glade.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.hh	2005-12-15 16:49:31 UTC (rev 11)
+++ trunk/UI/GTK2/src/mainWindow_glade.hh	2005-12-15 16:50:35 UTC (rev 12)
@@ -1,8 +1,8 @@
-// generated 2005/11/6 16:50:21 SGT by fabrice at amra.dyndns.org.(none)
+// generated 2005/12/16 0:34:21 SGT by fabrice at amra.dyndns.org.(none)
 // using glademm V2.6.0
 //
 // DO NOT EDIT THIS FILE ! It was created using
-// glade-- /home/fabrice/Projects/MetaSE/metase/UI/GTK2/metase-gtk2.glade
+// glade-- /home/fabrice/Projects/MetaSE/pinot/UI/GTK2/metase-gtk2.glade
 // for gtk 2.6.10 and gtkmm 2.6.2
 //
 // Please modify the corresponding derived classes in ./src/mainWindow.hh and./src/mainWindow.cc
@@ -101,10 +101,8 @@
 #endif //
         class Gtk::VBox * resultsVbox;
         class Gtk::ComboBox * indexCombobox;
-        class Gtk::Button * indexFirstButton;
         class Gtk::Button * indexBackButton;
         class Gtk::Button * indexForwardButton;
-        class Gtk::Button * indexLastButton;
         class Gtk::VBox * indexVbox;
         class Gtk::VBox * viewVbox;
         class Gtk::Notebook * mainNotebook;
@@ -143,10 +141,8 @@
         virtual void on_removeQueryButton_clicked() = 0;
         virtual void on_findQueryButton_clicked() = 0;
         virtual void on_indexCombobox_changed() = 0;
-        virtual void on_indexFirstButton_clicked() = 0;
         virtual void on_indexBackButton_clicked() = 0;
         virtual void on_indexForwardButton_clicked() = 0;
-        virtual void on_indexLastButton_clicked() = 0;
         virtual bool on_mainWindow_delete_event(GdkEventAny *ev) = 0;
 };
 #endif



From fabricecolin at berlios.de  Thu Dec 15 17:56:49 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Thu, 15 Dec 2005 17:56:49 +0100
Subject: [Pinot-svn] r13 - trunk/Utils
Message-ID: <200512151656.jBFGunr9017182@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-15 17:56:48 +0100 (Thu, 15 Dec 2005)
New Revision: 13

Modified:
   trunk/Utils/XapianDatabase.h
Log:
IndexHistory is history...


Modified: trunk/Utils/XapianDatabase.h
===================================================================
--- trunk/Utils/XapianDatabase.h	2005-12-15 16:50:35 UTC (rev 12)
+++ trunk/Utils/XapianDatabase.h	2005-12-15 16:56:48 UTC (rev 13)
@@ -24,7 +24,6 @@
 #include <xapian.h>
 
 #include "DocumentInfo.h"
-#include "IndexHistory.h"
 #include "IndexInterface.h"
 
 class XapianDatabase



From fabricecolin at berlios.de  Fri Dec 16 01:34:39 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 16 Dec 2005 01:34:39 +0100
Subject: [Pinot-svn] r14 - in trunk: Index UI/GTK2/src
Message-ID: <200512160034.jBG0YdmE016172@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-16 01:34:33 +0100 (Fri, 16 Dec 2005)
New Revision: 14

Modified:
   trunk/Index/XapianIndex.cpp
   trunk/UI/GTK2/src/mainWindow.cc
Log:
Fixed index listing with an offset. Allow to paste into live queries field.


Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2005-12-15 16:56:48 UTC (rev 13)
+++ trunk/Index/XapianIndex.cpp	2005-12-16 00:34:33 UTC (rev 14)
@@ -976,7 +976,7 @@
 		{
 			// Get a list of documents that have the magic term
 			for (Xapian::PostingIterator postingIter = pIndex->postlist_begin(MAGIC_TERM);
-				(postingIter != pIndex->postlist_end(MAGIC_TERM)) && (docCount < maxDocsCount);
+				(postingIter != pIndex->postlist_end(MAGIC_TERM)) && (docIds.size() < maxDocsCount);
 				++postingIter)
 			{
 				Xapian::docid docId = *postingIter;

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-15 16:56:48 UTC (rev 13)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-16 00:34:33 UTC (rev 14)
@@ -1449,8 +1449,15 @@
 	}
 
 	ustring clipText = refClipboard->wait_for_text();
-	if (queryTreeview->is_focus() == true)
+	if (liveQueryEntry->is_focus() == true)
 	{
+		ustring queryText = liveQueryEntry->get_text();
+
+		// FIXME: paste where the cursor is
+		liveQueryEntry->set_text(queryText + clipText);
+	}
+	else if (queryTreeview->is_focus() == true)
+	{
 #ifdef DEBUG
 		cout << "mainWindow::on_paste_activate: query tree" << endl;
 #endif



From fabricecolin at berlios.de  Sat Dec 17 04:20:44 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 17 Dec 2005 04:20:44 +0100
Subject: [Pinot-svn] r15 - in trunk: Index Utils
Message-ID: <200512170320.jBH3Ki51016814@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-17 04:20:03 +0100 (Sat, 17 Dec 2005)
New Revision: 15

Modified:
   trunk/Index/XapianIndex.cpp
   trunk/Utils/StringManip.cpp
Log:
Fixed extraction of language from document data.


Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2005-12-16 00:34:33 UTC (rev 14)
+++ trunk/Index/XapianIndex.cpp	2005-12-17 03:20:03 UTC (rev 15)
@@ -369,8 +369,12 @@
 				docInfo = DocumentInfo(StringManip::extractField(record, "caption=", "\n"),
 					StringManip::extractField(record, "url=", "\n"),
 					StringManip::extractField(record, "type=", "\n"),
-					StringManip::extractField(record, "language=", "\n"));
+					StringManip::extractField(record, "language=", ""));
 				docInfo.setTimestamp(StringManip::extractField(record, "timestamp=", "\n"));
+#ifdef DEBUG
+				cout << "XapianIndex::getDocumentInfo: language is "
+					<< docInfo.getLanguage() << endl;
+#endif
 				foundDocument = true;
 			}
 		}
@@ -579,7 +583,7 @@
 			// Get the current document data
 			string record = doc.get_data();
 			string extract = StringManip::extractField(record, "sample=", "\n");
-			string language = StringManip::extractField(record, "language=", "\n");
+			string language = StringManip::extractField(record, "language=", "");
 
 			// Update the document data with the current extract and language
 			setDocumentData(doc, docInfo, extract, language);

Modified: trunk/Utils/StringManip.cpp
===================================================================
--- trunk/Utils/StringManip.cpp	2005-12-16 00:34:33 UTC (rev 14)
+++ trunk/Utils/StringManip.cpp	2005-12-17 03:20:03 UTC (rev 15)
@@ -63,16 +63,33 @@
 string StringManip::extractField(const string &str, const string &start, const string &end, string::size_type &endPos)
 {
 	string fieldValue;
+	string::size_type startPos = string::npos;
 
-	string::size_type startPos = str.find(start, endPos);
+	if (start.empty() == true)
+	{
+		startPos = 0;
+	}
+	else
+	{
+		startPos = str.find(start, endPos);
+	}
+
 	if (startPos != string::npos)
 	{
 		startPos += start.length();
-		endPos = str.find(end, startPos);
-		if (endPos != string::npos)
+
+		if (end.empty() == true)
 		{
-			fieldValue = str.substr(startPos, endPos - startPos);
+			fieldValue = str.substr(startPos);
 		}
+		else
+		{
+			endPos = str.find(end, startPos);
+			if (endPos != string::npos)
+			{
+				fieldValue = str.substr(startPos, endPos - startPos);
+			}
+		}
 	}
 
 	return fieldValue;



From fabricecolin at berlios.de  Sat Dec 17 04:34:00 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 17 Dec 2005 04:34:00 +0100
Subject: [Pinot-svn] r16 - trunk/Search
Message-ID: <200512170334.jBH3Y0de022898@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-17 04:33:44 +0100 (Sat, 17 Dec 2005)
New Revision: 16

Modified:
   trunk/Search/XapianEngine.cpp
   trunk/Search/XapianEngine.h
Log:
Experimenting with multi-step search :
1. follow operators and don't stem terms
2. if no results, follow operators and stem terms
3. if no results, don't follow operators and don't stem terms
4. if no results, don't follow operators and stem terms
Steps 2 and 4 depend on a language being defined for the query.


Modified: trunk/Search/XapianEngine.cpp
===================================================================
--- trunk/Search/XapianEngine.cpp	2005-12-17 03:20:03 UTC (rev 15)
+++ trunk/Search/XapianEngine.cpp	2005-12-17 03:33:44 UTC (rev 16)
@@ -183,9 +183,8 @@
 }
 
 void XapianEngine::stackQuery(const QueryProperties &queryProps,
-	stack<Xapian::Query> &queryStack, bool followOperators)
+	stack<Xapian::Query> &queryStack, const string &language, bool followOperators)
 {
-	string language = queryProps.getLanguage();
 	Xapian::Query::op queryOp = Xapian::Query::OP_OR;
 	string term;
 
@@ -253,22 +252,16 @@
 #ifdef DEBUG
 			cout << "XapianEngine::stackQuery: OP_AND_NOT "  << notTerms.size() << endl;
 #endif
-			// An AND_NOT has to have two sub-queries
-			if (followOperators == true)
-			{
-				queryOp = Xapian::Query::OP_AND;
-			}
-			Xapian::Query notQuery(queryOp, notTerms.begin(), notTerms.end());
 			// We need something to AND_NOT these terms against
+			// Not following the operator would make us return documents
+			// that have terms the user isn't interested in
+			Xapian::Query notQuery(Xapian::Query::OP_AND, notTerms.begin(), notTerms.end());
 			if (queryStack.empty() == false)
 			{
 				Xapian::Query topQuery = queryStack.top();
 				queryStack.pop();
-				if (followOperators == true)
-				{
-					queryOp = Xapian::Query::OP_AND_NOT;
-				}
-				queryStack.push(Xapian::Query(queryOp, topQuery, notQuery));
+
+				queryStack.push(Xapian::Query(Xapian::Query::OP_AND_NOT, topQuery, notQuery));
 			}
 		}
 	}
@@ -384,9 +377,17 @@
 	try
 	{
 		stack<Xapian::Query> queryStack;
+		string language;
+		unsigned int searchStep = 1;
 		bool followOperators = true;
 
-		stackQuery(queryProps, queryStack, followOperators);
+		// Searches are run in this order :
+		// 1. follow operators and don't stem terms
+		// 2. if no results, follow operators and stem terms
+		// 3. if no results, don't follow operators and don't stem terms
+		// 4. if no results, don't follow operators and stem terms
+		// Steps 2 and 4 depend on a language being defined for the query
+		stackQuery(queryProps, queryStack, language, followOperators);
 		while (queryStack.empty() == false)
 		{
 			while (queryStack.size() > 1)
@@ -404,27 +405,50 @@
 				queryStack.push(query);
 			}
 
-			// Query the database with the full query
+			// Query the database
 			if (queryDatabase(queryStack.top()) == true)
 			{
-#if 0
-				if ((m_resultsList.empty() == true) &&
-					(followOperators == true))
+				if (m_resultsList.empty() == true)
 				{
 					// The search did succeed but didn't return anything
-					// Try again by OR'ing terms together
+					// Try the next step
+					switch (++searchStep)
+					{
+						case 2:
+							followOperators = true;
+							language = queryProps.getLanguage();
+							if (language.empty() == false)
+							{
+								break;
+							}
+							++searchStep;
+						case 3:
+							followOperators = false;
+							language.clear();
+							break;
+						case 4:
+							followOperators = false;
+							language = queryProps.getLanguage();
+							if (language.empty() == false)
+							{
+								break;
+							}
+							++searchStep;
+						default:
+							return true;
+					}
+
+					// Empty the stack
 					while (queryStack.empty() == false)
 					{
 						queryStack.pop();
 					}
-					followOperators = false;
 #ifdef DEBUG
-					cout << "XapianEngine::runQuery: trying with OR'ed terms" << endl;
+					cout << "XapianEngine::runQuery: trying step " << searchStep << endl;
 #endif
-					stackQuery(queryProps, queryStack, followOperators);
+					stackQuery(queryProps, queryStack, language, followOperators);
 					continue;
 				}
-#endif
 
 				return true;
 			}

Modified: trunk/Search/XapianEngine.h
===================================================================
--- trunk/Search/XapianEngine.h	2005-12-17 03:20:03 UTC (rev 15)
+++ trunk/Search/XapianEngine.h	2005-12-17 03:33:44 UTC (rev 16)
@@ -50,7 +50,8 @@
 		bool queryDatabase(Xapian::Query &query);
 
 		void stackQuery(const QueryProperties &queryProps,
-			std::stack<Xapian::Query> &queryStack, bool followOperators);
+			std::stack<Xapian::Query> &queryStack, const string &language,
+			bool followOperators);
 
 	private:
 		XapianEngine(const XapianEngine &other);



From fabricecolin at berlios.de  Sat Dec 17 05:12:35 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 17 Dec 2005 05:12:35 +0100
Subject: [Pinot-svn] r17 - trunk/UI/GTK2/src
Message-ID: <200512170412.jBH4CZkm025996@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-17 05:12:31 +0100 (Sat, 17 Dec 2005)
New Revision: 17

Modified:
   trunk/UI/GTK2/src/mainWindow.cc
Log:
Hopefully fixed copy and paste into the live query field.


Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-17 03:33:44 UTC (rev 16)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-17 04:12:31 UTC (rev 17)
@@ -1366,8 +1366,13 @@
 {
 	ustring text;
 
-	if (queryTreeview->is_focus() == true)
+	if (liveQueryEntry->is_focus() == true)
 	{
+		liveQueryEntry->copy_clipboard();
+		return;
+	}
+	else if (queryTreeview->is_focus() == true)
+	{
 #ifdef DEBUG
 		cout << "mainWindow::on_copy_activate: query tree" << endl;
 #endif
@@ -1451,10 +1456,10 @@
 	ustring clipText = refClipboard->wait_for_text();
 	if (liveQueryEntry->is_focus() == true)
 	{
-		ustring queryText = liveQueryEntry->get_text();
+		int currentPosition = liveQueryEntry->get_position();
 
-		// FIXME: paste where the cursor is
-		liveQueryEntry->set_text(queryText + clipText);
+		// Paste where the cursor is
+		liveQueryEntry->insert_text(clipText, clipText.length(), currentPosition);
 	}
 	else if (queryTreeview->is_focus() == true)
 	{
@@ -1482,8 +1487,12 @@
 //
 void mainWindow::on_delete_activate()
 {
-	if (m_pResultsTree->is_focus() == true)
+	if (liveQueryEntry->is_focus() == true)
 	{
+		liveQueryEntry->delete_selection();
+	}
+	else if (m_pResultsTree->is_focus() == true)
+	{
 #ifdef DEBUG
 		cout << "mainWindow::on_delete_activate: results tree" << endl;
 #endif



From fabricecolin at berlios.de  Sat Dec 17 11:49:08 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 17 Dec 2005 11:49:08 +0100
Subject: [Pinot-svn] r18 - trunk/UI/RenderHTML
Message-ID: <200512171049.jBHAn8o7027800@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-17 11:49:04 +0100 (Sat, 17 Dec 2005)
New Revision: 18

Modified:
   trunk/UI/RenderHTML/MozillaRenderer.cpp
Log:
Initialize NSPR and NSS to avoid segmentation fault on https sites.


Modified: trunk/UI/RenderHTML/MozillaRenderer.cpp
===================================================================
--- trunk/UI/RenderHTML/MozillaRenderer.cpp	2005-12-17 04:12:31 UTC (rev 17)
+++ trunk/UI/RenderHTML/MozillaRenderer.cpp	2005-12-17 10:49:04 UTC (rev 18)
@@ -15,12 +15,32 @@
  */
  
 #include <iostream>
+#include <nspr/nspr.h>
+#include <nss/nss.h>
+#include <nss/ssl.h>
 #include <gtkmozembed.h>
 
 #include "MozillaRenderer.h"
 
 MozillaRenderer::MozillaRenderer()
 {
+	// Initialize NSPR and NSS
+	PR_Init (PR_SYSTEM_THREAD, PR_PRIORITY_NORMAL, 10);
+	if (NSS_InitReadWrite(NULL) == SECFailure)
+	{
+		if (NSS_NoDB_Init(NULL) == SECFailure)
+		{
+#ifdef DEBUG
+			cout << "MozillaRenderer::ctor: couldn't initialize NSS" << endl;
+#endif
+		}
+	}
+	NSS_SetDomesticPolicy();
+	SSL_OptionSetDefault(SSL_ENABLE_SSL2, PR_TRUE);
+	SSL_OptionSetDefault(SSL_ENABLE_SSL3, PR_TRUE);
+	SSL_OptionSetDefault(SSL_ENABLE_TLS, PR_TRUE);
+	SSL_OptionSetDefault(SSL_V2_COMPATIBLE_HELLO, PR_TRUE);
+
 	gtk_moz_embed_push_startup();
 
 	// Create our web browser component
@@ -42,6 +62,10 @@
 MozillaRenderer::~MozillaRenderer()
 {
 	gtk_moz_embed_pop_startup();
+	// Shutdown NSS and NSPR
+	NSS_Shutdown();
+	// FIXME: this hangs, waiting on a condition variable
+	//PR_Cleanup();
 }
 
 /// Returns the GTK widget.



From fabricecolin at berlios.de  Sat Dec 17 12:01:44 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 17 Dec 2005 12:01:44 +0100
Subject: [Pinot-svn] r19 - in trunk: Collect UI/GTK2/src
Message-ID: <200512171101.jBHB1iL6030005@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-17 12:01:43 +0100 (Sat, 17 Dec 2005)
New Revision: 19

Modified:
   trunk/Collect/NeonDownloader.cpp
   trunk/Collect/NeonDownloader.h
   trunk/UI/GTK2/src/pinot.cpp
Log:
NeonDownloader sets up the callbacks necessary for safe multi-threading with
OpenSSL.


Modified: trunk/Collect/NeonDownloader.cpp
===================================================================
--- trunk/Collect/NeonDownloader.cpp	2005-12-17 10:49:04 UTC (rev 18)
+++ trunk/Collect/NeonDownloader.cpp	2005-12-17 11:01:43 UTC (rev 19)
@@ -20,6 +20,12 @@
 #include <pthread.h>
 #include <iostream>
 
+#include <neon/ne_session.h>
+// Does Neon have OpenSSL support ?
+#ifdef NE_SSL_H
+#include <openssl/crypto.h>
+#endif	// NE_SSL_H
+
 #include "HtmlTokenizer.h"
 #include "HtmlDocument.h"
 #include "Url.h"
@@ -60,6 +66,62 @@
 
 bool NeonDownloader::m_initialized = false;
 
+#ifdef NE_SSL_H
+// OpenSSL multi-thread support, required by Neon
+static pthread_mutex_t locksTable[CRYPTO_NUM_LOCKS];
+
+// OpenSSL locking functiom
+static void lockingCallback(int mode, int n, const char *file, int line)
+{
+#ifdef DEBUG
+	cout << "lockingCallback: called for mutex " << n << endl;
+#endif
+	if (mode & CRYPTO_LOCK)
+	{
+		pthread_mutex_lock(&(locksTable[n]));
+	}
+	else
+	{
+		pthread_mutex_unlock(&(locksTable[n]));
+	}
+}
+
+unsigned long idCallback(void)
+{
+	return (unsigned long)pthread_self();
+}
+#endif // NE_SSL_H
+
+/// Initialize the downloader.
+void NeonDownloader::initialize(void)
+{
+#ifdef NE_SSL_H
+	// Initialize the OpenSSL mutexes
+	for (unsigned int lockNum = 0; lockNum < CRYPTO_NUM_LOCKS; ++lockNum)
+	{
+		pthread_mutex_init(&(locksTable[lockNum]), NULL);
+	}
+	// Set the callbacks
+	CRYPTO_set_locking_callback(lockingCallback);
+	CRYPTO_set_id_callback(idCallback);
+#endif	// NE_SSL_H
+}
+
+/// Shutdown the downloader.
+void NeonDownloader::shutdown(void)
+{
+#ifdef NE_SSL_H
+	// Reset the OpenSSL callbacks
+	CRYPTO_set_id_callback(NULL);
+	CRYPTO_set_locking_callback(NULL);
+	// Free the mutexes
+	for (unsigned int lockNum = 0; lockNum < CRYPTO_NUM_LOCKS; ++lockNum)
+	{
+		pthread_mutex_destroy(&(locksTable[lockNum]));
+	}
+#endif	// NE_SSL_H
+}
+
 NeonDownloader::NeonDownloader() :
 	m_pSession(NULL), m_pRequest(NULL), DownloaderInterface()
 {

Modified: trunk/Collect/NeonDownloader.h
===================================================================
--- trunk/Collect/NeonDownloader.h	2005-12-17 10:49:04 UTC (rev 18)
+++ trunk/Collect/NeonDownloader.h	2005-12-17 11:01:43 UTC (rev 19)
@@ -31,6 +31,12 @@
 		NeonDownloader();
 		virtual ~NeonDownloader();
 
+		/// Initialize the downloader.
+		static void initialize(void);
+
+		/// Shutdown the downloader.
+		static void shutdown(void);
+
 		/// Sets a (name, value) setting; true if success.
 		virtual bool setSetting(const std::string &name, const std::string &value);
 

Modified: trunk/UI/GTK2/src/pinot.cpp
===================================================================
--- trunk/UI/GTK2/src/pinot.cpp	2005-12-17 10:49:04 UTC (rev 18)
+++ trunk/UI/GTK2/src/pinot.cpp	2005-12-17 11:01:43 UTC (rev 19)
@@ -27,11 +27,12 @@
 
 #include "TokenizerFactory.h"
 #include "Languages.h"
+#include "XapianDatabase.h"
+#include "XapianDatabaseFactory.h"
 #include "ActionHistory.h"
 #include "QueryHistory.h"
 #include "ViewHistory.h"
-#include "XapianDatabase.h"
-#include "XapianDatabaseFactory.h"
+#include "NeonDownloader.h"
 #include "config.h"
 #include "NLS.h"
 #include "PinotSettings.h"
@@ -39,9 +40,9 @@
 
 using namespace std;
 
-ofstream outputFile;
-streambuf *coutbuf = NULL;
-streambuf *cerrbuf = NULL;
+static ofstream outputFile;
+static streambuf *coutBuf = NULL;
+static streambuf *cerrBuf = NULL;
 
 void closeAll(void)
 {
@@ -61,14 +62,17 @@
 	TokenizerFactory::unloadTokenizers();
 
 	// Restore the stream buffers
-	if (coutbuf != NULL)
+	if (coutBuf != NULL)
 	{
-		cout.rdbuf(coutbuf);
+		cout.rdbuf(coutBuf);
 	}
-	if (cerrbuf != NULL)
+	if (cerrBuf != NULL)
 	{
-		cerr.rdbuf(cerrbuf);
+		cerr.rdbuf(cerrBuf);
 	}
+	outputFile.close();
+
+	NeonDownloader::shutdown();
 }
 
 int main(int argc, char **argv)
@@ -78,6 +82,7 @@
 	textdomain (GETTEXT_PACKAGE);
 #endif //ENABLE_NLS
 
+	NeonDownloader::initialize();
 	Glib::thread_init();
 	Gtk::Main m(&argc, &argv);
 
@@ -91,8 +96,8 @@
 	string logFileName = confDirectory;
 	logFileName += "/pinot.log";
 	outputFile.open(logFileName.c_str());
-	coutbuf = cout.rdbuf();
-	cerrbuf = cerr.rdbuf();
+	coutBuf = cout.rdbuf();
+	cerrBuf = cerr.rdbuf();
 	cout.rdbuf(outputFile.rdbuf());
 	cerr.rdbuf(outputFile.rdbuf());
 



From fabricecolin at berlios.de  Sat Dec 17 12:02:31 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 17 Dec 2005 12:02:31 +0100
Subject: [Pinot-svn] r20 - trunk
Message-ID: <200512171102.jBHB2VYM030260@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-17 12:02:30 +0100 (Sat, 17 Dec 2005)
New Revision: 20

Modified:
   trunk/variables.mk
Log:
Link against mozilla-nss libraries.


Modified: trunk/variables.mk
===================================================================
--- trunk/variables.mk	2005-12-17 11:01:43 UTC (rev 19)
+++ trunk/variables.mk	2005-12-17 11:02:30 UTC (rev 20)
@@ -84,7 +84,7 @@
 MOZILLA_XPCOM_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags mozilla-xpcom)
 MOZILLA_XPCOM_LIBS = -Xlinker -rpath -Xlinker ${MOZILLA_LIB_DIR} $(shell /usr/bin/pkg-config --libs mozilla-xpcom)
 GTKMOZ_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags mozilla-gtkmozembed gtk+-2.0)
-GTKMOZ_LIBS = -Xlinker -rpath -Xlinker ${MOZILLA_LIB_DIR} $(shell /usr/bin/pkg-config --libs mozilla-gtkmozembed gtk+-2.0)
+GTKMOZ_LIBS = -Xlinker -rpath -Xlinker ${MOZILLA_LIB_DIR} $(shell /usr/bin/pkg-config --libs mozilla-gtkmozembed gtk+-2.0 mozilla-nss)
 # GTKmm 2.0
 GTKMM_CXXFLAGS = $(shell /usr/bin/pkg-config --cflags gtkmm-2.4)
 GTKMM_LIBS = $(shell /usr/bin/pkg-config --libs gtkmm-2.4)



From fabricecolin at berlios.de  Sat Dec 17 12:55:49 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 17 Dec 2005 12:55:49 +0100
Subject: [Pinot-svn] r21 - in trunk: Index UI/GTK2/src
Message-ID: <200512171155.jBHBtnH3021096@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-17 12:55:43 +0100 (Sat, 17 Dec 2005)
New Revision: 21

Modified:
   trunk/Index/IndexInterface.h
   trunk/Index/XapianIndex.cpp
   trunk/Index/XapianIndex.h
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/mainWindow.cc
Log:
Changed IndexInterface a bit, reintroduced hasLabel() so that whether documents
match the current label can be shown in the index list.


Modified: trunk/Index/IndexInterface.h
===================================================================
--- trunk/Index/IndexInterface.h	2005-12-17 11:02:30 UTC (rev 20)
+++ trunk/Index/IndexInterface.h	2005-12-17 11:55:43 UTC (rev 21)
@@ -47,6 +47,9 @@
 		/// Returns a document's properties.
 		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const = 0;
 
+		/// Determines whether a document has a label.
+		virtual bool hasLabel(unsigned int docId, const std::string &name) const = 0;
+
 		/// Returns a document's labels.
 		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const = 0;
 
@@ -84,10 +87,9 @@
 		/// Returns the number of documents.
 		virtual unsigned int getDocumentsCount(void) const = 0;
 
-		/// Returns a list of document IDs.
-		virtual unsigned int getDocumentIDs(std::set<unsigned int> &docIDList,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0,
-			bool sortByDate = false) const = 0;
+		/// Lists document IDs.
+		virtual unsigned int listDocuments(std::set<unsigned int> &docIDList,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const = 0;
 
 	protected:
 		StemmingMode m_stemMode;

Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2005-12-17 11:02:30 UTC (rev 20)
+++ trunk/Index/XapianIndex.cpp	2005-12-17 11:55:43 UTC (rev 21)
@@ -392,6 +392,54 @@
 	return foundDocument;
 }
 
+/// Determines whether a document has a label.
+bool XapianIndex::hasLabel(unsigned int docId, const string &name) const
+{
+	bool foundLabel = false;
+
+	XapianDatabase *pDatabase = XapianDatabaseFactory::getDatabase(m_databaseName, false);
+	if (pDatabase == NULL)
+	{
+		cerr << "Bad index " << m_databaseName << endl;
+		return false;
+	}
+
+	try
+	{
+		Xapian::WritableDatabase *pIndex = pDatabase->writeLock();
+		if (pIndex != NULL)
+		{
+			string term("C");
+
+			// Get documents that have this label
+			// FIXME: would it be faster to get the document's terms ?
+			term += name;
+			Xapian::PostingIterator postingIter = pIndex->postlist_begin(term);
+			if (postingIter != pIndex->postlist_end(term))
+			{
+				// Is this document in the list ?
+				postingIter.skip_to(docId);
+				if ((postingIter != pIndex->postlist_end(term)) &&
+					(docId == (*postingIter)))
+				{
+					foundLabel = true;
+				}
+			}
+		}
+		pDatabase->unlock();
+	}
+	catch (const Xapian::Error &error)
+	{
+		cerr << "Couldn't check document labels: " << error.get_msg() << endl;
+	}
+	catch (...)
+	{
+		cerr << "Couldn't check document labels, unknown exception occured" << endl;
+	}
+
+	return foundLabel;
+}
+
 /// Returns a document's labels.
 bool XapianIndex::getDocumentLabels(unsigned int docId, set<string> &labels) const
 {
@@ -959,9 +1007,9 @@
 	return docCount;
 }
 
-/// Returns a list of document IDs.
-unsigned int XapianIndex::getDocumentIDs(set<unsigned int> &docIds,
-	unsigned int maxDocsCount, unsigned int startDoc, bool sortByDate) const
+/// Lists document IDs.
+unsigned int XapianIndex::listDocuments(set<unsigned int> &docIds,
+	unsigned int maxDocsCount, unsigned int startDoc) const
 {
 	unsigned int docCount = 0;
 

Modified: trunk/Index/XapianIndex.h
===================================================================
--- trunk/Index/XapianIndex.h	2005-12-17 11:02:30 UTC (rev 20)
+++ trunk/Index/XapianIndex.h	2005-12-17 11:55:43 UTC (rev 21)
@@ -41,6 +41,9 @@
 		/// Returns a document's properties.
 		virtual bool getDocumentInfo(unsigned int docId, DocumentInfo &docInfo) const;
 
+		/// Determines whether a document has a label.
+		virtual bool hasLabel(unsigned int docId, const std::string &name) const;
+
 		/// Returns a document's labels.
 		virtual bool getDocumentLabels(unsigned int docId, std::set<std::string> &labels) const;
 
@@ -78,10 +81,9 @@
 		/// Returns the number of documents.
 		virtual unsigned int getDocumentsCount(void) const;
 
-		/// Returns a list of document IDs.
-		virtual unsigned int getDocumentIDs(std::set<unsigned int> &docIds,
-			unsigned int maxDocsCount = 0, unsigned int startDoc = 0,
-			bool sortByDate = false) const;
+		/// Lists document IDs.
+		virtual unsigned int listDocuments(std::set<unsigned int> &docIds,
+			unsigned int maxDocsCount = 0, unsigned int startDoc = 0) const;
 
 	protected:
 		static const unsigned int m_maxTermLength;

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-17 11:02:30 UTC (rev 20)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-17 11:55:43 UTC (rev 21)
@@ -214,7 +214,7 @@
 	cout << "IndexBrowserThread::do_browsing: " << m_maxDocsCount << " off " << m_indexDocsCount
 		<< " documents to browse, starting at " << m_startDoc << endl;
 #endif
-	index.getDocumentIDs(docIDList, m_maxDocsCount, m_startDoc);
+	index.listDocuments(docIDList, m_maxDocsCount, m_startDoc);
 	for (set<unsigned int>::iterator iter = docIDList.begin(); iter != docIDList.end(); ++iter)
 	{
 		if (m_done == true)

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-17 11:02:30 UTC (rev 20)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-17 11:55:43 UTC (rev 21)
@@ -1226,6 +1226,8 @@
 //
 void mainWindow::on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, string indexName)
 {
+	bool hasLabel = false;
+
 	if (indexName != locale_from_utf8(m_state.getCurrentIndex()))
 	{
 		// Ignore
@@ -1246,15 +1248,25 @@
 		return;
 	}
 
-	const std::map<string, string> &indexesMap = PinotSettings::getInstance().getIndexes();
-	std::map<string, string>::const_iterator mapIter = indexesMap.find(indexName);
-	if (mapIter == indexesMap.end())
+	// Does that document have the current label ?
+	string currentLabelName;
+	if (m_state.getCurrentLabel(currentLabelName) > 0)
 	{
-		return;
+		const std::map<string, string> &indexesMap = PinotSettings::getInstance().getIndexes();
+		std::map<string, string>::const_iterator mapIter = indexesMap.find(indexName);
+		if (mapIter != indexesMap.end())
+		{
+			XapianIndex index(mapIter->second);
+
+			if (index.isGood() == true)
+			{
+				hasLabel = index.hasLabel(docId, currentLabelName);
+			}
+		}
 	}
 
 	// Add a row
-	if (m_pIndexTree->appendDocument(docInfo, true) == true)
+	if (m_pIndexTree->appendDocument(docInfo, hasLabel) == true)
 	{
 #ifdef DEBUG
 		cout << "mainWindow::on_message_indexupdate: added document to index list" << endl;
@@ -1681,10 +1693,11 @@
 {
 	vector<IndexedDocument> documentsList;
 	set<string> docLabels;
+	string currentLabelName;
 	DocumentInfo docInfo;
 	unsigned int docId = 0;
 	int width, height;
-	bool editTitle = false;
+	bool matchedLabel = false, editTitle = false;
 
 	const std::map<string, string> &indexesMap = PinotSettings::getInstance().getIndexes();
 	std::map<string, string>::const_iterator mapIter = indexesMap.find(m_state.getCurrentIndex());	
@@ -1721,6 +1734,13 @@
 		if (index.isGood() == true)
 		{
 			index.getDocumentLabels(docId, docLabels);
+
+			// Does it match the current label ?
+			if ((m_state.getCurrentLabel(currentLabelName) > 0) &&
+				(find(docLabels.begin(), docLabels.end(), currentLabelName) != docLabels.end()))
+			{
+				matchedLabel = true;
+			}
 		}
 
 		docInfo = DocumentInfo(docIter->getTitle(), docIter->getOriginalLocation(),
@@ -1755,12 +1775,29 @@
 	if ((documentsList.size() == 1) &&
 		(docId > 0))
 	{
+		bool matchesLabel = false;
+
+		// Does the sole selected document match the current label now ?
+		if ((currentLabelName.empty() == false) &&
+			(find(labels.begin(), labels.end(), currentLabelName) != labels.end()))
+		{
+				matchesLabel = true;
+		}
+
+		// Was there any change ?
+		if (matchesLabel != matchedLabel)
+		{
+				// Update this document to the index tree
+				m_pIndexTree->setDocumentLabeledState(docId, matchesLabel);
+		}
+
+		// Did the title change ?
 		string newTitle = propertiesBox.getDocumentInfo().getTitle();
 		if (newTitle != docInfo.getTitle())
 		{
 			docInfo.setTitle(newTitle);
 			
-			// Update the document's title
+			// Update the document
 			start_thread(new UpdateDocumentThread(m_state.getCurrentIndex(), docId, docInfo));
 		}
 	}



From fabricecolin at berlios.de  Sat Dec 17 17:38:56 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 17 Dec 2005 17:38:56 +0100
Subject: [Pinot-svn] r22 - trunk/UI/GTK2/src
Message-ID: <200512171638.jBHGcu0K006226@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-17 17:38:56 +0100 (Sat, 17 Dec 2005)
New Revision: 22

Modified:
   trunk/UI/GTK2/src/mainWindow.cc
Log:
Minor fix for LabelUpdateThread.


Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-17 11:55:43 UTC (rev 21)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-17 16:38:56 UTC (rev 22)
@@ -957,8 +957,8 @@
 	}
 	else if (type == "LabelUpdateThread")
 	{
-		LabelQueryThread *pLabelQueryThread = dynamic_cast<LabelQueryThread *>(pThread);
-		if (pLabelQueryThread == NULL)
+		LabelUpdateThread *pLabelUpdateThread = dynamic_cast<LabelUpdateThread *>(pThread);
+		if (pLabelUpdateThread == NULL)
 		{
 			delete pThread;
 			return;



From fabricecolin at berlios.de  Sat Dec 17 17:40:36 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 17 Dec 2005 17:40:36 +0100
Subject: [Pinot-svn] r23 - in trunk: Collect UI/GTK2/src UI/RenderHTML
Message-ID: <200512171640.jBHGeaPN006382@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-17 17:40:35 +0100 (Sat, 17 Dec 2005)
New Revision: 23

Modified:
   trunk/Collect/NeonDownloader.h
   trunk/UI/GTK2/src/pinot.cpp
   trunk/UI/RenderHTML/MozillaRenderer.cpp
   trunk/UI/RenderHTML/MozillaRenderer.h
Log:
Mostly cosmetic changes to startup initialization.


Modified: trunk/Collect/NeonDownloader.h
===================================================================
--- trunk/Collect/NeonDownloader.h	2005-12-17 16:38:56 UTC (rev 22)
+++ trunk/Collect/NeonDownloader.h	2005-12-17 16:40:35 UTC (rev 23)
@@ -31,10 +31,10 @@
 		NeonDownloader();
 		virtual ~NeonDownloader();
 
-		/// Initialize the downloader.
+		/// Initializes the downloader.
 		static void initialize(void);
 
-		/// Shutdown the downloader.
+		/// Shutdowns the downloader.
 		static void shutdown(void);
 
 		/// Sets a (name, value) setting; true if success.

Modified: trunk/UI/GTK2/src/pinot.cpp
===================================================================
--- trunk/UI/GTK2/src/pinot.cpp	2005-12-17 16:38:56 UTC (rev 22)
+++ trunk/UI/GTK2/src/pinot.cpp	2005-12-17 16:40:35 UTC (rev 23)
@@ -33,6 +33,7 @@
 #include "QueryHistory.h"
 #include "ViewHistory.h"
 #include "NeonDownloader.h"
+#include "MozillaRenderer.h"
 #include "config.h"
 #include "NLS.h"
 #include "PinotSettings.h"
@@ -72,6 +73,7 @@
 	}
 	outputFile.close();
 
+	MozillaRenderer::shutdown();
 	NeonDownloader::shutdown();
 }
 
@@ -83,6 +85,7 @@
 #endif //ENABLE_NLS
 
 	NeonDownloader::initialize();
+	MozillaRenderer::initialize();
 	Glib::thread_init();
 	Gtk::Main m(&argc, &argv);
 

Modified: trunk/UI/RenderHTML/MozillaRenderer.cpp
===================================================================
--- trunk/UI/RenderHTML/MozillaRenderer.cpp	2005-12-17 16:38:56 UTC (rev 22)
+++ trunk/UI/RenderHTML/MozillaRenderer.cpp	2005-12-17 16:40:35 UTC (rev 23)
@@ -22,7 +22,7 @@
 
 #include "MozillaRenderer.h"
 
-MozillaRenderer::MozillaRenderer()
+void MozillaRenderer::initialize(void)
 {
 	// Initialize NSPR and NSS
 	PR_Init (PR_SYSTEM_THREAD, PR_PRIORITY_NORMAL, 10);
@@ -40,7 +40,18 @@
 	SSL_OptionSetDefault(SSL_ENABLE_SSL3, PR_TRUE);
 	SSL_OptionSetDefault(SSL_ENABLE_TLS, PR_TRUE);
 	SSL_OptionSetDefault(SSL_V2_COMPATIBLE_HELLO, PR_TRUE);
+}
 
+void MozillaRenderer::shutdown(void)
+{
+	// Shutdown NSS and NSPR
+	NSS_Shutdown();
+	// FIXME: this hangs, waiting on a condition variable
+	//PR_Cleanup();
+}
+
+MozillaRenderer::MozillaRenderer()
+{
 	gtk_moz_embed_push_startup();
 
 	// Create our web browser component
@@ -62,10 +73,6 @@
 MozillaRenderer::~MozillaRenderer()
 {
 	gtk_moz_embed_pop_startup();
-	// Shutdown NSS and NSPR
-	NSS_Shutdown();
-	// FIXME: this hangs, waiting on a condition variable
-	//PR_Cleanup();
 }
 
 /// Returns the GTK widget.

Modified: trunk/UI/RenderHTML/MozillaRenderer.h
===================================================================
--- trunk/UI/RenderHTML/MozillaRenderer.h	2005-12-17 16:38:56 UTC (rev 22)
+++ trunk/UI/RenderHTML/MozillaRenderer.h	2005-12-17 16:40:35 UTC (rev 23)
@@ -32,6 +32,12 @@
 		MozillaRenderer();
 		virtual ~MozillaRenderer();
 
+		/// Initializes the renderer.
+		static void initialize(void);
+
+		/// Shutdowns the renderer.
+		static void shutdown(void);
+
 		/// Returns the GTK widget.
 		GtkWidget *getWidget(void);
 



From fabricecolin at berlios.de  Sat Dec 17 17:41:29 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 17 Dec 2005 17:41:29 +0100
Subject: [Pinot-svn] r24 - trunk/po
Message-ID: <200512171641.jBHGfTtT006460@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-17 17:41:27 +0100 (Sat, 17 Dec 2005)
New Revision: 24

Modified:
   trunk/po/en_GB.po
   trunk/po/fr_FR.po
Log:
Updated po files.


Modified: trunk/po/en_GB.po
===================================================================
--- trunk/po/en_GB.po	2005-12-17 16:40:35 UTC (rev 23)
+++ trunk/po/en_GB.po	2005-12-17 16:41:27 UTC (rev 24)
@@ -27,7 +27,7 @@
 "Content-Type: text/plain; charset=utf-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 
-#: UI/GTK2/src/aboutDialog_glade.cc:342 UI/GTK2/src/mainWindow_glade.cc:445
+#: UI/GTK2/src/aboutDialog_glade.cc:342 UI/GTK2/src/mainWindow_glade.cc:449
 msgid "Pinot"
 msgstr ""
 
@@ -51,16 +51,16 @@
 msgid "Current User"
 msgstr ""
 
-#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:79
-#: UI/GTK2/src/mainWindow.cc:631 UI/GTK2/src/mainWindow.cc:1059
-#: UI/GTK2/src/mainWindow.cc:2514 UI/GTK2/src/PinotSettings.cpp:198
-#: UI/GTK2/src/PinotSettings.cpp:859 UI/GTK2/src/PinotSettings.cpp:915
+#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:78
+#: UI/GTK2/src/mainWindow.cc:628 UI/GTK2/src/mainWindow.cc:1052
+#: UI/GTK2/src/mainWindow.cc:2512 UI/GTK2/src/PinotSettings.cpp:198
+#: UI/GTK2/src/PinotSettings.cpp:864 UI/GTK2/src/PinotSettings.cpp:920
 msgid "My Documents"
 msgstr ""
 
-#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:635
-#: UI/GTK2/src/MonitorHandler.cpp:173 UI/GTK2/src/PinotSettings.cpp:199
-#: UI/GTK2/src/PinotSettings.cpp:860 UI/GTK2/src/PinotSettings.cpp:916
+#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:632
+#: UI/GTK2/src/MonitorHandler.cpp:174 UI/GTK2/src/PinotSettings.cpp:199
+#: UI/GTK2/src/PinotSettings.cpp:865 UI/GTK2/src/PinotSettings.cpp:921
 #: UI/GTK2/src/prefsDialog_glade.cc:116
 msgid "My Email"
 msgstr ""
@@ -136,226 +136,230 @@
 msgid "Timestamp"
 msgstr ""
 
-#: UI/GTK2/src/IndexTree.cpp:219 UI/GTK2/src/WorkerThreads.cpp:341
+#: UI/GTK2/src/IndexTree.cpp:219 UI/GTK2/src/WorkerThreads.cpp:340
 msgid "No title"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:78 UI/GTK2/src/mainWindow.cc:489
-#: UI/GTK2/src/mainWindow.cc:684
+#: UI/GTK2/src/mainWindow.cc:77 UI/GTK2/src/mainWindow.cc:486
+#: UI/GTK2/src/mainWindow.cc:681 UI/GTK2/src/queryDialog.cc:81
 msgid "None"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:217
+#: UI/GTK2/src/mainWindow.cc:216
 msgid "Query Name"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:222
+#: UI/GTK2/src/mainWindow.cc:221
 msgid "Last Run"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:223
+#: UI/GTK2/src/mainWindow.cc:222
 msgid "Summary"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:306
+#: UI/GTK2/src/mainWindow.cc:303
 msgid "Add index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:307
+#: UI/GTK2/src/mainWindow.cc:304
 msgid "Remove index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:332
+#: UI/GTK2/src/mainWindow.cc:329
 msgid "Ready"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:385
+#: UI/GTK2/src/mainWindow.cc:382
 msgid "N/A"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:395 UI/GTK2/src/mainWindow.cc:1480
+#: UI/GTK2/src/mainWindow.cc:392
 msgid "<undefined>"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:602
+#: UI/GTK2/src/mainWindow.cc:599
 msgid "Result location is"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:646
+#: UI/GTK2/src/mainWindow.cc:643
 msgid "Document location is"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:687
+#: UI/GTK2/src/mainWindow.cc:684
 msgid "No labels"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:791
+#: UI/GTK2/src/mainWindow.cc:788
 msgid "Showing"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:796
+#: UI/GTK2/src/mainWindow.cc:793
 msgid "off"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:801
+#: UI/GTK2/src/mainWindow.cc:798
 msgid "documents from"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:871
+#: UI/GTK2/src/mainWindow.cc:852
 msgid "Query"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:875 UI/GTK2/src/mainWindow.cc:2482
+#: UI/GTK2/src/mainWindow.cc:856 UI/GTK2/src/mainWindow.cc:2480
 #: UI/GTK2/src/ResultsTree.cpp:436 UI/GTK2/src/ResultsTree.cpp:708
 msgid "on"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:879
+#: UI/GTK2/src/mainWindow.cc:860
 msgid "ended"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:940 UI/GTK2/src/propertiesDialog.cc:34
+#: UI/GTK2/src/mainWindow.cc:921 UI/GTK2/src/propertiesDialog.cc:34
 msgid "Label"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:944
+#: UI/GTK2/src/mainWindow.cc:925
 msgid "matches"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:949
+#: UI/GTK2/src/mainWindow.cc:930
 msgid "document(s)"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1027 UI/GTK2/src/mainWindow.cc:1122
+#: UI/GTK2/src/mainWindow.cc:967
+msgid "Updated label(s)"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:1020 UI/GTK2/src/mainWindow.cc:1117
 msgid "Updated document"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1034
+#: UI/GTK2/src/mainWindow.cc:1027
 msgid "Indexed"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1101
+#: UI/GTK2/src/mainWindow.cc:1096
 msgid "Unindexed document(s)"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1179
+#: UI/GTK2/src/mainWindow.cc:1174
 msgid "Couldn't rename index, name"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1183 UI/GTK2/src/mainWindow.cc:1914
-#: UI/GTK2/src/mainWindow.cc:2024 UI/GTK2/src/mainWindow.cc:2081
+#: UI/GTK2/src/mainWindow.cc:1178 UI/GTK2/src/mainWindow.cc:1932
+#: UI/GTK2/src/mainWindow.cc:2314
 msgid "is already in use"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1196
+#: UI/GTK2/src/mainWindow.cc:1191
 msgid "Couldn't rename index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1209
+#: UI/GTK2/src/mainWindow.cc:1204
 msgid "Edited index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1581 UI/GTK2/src/mainWindow.cc:1640
+#: UI/GTK2/src/mainWindow.cc:1588 UI/GTK2/src/mainWindow.cc:1649
 msgid "Please set a location for the index first"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1597
+#: UI/GTK2/src/mainWindow.cc:1604
 msgid "Result location is unknown"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1613
+#: UI/GTK2/src/mainWindow.cc:1620
 msgid "Import Document(s)"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1693 UI/GTK2/src/mainWindow_glade.cc:163
-#: UI/GTK2/src/pinot.cpp:111 UI/GTK2/src/pinot.cpp:116
-#: UI/GTK2/src/WorkerThreads.cpp:184 UI/GTK2/src/WorkerThreads.cpp:417
-#: UI/GTK2/src/WorkerThreads.cpp:960
+#: UI/GTK2/src/mainWindow.cc:1706 UI/GTK2/src/mainWindow_glade.cc:163
+#: UI/GTK2/src/pinot.cpp:115 UI/GTK2/src/pinot.cpp:120
+#: UI/GTK2/src/WorkerThreads.cpp:183 UI/GTK2/src/WorkerThreads.cpp:416
+#: UI/GTK2/src/WorkerThreads.cpp:1029
 msgid "Index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1697 UI/GTK2/src/WorkerThreads.cpp:188
-#: UI/GTK2/src/WorkerThreads.cpp:421 UI/GTK2/src/WorkerThreads.cpp:964
+#: UI/GTK2/src/mainWindow.cc:1710 UI/GTK2/src/WorkerThreads.cpp:187
+#: UI/GTK2/src/WorkerThreads.cpp:420 UI/GTK2/src/WorkerThreads.cpp:1033
 msgid "doesn't exist"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1805
+#: UI/GTK2/src/mainWindow.cc:1823
 msgid "Delete this document from the index ?"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1816
+#: UI/GTK2/src/mainWindow.cc:1834
 msgid "Delete these documents from the index ?"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1910
+#: UI/GTK2/src/mainWindow.cc:1928
 msgid "Index name"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1925
+#: UI/GTK2/src/mainWindow.cc:1943
 msgid "Couldn't add index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1939
+#: UI/GTK2/src/mainWindow.cc:1957
 msgid "Added new index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1974
+#: UI/GTK2/src/mainWindow.cc:1992
 msgid "Couldn't remove index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2020 UI/GTK2/src/mainWindow.cc:2077
-msgid "Query name"
+#: UI/GTK2/src/mainWindow.cc:2180
+msgid "At least one background task hasn't been completed yet. Quit now ?"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2034
-msgid "Couldn't add query"
+#: UI/GTK2/src/mainWindow.cc:2310
+msgid "Query name"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2043
-msgid "Added new query"
-msgstr ""
-
-#: UI/GTK2/src/mainWindow.cc:2102
+#: UI/GTK2/src/mainWindow.cc:2337
 msgid "Couldn't update query"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2111
+#: UI/GTK2/src/mainWindow.cc:2345
 msgid "Edited query"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2263
-msgid "At least one background task hasn't been completed yet. Quit now ?"
+#: UI/GTK2/src/mainWindow.cc:2352
+msgid "Couldn't add query"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2376
+#: UI/GTK2/src/mainWindow.cc:2360
+msgid "Added new query"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2374
 msgid "Query is not set"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2387
+#: UI/GTK2/src/mainWindow.cc:2385
 msgid "No search engine selected"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2469
+#: UI/GTK2/src/mainWindow.cc:2467
 msgid "Please set the Google API key first"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2478
+#: UI/GTK2/src/mainWindow.cc:2476
 msgid "Running query"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2628
+#: UI/GTK2/src/mainWindow.cc:2607
 msgid "No URL to browse"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2642
+#: UI/GTK2/src/mainWindow.cc:2621
 msgid "No browser configured to view results"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2654
+#: UI/GTK2/src/mainWindow.cc:2633
 msgid "Couldn't browse URL:"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2883
+#: UI/GTK2/src/mainWindow.cc:2865
 msgid "thread(s)"
 msgstr ""
 
@@ -375,6 +379,14 @@
 msgid "Results"
 msgstr ""
 
+#: UI/GTK2/src/mainWindow_glade.cc:148
+msgid "Show Previous"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow_glade.cc:154
+msgid "Show Next"
+msgstr ""
+
 #: UI/GTK2/src/mainWindow_glade.cc:166 UI/GTK2/src/mainWindow_glade.cc:234
 msgid "View"
 msgstr ""
@@ -429,7 +441,7 @@
 
 #: UI/GTK2/src/mainWindow_glade.cc:243
 #: UI/GTK2/src/propertiesDialog_glade.cc:174
-#: UI/GTK2/src/queryDialog_glade.cc:80
+#: UI/GTK2/src/queryDialog_glade.cc:83
 msgid "Properties"
 msgstr ""
 
@@ -457,63 +469,63 @@
 msgid "Couldn't save configuration file"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:112 UI/GTK2/src/pinot.cpp:117
+#: UI/GTK2/src/pinot.cpp:116 UI/GTK2/src/pinot.cpp:121
 msgid "is not valid, please check"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:127
+#: UI/GTK2/src/pinot.cpp:130
 msgid "History database"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:128
+#: UI/GTK2/src/pinot.cpp:131
 msgid "couldn't be created"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:134
+#: UI/GTK2/src/pinot.cpp:137
 msgid "Danish"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:135
+#: UI/GTK2/src/pinot.cpp:138
 msgid "Dutch"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:136
+#: UI/GTK2/src/pinot.cpp:139
 msgid "English"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:137
+#: UI/GTK2/src/pinot.cpp:140
 msgid "Finnish"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:138
+#: UI/GTK2/src/pinot.cpp:141
 msgid "French"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:139
+#: UI/GTK2/src/pinot.cpp:142
 msgid "German"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:140
+#: UI/GTK2/src/pinot.cpp:143
 msgid "Italian"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:141
+#: UI/GTK2/src/pinot.cpp:144
 msgid "Norwegian"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:142
+#: UI/GTK2/src/pinot.cpp:145
 msgid "Portuguese"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:143
+#: UI/GTK2/src/pinot.cpp:146
 msgid "Russian"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:144
+#: UI/GTK2/src/pinot.cpp:147
 msgid "Spanish"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:145
+#: UI/GTK2/src/pinot.cpp:148
 msgid "Swedish"
 msgstr ""
 
@@ -561,47 +573,47 @@
 msgid "Couldn't load mailaccount block"
 msgstr ""
 
-#: UI/GTK2/src/PinotSettings.cpp:711
+#: UI/GTK2/src/PinotSettings.cpp:715
 msgid "Unclassified"
 msgstr ""
 
-#: UI/GTK2/src/prefsDialog.cc:63
+#: UI/GTK2/src/prefsDialog.cc:62
 msgid "Name"
 msgstr ""
 
-#: UI/GTK2/src/prefsDialog.cc:71
+#: UI/GTK2/src/prefsDialog.cc:70
 msgid "Location"
 msgstr ""
 
-#: UI/GTK2/src/prefsDialog.cc:72
+#: UI/GTK2/src/prefsDialog.cc:71
 msgid "MIME Type"
 msgstr ""
 
-#: UI/GTK2/src/prefsDialog.cc:100
+#: UI/GTK2/src/prefsDialog.cc:107
 msgid "In internal viewer"
 msgstr ""
 
-#: UI/GTK2/src/prefsDialog.cc:103
+#: UI/GTK2/src/prefsDialog.cc:110
 msgid "In browser"
 msgstr ""
 
-#: UI/GTK2/src/prefsDialog.cc:364
+#: UI/GTK2/src/prefsDialog.cc:352
 msgid "Browser location"
 msgstr ""
 
-#: UI/GTK2/src/prefsDialog.cc:375
+#: UI/GTK2/src/prefsDialog.cc:363
 msgid "New Label"
 msgstr ""
 
-#: UI/GTK2/src/prefsDialog.cc:397
+#: UI/GTK2/src/prefsDialog.cc:385
 msgid "Colour"
 msgstr ""
 
-#: UI/GTK2/src/prefsDialog.cc:463
+#: UI/GTK2/src/prefsDialog.cc:451
 msgid "Import Mail Box(es)"
 msgstr ""
 
-#: UI/GTK2/src/prefsDialog.cc:481
+#: UI/GTK2/src/prefsDialog.cc:469
 msgid "Mbox File Location"
 msgstr ""
 
@@ -665,7 +677,7 @@
 msgid "Language:"
 msgstr ""
 
-#: UI/GTK2/src/queryDialog.cc:107
+#: UI/GTK2/src/queryDialog.cc:86 UI/GTK2/src/queryDialog.cc:115
 msgid "Any"
 msgstr ""
 
@@ -678,138 +690,144 @@
 msgstr ""
 
 #: UI/GTK2/src/queryDialog_glade.cc:73
-msgid "Host name:"
+msgid "File name:"
 msgstr ""
 
 #: UI/GTK2/src/queryDialog_glade.cc:74
-msgid "File name:"
+msgid "Number of results:"
 msgstr ""
 
-#: UI/GTK2/src/queryDialog_glade.cc:75
-msgid "Number of results:"
+#: UI/GTK2/src/queryDialog_glade.cc:77
+msgid "Host name:"
 msgstr ""
 
-#: UI/GTK2/src/queryDialog_glade.cc:81
+#: UI/GTK2/src/queryDialog_glade.cc:78
+msgid "None of the words:"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:84
 msgid "Limit to documents that match"
 msgstr ""
 
-#: UI/GTK2/src/queryDialog_glade.cc:85
+#: UI/GTK2/src/queryDialog_glade.cc:87
 msgid "the exact phrase:"
 msgstr ""
 
-#: UI/GTK2/src/queryDialog_glade.cc:86
-msgid "none of the words:"
-msgstr ""
-
-#: UI/GTK2/src/queryDialog_glade.cc:87
+#: UI/GTK2/src/queryDialog_glade.cc:88
 msgid "the language:"
 msgstr ""
 
-#: UI/GTK2/src/queryDialog_glade.cc:91
+#: UI/GTK2/src/queryDialog_glade.cc:92
 msgid "all the words:"
 msgstr ""
 
-#: UI/GTK2/src/queryDialog_glade.cc:94
+#: UI/GTK2/src/queryDialog_glade.cc:93
+msgid "the label:"
+msgstr ""
+
+#: UI/GTK2/src/queryDialog_glade.cc:98
 msgid "Advanced"
 msgstr ""
 
-#: UI/GTK2/src/queryDialog_glade.cc:278
+#: UI/GTK2/src/queryDialog_glade.cc:290
 msgid "Query properties"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:163
+#: UI/GTK2/src/WorkerThreads.cpp:162
 msgid "Stopped browsing"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:197 UI/GTK2/src/WorkerThreads.cpp:632
-#: UI/GTK2/src/WorkerThreads.cpp:838 UI/GTK2/src/WorkerThreads.cpp:973
+#: UI/GTK2/src/WorkerThreads.cpp:196 UI/GTK2/src/WorkerThreads.cpp:428
+#: UI/GTK2/src/WorkerThreads.cpp:476 UI/GTK2/src/WorkerThreads.cpp:486
+#: UI/GTK2/src/WorkerThreads.cpp:710 UI/GTK2/src/WorkerThreads.cpp:911
+#: UI/GTK2/src/WorkerThreads.cpp:1042
 msgid "Index error on"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:303
+#: UI/GTK2/src/WorkerThreads.cpp:302
 msgid "Stopped querying"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:315
+#: UI/GTK2/src/WorkerThreads.cpp:314
 msgid "Couldn't create search engine"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:327
+#: UI/GTK2/src/WorkerThreads.cpp:326
 msgid "Couldn't run query on search engine"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:401
+#: UI/GTK2/src/WorkerThreads.cpp:400 UI/GTK2/src/WorkerThreads.cpp:467
 msgid "Stopped querying index labels"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:482
+#: UI/GTK2/src/WorkerThreads.cpp:560
 msgid "Stopped retrieval of"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:518
+#: UI/GTK2/src/WorkerThreads.cpp:596
 msgid "Couldn't obtain downloader for protocol"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:532 UI/GTK2/src/WorkerThreads.cpp:646
+#: UI/GTK2/src/WorkerThreads.cpp:610 UI/GTK2/src/WorkerThreads.cpp:724
 msgid "Couldn't retrieve"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:617
+#: UI/GTK2/src/WorkerThreads.cpp:695
 msgid "Stopped indexing"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:671
+#: UI/GTK2/src/WorkerThreads.cpp:749
 msgid "Cannot index document type"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:675
+#: UI/GTK2/src/WorkerThreads.cpp:753
 msgid "at"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:693
+#: UI/GTK2/src/WorkerThreads.cpp:771
 msgid "Couln't tokenize"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:714
+#: UI/GTK2/src/WorkerThreads.cpp:792
 msgid "Robots META tag forbids indexing"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:760
+#: UI/GTK2/src/WorkerThreads.cpp:834
 msgid "Couldn't index"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:825
+#: UI/GTK2/src/WorkerThreads.cpp:899
 msgid "Stopped unindexing document(s)"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:846
+#: UI/GTK2/src/WorkerThreads.cpp:919
 msgid "Couldn't unindex document(s)"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:945
+#: UI/GTK2/src/WorkerThreads.cpp:1014
 msgid "Stopped document update for "
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:982
+#: UI/GTK2/src/WorkerThreads.cpp:1051
 msgid "Couldn't update document"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:1022
+#: UI/GTK2/src/WorkerThreads.cpp:1091
 msgid "Stopped listening on"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:1114
+#: UI/GTK2/src/WorkerThreads.cpp:1189
 msgid "Couldn't read FIFO at"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:1154
+#: UI/GTK2/src/WorkerThreads.cpp:1229
 msgid "Stopped monitoring"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:1172
+#: UI/GTK2/src/WorkerThreads.cpp:1247
 msgid "No monitoring handler"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:1206
+#: UI/GTK2/src/WorkerThreads.cpp:1281
 msgid "Couldn't open FAM connection"
 msgstr ""

Modified: trunk/po/fr_FR.po
===================================================================
--- trunk/po/fr_FR.po	2005-12-17 16:40:35 UTC (rev 23)
+++ trunk/po/fr_FR.po	2005-12-17 16:41:27 UTC (rev 24)
@@ -27,7 +27,7 @@
 "Content-Type: text/plain; charset=utf-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 
-#: UI/GTK2/src/aboutDialog_glade.cc:342 UI/GTK2/src/mainWindow_glade.cc:445
+#: UI/GTK2/src/aboutDialog_glade.cc:342 UI/GTK2/src/mainWindow_glade.cc:449
 msgid "Pinot"
 msgstr "Pinot"
 
@@ -51,16 +51,16 @@
 msgid "Current User"
 msgstr "Utilisateur"
 
-#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:79
-#: UI/GTK2/src/mainWindow.cc:631 UI/GTK2/src/mainWindow.cc:1059
-#: UI/GTK2/src/mainWindow.cc:2514 UI/GTK2/src/PinotSettings.cpp:198
-#: UI/GTK2/src/PinotSettings.cpp:859 UI/GTK2/src/PinotSettings.cpp:915
+#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:78
+#: UI/GTK2/src/mainWindow.cc:628 UI/GTK2/src/mainWindow.cc:1052
+#: UI/GTK2/src/mainWindow.cc:2512 UI/GTK2/src/PinotSettings.cpp:198
+#: UI/GTK2/src/PinotSettings.cpp:864 UI/GTK2/src/PinotSettings.cpp:920
 msgid "My Documents"
 msgstr "Mes Documents"
 
-#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:635
-#: UI/GTK2/src/MonitorHandler.cpp:173 UI/GTK2/src/PinotSettings.cpp:199
-#: UI/GTK2/src/PinotSettings.cpp:860 UI/GTK2/src/PinotSettings.cpp:916
+#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:632
+#: UI/GTK2/src/MonitorHandler.cpp:174 UI/GTK2/src/PinotSettings.cpp:199
+#: UI/GTK2/src/PinotSettings.cpp:865 UI/GTK2/src/PinotSettings.cpp:921
 #: UI/GTK2/src/prefsDialog_glade.cc:116
 msgid "My Email"
 msgstr "Mon Courrier"
@@ -136,226 +136,230 @@
 msgid "Timestamp"
 msgstr "Date"
 
-#: UI/GTK2/src/IndexTree.cpp:219 UI/GTK2/src/WorkerThreads.cpp:341
+#: UI/GTK2/src/IndexTree.cpp:219 UI/GTK2/src/WorkerThreads.cpp:340
 msgid "No title"
 msgstr "Pas de titre"
 
-#: UI/GTK2/src/mainWindow.cc:78 UI/GTK2/src/mainWindow.cc:489
-#: UI/GTK2/src/mainWindow.cc:684
+#: UI/GTK2/src/mainWindow.cc:77 UI/GTK2/src/mainWindow.cc:486
+#: UI/GTK2/src/mainWindow.cc:681 UI/GTK2/src/queryDialog.cc:81
 msgid "None"
 msgstr "Aucune"
 
-#: UI/GTK2/src/mainWindow.cc:217
+#: UI/GTK2/src/mainWindow.cc:216
 msgid "Query Name"
 msgstr "Nom de la Recherche"
 
-#: UI/GTK2/src/mainWindow.cc:222
+#: UI/GTK2/src/mainWindow.cc:221
 msgid "Last Run"
 msgstr "Derniere Utilisation"
 
-#: UI/GTK2/src/mainWindow.cc:223
+#: UI/GTK2/src/mainWindow.cc:222
 msgid "Summary"
 msgstr "Sommaire"
 
-#: UI/GTK2/src/mainWindow.cc:306
+#: UI/GTK2/src/mainWindow.cc:303
 msgid "Add index"
 msgstr "Ajouter un index"
 
-#: UI/GTK2/src/mainWindow.cc:307
+#: UI/GTK2/src/mainWindow.cc:304
 msgid "Remove index"
 msgstr "Enlever un index"
 
-#: UI/GTK2/src/mainWindow.cc:332
+#: UI/GTK2/src/mainWindow.cc:329
 msgid "Ready"
 msgstr "Pret"
 
-#: UI/GTK2/src/mainWindow.cc:385
+#: UI/GTK2/src/mainWindow.cc:382
 msgid "N/A"
 msgstr "Inconnue"
 
-#: UI/GTK2/src/mainWindow.cc:395 UI/GTK2/src/mainWindow.cc:1480
+#: UI/GTK2/src/mainWindow.cc:392
 msgid "<undefined>"
 msgstr "<inconnu>"
 
-#: UI/GTK2/src/mainWindow.cc:602
+#: UI/GTK2/src/mainWindow.cc:599
 msgid "Result location is"
 msgstr "La location du resultat est"
 
-#: UI/GTK2/src/mainWindow.cc:646
+#: UI/GTK2/src/mainWindow.cc:643
 msgid "Document location is"
 msgstr "La location du document is"
 
-#: UI/GTK2/src/mainWindow.cc:687
+#: UI/GTK2/src/mainWindow.cc:684
 msgid "No labels"
 msgstr "Pas d'etiquettes"
 
-#: UI/GTK2/src/mainWindow.cc:791
+#: UI/GTK2/src/mainWindow.cc:788
 msgid "Showing"
 msgstr "Listant"
 
-#: UI/GTK2/src/mainWindow.cc:796
+#: UI/GTK2/src/mainWindow.cc:793
 msgid "off"
 msgstr "de"
 
-#: UI/GTK2/src/mainWindow.cc:801
+#: UI/GTK2/src/mainWindow.cc:798
 msgid "documents from"
 msgstr "documents venant de"
 
-#: UI/GTK2/src/mainWindow.cc:871
+#: UI/GTK2/src/mainWindow.cc:852
 msgid "Query"
 msgstr "La recherche"
 
-#: UI/GTK2/src/mainWindow.cc:875 UI/GTK2/src/mainWindow.cc:2482
+#: UI/GTK2/src/mainWindow.cc:856 UI/GTK2/src/mainWindow.cc:2480
 #: UI/GTK2/src/ResultsTree.cpp:436 UI/GTK2/src/ResultsTree.cpp:708
 msgid "on"
 msgstr "sur"
 
-#: UI/GTK2/src/mainWindow.cc:879
+#: UI/GTK2/src/mainWindow.cc:860
 msgid "ended"
 msgstr "est terminee"
 
-#: UI/GTK2/src/mainWindow.cc:940 UI/GTK2/src/propertiesDialog.cc:34
+#: UI/GTK2/src/mainWindow.cc:921 UI/GTK2/src/propertiesDialog.cc:34
 msgid "Label"
 msgstr "L'etiquette"
 
-#: UI/GTK2/src/mainWindow.cc:944
+#: UI/GTK2/src/mainWindow.cc:925
 msgid "matches"
 msgstr "correspond a"
 
-#: UI/GTK2/src/mainWindow.cc:949
+#: UI/GTK2/src/mainWindow.cc:930
 msgid "document(s)"
 msgstr "document(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1027 UI/GTK2/src/mainWindow.cc:1122
+#: UI/GTK2/src/mainWindow.cc:967
+msgid "Updated label(s)"
+msgstr "Mis a jour l(es) etiquette(s)"
+
+#: UI/GTK2/src/mainWindow.cc:1020 UI/GTK2/src/mainWindow.cc:1117
 msgid "Updated document"
 msgstr "Mis a jour le document"
 
-#: UI/GTK2/src/mainWindow.cc:1034
+#: UI/GTK2/src/mainWindow.cc:1027
 msgid "Indexed"
 msgstr "Indexe"
 
-#: UI/GTK2/src/mainWindow.cc:1101
+#: UI/GTK2/src/mainWindow.cc:1096
 msgid "Unindexed document(s)"
 msgstr "Desindexe le(s) document(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1179
+#: UI/GTK2/src/mainWindow.cc:1174
 msgid "Couldn't rename index, name"
 msgstr "N'a pas pu renommer l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1183 UI/GTK2/src/mainWindow.cc:1914
-#: UI/GTK2/src/mainWindow.cc:2024 UI/GTK2/src/mainWindow.cc:2081
+#: UI/GTK2/src/mainWindow.cc:1178 UI/GTK2/src/mainWindow.cc:1932
+#: UI/GTK2/src/mainWindow.cc:2314
 msgid "is already in use"
 msgstr "est deja utilise"
 
-#: UI/GTK2/src/mainWindow.cc:1196
+#: UI/GTK2/src/mainWindow.cc:1191
 msgid "Couldn't rename index"
 msgstr "N'a pas pu renommer l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1209
+#: UI/GTK2/src/mainWindow.cc:1204
 msgid "Edited index"
 msgstr "Edite l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1581 UI/GTK2/src/mainWindow.cc:1640
+#: UI/GTK2/src/mainWindow.cc:1588 UI/GTK2/src/mainWindow.cc:1649
 msgid "Please set a location for the index first"
 msgstr "Donnez une location a l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1597
+#: UI/GTK2/src/mainWindow.cc:1604
 msgid "Result location is unknown"
 msgstr "La location du resultat est inconnue"
 
-#: UI/GTK2/src/mainWindow.cc:1613
+#: UI/GTK2/src/mainWindow.cc:1620
 msgid "Import Document(s)"
 msgstr "Importation de Document(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1693 UI/GTK2/src/mainWindow_glade.cc:163
-#: UI/GTK2/src/pinot.cpp:111 UI/GTK2/src/pinot.cpp:116
-#: UI/GTK2/src/WorkerThreads.cpp:184 UI/GTK2/src/WorkerThreads.cpp:417
-#: UI/GTK2/src/WorkerThreads.cpp:960
+#: UI/GTK2/src/mainWindow.cc:1706 UI/GTK2/src/mainWindow_glade.cc:163
+#: UI/GTK2/src/pinot.cpp:115 UI/GTK2/src/pinot.cpp:120
+#: UI/GTK2/src/WorkerThreads.cpp:183 UI/GTK2/src/WorkerThreads.cpp:416
+#: UI/GTK2/src/WorkerThreads.cpp:1029
 msgid "Index"
 msgstr "L'index"
 
-#: UI/GTK2/src/mainWindow.cc:1697 UI/GTK2/src/WorkerThreads.cpp:188
-#: UI/GTK2/src/WorkerThreads.cpp:421 UI/GTK2/src/WorkerThreads.cpp:964
+#: UI/GTK2/src/mainWindow.cc:1710 UI/GTK2/src/WorkerThreads.cpp:187
+#: UI/GTK2/src/WorkerThreads.cpp:420 UI/GTK2/src/WorkerThreads.cpp:1033
 msgid "doesn't exist"
 msgstr "n'existe pas"
 
-#: UI/GTK2/src/mainWindow.cc:1805
+#: UI/GTK2/src/mainWindow.cc:1823
 msgid "Delete this document from the index ?"
 msgstr "Enlever ce document de l'index ?"
 
-#: UI/GTK2/src/mainWindow.cc:1816
+#: UI/GTK2/src/mainWindow.cc:1834
 msgid "Delete these documents from the index ?"
 msgstr "Enlever ces documents de l'index ?"
 
-#: UI/GTK2/src/mainWindow.cc:1910
+#: UI/GTK2/src/mainWindow.cc:1928
 msgid "Index name"
 msgstr "Nom de l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1925
+#: UI/GTK2/src/mainWindow.cc:1943
 msgid "Couldn't add index"
 msgstr "N'a pas pu ajouter l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1939
+#: UI/GTK2/src/mainWindow.cc:1957
 msgid "Added new index"
 msgstr "Ajouter un nouvel index"
 
-#: UI/GTK2/src/mainWindow.cc:1974
+#: UI/GTK2/src/mainWindow.cc:1992
 msgid "Couldn't remove index"
 msgstr "N'a pas pu enlever l'index"
 
-#: UI/GTK2/src/mainWindow.cc:2020 UI/GTK2/src/mainWindow.cc:2077
-msgid "Query name"
+#: UI/GTK2/src/mainWindow.cc:2180
+msgid "At least one background task hasn't been completed yet. Quit now ?"
 msgstr "Nom de la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2034
-msgid "Couldn't add query"
+#: UI/GTK2/src/mainWindow.cc:2310
+msgid "Query name"
 msgstr "N'a pas pu ajouter la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2043
-msgid "Added new query"
+#: UI/GTK2/src/mainWindow.cc:2337
+msgid "Couldn't update query"
 msgstr "Ajoute une nouvelle recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2102
-msgid "Couldn't update query"
+#: UI/GTK2/src/mainWindow.cc:2345
+msgid "Edited query"
 msgstr "N'a pas pu mettre a jour la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2111
-msgid "Edited query"
+#: UI/GTK2/src/mainWindow.cc:2352
+msgid "Couldn't add query"
 msgstr "Edite la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2263
-msgid "At least one background task hasn't been completed yet. Quit now ?"
+#: UI/GTK2/src/mainWindow.cc:2360
+msgid "Added new query"
 msgstr "Au moins une tache n'est pas terminee. Quitter maintenant ?"
 
-#: UI/GTK2/src/mainWindow.cc:2376
+#: UI/GTK2/src/mainWindow.cc:2374
 msgid "Query is not set"
 msgstr "Recherche indefinie"
 
-#: UI/GTK2/src/mainWindow.cc:2387
+#: UI/GTK2/src/mainWindow.cc:2385
 msgid "No search engine selected"
 msgstr "Pas de moteur selectionne"
 
-#: UI/GTK2/src/mainWindow.cc:2469
+#: UI/GTK2/src/mainWindow.cc:2467
 msgid "Please set the Google API key first"
 msgstr "Configurez la clef de l'API Google "
 
-#: UI/GTK2/src/mainWindow.cc:2478
+#: UI/GTK2/src/mainWindow.cc:2476
 msgid "Running query"
 msgstr "Recherche en cours"
 
-#: UI/GTK2/src/mainWindow.cc:2628
+#: UI/GTK2/src/mainWindow.cc:2607
 msgid "No URL to browse"
 msgstr "Pas d'URL a brouter"
 
-#: UI/GTK2/src/mainWindow.cc:2642
+#: UI/GTK2/src/mainWindow.cc:2621
 msgid "No browser configured to view results"
 msgstr "Pas de brouter configure"
 
-#: UI/GTK2/src/mainWindow.cc:2654
+#: UI/GTK2/src/mainWindow.cc:2633
 msgid "Couldn't browse URL:"
 msgstr "N'a pas pu brouter l'URL"
 
-#: UI/GTK2/src/mainWindow.cc:2883
+#: UI/GTK2/src/mainWindow.cc:2865
 msgid "thread(s)"
 msgstr "tache(s)"
 
@@ -375,6 +379,14 @@
 msgid "Results"
 msgstr "Resultats"
 
+#: UI/GTK2/src/mainWindow_glade.cc:148
+msgid "Show Previous"
+msgstr "Precedents"
+
+#: UI/GTK2/src/mainWindow_glade.cc:154
+msgid "Show Next"
+msgstr "Suivants"
+
 #: UI/GTK2/src/mainWindow_glade.cc:166 UI/GTK2/src/mainWindow_glade.cc:234
 msgid "View"
 msgstr "Voir"
@@ -429,7 +441,7 @@
 
 #: UI/GTK2/src/mainWindow_glade.cc:243
 #: UI/GTK2/src/propertiesDialog_glade.cc:174
-#: UI/GTK2/src/queryDialog_glade.cc:80
+#: UI/GTK2/src/queryDialog_glade.cc:83
 msgid "Properties"
 msgstr "Proprietes"
 
@@ -457,63 +469,63 @@
 msgid "Couldn't save configuration file"
 msgstr "N'a pas pu sauver la configuration"
 
-#: UI/GTK2/src/pinot.cpp:112 UI/GTK2/src/pinot.cpp:117
+#: UI/GTK2/src/pinot.cpp:116 UI/GTK2/src/pinot.cpp:121
 msgid "is not valid, please check"
 msgstr "n'est pas valide, veuillez verifier"
 
-#: UI/GTK2/src/pinot.cpp:127
+#: UI/GTK2/src/pinot.cpp:130
 msgid "History database"
 msgstr "La base des historiques"
 
-#: UI/GTK2/src/pinot.cpp:128
+#: UI/GTK2/src/pinot.cpp:131
 msgid "couldn't be created"
 msgstr "n'a pas pu etre creee"
 
-#: UI/GTK2/src/pinot.cpp:134
+#: UI/GTK2/src/pinot.cpp:137
 msgid "Danish"
 msgstr "Danois"
 
-#: UI/GTK2/src/pinot.cpp:135
+#: UI/GTK2/src/pinot.cpp:138
 msgid "Dutch"
 msgstr "Hollandais"
 
-#: UI/GTK2/src/pinot.cpp:136
+#: UI/GTK2/src/pinot.cpp:139
 msgid "English"
 msgstr "Anglais"
 
-#: UI/GTK2/src/pinot.cpp:137
+#: UI/GTK2/src/pinot.cpp:140
 msgid "Finnish"
 msgstr "Finlandais"
 
-#: UI/GTK2/src/pinot.cpp:138
+#: UI/GTK2/src/pinot.cpp:141
 msgid "French"
 msgstr "Francais"
 
-#: UI/GTK2/src/pinot.cpp:139
+#: UI/GTK2/src/pinot.cpp:142
 msgid "German"
 msgstr "Allemand"
 
-#: UI/GTK2/src/pinot.cpp:140
+#: UI/GTK2/src/pinot.cpp:143
 msgid "Italian"
 msgstr "Italien"
 
-#: UI/GTK2/src/pinot.cpp:141
+#: UI/GTK2/src/pinot.cpp:144
 msgid "Norwegian"
 msgstr "Norvegien"
 
-#: UI/GTK2/src/pinot.cpp:142
+#: UI/GTK2/src/pinot.cpp:145
 msgid "Portuguese"
 msgstr "Portugais"
 
-#: UI/GTK2/src/pinot.cpp:143
+#: UI/GTK2/src/pinot.cpp:146
 msgid "Russian"
 msgstr "Russe"
 
-#: UI/GTK2/src/pinot.cpp:144
+#: UI/GTK2/src/pinot.cpp:147
 msgid "Spanish"
 msgstr "Espagnol"
 
-#: UI/GTK2/src/pinot.cpp:145
+#: UI/GTK2/src/pinot.cpp:148
 msgid "Swedish"
 msgstr "Suedois"
 
@@ -561,47 +573,47 @@
 msgid "Couldn't load mailaccount block"
 msgstr "N'a pas pu charger le bloc mailaccount"
 
-#: UI/GTK2/src/PinotSettings.cpp:711
+#: UI/GTK2/src/PinotSettings.cpp:715
 msgid "Unclassified"
 msgstr "Non classifie"
 
-#: UI/GTK2/src/prefsDialog.cc:63
+#: UI/GTK2/src/prefsDialog.cc:62
 msgid "Name"
 msgstr "Nom"
 
-#: UI/GTK2/src/prefsDialog.cc:71
+#: UI/GTK2/src/prefsDialog.cc:70
 msgid "Location"
 msgstr "Location"
 
-#: UI/GTK2/src/prefsDialog.cc:72
+#: UI/GTK2/src/prefsDialog.cc:71
 msgid "MIME Type"
 msgstr "Type MIME"
 
-#: UI/GTK2/src/prefsDialog.cc:100
+#: UI/GTK2/src/prefsDialog.cc:107
 msgid "In internal viewer"
 msgstr "Dans le brouteur interne"
 
-#: UI/GTK2/src/prefsDialog.cc:103
+#: UI/GTK2/src/prefsDialog.cc:110
 msgid "In browser"
 msgstr "Dans le brouteur"
 
-#: UI/GTK2/src/prefsDialog.cc:364
+#: UI/GTK2/src/prefsDialog.cc:352
 msgid "Browser location"
 msgstr "Brouter la location"
 
-#: UI/GTK2/src/prefsDialog.cc:375
+#: UI/GTK2/src/prefsDialog.cc:363
 msgid "New Label"
 msgstr "Nouvelle Etiquette"
 
-#: UI/GTK2/src/prefsDialog.cc:397
+#: UI/GTK2/src/prefsDialog.cc:385
 msgid "Colour"
 msgstr "Couleur"
 
-#: UI/GTK2/src/prefsDialog.cc:463
+#: UI/GTK2/src/prefsDialog.cc:451
 msgid "Import Mail Box(es)"
 msgstr "Impoter des Boites de Courrier"
 
-#: UI/GTK2/src/prefsDialog.cc:481
+#: UI/GTK2/src/prefsDialog.cc:469
 msgid "Mbox File Location"
 msgstr "Location du Fichier mbox"
 
@@ -665,7 +677,7 @@
 msgid "Language:"
 msgstr "Langue:"
 
-#: UI/GTK2/src/queryDialog.cc:107
+#: UI/GTK2/src/queryDialog.cc:86 UI/GTK2/src/queryDialog.cc:115
 msgid "Any"
 msgstr "N'importe"
 
@@ -678,138 +690,144 @@
 msgstr "N'importe lequel des mots:"
 
 #: UI/GTK2/src/queryDialog_glade.cc:73
-msgid "Host name:"
+msgid "File name:"
 msgstr "Nom de machine:"
 
 #: UI/GTK2/src/queryDialog_glade.cc:74
-msgid "File name:"
+msgid "Number of results:"
+msgstr "Nombre de resultats:"
+
+#: UI/GTK2/src/queryDialog_glade.cc:77
+msgid "Host name:"
 msgstr "Nom de fichier:"
 
-#: UI/GTK2/src/queryDialog_glade.cc:75
-msgid "Number of results:"
+#: UI/GTK2/src/queryDialog_glade.cc:78
+msgid "None of the words:"
 msgstr "Nombre de resultats:"
 
-#: UI/GTK2/src/queryDialog_glade.cc:81
+#: UI/GTK2/src/queryDialog_glade.cc:84
 msgid "Limit to documents that match"
 msgstr "Limiter aux documents qui ont"
 
-#: UI/GTK2/src/queryDialog_glade.cc:85
+#: UI/GTK2/src/queryDialog_glade.cc:87
 msgid "the exact phrase:"
 msgstr "la phrase"
 
-#: UI/GTK2/src/queryDialog_glade.cc:86
-msgid "none of the words:"
+#: UI/GTK2/src/queryDialog_glade.cc:88
+msgid "the language:"
 msgstr "aucun des mots"
 
-#: UI/GTK2/src/queryDialog_glade.cc:87
-msgid "the language:"
+#: UI/GTK2/src/queryDialog_glade.cc:92
+msgid "all the words:"
 msgstr "la langue"
 
-#: UI/GTK2/src/queryDialog_glade.cc:91
-msgid "all the words:"
+#: UI/GTK2/src/queryDialog_glade.cc:93
+msgid "the label:"
 msgstr "tous les mots"
 
-#: UI/GTK2/src/queryDialog_glade.cc:94
+#: UI/GTK2/src/queryDialog_glade.cc:98
 msgid "Advanced"
 msgstr "Avance"
 
-#: UI/GTK2/src/queryDialog_glade.cc:278
+#: UI/GTK2/src/queryDialog_glade.cc:290
 msgid "Query properties"
 msgstr "Proprietes de la recherche"
 
-#: UI/GTK2/src/WorkerThreads.cpp:163
+#: UI/GTK2/src/WorkerThreads.cpp:162
 msgid "Stopped browsing"
 msgstr "Arrete le brouteur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:197 UI/GTK2/src/WorkerThreads.cpp:632
-#: UI/GTK2/src/WorkerThreads.cpp:838 UI/GTK2/src/WorkerThreads.cpp:973
+#: UI/GTK2/src/WorkerThreads.cpp:196 UI/GTK2/src/WorkerThreads.cpp:428
+#: UI/GTK2/src/WorkerThreads.cpp:476 UI/GTK2/src/WorkerThreads.cpp:486
+#: UI/GTK2/src/WorkerThreads.cpp:710 UI/GTK2/src/WorkerThreads.cpp:911
+#: UI/GTK2/src/WorkerThreads.cpp:1042
 msgid "Index error on"
 msgstr "Erreur d'index sur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:303
+#: UI/GTK2/src/WorkerThreads.cpp:302
 msgid "Stopped querying"
 msgstr "Arrete la recherche"
 
-#: UI/GTK2/src/WorkerThreads.cpp:315
+#: UI/GTK2/src/WorkerThreads.cpp:314
 msgid "Couldn't create search engine"
 msgstr "N'a pas pu creer le moteur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:327
+#: UI/GTK2/src/WorkerThreads.cpp:326
 msgid "Couldn't run query on search engine"
 msgstr "N'a pas pu lancer la recherche sur le moteur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:401
+#: UI/GTK2/src/WorkerThreads.cpp:400 UI/GTK2/src/WorkerThreads.cpp:467
 msgid "Stopped querying index labels"
 msgstr "Arrete la recherche d'etiquettes"
 
-#: UI/GTK2/src/WorkerThreads.cpp:482
+#: UI/GTK2/src/WorkerThreads.cpp:560
 msgid "Stopped retrieval of"
 msgstr "Arrete le telechargement de"
 
-#: UI/GTK2/src/WorkerThreads.cpp:518
+#: UI/GTK2/src/WorkerThreads.cpp:596
 msgid "Couldn't obtain downloader for protocol"
 msgstr "N'a pas pu obtenir un brouteur pour ="
 
-#: UI/GTK2/src/WorkerThreads.cpp:532 UI/GTK2/src/WorkerThreads.cpp:646
+#: UI/GTK2/src/WorkerThreads.cpp:610 UI/GTK2/src/WorkerThreads.cpp:724
 msgid "Couldn't retrieve"
 msgstr "N'a pas pu telecharger"
 
-#: UI/GTK2/src/WorkerThreads.cpp:617
+#: UI/GTK2/src/WorkerThreads.cpp:695
 msgid "Stopped indexing"
 msgstr "Arrete l'indexation"
 
-#: UI/GTK2/src/WorkerThreads.cpp:671
+#: UI/GTK2/src/WorkerThreads.cpp:749
 msgid "Cannot index document type"
 msgstr "Impossible d'indexer de type de documents"
 
-#: UI/GTK2/src/WorkerThreads.cpp:675
+#: UI/GTK2/src/WorkerThreads.cpp:753
 msgid "at"
 msgstr "a"
 
-#: UI/GTK2/src/WorkerThreads.cpp:693
+#: UI/GTK2/src/WorkerThreads.cpp:771
 msgid "Couln't tokenize"
 msgstr "N'a pas pu tokenise"
 
-#: UI/GTK2/src/WorkerThreads.cpp:714
+#: UI/GTK2/src/WorkerThreads.cpp:792
 msgid "Robots META tag forbids indexing"
 msgstr "Le META tag Robots empeche d'indexer"
 
-#: UI/GTK2/src/WorkerThreads.cpp:760
+#: UI/GTK2/src/WorkerThreads.cpp:834
 msgid "Couldn't index"
 msgstr "N'a pas pu indexer"
 
-#: UI/GTK2/src/WorkerThreads.cpp:825
+#: UI/GTK2/src/WorkerThreads.cpp:899
 msgid "Stopped unindexing document(s)"
 msgstr "Arrete d'indexer les document(s)"
 
-#: UI/GTK2/src/WorkerThreads.cpp:846
+#: UI/GTK2/src/WorkerThreads.cpp:919
 msgid "Couldn't unindex document(s)"
 msgstr "N'a pas pu desindexer le(s) document(s)"
 
-#: UI/GTK2/src/WorkerThreads.cpp:945
+#: UI/GTK2/src/WorkerThreads.cpp:1014
 msgid "Stopped document update for "
 msgstr "Arrete la mise a jour pour "
 
-#: UI/GTK2/src/WorkerThreads.cpp:982
+#: UI/GTK2/src/WorkerThreads.cpp:1051
 msgid "Couldn't update document"
 msgstr "N'a pas pu mettre a jour le document"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1022
+#: UI/GTK2/src/WorkerThreads.cpp:1091
 msgid "Stopped listening on"
 msgstr "Arrete l'ecoute sur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1114
+#: UI/GTK2/src/WorkerThreads.cpp:1189
 msgid "Couldn't read FIFO at"
 msgstr "N'a pas pu lire la FIFO a"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1154
+#: UI/GTK2/src/WorkerThreads.cpp:1229
 msgid "Stopped monitoring"
 msgstr "Arrete la surveillance"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1172
+#: UI/GTK2/src/WorkerThreads.cpp:1247
 msgid "No monitoring handler"
 msgstr "Pas de moniteur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1206
+#: UI/GTK2/src/WorkerThreads.cpp:1281
 msgid "Couldn't open FAM connection"
 msgstr "N'a pas pu ouvrir la connection FAM"



From fabricecolin at berlios.de  Sun Dec 18 06:45:16 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sun, 18 Dec 2005 06:45:16 +0100
Subject: [Pinot-svn] r25 - trunk
Message-ID: <200512180545.jBI5jGVx017064@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-18 06:45:01 +0100 (Sun, 18 Dec 2005)
New Revision: 25

Modified:
   trunk/TODO
Log:
+4 items.


Modified: trunk/TODO
===================================================================
--- trunk/TODO	2005-12-17 16:41:27 UTC (rev 24)
+++ trunk/TODO	2005-12-18 05:45:01 UTC (rev 25)
@@ -9,6 +9,8 @@
 - Check for leaks with valgrind (eg --tool=memcheck -v --leak-check=yes --show-reachable=yes ...)
 - Change .spec to allow building with Google and ObjectsSearch SOAP APIs support
 - Don't use system(), fork and exec, especially for the external browser
+- Replace libmagic with xdgmime (built in gtk > 2.8), use it to determine which application
+  is for which MIME type too
 
 Search
 - Write a Spirit-based parser for extracting results from web pages
@@ -21,6 +23,7 @@
 - Add csourcesearch.net
 - Add http://www.patentcommons.org/commons/patentsearch.php
 - Apply Pinot specific filters (eg "L" for language) on internal indices only
+- Use Xapian's QueryParser, map fields (label, language, title etc...) to prefixes
 
 Collect
 - Comply with robot stuff defined at http://www.robotstxt.org/
@@ -31,6 +34,7 @@
 - Support for HTML frames
 - Write a tokenizer for RFCs that breaks chapters into individual documents
 - Allow to cache documents that had to be converted ? eg PDF, MS Word
+- Use poppler for the PDF tokenizer
 
 Index
 - Get hold of stopwords lists for the languages supported by Xapian's stemmers and don't index stop words
@@ -96,4 +100,5 @@
 - Add a Recent Import section that relies on documents timestamps
 - Filter documents by language, similarly to how labels are shown
 - Save query expander and extract field status in config file
+- Enable to save live queries
 



From fabricecolin at berlios.de  Sun Dec 18 11:26:23 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sun, 18 Dec 2005 11:26:23 +0100
Subject: [Pinot-svn] r26 - in trunk: . UI/GTK2
Message-ID: <200512181026.jBIAQNV8016507@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-18 11:26:22 +0100 (Sun, 18 Dec 2005)
New Revision: 26

Modified:
   trunk/ChangeLog
   trunk/UI/GTK2/config.h
   trunk/pinot.spec
Log:
Bumping version number to 0.35.


Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2005-12-18 05:45:01 UTC (rev 25)
+++ trunk/ChangeLog	2005-12-18 10:26:22 UTC (rev 26)
@@ -1,2 +1,20 @@
+2005/12/18 version_0_3_5
+Xapian + SQLite back-end :
+ - dropped unnecessary tables, moved labels and properties into the index
+Neon downloader :
+ - fail on HTTP errors
+ - setup OpenSSL callbacks for multi-threading support
+Search :
+ - can filter documents by label
+ - multi-step index search : exact matches first, then with stemming, then with ignoring the operators
+HTML browser :
+ - initialize NSS and NSPR to get rid of crash when visiting https sites
+UI :
+ - on double clicks in the index tab, check a document is selected before opening the properties box
+ - copy & paste should now work as expected
+ - modified index browser
+Threads :
+ - handle select() errors
+
 2005/12/08 version_0_3_0
  - first public release

Modified: trunk/UI/GTK2/config.h
===================================================================
--- trunk/UI/GTK2/config.h	2005-12-18 05:45:01 UTC (rev 25)
+++ trunk/UI/GTK2/config.h	2005-12-18 10:26:22 UTC (rev 26)
@@ -76,16 +76,16 @@
 #define PACKAGE_NAME "Pinot"
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING "Pinot v0.30"
+#define PACKAGE_STRING "Pinot v0.35"
 
 /* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME "pinot-0.30.tar.gz"
+#define PACKAGE_TARNAME "pinot-0.35.tar.gz"
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "0.30"
+#define PACKAGE_VERSION "0.35"
 
 /* Define to 1 if you have the ANSI C header files. */
 #define STDC_HEADERS 1
 
 /* Version number of package */
-#define VERSION "0.30"
+#define VERSION "0.35"

Modified: trunk/pinot.spec
===================================================================
--- trunk/pinot.spec	2005-12-18 05:45:01 UTC (rev 25)
+++ trunk/pinot.spec	2005-12-18 10:26:22 UTC (rev 26)
@@ -3,7 +3,7 @@
 
 Summary: Metasearch tool
 Name: pinot
-Version: 0.30
+Version: 0.35
 Release: 1
 License: GPL
 Group: Applications/Internet 



From fabricecolin at berlios.de  Sun Dec 18 11:33:02 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sun, 18 Dec 2005 11:33:02 +0100
Subject: [Pinot-svn] r27 - tags
Message-ID: <200512181033.jBIAX2TQ017825@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-18 11:33:00 +0100 (Sun, 18 Dec 2005)
New Revision: 27

Added:
   tags/version_0_3_5/
Log:
Tagging v0.35.


Copied: tags/version_0_3_5 (from rev 26, trunk)



From fabricecolin at berlios.de  Thu Dec 29 10:00:58 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Thu, 29 Dec 2005 10:00:58 +0100
Subject: [Pinot-svn] r28 - in trunk/UI/GTK2: . src
Message-ID: <200512290900.jBT90wrq032068@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-29 10:00:55 +0100 (Thu, 29 Dec 2005)
New Revision: 28

Added:
   trunk/UI/GTK2/src/IndexPage.cpp
   trunk/UI/GTK2/src/IndexPage.h
   trunk/UI/GTK2/src/NotebookTabBox.cpp
   trunk/UI/GTK2/src/NotebookTabBox.h
Modified:
   trunk/UI/GTK2/metase-gtk2.glade
   trunk/UI/GTK2/src/IndexTree.cpp
   trunk/UI/GTK2/src/IndexTree.h
   trunk/UI/GTK2/src/Makefile
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/PinotUtils.cpp
   trunk/UI/GTK2/src/PinotUtils.h
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/mainWindow.hh
   trunk/UI/GTK2/src/mainWindow_glade.cc
   trunk/UI/GTK2/src/mainWindow_glade.hh
Log:
First stab at getting rid of 3 tabs limitation.


Modified: trunk/UI/GTK2/metase-gtk2.glade
===================================================================
--- trunk/UI/GTK2/metase-gtk2.glade	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/metase-gtk2.glade	2005-12-29 09:00:55 UTC (rev 28)
@@ -146,7 +146,7 @@
 		      <signal name="activate" handler="on_clearresults_activate" last_modification_time="Wed, 03 Mar 2004 19:51:48 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image514">
+			<widget class="GtkImage" id="image538">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-clear</property>
 			  <property name="icon_size">1</property>
@@ -256,10 +256,10 @@
 		<widget class="GtkMenu" id="indexMenuitem_menu">
 
 		  <child>
-		    <widget class="GtkMenuItem" id="showlabels1">
+		    <widget class="GtkMenuItem" id="list1">
 		      <property agent="glademm" name="cxx_visibility">protected</property>
 		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Show Label</property>
+		      <property name="label" translatable="yes">List Contents Of</property>
 		      <property name="use_underline">True</property>
 		    </widget>
 		  </child>
@@ -273,7 +273,7 @@
 		      <signal name="activate" handler="on_import_activate" last_modification_time="Tue, 02 Mar 2004 22:13:44 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image515">
+			<widget class="GtkImage" id="image539">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-open</property>
 			  <property name="icon_size">1</property>
@@ -311,7 +311,7 @@
 		      <signal name="activate" handler="on_refreshindex_activate" last_modification_time="Fri, 20 Feb 2004 18:57:09 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image516">
+			<widget class="GtkImage" id="image540">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-refresh</property>
 			  <property name="icon_size">1</property>
@@ -333,7 +333,7 @@
 		      <signal name="activate" handler="on_unindex_activate" last_modification_time="Thu, 28 Jul 2005 12:42:23 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image517">
+			<widget class="GtkImage" id="image541">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-delete</property>
 			  <property name="icon_size">1</property>
@@ -355,7 +355,7 @@
 		      <signal name="activate" handler="on_showfromindex_activate" last_modification_time="Sun, 06 Nov 2005 08:43:05 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image518">
+			<widget class="GtkImage" id="image542">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-properties</property>
 			  <property name="icon_size">1</property>
@@ -826,6 +826,7 @@
 		  <property name="tab_pos">GTK_POS_TOP</property>
 		  <property name="scrollable">False</property>
 		  <property name="enable_popup">False</property>
+		  <signal name="switch_page" handler="on_mainNotebook_switch_page" last_modification_time="Wed, 28 Dec 2005 16:33:00 GMT"/>
 
 		  <child>
 		    <widget class="GtkVBox" id="resultsVbox">
@@ -872,240 +873,6 @@
 		  </child>
 
 		  <child>
-		    <widget class="GtkVBox" id="indexVbox">
-		      <property agent="glademm" name="cxx_visibility">protected</property>
-		      <property name="visible">True</property>
-		      <property name="homogeneous">False</property>
-		      <property name="spacing">0</property>
-
-		      <child>
-			<widget class="GtkHBox" id="indexButtonsHbox">
-			  <property name="visible">True</property>
-			  <property name="homogeneous">False</property>
-			  <property name="spacing">0</property>
-
-			  <child>
-			    <widget class="GtkComboBox" id="indexCombobox">
-			      <property agent="glademm" name="cxx_visibility">protected</property>
-			      <property name="visible">True</property>
-			      <property name="items" translatable="yes"></property>
-			      <property name="add_tearoffs">False</property>
-			      <property name="focus_on_click">True</property>
-			      <signal name="changed" handler="on_indexCombobox_changed" last_modification_time="Mon, 18 Jul 2005 12:49:12 GMT"/>
-			    </widget>
-			    <packing>
-			      <property name="padding">4</property>
-			      <property name="expand">False</property>
-			      <property name="fill">True</property>
-			    </packing>
-			  </child>
-
-			  <child>
-			    <widget class="GtkHButtonBox" id="indexHbuttonbox">
-			      <property name="visible">True</property>
-			      <property name="layout_style">GTK_BUTTONBOX_SPREAD</property>
-			      <property name="spacing">0</property>
-
-			      <child>
-				<widget class="GtkButton" id="indexBackButton">
-				  <property agent="glademm" name="cxx_visibility">protected</property>
-				  <property name="visible">True</property>
-				  <property name="can_default">True</property>
-				  <property name="can_focus">True</property>
-				  <property name="relief">GTK_RELIEF_NORMAL</property>
-				  <property name="focus_on_click">True</property>
-				  <signal name="clicked" handler="on_indexBackButton_clicked" last_modification_time="Tue, 05 Jul 2005 13:26:43 GMT"/>
-
-				  <child>
-				    <widget class="GtkAlignment" id="alignment31">
-				      <property name="visible">True</property>
-				      <property name="xalign">0.5</property>
-				      <property name="yalign">0.5</property>
-				      <property name="xscale">0</property>
-				      <property name="yscale">0</property>
-				      <property name="top_padding">0</property>
-				      <property name="bottom_padding">0</property>
-				      <property name="left_padding">0</property>
-				      <property name="right_padding">0</property>
-
-				      <child>
-					<widget class="GtkHBox" id="hbox45">
-					  <property name="visible">True</property>
-					  <property name="homogeneous">False</property>
-					  <property name="spacing">2</property>
-
-					  <child>
-					    <widget class="GtkImage" id="image521">
-					      <property name="visible">True</property>
-					      <property name="stock">gtk-media-rewind</property>
-					      <property name="icon_size">4</property>
-					      <property name="xalign">0.5</property>
-					      <property name="yalign">0.5</property>
-					      <property name="xpad">0</property>
-					      <property name="ypad">0</property>
-					    </widget>
-					    <packing>
-					      <property name="padding">0</property>
-					      <property name="expand">False</property>
-					      <property name="fill">False</property>
-					    </packing>
-					  </child>
-
-					  <child>
-					    <widget class="GtkLabel" id="label52">
-					      <property name="visible">True</property>
-					      <property name="label" translatable="yes">Show Previous</property>
-					      <property name="use_underline">True</property>
-					      <property name="use_markup">False</property>
-					      <property name="justify">GTK_JUSTIFY_LEFT</property>
-					      <property name="wrap">False</property>
-					      <property name="selectable">False</property>
-					      <property name="xalign">0.5</property>
-					      <property name="yalign">0.5</property>
-					      <property name="xpad">0</property>
-					      <property name="ypad">0</property>
-					      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-					      <property name="width_chars">-1</property>
-					      <property name="single_line_mode">False</property>
-					      <property name="angle">0</property>
-					    </widget>
-					    <packing>
-					      <property name="padding">0</property>
-					      <property name="expand">False</property>
-					      <property name="fill">False</property>
-					    </packing>
-					  </child>
-					</widget>
-				      </child>
-				    </widget>
-				  </child>
-				</widget>
-			      </child>
-
-			      <child>
-				<widget class="GtkButton" id="indexForwardButton">
-				  <property agent="glademm" name="cxx_visibility">protected</property>
-				  <property name="visible">True</property>
-				  <property name="can_default">True</property>
-				  <property name="can_focus">True</property>
-				  <property name="relief">GTK_RELIEF_NORMAL</property>
-				  <property name="focus_on_click">True</property>
-				  <signal name="clicked" handler="on_indexForwardButton_clicked" last_modification_time="Tue, 05 Jul 2005 13:26:48 GMT"/>
-
-				  <child>
-				    <widget class="GtkAlignment" id="alignment32">
-				      <property name="visible">True</property>
-				      <property name="xalign">0.5</property>
-				      <property name="yalign">0.5</property>
-				      <property name="xscale">0</property>
-				      <property name="yscale">0</property>
-				      <property name="top_padding">0</property>
-				      <property name="bottom_padding">0</property>
-				      <property name="left_padding">0</property>
-				      <property name="right_padding">0</property>
-
-				      <child>
-					<widget class="GtkHBox" id="hbox46">
-					  <property name="visible">True</property>
-					  <property name="homogeneous">False</property>
-					  <property name="spacing">2</property>
-
-					  <child>
-					    <widget class="GtkImage" id="image522">
-					      <property name="visible">True</property>
-					      <property name="stock">gtk-media-forward</property>
-					      <property name="icon_size">4</property>
-					      <property name="xalign">0.5</property>
-					      <property name="yalign">0.5</property>
-					      <property name="xpad">0</property>
-					      <property name="ypad">0</property>
-					    </widget>
-					    <packing>
-					      <property name="padding">0</property>
-					      <property name="expand">False</property>
-					      <property name="fill">False</property>
-					    </packing>
-					  </child>
-
-					  <child>
-					    <widget class="GtkLabel" id="label53">
-					      <property name="visible">True</property>
-					      <property name="label" translatable="yes">Show Next</property>
-					      <property name="use_underline">True</property>
-					      <property name="use_markup">False</property>
-					      <property name="justify">GTK_JUSTIFY_LEFT</property>
-					      <property name="wrap">False</property>
-					      <property name="selectable">False</property>
-					      <property name="xalign">0.5</property>
-					      <property name="yalign">0.5</property>
-					      <property name="xpad">0</property>
-					      <property name="ypad">0</property>
-					      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-					      <property name="width_chars">-1</property>
-					      <property name="single_line_mode">False</property>
-					      <property name="angle">0</property>
-					    </widget>
-					    <packing>
-					      <property name="padding">0</property>
-					      <property name="expand">False</property>
-					      <property name="fill">False</property>
-					    </packing>
-					  </child>
-					</widget>
-				      </child>
-				    </widget>
-				  </child>
-				</widget>
-			      </child>
-			    </widget>
-			    <packing>
-			      <property name="padding">4</property>
-			      <property name="expand">False</property>
-			      <property name="fill">True</property>
-			    </packing>
-			  </child>
-			</widget>
-			<packing>
-			  <property name="padding">4</property>
-			  <property name="expand">False</property>
-			  <property name="fill">True</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<placeholder/>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="tab_expand">False</property>
-		      <property name="tab_fill">True</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="indexLabel">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Index</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="type">tab</property>
-		    </packing>
-		  </child>
-
-		  <child>
 		    <widget class="GtkVBox" id="viewVbox">
 		      <property agent="glademm" name="cxx_visibility">protected</property>
 		      <property name="visible">True</property>

Added: trunk/UI/GTK2/src/IndexPage.cpp
===================================================================
--- trunk/UI/GTK2/src/IndexPage.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/IndexPage.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -0,0 +1,307 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+#include <gtkmm/alignment.h>
+#include <gtkmm/buttonbox.h>
+#include <gtkmm/stock.h>
+#include <gtkmm/textbuffer.h>
+
+#include "HtmlTokenizer.h"
+#include "Url.h"
+#include "QueryHistory.h"
+#include "ViewHistory.h"
+#include "config.h"
+#include "NLS.h"
+#include "PinotSettings.h"
+#include "PinotUtils.h"
+#include "IndexPage.h"
+
+using namespace std;
+using namespace SigC;
+using namespace Glib;
+using namespace Gtk;
+
+IndexPage::IndexPage(const ustring &indexName, IndexTree *pTree,
+	PinotSettings &settings) :
+	VBox(),
+	m_indexName(indexName),
+	m_pTree(pTree),
+	m_settings(settings),
+	m_pLabelCombobox(NULL),
+	m_pBackButton(NULL),
+	m_pForwardButton(NULL),
+	m_docsCount(0),
+	m_firstDoc(0)
+{
+	m_pLabelCombobox = manage(new ComboBox());
+
+	Image *image521 = manage(new Image(StockID("gtk-media-rewind"), IconSize(4)));
+	Label *label52 = manage(new Label(_("Show Previous")));
+	HBox *hbox45 = manage(new HBox(false, 2));
+	Alignment *alignment31 = manage(new Alignment(0.5, 0.5, 0, 0));
+	m_pBackButton = manage(new Button());
+
+	Image *image522 = manage(new Image(StockID("gtk-media-forward"), IconSize(4)));
+	Label *label53 = manage(new Label(_("Show Next")));
+	HBox *hbox46 = manage(new HBox(false, 2));
+	Alignment *alignment32 = manage(new Alignment(0.5, 0.5, 0, 0));
+	m_pForwardButton = manage(new Button());
+
+	HButtonBox *indexHbuttonbox = manage(new HButtonBox(BUTTONBOX_START, 0));
+	HBox *indexButtonsHbox = manage(new HBox(false, 0));
+
+	// Buttons
+	image521->set_alignment(0.5,0.5);
+	image521->set_padding(0,0);
+	label52->set_alignment(0.5,0.5);
+	label52->set_padding(0,0);
+	label52->set_justify(Gtk::JUSTIFY_LEFT);
+	label52->set_line_wrap(false);
+	label52->set_use_markup(false);
+	label52->set_selectable(false);
+	hbox45->pack_start(*image521, Gtk::PACK_SHRINK, 0);
+	hbox45->pack_start(*label52, Gtk::PACK_SHRINK, 0);
+	alignment31->add(*hbox45);
+	m_pBackButton->set_flags(Gtk::CAN_FOCUS);
+	m_pBackButton->set_flags(Gtk::CAN_DEFAULT);
+	m_pBackButton->set_relief(Gtk::RELIEF_NORMAL);
+	m_pBackButton->add(*alignment31);
+	image522->set_alignment(0.5,0.5);
+	image522->set_padding(0,0);
+	label53->set_alignment(0.5,0.5);
+	label53->set_padding(0,0);
+	label53->set_justify(Gtk::JUSTIFY_LEFT);
+	label53->set_line_wrap(false);
+	label53->set_use_markup(false);
+	label53->set_selectable(false);
+	hbox46->pack_start(*image522, Gtk::PACK_SHRINK, 0);
+	hbox46->pack_start(*label53, Gtk::PACK_SHRINK, 0);
+	alignment32->add(*hbox46);
+	m_pForwardButton->set_flags(Gtk::CAN_FOCUS);
+	m_pForwardButton->set_flags(Gtk::CAN_DEFAULT);
+	m_pForwardButton->set_relief(Gtk::RELIEF_NORMAL);
+	m_pForwardButton->add(*alignment32);
+
+	// Position everything
+	indexHbuttonbox->pack_start(*m_pBackButton);
+	indexHbuttonbox->pack_start(*m_pForwardButton);
+	indexButtonsHbox->pack_start(*m_pLabelCombobox, Gtk::PACK_SHRINK, 4);
+	indexButtonsHbox->pack_start(*indexHbuttonbox, Gtk::PACK_EXPAND_WIDGET, 4);
+	pack_start(*indexButtonsHbox, Gtk::PACK_SHRINK, 4);
+	if (pTree != NULL)
+	{
+		pack_start(*pTree->getScrolledWindow());
+	}
+
+	// Associate the columns model to the label combo
+	m_refLabelNameTree = ListStore::create(m_labelNameColumns);
+	m_pLabelCombobox->set_model(m_refLabelNameTree);
+	m_pLabelCombobox->pack_start(m_labelNameColumns.m_name);
+	// Populate
+	populateLabelCombobox();
+
+	// Connect the signals
+	m_pLabelCombobox->signal_changed().connect(
+		SigC::slot(*this, &IndexPage::onLabelChanged));
+	m_pBackButton->signal_clicked().connect(
+		SigC::slot(*this, &IndexPage::onBackClicked));
+	m_pForwardButton->signal_clicked().connect(
+		SigC::slot(*this, &IndexPage::onForwardClicked));
+
+	// Disable the buttons until something is being shown
+	m_pBackButton->set_sensitive(false);
+	m_pForwardButton->set_sensitive(false);
+
+	// Show all
+	m_pLabelCombobox->show();
+	image521->show();
+	label52->show();
+	hbox45->show();
+	alignment31->show();
+	m_pBackButton->show();
+	image522->show();
+	label53->show();
+	hbox46->show();
+	alignment32->show();
+	m_pForwardButton->show();
+	indexHbuttonbox->show();
+	indexButtonsHbox->show();
+	show();
+}
+
+IndexPage::~IndexPage()
+{
+}
+
+void IndexPage::onLabelChanged(void)
+{
+	TreeModel::iterator labelIter = m_pLabelCombobox->get_active();
+	if (labelIter)
+	{
+		TreeModel::Row row = *labelIter;
+
+		m_labelName = row[m_labelNameColumns.m_name];
+#ifdef DEBUG
+		cout << "IndexPage::onLabelChanged: current label now " << m_labelName << endl;
+#endif
+		if (m_labelName == _("None"))
+		{
+			m_labelName.clear();
+		}
+		m_signalLabelChanged(m_indexName, m_labelName);
+	}
+}
+
+void IndexPage::onBackClicked(void)
+{
+	m_signalBackClicked(m_indexName);
+}
+
+void IndexPage::onForwardClicked(void)
+{
+	m_signalForwardClicked(m_indexName);
+}
+
+//
+// Returns the name of the index being listed.
+//
+ustring IndexPage::getIndexName(void) const
+{
+	return m_indexName;
+}
+
+//
+// Returns the name of the current label.
+//
+ustring IndexPage::getLabelName(void) const
+{
+	return m_labelName;
+}
+
+//
+// Returns the page's tree.
+//
+IndexTree *IndexPage::getTree(void) const
+{
+	return m_pTree;
+}
+
+//
+// Populates the labels list.
+//
+void IndexPage::populateLabelCombobox(void)
+{
+	TreeModel::iterator iter;
+	TreeModel::Row row;
+
+	m_refLabelNameTree->clear();
+
+	iter = m_refLabelNameTree->append();
+	row = *iter;
+	row[m_labelNameColumns.m_name] = _("None");
+
+	for (set<PinotSettings::Label>::const_iterator labelIter = m_settings.m_labels.begin();
+		labelIter != m_settings.m_labels.end(); ++labelIter)
+	{
+		string labelName(labelIter->m_name);
+
+		iter = m_refLabelNameTree->append();
+		row = *iter;
+		row[m_labelNameColumns.m_name] = to_utf8(labelName);
+	}
+
+	m_pLabelCombobox->set_active(0);
+}
+
+//
+// Updates the state of the index buttons.
+//
+void IndexPage::updateButtons(unsigned int maxDocsCount)
+{
+	if (m_firstDoc >= maxDocsCount)
+	{
+		m_pBackButton->set_sensitive(true);
+	}
+	else
+	{
+		m_pBackButton->set_sensitive(false);
+	}
+	if (m_docsCount >= m_firstDoc + maxDocsCount)
+	{
+		m_pForwardButton->set_sensitive(true);
+	}
+	else
+	{
+		m_pForwardButton->set_sensitive(false);
+	}
+}
+
+//
+// Gets the number of documents.
+//
+unsigned int IndexPage::getDocumentsCount(void) const
+{
+	return m_docsCount;
+}
+
+//
+// Sets the number of documents.
+//
+void IndexPage::setDocumentsCount(unsigned int docsCount)
+{
+	m_docsCount = docsCount;
+}
+
+//
+// Gets the first document.
+//
+unsigned int IndexPage::getFirstDocument(void) const
+{
+	return m_firstDoc;
+}
+
+//
+// Sets the first document.
+//
+void IndexPage::setFirstDocument(unsigned int startDoc)
+{
+	m_firstDoc = startDoc;
+}
+
+//
+// Returns the changed label signal.
+//
+Signal2<void, ustring, ustring>& IndexPage::getLabelChangedSignal(void)
+{
+	return m_signalLabelChanged;
+}
+
+//
+// Returns the back button clicked signal.
+//
+Signal1<void, ustring>& IndexPage::getBackClickedSignal(void)
+{
+	return m_signalBackClicked;
+}
+
+//
+// Returns the forward button clicked signal.
+//
+Signal1<void, ustring>& IndexPage::getForwardClickedSignal(void)
+{
+	return m_signalForwardClicked;
+}

Added: trunk/UI/GTK2/src/IndexPage.h
===================================================================
--- trunk/UI/GTK2/src/IndexPage.h	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/IndexPage.h	2005-12-29 09:00:55 UTC (rev 28)
@@ -0,0 +1,113 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _INDEXPAGE_HH
+#define _INDEXPAGE_HH
+
+#include <string>
+#include <vector>
+#include <sigc++/slot.h>
+#include <glibmm/refptr.h>
+#include <glibmm/ustring.h>
+#include <gtkmm/box.h>
+#include <gtkmm/menu.h>
+#include <gdkmm/pixbuf.h>
+#include <gtkmm/combobox.h>
+#include <gtkmm/button.h>
+#include <gtkmm/scrolledwindow.h>
+#include <gtkmm/textview.h>
+#include <gtkmm/liststore.h>
+#include <gtkmm/treeview.h>
+#include <gtkmm/treeselection.h>
+
+#include "QueryProperties.h"
+#include "IndexedDocument.h"
+#include "IndexTree.h"
+#include "ModelColumns.h"
+#include "PinotSettings.h"
+
+class IndexPage : public Gtk::VBox
+{
+	public:
+		IndexPage(const Glib::ustring &indexName, IndexTree *pTree,
+			PinotSettings &settings);
+		virtual ~IndexPage();
+
+		/// Returns the name of the index being listed.
+		Glib::ustring getIndexName(void) const;
+
+		/// Returns the name of the current label.
+		Glib::ustring getLabelName(void) const;
+
+		/// Returns the page's tree.
+		IndexTree *getTree(void) const;
+
+		/// Populates the labels list.
+		void populateLabelCombobox(void);
+
+		/// Updates the state of the index buttons.
+		void updateButtons(unsigned int maxDocsCount);
+
+		/// Gets the number of documents.
+		unsigned int getDocumentsCount(void) const;
+
+		/// Sets the number of documents.
+		void setDocumentsCount(unsigned int docsCount);
+
+		/// Gets the first document.
+		unsigned int getFirstDocument(void) const;
+
+		/// Sets the first document.
+		void setFirstDocument(unsigned int startDoc);
+
+		/// Returns the changed label signal.
+		SigC::Signal2<void, Glib::ustring, Glib::ustring>& getLabelChangedSignal(void);
+
+		/// Returns the back button clicked signal.
+		SigC::Signal1<void, Glib::ustring>& getBackClickedSignal(void);
+
+		/// Returns the forward button clicked signal.
+		SigC::Signal1<void, Glib::ustring>& getForwardClickedSignal(void);
+
+	protected:
+		Glib::ustring m_indexName;
+		Glib::ustring m_labelName;
+		IndexTree *m_pTree;
+		PinotSettings &m_settings;
+		ComboModelColumns m_labelNameColumns;
+		Glib::RefPtr<Gtk::ListStore> m_refLabelNameTree;
+		Gtk::ComboBox *m_pLabelCombobox;
+		Gtk::Button *m_pBackButton;
+		Gtk::Button *m_pForwardButton;
+		unsigned int m_docsCount;
+		unsigned int m_firstDoc;
+		SigC::Signal2<void, Glib::ustring, Glib::ustring> m_signalLabelChanged;
+		SigC::Signal1<void, Glib::ustring> m_signalBackClicked;
+		SigC::Signal1<void, Glib::ustring> m_signalForwardClicked;
+
+		void onLabelChanged(void);
+
+		void onBackClicked(void);
+
+		void onForwardClicked(void);
+
+	private:
+		IndexPage(const IndexPage &other);
+		IndexPage &operator=(const IndexPage &other);
+
+};
+
+#endif // _INDEXPAGE_HH

Modified: trunk/UI/GTK2/src/IndexTree.cpp
===================================================================
--- trunk/UI/GTK2/src/IndexTree.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/IndexTree.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -34,12 +34,13 @@
 using namespace Gdk;
 using namespace Gtk;
 
-IndexTree::IndexTree(VBox *indexVbox, Menu *pPopupMenu, PinotSettings &settings) :
+IndexTree::IndexTree(const ustring &indexName, Menu *pPopupMenu, PinotSettings &settings) :
 	TreeView(),
+	m_indexName(indexName),
 	m_pPopupMenu(pPopupMenu),
 	m_settings(settings)
 {
-	ScrolledWindow *indexScrolledwindow = manage(new ScrolledWindow());
+	m_pIndexScrolledwindow = manage(new ScrolledWindow());
 
 	// This is the actual index tree
 	set_events(Gdk::BUTTON_PRESS_MASK);
@@ -48,16 +49,13 @@
 	set_rules_hint(true);
 	set_reorderable(false);
 	set_enable_search(true);
-	indexScrolledwindow->set_flags(Gtk::CAN_FOCUS);
-	indexScrolledwindow->set_border_width(4);
-	indexScrolledwindow->set_shadow_type(Gtk::SHADOW_NONE);
-	indexScrolledwindow->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_ALWAYS);
-	indexScrolledwindow->property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
-	indexScrolledwindow->add(*this);
+	m_pIndexScrolledwindow->set_flags(Gtk::CAN_FOCUS);
+	m_pIndexScrolledwindow->set_border_width(4);
+	m_pIndexScrolledwindow->set_shadow_type(Gtk::SHADOW_NONE);
+	m_pIndexScrolledwindow->set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_ALWAYS);
+	m_pIndexScrolledwindow->property_window_placement().set_value(Gtk::CORNER_TOP_LEFT);
+	m_pIndexScrolledwindow->add(*this);
 
-	// Position the scrolled window
-	indexVbox->pack_start(*indexScrolledwindow);
-	
 	// Associate the columns model to the index tree
 	m_refStore = ListStore::create(m_indexColumns);
 	set_model(m_refStore);
@@ -81,8 +79,12 @@
 	// Allow multiple selection
 	get_selection()->set_mode(SELECTION_MULTIPLE);
 
-	// Handle button presses
-	signal_button_press_event().connect_notify(SigC::slot(*this, &IndexTree::onButtonPressEvent));
+	// Connect the signals
+	signal_button_press_event().connect_notify(
+		SigC::slot(*this, &IndexTree::onButtonPressEvent));
+	get_selection()->signal_changed().connect(
+		SigC::slot(*this, &IndexTree::onSelectionChanged));
+
 	// Enable interactive search
 	set_search_column(m_indexColumns.m_text.index());
 	set_search_equal_func(SigC::slot(*this, &IndexTree::onSearchEqual));
@@ -96,8 +98,8 @@
 	setCurrentLabelColour(0, 0, 0, false);
 
 	// Show all
+	m_pIndexScrolledwindow->show();
 	show();
-	indexScrolledwindow->show();
 }
 
 IndexTree::~IndexTree()
@@ -134,17 +136,6 @@
 	}
 }
 
-//
-// Interactive search equal function.
-//
-bool IndexTree::onSearchEqual(const RefPtr<TreeModel>& model, int column,
-	const ustring& key, const TreeModel::iterator& iter)
-{
-}
-
-//
-// Handles button presses.
-//
 void IndexTree::onButtonPressEvent(GdkEventButton *ev)
 {
 	// Check for popup click
@@ -159,30 +150,20 @@
 	// Check for double clicks
 	else if (ev->type == GDK_2BUTTON_PRESS)
 	{
-		m_signalEdit();
+		m_signalEdit;
 	}
 }
 
-//
-// Handles selection changes.
-//
-bool IndexTree::onSelectionChanged(void)
+void IndexTree::onSelectionChanged(void)
 {
-#ifdef DEBUG
-	cout << "IndexTree::onSelectionChanged: called" << endl;
-#endif
-	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
-	if (selectedItems.empty() == true)
-	{
-		return false;
-	}
+	m_signalSelectionChanged(m_indexName);
+}
 
-	return true;
+bool IndexTree::onSearchEqual(const RefPtr<TreeModel>& model, int column,
+	const ustring& key, const TreeModel::iterator& iter)
+{
 }
 
-//
-// Handles attempts to select rows.
-//
 bool IndexTree::onSelectionSelect(const RefPtr<TreeModel>& model,
 		const TreeModel::Path& path, bool path_currently_selected)
 {
@@ -206,6 +187,14 @@
 }
 
 //
+// Returns the tree's scrolled window.
+//
+ScrolledWindow *IndexTree::getScrolledWindow(void) const
+{
+	return m_pIndexScrolledwindow;
+}
+
+//
 // Appends a new row in the index tree.
 //
 bool IndexTree::appendDocument(const IndexedDocument &docInfo, bool labeled)
@@ -485,6 +474,15 @@
 }
 
 //
+// Refreshes the tree.
+//
+void IndexTree::refresh(void)
+{
+	// FIXME: not sure why, but this helps with refreshing the tree
+	columns_autosize();
+}
+
+//
 // Returns true if the tree is empty.
 //
 bool IndexTree::isEmpty(void)
@@ -532,3 +530,11 @@
 {
 	return m_signalEdit;
 }
+
+//
+// Returns the changed selection signal.
+//
+Signal1<void, ustring>& IndexTree::getSelectionChangedSignal(void)
+{
+	return m_signalSelectionChanged;
+}

Modified: trunk/UI/GTK2/src/IndexTree.h
===================================================================
--- trunk/UI/GTK2/src/IndexTree.h	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/IndexTree.h	2005-12-29 09:00:55 UTC (rev 28)
@@ -22,7 +22,6 @@
 #include <sigc++/slot.h>
 #include <glibmm/refptr.h>
 #include <glibmm/ustring.h>
-#include <gtkmm/box.h>
 #include <gtkmm/menu.h>
 #include <gdkmm/pixbuf.h>
 #include <gtkmm/scrolledwindow.h>
@@ -39,14 +38,12 @@
 class IndexTree : public Gtk::TreeView
 {
 	public:
-		IndexTree(Gtk::VBox *indexVbox, Gtk::Menu *pPopupMenu, PinotSettings &settings);
+		IndexTree(const Glib::ustring &indexName, Gtk::Menu *pPopupMenu,
+			PinotSettings &settings);
 		virtual ~IndexTree();
 
-		/**
-		  * Handles selection changes.
-		  * Returns true if a result is selected.
-		  */
-		bool onSelectionChanged(void);
+		/// Returns the tree's scrolled window.
+		Gtk::ScrolledWindow *getScrolledWindow(void) const;
 
 		/// Adds a set of documents.
 		bool addDocuments(const std::vector<IndexedDocument> &documentsList);
@@ -85,6 +82,9 @@
 		/// Returns the number of rows.
 		unsigned int getRowsCount(void);
 
+		/// Refreshes the tree.
+		void refresh(void);
+
 		/// Returns true if the tree is empty.
 		bool isEmpty(void);
 
@@ -94,10 +94,16 @@
 		/// Returns the document edit signal.
 		SigC::Signal0<void>& getEditDocumentSignal(void);
 
+		/// Returns the changed selection signal.
+		SigC::Signal1<void, Glib::ustring>& getSelectionChangedSignal(void);
+
 	protected:
+		Glib::ustring m_indexName;
+		Gtk::Menu *m_pPopupMenu;
+		Gtk::ScrolledWindow *m_pIndexScrolledwindow;
 		Glib::RefPtr<Gtk::ListStore> m_refStore;
-		Gtk::Menu *m_pPopupMenu;
 		SigC::Signal0<void> m_signalEdit;
+		SigC::Signal1<void, Glib::ustring> m_signalSelectionChanged;
 		PinotSettings &m_settings;
 		IndexModelColumns m_indexColumns;
 		Gdk::Color m_currentLabelColour;
@@ -106,14 +112,13 @@
 
 		void renderLabel(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &iter);
 
-		/// Interactive search equal function.
+		void onButtonPressEvent(GdkEventButton *ev);
+
+		void onSelectionChanged(void);
+
 		bool onSearchEqual(const Glib::RefPtr<Gtk::TreeModel>& model, int column,
 			const Glib::ustring& key, const Gtk::TreeModel::iterator& iter);
 
-		/// Handles button presses.
-		void onButtonPressEvent(GdkEventButton *ev);
-
-		/// Handles attempts to select rows.
 		bool onSelectionSelect(const Glib::RefPtr<Gtk::TreeModel>& model,
 			const Gtk::TreeModel::Path& path, bool path_currently_selected);
 

Modified: trunk/UI/GTK2/src/Makefile
===================================================================
--- trunk/UI/GTK2/src/Makefile	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/Makefile	2005-12-29 09:00:55 UTC (rev 28)
@@ -13,10 +13,9 @@
 	propertiesDialog.cc propertiesDialog_glade.cc \
 	queryDialog.cc queryDialog_glade.cc \
 	mainWindow.cc mainWindow_glade.cc
-UI_SRCS = pinot.cpp EnginesTree.cpp IndexTree.cpp \
-	HtmlView.cpp ModelColumns.cpp MonitorHandler.cpp \
-	PinotSettings.cpp PinotUtils.cpp ResultsTree.cpp \
-	WorkerThreads.cpp
+UI_SRCS = pinot.cpp EnginesTree.cpp IndexPage.cpp IndexTree.cpp \
+	HtmlView.cpp ModelColumns.cpp MonitorHandler.cpp NotebookTabBox.cpp \
+	PinotSettings.cpp PinotUtils.cpp ResultsTree.cpp WorkerThreads.cpp
 UI_GTK2_OBJS := $(patsubst %.cc,${OBJ_DIR}/%.o,${UI_GTK2_SRCS})
 UI_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${UI_SRCS})
 UI_GTK2_BIN = ${BIN_DIR}/pinot

Added: trunk/UI/GTK2/src/NotebookTabBox.cpp
===================================================================
--- trunk/UI/GTK2/src/NotebookTabBox.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/NotebookTabBox.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -0,0 +1,130 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sigc++/slot.h>
+
+#include "NotebookTabBox.h"
+#include "PinotUtils.h"
+
+using namespace SigC;
+using namespace Glib;
+using namespace Gtk;
+
+NotebookTabBox::NotebookTabBox(const Glib::ustring &title, PageType type) :
+	HBox(),
+	m_title(title),
+	m_pageType(type),
+	m_tabLabel(NULL),
+#if _USE_BUTTON_TAB
+	m_tabButton(NULL)
+#else
+	m_tabEventBox(NULL)
+#endif
+{
+	int width, height;
+
+	// Lookup the standard icon size
+	bool gotDimensions = IconSize::lookup(ICON_SIZE_MENU, width, height);
+
+	m_tabLabel = manage(new Label(title));
+	m_tabImage = manage(new Image(StockID("gtk-close"), IconSize(ICON_SIZE_MENU)));
+#if _USE_BUTTON_TAB
+	m_tabButton = manage(new Button());
+#else
+	m_tabEventBox = manage(new EventBox);
+#endif
+
+	m_tabLabel->set_alignment(0,0.5);
+	m_tabLabel->set_padding(0,0);
+	m_tabLabel->set_justify(JUSTIFY_LEFT);
+	m_tabLabel->set_line_wrap(false);
+	m_tabLabel->set_use_markup(false);
+	m_tabLabel->set_selectable(false);
+	m_tabImage->set_alignment(0,0);
+	m_tabImage->set_padding(0,0);
+#if _USE_BUTTON_TAB
+	m_tabButton->set_flags(CAN_FOCUS);
+	m_tabButton->set_flags(CAN_DEFAULT);
+	m_tabButton->add(*m_tabImage);
+	m_tabButton->set_relief(RELIEF_NONE);
+	m_tabButton->set_border_width(0);
+	m_tabButton->set_alignment(0,0);
+	// Resize the button
+	if (gotDimensions == true)
+	{
+		m_tabButton->set_size_request(width, height);
+		m_tabButton->check_resize();
+	}
+#else
+	m_tabEventBox->add(*m_tabImage);
+	m_tabEventBox->set_events(Gdk::BUTTON_PRESS_MASK);
+#endif
+	pack_start(*m_tabLabel);
+#if _USE_BUTTON_TAB
+	pack_start(*m_tabButton, PACK_SHRINK);
+#else
+	pack_start(*m_tabEventBox, PACK_SHRINK);
+#endif
+	set_spacing(0);
+	set_homogeneous(false);
+	m_tabLabel->show();
+	m_tabImage->show();
+#if _USE_BUTTON_TAB
+	m_tabButton->show();
+#else
+	m_tabEventBox->show();
+#endif
+	show();
+
+#if _USE_BUTTON_TAB
+	m_tabButton->signal_clicked().connect(
+		SigC::slot(*this, &NotebookTabBox::onButtonClicked));
+#else
+	m_tabEventBox->signal_button_press_event().connect(
+		SigC::slot(*this, &NotebookTabBox::onButtonPressEvent));
+#endif
+}
+
+NotebookTabBox::~NotebookTabBox()
+{
+}
+
+#if _USE_BUTTON_TAB
+void NotebookTabBox::onButtonClicked(void)
+#else
+bool NotebookTabBox::onButtonPressEvent(GdkEventButton *ev)
+#endif
+{
+	m_signalClose(m_title, m_pageType);
+
+	return true;
+}
+
+//
+// Returns the page type.
+//
+NotebookTabBox::PageType NotebookTabBox::getPageType(void) const
+{
+	return m_pageType;
+}
+
+//
+// Returns the close signal.
+//
+Signal2<void, ustring, NotebookTabBox::PageType>& NotebookTabBox::getCloseSignal(void)
+{
+	return m_signalClose;
+}

Added: trunk/UI/GTK2/src/NotebookTabBox.h
===================================================================
--- trunk/UI/GTK2/src/NotebookTabBox.h	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/NotebookTabBox.h	2005-12-29 09:00:55 UTC (rev 28)
@@ -0,0 +1,68 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _NOTEBOOKTABBOX_HH
+#define _NOTEBOOKTABBOX_HH
+
+#include <sigc++/signal.h>
+#include <glibmm/ustring.h>
+#include <gtkmm/box.h>
+#include <gtkmm/label.h>
+#include <gtkmm/image.h>
+#if _USE_BUTTON_TAB
+#include <gtkmm/button.h>
+#else
+#include <gtkmm/eventbox.h>
+#endif
+
+/**
+  * Closable notebook tab.
+  */
+class NotebookTabBox : public Gtk::HBox
+{
+	public:
+		typedef enum { RESULTS_PAGE = 0, INDEX_PAGE, VIEW_PAGE } PageType;
+
+		NotebookTabBox(const Glib::ustring &title, PageType type);
+		virtual ~NotebookTabBox();
+
+		/// Returns the page type.
+		PageType getPageType(void) const;
+
+		/// Returns the close signal.
+		SigC::Signal2<void, Glib::ustring, PageType>& getCloseSignal(void);
+
+	protected:
+		Glib::ustring m_title;
+		PageType m_pageType;
+		Gtk::Label *m_tabLabel;
+		Gtk::Image *m_tabImage;
+#if _USE_BUTTON_TAB
+		Gtk::Button *m_tabButton;
+#else
+		Gtk::EventBox *m_tabEventBox;
+#endif
+		SigC::Signal2<void, Glib::ustring, PageType> m_signalClose;
+
+#if _USE_BUTTON_TAB
+		void onButtonClicked(void);
+#else
+		bool onButtonPressEvent(GdkEventButton *ev);
+#endif
+
+};
+
+#endif // _NOTEBOOKTABBOX_HH

Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -253,10 +253,10 @@
 	// FIXME: check the top-level element is okay
 
 	// Go through the subnodes
-	Node::NodeList childNodes = pRootElem->get_children();
+	const Node::NodeList childNodes = pRootElem->get_children();
 	if (childNodes.empty() == false)
 	{
-		for (Node::NodeList::iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
+		for (Node::NodeList::const_iterator iter = childNodes.begin(); iter != childNodes.end(); ++iter)
 		{
 			Node *pNode = (*iter);
 			// All nodes should be elements

Modified: trunk/UI/GTK2/src/PinotUtils.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/PinotUtils.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -23,6 +23,7 @@
 #include "PinotUtils.h"
 
 using namespace std;
+using namespace SigC;
 using namespace Glib;
 using namespace Gtk;
 
@@ -80,8 +81,8 @@
 	fileChooser.set_select_multiple(false);
 	fileChooser.set_transient_for(parentWindow);
 	// Add response buttons
-	fileChooser.add_button(Stock::CANCEL, Gtk::RESPONSE_CANCEL);
-	fileChooser.add_button(okButtonStockId, Gtk::RESPONSE_OK);
+	fileChooser.add_button(Stock::CANCEL, RESPONSE_CANCEL);
+	fileChooser.add_button(okButtonStockId, RESPONSE_OK);
 	// FIXME: add FileFilter's
 	fileChooser.show();
 	int result = fileChooser.run();
@@ -116,23 +117,6 @@
 	return treeColumn;
 }
 
-/// Create a resizable text column, rendered by renderTextCell.
-TreeViewColumn *create_resizable_column(const ustring &title, const TreeModelColumnBase& modelColumn,
-	const TreeViewColumn::SlotCellData &renderTextCell)
-{
-	TreeViewColumn *treeColumn = new TreeViewColumn(title);
-
-	CellRendererText *textCellRenderer = new CellRendererText();
-	treeColumn->pack_start(*manage(textCellRenderer));
-	// This will be called to render the text
-	treeColumn->set_cell_data_func(*textCellRenderer, renderTextCell);
-
-	treeColumn->add_attribute(textCellRenderer->property_text(), modelColumn);
-	treeColumn->set_resizable(true);
-
-	return treeColumn;
-}
-
 /// Create a resizable icon and text column, rendered by renderTextAndIconCell.
 TreeViewColumn *create_resizable_column_with_icon(const ustring &title,
 	const TreeModelColumnBase& modelColumn, const TreeViewColumn::SlotCellData &renderTextAndIconCell)

Modified: trunk/UI/GTK2/src/PinotUtils.h
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.h	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/PinotUtils.h	2005-12-29 09:00:55 UTC (rev 28)
@@ -22,42 +22,11 @@
 #if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
 #include <sigc++/compatibility.h>
 #endif
-#include <sigc++/signal.h>
 #include <glibmm/ustring.h>
 #include <gtkmm/window.h>
 #include <gtkmm/treeview.h>
 #include <gtkmm/treemodel.h>
 
-/**
-  * DCTreeView subclasses TreeView and handles double clicks.
-  * Handling double-clicks on tree views is not straight-forward, see :
-  * http://bugzilla.gnome.org/show_bug.cgi?id=89780
-  * http://www.gtkmm.org/gtkmm2/docs/tutorial/html/ch08s07.html
-  */
-class DCTreeView : public Gtk::TreeView
-{
-	public:
-		DCTreeView() : Gtk::TreeView() {}
-		virtual ~DCTreeView() {}
-
-		SigC::Signal0<void> signal_double_click_event;
-
-	protected:
-		bool on_button_press_event(GdkEventButton* event)
-		{
-			// Check for double clicks
-			if (event->type == GDK_2BUTTON_PRESS)
-			{
-				signal_double_click_event();
-				return true;
-			}
-
-			// Not handled
-			return TreeView::on_button_press_event(event);
-		}
-
-};
-
 /// Open a FileSelector and request a file. Location can be initialized.
 bool select_file_name(Gtk::Window &parentWindow, const Glib::ustring &title,
 	Glib::ustring &location, bool openOrCreate = true, bool directoriesOnly = false);
@@ -66,11 +35,6 @@
 Gtk::TreeViewColumn *create_resizable_column(const Glib::ustring &title,
 	const Gtk::TreeModelColumnBase& modelColumn);
 
-/// Create a resizable text column, rendered by renderTextCell.
-Gtk::TreeViewColumn *create_resizable_column(const Glib::ustring &title,
-	const Gtk::TreeModelColumnBase& modelColumn,
-	const  Gtk::TreeViewColumn::SlotCellData &renderTextCell);
-
 /// Create a resizable icon and text column, rendered by renderTextAndIconCell.
 Gtk::TreeViewColumn *create_resizable_column_with_icon(const Glib::ustring &title,
 	const Gtk::TreeModelColumnBase& modelColumn,

Modified: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -48,7 +48,6 @@
 	m_extractTextview(NULL),
 	m_showExtract(true)
 {
-	HBox *extractHbox = manage(new class Gtk::HBox(false, 0));
 	ScrolledWindow *resultsScrolledwindow = manage(new ScrolledWindow());
 	m_extractScrolledwindow = manage(new ScrolledWindow());
 	m_extractTextview = manage(new TextView());
@@ -142,7 +141,6 @@
 	resultsScrolledwindow->show();
 	m_extractTextview->show();
 	m_extractScrolledwindow->show();
-	extractHbox->show();
 }
 
 ResultsTree::~ResultsTree()

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-29 09:00:55 UTC (rev 28)
@@ -389,6 +389,11 @@
 	return "LabelQueryThread";
 }
 
+string LabelQueryThread::getIndexName(void) const
+{
+	return m_indexName;
+}
+
 string LabelQueryThread::getLabelName(void) const
 {
 	return m_labelName;

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2005-12-29 09:00:55 UTC (rev 28)
@@ -125,11 +125,11 @@
 
 		virtual std::string getType(void) const;
 
-		virtual std::string getEngineName(void) const;
+		std::string getEngineName(void) const;
 
-		virtual QueryProperties getQuery(void) const;
+		QueryProperties getQuery(void) const;
 
-		virtual const std::vector<Result> &getResults(void) const;
+		const std::vector<Result> &getResults(void) const;
 
 		virtual bool stop(void);
 
@@ -158,11 +158,13 @@
 
 		virtual std::string getType(void) const;
 
-		virtual std::string getLabelName(void) const;
+		std::string getIndexName(void) const;
 
+		std::string getLabelName(void) const;
+
 		virtual bool stop(void);
 
-		virtual const std::set<unsigned int> &getDocumentsList(void) const;
+		const std::set<unsigned int> &getDocumentsList(void) const;
 
 	protected:
 		std::string m_indexName;
@@ -212,9 +214,9 @@
 
 		virtual std::string getType(void) const;
 
-		virtual std::string getURL(void) const;
+		std::string getURL(void) const;
 
-		virtual const Document *getDocument(void) const;
+		const Document *getDocument(void) const;
 
 		virtual bool stop(void);
 

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-29 09:00:55 UTC (rev 28)
@@ -73,11 +73,7 @@
 unsigned int mainWindow::m_maxThreads = 2;
 
 mainWindow::InternalState::InternalState() :
-	m_currentLabelPos(0),
-	m_currentLabelName(_("None")),
-	m_currentIndexName(_("My Documents")),
-	m_indexDocsCount(0),
-	m_startDoc(0),
+	m_currentPage(0),
 	m_backgroundThreads(0),
 	m_browsingIndex(false)
 {
@@ -124,52 +120,6 @@
 	pthread_rwlock_unlock(&m_rwLock);
 }
 
-unsigned int mainWindow::InternalState::getCurrentLabel(string &labelName)
-{
-	if (readLock(1) == true)
-	{
-		unsigned int labelPos = m_currentLabelPos;
-		labelName = m_currentLabelName;
-		unlock();
-
-		return labelPos;
-	}
-	
-	return 0;
-}
-
-void mainWindow::InternalState::setCurrentLabel(unsigned int labelPos, const string &labelName)
-{
-	if (writeLock(1) == true)
-	{
-		m_currentLabelPos = labelPos;
-		m_currentLabelName = labelName;
-		unlock();
-	}
-}
-
-Glib::ustring mainWindow::InternalState::getCurrentIndex(void)
-{
-	ustring indexName;
-
-	if (readLock(2) == true)
-	{
-		indexName = m_currentIndexName;
-		unlock();
-	}
-
-	return indexName;
-}
-
-void mainWindow::InternalState::setCurrentIndex(const Glib::ustring &indexName)
-{
-	if (writeLock(2) == true)
-	{
-		m_currentIndexName = indexName;
-		unlock();
-	}
-}
-
 //
 // Constructor
 //
@@ -177,7 +127,7 @@
 	m_settings(PinotSettings::getInstance()), mainWindow_glade(),
 	m_pEnginesTree(NULL),
 	m_pResultsTree(NULL),
-	m_pIndexTree(NULL),
+	m_pIndexMenu(NULL),
 	m_pLabelsMenu(NULL)
 {
 	// Reposition and resize the window
@@ -234,31 +184,15 @@
 	m_pResultsTree->get_selection()->signal_changed().connect(SigC::slot(*this,
 		&mainWindow::on_resultsTreeviewSelection_changed));
 
-	// Position the index tree
-	m_pIndexTree = manage(new IndexTree(indexVbox, indexMenuitem->get_submenu(), m_settings));
-	// Connect to the "changed" signal
-	m_pIndexTree->get_selection()->signal_changed().connect(SigC::slot(*this,
-		&mainWindow::on_indexTreeviewSelection_changed));
-	// Connect to the edit document signal
-	m_pIndexTree->getEditDocumentSignal().connect(SigC::slot(*this,
-		&mainWindow::on_showfromindex_activate));
+	// Populate the index menu
+	populate_indexMenu();
 
-	// Associate the columns model to the index combo
-	m_refIndexNameTree = ListStore::create(m_indexNameColumns);
-	indexCombobox->set_model(m_refIndexNameTree);
-	indexCombobox->pack_start(m_indexNameColumns.m_name);
-	// Populate the index combo
-	populate_indexCombobox();
-
-	// Populate the label menu
-	populate_labelMenu();
-
 	// Add an HTML renderer in the View tab
 	m_pHtmlView = new HtmlView(viewVbox, NULL);
 	if (m_settings.m_browseResults == true)
 	{
 		// Hide this tab
-		Widget *pPage = mainNotebook->get_nth_page(2);
+		Widget *pPage = mainNotebook->get_nth_page(1);
 		if (pPage != NULL)
 		{
 			pPage->hide();
@@ -285,7 +219,6 @@
 		viewcache1->set_sensitive(false);
 	}
 	indexresults1->set_sensitive(false);
-	showlabels1->set_sensitive(false);
 	viewfromindex1->set_sensitive(false);
 	refreshindex1->set_sensitive(false);
 	showfromindex1->set_sensitive(false);
@@ -293,8 +226,6 @@
 	//viewstop1->set_sensitive(false);
 	// ...and buttons
 	removeIndexButton->set_sensitive(false);
-	indexBackButton->set_sensitive(false);
-	indexForwardButton->set_sensitive(false);
 
 	// Set focus on the query entry field
 	set_focus(*liveQueryEntry);
@@ -320,8 +251,6 @@
 	start_thread(pMonitorThread, true);
 	// The handler object will be deleted when the thread terminates
 
-	// List the documents index
-	browse_index();
 	// There might be queued actions
 	check_queue();
 
@@ -344,12 +273,12 @@
 	}
 
 	// This is a hack to avoid segfaults when the View tab hasn't been made visible
-	Widget *pPage = mainNotebook->get_nth_page(2);
+	Widget *pPage = mainNotebook->get_nth_page(1);
 	if (pPage != NULL)
 	{
 		pPage->show();
 	}
-	mainNotebook->set_current_page(2);
+	mainNotebook->set_current_page(1);
 	// Stop if we were loading a page
 	m_pHtmlView->stop();
 	delete m_pHtmlView;
@@ -424,82 +353,35 @@
 }
 
 //
-// Populate the indexes list
+// Populate the index menu
 //
-void mainWindow::populate_indexCombobox()
+void mainWindow::populate_indexMenu()
 {
-	TreeModel::iterator iter;
-	TreeModel::Row row;
-
-	const std::map<string, string> &indexes = m_settings.getIndexes();
-#ifdef DEBUG
-	cout << "mainWindow::populate_indexCombobox: " << indexes.size() << " indexes" << endl;
-#endif
-	m_refIndexNameTree->clear();
-	std::map<string, string>::const_iterator indexIter = indexes.begin();
-	for (; indexIter != indexes.end(); ++indexIter)
+	if (m_pIndexMenu == NULL)
 	{
-		string indexName = indexIter->first;
-
-		if (m_settings.isInternalIndex(indexName) == true)
-		{
-			// Add this index
-			iter = m_refIndexNameTree->append();
-			row = *iter;
-			row[m_indexNameColumns.m_name] = to_utf8(indexName);
-#ifdef DEBUG
-			cout << "mainWindow::populate_indexCombobox: added " << indexName << endl;
-#endif
-		}
+		m_pIndexMenu = new Menu();
+		list1->set_submenu(*m_pIndexMenu);
 	}
-
-	indexCombobox->set_active(0);
-}
-
-//
-// Populate the labels menu
-//
-void mainWindow::populate_labelMenu()
-{
-	RadioMenuItem::Group labelsGroup;
-	RadioMenuItem *firstLabelMenuItem = NULL;
-	RadioMenuItem *labelMenuItem = NULL;
-
-#ifdef DEBUG
-	cout << "mainWindow::populate_labels_menu: called" << endl;
-#endif
-	if (m_pLabelsMenu == NULL)
-	{
-		m_pLabelsMenu = new Menu();
-		showlabels1->set_submenu(*m_pLabelsMenu);
-	}
 	else
 	{
 		// Clear the submenu
-		m_pLabelsMenu->items().clear();
+		m_pIndexMenu->items().clear();
 	}
 
-	SigC::Slot1<void, unsigned int> labelsSlot = SigC::slot(*this, &mainWindow::on_labelMenu_changed);
-	unsigned int count = 1;
-                                                                                                                                                             
-	// Initialize the submenu
-	m_pLabelsMenu->items().push_back(Menu_Helpers::RadioMenuElem(labelsGroup, _("None")));
-	firstLabelMenuItem = labelMenuItem = (RadioMenuItem*)&m_pLabelsMenu->items().back();
-	// Bind the callback's parameter to the menuitem's position in the submenu
-	SigC::Slot0<void> labelsSlot0 = sigc::bind(labelsSlot, 0);
-	labelMenuItem->signal_activate().connect(labelsSlot0);
-	for (set<PinotSettings::Label>::const_iterator iter = m_settings.m_labels.begin();
-		iter != m_settings.m_labels.end(); ++iter)
-	{
-		m_pLabelsMenu->items().push_back(Menu_Helpers::RadioMenuElem(labelsGroup, iter->m_name));
-		labelMenuItem = (RadioMenuItem*)&m_pLabelsMenu->items().back();
-		SigC::Slot0<void> labelsSlot0 = sigc::bind(labelsSlot, count);
-		labelMenuItem->signal_activate().connect(labelsSlot0);
-		++count;
-	}
+	SigC::Slot1<void, ustring> indexSlot = SigC::slot(*this, &mainWindow::on_index_changed);
 
-	// Activate the first menuitem
-	firstLabelMenuItem->set_active(true);
+	// Populate the submenu
+	m_pIndexMenu->items().push_back(Menu_Helpers::MenuElem(_("My Documents")));
+	MenuItem *pMenuItem = &m_pIndexMenu->items().back();
+	// Bind the callback's parameter to the index name
+	SigC::Slot0<void> documentsActivateSlot = sigc::bind(indexSlot, _("My Documents"));
+	pMenuItem->signal_activate().connect(documentsActivateSlot);
+
+	m_pIndexMenu->items().push_back(Menu_Helpers::MenuElem(_("My Email")));
+	pMenuItem = &m_pIndexMenu->items().back();
+	// Bind the callback's parameter to the index name
+	SigC::Slot0<void> emailActivateSlot = sigc::bind(indexSlot, _("My Email"));
+	pMenuItem->signal_activate().connect(emailActivateSlot);
 }
 
 //
@@ -616,20 +498,29 @@
 //
 // Index tree selection changed
 //
-void mainWindow::on_indexTreeviewSelection_changed()
+void mainWindow::on_indexTreeviewSelection_changed(ustring indexName)
 {
-	if (m_pIndexTree->onSelectionChanged() == true)
+	vector<IndexedDocument> documentsList;
+
+	IndexPage *pIndexPage = get_index_page(indexName);
+	if (pIndexPage == NULL)
 	{
+		return;
+	}
+
+	IndexTree *pIndexTree = pIndexPage->getTree();
+	if ((pIndexTree != NULL) &&
+		(pIndexTree->getSelection(documentsList) == true))
+	{
 		bool isDocumentsIndex = true;
 		bool canViewDocument = true;
 
 		// Enable these menu items, unless the index is not the documents index
-		ustring currentIndexName = m_state.getCurrentIndex();
-		if (currentIndexName != _("My Documents"))
+		if (indexName != _("My Documents"))
 		{
 			isDocumentsIndex = false;
 		}
-		if ((currentIndexName == _("My Email")) &&
+		if ((indexName == _("My Email")) &&
 			(m_settings.m_browseResults == true))
 		{
 			canViewDocument = false;
@@ -642,7 +533,7 @@
 		// Show the URL in the status bar
 		ustring statusText = _("Document location is");
 		statusText += " ";
-		statusText += m_pIndexTree->getFirstSelectionURL();
+		statusText += pIndexTree->getFirstSelectionURL();
 		set_status(statusText, true);
 	}
 	else
@@ -656,56 +547,128 @@
 }
 
 //
-// Index > Show Labels menu selected
+// Index > List menu selected
 //
-void mainWindow::on_labelMenu_changed(unsigned int pos)
+void mainWindow::on_index_changed(ustring indexName)
 {
-	string currentLabelName;
-	unsigned int currentLabelPos;
+	IndexTree *pIndexTree = NULL;
+	IndexPage *pIndexPage = NULL;
+	bool foundPage = false;
 
-	// Since we listen for signal_activate(), this handler gets called when the
-	// current item is unselected and when the new one is selected
-	currentLabelPos = m_state.getCurrentLabel(currentLabelName);
-	if (currentLabelPos == pos)
+#ifdef DEBUG
+	cout << "mainWindow::on_index_changed: current index now " << indexName << endl;
+#endif
+
+	// Is there already a page for this index ?
+	pIndexPage = get_index_page(indexName);
+	if (pIndexPage != NULL)
 	{
-		// Ignore unselections
+		// Force a refresh
+		pIndexTree = pIndexPage->getTree();
+		if (pIndexTree != NULL)
+		{
+			pIndexTree->clear();
+		}
+		pIndexPage->setFirstDocument(0);
+		pIndexPage->setDocumentsCount(0);
+		foundPage = true;
+	}
+
+	if ((foundPage == false) &&
+		(m_state.writeLock(1) == true))
+	{
+		NotebookTabBox *pTab = manage(new NotebookTabBox(indexName,
+			NotebookTabBox::INDEX_PAGE));
+		pTab->getCloseSignal().connect(
+			SigC::slot(*this, &mainWindow::on_page_closed));
+
+		// Position the index tree
+		pIndexTree = manage(new IndexTree(indexName, indexMenuitem->get_submenu(), m_settings));
+		pIndexPage = manage(new IndexPage(indexName, pIndexTree, m_settings));
+		// Connect to the "changed" signal
+		pIndexTree->getSelectionChangedSignal().connect(
+			SigC::slot(*this, &mainWindow::on_indexTreeviewSelection_changed));
+		// Connect to the edit document signal
+		pIndexTree->getEditDocumentSignal().connect(
+			SigC::slot(*this, &mainWindow::on_showfromindex_activate));
+		// Connect to the label changed signal
+		pIndexPage->getLabelChangedSignal().connect(
+			SigC::slot(*this, &mainWindow::on_label_changed));
+		// ...and to the buttons clicked signals
+		pIndexPage->getBackClickedSignal().connect(
+			SigC::slot(*this, &mainWindow::on_indexBackButton_clicked));
+		pIndexPage->getForwardClickedSignal().connect(
+			SigC::slot(*this, &mainWindow::on_indexForwardButton_clicked));
+		int pageNum = mainNotebook->append_page(*pIndexPage, *pTab);
+		if (pageNum >= 0)
+		{
+			// Add this page to the list
+			foundPage = true;
+		}
+
+		m_state.unlock();
+	}
+
+	if (foundPage == true)
+	{
+		browse_index(indexName, 0);
+	}
+}
+
+//
+// Index > labels combo selection changed
+//
+void mainWindow::on_label_changed(ustring indexName, ustring labelName)
+{
+	IndexPage *pIndexPage = get_index_page(indexName);
+	if (pIndexPage == NULL)
+	{
 		return;
 	}
+	IndexTree *pIndexTree = pIndexPage->getTree();
+	if (pIndexTree == NULL)
+	{
+		return;
+	}
+
 #ifdef DEBUG
-	cout << "mainWindow::on_labelMenu_changed: called on " << pos << endl;
+	cout << "mainWindow::on_label_changed: called on " << labelName << endl;
 #endif
-	currentLabelPos = pos;
-	if (currentLabelPos == 0)
+	pIndexTree->setCurrentLabelColour(0, 0, 0, false);
+	if (labelName.empty() == true)
 	{
 		// User selected no label
-		currentLabelName = _("None");
-		m_state.setCurrentLabel(currentLabelPos, currentLabelName);
-		m_pIndexTree->setCurrentLabelColour(0, 0, 0, false);
-		set_status(_("No labels"));
+		set_status(_("No label"));
 		return;
 	}
 
-	// Get the actual label from the settings object
-	unsigned int labelNum = 1;
-	for (set<PinotSettings::Label>::iterator labelIter = m_settings.m_labels.begin();
-		labelIter != m_settings.m_labels.end(); ++labelIter)
+	// Get the documents that match this label
+	start_thread(new LabelQueryThread(indexName, labelName));
+}
+
+//
+// Notebook page closed
+//
+void mainWindow::on_page_closed(ustring title, NotebookTabBox::PageType type)
+{
+	if (type != NotebookTabBox::INDEX_PAGE)
 	{
-		if (labelNum == pos)
-		{
-			// That's the one
-			currentLabelName = locale_from_utf8(labelIter->m_name);
-			m_state.setCurrentLabel(currentLabelPos, currentLabelName);
+		return;
+	}
+
 #ifdef DEBUG
-			cout << "mainWindow::on_labelMenu_changed: label is " << currentLabelName << endl;
+	cout << "mainWindow::on_page_closed: called for tab " << title << endl;
 #endif
-			// Switch temporarily to no label
-			m_pIndexTree->setCurrentLabelColour(0, 0, 0, false);
+	int pageNum = get_index_page_number(title);
+	if (pageNum >= 0)
+	{
+		if (m_state.writeLock(2) == true)
+		{
+			// Remove the page
+			mainNotebook->remove_page(pageNum);
 
-			// Get the documents that match this label
-			start_thread(new LabelQueryThread(m_state.getCurrentIndex(), currentLabelName));
-			break;
+			m_state.unlock();
 		}
-		++labelNum;
 	}
 }
 
@@ -773,7 +736,6 @@
 	{
 		char docsCountStr[64];
 		unsigned int count = 0;
-		bool enableIndexOps = false;
 
 		IndexBrowserThread *pBrowseThread = dynamic_cast<IndexBrowserThread *>(pThread);
 		if (pBrowseThread == NULL)
@@ -782,9 +744,26 @@
 			return;
 		}
 
-		m_state.m_indexDocsCount = pBrowseThread->getDocumentsCount();
-		count = m_pIndexTree->getRowsCount();
+		IndexPage *pIndexPage = NULL;
+		IndexTree *pIndexTree = NULL;
+		ustring indexName = locale_to_utf8(pBrowseThread->getIndexName());
 
+		// Find the page for this index
+		pIndexPage = get_index_page(indexName);
+		if (pIndexPage == NULL)
+		{
+			// It's probably been closed by the user
+			return;
+		}
+		pIndexTree = pIndexPage->getTree();
+		if (pIndexTree == NULL)
+		{
+			return;
+		}
+
+		pIndexPage->setDocumentsCount(pBrowseThread->getDocumentsCount());
+		count = pIndexTree->getRowsCount();
+
 		status = _("Showing");
 		status += " ";
 		snprintf(docsCountStr, 64, "%u", count);
@@ -792,43 +771,20 @@
 		status += " ";
 		status += _("off");
 		status += " ";
-		snprintf(docsCountStr, 64, "%u", m_state.m_indexDocsCount);
+		snprintf(docsCountStr, 64, "%u", pIndexPage->getDocumentsCount());
 		status += docsCountStr;
 		status += " ";
 		status += _("documents from");
 		status += " ";
-		status += m_state.getCurrentIndex();
+		status += indexName;
 		set_status(status);
 
-		if (m_state.m_indexDocsCount > 0)
+		if (pIndexPage->getDocumentsCount() > 0)
 		{
-			// Switch to the index page
-			mainNotebook->set_current_page(1);
-			// FIXME: not sure why, but this helps with refreshing the tree
-			m_pIndexTree->columns_autosize();
-			enableIndexOps = true;
+			// Refresh the tree
+			pIndexTree->refresh();
 		}
-		showlabels1->set_sensitive(enableIndexOps);
-#ifdef DEBUG
-		cout << "mainWindow::on_thread_end: " << m_state.m_indexDocsCount
-			<< " documents, starting at " << m_state.m_startDoc << endl;
-#endif
-		if (m_state.m_startDoc >= m_maxDocsCount)
-		{
-			indexBackButton->set_sensitive(true);
-		}
-		else
-		{
-			indexBackButton->set_sensitive(false);
-		}
-		if (m_state.m_indexDocsCount >= m_state.m_startDoc + m_maxDocsCount)
-		{
-			indexForwardButton->set_sensitive(true);
-		}
-		else
-		{
-			indexForwardButton->set_sensitive(false);
-		}
+		pIndexPage->updateButtons(m_maxDocsCount);
 		m_state.m_browsingIndex = false;
 	}
 	else if (type == "QueryingThread")
@@ -896,31 +852,39 @@
 	}
 	else if (type == "LabelQueryThread")
 	{
-		string currentLabelName;
-		unsigned int currentLabelPos = 0;
-
 		LabelQueryThread *pLabelQueryThread = dynamic_cast<LabelQueryThread *>(pThread);
 		if (pLabelQueryThread == NULL)
 		{
 			delete pThread;
 			return;
 		}
+		ustring indexName = locale_to_utf8(pLabelQueryThread->getIndexName());
 
+		IndexPage *pIndexPage = get_index_page(indexName);
+		if (pIndexPage == NULL)
+		{
+			return;
+		}
+		IndexTree *pIndexTree = pIndexPage->getTree();
+		if (pIndexTree == NULL)
+		{
+			return;
+		}
+
 		// Don't bother if the index is not being listed, or if the user
 		// changed the label in the meantime
-		currentLabelPos = m_state.getCurrentLabel(currentLabelName);
-		if ((m_pIndexTree->isEmpty() == false) &&
-			(currentLabelPos > 0) &&
-			(currentLabelName == pLabelQueryThread->getLabelName()))
+		ustring labelName = pIndexPage->getLabelName();
+		if ((pIndexTree->isEmpty() == false) &&
+			(labelName.empty() == false) &&
+			(labelName == locale_to_utf8(pLabelQueryThread->getLabelName())))
 		{
 			const set<unsigned int> &documentsList = pLabelQueryThread->getDocumentsList();
 			char docsCountStr[64];
 			unsigned int docsCount = documentsList.size();
-			unsigned int labelNum = 1;
 
 			status = _("Label");
 			status += " ";
-			status += to_utf8(pLabelQueryThread->getLabelName());
+			status += labelName;
 			status += " ";
 			status += _("matches");
 			status += " ";
@@ -931,27 +895,22 @@
 			set_status(status);
 
 #ifdef DEBUG
-			cout << "mainWindow::on_thread_end: current label is " << currentLabelName << endl;
+			cout << "mainWindow::on_thread_end: current label is " << labelName << endl;
 #endif
 			// Get the actual label colour from the settings
 			for (set<PinotSettings::Label>::iterator labelIter = m_settings.m_labels.begin();
 				labelIter != m_settings.m_labels.end(); ++labelIter)
 			{
-#ifdef DEBUG
-				cout << "mainWindow::on_thread_end: looking at label "
-					<< labelIter->m_name << ", position " << labelNum << endl;
-#endif
-				if (labelNum == currentLabelPos)
+				if (labelName == labelIter->m_name)
 				{
 					// Display the selected label's colour in the index tree
-					m_pIndexTree->setCurrentLabelColour(labelIter->m_red, labelIter->m_green, labelIter->m_blue);
-					m_pIndexTree->setLabel(documentsList);
+					pIndexTree->setCurrentLabelColour(labelIter->m_red, labelIter->m_green, labelIter->m_blue);
+					pIndexTree->setLabel(documentsList);
 
 					// Switch to the index page
-					mainNotebook->set_current_page(1);
+					mainNotebook->set_current_page(get_index_page_number(indexName));
 					break;
 				}
-				++labelNum;
 			}
 		}
 	}
@@ -990,7 +949,7 @@
 				if (m_settings.m_browseResults == false)
 				{
 					// Display the URL in the View tab
-					mainNotebook->set_current_page(2);
+					mainNotebook->set_current_page(1);
 					if (m_pHtmlView->renderData(pData, dataLength, url) == true)
 					{
 						//viewstop1->set_sensitive(true);
@@ -1029,7 +988,7 @@
 			status += to_utf8(url);
 
 			// Update the in-progress list
-			if (m_state.writeLock(3) == true)
+			if (m_state.writeLock(4) == true)
 			{
 				set<string>::iterator urlIter = m_state.m_beingIndexed.find(url);
 				if (urlIter != m_state.m_beingIndexed.end())
@@ -1040,21 +999,24 @@
 				m_state.unlock();
 			}
 
-			// Was the current label applied to that document ?
-			string currentLabelName;
-			if ((m_state.getCurrentLabel(currentLabelName) > 0) &&
-				(pIndexThread->getLabelName() == currentLabelName))
-			{
-				labeled = true;
-			}
-
 			// Is the index still being shown ?
-			if (m_state.getCurrentIndex() == _("My Documents"))
+			IndexPage *pIndexPage = get_index_page(_("My Documents"));
+			if (pIndexPage != NULL)
 			{
+				IndexTree *pIndexTree = pIndexPage->getTree();
 				XapianIndex index(m_settings.m_indexLocation);
 
-				if (index.isGood() == true)
+				// Was the current label applied to that document ?
+				ustring labelName = pIndexPage->getLabelName();
+				if ((labelName.empty() == false) &&
+					(labelName == locale_to_utf8(pIndexThread->getLabelName())))
 				{
+					labeled = true;
+				}
+
+				if ((pIndexTree != NULL) &&
+					(index.isGood() == true))
+				{
 					// Update the index tree
 					for (set<unsigned int>::iterator idIter = docIdList.begin();
 						idIter != docIdList.end(); ++idIter)
@@ -1071,12 +1033,10 @@
 								docInfo.getLocation(), docInfo.getType(),
 								docInfo.getLanguage());
 							indexedDoc.setTimestamp(docInfo.getTimestamp());
-							m_pIndexTree->appendDocument(indexedDoc, labeled);
+							pIndexTree->appendDocument(indexedDoc, labeled);
 						}
 					}
 				}
-
-				showlabels1->set_sensitive(true);
 			}
 		}
 
@@ -1111,8 +1071,16 @@
 			return;
 		}
 
-		m_pIndexTree->setDocumentTitle(pUpdateThread->getDocumentID(),
-			pUpdateThread->getDocumentInfo().getTitle());
+		IndexPage *pIndexPage = get_index_page(_("My Documents"));
+		if (pIndexPage != NULL)
+		{
+			IndexTree *pIndexTree = pIndexPage->getTree();
+			if (pIndexTree != NULL)
+			{
+				pIndexTree->setDocumentTitle(pUpdateThread->getDocumentID(),
+					pUpdateThread->getDocumentInfo().getTitle());
+			}
+		}
 
 		status = _("Updated document");
 		set_status(status);
@@ -1226,31 +1194,40 @@
 //
 void mainWindow::on_message_indexupdate(IndexedDocument docInfo, unsigned int docId, string indexName)
 {
+	IndexPage *pIndexPage = NULL;
+	IndexTree *pIndexTree = NULL;
 	bool hasLabel = false;
 
-	if (indexName != locale_from_utf8(m_state.getCurrentIndex()))
+	// Find the page for this index
+	pIndexPage = get_index_page(locale_to_utf8(indexName));
+	if (pIndexPage == NULL)
 	{
-		// Ignore
+		// It's probably been closed by the user
 #ifdef DEBUG
-		cout << "mainWindow::on_message_indexupdate: " << indexName << " not current" << endl;
+		cout << "mainWindow::on_message_indexupdate: " << indexName << " not being shown" << endl;
 #endif
 		return;
 	}
+	pIndexTree = pIndexPage->getTree();
+	if (pIndexTree == NULL)
+	{
+		return;
+	}
 
 	// Is the last page being displayed ?
-	if (m_state.m_startDoc + m_maxDocsCount < m_state.m_indexDocsCount)
+	if (pIndexPage->getFirstDocument() + m_maxDocsCount < pIndexPage->getDocumentsCount())
 	{
 		// No, so we can't add a new entry for that document
 		// Increment the count
-		++m_state.m_indexDocsCount;
+		pIndexPage->setDocumentsCount(pIndexPage->getDocumentsCount() + 1);
 		// ...and make sure the user can display that last page
-		indexForwardButton->set_sensitive(true);
+		pIndexPage->updateButtons(m_maxDocsCount);
 		return;
 	}
 
 	// Does that document have the current label ?
-	string currentLabelName;
-	if (m_state.getCurrentLabel(currentLabelName) > 0)
+	ustring labelName = pIndexPage->getLabelName();
+	if (labelName.empty() == false)
 	{
 		const std::map<string, string> &indexesMap = PinotSettings::getInstance().getIndexes();
 		std::map<string, string>::const_iterator mapIter = indexesMap.find(indexName);
@@ -1260,18 +1237,18 @@
 
 			if (index.isGood() == true)
 			{
-				hasLabel = index.hasLabel(docId, currentLabelName);
+				hasLabel = index.hasLabel(docId, locale_from_utf8(labelName));
 			}
 		}
 	}
 
 	// Add a row
-	if (m_pIndexTree->appendDocument(docInfo, hasLabel) == true)
+	if (pIndexTree->appendDocument(docInfo, hasLabel) == true)
 	{
 #ifdef DEBUG
 		cout << "mainWindow::on_message_indexupdate: added document to index list" << endl;
 #endif
-		++m_state.m_indexDocsCount;
+		pIndexPage->setDocumentsCount(pIndexPage->getDocumentsCount() + 1);
 	}
 }
 
@@ -1309,15 +1286,36 @@
 	// FIXME: if mail accounts are configured, make sure the MonitorThread
 	// is running and knows about the new accounts
 
-	// Synchronize the labels list with the new settings
-	m_pIndexTree->setCurrentLabelColour(0, 0, 0, false);
-	populate_labelMenu();
+	if (m_state.readLock(5) == true)
+	{
+		for (int pageNum = 0; pageNum < mainNotebook->get_n_pages(); ++pageNum)
+		{
+			Widget *pPage = mainNotebook->get_nth_page(pageNum);
+			if (pPage != NULL)
+			{
+				IndexPage *pIndexPage = dynamic_cast<IndexPage*>(pPage);
+				if (pIndexPage != NULL)
+				{
+					IndexTree *pIndexTree = pIndexPage->getTree();
 
+					// Synchronize the labels list with the new settings
+					if (pIndexTree != NULL)
+					{
+						pIndexTree->setCurrentLabelColour(0, 0, 0, false);
+					}
+					pIndexPage->populateLabelCombobox();
+				}
+			}
+		}
+
+		m_state.unlock();
+	}
+
 	// Do the changes affect the View tab ?
 	if (useExternalBrowser != m_settings.m_browseResults)
 	{
 		int nCurrentPage = mainNotebook->get_current_page();
-		Widget *pPage = mainNotebook->get_nth_page(2);
+		Widget *pPage = mainNotebook->get_nth_page(1);
 		if (pPage != NULL)
 		{
 			// Hide or show ?
@@ -1417,37 +1415,47 @@
 			firstItem = false;
 		}
 	}
-	else if (m_pIndexTree->is_focus() == true)
+	else
 	{
-		vector<IndexedDocument> documentsList;
-		bool firstItem = true;
+		// The focus may be on one of the index tabs
+		IndexPage *pIndexPage = get_index_page_with_focus(true);
+		if (pIndexPage != NULL)
+		{
+			IndexTree *pIndexTree = pIndexPage->getTree();
+			if (pIndexTree != NULL)
+			{
+				vector<IndexedDocument> documentsList;
+				bool firstItem = true;
 
 #ifdef DEBUG
-		cout << "mainWindow::on_copy_activate: index tree" << endl;
+				cout << "mainWindow::on_copy_activate: index tree" << endl;
 #endif
-		// Get the current documents selection
-		m_pIndexTree->getSelection(documentsList);
-	
-		for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
-			docIter != documentsList.end(); ++docIter)
-		{
-			if (firstItem == false)
-			{
-				text += "\n";
+				// Get the current documents selection
+				pIndexTree->getSelection(documentsList);
+
+				for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
+					docIter != documentsList.end(); ++docIter)
+				{
+					if (firstItem == false)
+					{
+						text += "\n";
+					}
+					text += docIter->getTitle();
+					text += " ";
+					text += docIter->getLocation();
+					firstItem = false;
+				}
 			}
-			text += docIter->getTitle();
-			text += " ";
-			text += docIter->getLocation();
-			firstItem = false;
 		}
-	}
-	else
-	{
-		// Only rows from the query, results and index trees can be copied
+
+		if (text.empty() == true)
+		{
+			// Only rows from the query, results and index trees can be copied
 #ifdef DEBUG
-		cout << "mainWindow::on_copy_activate: other" << endl;
+			cout << "mainWindow::on_copy_activate: other" << endl;
 #endif
-		return;
+			return;
+		}
 	}
 	
 	RefPtr<Clipboard> refClipboard = Clipboard::get();
@@ -1631,9 +1639,18 @@
 //
 void mainWindow::on_viewfromindex_activate()
 {
-	// View the first document, don't bother about the rest
-	ustring url = m_pIndexTree->getFirstSelectionLiveURL();
-	view_document(locale_from_utf8(url));
+	IndexPage *pIndexPage = get_index_page_with_focus(false);
+	if (pIndexPage != NULL)
+	{
+		IndexTree *pIndexTree = pIndexPage->getTree();
+
+		if (pIndexTree != NULL)
+		{
+			// View the first document, don't bother about the rest
+			ustring url = pIndexTree->getFirstSelectionLiveURL();
+			view_document(locale_from_utf8(url));
+		}
+	}
 }
 
 //
@@ -1651,11 +1668,20 @@
 	}
 
 	// Get the current documents selection
-	if ((m_pIndexTree->getSelection(documentsList) == false) ||
-		(documentsList.empty() == true))
+	IndexPage *pIndexPage = get_index_page_with_focus(false);
+	if (pIndexPage != NULL)
 	{
-		// No selection
-		return;
+		IndexTree *pIndexTree = pIndexPage->getTree();
+
+		if (pIndexTree != NULL)
+		{
+			if ((pIndexTree->getSelection(documentsList) == false) ||
+				(documentsList.empty() == true))
+			{
+				// No selection
+				return;
+			}
+		}
 	}
 
 	for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
@@ -1693,19 +1719,28 @@
 {
 	vector<IndexedDocument> documentsList;
 	set<string> docLabels;
-	string currentLabelName;
+	string indexName, labelName;
 	DocumentInfo docInfo;
 	unsigned int docId = 0;
 	int width, height;
 	bool matchedLabel = false, editTitle = false;
 
+	IndexTree *pIndexTree = NULL;
+	IndexPage *pIndexPage = get_index_page_with_focus(false);
+	if (pIndexPage != NULL)
+	{
+		indexName = locale_from_utf8(pIndexPage->getIndexName());
+		labelName = locale_from_utf8(pIndexPage->getLabelName());
+		pIndexTree = pIndexPage->getTree();
+	}
+
 	const std::map<string, string> &indexesMap = PinotSettings::getInstance().getIndexes();
-	std::map<string, string>::const_iterator mapIter = indexesMap.find(m_state.getCurrentIndex());	
+	std::map<string, string>::const_iterator mapIter = indexesMap.find(indexName);	
 	if (mapIter == indexesMap.end())
 	{
 		ustring statusText = _("Index");
 		statusText += " ";
-		statusText += m_state.getCurrentIndex();
+		statusText += indexName;
 		statusText += " ";
 		statusText += _("doesn't exist");
 		set_status(statusText);
@@ -1715,7 +1750,8 @@
 	XapianIndex index(mapIter->second);
 
 	// Get the current documents selection
-	if ((m_pIndexTree->getSelection(documentsList) == false) ||
+	if ((pIndexTree == NULL) ||
+		(pIndexTree->getSelection(documentsList) == false) ||
 		(documentsList.empty() == true))
 	{
 		// No selection
@@ -1736,8 +1772,8 @@
 			index.getDocumentLabels(docId, docLabels);
 
 			// Does it match the current label ?
-			if ((m_state.getCurrentLabel(currentLabelName) > 0) &&
-				(find(docLabels.begin(), docLabels.end(), currentLabelName) != docLabels.end()))
+			if ((labelName.empty() == false) &&
+				(find(docLabels.begin(), docLabels.end(), labelName) != docLabels.end()))
 			{
 				matchedLabel = true;
 			}
@@ -1778,17 +1814,17 @@
 		bool matchesLabel = false;
 
 		// Does the sole selected document match the current label now ?
-		if ((currentLabelName.empty() == false) &&
-			(find(labels.begin(), labels.end(), currentLabelName) != labels.end()))
+		if ((labelName.empty() == false) &&
+			(find(labels.begin(), labels.end(), labelName) != labels.end()))
 		{
-				matchesLabel = true;
+			matchesLabel = true;
 		}
 
 		// Was there any change ?
 		if (matchesLabel != matchedLabel)
 		{
-				// Update this document to the index tree
-				m_pIndexTree->setDocumentLabeledState(docId, matchesLabel);
+			// Update this document to the index tree
+			pIndexTree->setDocumentLabeledState(docId, matchesLabel);
 		}
 
 		// Did the title change ?
@@ -1798,18 +1834,16 @@
 			docInfo.setTitle(newTitle);
 			
 			// Update the document
-			start_thread(new UpdateDocumentThread(m_state.getCurrentIndex(), docId, docInfo));
+			start_thread(new UpdateDocumentThread(indexName, docId, docInfo));
 		}
 	}
 	else
 	{
-		string currentLabelName;
-
-		if (m_state.getCurrentLabel(currentLabelName) > 0)
+		if (labelName.empty() == false)
 		{
 			// The current label may have been applied to or removed from
 			// one or more of the selected documents, so refresh the list
-			start_thread(new LabelQueryThread(m_state.getCurrentIndex(), currentLabelName));
+			start_thread(new LabelQueryThread(indexName, labelName));
 		}
 	}
 }
@@ -1822,8 +1856,16 @@
 	vector<IndexedDocument> documentsList;
 	ustring boxTitle = _("Delete this document from the index ?");
 
+	IndexTree *pIndexTree = NULL;
+	IndexPage *pIndexPage = get_index_page_with_focus(false);
+	if (pIndexPage != NULL)
+	{
+		pIndexTree = pIndexPage->getTree();
+	}
+
 	// Get the current documents selection
-	if ((m_pIndexTree->getSelection(documentsList) == false) ||
+	if ((pIndexTree == NULL) ||
+		(pIndexTree->getSelection(documentsList) == false) ||
 		(documentsList.empty() == true))
 	{
 		return;
@@ -1845,11 +1887,7 @@
 	}
 
 	// Remove these documents from the tree
-	if (m_pIndexTree->deleteSelection() == true)
-	{
-		// The index tree is now empty
-		showlabels1->set_sensitive(false);
-	}
+	pIndexTree->deleteSelection();
 
 	set<unsigned int> docIdList;
 	for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
@@ -2101,58 +2139,40 @@
 }
 
 //
-// Index list mouse click
+// Index back button click
 //
-void mainWindow::on_indexCombobox_changed()
+void mainWindow::on_indexBackButton_clicked(ustring indexName)
 {
-	TreeModel::iterator indexIter = indexCombobox->get_active();
-	if (indexIter)
+	IndexPage *pIndexPage = get_index_page(indexName);
+	if (pIndexPage != NULL)
 	{
-		TreeModel::Row row = *indexIter;
-
-		ustring indexName = row[m_indexNameColumns.m_name];
-#ifdef DEBUG
-		cout << "mainWindow::on_indexCombobox_changed: current index now " << indexName << endl;
-#endif
-		ustring currentIndexName = m_state.getCurrentIndex();
-		m_state.setCurrentIndex(indexName);
-		if ((currentIndexName.empty() == false) &&
-			(currentIndexName != indexName))
+		if (pIndexPage->getFirstDocument() >= m_maxDocsCount)
 		{
-			// Force a refresh if the selected index has changed
-			m_state.m_startDoc = m_state.m_indexDocsCount = 0;
-			on_indexForwardButton_clicked();
+			pIndexPage->setFirstDocument(pIndexPage->getFirstDocument() - m_maxDocsCount);
+			browse_index(indexName, pIndexPage->getFirstDocument());
 		}
 	}
 }
 
 //
-// Index back button click
-//
-void mainWindow::on_indexBackButton_clicked()
-{
-	if (m_state.m_startDoc >= m_maxDocsCount)
-	{
-		m_state.m_startDoc -= m_maxDocsCount;
-		browse_index(m_state.m_startDoc);
-	}
-}
-
-//
 // Index forward button click
 //
-void mainWindow::on_indexForwardButton_clicked()
+void mainWindow::on_indexForwardButton_clicked(ustring indexName)
 {
-	if (m_state.m_indexDocsCount == 0)
+	IndexPage *pIndexPage = get_index_page(indexName);
+	if (pIndexPage != NULL)
 	{
-		m_state.m_startDoc = 0;
-		browse_index(m_state.m_startDoc);
+		if (pIndexPage->getDocumentsCount() == 0)
+		{
+			pIndexPage->setFirstDocument(0);
+			browse_index(indexName, 0);
+		}
+		else if (pIndexPage->getDocumentsCount() >= pIndexPage->getFirstDocument() + m_maxDocsCount)
+		{
+			pIndexPage->setFirstDocument(pIndexPage->getFirstDocument() + m_maxDocsCount);
+			browse_index(indexName, pIndexPage->getFirstDocument());
+		}
 	}
-	else if (m_state.m_indexDocsCount >= m_state.m_startDoc + m_maxDocsCount)
-	{
-		m_state.m_startDoc += m_maxDocsCount;
-		browse_index(m_state.m_startDoc);
-	}
 }
 
 //
@@ -2170,6 +2190,31 @@
 }
 
 //
+// Notebook page switch
+//
+void mainWindow::on_mainNotebook_switch_page(GtkNotebookPage *p0, guint p1)
+{
+#ifdef DEBUG
+	cout << "mainWindow::on_mainNotebook_switch_page: switched to page " << p1 << endl;
+#endif
+	if (m_state.m_currentPage != (int)p1)
+	{
+		// Disable the widgets that depend on what page is selected
+		// Results
+		clearresults1->set_sensitive(false);
+		viewresults1->set_sensitive(false);
+		viewcache1->set_sensitive(false);
+		indexresults1->set_sensitive(false);
+		// Index
+		viewfromindex1->set_sensitive(false);
+		refreshindex1->set_sensitive(false);
+		showfromindex1->set_sensitive(false);
+		unindex1->set_sensitive(false);
+	}
+	m_state.m_currentPage = (int)p1;
+}
+
+//
 // Main window deleted
 //
 bool mainWindow::on_mainWindow_delete_event(GdkEventAny *ev)
@@ -2187,7 +2232,7 @@
 			return true;
 		}
 
-		if (m_state.readLock(4) == true)
+		if (m_state.readLock(6) == true)
 		{
 			for (set<WorkerThread *>::iterator threadIter = m_state.m_pThreads.begin();
 				threadIter != m_state.m_pThreads.end(); ++threadIter)
@@ -2218,6 +2263,127 @@
 }
 
 //
+// Returns the IndexPage for the index that has the focus.
+//
+IndexPage *mainWindow::get_index_page_with_focus(bool checkTree)
+{
+	IndexPage *pIndexPage = NULL;
+
+	if (m_state.readLock(7) == true)
+	{
+		for (int pageNum = 0; pageNum < mainNotebook->get_n_pages(); ++pageNum)
+		{
+			Widget *pPage = mainNotebook->get_nth_page(pageNum);
+			if (pPage != NULL)
+			{
+				pIndexPage = dynamic_cast<IndexPage*>(pPage);
+				if (pIndexPage != NULL)
+				{
+#ifdef DEBUG
+					cout << "mainWindow::get_index_page_with_focus: " << pIndexPage->getIndexName() << endl;
+#endif
+					if (checkTree == false)
+					{
+						if (pIndexPage->is_focus() == true)
+						{
+							break;
+						}
+					}
+					else
+					{
+						IndexTree *pIndexTree = pIndexPage->getTree();
+						if ((pIndexTree != NULL) &&
+							(pIndexTree->is_focus() == true))
+						{
+							break;
+						}
+					}
+					pIndexPage = NULL;
+				}
+			}
+		}
+
+		m_state.unlock();
+	}
+
+	return pIndexPage;
+}
+
+//
+// Returns the IndexPage for the given index.
+//
+IndexPage *mainWindow::get_index_page(const ustring &indexName)
+{
+	IndexPage *pIndexPage = NULL;
+
+	if (m_state.readLock(8) == true)
+	{
+		for (int pageNum = 0; pageNum < mainNotebook->get_n_pages(); ++pageNum)
+		{
+			Widget *pPage = mainNotebook->get_nth_page(pageNum);
+			if (pPage != NULL)
+			{
+				pIndexPage = dynamic_cast<IndexPage*>(pPage);
+				if (pIndexPage != NULL)
+				{
+#ifdef DEBUG
+					cout << "mainWindow::get_index_page: " << pIndexPage->getIndexName() << endl;
+#endif
+					// It's an index page, check the name of the index
+					if (indexName == pIndexPage->getIndexName())
+					{
+						// That's the page we are looking for
+						break;
+					}
+					pIndexPage = NULL;
+				}
+			}
+		}
+
+		m_state.unlock();
+	}
+
+	return pIndexPage;
+}
+
+//
+// Returns the page number for the given index.
+//
+int mainWindow::get_index_page_number(const ustring &indexName)
+{
+	int pageNumber = -1;
+
+	if (m_state.readLock(9) == true)
+	{
+		for (int pageNum = 0; pageNum < mainNotebook->get_n_pages(); ++pageNum)
+		{
+			Widget *pPage = mainNotebook->get_nth_page(pageNum);
+			if (pPage != NULL)
+			{
+				IndexPage *pIndexPage = dynamic_cast<IndexPage*>(pPage);
+				if (pIndexPage != NULL)
+				{
+#ifdef DEBUG
+					cout << "mainWindow::get_index_page_number: " << pIndexPage->getIndexName() << endl;
+#endif
+					// It's an index page, check the name of the index
+					if (indexName == pIndexPage->getIndexName())
+					{
+						// That's the page we are looking for
+						pageNumber = pageNum;
+						break;
+					}
+				}
+			}
+		}
+
+		m_state.unlock();
+	}
+
+	return pageNumber;
+}
+
+//
 // Queues additions to the index.
 //
 bool mainWindow::queue_index(const DocumentInfo &docInfo,
@@ -2491,7 +2657,7 @@
 //
 // Browse an index
 //
-void mainWindow::browse_index(unsigned int startDoc)
+void mainWindow::browse_index(const ustring &indexName, unsigned int startDoc)
 {
 	bool enableIndexOps = false;
 
@@ -2502,25 +2668,31 @@
 	}
 	m_state.m_browsingIndex = true;
 
-	// Remove existing rows in the index tree
-	m_pIndexTree->clear();
-	// Disable this
-	showlabels1->set_sensitive(false);
-	// Reset variables
-	m_state.m_indexDocsCount = 0;
+	IndexPage *pIndexPage = get_index_page(indexName);
+	if (pIndexPage != NULL)
+	{
+		IndexTree *pIndexTree = pIndexPage->getTree();
+		if (pIndexTree != NULL)
+		{
+			// Remove existing rows in the index tree
+			pIndexTree->clear();
+		}
+		// Reset variables
+		pIndexPage->setDocumentsCount(0);
 
-	if (m_state.getCurrentIndex() == _("My Documents"))
+		// Switch to that index page
+		mainNotebook->set_current_page(get_index_page_number(indexName));
+	}
+
+	if (indexName == _("My Documents"))
 	{
 		enableIndexOps = true;
 	}
 	import1->set_sensitive(enableIndexOps);
 
 	// Spawn a new thread to browse the index
-#ifdef DEBUG
-	cout << "mainWindow::browse_index: indexing " << m_state.getCurrentIndex() << endl;
-#endif
 	IndexBrowserThread *pBrowseThread = new IndexBrowserThread(
-		locale_from_utf8(m_state.getCurrentIndex()), m_maxDocsCount, startDoc);
+		locale_from_utf8(indexName), m_maxDocsCount, startDoc);
 	pBrowseThread->getUpdateSignal().connect(SigC::slot(*this,
 		&mainWindow::on_message_indexupdate));
 	start_thread(pBrowseThread);
@@ -2561,7 +2733,7 @@
 			docId = index.hasDocument(url);
 		}
 		if ((docId == 0) &&
-			(m_state.writeLock(4) == true))
+			(m_state.writeLock(10) == true))
 		{
 			if (m_state.m_beingIndexed.find(url) == m_state.m_beingIndexed.end())
 			{
@@ -2649,7 +2821,7 @@
 		else
 		{
 			// Display the URL in the View tab
-			mainNotebook->set_current_page(2);
+			mainNotebook->set_current_page(1);
 			if (m_pHtmlView->renderUrl(url) == true)
 			{
 				//viewstop1->set_sensitive(true);
@@ -2686,7 +2858,7 @@
 	pNewThread->getFinishedSignal().connect(SigC::slot(*this,
 		&mainWindow::on_thread_end));
 
-	if (m_state.writeLock(5) == true)
+	if (m_state.writeLock(11) == true)
 	{
 		pair<set<WorkerThread *>::iterator, bool> insertPair = m_state.m_pThreads.insert(pNewThread);
 		insertedThread = insertPair.second;
@@ -2833,7 +3005,7 @@
 {
 	int count = 0;
 
-	if (m_state.readLock(5) == true)
+	if (m_state.readLock(12) == true)
 	{
 		count = m_state.m_pThreads.size() - m_state.m_backgroundThreads;
 		m_state.unlock();

Modified: trunk/UI/GTK2/src/mainWindow.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow.hh	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/mainWindow.hh	2005-12-29 09:00:55 UTC (rev 28)
@@ -36,10 +36,11 @@
 #include "IndexedDocument.h"
 #include "ActionHistory.h"
 #include "QueryProperties.h"
-#include "HtmlView.h"
 #include "EnginesTree.h"
-#include "IndexTree.h"
+#include "HtmlView.h"
+#include "IndexPage.h"
 #include "ModelColumns.h"
+#include "NotebookTabBox.h"
 #include "PinotSettings.h"
 #include "ResultsTree.h"
 #include "WorkerThreads.h"
@@ -55,15 +56,16 @@
 	// Utility methods
 	void populate_queryTreeview();
 	void save_queryTreeview();
-	void populate_indexCombobox();
-	void populate_labelMenu();
+	void populate_indexMenu();
 
 	// Handlers
 	void on_enginesTreeviewSelection_changed();
 	void on_queryTreeviewSelection_changed();
 	void on_resultsTreeviewSelection_changed();
-	void on_indexTreeviewSelection_changed();
-	void on_labelMenu_changed(unsigned int pos);
+	void on_indexTreeviewSelection_changed(Glib::ustring indexName);
+	void on_index_changed(Glib::ustring indexName);
+	void on_label_changed(Glib::ustring indexName, Glib::ustring labelName);
+	void on_page_closed(Glib::ustring title, NotebookTabBox::PageType type);
 	void on_thread_end();
 	void on_editindex(Glib::ustring indexName, Glib::ustring location);
 	void on_message_reception(DocumentInfo docInfo, std::string labelName);
@@ -103,21 +105,23 @@
 	virtual void on_removeQueryButton_clicked();
 	virtual void on_findQueryButton_clicked();
 
-	virtual void on_indexCombobox_changed();
+	virtual void on_indexBackButton_clicked(Glib::ustring indexName);
+	virtual void on_indexForwardButton_clicked(Glib::ustring indexName);
 
-	virtual void on_indexBackButton_clicked();
-	virtual void on_indexForwardButton_clicked();
-
 	virtual bool on_queryTreeview_button_press_event(GdkEventButton *ev);
+	virtual void on_mainNotebook_switch_page(GtkNotebookPage *p0, guint p1);
 	virtual bool on_mainWindow_delete_event(GdkEventAny *ev);
 
 	// Action methods
+	IndexPage *get_index_page_with_focus(bool checkTree);
+	IndexPage *get_index_page(const Glib::ustring &indexName);
+	int get_index_page_number(const Glib::ustring &indexName);
 	bool queue_index(const DocumentInfo &docInfo, const std::string &labelName,
 		unsigned int docId = 0);
 	bool queue_unindex(set<unsigned int> &docIdList);
 	void edit_query(QueryProperties &queryProps, bool newQuery);
 	void run_search(const QueryProperties &queryProps);
-	void browse_index(unsigned int startDoc = 0);
+	void browse_index(const Glib::ustring &indexName, unsigned int startDoc);
 	void index_document(const DocumentInfo &docInfo, const std::string &labelName,
 		unsigned int docId = 0);
 	bool view_document(const std::string &url, bool internalViewerOnly = false);
@@ -143,7 +147,7 @@
 	// Results
 	ResultsTree *m_pResultsTree;
 	// Index
-	IndexTree *m_pIndexTree;
+	Gtk::Menu *m_pIndexMenu;
 	Gtk::Menu *m_pLabelsMenu;
 	ComboModelColumns m_indexNameColumns;
 	Glib::RefPtr<Gtk::ListStore> m_refIndexNameTree;
@@ -164,14 +168,8 @@
 			bool writeLock(unsigned int where);
 			void unlock(void);
 
-			unsigned int getCurrentLabel(std::string &labelName);
-			void setCurrentLabel(unsigned int labelPos, const std::string &labelName);
-			Glib::ustring getCurrentIndex(void);
-			void setCurrentIndex(const Glib::ustring &indexName);
-
-			// Index
-			unsigned int m_indexDocsCount;
-			unsigned int m_startDoc;
+			// Notebook pages
+			int m_currentPage;
 			// Worker threads
 			std::set<WorkerThread *> m_pThreads;
 			unsigned int m_backgroundThreads;
@@ -182,10 +180,6 @@
 		protected:
 			// Read/write lock
 			pthread_rwlock_t m_rwLock;
-			// Index
-			unsigned int m_currentLabelPos;
-			std::string m_currentLabelName;
-			Glib::ustring m_currentIndexName;
 
 	} m_state;
 	static unsigned int m_maxDocsCount;

Modified: trunk/UI/GTK2/src/mainWindow_glade.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-29 09:00:55 UTC (rev 28)
@@ -1,4 +1,4 @@
-// generated 2005/12/16 0:48:33 SGT by fabrice at amra.dyndns.org.(none)
+// generated 2005/12/29 0:33:08 SGT by fabrice at thorgrim.dyndns.org.(none)
 // using glademm V2.6.0
 //
 // DO NOT EDIT THIS FILE ! It was created using
@@ -71,7 +71,7 @@
    delete1 = NULL;
    Gtk::Menu *editMenuitem_menu = Gtk::manage(new class Gtk::Menu());
    editMenuitem = NULL;
-   Gtk::Image *image514 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-clear"), Gtk::IconSize(1)));
+   Gtk::Image *image530 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-clear"), Gtk::IconSize(1)));
    clearresults1 = NULL;
    showextract1 = NULL;
    searchenginegroup1 = NULL;
@@ -85,16 +85,16 @@
    indexresults1 = NULL;
    Gtk::Menu *resultsMenuitem_menu = Gtk::manage(new class Gtk::Menu());
    resultsMenuitem = NULL;
-   showlabels1 = NULL;
-   Gtk::Image *image515 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-open"), Gtk::IconSize(1)));
+   list1 = NULL;
+   Gtk::Image *image531 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-open"), Gtk::IconSize(1)));
    import1 = NULL;
    Gtk::MenuItem *separator3 = NULL;
    viewfromindex1 = NULL;
-   Gtk::Image *image516 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-refresh"), Gtk::IconSize(1)));
+   Gtk::Image *image532 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-refresh"), Gtk::IconSize(1)));
    refreshindex1 = NULL;
-   Gtk::Image *image517 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-delete"), Gtk::IconSize(1)));
+   Gtk::Image *image533 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-delete"), Gtk::IconSize(1)));
    unindex1 = NULL;
-   Gtk::Image *image518 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-properties"), Gtk::IconSize(1)));
+   Gtk::Image *image534 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-properties"), Gtk::IconSize(1)));
    showfromindex1 = NULL;
    Gtk::Menu *indexMenuitem_menu = Gtk::manage(new class Gtk::Menu());
    indexMenuitem = NULL;
@@ -142,25 +142,6 @@
    resultsVbox = Gtk::manage(new class Gtk::VBox(false, 0));
    
    Gtk::Label *resultsLabel = Gtk::manage(new class Gtk::Label(_("Results")));
-   indexCombobox = Gtk::manage(new class Gtk::ComboBox());
-   
-   Gtk::Image *image521 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-media-rewind"), Gtk::IconSize(4)));
-   Gtk::Label *label52 = Gtk::manage(new class Gtk::Label(_("Show Previous")));
-   Gtk::HBox *hbox45 = Gtk::manage(new class Gtk::HBox(false, 2));
-   Gtk::Alignment *alignment31 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
-   indexBackButton = Gtk::manage(new class Gtk::Button());
-   
-   Gtk::Image *image522 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-media-forward"), Gtk::IconSize(4)));
-   Gtk::Label *label53 = Gtk::manage(new class Gtk::Label(_("Show Next")));
-   Gtk::HBox *hbox46 = Gtk::manage(new class Gtk::HBox(false, 2));
-   Gtk::Alignment *alignment32 = Gtk::manage(new class Gtk::Alignment(0.5, 0.5, 0, 0));
-   indexForwardButton = Gtk::manage(new class Gtk::Button());
-   
-   Gtk::HButtonBox *indexHbuttonbox = Gtk::manage(new class Gtk::HButtonBox(Gtk::BUTTONBOX_SPREAD, 0));
-   Gtk::HBox *indexButtonsHbox = Gtk::manage(new class Gtk::HBox(false, 0));
-   indexVbox = Gtk::manage(new class Gtk::VBox(false, 0));
-   
-   Gtk::Label *indexLabel = Gtk::manage(new class Gtk::Label(_("Index")));
    viewVbox = Gtk::manage(new class Gtk::VBox(false, 0));
    
    Gtk::Label *viewLabel = Gtk::manage(new class Gtk::Label(_("View")));
@@ -201,7 +182,7 @@
    groupresults1_menu->items().push_back(Gtk::Menu_Helpers::RadioMenuElem(_RadioMIGroup_searchenginegroup1, _("Host Name")));
    hostnamegroup1 = (Gtk::RadioMenuItem *)&groupresults1_menu->items().back();
    
-   resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Clear List"), *image514));
+   resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Clear List"), *image530));
    clearresults1 = (Gtk::ImageMenuItem *)&resultsMenuitem_menu->items().back();
    
    resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::CheckMenuElem(_("Show Extract")));
@@ -222,10 +203,10 @@
    resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("_Index")));
    indexresults1 = (Gtk::MenuItem *)&resultsMenuitem_menu->items().back();
    
-   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("Show Label")));
-   showlabels1 = (Gtk::MenuItem *)&indexMenuitem_menu->items().back();
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("List Contents Of")));
+   list1 = (Gtk::MenuItem *)&indexMenuitem_menu->items().back();
    
-   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Import"), *image515));
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Import"), *image531));
    import1 = (Gtk::ImageMenuItem *)&indexMenuitem_menu->items().back();
    
    indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::SeparatorElem());
@@ -234,13 +215,13 @@
    indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("View")));
    viewfromindex1 = (Gtk::MenuItem *)&indexMenuitem_menu->items().back();
    
-   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Update"), *image516));
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Update"), *image532));
    refreshindex1 = (Gtk::ImageMenuItem *)&indexMenuitem_menu->items().back();
    
-   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Unindex"), *image517));
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Unindex"), *image533));
    unindex1 = (Gtk::ImageMenuItem *)&indexMenuitem_menu->items().back();
    
-   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Properties"), *image518));
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Properties"), *image534));
    showfromindex1 = (Gtk::ImageMenuItem *)&indexMenuitem_menu->items().back();
    
    helpMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("_About")));
@@ -260,19 +241,19 @@
    
    mainMenubar->items().push_back(Gtk::Menu_Helpers::MenuElem(_("_Help"), *helpMenuitem_menu));
    helpMenuitem = (Gtk::MenuItem *)&mainMenubar->items().back();
-   image514->set_alignment(0.5,0.5);
-   image514->set_padding(0,0);
+   image530->set_alignment(0.5,0.5);
+   image530->set_padding(0,0);
    showextract1->set_active(true);
    searchenginegroup1->set_active(true);
    hostnamegroup1->set_active(false);
-   image515->set_alignment(0.5,0.5);
-   image515->set_padding(0,0);
-   image516->set_alignment(0.5,0.5);
-   image516->set_padding(0,0);
-   image517->set_alignment(0.5,0.5);
-   image517->set_padding(0,0);
-   image518->set_alignment(0.5,0.5);
-   image518->set_padding(0,0);
+   image531->set_alignment(0.5,0.5);
+   image531->set_padding(0,0);
+   image532->set_alignment(0.5,0.5);
+   image532->set_padding(0,0);
+   image533->set_alignment(0.5,0.5);
+   image533->set_padding(0,0);
+   image534->set_alignment(0.5,0.5);
+   image534->set_padding(0,0);
    image439->set_alignment(0.5,0.5);
    image439->set_padding(0,0);
    addIndexButton->set_flags(Gtk::CAN_FOCUS);
@@ -375,47 +356,6 @@
    resultsLabel->set_line_wrap(false);
    resultsLabel->set_use_markup(false);
    resultsLabel->set_selectable(false);
-   image521->set_alignment(0.5,0.5);
-   image521->set_padding(0,0);
-   label52->set_alignment(0.5,0.5);
-   label52->set_padding(0,0);
-   label52->set_justify(Gtk::JUSTIFY_LEFT);
-   label52->set_line_wrap(false);
-   label52->set_use_markup(false);
-   label52->set_selectable(false);
-   hbox45->pack_start(*image521, Gtk::PACK_SHRINK, 0);
-   hbox45->pack_start(*label52, Gtk::PACK_SHRINK, 0);
-   alignment31->add(*hbox45);
-   indexBackButton->set_flags(Gtk::CAN_FOCUS);
-   indexBackButton->set_flags(Gtk::CAN_DEFAULT);
-   indexBackButton->set_relief(Gtk::RELIEF_NORMAL);
-   indexBackButton->add(*alignment31);
-   image522->set_alignment(0.5,0.5);
-   image522->set_padding(0,0);
-   label53->set_alignment(0.5,0.5);
-   label53->set_padding(0,0);
-   label53->set_justify(Gtk::JUSTIFY_LEFT);
-   label53->set_line_wrap(false);
-   label53->set_use_markup(false);
-   label53->set_selectable(false);
-   hbox46->pack_start(*image522, Gtk::PACK_SHRINK, 0);
-   hbox46->pack_start(*label53, Gtk::PACK_SHRINK, 0);
-   alignment32->add(*hbox46);
-   indexForwardButton->set_flags(Gtk::CAN_FOCUS);
-   indexForwardButton->set_flags(Gtk::CAN_DEFAULT);
-   indexForwardButton->set_relief(Gtk::RELIEF_NORMAL);
-   indexForwardButton->add(*alignment32);
-   indexHbuttonbox->pack_start(*indexBackButton);
-   indexHbuttonbox->pack_start(*indexForwardButton);
-   indexButtonsHbox->pack_start(*indexCombobox, Gtk::PACK_SHRINK, 4);
-   indexButtonsHbox->pack_start(*indexHbuttonbox, Gtk::PACK_SHRINK, 4);
-   indexVbox->pack_start(*indexButtonsHbox, Gtk::PACK_SHRINK, 4);
-   indexLabel->set_alignment(0.5,0.5);
-   indexLabel->set_padding(0,0);
-   indexLabel->set_justify(Gtk::JUSTIFY_LEFT);
-   indexLabel->set_line_wrap(false);
-   indexLabel->set_use_markup(false);
-   indexLabel->set_selectable(false);
    viewLabel->set_alignment(0.5,0.5);
    viewLabel->set_padding(0,0);
    viewLabel->set_justify(Gtk::JUSTIFY_LEFT);
@@ -429,8 +369,6 @@
    mainNotebook->set_scrollable(false);
    mainNotebook->append_page(*resultsVbox, *resultsLabel);
    mainNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
-   mainNotebook->append_page(*indexVbox, *indexLabel);
-   mainNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
    mainNotebook->append_page(*viewVbox, *viewLabel);
    mainNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
    rightVbox->pack_start(*liveQueryHbox, Gtk::PACK_SHRINK, 0);
@@ -462,7 +400,7 @@
    paste1->show();
    delete1->show();
    editMenuitem->show();
-   image514->show();
+   image530->show();
    clearresults1->show();
    showextract1->show();
    searchenginegroup1->show();
@@ -473,16 +411,16 @@
    viewcache1->show();
    indexresults1->show();
    resultsMenuitem->show();
-   showlabels1->show();
-   image515->show();
+   list1->show();
+   image531->show();
    import1->show();
    separator3->show();
    viewfromindex1->show();
-   image516->show();
+   image532->show();
    refreshindex1->show();
-   image517->show();
+   image533->show();
    unindex1->show();
-   image518->show();
+   image534->show();
    showfromindex1->show();
    indexMenuitem->show();
    about1->show();
@@ -516,21 +454,6 @@
    queryExpander->show();
    resultsVbox->show();
    resultsLabel->show();
-   indexCombobox->show();
-   image521->show();
-   label52->show();
-   hbox45->show();
-   alignment31->show();
-   indexBackButton->show();
-   image522->show();
-   label53->show();
-   hbox46->show();
-   alignment32->show();
-   indexForwardButton->show();
-   indexHbuttonbox->show();
-   indexButtonsHbox->show();
-   indexVbox->show();
-   indexLabel->show();
    viewVbox->show();
    viewLabel->show();
    mainNotebook->show();
@@ -567,9 +490,7 @@
    editQueryButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_editQueryButton_clicked), false);
    removeQueryButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_removeQueryButton_clicked), false);
    findQueryButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_findQueryButton_clicked), false);
-   indexCombobox->signal_changed().connect(SigC::slot(*this, &mainWindow_glade::on_indexCombobox_changed), false);
-   indexBackButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_indexBackButton_clicked), false);
-   indexForwardButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_indexForwardButton_clicked), false);
+   mainNotebook->signal_switch_page().connect(SigC::slot(*this, &mainWindow_glade::on_mainNotebook_switch_page), false);
    mainWindow->signal_delete_event().connect(SigC::slot(*this, &mainWindow_glade::on_mainWindow_delete_event), false);
 }
 

Modified: trunk/UI/GTK2/src/mainWindow_glade.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.hh	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/mainWindow_glade.hh	2005-12-29 09:00:55 UTC (rev 28)
@@ -1,4 +1,4 @@
-// generated 2005/12/16 0:34:21 SGT by fabrice at amra.dyndns.org.(none)
+// generated 2005/12/29 0:33:08 SGT by fabrice at thorgrim.dyndns.org.(none)
 // using glademm V2.6.0
 //
 // DO NOT EDIT THIS FILE ! It was created using
@@ -45,7 +45,6 @@
 #else //
 #include <gtkmm/handlebox.h>
 #endif //
-#include <gtkmm/combobox.h>
 #include <gtkmm/notebook.h>
 #include <gtkmm/paned.h>
 #include <gtkmm/progressbar.h>
@@ -75,7 +74,7 @@
         class Gtk::MenuItem * viewcache1;
         class Gtk::MenuItem * indexresults1;
         class Gtk::MenuItem * resultsMenuitem;
-        class Gtk::MenuItem * showlabels1;
+        class Gtk::MenuItem * list1;
         class Gtk::ImageMenuItem * import1;
         class Gtk::MenuItem * viewfromindex1;
         class Gtk::ImageMenuItem * refreshindex1;
@@ -100,10 +99,6 @@
         class Gtk::HandleBox * queryExpander;
 #endif //
         class Gtk::VBox * resultsVbox;
-        class Gtk::ComboBox * indexCombobox;
-        class Gtk::Button * indexBackButton;
-        class Gtk::Button * indexForwardButton;
-        class Gtk::VBox * indexVbox;
         class Gtk::VBox * viewVbox;
         class Gtk::Notebook * mainNotebook;
         class Gtk::HPaned * mainHpaned;
@@ -140,9 +135,7 @@
         virtual void on_editQueryButton_clicked() = 0;
         virtual void on_removeQueryButton_clicked() = 0;
         virtual void on_findQueryButton_clicked() = 0;
-        virtual void on_indexCombobox_changed() = 0;
-        virtual void on_indexBackButton_clicked() = 0;
-        virtual void on_indexForwardButton_clicked() = 0;
+        virtual void on_mainNotebook_switch_page(GtkNotebookPage *p0, guint p1) = 0;
         virtual bool on_mainWindow_delete_event(GdkEventAny *ev) = 0;
 };
 #endif



From fabricecolin at berlios.de  Thu Dec 29 15:09:38 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Thu, 29 Dec 2005 15:09:38 +0100
Subject: [Pinot-svn] r29 - in trunk/UI: GTK2 GTK2/src RenderHTML
Message-ID: <200512291409.jBTE9cnj026257@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-29 15:09:35 +0100 (Thu, 29 Dec 2005)
New Revision: 29

Added:
   trunk/UI/GTK2/src/Notebook.cpp
   trunk/UI/GTK2/src/Notebook.h
Removed:
   trunk/UI/GTK2/src/NotebookTabBox.cpp
   trunk/UI/GTK2/src/NotebookTabBox.h
Modified:
   trunk/UI/GTK2/metase-gtk2.glade
   trunk/UI/GTK2/src/HtmlView.cpp
   trunk/UI/GTK2/src/HtmlView.h
   trunk/UI/GTK2/src/IndexPage.cpp
   trunk/UI/GTK2/src/IndexPage.h
   trunk/UI/GTK2/src/IndexTree.cpp
   trunk/UI/GTK2/src/Makefile
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/ResultsTree.h
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/mainWindow.hh
   trunk/UI/GTK2/src/mainWindow_glade.cc
   trunk/UI/GTK2/src/mainWindow_glade.hh
   trunk/UI/RenderHTML/MozillaRenderer.cpp
   trunk/UI/RenderHTML/MozillaRenderer.h
Log:
All notebook tabs are open on a need-to basis and can can be closed.


Modified: trunk/UI/GTK2/metase-gtk2.glade
===================================================================
--- trunk/UI/GTK2/metase-gtk2.glade	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/metase-gtk2.glade	2005-12-29 14:09:35 UTC (rev 29)
@@ -146,7 +146,7 @@
 		      <signal name="activate" handler="on_clearresults_activate" last_modification_time="Wed, 03 Mar 2004 19:51:48 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image538">
+			<widget class="GtkImage" id="image546">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-clear</property>
 			  <property name="icon_size">1</property>
@@ -172,6 +172,7 @@
 
 		  <child>
 		    <widget class="GtkMenuItem" id="groupresults1">
+		      <property agent="glademm" name="cxx_visibility">protected</property>
 		      <property name="visible">True</property>
 		      <property name="label" translatable="yes">Group By</property>
 		      <property name="use_underline">True</property>
@@ -273,7 +274,7 @@
 		      <signal name="activate" handler="on_import_activate" last_modification_time="Tue, 02 Mar 2004 22:13:44 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image539">
+			<widget class="GtkImage" id="image547">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-open</property>
 			  <property name="icon_size">1</property>
@@ -311,7 +312,7 @@
 		      <signal name="activate" handler="on_refreshindex_activate" last_modification_time="Fri, 20 Feb 2004 18:57:09 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image540">
+			<widget class="GtkImage" id="image548">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-refresh</property>
 			  <property name="icon_size">1</property>
@@ -333,7 +334,7 @@
 		      <signal name="activate" handler="on_unindex_activate" last_modification_time="Thu, 28 Jul 2005 12:42:23 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image541">
+			<widget class="GtkImage" id="image549">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-delete</property>
 			  <property name="icon_size">1</property>
@@ -355,7 +356,7 @@
 		      <signal name="activate" handler="on_showfromindex_activate" last_modification_time="Sun, 06 Nov 2005 08:43:05 GMT"/>
 
 		      <child internal-child="image">
-			<widget class="GtkImage" id="image542">
+			<widget class="GtkImage" id="image550">
 			  <property name="visible">True</property>
 			  <property name="stock">gtk-properties</property>
 			  <property name="icon_size">1</property>
@@ -513,6 +514,7 @@
 
 	  <child>
 	    <widget class="GtkVBox" id="rightVbox">
+	      <property agent="glademm" name="cxx_visibility">protected</property>
 	      <property name="visible">True</property>
 	      <property name="homogeneous">False</property>
 	      <property name="spacing">0</property>
@@ -817,106 +819,7 @@
 	      </child>
 
 	      <child>
-		<widget class="GtkNotebook" id="mainNotebook">
-		  <property agent="glademm" name="cxx_visibility">protected</property>
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="show_tabs">True</property>
-		  <property name="show_border">True</property>
-		  <property name="tab_pos">GTK_POS_TOP</property>
-		  <property name="scrollable">False</property>
-		  <property name="enable_popup">False</property>
-		  <signal name="switch_page" handler="on_mainNotebook_switch_page" last_modification_time="Wed, 28 Dec 2005 16:33:00 GMT"/>
-
-		  <child>
-		    <widget class="GtkVBox" id="resultsVbox">
-		      <property agent="glademm" name="cxx_visibility">protected</property>
-		      <property name="visible">True</property>
-		      <property name="homogeneous">False</property>
-		      <property name="spacing">0</property>
-
-		      <child>
-			<placeholder/>
-		      </child>
-
-		      <child>
-			<placeholder/>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="tab_expand">False</property>
-		      <property name="tab_fill">True</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="resultsLabel">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Results</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="type">tab</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkVBox" id="viewVbox">
-		      <property agent="glademm" name="cxx_visibility">protected</property>
-		      <property name="visible">True</property>
-		      <property name="homogeneous">False</property>
-		      <property name="spacing">0</property>
-
-		      <child>
-			<placeholder/>
-		      </child>
-		    </widget>
-		    <packing>
-		      <property name="tab_expand">False</property>
-		      <property name="tab_fill">True</property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="viewLabel">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">View</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0.5</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="type">tab</property>
-		    </packing>
-		  </child>
-		</widget>
-		<packing>
-		  <property name="padding">4</property>
-		  <property name="expand">True</property>
-		  <property name="fill">True</property>
-		</packing>
+		<placeholder/>
 	      </child>
 	    </widget>
 	    <packing>

Modified: trunk/UI/GTK2/src/HtmlView.cpp
===================================================================
--- trunk/UI/GTK2/src/HtmlView.cpp	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/HtmlView.cpp	2005-12-29 14:09:35 UTC (rev 29)
@@ -26,25 +26,23 @@
 using namespace Glib;
 using namespace Gtk;
 
-HtmlView::HtmlView(VBox *viewVbox, Menu *pPopupMenu) :
+HtmlView::HtmlView(Menu *pPopupMenu) :
 	MozillaRenderer(),
-	m_pPopupMenu(pPopupMenu)
+	m_pPopupMenu(pPopupMenu),
+	m_pDocHtmlView(NULL)
 {
-	GtkWidget *view = getWidget();
+	GtkWidget *view = getObject();
 	if (view != NULL)
 	{
 		// Wrap this into a gtkmm Widget object
-		// FIXME: need manage(wrap()) ?
-		Widget *pDocHtmlView = wrap(view);
-		if ((pDocHtmlView != NULL) &&
-			(viewVbox != NULL))
+		m_pDocHtmlView = wrap(view);
+		if (m_pDocHtmlView != NULL)
 		{
-			viewVbox->pack_start(*pDocHtmlView);
-
 			// Handle button presses
-			pDocHtmlView->signal_button_press_event().connect_notify(SigC::slot(*this, &HtmlView::onButtonPressEvent));
+			m_pDocHtmlView->signal_button_press_event().connect_notify(
+				SigC::slot(*this, &HtmlView::onButtonPressEvent));
 
-			pDocHtmlView->show();
+			m_pDocHtmlView->show();
 		}
 	}
 }
@@ -71,3 +69,11 @@
 		}
 	}
 }
+
+//
+// Returns the underlying widget.
+//
+Widget *HtmlView::getWidget(void) const
+{
+	return m_pDocHtmlView;
+}

Modified: trunk/UI/GTK2/src/HtmlView.h
===================================================================
--- trunk/UI/GTK2/src/HtmlView.h	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/HtmlView.h	2005-12-29 14:09:35 UTC (rev 29)
@@ -18,7 +18,6 @@
 #define _HTMLVIEW_HH
 
 #include <sigc++/object.h>
-#include <gtkmm/box.h>
 #include <gtkmm/menu.h>
 
 #include "MozillaRenderer.h"
@@ -26,11 +25,15 @@
 class HtmlView : public MozillaRenderer, public SigC::Object
 {
 	public:
-		HtmlView(Gtk::VBox *viewVbox, Gtk::Menu *pPopupMenu);
+		HtmlView(Gtk::Menu *pPopupMenu);
 		virtual ~HtmlView();
 
+		/// Returns the underlying widget.
+		Gtk::Widget *getWidget(void) const;
+
 	protected:
 		Gtk::Menu *m_pPopupMenu;
+		Gtk::Widget *m_pDocHtmlView;
 
 		/// Handles button presses.
 		void onButtonPressEvent(GdkEventButton *ev);

Modified: trunk/UI/GTK2/src/IndexPage.cpp
===================================================================
--- trunk/UI/GTK2/src/IndexPage.cpp	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/IndexPage.cpp	2005-12-29 14:09:35 UTC (rev 29)
@@ -37,10 +37,8 @@
 
 IndexPage::IndexPage(const ustring &indexName, IndexTree *pTree,
 	PinotSettings &settings) :
-	VBox(),
-	m_indexName(indexName),
+	NotebookPageBox(indexName, NotebookPageBox::INDEX_PAGE, settings),
 	m_pTree(pTree),
-	m_settings(settings),
 	m_pLabelCombobox(NULL),
 	m_pBackButton(NULL),
 	m_pForwardButton(NULL),
@@ -162,26 +160,26 @@
 		{
 			m_labelName.clear();
 		}
-		m_signalLabelChanged(m_indexName, m_labelName);
+		m_signalLabelChanged(m_title, m_labelName);
 	}
 }
 
 void IndexPage::onBackClicked(void)
 {
-	m_signalBackClicked(m_indexName);
+	m_signalBackClicked(m_title);
 }
 
 void IndexPage::onForwardClicked(void)
 {
-	m_signalForwardClicked(m_indexName);
+	m_signalForwardClicked(m_title);
 }
 
 //
-// Returns the name of the index being listed.
+// Returns the page's tree.
 //
-ustring IndexPage::getIndexName(void) const
+IndexTree *IndexPage::getTree(void) const
 {
-	return m_indexName;
+	return m_pTree;
 }
 
 //
@@ -193,14 +191,6 @@
 }
 
 //
-// Returns the page's tree.
-//
-IndexTree *IndexPage::getTree(void) const
-{
-	return m_pTree;
-}
-
-//
 // Populates the labels list.
 //
 void IndexPage::populateLabelCombobox(void)

Modified: trunk/UI/GTK2/src/IndexPage.h
===================================================================
--- trunk/UI/GTK2/src/IndexPage.h	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/IndexPage.h	2005-12-29 14:09:35 UTC (rev 29)
@@ -22,7 +22,6 @@
 #include <sigc++/slot.h>
 #include <glibmm/refptr.h>
 #include <glibmm/ustring.h>
-#include <gtkmm/box.h>
 #include <gtkmm/menu.h>
 #include <gdkmm/pixbuf.h>
 #include <gtkmm/combobox.h>
@@ -37,24 +36,22 @@
 #include "IndexedDocument.h"
 #include "IndexTree.h"
 #include "ModelColumns.h"
+#include "Notebook.h"
 #include "PinotSettings.h"
 
-class IndexPage : public Gtk::VBox
+class IndexPage : public NotebookPageBox
 {
 	public:
 		IndexPage(const Glib::ustring &indexName, IndexTree *pTree,
 			PinotSettings &settings);
 		virtual ~IndexPage();
 
-		/// Returns the name of the index being listed.
-		Glib::ustring getIndexName(void) const;
+		/// Returns the page's tree.
+		virtual IndexTree *getTree(void) const;
 
 		/// Returns the name of the current label.
 		Glib::ustring getLabelName(void) const;
 
-		/// Returns the page's tree.
-		IndexTree *getTree(void) const;
-
 		/// Populates the labels list.
 		void populateLabelCombobox(void);
 
@@ -86,7 +83,6 @@
 		Glib::ustring m_indexName;
 		Glib::ustring m_labelName;
 		IndexTree *m_pTree;
-		PinotSettings &m_settings;
 		ComboModelColumns m_labelNameColumns;
 		Glib::RefPtr<Gtk::ListStore> m_refLabelNameTree;
 		Gtk::ComboBox *m_pLabelCombobox;

Modified: trunk/UI/GTK2/src/IndexTree.cpp
===================================================================
--- trunk/UI/GTK2/src/IndexTree.cpp	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/IndexTree.cpp	2005-12-29 14:09:35 UTC (rev 29)
@@ -38,6 +38,7 @@
 	TreeView(),
 	m_indexName(indexName),
 	m_pPopupMenu(pPopupMenu),
+	m_pIndexScrolledwindow(NULL),
 	m_settings(settings)
 {
 	m_pIndexScrolledwindow = manage(new ScrolledWindow());
@@ -150,7 +151,10 @@
 	// Check for double clicks
 	else if (ev->type == GDK_2BUTTON_PRESS)
 	{
-		m_signalEdit;
+#ifdef DEBUG
+		cout << "IndexTree::onButtonPressEvent: double-click" << endl;
+#endif
+		m_signalEdit();
 	}
 }
 

Modified: trunk/UI/GTK2/src/Makefile
===================================================================
--- trunk/UI/GTK2/src/Makefile	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/Makefile	2005-12-29 14:09:35 UTC (rev 29)
@@ -14,7 +14,7 @@
 	queryDialog.cc queryDialog_glade.cc \
 	mainWindow.cc mainWindow_glade.cc
 UI_SRCS = pinot.cpp EnginesTree.cpp IndexPage.cpp IndexTree.cpp \
-	HtmlView.cpp ModelColumns.cpp MonitorHandler.cpp NotebookTabBox.cpp \
+	HtmlView.cpp ModelColumns.cpp MonitorHandler.cpp Notebook.cpp \
 	PinotSettings.cpp PinotUtils.cpp ResultsTree.cpp WorkerThreads.cpp
 UI_GTK2_OBJS := $(patsubst %.cc,${OBJ_DIR}/%.o,${UI_GTK2_SRCS})
 UI_OBJS := $(patsubst %.cpp,${OBJ_DIR}/%.o,${UI_SRCS})

Copied: trunk/UI/GTK2/src/Notebook.cpp (from rev 28, trunk/UI/GTK2/src/NotebookTabBox.cpp)
===================================================================
--- trunk/UI/GTK2/src/NotebookTabBox.cpp	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/Notebook.cpp	2005-12-29 14:09:35 UTC (rev 29)
@@ -0,0 +1,206 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <sigc++/slot.h>
+
+#include "Notebook.h"
+#include "PinotUtils.h"
+
+using namespace SigC;
+using namespace Glib;
+using namespace Gtk;
+
+NotebookPageBox::NotebookPageBox(const ustring &title, NotebookPageBox::PageType type,
+	PinotSettings &settings) :
+	VBox(),
+	m_title(title),
+	m_type(type),
+	m_settings(settings)
+{
+}
+
+NotebookPageBox::~NotebookPageBox()
+{
+}
+
+//
+// Returns the page title.
+//
+ustring NotebookPageBox::getTitle(void) const
+{
+	return m_title;
+}
+
+//
+// Returns the page type.
+//
+NotebookPageBox::PageType NotebookPageBox::getType(void) const
+{
+	return m_type;
+}
+
+ResultsPage::ResultsPage(const ustring &queryName, ResultsTree *pTree,
+	PinotSettings &settings) :
+	NotebookPageBox(queryName, NotebookPageBox::RESULTS_PAGE, settings),
+	m_pTree(pTree)
+{
+	if (pTree != NULL)
+	{
+		pack_start(*pTree->getResultsScrolledWindow(), Gtk::PACK_EXPAND_WIDGET, 0);
+		pack_start(*pTree->getExtractScrolledWindow(), Gtk::PACK_SHRINK, 0);
+	}
+
+	show();
+}
+
+ResultsPage::~ResultsPage()
+{
+}
+
+//
+// Returns the page's tree.
+//
+ResultsTree *ResultsPage::getTree(void) const
+{
+	return m_pTree;
+}
+
+ViewPage::ViewPage(const ustring &viewName, HtmlView *pView,
+	PinotSettings &settings) :
+	NotebookPageBox(viewName, NotebookPageBox::VIEW_PAGE, settings),
+	m_pView(pView)
+{
+	if (pView != NULL)
+	{
+		Widget *pViewWidget = pView->getWidget();
+		if (pViewWidget != NULL)
+		{
+			pack_start(*pViewWidget);
+		}
+	}
+
+	show();
+}
+
+ViewPage::~ViewPage()
+{
+}
+
+//
+// Returns the page's view.
+//
+HtmlView *ViewPage::getView(void) const
+{
+	return m_pView;
+}
+
+NotebookTabBox::NotebookTabBox(const Glib::ustring &title, NotebookPageBox::PageType type) :
+	HBox(),
+	m_title(title),
+	m_pageType(type),
+	m_tabLabel(NULL),
+#if _USE_BUTTON_TAB
+	m_tabButton(NULL)
+#else
+	m_tabEventBox(NULL)
+#endif
+{
+	int width, height;
+
+	// Lookup the standard icon size
+	bool gotDimensions = IconSize::lookup(ICON_SIZE_MENU, width, height);
+
+	m_tabLabel = manage(new Label(title));
+	m_tabImage = manage(new Image(StockID("gtk-close"), IconSize(ICON_SIZE_MENU)));
+#if _USE_BUTTON_TAB
+	m_tabButton = manage(new Button());
+#else
+	m_tabEventBox = manage(new EventBox);
+#endif
+
+	m_tabLabel->set_alignment(0,0.5);
+	m_tabLabel->set_padding(0,0);
+	m_tabLabel->set_justify(JUSTIFY_LEFT);
+	m_tabLabel->set_line_wrap(false);
+	m_tabLabel->set_use_markup(false);
+	m_tabLabel->set_selectable(false);
+	m_tabImage->set_alignment(0,0);
+	m_tabImage->set_padding(0,0);
+#if _USE_BUTTON_TAB
+	m_tabButton->set_flags(CAN_FOCUS);
+	m_tabButton->set_flags(CAN_DEFAULT);
+	m_tabButton->add(*m_tabImage);
+	m_tabButton->set_relief(RELIEF_NONE);
+	m_tabButton->set_border_width(0);
+	m_tabButton->set_alignment(0,0);
+	// Resize the button
+	if (gotDimensions == true)
+	{
+		m_tabButton->set_size_request(width, height);
+		m_tabButton->check_resize();
+	}
+#else
+	m_tabEventBox->add(*m_tabImage);
+	m_tabEventBox->set_events(Gdk::BUTTON_PRESS_MASK);
+#endif
+	pack_start(*m_tabLabel);
+#if _USE_BUTTON_TAB
+	pack_start(*m_tabButton, PACK_SHRINK);
+#else
+	pack_start(*m_tabEventBox, PACK_SHRINK);
+#endif
+	set_spacing(0);
+	set_homogeneous(false);
+	m_tabLabel->show();
+	m_tabImage->show();
+#if _USE_BUTTON_TAB
+	m_tabButton->show();
+#else
+	m_tabEventBox->show();
+#endif
+	show();
+
+#if _USE_BUTTON_TAB
+	m_tabButton->signal_clicked().connect(
+		SigC::slot(*this, &NotebookTabBox::onButtonClicked));
+#else
+	m_tabEventBox->signal_button_press_event().connect(
+		SigC::slot(*this, &NotebookTabBox::onButtonPressEvent));
+#endif
+}
+
+NotebookTabBox::~NotebookTabBox()
+{
+}
+
+#if _USE_BUTTON_TAB
+void NotebookTabBox::onButtonClicked(void)
+#else
+bool NotebookTabBox::onButtonPressEvent(GdkEventButton *ev)
+#endif
+{
+	m_signalClose(m_title, m_pageType);
+
+	return true;
+}
+
+//
+// Returns the close signal.
+//
+Signal2<void, ustring, NotebookPageBox::PageType>& NotebookTabBox::getCloseSignal(void)
+{
+	return m_signalClose;
+}

Copied: trunk/UI/GTK2/src/Notebook.h (from rev 28, trunk/UI/GTK2/src/NotebookTabBox.h)
===================================================================
--- trunk/UI/GTK2/src/NotebookTabBox.h	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/Notebook.h	2005-12-29 14:09:35 UTC (rev 29)
@@ -0,0 +1,116 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _NOTEBOOK_HH
+#define _NOTEBOOK_HH
+
+#include <sigc++/signal.h>
+#include <glibmm/ustring.h>
+#include <gtkmm/box.h>
+#include <gtkmm/label.h>
+#include <gtkmm/image.h>
+#if _USE_BUTTON_TAB
+#include <gtkmm/button.h>
+#else
+#include <gtkmm/eventbox.h>
+#endif
+
+#include "HtmlView.h"
+#include "PinotSettings.h"
+#include "ResultsTree.h"
+
+class NotebookPageBox : public Gtk::VBox
+{
+	public:
+		typedef enum { RESULTS_PAGE = 0, INDEX_PAGE, VIEW_PAGE } PageType;
+
+		NotebookPageBox(const Glib::ustring &title, PageType type,
+			PinotSettings &settings);
+		virtual ~NotebookPageBox();
+
+		/// Returns the page title.
+		Glib::ustring getTitle(void) const;
+
+		/// Returns the page type.
+		PageType getType(void) const;
+
+	protected:
+		Glib::ustring m_title;
+		PageType m_type;
+		PinotSettings &m_settings;
+
+};
+
+class ResultsPage : public NotebookPageBox
+{
+	public:
+		ResultsPage(const Glib::ustring &queryName, ResultsTree *pTree,
+			PinotSettings &settings);
+		virtual ~ResultsPage();
+
+		/// Returns the page's tree.
+		virtual ResultsTree *getTree(void) const;
+
+	protected:
+		ResultsTree *m_pTree;
+
+};
+
+class ViewPage : public NotebookPageBox
+{
+	public:
+		ViewPage(const Glib::ustring &viewName, HtmlView *pView,
+			PinotSettings &settings);
+		virtual ~ViewPage();
+
+		/// Returns the page's view.
+		virtual HtmlView *getView(void) const;
+
+	protected:
+		HtmlView *m_pView;
+
+};
+
+class NotebookTabBox : public Gtk::HBox
+{
+	public:
+		NotebookTabBox(const Glib::ustring &title, NotebookPageBox::PageType type);
+		virtual ~NotebookTabBox();
+
+		/// Returns the close signal.
+		SigC::Signal2<void, Glib::ustring, NotebookPageBox::PageType>& getCloseSignal(void);
+
+	protected:
+		Glib::ustring m_title;
+		NotebookPageBox::PageType m_pageType;
+		Gtk::Label *m_tabLabel;
+		Gtk::Image *m_tabImage;
+#if _USE_BUTTON_TAB
+		Gtk::Button *m_tabButton;
+#else
+		Gtk::EventBox *m_tabEventBox;
+#endif
+		SigC::Signal2<void, Glib::ustring, NotebookPageBox::PageType> m_signalClose;
+
+#if _USE_BUTTON_TAB
+		void onButtonClicked(void);
+#else
+		bool onButtonPressEvent(GdkEventButton *ev);
+#endif
+
+};
+
+#endif // _NOTEBOOK_HH

Deleted: trunk/UI/GTK2/src/NotebookTabBox.cpp
===================================================================
--- trunk/UI/GTK2/src/NotebookTabBox.cpp	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/NotebookTabBox.cpp	2005-12-29 14:09:35 UTC (rev 29)
@@ -1,130 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <sigc++/slot.h>
-
-#include "NotebookTabBox.h"
-#include "PinotUtils.h"
-
-using namespace SigC;
-using namespace Glib;
-using namespace Gtk;
-
-NotebookTabBox::NotebookTabBox(const Glib::ustring &title, PageType type) :
-	HBox(),
-	m_title(title),
-	m_pageType(type),
-	m_tabLabel(NULL),
-#if _USE_BUTTON_TAB
-	m_tabButton(NULL)
-#else
-	m_tabEventBox(NULL)
-#endif
-{
-	int width, height;
-
-	// Lookup the standard icon size
-	bool gotDimensions = IconSize::lookup(ICON_SIZE_MENU, width, height);
-
-	m_tabLabel = manage(new Label(title));
-	m_tabImage = manage(new Image(StockID("gtk-close"), IconSize(ICON_SIZE_MENU)));
-#if _USE_BUTTON_TAB
-	m_tabButton = manage(new Button());
-#else
-	m_tabEventBox = manage(new EventBox);
-#endif
-
-	m_tabLabel->set_alignment(0,0.5);
-	m_tabLabel->set_padding(0,0);
-	m_tabLabel->set_justify(JUSTIFY_LEFT);
-	m_tabLabel->set_line_wrap(false);
-	m_tabLabel->set_use_markup(false);
-	m_tabLabel->set_selectable(false);
-	m_tabImage->set_alignment(0,0);
-	m_tabImage->set_padding(0,0);
-#if _USE_BUTTON_TAB
-	m_tabButton->set_flags(CAN_FOCUS);
-	m_tabButton->set_flags(CAN_DEFAULT);
-	m_tabButton->add(*m_tabImage);
-	m_tabButton->set_relief(RELIEF_NONE);
-	m_tabButton->set_border_width(0);
-	m_tabButton->set_alignment(0,0);
-	// Resize the button
-	if (gotDimensions == true)
-	{
-		m_tabButton->set_size_request(width, height);
-		m_tabButton->check_resize();
-	}
-#else
-	m_tabEventBox->add(*m_tabImage);
-	m_tabEventBox->set_events(Gdk::BUTTON_PRESS_MASK);
-#endif
-	pack_start(*m_tabLabel);
-#if _USE_BUTTON_TAB
-	pack_start(*m_tabButton, PACK_SHRINK);
-#else
-	pack_start(*m_tabEventBox, PACK_SHRINK);
-#endif
-	set_spacing(0);
-	set_homogeneous(false);
-	m_tabLabel->show();
-	m_tabImage->show();
-#if _USE_BUTTON_TAB
-	m_tabButton->show();
-#else
-	m_tabEventBox->show();
-#endif
-	show();
-
-#if _USE_BUTTON_TAB
-	m_tabButton->signal_clicked().connect(
-		SigC::slot(*this, &NotebookTabBox::onButtonClicked));
-#else
-	m_tabEventBox->signal_button_press_event().connect(
-		SigC::slot(*this, &NotebookTabBox::onButtonPressEvent));
-#endif
-}
-
-NotebookTabBox::~NotebookTabBox()
-{
-}
-
-#if _USE_BUTTON_TAB
-void NotebookTabBox::onButtonClicked(void)
-#else
-bool NotebookTabBox::onButtonPressEvent(GdkEventButton *ev)
-#endif
-{
-	m_signalClose(m_title, m_pageType);
-
-	return true;
-}
-
-//
-// Returns the page type.
-//
-NotebookTabBox::PageType NotebookTabBox::getPageType(void) const
-{
-	return m_pageType;
-}
-
-//
-// Returns the close signal.
-//
-Signal2<void, ustring, NotebookTabBox::PageType>& NotebookTabBox::getCloseSignal(void)
-{
-	return m_signalClose;
-}

Deleted: trunk/UI/GTK2/src/NotebookTabBox.h
===================================================================
--- trunk/UI/GTK2/src/NotebookTabBox.h	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/NotebookTabBox.h	2005-12-29 14:09:35 UTC (rev 29)
@@ -1,68 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _NOTEBOOKTABBOX_HH
-#define _NOTEBOOKTABBOX_HH
-
-#include <sigc++/signal.h>
-#include <glibmm/ustring.h>
-#include <gtkmm/box.h>
-#include <gtkmm/label.h>
-#include <gtkmm/image.h>
-#if _USE_BUTTON_TAB
-#include <gtkmm/button.h>
-#else
-#include <gtkmm/eventbox.h>
-#endif
-
-/**
-  * Closable notebook tab.
-  */
-class NotebookTabBox : public Gtk::HBox
-{
-	public:
-		typedef enum { RESULTS_PAGE = 0, INDEX_PAGE, VIEW_PAGE } PageType;
-
-		NotebookTabBox(const Glib::ustring &title, PageType type);
-		virtual ~NotebookTabBox();
-
-		/// Returns the page type.
-		PageType getPageType(void) const;
-
-		/// Returns the close signal.
-		SigC::Signal2<void, Glib::ustring, PageType>& getCloseSignal(void);
-
-	protected:
-		Glib::ustring m_title;
-		PageType m_pageType;
-		Gtk::Label *m_tabLabel;
-		Gtk::Image *m_tabImage;
-#if _USE_BUTTON_TAB
-		Gtk::Button *m_tabButton;
-#else
-		Gtk::EventBox *m_tabEventBox;
-#endif
-		SigC::Signal2<void, Glib::ustring, PageType> m_signalClose;
-
-#if _USE_BUTTON_TAB
-		void onButtonClicked(void);
-#else
-		bool onButtonPressEvent(GdkEventButton *ev);
-#endif
-
-};
-
-#endif // _NOTEBOOKTABBOX_HH

Modified: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-29 14:09:35 UTC (rev 29)
@@ -40,16 +40,19 @@
 using namespace Gdk;
 using namespace Gtk;
 
-ResultsTree::ResultsTree(VBox *resultsVbox, Menu *pPopupMenu, PinotSettings &settings) :
+ResultsTree::ResultsTree(const ustring &queryName, Menu *pPopupMenu,
+	PinotSettings &settings) :
 	TreeView(),
+	m_queryName(queryName),
 	m_pPopupMenu(pPopupMenu),
+	m_pResultsScrolledwindow(NULL),
 	m_settings(settings),
-	m_extractScrolledwindow(NULL),
+	m_pExtractScrolledwindow(NULL),
 	m_extractTextview(NULL),
 	m_showExtract(true)
 {
-	ScrolledWindow *resultsScrolledwindow = manage(new ScrolledWindow());
-	m_extractScrolledwindow = manage(new ScrolledWindow());
+	m_pResultsScrolledwindow = manage(new ScrolledWindow());
+	m_pExtractScrolledwindow = manage(new ScrolledWindow());
 	m_extractTextview = manage(new TextView());
 
 	// This is the actual results tree
@@ -59,12 +62,12 @@
 	set_rules_hint(true);
 	set_reorderable(false);
 	set_enable_search(true);
-	resultsScrolledwindow->set_flags(CAN_FOCUS);
-	resultsScrolledwindow->set_border_width(4);
-	resultsScrolledwindow->set_shadow_type(SHADOW_NONE);
-	resultsScrolledwindow->set_policy(POLICY_AUTOMATIC, POLICY_ALWAYS);
-	resultsScrolledwindow->property_window_placement().set_value(CORNER_TOP_LEFT);
-	resultsScrolledwindow->add(*this);
+	m_pResultsScrolledwindow->set_flags(CAN_FOCUS);
+	m_pResultsScrolledwindow->set_border_width(4);
+	m_pResultsScrolledwindow->set_shadow_type(SHADOW_NONE);
+	m_pResultsScrolledwindow->set_policy(POLICY_AUTOMATIC, POLICY_ALWAYS);
+	m_pResultsScrolledwindow->property_window_placement().set_value(CORNER_TOP_LEFT);
+	m_pResultsScrolledwindow->add(*this);
 
 	// That's for the extract view
 	m_extractTextview->set_flags(CAN_FOCUS);
@@ -78,17 +81,13 @@
 	m_extractTextview->set_indent(0);
 	m_extractTextview->set_wrap_mode(WRAP_WORD);
 	m_extractTextview->set_justification(JUSTIFY_LEFT);
-	m_extractScrolledwindow->set_flags(CAN_FOCUS);
-	m_extractScrolledwindow->set_border_width(4);
-	m_extractScrolledwindow->set_shadow_type(SHADOW_NONE);
-	m_extractScrolledwindow->set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
-	m_extractScrolledwindow->property_window_placement().set_value(CORNER_TOP_LEFT);
-	m_extractScrolledwindow->add(*m_extractTextview);
+	m_pExtractScrolledwindow->set_flags(CAN_FOCUS);
+	m_pExtractScrolledwindow->set_border_width(4);
+	m_pExtractScrolledwindow->set_shadow_type(SHADOW_NONE);
+	m_pExtractScrolledwindow->set_policy(POLICY_AUTOMATIC, POLICY_AUTOMATIC);
+	m_pExtractScrolledwindow->property_window_placement().set_value(CORNER_TOP_LEFT);
+	m_pExtractScrolledwindow->add(*m_extractTextview);
 
-	// Position the scrolled windows
-	resultsVbox->pack_start(*resultsScrolledwindow, Gtk::PACK_EXPAND_WIDGET, 0);
-	resultsVbox->pack_start(*m_extractScrolledwindow, Gtk::PACK_SHRINK, 0);
-
 	// Associate the columns model to the results tree
 	m_refStore = TreeStore::create(m_resultsColumns);
 	set_model(m_refStore);
@@ -119,8 +118,12 @@
 	// Allow multiple selection
 	get_selection()->set_mode(SELECTION_MULTIPLE);
 
-	// Handle button presses
-	signal_button_press_event().connect_notify(SigC::slot(*this, &ResultsTree::onButtonPressEvent));
+	// Connect the signals
+	signal_button_press_event().connect_notify(
+		SigC::slot(*this, &ResultsTree::onButtonPressEvent));
+	get_selection()->signal_changed().connect(
+		SigC::slot(*this, &ResultsTree::onSelectionChanged));
+
 	// Enable interactive search
 	set_search_column(m_resultsColumns.m_text.index());
 	set_search_equal_func(SigC::slot(*this, &ResultsTree::onSearchEqual));
@@ -138,9 +141,9 @@
 
 	// Show all
 	show();
-	resultsScrolledwindow->show();
+	m_pResultsScrolledwindow->show();
 	m_extractTextview->show();
-	m_extractScrolledwindow->show();
+	m_pExtractScrolledwindow->show();
 }
 
 ResultsTree::~ResultsTree()
@@ -230,17 +233,6 @@
 	}
 }
 
-//
-// Interactive search equal function.
-//
-bool ResultsTree::onSearchEqual(const RefPtr<TreeModel>& model, int column,
-	const ustring& key, const TreeModel::iterator& iter)
-{
-}
-
-//
-// Handles button presses.
-//
 void ResultsTree::onButtonPressEvent(GdkEventButton *ev)
 {
 	// Check for popup click
@@ -278,43 +270,16 @@
 	}
 }
 
-//
-// Handles selection changes.
-//
-bool ResultsTree::onSelectionChanged(void)
+void ResultsTree::onSelectionChanged(void)
 {
-	bool goodSel = true;
+	m_signalSelectionChanged(m_queryName);
+}
 
-#ifdef DEBUG
-	cout << "ResultsTree::onSelectionChanged: called" << endl;
-#endif
-	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
-	if (selectedItems.empty() == true)
-	{
-		return false;
-	}
-
-	// Go through selected items
-	for (list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
-		itemPath != selectedItems.end(); ++itemPath)
-	{
-		TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
-		TreeModel::Row row = *iter;
-
-		// Check only results are selected
-		ResultsModelColumns::ResultType type = row[m_resultsColumns.m_type];
-		if (type != ResultsModelColumns::RESULT_TITLE)
-		{
-			goodSel = false;
-		}
-	}
-
-	return goodSel;
+bool ResultsTree::onSearchEqual(const RefPtr<TreeModel>& model, int column,
+	const ustring& key, const TreeModel::iterator& iter)
+{
 }
 
-//
-// Handles attempts to select rows.
-//
 bool ResultsTree::onSelectionSelect(const RefPtr<TreeModel>& model,
 		const TreeModel::Path& path, bool path_currently_selected)
 {
@@ -343,7 +308,7 @@
 			set<string> engineNames, indexNames;
 			string extract;
 
-			m_queryName = locale_from_utf8(row[m_resultsColumns.m_queryName]);
+			// m_queryName and row[m_resultsColumns.m_queryName] should be equal
 			string url = locale_from_utf8(row[m_resultsColumns.m_url]);
 			unsigned int engineIds = row[m_resultsColumns.m_engines];
 			unsigned int indexIds = row[m_resultsColumns.m_indexes];
@@ -378,7 +343,7 @@
 #ifdef DEBUG
 				cout << "ResultsTree::onSelectionSelect: first engine for " << url << " was " << engineName << endl;
 #endif
-				extract = history.getItemExtract(m_queryName, engineName, url);
+				extract = history.getItemExtract(locale_from_utf8(m_queryName), engineName, url);
 			}
 
 			RefPtr<TextBuffer> refBuffer = m_extractTextview->get_buffer();
@@ -392,9 +357,6 @@
 	return true;
 }
 
-//
-// Handles GTK style changes.
-//
 void ResultsTree::onStyleChanged(const RefPtr<Style> &previous_style)
 {
 #ifdef DEBUG
@@ -409,6 +371,22 @@
 }
 
 //
+// Returns the results scrolled window.
+//
+ScrolledWindow *ResultsTree::getResultsScrolledWindow(void) const
+{
+	return m_pResultsScrolledwindow;
+}
+
+//
+// Returns the extract scrolled window.
+//
+ScrolledWindow *ResultsTree::getExtractScrolledWindow(void) const
+{
+	return m_pExtractScrolledwindow;
+}
+
+//
 // Adds a set of results.
 // Returns true if something was added to the tree.
 //
@@ -773,6 +751,40 @@
 }
 
 //
+// Determines if results are selected.
+//
+bool ResultsTree::checkSelection(void)
+{
+	bool goodSel = true;
+
+#ifdef DEBUG
+	cout << "ResultsTree::checkSelection: called" << endl;
+#endif
+	list<TreeModel::Path> selectedItems = get_selection()->get_selected_rows();
+	if (selectedItems.empty() == true)
+	{
+		return false;
+	}
+
+	// Go through selected items
+	for (list<TreeModel::Path>::iterator itemPath = selectedItems.begin();
+		itemPath != selectedItems.end(); ++itemPath)
+	{
+		TreeModel::iterator iter = m_refStore->get_iter(*itemPath);
+		TreeModel::Row row = *iter;
+
+		// Check only results are selected
+		ResultsModelColumns::ResultType type = row[m_resultsColumns.m_type];
+		if (type != ResultsModelColumns::RESULT_TITLE)
+		{
+			goodSel = false;
+		}
+	}
+
+	return goodSel;
+}
+
+//
 // Gets the first selected item's URL.
 //
 ustring ResultsTree::getFirstSelectionURL(void)
@@ -941,16 +953,24 @@
 	if (m_showExtract == true)
 	{
 		// Show the extract
-		m_extractScrolledwindow->show();
+		m_pExtractScrolledwindow->show();
 	}
 	else
 	{
 		// Hide
-		m_extractScrolledwindow->hide();
+		m_pExtractScrolledwindow->hide();
 	}
 }
 
 //
+// Returns the changed selection signal.
+//
+Signal1<void, ustring>& ResultsTree::getSelectionChangedSignal(void)
+{
+	return m_signalSelectionChanged;
+}
+
+//
 // Adds a new row in the results tree.
 //
 bool ResultsTree::appendResult(const string &text, const string &url,

Modified: trunk/UI/GTK2/src/ResultsTree.h
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.h	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/ResultsTree.h	2005-12-29 14:09:35 UTC (rev 29)
@@ -25,7 +25,6 @@
 #include <glibmm/refptr.h>
 #include <glibmm/ustring.h>
 #include <gdkmm/pixbuf.h>
-#include <gtkmm/box.h>
 #include <gtkmm/button.h>
 #include <gtkmm/menu.h>
 #include <gtkmm/scrolledwindow.h>
@@ -42,15 +41,16 @@
 class ResultsTree : public Gtk::TreeView
 {
 	public:
-		ResultsTree(Gtk::VBox *resultsVbox, Gtk::Menu *pPopupMenu, PinotSettings &settings);
+		ResultsTree(const Glib::ustring &queryName, Gtk::Menu *pPopupMenu,
+			PinotSettings &settings);
 		virtual ~ResultsTree();
 
-		/**
-		  * Handles selection changes.
-		  * Returns true if a result is selected.
-		  */
-		bool onSelectionChanged(void);
+		/// Returns the results scrolled window.
+		Gtk::ScrolledWindow *getResultsScrolledWindow(void) const;
 
+		/// Returns the extract scrolled window.
+		Gtk::ScrolledWindow *getExtractScrolledWindow(void) const;
+
 		/**
 		  * Adds a set of results.
 		  * Returns true if something was added to the tree.
@@ -61,6 +61,9 @@
 		/// Groups results.
 		void regroupResults(bool groupBySearchEngine);
 
+		/// Determines if results are selected.
+		bool checkSelection(void);
+
 		/// Gets the first selected item's URL.
 		Glib::ustring getFirstSelectionURL(void);
 
@@ -82,9 +85,15 @@
 		/// Shows or hides the extract field.
 		void showExtract(bool show = true);
 
+		/// Returns the changed selection signal.
+		SigC::Signal1<void, Glib::ustring>& getSelectionChangedSignal(void);
+
 	protected:
+		Glib::ustring m_queryName;
+		Gtk::Menu *m_pPopupMenu;
+		Gtk::ScrolledWindow *m_pResultsScrolledwindow;
 		Glib::RefPtr<Gtk::TreeStore> m_refStore;
-		Gtk::Menu *m_pPopupMenu;
+		SigC::Signal1<void, Glib::ustring> m_signalSelectionChanged;
 		PinotSettings &m_settings;
 		Glib::RefPtr<Gdk::Pixbuf> m_indexedIconPixbuf;
 		Glib::RefPtr<Gdk::Pixbuf> m_viewededIconPixbuf;
@@ -93,11 +102,10 @@
 		Glib::RefPtr<Gdk::Pixbuf> m_downIconPixbuf;
 		std::map<std::string, Gtk::TreeModel::iterator> m_resultsGroups;
 		ResultsModelColumns m_resultsColumns;
-		Gtk::ScrolledWindow *m_extractScrolledwindow;
+		Gtk::ScrolledWindow *m_pExtractScrolledwindow;
 		Gtk::TextView *m_extractTextview;
 		std::set<std::string> m_indexNames;
 		bool m_showExtract;
-		std::string m_queryName;
 
 		void renderViewStatus(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &iter);
 
@@ -105,14 +113,13 @@
 
 		void renderRanking(Gtk::CellRenderer *renderer, const Gtk::TreeModel::iterator &iter);
 
-		/// Interactive search equal function.
+		void onButtonPressEvent(GdkEventButton *ev);
+
+		void onSelectionChanged(void);
+
 		bool onSearchEqual(const Glib::RefPtr<Gtk::TreeModel>& model, int column,
 			const Glib::ustring& key, const Gtk::TreeModel::iterator& iter);
 
-		/// Handles button presses.
-		void onButtonPressEvent(GdkEventButton *ev);
-
-		/// Handles attempts to select rows.
 		bool onSelectionSelect(const Glib::RefPtr<Gtk::TreeModel>& model,
 			const Gtk::TreeModel::Path& path, bool path_currently_selected);
 

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-29 14:09:35 UTC (rev 29)
@@ -44,6 +44,7 @@
 #include "XapianEngine.h"
 #include "config.h"
 #include "NLS.h"
+#include "IndexPage.h"
 #include "PinotUtils.h"
 #include "mainWindow.hh"
 #include "aboutDialog.hh"
@@ -126,9 +127,10 @@
 mainWindow::mainWindow() :
 	m_settings(PinotSettings::getInstance()), mainWindow_glade(),
 	m_pEnginesTree(NULL),
-	m_pResultsTree(NULL),
+	m_pNotebook(NULL),
 	m_pIndexMenu(NULL),
-	m_pLabelsMenu(NULL)
+	m_pLabelsMenu(NULL),
+	m_pHtmlView(NULL)
 {
 	// Reposition and resize the window
 	// Make sure the coordinates and sizes make sense
@@ -178,28 +180,24 @@
 	// Populate
 	populate_queryTreeview();
 
-	// Position the results tree
-	m_pResultsTree = manage(new ResultsTree(resultsVbox, resultsMenuitem->get_submenu(), m_settings));
-	// Connect to the "changed" signal
-	m_pResultsTree->get_selection()->signal_changed().connect(SigC::slot(*this,
-		&mainWindow::on_resultsTreeviewSelection_changed));
-
 	// Populate the index menu
 	populate_indexMenu();
 
-	// Add an HTML renderer in the View tab
-	m_pHtmlView = new HtmlView(viewVbox, NULL);
-	if (m_settings.m_browseResults == true)
+	// Create a notebook, without any page initially
+	m_pNotebook = manage(new Notebook());
+	m_pNotebook->set_flags(Gtk::CAN_FOCUS);
+	m_pNotebook->set_show_tabs(true);
+	m_pNotebook->set_show_border(true);
+	m_pNotebook->set_tab_pos(Gtk::POS_TOP);
+	m_pNotebook->set_scrollable(false);
+	rightVbox->pack_start(*m_pNotebook, Gtk::PACK_EXPAND_WIDGET, 4);
+	m_pNotebook->signal_switch_page().connect(
+		SigC::slot(*this, &mainWindow::on_switch_page), false);
+
+	// Create an HTML renderer
+	m_pHtmlView = new HtmlView(NULL);
+	if (m_settings.m_browseResults == false)
 	{
-		// Hide this tab
-		Widget *pPage = mainNotebook->get_nth_page(1);
-		if (pPage != NULL)
-		{
-			pPage->hide();
-		}
-	}
-	else
-	{
 		view_document("file:///usr/share/pinot/index.html", true);
 	}
 
@@ -208,6 +206,8 @@
 	removeQueryButton->set_sensitive(false);
 	findQueryButton->set_sensitive(false);
 	clearresults1->set_sensitive(false);
+	showextract1->set_sensitive(false);
+	groupresults1->set_sensitive(false);
 	viewresults1->set_sensitive(false);
 	// Hide the View Cache menu item ?
 	if (SearchEngineFactory::isSupported("googleapi") == false)
@@ -256,6 +256,7 @@
 
 	// Now we are ready
 	set_status(_("Ready"));
+	m_pNotebook->show();
 	show();
 }
 
@@ -272,15 +273,12 @@
 		for_each(m_state.m_pThreads.begin(), m_state.m_pThreads.end(), DeleteSetPointer());
 	}
 
-	// This is a hack to avoid segfaults when the View tab hasn't been made visible
-	Widget *pPage = mainNotebook->get_nth_page(1);
-	if (pPage != NULL)
+	// Stop in case we were loading a page
+	NotebookPageBox *pNotebookPage = get_page(_("View"), NotebookPageBox::VIEW_PAGE);
+	if (pNotebookPage != NULL)
 	{
-		pPage->show();
+		m_pHtmlView->stop();
 	}
-	mainNotebook->set_current_page(1);
-	// Stop if we were loading a page
-	m_pHtmlView->stop();
 	delete m_pHtmlView;
 }
 
@@ -449,11 +447,31 @@
 //
 // Results tree selection changed
 //
-void mainWindow::on_resultsTreeviewSelection_changed()
+void mainWindow::on_resultsTreeviewSelection_changed(ustring queryName)
 {
-	if (m_pResultsTree->onSelectionChanged() == true)
+	ustring url;
+	bool hasSelection = false;
+
+	NotebookPageBox *pNotebookPage = get_page(queryName, NotebookPageBox::RESULTS_PAGE);
+	if (pNotebookPage != NULL)
 	{
-		ustring url = m_pResultsTree->getFirstSelectionURL();
+		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
+		if (pResultsPage != NULL)
+		{
+			ResultsTree *pResultsTree = pResultsPage->getTree();
+			if (pResultsTree != NULL)
+			{
+				hasSelection = pResultsTree->checkSelection();
+				if (hasSelection == true)
+				{
+					url = pResultsTree->getFirstSelectionURL();
+				}
+			}
+		}
+	}
+
+	if (hasSelection == true)
+	{
 		bool isViewable = true, isIndexable = true, isCached = false;
 
 		Url urlObj(locale_from_utf8(url));
@@ -502,7 +520,7 @@
 {
 	vector<IndexedDocument> documentsList;
 
-	IndexPage *pIndexPage = get_index_page(indexName);
+	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(indexName, NotebookPageBox::INDEX_PAGE));
 	if (pIndexPage == NULL)
 	{
 		return;
@@ -560,7 +578,7 @@
 #endif
 
 	// Is there already a page for this index ?
-	pIndexPage = get_index_page(indexName);
+	pIndexPage = dynamic_cast<IndexPage*>(get_page(indexName, NotebookPageBox::INDEX_PAGE));
 	if (pIndexPage != NULL)
 	{
 		// Force a refresh
@@ -574,13 +592,12 @@
 		foundPage = true;
 	}
 
-	if ((foundPage == false) &&
-		(m_state.writeLock(1) == true))
+	if (foundPage == false)
 	{
 		NotebookTabBox *pTab = manage(new NotebookTabBox(indexName,
-			NotebookTabBox::INDEX_PAGE));
+			NotebookPageBox::INDEX_PAGE));
 		pTab->getCloseSignal().connect(
-			SigC::slot(*this, &mainWindow::on_page_closed));
+			SigC::slot(*this, &mainWindow::on_close_page));
 
 		// Position the index tree
 		pIndexTree = manage(new IndexTree(indexName, indexMenuitem->get_submenu(), m_settings));
@@ -599,14 +616,19 @@
 			SigC::slot(*this, &mainWindow::on_indexBackButton_clicked));
 		pIndexPage->getForwardClickedSignal().connect(
 			SigC::slot(*this, &mainWindow::on_indexForwardButton_clicked));
-		int pageNum = mainNotebook->append_page(*pIndexPage, *pTab);
-		if (pageNum >= 0)
+
+		// Append the page
+		if (m_state.writeLock(1) == true)
 		{
-			// Add this page to the list
-			foundPage = true;
+			int pageNum = m_pNotebook->append_page(*pIndexPage, *pTab);
+			m_pNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+			if (pageNum >= 0)
+			{
+				foundPage = true;
+			}
+
+			m_state.unlock();
 		}
-
-		m_state.unlock();
 	}
 
 	if (foundPage == true)
@@ -620,7 +642,7 @@
 //
 void mainWindow::on_label_changed(ustring indexName, ustring labelName)
 {
-	IndexPage *pIndexPage = get_index_page(indexName);
+	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(indexName, NotebookPageBox::INDEX_PAGE));
 	if (pIndexPage == NULL)
 	{
 		return;
@@ -647,25 +669,52 @@
 }
 
 //
-// Notebook page closed
+// Notebook page switch
 //
-void mainWindow::on_page_closed(ustring title, NotebookTabBox::PageType type)
+void mainWindow::on_switch_page(GtkNotebookPage *p0, guint p1)
 {
-	if (type != NotebookTabBox::INDEX_PAGE)
+#ifdef DEBUG
+	cout << "mainWindow::on_switch_page: switched to page " << p1 << endl;
+#endif
+	if (m_state.m_currentPage != (int)p1)
 	{
-		return;
+		// Disable the widgets that depend on what page is selected
+		// Results
+		clearresults1->set_sensitive(false);
+		showextract1->set_sensitive(false);
+		groupresults1->set_sensitive(false);
+		viewresults1->set_sensitive(false);
+		viewcache1->set_sensitive(false);
+		indexresults1->set_sensitive(false);
+		// Index
+		viewfromindex1->set_sensitive(false);
+		refreshindex1->set_sensitive(false);
+		showfromindex1->set_sensitive(false);
+		unindex1->set_sensitive(false);
 	}
+	m_state.m_currentPage = (int)p1;
+}
 
+//
+// Notebook page closed
+//
+void mainWindow::on_close_page(ustring title, NotebookPageBox::PageType type)
+{
 #ifdef DEBUG
-	cout << "mainWindow::on_page_closed: called for tab " << title << endl;
+	cout << "mainWindow::on_close_page: called for tab " << title << endl;
 #endif
-	int pageNum = get_index_page_number(title);
+	int pageNum = get_page_number(title, type);
 	if (pageNum >= 0)
 	{
+		if (type == NotebookPageBox::VIEW_PAGE)
+		{
+			m_pHtmlView->stop();
+		}
+
 		if (m_state.writeLock(2) == true)
 		{
 			// Remove the page
-			mainNotebook->remove_page(pageNum);
+			m_pNotebook->remove_page(pageNum);
 
 			m_state.unlock();
 		}
@@ -749,7 +798,7 @@
 		ustring indexName = locale_to_utf8(pBrowseThread->getIndexName());
 
 		// Find the page for this index
-		pIndexPage = get_index_page(indexName);
+		pIndexPage = dynamic_cast<IndexPage*>(get_page(indexName, NotebookPageBox::INDEX_PAGE));
 		if (pIndexPage == NULL)
 		{
 			// It's probably been closed by the user
@@ -793,6 +842,7 @@
 		unsigned int count = 0;
 		ResultsModelColumns::ResultType rootType;
 		bool mergeDuplicates = false;
+		int pageNum = -1;
 
 		QueryingThread *pQueryThread = dynamic_cast<QueryingThread *>(pThread);
 		if (pQueryThread == NULL)
@@ -802,51 +852,93 @@
 		}
 
 		QueryProperties queryProps = pQueryThread->getQuery();
-		string queryName = queryProps.getName();
-		string engineName = pQueryThread->getEngineName();
+		ustring queryName = to_utf8(queryProps.getName());
+		ustring engineName = to_utf8(pQueryThread->getEngineName());
+		const vector<Result> &resultsList = pQueryThread->getResults();
 
 		status = _("Query");
 		status += " ";
-		status += to_utf8(queryName);
+		status += queryName;
 		status += " ";
 		status += _("on");
 		status += " ";
-		status += to_utf8(engineName);
+		status += engineName;
 		status += " ";
 		status += _("ended");
 		set_status(status);
 
-		// Switch to the results page
-		mainNotebook->set_current_page(0);
+		// Find the page for this query
+		ResultsTree *pResultsTree = NULL;
+		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(get_page(queryName, NotebookPageBox::RESULTS_PAGE));
+		if (pResultsPage != NULL)
+		{
+			pResultsTree = pResultsPage->getTree();
+			if (pResultsTree == NULL)
+			{
+				return;
+			}
+			pageNum = get_page_number(queryName, NotebookPageBox::RESULTS_PAGE);
+		}
+		else
+		{
+			// There is none, create one
+			NotebookTabBox *pTab = manage(new NotebookTabBox(queryName,
+				NotebookPageBox::RESULTS_PAGE));
+			pTab->getCloseSignal().connect(
+				SigC::slot(*this, &mainWindow::on_close_page));
 
-		// Add these results to the tree
-		const vector<Result> &resultsList = pQueryThread->getResults();
-		if (m_pResultsTree->addResults(queryProps, engineName,
-			resultsList, searchenginegroup1->get_active()) == true)
+			// Position the results tree
+			pResultsTree = manage(new ResultsTree(queryName, resultsMenuitem->get_submenu(), m_settings));
+			pResultsPage = manage(new ResultsPage(queryName, pResultsTree, m_settings));
+			// Connect to the "changed" signal
+			pResultsTree->getSelectionChangedSignal().connect(
+				SigC::slot(*this, &mainWindow::on_resultsTreeviewSelection_changed));
+
+			// Append the page
+			if (m_state.writeLock(1) == true)
+			{
+				pageNum = m_pNotebook->append_page(*pResultsPage, *pTab);
+				m_pNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+
+				m_state.unlock();
+			}
+		}
+
+		if (pageNum >= 0)
 		{
+			// Switch to that page
+			m_pNotebook->set_current_page(pageNum);
+
+			// Add the results to the tree
+			if (pResultsTree->addResults(queryProps, engineName,
+				resultsList, searchenginegroup1->get_active()) == true)
+			{
 #ifdef DEBUG
-			cout << "mainWindow::on_thread_end: added results" << endl;
+				cout << "mainWindow::on_thread_end: added results" << endl;
 #endif
-			// Enable results clearing
-			clearresults1->set_sensitive(true);
+				// Enable some menuitems
+				clearresults1->set_sensitive(true);
+				showextract1->set_sensitive(false);
+				groupresults1->set_sensitive(false);
+			}
+		}
 
-			// Index results ?
-			if ((queryProps.getIndexResults() == true) &&
-				(resultsList.empty() == false))
-			{
-				string labelName = queryProps.getLabelName();
+		// Index results ?
+		if ((queryProps.getIndexResults() == true) &&
+			(resultsList.empty() == false))
+		{
+			string labelName = queryProps.getLabelName();
 
 #ifdef DEBUG
-				cout << "mainWindow::on_thread_end: indexing results, with label " << labelName << endl;
+			cout << "mainWindow::on_thread_end: indexing results, with label " << labelName << endl;
 #endif
-				for (vector<Result>::const_iterator resultIter = resultsList.begin();
-					resultIter != resultsList.end(); ++resultIter)
-				{
-					// Queue this action
-					queue_index(DocumentInfo(resultIter->getTitle(), resultIter->getLocation(),
-						resultIter->getType(), resultIter->getLanguage()),
-						labelName);
-				}
+			for (vector<Result>::const_iterator resultIter = resultsList.begin();
+				resultIter != resultsList.end(); ++resultIter)
+			{
+				// Queue this action
+				queue_index(DocumentInfo(resultIter->getTitle(), resultIter->getLocation(),
+					resultIter->getType(), resultIter->getLanguage()),
+					labelName);
 			}
 		}
 	}
@@ -860,7 +952,7 @@
 		}
 		ustring indexName = locale_to_utf8(pLabelQueryThread->getIndexName());
 
-		IndexPage *pIndexPage = get_index_page(indexName);
+		IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(indexName, NotebookPageBox::INDEX_PAGE));
 		if (pIndexPage == NULL)
 		{
 			return;
@@ -908,7 +1000,7 @@
 					pIndexTree->setLabel(documentsList);
 
 					// Switch to the index page
-					mainNotebook->set_current_page(get_index_page_number(indexName));
+					m_pNotebook->set_current_page(get_page_number(indexName, NotebookPageBox::INDEX_PAGE));
 					break;
 				}
 			}
@@ -948,13 +1040,21 @@
 				// Make sure settings haven't changed in the meantime
 				if (m_settings.m_browseResults == false)
 				{
-					// Display the URL in the View tab
-					mainNotebook->set_current_page(1);
-					if (m_pHtmlView->renderData(pData, dataLength, url) == true)
+					ustring viewName = _("View");
+
+					// Is there still a view page ?
+					int pageNum = get_page_number(viewName, NotebookPageBox::VIEW_PAGE);
+					if (pageNum >= 0)
 					{
-						//viewstop1->set_sensitive(true);
+						// Display the URL in the View tab
+						if (m_pHtmlView->renderData(pData, dataLength, url) == true)
+						{
+							//viewstop1->set_sensitive(true);
+							set_status(locale_to_utf8(url));
+						}
+
+						m_pNotebook->set_current_page(pageNum);
 					}
-					set_status(locale_to_utf8(url));
 				}
 			}
 		}
@@ -1000,7 +1100,7 @@
 			}
 
 			// Is the index still being shown ?
-			IndexPage *pIndexPage = get_index_page(_("My Documents"));
+			IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(_("My Documents"), NotebookPageBox::INDEX_PAGE));
 			if (pIndexPage != NULL)
 			{
 				IndexTree *pIndexTree = pIndexPage->getTree();
@@ -1071,7 +1171,7 @@
 			return;
 		}
 
-		IndexPage *pIndexPage = get_index_page(_("My Documents"));
+		IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(_("My Documents"), NotebookPageBox::INDEX_PAGE));
 		if (pIndexPage != NULL)
 		{
 			IndexTree *pIndexTree = pIndexPage->getTree();
@@ -1199,7 +1299,7 @@
 	bool hasLabel = false;
 
 	// Find the page for this index
-	pIndexPage = get_index_page(locale_to_utf8(indexName));
+	pIndexPage = dynamic_cast<IndexPage*>(get_page(locale_to_utf8(indexName), NotebookPageBox::INDEX_PAGE));
 	if (pIndexPage == NULL)
 	{
 		// It's probably been closed by the user
@@ -1288,9 +1388,9 @@
 
 	if (m_state.readLock(5) == true)
 	{
-		for (int pageNum = 0; pageNum < mainNotebook->get_n_pages(); ++pageNum)
+		for (int pageNum = 0; pageNum < m_pNotebook->get_n_pages(); ++pageNum)
 		{
-			Widget *pPage = mainNotebook->get_nth_page(pageNum);
+			Widget *pPage = m_pNotebook->get_nth_page(pageNum);
 			if (pPage != NULL)
 			{
 				IndexPage *pIndexPage = dynamic_cast<IndexPage*>(pPage);
@@ -1314,22 +1414,10 @@
 	// Do the changes affect the View tab ?
 	if (useExternalBrowser != m_settings.m_browseResults)
 	{
-		int nCurrentPage = mainNotebook->get_current_page();
-		Widget *pPage = mainNotebook->get_nth_page(1);
-		if (pPage != NULL)
+		// Close the existing view page ?
+		if (m_settings.m_browseResults == true)
 		{
-			// Hide or show ?
-			if (m_settings.m_browseResults == true)
-			{
-				pPage->hide();
-			}
-			else
-			{
-				pPage->show();
-
-				// Make sure we show the same tab
-				mainNotebook->set_current_page(nCurrentPage);
-			}
+			on_close_page(_("View"), NotebookPageBox::VIEW_PAGE);
 		}
 	}
 
@@ -1391,38 +1479,44 @@
 		// Copy only the query name, not the summary
 		text = row[m_queryColumns.m_name];
 	}
-	else if (m_pResultsTree->is_focus() == true)
+	else
 	{
-		vector<Result> resultsList;
-		bool firstItem = true;
+		// The focus may be on one of the notebook pages
+		NotebookPageBox *pNotebookPage = get_page_with_focus();
+		if (pNotebookPage != NULL)
+		{
+			ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
+			if (pResultsPage != NULL)
+			{
+				vector<Result> resultsList;
+				bool firstItem = true;
 
 #ifdef DEBUG
-		cout << "mainWindow::on_copy_activate: results tree" << endl;
+				cout << "mainWindow::on_copy_activate: results tree" << endl;
 #endif
-		// Get the current results selection
-		m_pResultsTree->getSelection(resultsList);
-	
-		for (vector<Result>::const_iterator resultIter = resultsList.begin();
-			resultIter != resultsList.end(); ++resultIter)
-		{
-			if (firstItem == false)
-			{
-				text += "\n";
+				ResultsTree *pResultsTree = pResultsPage->getTree();
+				if (pResultsTree != NULL)
+				{
+					// Get the current results selection
+					pResultsTree->getSelection(resultsList);
+				}
+
+				for (vector<Result>::const_iterator resultIter = resultsList.begin();
+					resultIter != resultsList.end(); ++resultIter)
+				{
+					if (firstItem == false)
+					{
+						text += "\n";
+					}
+					text += resultIter->getTitle();
+					text += " ";
+					text += resultIter->getLocation();
+					firstItem = false;
+				}
 			}
-			text += resultIter->getTitle();
-			text += " ";
-			text += resultIter->getLocation();
-			firstItem = false;
-		}
-	}
-	else
-	{
-		// The focus may be on one of the index tabs
-		IndexPage *pIndexPage = get_index_page_with_focus(true);
-		if (pIndexPage != NULL)
-		{
-			IndexTree *pIndexTree = pIndexPage->getTree();
-			if (pIndexTree != NULL)
+
+			IndexPage *pIndexPage = dynamic_cast<IndexPage*>(pNotebookPage);
+			if (pIndexPage != NULL)
 			{
 				vector<IndexedDocument> documentsList;
 				bool firstItem = true;
@@ -1430,8 +1524,12 @@
 #ifdef DEBUG
 				cout << "mainWindow::on_copy_activate: index tree" << endl;
 #endif
-				// Get the current documents selection
-				pIndexTree->getSelection(documentsList);
+				IndexTree *pIndexTree = pIndexPage->getTree();
+				if (pIndexTree != NULL)
+				{
+					// Get the current documents selection
+					pIndexTree->getSelection(documentsList);
+				}
 
 				for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
 					docIter != documentsList.end(); ++docIter)
@@ -1511,15 +1609,25 @@
 	{
 		liveQueryEntry->delete_selection();
 	}
-	else if (m_pResultsTree->is_focus() == true)
+	else
 	{
+		NotebookPageBox *pNotebookPage = get_page_with_focus();
+		if (pNotebookPage != NULL)
+		{
+			ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
+			if (pResultsPage != NULL)
+			{
 #ifdef DEBUG
-		cout << "mainWindow::on_delete_activate: results tree" << endl;
+				cout << "mainWindow::on_delete_activate: results tree" << endl;
 #endif
-		if (m_pResultsTree->deleteSelection() == true)
-		{
-			// The results tree is now empty
-			clearresults1->set_sensitive(false);
+				ResultsTree *pResultsTree = pResultsPage->getTree();
+				if ((pResultsTree != NULL) &&
+					(pResultsTree->deleteSelection() == true))
+				{
+					// The results tree is now empty
+					clearresults1->set_sensitive(false);
+				}
+			}
 		}
 	}
 	// Nothing else can be deleted
@@ -1530,8 +1638,20 @@
 //
 void mainWindow::on_clearresults_activate()
 {
-	m_pResultsTree->clear();
-	clearresults1->set_sensitive(false);
+	NotebookPageBox *pNotebookPage = get_page_with_focus();
+	if (pNotebookPage != NULL)
+	{
+		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
+		if (pResultsPage != NULL)
+		{
+			ResultsTree *pResultsTree = pResultsPage->getTree();
+			if (pResultsTree != NULL)
+			{
+				pResultsTree->clear();
+				clearresults1->set_sensitive(false);
+			}
+		}
+	}
 }
 
 //
@@ -1539,10 +1659,19 @@
 //
 void mainWindow::on_showextract_activate()
 {
-#ifdef DEBUG
-	cout << "mainWindow::on_showextract_activate: called" << endl;
-#endif
-	m_pResultsTree->showExtract(showextract1->get_active());
+	NotebookPageBox *pNotebookPage = get_page_with_focus();
+	if (pNotebookPage != NULL)
+	{
+		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
+		if (pResultsPage != NULL)
+		{
+			ResultsTree *pResultsTree = pResultsPage->getTree();
+			if (pResultsTree != NULL)
+			{
+				pResultsTree->showExtract(showextract1->get_active());
+			}
+		}
+	}
 }
 
 //
@@ -1552,11 +1681,20 @@
 {
 	ResultsModelColumns::ResultType currentType, newType;
 
-#ifdef DEBUG
-	cout << "mainWindow::on_groupresults_activate: called" << endl;
-#endif
 	// What's the new grouping criteria ?
-	m_pResultsTree->regroupResults(searchenginegroup1->get_active());
+	NotebookPageBox *pNotebookPage = get_page_with_focus();
+	if (pNotebookPage != NULL)
+	{
+		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
+		if (pResultsPage != NULL)
+		{
+			ResultsTree *pResultsTree = pResultsPage->getTree();
+			if (pResultsTree != NULL)
+			{
+				pResultsTree->regroupResults(searchenginegroup1->get_active());
+			}
+		}
+	}
 }
 
 //
@@ -1564,11 +1702,23 @@
 //
 void mainWindow::on_viewresults_activate()
 {
-	ustring url = m_pResultsTree->getFirstSelectionURL();
-	if (view_document(locale_from_utf8(url)) == true)
+	NotebookPageBox *pNotebookPage = get_page_with_focus();
+	if (pNotebookPage != NULL)
 	{
-		// We can update the row right now
-		m_pResultsTree->setFirstSelectionViewedState(true);
+		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
+		if (pResultsPage != NULL)
+		{
+			ResultsTree *pResultsTree = pResultsPage->getTree();
+			if (pResultsTree != NULL)
+			{
+				ustring url = pResultsTree->getFirstSelectionURL();
+				if (view_document(locale_from_utf8(url)) == true)
+				{
+					// We can update the row right now
+					pResultsTree->setFirstSelectionViewedState(true);
+				}
+			}
+		}
 	}
 }
 
@@ -1577,12 +1727,24 @@
 //
 void mainWindow::on_viewcache_activate()
 {
-	ustring url = m_pResultsTree->getFirstSelectionURL();
+	NotebookPageBox *pNotebookPage = get_page_with_focus();
+	if (pNotebookPage != NULL)
+	{
+		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
+		if (pResultsPage != NULL)
+		{
+			ResultsTree *pResultsTree = pResultsPage->getTree();
+			if (pResultsTree != NULL)
+			{
+				ustring url = pResultsTree->getFirstSelectionURL();
 
-	start_thread(new DownloadingThread(url, true));
+				start_thread(new DownloadingThread(url, true));
 
-	// Update the row now, even though the cached page may not be retrieved
-	m_pResultsTree->setFirstSelectionViewedState(true);
+				// Update the row now, even though the cached page may not be retrieved
+				pResultsTree->setFirstSelectionViewedState(true);
+			}
+		}
+	}
 }
 
 //
@@ -1590,6 +1752,8 @@
 //
 void mainWindow::on_indexresults_activate()
 {
+	vector<Result> resultsList;
+
 	// Make sure this has been configured
 	if (m_settings.m_indexLocation.empty() == true)
 	{
@@ -1597,8 +1761,19 @@
 		return;
 	}
 
-	vector<Result> resultsList;
-	m_pResultsTree->getSelection(resultsList);
+	NotebookPageBox *pNotebookPage = get_page_with_focus();
+	if (pNotebookPage != NULL)
+	{
+		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
+		if (pResultsPage != NULL)
+		{
+			ResultsTree *pResultsTree = pResultsPage->getTree();
+			if (pResultsTree != NULL)
+			{
+				pResultsTree->getSelection(resultsList);
+			}
+		}
+	}
 
 	// Go through selected results
 	for (vector<Result>::const_iterator resultIter = resultsList.begin();
@@ -1639,7 +1814,7 @@
 //
 void mainWindow::on_viewfromindex_activate()
 {
-	IndexPage *pIndexPage = get_index_page_with_focus(false);
+	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page_with_focus());
 	if (pIndexPage != NULL)
 	{
 		IndexTree *pIndexTree = pIndexPage->getTree();
@@ -1668,7 +1843,7 @@
 	}
 
 	// Get the current documents selection
-	IndexPage *pIndexPage = get_index_page_with_focus(false);
+	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page_with_focus());
 	if (pIndexPage != NULL)
 	{
 		IndexTree *pIndexTree = pIndexPage->getTree();
@@ -1725,11 +1900,14 @@
 	int width, height;
 	bool matchedLabel = false, editTitle = false;
 
+#ifdef DEBUG
+	cout << "mainWindow::on_showfromindex_activate: called" << endl;
+#endif
 	IndexTree *pIndexTree = NULL;
-	IndexPage *pIndexPage = get_index_page_with_focus(false);
+	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page_with_focus());
 	if (pIndexPage != NULL)
 	{
-		indexName = locale_from_utf8(pIndexPage->getIndexName());
+		indexName = locale_from_utf8(pIndexPage->getTitle());
 		labelName = locale_from_utf8(pIndexPage->getLabelName());
 		pIndexTree = pIndexPage->getTree();
 	}
@@ -1857,7 +2035,7 @@
 	ustring boxTitle = _("Delete this document from the index ?");
 
 	IndexTree *pIndexTree = NULL;
-	IndexPage *pIndexPage = get_index_page_with_focus(false);
+	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page_with_focus());
 	if (pIndexPage != NULL)
 	{
 		pIndexTree = pIndexPage->getTree();
@@ -2143,7 +2321,7 @@
 //
 void mainWindow::on_indexBackButton_clicked(ustring indexName)
 {
-	IndexPage *pIndexPage = get_index_page(indexName);
+	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(indexName, NotebookPageBox::INDEX_PAGE));
 	if (pIndexPage != NULL)
 	{
 		if (pIndexPage->getFirstDocument() >= m_maxDocsCount)
@@ -2159,7 +2337,7 @@
 //
 void mainWindow::on_indexForwardButton_clicked(ustring indexName)
 {
-	IndexPage *pIndexPage = get_index_page(indexName);
+	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(indexName, NotebookPageBox::INDEX_PAGE));
 	if (pIndexPage != NULL)
 	{
 		if (pIndexPage->getDocumentsCount() == 0)
@@ -2190,31 +2368,6 @@
 }
 
 //
-// Notebook page switch
-//
-void mainWindow::on_mainNotebook_switch_page(GtkNotebookPage *p0, guint p1)
-{
-#ifdef DEBUG
-	cout << "mainWindow::on_mainNotebook_switch_page: switched to page " << p1 << endl;
-#endif
-	if (m_state.m_currentPage != (int)p1)
-	{
-		// Disable the widgets that depend on what page is selected
-		// Results
-		clearresults1->set_sensitive(false);
-		viewresults1->set_sensitive(false);
-		viewcache1->set_sensitive(false);
-		indexresults1->set_sensitive(false);
-		// Index
-		viewfromindex1->set_sensitive(false);
-		refreshindex1->set_sensitive(false);
-		showfromindex1->set_sensitive(false);
-		unindex1->set_sensitive(false);
-	}
-	m_state.m_currentPage = (int)p1;
-}
-
-//
 // Main window deleted
 //
 bool mainWindow::on_mainWindow_delete_event(GdkEventAny *ev)
@@ -2263,79 +2416,56 @@
 }
 
 //
-// Returns the IndexPage for the index that has the focus.
+// Returns the page that has the focus.
 //
-IndexPage *mainWindow::get_index_page_with_focus(bool checkTree)
+NotebookPageBox *mainWindow::get_page_with_focus(void)
 {
-	IndexPage *pIndexPage = NULL;
+	NotebookPageBox *pNotebookPage = NULL;
 
 	if (m_state.readLock(7) == true)
 	{
-		for (int pageNum = 0; pageNum < mainNotebook->get_n_pages(); ++pageNum)
+		if (m_state.m_currentPage >= 0)
 		{
-			Widget *pPage = mainNotebook->get_nth_page(pageNum);
+			Widget *pPage = m_pNotebook->get_nth_page(m_state.m_currentPage);
 			if (pPage != NULL)
 			{
-				pIndexPage = dynamic_cast<IndexPage*>(pPage);
-				if (pIndexPage != NULL)
-				{
-#ifdef DEBUG
-					cout << "mainWindow::get_index_page_with_focus: " << pIndexPage->getIndexName() << endl;
-#endif
-					if (checkTree == false)
-					{
-						if (pIndexPage->is_focus() == true)
-						{
-							break;
-						}
-					}
-					else
-					{
-						IndexTree *pIndexTree = pIndexPage->getTree();
-						if ((pIndexTree != NULL) &&
-							(pIndexTree->is_focus() == true))
-						{
-							break;
-						}
-					}
-					pIndexPage = NULL;
-				}
+				pNotebookPage = dynamic_cast<NotebookPageBox*>(pPage);
 			}
 		}
 
 		m_state.unlock();
 	}
 
-	return pIndexPage;
+	return pNotebookPage;
 }
 
 //
-// Returns the IndexPage for the given index.
+// Returns the page with the given title.
 //
-IndexPage *mainWindow::get_index_page(const ustring &indexName)
+NotebookPageBox *mainWindow::get_page(const ustring &title, NotebookPageBox::PageType type)
 {
-	IndexPage *pIndexPage = NULL;
+	NotebookPageBox *pNotebookPage = NULL;
 
 	if (m_state.readLock(8) == true)
 	{
-		for (int pageNum = 0; pageNum < mainNotebook->get_n_pages(); ++pageNum)
+		for (int pageNum = 0; pageNum < m_pNotebook->get_n_pages(); ++pageNum)
 		{
-			Widget *pPage = mainNotebook->get_nth_page(pageNum);
+			Widget *pPage = m_pNotebook->get_nth_page(pageNum);
 			if (pPage != NULL)
 			{
-				pIndexPage = dynamic_cast<IndexPage*>(pPage);
-				if (pIndexPage != NULL)
+				pNotebookPage = dynamic_cast<NotebookPageBox*>(pPage);
+				if (pNotebookPage != NULL)
 				{
 #ifdef DEBUG
-					cout << "mainWindow::get_index_page: " << pIndexPage->getIndexName() << endl;
+					cout << "mainWindow::get_page: " << pNotebookPage->getTitle() << endl;
 #endif
-					// It's an index page, check the name of the index
-					if (indexName == pIndexPage->getIndexName())
+					if ((title == pNotebookPage->getTitle()) &&
+						(type == pNotebookPage->getType()))
 					{
 						// That's the page we are looking for
 						break;
 					}
-					pIndexPage = NULL;
+					pNotebookPage = NULL;
 				}
 			}
 		}
@@ -2343,31 +2473,31 @@
 		m_state.unlock();
 	}
 
-	return pIndexPage;
+	return pNotebookPage;
 }
 
 //
-// Returns the page number for the given index.
+// Returns the page number with the given title.
 //
-int mainWindow::get_index_page_number(const ustring &indexName)
+int mainWindow::get_page_number(const ustring &title, NotebookPageBox::PageType type)
 {
 	int pageNumber = -1;
 
 	if (m_state.readLock(9) == true)
 	{
-		for (int pageNum = 0; pageNum < mainNotebook->get_n_pages(); ++pageNum)
+		for (int pageNum = 0; pageNum < m_pNotebook->get_n_pages(); ++pageNum)
 		{
-			Widget *pPage = mainNotebook->get_nth_page(pageNum);
+			Widget *pPage = m_pNotebook->get_nth_page(pageNum);
 			if (pPage != NULL)
 			{
-				IndexPage *pIndexPage = dynamic_cast<IndexPage*>(pPage);
-				if (pIndexPage != NULL)
+				NotebookPageBox *pNotebookPage = dynamic_cast<NotebookPageBox*>(pPage);
+				if (pNotebookPage != NULL)
 				{
 #ifdef DEBUG
-					cout << "mainWindow::get_index_page_number: " << pIndexPage->getIndexName() << endl;
+					cout << "mainWindow::get_page_number: " << pNotebookPage->getTitle() << endl;
 #endif
-					// It's an index page, check the name of the index
-					if (indexName == pIndexPage->getIndexName())
+					if ((title == pNotebookPage->getTitle()) &&
+						(type == pNotebookPage->getType()))
 					{
 						// That's the page we are looking for
 						pageNumber = pageNum;
@@ -2668,7 +2798,7 @@
 	}
 	m_state.m_browsingIndex = true;
 
-	IndexPage *pIndexPage = get_index_page(indexName);
+	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(indexName, NotebookPageBox::INDEX_PAGE));
 	if (pIndexPage != NULL)
 	{
 		IndexTree *pIndexTree = pIndexPage->getTree();
@@ -2681,7 +2811,7 @@
 		pIndexPage->setDocumentsCount(0);
 
 		// Switch to that index page
-		mainNotebook->set_current_page(get_index_page_number(indexName));
+		m_pNotebook->set_current_page(get_page_number(indexName, NotebookPageBox::INDEX_PAGE));
 	}
 
 	if (indexName == _("My Documents"))
@@ -2779,9 +2909,6 @@
 		set_status(_("No URL to browse"));
 		return false;
 	}
-#ifdef DEBUG
-	cout << "mainWindow::view_document: URL is " << url << endl;
-#endif
 
 	// Is browsing enabled ?
 	if ((internalViewerOnly == false) &&
@@ -2820,13 +2947,46 @@
 		}
 		else
 		{
-			// Display the URL in the View tab
-			mainNotebook->set_current_page(1);
-			if (m_pHtmlView->renderUrl(url) == true)
+			ViewPage *pViewPage = NULL;
+			ustring viewName = _("View");
+			int pageNum = -1;
+
+			// Is there already a page for this index ?
+			pViewPage = dynamic_cast<ViewPage*>(get_page(viewName, NotebookPageBox::VIEW_PAGE));
+			if (pViewPage != NULL)
 			{
-				//viewstop1->set_sensitive(true);
+				pageNum = get_page_number(viewName, NotebookPageBox::VIEW_PAGE);
 			}
-			set_status(locale_to_utf8(m_pHtmlView->getLocation()));
+			else
+			{
+				NotebookTabBox *pTab = manage(new NotebookTabBox(viewName,
+					NotebookPageBox::VIEW_PAGE));
+				pTab->getCloseSignal().connect(
+					SigC::slot(*this, &mainWindow::on_close_page));
+
+				// Position everything
+				pViewPage = manage(new ViewPage(viewName, m_pHtmlView, m_settings));
+
+				// Append the page
+				if (m_state.writeLock(1) == true)
+				{
+					pageNum = m_pNotebook->append_page(*pViewPage, *pTab);
+					m_pNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
+
+					m_state.unlock();
+				}
+			}
+
+			if (pageNum >= 0)
+			{
+				// Display the URL
+				m_pNotebook->set_current_page(pageNum);
+				if (m_pHtmlView->renderUrl(url) == true)
+				{
+					//viewstop1->set_sensitive(true);
+				}
+				set_status(locale_to_utf8(m_pHtmlView->getLocation()));
+			}
 		}
 	}
 

Modified: trunk/UI/GTK2/src/mainWindow.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow.hh	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/mainWindow.hh	2005-12-29 14:09:35 UTC (rev 29)
@@ -25,6 +25,7 @@
 #include <gdkmm/pixbuf.h>
 #include <gdkmm/color.h>
 #include <gtkmm/rc.h>
+#include <gtkmm/notebook.h>
 #include <gtkmm/liststore.h>
 #include <gtkmm/treestore.h>
 #include <gtkmm/treeselection.h>
@@ -38,9 +39,8 @@
 #include "QueryProperties.h"
 #include "EnginesTree.h"
 #include "HtmlView.h"
-#include "IndexPage.h"
 #include "ModelColumns.h"
-#include "NotebookTabBox.h"
+#include "Notebook.h"
 #include "PinotSettings.h"
 #include "ResultsTree.h"
 #include "WorkerThreads.h"
@@ -61,11 +61,12 @@
 	// Handlers
 	void on_enginesTreeviewSelection_changed();
 	void on_queryTreeviewSelection_changed();
-	void on_resultsTreeviewSelection_changed();
+	void on_resultsTreeviewSelection_changed(Glib::ustring queryName);
 	void on_indexTreeviewSelection_changed(Glib::ustring indexName);
 	void on_index_changed(Glib::ustring indexName);
 	void on_label_changed(Glib::ustring indexName, Glib::ustring labelName);
-	void on_page_closed(Glib::ustring title, NotebookTabBox::PageType type);
+	void on_switch_page(GtkNotebookPage *p0, guint p1);
+	void on_close_page(Glib::ustring title, NotebookPageBox::PageType type);
 	void on_thread_end();
 	void on_editindex(Glib::ustring indexName, Glib::ustring location);
 	void on_message_reception(DocumentInfo docInfo, std::string labelName);
@@ -109,13 +110,14 @@
 	virtual void on_indexForwardButton_clicked(Glib::ustring indexName);
 
 	virtual bool on_queryTreeview_button_press_event(GdkEventButton *ev);
-	virtual void on_mainNotebook_switch_page(GtkNotebookPage *p0, guint p1);
 	virtual bool on_mainWindow_delete_event(GdkEventAny *ev);
 
 	// Action methods
-	IndexPage *get_index_page_with_focus(bool checkTree);
-	IndexPage *get_index_page(const Glib::ustring &indexName);
-	int get_index_page_number(const Glib::ustring &indexName);
+	NotebookPageBox *get_page_with_focus(void);
+	NotebookPageBox *get_page(const Glib::ustring &title,
+		NotebookPageBox::PageType type);
+	int get_page_number(const Glib::ustring &title,
+		NotebookPageBox::PageType type);
 	bool queue_index(const DocumentInfo &docInfo, const std::string &labelName,
 		unsigned int docId = 0);
 	bool queue_unindex(set<unsigned int> &docIdList);
@@ -144,8 +146,8 @@
 	// Query
 	QueryModelColumns m_queryColumns;
 	Glib::RefPtr<Gtk::ListStore> m_refQueryTree;
-	// Results
-	ResultsTree *m_pResultsTree;
+	// Notebook
+	Gtk::Notebook *m_pNotebook;
 	// Index
 	Gtk::Menu *m_pIndexMenu;
 	Gtk::Menu *m_pLabelsMenu;

Modified: trunk/UI/GTK2/src/mainWindow_glade.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-29 14:09:35 UTC (rev 29)
@@ -1,4 +1,4 @@
-// generated 2005/12/29 0:33:08 SGT by fabrice at thorgrim.dyndns.org.(none)
+// generated 2005/12/29 5:49:01 SGT by fabrice at thorgrim.dyndns.org.(none)
 // using glademm V2.6.0
 //
 // DO NOT EDIT THIS FILE ! It was created using
@@ -71,14 +71,14 @@
    delete1 = NULL;
    Gtk::Menu *editMenuitem_menu = Gtk::manage(new class Gtk::Menu());
    editMenuitem = NULL;
-   Gtk::Image *image530 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-clear"), Gtk::IconSize(1)));
+   Gtk::Image *image546 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-clear"), Gtk::IconSize(1)));
    clearresults1 = NULL;
    showextract1 = NULL;
    searchenginegroup1 = NULL;
    Gtk::RadioMenuItem::Group _RadioMIGroup_searchenginegroup1;
    hostnamegroup1 = NULL;
    Gtk::Menu *groupresults1_menu = Gtk::manage(new class Gtk::Menu());
-   Gtk::MenuItem *groupresults1 = NULL;
+   groupresults1 = NULL;
    Gtk::MenuItem *separator1 = NULL;
    viewresults1 = NULL;
    viewcache1 = NULL;
@@ -86,15 +86,15 @@
    Gtk::Menu *resultsMenuitem_menu = Gtk::manage(new class Gtk::Menu());
    resultsMenuitem = NULL;
    list1 = NULL;
-   Gtk::Image *image531 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-open"), Gtk::IconSize(1)));
+   Gtk::Image *image547 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-open"), Gtk::IconSize(1)));
    import1 = NULL;
    Gtk::MenuItem *separator3 = NULL;
    viewfromindex1 = NULL;
-   Gtk::Image *image532 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-refresh"), Gtk::IconSize(1)));
+   Gtk::Image *image548 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-refresh"), Gtk::IconSize(1)));
    refreshindex1 = NULL;
-   Gtk::Image *image533 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-delete"), Gtk::IconSize(1)));
+   Gtk::Image *image549 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-delete"), Gtk::IconSize(1)));
    unindex1 = NULL;
-   Gtk::Image *image534 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-properties"), Gtk::IconSize(1)));
+   Gtk::Image *image550 = Gtk::manage(new class Gtk::Image(Gtk::StockID("gtk-properties"), Gtk::IconSize(1)));
    showfromindex1 = NULL;
    Gtk::Menu *indexMenuitem_menu = Gtk::manage(new class Gtk::Menu());
    indexMenuitem = NULL;
@@ -139,15 +139,7 @@
 #else //
    queryExpander = Gtk::manage(new class Gtk::HandleBox());
 #endif //
-   resultsVbox = Gtk::manage(new class Gtk::VBox(false, 0));
-   
-   Gtk::Label *resultsLabel = Gtk::manage(new class Gtk::Label(_("Results")));
-   viewVbox = Gtk::manage(new class Gtk::VBox(false, 0));
-   
-   Gtk::Label *viewLabel = Gtk::manage(new class Gtk::Label(_("View")));
-   mainNotebook = Gtk::manage(new class Gtk::Notebook());
-   
-   Gtk::VBox *rightVbox = Gtk::manage(new class Gtk::VBox(false, 0));
+   rightVbox = Gtk::manage(new class Gtk::VBox(false, 0));
    mainHpaned = Gtk::manage(new class Gtk::HPaned());
    mainProgressbar = Gtk::manage(new class Gtk::ProgressBar());
    mainStatusbar = Gtk::manage(new class Gtk::Statusbar());
@@ -182,7 +174,7 @@
    groupresults1_menu->items().push_back(Gtk::Menu_Helpers::RadioMenuElem(_RadioMIGroup_searchenginegroup1, _("Host Name")));
    hostnamegroup1 = (Gtk::RadioMenuItem *)&groupresults1_menu->items().back();
    
-   resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Clear List"), *image530));
+   resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Clear List"), *image546));
    clearresults1 = (Gtk::ImageMenuItem *)&resultsMenuitem_menu->items().back();
    
    resultsMenuitem_menu->items().push_back(Gtk::Menu_Helpers::CheckMenuElem(_("Show Extract")));
@@ -206,7 +198,7 @@
    indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("List Contents Of")));
    list1 = (Gtk::MenuItem *)&indexMenuitem_menu->items().back();
    
-   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Import"), *image531));
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Import"), *image547));
    import1 = (Gtk::ImageMenuItem *)&indexMenuitem_menu->items().back();
    
    indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::SeparatorElem());
@@ -215,13 +207,13 @@
    indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("View")));
    viewfromindex1 = (Gtk::MenuItem *)&indexMenuitem_menu->items().back();
    
-   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Update"), *image532));
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Update"), *image548));
    refreshindex1 = (Gtk::ImageMenuItem *)&indexMenuitem_menu->items().back();
    
-   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Unindex"), *image533));
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Unindex"), *image549));
    unindex1 = (Gtk::ImageMenuItem *)&indexMenuitem_menu->items().back();
    
-   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Properties"), *image534));
+   indexMenuitem_menu->items().push_back(Gtk::Menu_Helpers::ImageMenuElem(_("Properties"), *image550));
    showfromindex1 = (Gtk::ImageMenuItem *)&indexMenuitem_menu->items().back();
    
    helpMenuitem_menu->items().push_back(Gtk::Menu_Helpers::MenuElem(_("_About")));
@@ -241,19 +233,19 @@
    
    mainMenubar->items().push_back(Gtk::Menu_Helpers::MenuElem(_("_Help"), *helpMenuitem_menu));
    helpMenuitem = (Gtk::MenuItem *)&mainMenubar->items().back();
-   image530->set_alignment(0.5,0.5);
-   image530->set_padding(0,0);
+   image546->set_alignment(0.5,0.5);
+   image546->set_padding(0,0);
    showextract1->set_active(true);
    searchenginegroup1->set_active(true);
    hostnamegroup1->set_active(false);
-   image531->set_alignment(0.5,0.5);
-   image531->set_padding(0,0);
-   image532->set_alignment(0.5,0.5);
-   image532->set_padding(0,0);
-   image533->set_alignment(0.5,0.5);
-   image533->set_padding(0,0);
-   image534->set_alignment(0.5,0.5);
-   image534->set_padding(0,0);
+   image547->set_alignment(0.5,0.5);
+   image547->set_padding(0,0);
+   image548->set_alignment(0.5,0.5);
+   image548->set_padding(0,0);
+   image549->set_alignment(0.5,0.5);
+   image549->set_padding(0,0);
+   image550->set_alignment(0.5,0.5);
+   image550->set_padding(0,0);
    image439->set_alignment(0.5,0.5);
    image439->set_padding(0,0);
    addIndexButton->set_flags(Gtk::CAN_FOCUS);
@@ -350,30 +342,8 @@
 #if GTKMM_MAJOR_VERSION==2 && GTKMM_MINOR_VERSION>2
    queryExpander->set_label_widget(*queryLabel);
 #endif //
-   resultsLabel->set_alignment(0.5,0.5);
-   resultsLabel->set_padding(0,0);
-   resultsLabel->set_justify(Gtk::JUSTIFY_LEFT);
-   resultsLabel->set_line_wrap(false);
-   resultsLabel->set_use_markup(false);
-   resultsLabel->set_selectable(false);
-   viewLabel->set_alignment(0.5,0.5);
-   viewLabel->set_padding(0,0);
-   viewLabel->set_justify(Gtk::JUSTIFY_LEFT);
-   viewLabel->set_line_wrap(false);
-   viewLabel->set_use_markup(false);
-   viewLabel->set_selectable(false);
-   mainNotebook->set_flags(Gtk::CAN_FOCUS);
-   mainNotebook->set_show_tabs(true);
-   mainNotebook->set_show_border(true);
-   mainNotebook->set_tab_pos(Gtk::POS_TOP);
-   mainNotebook->set_scrollable(false);
-   mainNotebook->append_page(*resultsVbox, *resultsLabel);
-   mainNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
-   mainNotebook->append_page(*viewVbox, *viewLabel);
-   mainNotebook->pages().back().set_tab_label_packing(false, true, Gtk::PACK_START);
    rightVbox->pack_start(*liveQueryHbox, Gtk::PACK_SHRINK, 0);
    rightVbox->pack_start(*queryExpander, Gtk::PACK_SHRINK, 0);
-   rightVbox->pack_start(*mainNotebook, Gtk::PACK_EXPAND_WIDGET, 4);
    mainHpaned->set_flags(Gtk::CAN_FOCUS);
    mainHpaned->set_position(105);
    mainHpaned->pack1(*leftVbox, Gtk::SHRINK);
@@ -400,7 +370,7 @@
    paste1->show();
    delete1->show();
    editMenuitem->show();
-   image530->show();
+   image546->show();
    clearresults1->show();
    showextract1->show();
    searchenginegroup1->show();
@@ -412,15 +382,15 @@
    indexresults1->show();
    resultsMenuitem->show();
    list1->show();
-   image531->show();
+   image547->show();
    import1->show();
    separator3->show();
    viewfromindex1->show();
-   image532->show();
+   image548->show();
    refreshindex1->show();
-   image533->show();
+   image549->show();
    unindex1->show();
-   image534->show();
+   image550->show();
    showfromindex1->show();
    indexMenuitem->show();
    about1->show();
@@ -452,11 +422,6 @@
    queryHbox->show();
    queryLabel->show();
    queryExpander->show();
-   resultsVbox->show();
-   resultsLabel->show();
-   viewVbox->show();
-   viewLabel->show();
-   mainNotebook->show();
    rightVbox->show();
    mainHpaned->show();
    mainProgressbar->show();
@@ -490,7 +455,6 @@
    editQueryButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_editQueryButton_clicked), false);
    removeQueryButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_removeQueryButton_clicked), false);
    findQueryButton->signal_clicked().connect(SigC::slot(*this, &mainWindow_glade::on_findQueryButton_clicked), false);
-   mainNotebook->signal_switch_page().connect(SigC::slot(*this, &mainWindow_glade::on_mainNotebook_switch_page), false);
    mainWindow->signal_delete_event().connect(SigC::slot(*this, &mainWindow_glade::on_mainWindow_delete_event), false);
 }
 

Modified: trunk/UI/GTK2/src/mainWindow_glade.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.hh	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/GTK2/src/mainWindow_glade.hh	2005-12-29 14:09:35 UTC (rev 29)
@@ -1,4 +1,4 @@
-// generated 2005/12/29 0:33:08 SGT by fabrice at thorgrim.dyndns.org.(none)
+// generated 2005/12/29 5:49:01 SGT by fabrice at thorgrim.dyndns.org.(none)
 // using glademm V2.6.0
 //
 // DO NOT EDIT THIS FILE ! It was created using
@@ -45,7 +45,6 @@
 #else //
 #include <gtkmm/handlebox.h>
 #endif //
-#include <gtkmm/notebook.h>
 #include <gtkmm/paned.h>
 #include <gtkmm/progressbar.h>
 #include <gtkmm/statusbar.h>
@@ -70,6 +69,7 @@
         class Gtk::CheckMenuItem * showextract1;
         class Gtk::RadioMenuItem * searchenginegroup1;
         class Gtk::RadioMenuItem * hostnamegroup1;
+        class Gtk::MenuItem * groupresults1;
         class Gtk::MenuItem * viewresults1;
         class Gtk::MenuItem * viewcache1;
         class Gtk::MenuItem * indexresults1;
@@ -98,9 +98,7 @@
 #else //
         class Gtk::HandleBox * queryExpander;
 #endif //
-        class Gtk::VBox * resultsVbox;
-        class Gtk::VBox * viewVbox;
-        class Gtk::Notebook * mainNotebook;
+        class Gtk::VBox * rightVbox;
         class Gtk::HPaned * mainHpaned;
         class Gtk::ProgressBar * mainProgressbar;
         class Gtk::Statusbar * mainStatusbar;
@@ -135,7 +133,6 @@
         virtual void on_editQueryButton_clicked() = 0;
         virtual void on_removeQueryButton_clicked() = 0;
         virtual void on_findQueryButton_clicked() = 0;
-        virtual void on_mainNotebook_switch_page(GtkNotebookPage *p0, guint p1) = 0;
         virtual bool on_mainWindow_delete_event(GdkEventAny *ev) = 0;
 };
 #endif

Modified: trunk/UI/RenderHTML/MozillaRenderer.cpp
===================================================================
--- trunk/UI/RenderHTML/MozillaRenderer.cpp	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/RenderHTML/MozillaRenderer.cpp	2005-12-29 14:09:35 UTC (rev 29)
@@ -76,7 +76,7 @@
 }
 
 /// Returns the GTK widget.
-GtkWidget *MozillaRenderer::getWidget(void)
+GtkWidget *MozillaRenderer::getObject(void)
 {
 	return m_htmlWidget;
 }

Modified: trunk/UI/RenderHTML/MozillaRenderer.h
===================================================================
--- trunk/UI/RenderHTML/MozillaRenderer.h	2005-12-29 09:00:55 UTC (rev 28)
+++ trunk/UI/RenderHTML/MozillaRenderer.h	2005-12-29 14:09:35 UTC (rev 29)
@@ -38,9 +38,6 @@
 		/// Shutdowns the renderer.
 		static void shutdown(void);
 
-		/// Returns the GTK widget.
-		GtkWidget *getWidget(void);
-
 		/// Renders HTML held in a buffer.
 		bool renderData(const char *data, unsigned int length, const string &baseUrl);
 
@@ -75,6 +72,9 @@
 		GtkWidget *m_htmlWidget;
 		bool m_rendering;
 
+		/// Returns the GTK widget.
+		GtkWidget *getObject(void);
+
 	private:
 		MozillaRenderer(const MozillaRenderer &other);
 		MozillaRenderer &operator=(const MozillaRenderer &other);



From fabricecolin at berlios.de  Thu Dec 29 22:30:54 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Thu, 29 Dec 2005 22:30:54 +0100
Subject: [Pinot-svn] r30 - trunk/UI/GTK2/src
Message-ID: <200512292130.jBTLUs7p003159@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-29 22:30:54 +0100 (Thu, 29 Dec 2005)
New Revision: 30

Modified:
   trunk/UI/GTK2/src/HtmlView.cpp
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/mainWindow.hh
Log:
Hide, don't close the view tab. Fixed document update.


Modified: trunk/UI/GTK2/src/HtmlView.cpp
===================================================================
--- trunk/UI/GTK2/src/HtmlView.cpp	2005-12-29 14:09:35 UTC (rev 29)
+++ trunk/UI/GTK2/src/HtmlView.cpp	2005-12-29 21:30:54 UTC (rev 30)
@@ -28,6 +28,7 @@
 
 HtmlView::HtmlView(Menu *pPopupMenu) :
 	MozillaRenderer(),
+	SigC::Object(),
 	m_pPopupMenu(pPopupMenu),
 	m_pDocHtmlView(NULL)
 {
@@ -49,6 +50,10 @@
 
 HtmlView::~HtmlView()
 {
+	if (m_pDocHtmlView != NULL)
+	{
+		delete m_pDocHtmlView;
+	}
 }
 
 //

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-29 14:09:35 UTC (rev 29)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-29 21:30:54 UTC (rev 30)
@@ -708,10 +708,17 @@
 	{
 		if (type == NotebookPageBox::VIEW_PAGE)
 		{
+			// Stop rendering
 			m_pHtmlView->stop();
+
+			// Hide, don't close the page
+			Widget *pPage = m_pNotebook->get_nth_page(pageNum);
+			if (pPage != NULL)
+			{
+				pPage->hide();
+			}
 		}
-
-		if (m_state.writeLock(2) == true)
+		else if (m_state.writeLock(2) == true)
 		{
 			// Remove the page
 			m_pNotebook->remove_page(pageNum);
@@ -1482,7 +1489,7 @@
 	else
 	{
 		// The focus may be on one of the notebook pages
-		NotebookPageBox *pNotebookPage = get_page_with_focus();
+		NotebookPageBox *pNotebookPage = get_current_page();
 		if (pNotebookPage != NULL)
 		{
 			ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
@@ -1611,7 +1618,7 @@
 	}
 	else
 	{
-		NotebookPageBox *pNotebookPage = get_page_with_focus();
+		NotebookPageBox *pNotebookPage = get_current_page();
 		if (pNotebookPage != NULL)
 		{
 			ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
@@ -1638,7 +1645,7 @@
 //
 void mainWindow::on_clearresults_activate()
 {
-	NotebookPageBox *pNotebookPage = get_page_with_focus();
+	NotebookPageBox *pNotebookPage = get_current_page();
 	if (pNotebookPage != NULL)
 	{
 		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
@@ -1659,7 +1666,7 @@
 //
 void mainWindow::on_showextract_activate()
 {
-	NotebookPageBox *pNotebookPage = get_page_with_focus();
+	NotebookPageBox *pNotebookPage = get_current_page();
 	if (pNotebookPage != NULL)
 	{
 		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
@@ -1682,7 +1689,7 @@
 	ResultsModelColumns::ResultType currentType, newType;
 
 	// What's the new grouping criteria ?
-	NotebookPageBox *pNotebookPage = get_page_with_focus();
+	NotebookPageBox *pNotebookPage = get_current_page();
 	if (pNotebookPage != NULL)
 	{
 		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
@@ -1702,7 +1709,7 @@
 //
 void mainWindow::on_viewresults_activate()
 {
-	NotebookPageBox *pNotebookPage = get_page_with_focus();
+	NotebookPageBox *pNotebookPage = get_current_page();
 	if (pNotebookPage != NULL)
 	{
 		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
@@ -1727,7 +1734,7 @@
 //
 void mainWindow::on_viewcache_activate()
 {
-	NotebookPageBox *pNotebookPage = get_page_with_focus();
+	NotebookPageBox *pNotebookPage = get_current_page();
 	if (pNotebookPage != NULL)
 	{
 		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
@@ -1761,7 +1768,7 @@
 		return;
 	}
 
-	NotebookPageBox *pNotebookPage = get_page_with_focus();
+	NotebookPageBox *pNotebookPage = get_current_page();
 	if (pNotebookPage != NULL)
 	{
 		ResultsPage *pResultsPage = dynamic_cast<ResultsPage*>(pNotebookPage);
@@ -1814,7 +1821,7 @@
 //
 void mainWindow::on_viewfromindex_activate()
 {
-	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page_with_focus());
+	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_current_page());
 	if (pIndexPage != NULL)
 	{
 		IndexTree *pIndexTree = pIndexPage->getTree();
@@ -1843,7 +1850,7 @@
 	}
 
 	// Get the current documents selection
-	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page_with_focus());
+	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_current_page());
 	if (pIndexPage != NULL)
 	{
 		IndexTree *pIndexTree = pIndexPage->getTree();
@@ -1862,28 +1869,28 @@
 	for (vector<IndexedDocument>::const_iterator docIter = documentsList.begin();
 		docIter != documentsList.end(); ++docIter)
 	{
-		// The URL to download, ie the original location of the document
-		string url = docIter->getOriginalLocation();
-		if (url.empty() == true)
+		// The document ID
+		unsigned int docId = docIter->getID();
+		if (docId == 0)
 		{
 			continue;
 		}
 
-		// The document ID
-		unsigned int docId = docIter->getID();
-		if (docId == 0)
+		// The URL to download, ie the original location of the document
+		string url = docIter->getOriginalLocation();
+		if (url.empty() == true)
 		{
 			continue;
 		}
-
-		// The title
-		string title = docIter->getTitle();
 #ifdef DEBUG
 		cout << "mainWindow::on_refreshindex_activate: URL is " << url << endl;
 #endif
 
 		// Add this action to the queue
-		queue_index(*docIter, "", docId);
+		DocumentInfo docInfo(docIter->getTitle(), url,
+			docIter->getType(), docIter->getLanguage());
+		docInfo.setTimestamp(docIter->getTimestamp());
+		queue_index(docInfo, "", docId);
 	}
 }
 
@@ -1904,7 +1911,7 @@
 	cout << "mainWindow::on_showfromindex_activate: called" << endl;
 #endif
 	IndexTree *pIndexTree = NULL;
-	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page_with_focus());
+	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_current_page());
 	if (pIndexPage != NULL)
 	{
 		indexName = locale_from_utf8(pIndexPage->getTitle());
@@ -2035,7 +2042,7 @@
 	ustring boxTitle = _("Delete this document from the index ?");
 
 	IndexTree *pIndexTree = NULL;
-	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page_with_focus());
+	IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_current_page());
 	if (pIndexPage != NULL)
 	{
 		pIndexTree = pIndexPage->getTree();
@@ -2416,21 +2423,18 @@
 }
 
 //
-// Returns the page that has the focus.
+// Returns the current page.
 //
-NotebookPageBox *mainWindow::get_page_with_focus(void)
+NotebookPageBox *mainWindow::get_current_page(void)
 {
 	NotebookPageBox *pNotebookPage = NULL;
 
 	if (m_state.readLock(7) == true)
 	{
-		if (m_state.m_currentPage >= 0)
+		Widget *pPage = m_pNotebook->get_nth_page(m_pNotebook->get_current_page());
+		if (pPage != NULL)
 		{
-			Widget *pPage = m_pNotebook->get_nth_page(m_state.m_currentPage);
-			if (pPage != NULL)
-			{
-				pNotebookPage = dynamic_cast<NotebookPageBox*>(pPage);
-			}
+			pNotebookPage = dynamic_cast<NotebookPageBox*>(pPage);
 		}
 
 		m_state.unlock();
@@ -2477,7 +2481,7 @@
 }
 
 //
-// Returns the page number with the given title.
+// Returns the number of the page with the given title.
 //
 int mainWindow::get_page_number(const ustring &title, NotebookPageBox::PageType type)
 {
@@ -2956,6 +2960,9 @@
 			if (pViewPage != NULL)
 			{
 				pageNum = get_page_number(viewName, NotebookPageBox::VIEW_PAGE);
+				// The page may be hidden
+				pViewPage->show();
+				// FIXME: move the page
 			}
 			else
 			{

Modified: trunk/UI/GTK2/src/mainWindow.hh
===================================================================
--- trunk/UI/GTK2/src/mainWindow.hh	2005-12-29 14:09:35 UTC (rev 29)
+++ trunk/UI/GTK2/src/mainWindow.hh	2005-12-29 21:30:54 UTC (rev 30)
@@ -113,7 +113,7 @@
 	virtual bool on_mainWindow_delete_event(GdkEventAny *ev);
 
 	// Action methods
-	NotebookPageBox *get_page_with_focus(void);
+	NotebookPageBox *get_current_page(void);
 	NotebookPageBox *get_page(const Glib::ustring &title,
 		NotebookPageBox::PageType type);
 	int get_page_number(const Glib::ustring &title,



From fabricecolin at berlios.de  Fri Dec 30 13:11:44 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 30 Dec 2005 13:11:44 +0100
Subject: [Pinot-svn] r31 - trunk/UI/GTK2/src
Message-ID: <200512301211.jBUCBibD032051@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-30 13:11:43 +0100 (Fri, 30 Dec 2005)
New Revision: 31

Added:
   trunk/UI/GTK2/src/pinot.cc
Removed:
   trunk/UI/GTK2/src/pinot.cpp
Modified:
   trunk/UI/GTK2/src/Makefile
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/mainWindow.cc
Log:
Sorted out issues with menuitems and view tab. Inform user if document to index
is already indexed. In the results tree, don't repeat the name of the query for
every group. Catch signals and quit cleanly.


Modified: trunk/UI/GTK2/src/Makefile
===================================================================
--- trunk/UI/GTK2/src/Makefile	2005-12-29 21:30:54 UTC (rev 30)
+++ trunk/UI/GTK2/src/Makefile	2005-12-30 12:11:43 UTC (rev 31)
@@ -12,8 +12,9 @@
 	prefsDialog.cc prefsDialog_glade.cc \
 	propertiesDialog.cc propertiesDialog_glade.cc \
 	queryDialog.cc queryDialog_glade.cc \
-	mainWindow.cc mainWindow_glade.cc
-UI_SRCS = pinot.cpp EnginesTree.cpp IndexPage.cpp IndexTree.cpp \
+	mainWindow.cc mainWindow_glade.cc \
+	pinot.cc
+UI_SRCS = EnginesTree.cpp IndexPage.cpp IndexTree.cpp \
 	HtmlView.cpp ModelColumns.cpp MonitorHandler.cpp Notebook.cpp \
 	PinotSettings.cpp PinotUtils.cpp ResultsTree.cpp WorkerThreads.cpp
 UI_GTK2_OBJS := $(patsubst %.cc,${OBJ_DIR}/%.o,${UI_GTK2_SRCS})

Modified: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-29 21:30:54 UTC (rev 30)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-30 12:11:43 UTC (rev 31)
@@ -405,14 +405,6 @@
 	// Unselect all
 	get_selection()->unselect_all();
 
-	// This describes the query
-	string queryDetails = "\"";
-	queryDetails += queryName;
-	queryDetails += "\" ";
-	queryDetails += _("on");
-	queryDetails += " ";
-	queryDetails += registeredEngineName;
-
 	// What's the grouping criteria ?
 	if (groupBySearchEngine == true)
 	{
@@ -479,7 +471,7 @@
 		}
 		else
 		{
-			groupName = queryDetails;
+			groupName = registeredEngineName;
 		}
 
 		// Add the group or get its position if it's already in
@@ -545,7 +537,7 @@
 		{
 			// If this didn't return any result, add an empty group
 			TreeModel::iterator groupIter;
-			appendGroup(queryDetails, rootType, groupIter);
+			appendGroup(registeredEngineName, rootType, groupIter);
 			updateGroup(groupIter);
 
 			return true;
@@ -677,16 +669,9 @@
 						for (set<string>::iterator iter = engineNames.begin(); iter != engineNames.end(); ++iter)
 						{
 							string engineName = (*iter);
-
-							string groupName = "\"";
-							groupName += locale_from_utf8(childRow[m_resultsColumns.m_queryName]);
-							groupName += "\" ";
-							groupName += _("on");
-							groupName += " ";
-							groupName += engineName;
-
 							unsigned int indexId = 0;
 							unsigned int engineId = m_settings.getEngineId(engineName);
+
 							if (engineId == 0)
 							{
 								// This is actually an index, not an engine...
@@ -698,7 +683,7 @@
 							}
 
 							// Add group
-							if (appendGroup(groupName, newType, groupIter) == true)
+							if (appendGroup(engineName, newType, groupIter) == true)
 							{
 								// Add result
 								appendResult(locale_from_utf8(childRow[m_resultsColumns.m_text]), url,

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-29 21:30:54 UTC (rev 30)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-30 12:11:43 UTC (rev 31)
@@ -221,8 +221,8 @@
 	indexresults1->set_sensitive(false);
 	viewfromindex1->set_sensitive(false);
 	refreshindex1->set_sensitive(false);
+	unindex1->set_sensitive(false);
 	showfromindex1->set_sensitive(false);
-	unindex1->set_sensitive(false);
 	//viewstop1->set_sensitive(false);
 	// ...and buttons
 	removeIndexButton->set_sensitive(false);
@@ -545,8 +545,8 @@
 		}
 		viewfromindex1->set_sensitive(canViewDocument);
 		refreshindex1->set_sensitive(isDocumentsIndex);
+		unindex1->set_sensitive(isDocumentsIndex);
 		showfromindex1->set_sensitive(true);
-		unindex1->set_sensitive(isDocumentsIndex);
 
 		// Show the URL in the status bar
 		ustring statusText = _("Document location is");
@@ -559,8 +559,8 @@
 		// No, disable these
 		viewfromindex1->set_sensitive(false);
 		refreshindex1->set_sensitive(false);
+		unindex1->set_sensitive(false);
 		showfromindex1->set_sensitive(false);
-		unindex1->set_sensitive(false);
 	}
 }
 
@@ -673,24 +673,40 @@
 //
 void mainWindow::on_switch_page(GtkNotebookPage *p0, guint p1)
 {
+	// Did the page change ?
+	if (m_state.m_currentPage != p1)
+	{
+		bool showResultsMenuitems = false;
+
+		NotebookPageBox *pNotebookPage = dynamic_cast<NotebookPageBox*>(m_pNotebook->get_nth_page(p1));
+		if (pNotebookPage != NULL)
+		{
+			NotebookPageBox::PageType type = pNotebookPage->getType();
+			if (type == NotebookPageBox::RESULTS_PAGE)
+			{
+				showResultsMenuitems = true;
+			}
 #ifdef DEBUG
-	cout << "mainWindow::on_switch_page: switched to page " << p1 << endl;
+			cout << "mainWindow::on_switch_page: switched to page " << p1
+				<< ", type " << type << endl;
 #endif
-	if (m_state.m_currentPage != (int)p1)
-	{
-		// Disable the widgets that depend on what page is selected
-		// Results
-		clearresults1->set_sensitive(false);
-		showextract1->set_sensitive(false);
-		groupresults1->set_sensitive(false);
+		}
+
+		// Results menuitems that depend on the page
+		clearresults1->set_sensitive(showResultsMenuitems);
+		showextract1->set_sensitive(showResultsMenuitems);
+		groupresults1->set_sensitive(showResultsMenuitems);
+
+		// Results menuitems that depend on selection
 		viewresults1->set_sensitive(false);
 		viewcache1->set_sensitive(false);
 		indexresults1->set_sensitive(false);
-		// Index
+
+		// Index menuitems that depend on selection
 		viewfromindex1->set_sensitive(false);
 		refreshindex1->set_sensitive(false);
+		unindex1->set_sensitive(false);
 		showfromindex1->set_sensitive(false);
-		unindex1->set_sensitive(false);
 	}
 	m_state.m_currentPage = (int)p1;
 }
@@ -913,21 +929,11 @@
 
 		if (pageNum >= 0)
 		{
+			// Add the results to the tree
+			pResultsTree->addResults(queryProps, engineName,
+				resultsList, searchenginegroup1->get_active());
 			// Switch to that page
 			m_pNotebook->set_current_page(pageNum);
-
-			// Add the results to the tree
-			if (pResultsTree->addResults(queryProps, engineName,
-				resultsList, searchenginegroup1->get_active()) == true)
-			{
-#ifdef DEBUG
-				cout << "mainWindow::on_thread_end: added results" << endl;
-#endif
-				// Enable some menuitems
-				clearresults1->set_sensitive(true);
-				showextract1->set_sensitive(false);
-				groupresults1->set_sensitive(false);
-			}
 		}
 
 		// Index results ?
@@ -1421,11 +1427,16 @@
 	// Do the changes affect the View tab ?
 	if (useExternalBrowser != m_settings.m_browseResults)
 	{
-		// Close the existing view page ?
 		if (m_settings.m_browseResults == true)
 		{
+			// Close the existing view page
 			on_close_page(_("View"), NotebookPageBox::VIEW_PAGE);
 		}
+		else
+		{
+			// Reopen the view page
+			view_document("file:///usr/share/pinot/index.html", true);
+		}
 	}
 
 	// Any labels to delete or rename ?
@@ -1628,11 +1639,9 @@
 				cout << "mainWindow::on_delete_activate: results tree" << endl;
 #endif
 				ResultsTree *pResultsTree = pResultsPage->getTree();
-				if ((pResultsTree != NULL) &&
-					(pResultsTree->deleteSelection() == true))
+				if (pResultsTree != NULL)
 				{
-					// The results tree is now empty
-					clearresults1->set_sensitive(false);
+					pResultsTree->deleteSelection();
 				}
 			}
 		}
@@ -1655,7 +1664,6 @@
 			if (pResultsTree != NULL)
 			{
 				pResultsTree->clear();
-				clearresults1->set_sensitive(false);
 			}
 		}
 	}
@@ -1813,7 +1821,7 @@
 		&mainWindow::on_message_import));
 	importBox.show();
 	importBox.run();
-	// Let the signal handler deal with mporting stuff
+	// Let the signal handler deal with importing stuff
 }
 
 //
@@ -2793,8 +2801,6 @@
 //
 void mainWindow::browse_index(const ustring &indexName, unsigned int startDoc)
 {
-	bool enableIndexOps = false;
-
 	// Rudimentary lock
 	if (m_state.m_browsingIndex == true)
 	{
@@ -2818,12 +2824,6 @@
 		m_pNotebook->set_current_page(get_page_number(indexName, NotebookPageBox::INDEX_PAGE));
 	}
 
-	if (indexName == _("My Documents"))
-	{
-		enableIndexOps = true;
-	}
-	import1->set_sensitive(enableIndexOps);
-
 	// Spawn a new thread to browse the index
 	IndexBrowserThread *pBrowseThread = new IndexBrowserThread(
 		locale_from_utf8(indexName), m_maxDocsCount, startDoc);
@@ -2874,9 +2874,6 @@
 				m_state.m_beingIndexed.insert(url);
 				isNewDocument = true;
 			}
-#ifdef DEBUG
-			else cout << "mainWindow::index_document: already indexed " << url << endl;
-#endif
 
 			m_state.unlock();
 		}
@@ -2886,6 +2883,13 @@
 			// This is a new document
 			start_thread(new IndexingThread(docInfo, labelName));
 		}
+		else
+		{
+			ustring status = url;
+			status += " ";
+			status += _("is already indexed or is being indexed");
+			set_status(status);
+		}
 	}
 
 	// If the document is indexed, we may have to update its labels
@@ -2934,7 +2938,7 @@
 			(system(shellCommand.c_str()) == -1))
 		{
 			ustring status = _("Couldn't browse URL:");
-			status == " ";
+			status += " ";
 			status += Glib::strerror(errno);
 			set_status(status);
 		}
@@ -2955,14 +2959,14 @@
 			ustring viewName = _("View");
 			int pageNum = -1;
 
-			// Is there already a page for this index ?
+			// Is there already a view page ?
 			pViewPage = dynamic_cast<ViewPage*>(get_page(viewName, NotebookPageBox::VIEW_PAGE));
 			if (pViewPage != NULL)
 			{
 				pageNum = get_page_number(viewName, NotebookPageBox::VIEW_PAGE);
 				// The page may be hidden
 				pViewPage->show();
-				// FIXME: move the page
+				// FIXME: reorder pages
 			}
 			else
 			{

Copied: trunk/UI/GTK2/src/pinot.cc (from rev 27, trunk/UI/GTK2/src/pinot.cpp)
===================================================================
--- trunk/UI/GTK2/src/pinot.cpp	2005-12-18 10:33:00 UTC (rev 27)
+++ trunk/UI/GTK2/src/pinot.cc	2005-12-30 12:11:43 UTC (rev 31)
@@ -0,0 +1,175 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+#include <libintl.h>
+#include <iostream>
+#include <fstream>
+#include <glibmm.h>
+#include <glibmm/thread.h>
+#include <glibmm/ustring.h>
+#include <glibmm/convert.h>
+#include <gtkmm/main.h>
+
+#include "TokenizerFactory.h"
+#include "Languages.h"
+#include "XapianDatabase.h"
+#include "XapianDatabaseFactory.h"
+#include "ActionHistory.h"
+#include "QueryHistory.h"
+#include "ViewHistory.h"
+#include "NeonDownloader.h"
+#include "MozillaRenderer.h"
+#include "config.h"
+#include "NLS.h"
+#include "PinotSettings.h"
+#include "mainWindow.hh"
+
+using namespace std;
+
+static ofstream outputFile;
+static streambuf *coutBuf = NULL;
+static streambuf *cerrBuf = NULL;
+
+static void closeAll(void)
+{
+	cout << "Exiting..." << endl;
+
+	// Save the settings
+	PinotSettings &settings = PinotSettings::getInstance();
+	if (settings.save() == false)
+	{
+		cerr << _("Couldn't save configuration file") << endl;
+	}
+
+	// Close all indexes we may have opened
+	XapianDatabaseFactory::closeAll();
+
+	// Close the tokenizer libraries
+	TokenizerFactory::unloadTokenizers();
+
+	// Restore the stream buffers
+	if (coutBuf != NULL)
+	{
+		cout.rdbuf(coutBuf);
+	}
+	if (cerrBuf != NULL)
+	{
+		cerr.rdbuf(cerrBuf);
+	}
+	outputFile.close();
+
+	MozillaRenderer::shutdown();
+	NeonDownloader::shutdown();
+}
+
+static void quitAll(int sigNum)
+{
+	cout << "Quitting..." << endl;
+
+	Gtk::Main::quit();
+}
+
+int main(int argc, char **argv)
+{
+	struct sigaction newAction;
+
+#if defined(ENABLE_NLS)
+	bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
+	textdomain (GETTEXT_PACKAGE);
+#endif //ENABLE_NLS
+
+	NeonDownloader::initialize();
+	MozillaRenderer::initialize();
+	Glib::thread_init();
+	Gtk::Main m(&argc, &argv);
+
+	// This will create the necessary directories on the first run
+	PinotSettings &settings = PinotSettings::getInstance();
+
+	string confDirectory = PinotSettings::getConfigurationDirectory();
+	chdir(confDirectory.c_str());
+
+	// Redirect cout and cerr to a file
+	string logFileName = confDirectory;
+	logFileName += "/pinot.log";
+	outputFile.open(logFileName.c_str());
+	coutBuf = cout.rdbuf();
+	cerrBuf = cerr.rdbuf();
+	cout.rdbuf(outputFile.rdbuf());
+	cerr.rdbuf(outputFile.rdbuf());
+
+	// Load the settings
+	settings.load();
+	settings.loadSearchEngines("/usr/share/pinot/engines");
+	settings.loadSearchEngines(confDirectory + string("/engines"));
+	// Load tokenizer libraries, if any
+	TokenizerFactory::loadTokenizers("/usr/share/pinot/tokenizers");
+	TokenizerFactory::loadTokenizers(confDirectory + string("/tokenizers"));
+
+	// Catch interrupts
+	sigemptyset(&newAction.sa_mask);
+	newAction.sa_flags = 0;
+	newAction.sa_handler = quitAll;
+	sigaction(SIGINT, &newAction, NULL);
+	sigaction(SIGQUIT, &newAction, NULL);
+
+	// Ensure Xapian will be able to deal with internal indices
+	if (XapianDatabaseFactory::getDatabase(settings.m_indexLocation, false) == NULL)
+	{
+		cerr << _("Index") << " " << settings.m_indexLocation << " "
+			<< _("is not valid, please check") << endl;
+	}
+	if (XapianDatabaseFactory::getDatabase(settings.m_mailIndexLocation, false) == NULL)
+	{
+		cerr << _("Index") << " " << settings.m_mailIndexLocation << " "
+			<< _("is not valid, please check") << endl;
+	}
+
+	// Do the same for the history database
+	if ((settings.m_historyDatabase.empty() == true) ||
+		(ActionHistory::create(settings.m_historyDatabase) == false) ||
+		(QueryHistory::create(settings.m_historyDatabase) == false) ||
+		(ViewHistory::create(settings.m_historyDatabase) == false))
+	{
+		cerr << _("History database") << " " << settings.m_historyDatabase << " "
+			<< _("couldn't be created") << endl;
+	}
+
+	atexit(closeAll);
+
+	// Localize language names
+	Languages::setIntlName(0, _("Danish"));
+	Languages::setIntlName(1, _("Dutch"));
+	Languages::setIntlName(2, _("English"));
+	Languages::setIntlName(3, _("Finnish"));
+	Languages::setIntlName(4, _("French"));
+	Languages::setIntlName(5, _("German"));
+	Languages::setIntlName(6, _("Italian"));
+	Languages::setIntlName(7, _("Norwegian"));
+	Languages::setIntlName(8, _("Portuguese"));
+	Languages::setIntlName(9, _("Russian"));
+	Languages::setIntlName(10, _("Spanish"));
+	Languages::setIntlName(11, _("Swedish"));
+
+	// Create and open the main dialog box
+	mainWindow mainBox;
+	m.run(mainBox);
+
+	return EXIT_SUCCESS;
+}

Deleted: trunk/UI/GTK2/src/pinot.cpp
===================================================================
--- trunk/UI/GTK2/src/pinot.cpp	2005-12-29 21:30:54 UTC (rev 30)
+++ trunk/UI/GTK2/src/pinot.cpp	2005-12-30 12:11:43 UTC (rev 31)
@@ -1,158 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Library General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <libintl.h>
-#include <iostream>
-#include <fstream>
-#include <glibmm.h>
-#include <glibmm/thread.h>
-#include <glibmm/ustring.h>
-#include <glibmm/convert.h>
-#include <gtkmm/main.h>
-
-#include "TokenizerFactory.h"
-#include "Languages.h"
-#include "XapianDatabase.h"
-#include "XapianDatabaseFactory.h"
-#include "ActionHistory.h"
-#include "QueryHistory.h"
-#include "ViewHistory.h"
-#include "NeonDownloader.h"
-#include "MozillaRenderer.h"
-#include "config.h"
-#include "NLS.h"
-#include "PinotSettings.h"
-#include "mainWindow.hh"
-
-using namespace std;
-
-static ofstream outputFile;
-static streambuf *coutBuf = NULL;
-static streambuf *cerrBuf = NULL;
-
-void closeAll(void)
-{
-	cout << "Exiting..." << endl;
-
-	// Save the settings
-	PinotSettings &settings = PinotSettings::getInstance();
-	if (settings.save() == false)
-	{
-		cerr << _("Couldn't save configuration file") << endl;
-	}
-
-	// Close all indexes we may have opened
-	XapianDatabaseFactory::closeAll();
-
-	// Close the tokenizer libraries
-	TokenizerFactory::unloadTokenizers();
-
-	// Restore the stream buffers
-	if (coutBuf != NULL)
-	{
-		cout.rdbuf(coutBuf);
-	}
-	if (cerrBuf != NULL)
-	{
-		cerr.rdbuf(cerrBuf);
-	}
-	outputFile.close();
-
-	MozillaRenderer::shutdown();
-	NeonDownloader::shutdown();
-}
-
-int main(int argc, char **argv)
-{
-#if defined(ENABLE_NLS)
-	bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
-	textdomain (GETTEXT_PACKAGE);
-#endif //ENABLE_NLS
-
-	NeonDownloader::initialize();
-	MozillaRenderer::initialize();
-	Glib::thread_init();
-	Gtk::Main m(&argc, &argv);
-
-	// This will create the necessary directories on the first run
-	PinotSettings &settings = PinotSettings::getInstance();
-
-	string confDirectory = PinotSettings::getConfigurationDirectory();
-	chdir(confDirectory.c_str());
-
-	// Redirect cout and cerr to a file
-	string logFileName = confDirectory;
-	logFileName += "/pinot.log";
-	outputFile.open(logFileName.c_str());
-	coutBuf = cout.rdbuf();
-	cerrBuf = cerr.rdbuf();
-	cout.rdbuf(outputFile.rdbuf());
-	cerr.rdbuf(outputFile.rdbuf());
-
-	// Load the settings
-	settings.load();
-	settings.loadSearchEngines("/usr/share/pinot/engines");
-	settings.loadSearchEngines(confDirectory + string("/engines"));
-	// Load tokenizer libraries, if any
-	TokenizerFactory::loadTokenizers("/usr/share/pinot/tokenizers");
-	TokenizerFactory::loadTokenizers(confDirectory + string("/tokenizers"));
-
-	// Ensure Xapian will be able to deal with internal indices
-	if (XapianDatabaseFactory::getDatabase(settings.m_indexLocation, false) == NULL)
-	{
-		cerr << _("Index") << " " << settings.m_indexLocation << " "
-			<< _("is not valid, please check") << endl;
-	}
-	if (XapianDatabaseFactory::getDatabase(settings.m_mailIndexLocation, false) == NULL)
-	{
-		cerr << _("Index") << " " << settings.m_mailIndexLocation << " "
-			<< _("is not valid, please check") << endl;
-	}
-
-	// Do the same for the history database
-	if ((settings.m_historyDatabase.empty() == true) ||
-		(ActionHistory::create(settings.m_historyDatabase) == false) ||
-		(QueryHistory::create(settings.m_historyDatabase) == false) ||
-		(ViewHistory::create(settings.m_historyDatabase) == false))
-	{
-		cerr << _("History database") << " " << settings.m_historyDatabase << " "
-			<< _("couldn't be created") << endl;
-	}
-
-	atexit(closeAll);
-
-	// Localize language names
-	Languages::setIntlName(0, _("Danish"));
-	Languages::setIntlName(1, _("Dutch"));
-	Languages::setIntlName(2, _("English"));
-	Languages::setIntlName(3, _("Finnish"));
-	Languages::setIntlName(4, _("French"));
-	Languages::setIntlName(5, _("German"));
-	Languages::setIntlName(6, _("Italian"));
-	Languages::setIntlName(7, _("Norwegian"));
-	Languages::setIntlName(8, _("Portuguese"));
-	Languages::setIntlName(9, _("Russian"));
-	Languages::setIntlName(10, _("Spanish"));
-	Languages::setIntlName(11, _("Swedish"));
-
-	// Create and open the main dialog box
-	mainWindow mainBox;
-	m.run(mainBox);
-
-	return EXIT_SUCCESS;
-}



From fabricecolin at berlios.de  Fri Dec 30 13:12:23 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 30 Dec 2005 13:12:23 +0100
Subject: [Pinot-svn] r32 - trunk/po
Message-ID: <200512301212.jBUCCNNT032273@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-30 13:12:21 +0100 (Fri, 30 Dec 2005)
New Revision: 32

Modified:
   trunk/po/POTFILES
   trunk/po/en_GB.po
   trunk/po/fr_FR.po
Log:
Updated translations.


Modified: trunk/po/POTFILES
===================================================================
--- trunk/po/POTFILES	2005-12-30 12:11:43 UTC (rev 31)
+++ trunk/po/POTFILES	2005-12-30 12:12:21 UTC (rev 32)
@@ -7,11 +7,13 @@
 UI/GTK2/src/indexDialog.cc
 UI/GTK2/src/indexDialog_glade.cc
 UI/GTK2/src/IndexTree.cpp
+UI/GTK2/src/IndexPage.cpp
 UI/GTK2/src/mainWindow.cc
 UI/GTK2/src/mainWindow_glade.cc
 UI/GTK2/src/ModelColumns.cpp
 UI/GTK2/src/MonitorHandler.cpp
-UI/GTK2/src/pinot.cpp
+UI/GTK2/src/Notebook.cpp
+UI/GTK2/src/pinot.cc
 UI/GTK2/src/PinotSettings.cpp
 UI/GTK2/src/PinotUtils.cpp
 UI/GTK2/src/prefsDialog.cc

Modified: trunk/po/en_GB.po
===================================================================
--- trunk/po/en_GB.po	2005-12-30 12:11:43 UTC (rev 31)
+++ trunk/po/en_GB.po	2005-12-30 12:12:21 UTC (rev 32)
@@ -27,7 +27,7 @@
 "Content-Type: text/plain; charset=utf-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 
-#: UI/GTK2/src/aboutDialog_glade.cc:342 UI/GTK2/src/mainWindow_glade.cc:449
+#: UI/GTK2/src/aboutDialog_glade.cc:342 UI/GTK2/src/mainWindow_glade.cc:357
 msgid "Pinot"
 msgstr ""
 
@@ -51,14 +51,16 @@
 msgid "Current User"
 msgstr ""
 
-#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:78
-#: UI/GTK2/src/mainWindow.cc:628 UI/GTK2/src/mainWindow.cc:1052
-#: UI/GTK2/src/mainWindow.cc:2512 UI/GTK2/src/PinotSettings.cpp:198
-#: UI/GTK2/src/PinotSettings.cpp:864 UI/GTK2/src/PinotSettings.cpp:920
+#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:372
+#: UI/GTK2/src/mainWindow.cc:375 UI/GTK2/src/mainWindow.cc:537
+#: UI/GTK2/src/mainWindow.cc:1116 UI/GTK2/src/mainWindow.cc:1187
+#: UI/GTK2/src/PinotSettings.cpp:198 UI/GTK2/src/PinotSettings.cpp:864
+#: UI/GTK2/src/PinotSettings.cpp:920
 msgid "My Documents"
 msgstr ""
 
-#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:632
+#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:378
+#: UI/GTK2/src/mainWindow.cc:381 UI/GTK2/src/mainWindow.cc:541
 #: UI/GTK2/src/MonitorHandler.cpp:174 UI/GTK2/src/PinotSettings.cpp:199
 #: UI/GTK2/src/PinotSettings.cpp:865 UI/GTK2/src/PinotSettings.cpp:921
 #: UI/GTK2/src/prefsDialog_glade.cc:116
@@ -73,8 +75,8 @@
 msgid "Whole directory"
 msgstr ""
 
-#: UI/GTK2/src/importDialog.cc:100 UI/GTK2/src/IndexTree.cpp:72
-#: UI/GTK2/src/ResultsTree.cpp:116
+#: UI/GTK2/src/importDialog.cc:100 UI/GTK2/src/IndexTree.cpp:71
+#: UI/GTK2/src/ResultsTree.cpp:114
 msgid "URL"
 msgstr ""
 
@@ -128,238 +130,254 @@
 msgid "External index"
 msgstr ""
 
-#: UI/GTK2/src/IndexTree.cpp:66 UI/GTK2/src/ResultsTree.cpp:98
+#: UI/GTK2/src/IndexTree.cpp:65 UI/GTK2/src/ResultsTree.cpp:96
 msgid "Title"
 msgstr ""
 
-#: UI/GTK2/src/IndexTree.cpp:77
+#: UI/GTK2/src/IndexTree.cpp:76
 msgid "Timestamp"
 msgstr ""
 
-#: UI/GTK2/src/IndexTree.cpp:219 UI/GTK2/src/WorkerThreads.cpp:340
+#: UI/GTK2/src/IndexTree.cpp:212 UI/GTK2/src/WorkerThreads.cpp:340
 msgid "No title"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:77 UI/GTK2/src/mainWindow.cc:486
-#: UI/GTK2/src/mainWindow.cc:681 UI/GTK2/src/queryDialog.cc:81
+#: UI/GTK2/src/IndexPage.cpp:51
+msgid "Show Previous"
+msgstr ""
+
+#: UI/GTK2/src/IndexPage.cpp:57
+msgid "Show Next"
+msgstr ""
+
+#: UI/GTK2/src/IndexPage.cpp:159 UI/GTK2/src/IndexPage.cpp:205
+#: UI/GTK2/src/queryDialog.cc:81
 msgid "None"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:216
+#: UI/GTK2/src/mainWindow.cc:168
 msgid "Query Name"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:221
+#: UI/GTK2/src/mainWindow.cc:173
 msgid "Last Run"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:222
+#: UI/GTK2/src/mainWindow.cc:174
 msgid "Summary"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:303
+#: UI/GTK2/src/mainWindow.cc:234
 msgid "Add index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:304
+#: UI/GTK2/src/mainWindow.cc:235
 msgid "Remove index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:329
+#: UI/GTK2/src/mainWindow.cc:258
 msgid "Ready"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:382
+#: UI/GTK2/src/mainWindow.cc:277 UI/GTK2/src/mainWindow.cc:1056
+#: UI/GTK2/src/mainWindow.cc:1433 UI/GTK2/src/mainWindow.cc:2959
+#: UI/GTK2/src/mainWindow_glade.cc:207
+msgid "View"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:309
 msgid "N/A"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:392
+#: UI/GTK2/src/mainWindow.cc:319
 msgid "<undefined>"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:599
+#: UI/GTK2/src/mainWindow.cc:499
 msgid "Result location is"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:643
+#: UI/GTK2/src/mainWindow.cc:552
 msgid "Document location is"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:684
-msgid "No labels"
+#: UI/GTK2/src/mainWindow.cc:663
+msgid "No label"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:788
+#: UI/GTK2/src/mainWindow.cc:839
 msgid "Showing"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:793
+#: UI/GTK2/src/mainWindow.cc:844
 msgid "off"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:798
+#: UI/GTK2/src/mainWindow.cc:849
 msgid "documents from"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:852
+#: UI/GTK2/src/mainWindow.cc:882
 msgid "Query"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:856 UI/GTK2/src/mainWindow.cc:2480
-#: UI/GTK2/src/ResultsTree.cpp:436 UI/GTK2/src/ResultsTree.cpp:708
+#: UI/GTK2/src/mainWindow.cc:886 UI/GTK2/src/mainWindow.cc:2788
 msgid "on"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:860
+#: UI/GTK2/src/mainWindow.cc:890
 msgid "ended"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:921 UI/GTK2/src/propertiesDialog.cc:34
+#: UI/GTK2/src/mainWindow.cc:990 UI/GTK2/src/propertiesDialog.cc:34
 msgid "Label"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:925
+#: UI/GTK2/src/mainWindow.cc:994
 msgid "matches"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:930
+#: UI/GTK2/src/mainWindow.cc:999
 msgid "document(s)"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:967
+#: UI/GTK2/src/mainWindow.cc:1031
 msgid "Updated label(s)"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1020 UI/GTK2/src/mainWindow.cc:1117
+#: UI/GTK2/src/mainWindow.cc:1092 UI/GTK2/src/mainWindow.cc:1198
 msgid "Updated document"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1027
+#: UI/GTK2/src/mainWindow.cc:1099
 msgid "Indexed"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1096
+#: UI/GTK2/src/mainWindow.cc:1169
 msgid "Unindexed document(s)"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1174
+#: UI/GTK2/src/mainWindow.cc:1255
 msgid "Couldn't rename index, name"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1178 UI/GTK2/src/mainWindow.cc:1932
-#: UI/GTK2/src/mainWindow.cc:2314
+#: UI/GTK2/src/mainWindow.cc:1259 UI/GTK2/src/mainWindow.cc:2163
+#: UI/GTK2/src/mainWindow.cc:2622
 msgid "is already in use"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1191
+#: UI/GTK2/src/mainWindow.cc:1272
 msgid "Couldn't rename index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1204
+#: UI/GTK2/src/mainWindow.cc:1285
 msgid "Edited index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1588 UI/GTK2/src/mainWindow.cc:1649
+#: UI/GTK2/src/mainWindow.cc:1775 UI/GTK2/src/mainWindow.cc:1856
 msgid "Please set a location for the index first"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1604
+#: UI/GTK2/src/mainWindow.cc:1802
 msgid "Result location is unknown"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1620
+#: UI/GTK2/src/mainWindow.cc:1818
 msgid "Import Document(s)"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1706 UI/GTK2/src/mainWindow_glade.cc:163
-#: UI/GTK2/src/pinot.cpp:115 UI/GTK2/src/pinot.cpp:120
-#: UI/GTK2/src/WorkerThreads.cpp:183 UI/GTK2/src/WorkerThreads.cpp:416
-#: UI/GTK2/src/WorkerThreads.cpp:1029
+#: UI/GTK2/src/mainWindow.cc:1934 UI/GTK2/src/pinot.cc:135
+#: UI/GTK2/src/pinot.cc:140 UI/GTK2/src/WorkerThreads.cpp:183
+#: UI/GTK2/src/WorkerThreads.cpp:421 UI/GTK2/src/WorkerThreads.cpp:1034
 msgid "Index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1710 UI/GTK2/src/WorkerThreads.cpp:187
-#: UI/GTK2/src/WorkerThreads.cpp:420 UI/GTK2/src/WorkerThreads.cpp:1033
+#: UI/GTK2/src/mainWindow.cc:1938 UI/GTK2/src/WorkerThreads.cpp:187
+#: UI/GTK2/src/WorkerThreads.cpp:425 UI/GTK2/src/WorkerThreads.cpp:1038
 msgid "doesn't exist"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1823
+#: UI/GTK2/src/mainWindow.cc:2050
 msgid "Delete this document from the index ?"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1834
+#: UI/GTK2/src/mainWindow.cc:2069
 msgid "Delete these documents from the index ?"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1928
+#: UI/GTK2/src/mainWindow.cc:2159
 msgid "Index name"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1943
+#: UI/GTK2/src/mainWindow.cc:2174
 msgid "Couldn't add index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1957
+#: UI/GTK2/src/mainWindow.cc:2188
 msgid "Added new index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:1992
+#: UI/GTK2/src/mainWindow.cc:2223
 msgid "Couldn't remove index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2180
+#: UI/GTK2/src/mainWindow.cc:2393
 msgid "At least one background task hasn't been completed yet. Quit now ?"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2310
+#: UI/GTK2/src/mainWindow.cc:2618
 msgid "Query name"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2337
+#: UI/GTK2/src/mainWindow.cc:2645
 msgid "Couldn't update query"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2345
+#: UI/GTK2/src/mainWindow.cc:2653
 msgid "Edited query"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2352
+#: UI/GTK2/src/mainWindow.cc:2660
 msgid "Couldn't add query"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2360
+#: UI/GTK2/src/mainWindow.cc:2668
 msgid "Added new query"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2374
+#: UI/GTK2/src/mainWindow.cc:2682
 msgid "Query is not set"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2385
+#: UI/GTK2/src/mainWindow.cc:2693
 msgid "No search engine selected"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2467
+#: UI/GTK2/src/mainWindow.cc:2775
 msgid "Please set the Google API key first"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2476
+#: UI/GTK2/src/mainWindow.cc:2784
 msgid "Running query"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2607
+#: UI/GTK2/src/mainWindow.cc:2890
+msgid "is already indexed or is being indexed"
+msgstr ""
+
+#: UI/GTK2/src/mainWindow.cc:2917
 msgid "No URL to browse"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2621
+#: UI/GTK2/src/mainWindow.cc:2928
 msgid "No browser configured to view results"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2633
+#: UI/GTK2/src/mainWindow.cc:2940
 msgid "Couldn't browse URL:"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow.cc:2865
+#: UI/GTK2/src/mainWindow.cc:3208
 msgid "thread(s)"
 msgstr ""
 
@@ -375,157 +393,141 @@
 msgid "Stored queries"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:144
-msgid "Results"
-msgstr ""
-
-#: UI/GTK2/src/mainWindow_glade.cc:148
-msgid "Show Previous"
-msgstr ""
-
-#: UI/GTK2/src/mainWindow_glade.cc:154
-msgid "Show Next"
-msgstr ""
-
-#: UI/GTK2/src/mainWindow_glade.cc:166 UI/GTK2/src/mainWindow_glade.cc:234
-msgid "View"
-msgstr ""
-
-#: UI/GTK2/src/mainWindow_glade.cc:198
+#: UI/GTK2/src/mainWindow_glade.cc:171
 msgid "Search Engine"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:201
+#: UI/GTK2/src/mainWindow_glade.cc:174
 msgid "Host Name"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:204
+#: UI/GTK2/src/mainWindow_glade.cc:177
 msgid "Clear List"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:207
+#: UI/GTK2/src/mainWindow_glade.cc:180
 msgid "Show Extract"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:210
+#: UI/GTK2/src/mainWindow_glade.cc:183
 msgid "Group By"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:216
+#: UI/GTK2/src/mainWindow_glade.cc:189
 msgid "Vie_w"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:219
+#: UI/GTK2/src/mainWindow_glade.cc:192
 msgid "View Cache"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:222 UI/GTK2/src/mainWindow_glade.cc:258
+#: UI/GTK2/src/mainWindow_glade.cc:195 UI/GTK2/src/mainWindow_glade.cc:231
 msgid "_Index"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:225
-msgid "Show Label"
+#: UI/GTK2/src/mainWindow_glade.cc:198
+msgid "List Contents Of"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:228
+#: UI/GTK2/src/mainWindow_glade.cc:201
 msgid "Import"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:237
+#: UI/GTK2/src/mainWindow_glade.cc:210
 msgid "Update"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:240
+#: UI/GTK2/src/mainWindow_glade.cc:213
 msgid "Unindex"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:243
+#: UI/GTK2/src/mainWindow_glade.cc:216
 #: UI/GTK2/src/propertiesDialog_glade.cc:174
 #: UI/GTK2/src/queryDialog_glade.cc:83
 msgid "Properties"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:246
+#: UI/GTK2/src/mainWindow_glade.cc:219
 msgid "_About"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:249
+#: UI/GTK2/src/mainWindow_glade.cc:222
 msgid "_Session"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:252
+#: UI/GTK2/src/mainWindow_glade.cc:225
 msgid "_Edit"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:255
+#: UI/GTK2/src/mainWindow_glade.cc:228
 msgid "_Results"
 msgstr ""
 
-#: UI/GTK2/src/mainWindow_glade.cc:261
+#: UI/GTK2/src/mainWindow_glade.cc:234
 msgid "_Help"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:55
+#: UI/GTK2/src/pinot.cc:57
 msgid "Couldn't save configuration file"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:116 UI/GTK2/src/pinot.cpp:121
+#: UI/GTK2/src/pinot.cc:136 UI/GTK2/src/pinot.cc:141
 msgid "is not valid, please check"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:130
+#: UI/GTK2/src/pinot.cc:150
 msgid "History database"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:131
+#: UI/GTK2/src/pinot.cc:151
 msgid "couldn't be created"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:137
+#: UI/GTK2/src/pinot.cc:157
 msgid "Danish"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:138
+#: UI/GTK2/src/pinot.cc:158
 msgid "Dutch"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:139
+#: UI/GTK2/src/pinot.cc:159
 msgid "English"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:140
+#: UI/GTK2/src/pinot.cc:160
 msgid "Finnish"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:141
+#: UI/GTK2/src/pinot.cc:161
 msgid "French"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:142
+#: UI/GTK2/src/pinot.cc:162
 msgid "German"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:143
+#: UI/GTK2/src/pinot.cc:163
 msgid "Italian"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:144
+#: UI/GTK2/src/pinot.cc:164
 msgid "Norwegian"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:145
+#: UI/GTK2/src/pinot.cc:165
 msgid "Portuguese"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:146
+#: UI/GTK2/src/pinot.cc:166
 msgid "Russian"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:147
+#: UI/GTK2/src/pinot.cc:167
 msgid "Spanish"
 msgstr ""
 
-#: UI/GTK2/src/pinot.cpp:148
+#: UI/GTK2/src/pinot.cc:168
 msgid "Swedish"
 msgstr ""
 
@@ -737,10 +739,10 @@
 msgid "Stopped browsing"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:196 UI/GTK2/src/WorkerThreads.cpp:428
-#: UI/GTK2/src/WorkerThreads.cpp:476 UI/GTK2/src/WorkerThreads.cpp:486
-#: UI/GTK2/src/WorkerThreads.cpp:710 UI/GTK2/src/WorkerThreads.cpp:911
-#: UI/GTK2/src/WorkerThreads.cpp:1042
+#: UI/GTK2/src/WorkerThreads.cpp:196 UI/GTK2/src/WorkerThreads.cpp:433
+#: UI/GTK2/src/WorkerThreads.cpp:481 UI/GTK2/src/WorkerThreads.cpp:491
+#: UI/GTK2/src/WorkerThreads.cpp:715 UI/GTK2/src/WorkerThreads.cpp:916
+#: UI/GTK2/src/WorkerThreads.cpp:1047
 msgid "Index error on"
 msgstr ""
 
@@ -756,78 +758,78 @@
 msgid "Couldn't run query on search engine"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:400 UI/GTK2/src/WorkerThreads.cpp:467
+#: UI/GTK2/src/WorkerThreads.cpp:405 UI/GTK2/src/WorkerThreads.cpp:472
 msgid "Stopped querying index labels"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:560
+#: UI/GTK2/src/WorkerThreads.cpp:565
 msgid "Stopped retrieval of"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:596
+#: UI/GTK2/src/WorkerThreads.cpp:601
 msgid "Couldn't obtain downloader for protocol"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:610 UI/GTK2/src/WorkerThreads.cpp:724
+#: UI/GTK2/src/WorkerThreads.cpp:615 UI/GTK2/src/WorkerThreads.cpp:729
 msgid "Couldn't retrieve"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:695
+#: UI/GTK2/src/WorkerThreads.cpp:700
 msgid "Stopped indexing"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:749
+#: UI/GTK2/src/WorkerThreads.cpp:754
 msgid "Cannot index document type"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:753
+#: UI/GTK2/src/WorkerThreads.cpp:758
 msgid "at"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:771
+#: UI/GTK2/src/WorkerThreads.cpp:776
 msgid "Couln't tokenize"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:792
+#: UI/GTK2/src/WorkerThreads.cpp:797
 msgid "Robots META tag forbids indexing"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:834
+#: UI/GTK2/src/WorkerThreads.cpp:839
 msgid "Couldn't index"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:899
+#: UI/GTK2/src/WorkerThreads.cpp:904
 msgid "Stopped unindexing document(s)"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:919
+#: UI/GTK2/src/WorkerThreads.cpp:924
 msgid "Couldn't unindex document(s)"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:1014
+#: UI/GTK2/src/WorkerThreads.cpp:1019
 msgid "Stopped document update for "
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:1051
+#: UI/GTK2/src/WorkerThreads.cpp:1056
 msgid "Couldn't update document"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:1091
+#: UI/GTK2/src/WorkerThreads.cpp:1096
 msgid "Stopped listening on"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:1189
+#: UI/GTK2/src/WorkerThreads.cpp:1194
 msgid "Couldn't read FIFO at"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:1229
+#: UI/GTK2/src/WorkerThreads.cpp:1234
 msgid "Stopped monitoring"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:1247
+#: UI/GTK2/src/WorkerThreads.cpp:1252
 msgid "No monitoring handler"
 msgstr ""
 
-#: UI/GTK2/src/WorkerThreads.cpp:1281
+#: UI/GTK2/src/WorkerThreads.cpp:1286
 msgid "Couldn't open FAM connection"
 msgstr ""

Modified: trunk/po/fr_FR.po
===================================================================
--- trunk/po/fr_FR.po	2005-12-30 12:11:43 UTC (rev 31)
+++ trunk/po/fr_FR.po	2005-12-30 12:12:21 UTC (rev 32)
@@ -27,7 +27,7 @@
 "Content-Type: text/plain; charset=utf-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 
-#: UI/GTK2/src/aboutDialog_glade.cc:342 UI/GTK2/src/mainWindow_glade.cc:449
+#: UI/GTK2/src/aboutDialog_glade.cc:342 UI/GTK2/src/mainWindow_glade.cc:357
 msgid "Pinot"
 msgstr "Pinot"
 
@@ -51,14 +51,16 @@
 msgid "Current User"
 msgstr "Utilisateur"
 
-#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:78
-#: UI/GTK2/src/mainWindow.cc:628 UI/GTK2/src/mainWindow.cc:1052
-#: UI/GTK2/src/mainWindow.cc:2512 UI/GTK2/src/PinotSettings.cpp:198
-#: UI/GTK2/src/PinotSettings.cpp:864 UI/GTK2/src/PinotSettings.cpp:920
+#: UI/GTK2/src/EnginesTree.cpp:303 UI/GTK2/src/mainWindow.cc:372
+#: UI/GTK2/src/mainWindow.cc:375 UI/GTK2/src/mainWindow.cc:537
+#: UI/GTK2/src/mainWindow.cc:1116 UI/GTK2/src/mainWindow.cc:1187
+#: UI/GTK2/src/PinotSettings.cpp:198 UI/GTK2/src/PinotSettings.cpp:864
+#: UI/GTK2/src/PinotSettings.cpp:920
 msgid "My Documents"
 msgstr "Mes Documents"
 
-#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:632
+#: UI/GTK2/src/EnginesTree.cpp:307 UI/GTK2/src/mainWindow.cc:378
+#: UI/GTK2/src/mainWindow.cc:381 UI/GTK2/src/mainWindow.cc:541
 #: UI/GTK2/src/MonitorHandler.cpp:174 UI/GTK2/src/PinotSettings.cpp:199
 #: UI/GTK2/src/PinotSettings.cpp:865 UI/GTK2/src/PinotSettings.cpp:921
 #: UI/GTK2/src/prefsDialog_glade.cc:116
@@ -73,8 +75,8 @@
 msgid "Whole directory"
 msgstr "Un repertoire"
 
-#: UI/GTK2/src/importDialog.cc:100 UI/GTK2/src/IndexTree.cpp:72
-#: UI/GTK2/src/ResultsTree.cpp:116
+#: UI/GTK2/src/importDialog.cc:100 UI/GTK2/src/IndexTree.cpp:71
+#: UI/GTK2/src/ResultsTree.cpp:114
 msgid "URL"
 msgstr "URL"
 
@@ -128,238 +130,254 @@
 msgid "External index"
 msgstr "Index externe"
 
-#: UI/GTK2/src/IndexTree.cpp:66 UI/GTK2/src/ResultsTree.cpp:98
+#: UI/GTK2/src/IndexTree.cpp:65 UI/GTK2/src/ResultsTree.cpp:96
 msgid "Title"
 msgstr "Titre"
 
-#: UI/GTK2/src/IndexTree.cpp:77
+#: UI/GTK2/src/IndexTree.cpp:76
 msgid "Timestamp"
 msgstr "Date"
 
-#: UI/GTK2/src/IndexTree.cpp:219 UI/GTK2/src/WorkerThreads.cpp:340
+#: UI/GTK2/src/IndexTree.cpp:212 UI/GTK2/src/WorkerThreads.cpp:340
 msgid "No title"
 msgstr "Pas de titre"
 
-#: UI/GTK2/src/mainWindow.cc:77 UI/GTK2/src/mainWindow.cc:486
-#: UI/GTK2/src/mainWindow.cc:681 UI/GTK2/src/queryDialog.cc:81
+#: UI/GTK2/src/IndexPage.cpp:51
+msgid "Show Previous"
+msgstr "Precedents"
+
+#: UI/GTK2/src/IndexPage.cpp:57
+msgid "Show Next"
+msgstr "Suivants"
+
+#: UI/GTK2/src/IndexPage.cpp:159 UI/GTK2/src/IndexPage.cpp:205
+#: UI/GTK2/src/queryDialog.cc:81
 msgid "None"
 msgstr "Aucune"
 
-#: UI/GTK2/src/mainWindow.cc:216
+#: UI/GTK2/src/mainWindow.cc:168
 msgid "Query Name"
 msgstr "Nom de la Recherche"
 
-#: UI/GTK2/src/mainWindow.cc:221
+#: UI/GTK2/src/mainWindow.cc:173
 msgid "Last Run"
 msgstr "Derniere Utilisation"
 
-#: UI/GTK2/src/mainWindow.cc:222
+#: UI/GTK2/src/mainWindow.cc:174
 msgid "Summary"
 msgstr "Sommaire"
 
-#: UI/GTK2/src/mainWindow.cc:303
+#: UI/GTK2/src/mainWindow.cc:234
 msgid "Add index"
 msgstr "Ajouter un index"
 
-#: UI/GTK2/src/mainWindow.cc:304
+#: UI/GTK2/src/mainWindow.cc:235
 msgid "Remove index"
 msgstr "Enlever un index"
 
-#: UI/GTK2/src/mainWindow.cc:329
+#: UI/GTK2/src/mainWindow.cc:258
 msgid "Ready"
 msgstr "Pret"
 
-#: UI/GTK2/src/mainWindow.cc:382
+#: UI/GTK2/src/mainWindow.cc:277 UI/GTK2/src/mainWindow.cc:1056
+#: UI/GTK2/src/mainWindow.cc:1433 UI/GTK2/src/mainWindow.cc:2959
+#: UI/GTK2/src/mainWindow_glade.cc:207
+msgid "View"
+msgstr "Voir"
+
+#: UI/GTK2/src/mainWindow.cc:309
 msgid "N/A"
 msgstr "Inconnue"
 
-#: UI/GTK2/src/mainWindow.cc:392
+#: UI/GTK2/src/mainWindow.cc:319
 msgid "<undefined>"
 msgstr "<inconnu>"
 
-#: UI/GTK2/src/mainWindow.cc:599
+#: UI/GTK2/src/mainWindow.cc:499
 msgid "Result location is"
 msgstr "La location du resultat est"
 
-#: UI/GTK2/src/mainWindow.cc:643
+#: UI/GTK2/src/mainWindow.cc:552
 msgid "Document location is"
 msgstr "La location du document is"
 
-#: UI/GTK2/src/mainWindow.cc:684
-msgid "No labels"
-msgstr "Pas d'etiquettes"
+#: UI/GTK2/src/mainWindow.cc:663
+msgid "No label"
+msgstr "Pas d'etiquette"
 
-#: UI/GTK2/src/mainWindow.cc:788
+#: UI/GTK2/src/mainWindow.cc:839
 msgid "Showing"
 msgstr "Listant"
 
-#: UI/GTK2/src/mainWindow.cc:793
+#: UI/GTK2/src/mainWindow.cc:844
 msgid "off"
 msgstr "de"
 
-#: UI/GTK2/src/mainWindow.cc:798
+#: UI/GTK2/src/mainWindow.cc:849
 msgid "documents from"
 msgstr "documents venant de"
 
-#: UI/GTK2/src/mainWindow.cc:852
+#: UI/GTK2/src/mainWindow.cc:882
 msgid "Query"
 msgstr "La recherche"
 
-#: UI/GTK2/src/mainWindow.cc:856 UI/GTK2/src/mainWindow.cc:2480
-#: UI/GTK2/src/ResultsTree.cpp:436 UI/GTK2/src/ResultsTree.cpp:708
+#: UI/GTK2/src/mainWindow.cc:886 UI/GTK2/src/mainWindow.cc:2788
 msgid "on"
 msgstr "sur"
 
-#: UI/GTK2/src/mainWindow.cc:860
+#: UI/GTK2/src/mainWindow.cc:890
 msgid "ended"
 msgstr "est terminee"
 
-#: UI/GTK2/src/mainWindow.cc:921 UI/GTK2/src/propertiesDialog.cc:34
+#: UI/GTK2/src/mainWindow.cc:990 UI/GTK2/src/propertiesDialog.cc:34
 msgid "Label"
 msgstr "L'etiquette"
 
-#: UI/GTK2/src/mainWindow.cc:925
+#: UI/GTK2/src/mainWindow.cc:994
 msgid "matches"
 msgstr "correspond a"
 
-#: UI/GTK2/src/mainWindow.cc:930
+#: UI/GTK2/src/mainWindow.cc:999
 msgid "document(s)"
 msgstr "document(s)"
 
-#: UI/GTK2/src/mainWindow.cc:967
+#: UI/GTK2/src/mainWindow.cc:1031
 msgid "Updated label(s)"
 msgstr "Mis a jour l(es) etiquette(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1020 UI/GTK2/src/mainWindow.cc:1117
+#: UI/GTK2/src/mainWindow.cc:1092 UI/GTK2/src/mainWindow.cc:1198
 msgid "Updated document"
 msgstr "Mis a jour le document"
 
-#: UI/GTK2/src/mainWindow.cc:1027
+#: UI/GTK2/src/mainWindow.cc:1099
 msgid "Indexed"
 msgstr "Indexe"
 
-#: UI/GTK2/src/mainWindow.cc:1096
+#: UI/GTK2/src/mainWindow.cc:1169
 msgid "Unindexed document(s)"
 msgstr "Desindexe le(s) document(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1174
+#: UI/GTK2/src/mainWindow.cc:1255
 msgid "Couldn't rename index, name"
 msgstr "N'a pas pu renommer l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1178 UI/GTK2/src/mainWindow.cc:1932
-#: UI/GTK2/src/mainWindow.cc:2314
+#: UI/GTK2/src/mainWindow.cc:1259 UI/GTK2/src/mainWindow.cc:2163
+#: UI/GTK2/src/mainWindow.cc:2622
 msgid "is already in use"
 msgstr "est deja utilise"
 
-#: UI/GTK2/src/mainWindow.cc:1191
+#: UI/GTK2/src/mainWindow.cc:1272
 msgid "Couldn't rename index"
 msgstr "N'a pas pu renommer l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1204
+#: UI/GTK2/src/mainWindow.cc:1285
 msgid "Edited index"
 msgstr "Edite l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1588 UI/GTK2/src/mainWindow.cc:1649
+#: UI/GTK2/src/mainWindow.cc:1775 UI/GTK2/src/mainWindow.cc:1856
 msgid "Please set a location for the index first"
 msgstr "Donnez une location a l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1604
+#: UI/GTK2/src/mainWindow.cc:1802
 msgid "Result location is unknown"
 msgstr "La location du resultat est inconnue"
 
-#: UI/GTK2/src/mainWindow.cc:1620
+#: UI/GTK2/src/mainWindow.cc:1818
 msgid "Import Document(s)"
 msgstr "Importation de Document(s)"
 
-#: UI/GTK2/src/mainWindow.cc:1706 UI/GTK2/src/mainWindow_glade.cc:163
-#: UI/GTK2/src/pinot.cpp:115 UI/GTK2/src/pinot.cpp:120
-#: UI/GTK2/src/WorkerThreads.cpp:183 UI/GTK2/src/WorkerThreads.cpp:416
-#: UI/GTK2/src/WorkerThreads.cpp:1029
+#: UI/GTK2/src/mainWindow.cc:1934 UI/GTK2/src/pinot.cc:135
+#: UI/GTK2/src/pinot.cc:140 UI/GTK2/src/WorkerThreads.cpp:183
+#: UI/GTK2/src/WorkerThreads.cpp:421 UI/GTK2/src/WorkerThreads.cpp:1034
 msgid "Index"
 msgstr "L'index"
 
-#: UI/GTK2/src/mainWindow.cc:1710 UI/GTK2/src/WorkerThreads.cpp:187
-#: UI/GTK2/src/WorkerThreads.cpp:420 UI/GTK2/src/WorkerThreads.cpp:1033
+#: UI/GTK2/src/mainWindow.cc:1938 UI/GTK2/src/WorkerThreads.cpp:187
+#: UI/GTK2/src/WorkerThreads.cpp:425 UI/GTK2/src/WorkerThreads.cpp:1038
 msgid "doesn't exist"
 msgstr "n'existe pas"
 
-#: UI/GTK2/src/mainWindow.cc:1823
+#: UI/GTK2/src/mainWindow.cc:2050
 msgid "Delete this document from the index ?"
 msgstr "Enlever ce document de l'index ?"
 
-#: UI/GTK2/src/mainWindow.cc:1834
+#: UI/GTK2/src/mainWindow.cc:2069
 msgid "Delete these documents from the index ?"
 msgstr "Enlever ces documents de l'index ?"
 
-#: UI/GTK2/src/mainWindow.cc:1928
+#: UI/GTK2/src/mainWindow.cc:2159
 msgid "Index name"
 msgstr "Nom de l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1943
+#: UI/GTK2/src/mainWindow.cc:2174
 msgid "Couldn't add index"
 msgstr "N'a pas pu ajouter l'index"
 
-#: UI/GTK2/src/mainWindow.cc:1957
+#: UI/GTK2/src/mainWindow.cc:2188
 msgid "Added new index"
 msgstr "Ajouter un nouvel index"
 
-#: UI/GTK2/src/mainWindow.cc:1992
+#: UI/GTK2/src/mainWindow.cc:2223
 msgid "Couldn't remove index"
 msgstr "N'a pas pu enlever l'index"
 
-#: UI/GTK2/src/mainWindow.cc:2180
+#: UI/GTK2/src/mainWindow.cc:2393
 msgid "At least one background task hasn't been completed yet. Quit now ?"
 msgstr "Nom de la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2310
+#: UI/GTK2/src/mainWindow.cc:2618
 msgid "Query name"
 msgstr "N'a pas pu ajouter la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2337
+#: UI/GTK2/src/mainWindow.cc:2645
 msgid "Couldn't update query"
 msgstr "Ajoute une nouvelle recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2345
+#: UI/GTK2/src/mainWindow.cc:2653
 msgid "Edited query"
 msgstr "N'a pas pu mettre a jour la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2352
+#: UI/GTK2/src/mainWindow.cc:2660
 msgid "Couldn't add query"
 msgstr "Edite la recherche"
 
-#: UI/GTK2/src/mainWindow.cc:2360
+#: UI/GTK2/src/mainWindow.cc:2668
 msgid "Added new query"
 msgstr "Au moins une tache n'est pas terminee. Quitter maintenant ?"
 
-#: UI/GTK2/src/mainWindow.cc:2374
+#: UI/GTK2/src/mainWindow.cc:2682
 msgid "Query is not set"
 msgstr "Recherche indefinie"
 
-#: UI/GTK2/src/mainWindow.cc:2385
+#: UI/GTK2/src/mainWindow.cc:2693
 msgid "No search engine selected"
 msgstr "Pas de moteur selectionne"
 
-#: UI/GTK2/src/mainWindow.cc:2467
+#: UI/GTK2/src/mainWindow.cc:2775
 msgid "Please set the Google API key first"
 msgstr "Configurez la clef de l'API Google "
 
-#: UI/GTK2/src/mainWindow.cc:2476
+#: UI/GTK2/src/mainWindow.cc:2784
 msgid "Running query"
 msgstr "Recherche en cours"
 
-#: UI/GTK2/src/mainWindow.cc:2607
+#: UI/GTK2/src/mainWindow.cc:2890
+msgid "is already indexed or is being indexed"
+msgstr "est deja indexe ou est en cours d'indexation"
+
+#: UI/GTK2/src/mainWindow.cc:2917
 msgid "No URL to browse"
 msgstr "Pas d'URL a brouter"
 
-#: UI/GTK2/src/mainWindow.cc:2621
+#: UI/GTK2/src/mainWindow.cc:2928
 msgid "No browser configured to view results"
 msgstr "Pas de brouter configure"
 
-#: UI/GTK2/src/mainWindow.cc:2633
+#: UI/GTK2/src/mainWindow.cc:2940
 msgid "Couldn't browse URL:"
 msgstr "N'a pas pu brouter l'URL"
 
-#: UI/GTK2/src/mainWindow.cc:2865
+#: UI/GTK2/src/mainWindow.cc:3208
 msgid "thread(s)"
 msgstr "tache(s)"
 
@@ -373,159 +391,143 @@
 
 #: UI/GTK2/src/mainWindow_glade.cc:136
 msgid "Stored queries"
-msgstr "Recherches Sauvees"
+msgstr "Recherches sauvegardees"
 
-#: UI/GTK2/src/mainWindow_glade.cc:144
-msgid "Results"
-msgstr "Resultats"
-
-#: UI/GTK2/src/mainWindow_glade.cc:148
-msgid "Show Previous"
-msgstr "Precedents"
-
-#: UI/GTK2/src/mainWindow_glade.cc:154
-msgid "Show Next"
-msgstr "Suivants"
-
-#: UI/GTK2/src/mainWindow_glade.cc:166 UI/GTK2/src/mainWindow_glade.cc:234
-msgid "View"
-msgstr "Voir"
-
-#: UI/GTK2/src/mainWindow_glade.cc:198
+#: UI/GTK2/src/mainWindow_glade.cc:171
 msgid "Search Engine"
 msgstr "Moteurs"
 
-#: UI/GTK2/src/mainWindow_glade.cc:201
+#: UI/GTK2/src/mainWindow_glade.cc:174
 msgid "Host Name"
 msgstr "Nom de machine"
 
-#: UI/GTK2/src/mainWindow_glade.cc:204
+#: UI/GTK2/src/mainWindow_glade.cc:177
 msgid "Clear List"
 msgstr "Nettoyer la Liste"
 
-#: UI/GTK2/src/mainWindow_glade.cc:207
+#: UI/GTK2/src/mainWindow_glade.cc:180
 msgid "Show Extract"
 msgstr "Montrer l'Extrait"
 
-#: UI/GTK2/src/mainWindow_glade.cc:210
+#: UI/GTK2/src/mainWindow_glade.cc:183
 msgid "Group By"
 msgstr "Grouper Par"
 
-#: UI/GTK2/src/mainWindow_glade.cc:216
+#: UI/GTK2/src/mainWindow_glade.cc:189
 msgid "Vie_w"
 msgstr "Voir"
 
-#: UI/GTK2/src/mainWindow_glade.cc:219
+#: UI/GTK2/src/mainWindow_glade.cc:192
 msgid "View Cache"
 msgstr "Voir le Cache"
 
-#: UI/GTK2/src/mainWindow_glade.cc:222 UI/GTK2/src/mainWindow_glade.cc:258
+#: UI/GTK2/src/mainWindow_glade.cc:195 UI/GTK2/src/mainWindow_glade.cc:231
 msgid "_Index"
 msgstr "Indexer"
 
-#: UI/GTK2/src/mainWindow_glade.cc:225
-msgid "Show Label"
-msgstr "Montrer l'Etiquette"
+#: UI/GTK2/src/mainWindow_glade.cc:198
+msgid "List Contents Of"
+msgstr "Lister le Contenu de"
 
-#: UI/GTK2/src/mainWindow_glade.cc:228
+#: UI/GTK2/src/mainWindow_glade.cc:201
 msgid "Import"
 msgstr "Importer"
 
-#: UI/GTK2/src/mainWindow_glade.cc:237
+#: UI/GTK2/src/mainWindow_glade.cc:210
 msgid "Update"
 msgstr "Mettre a Jour"
 
-#: UI/GTK2/src/mainWindow_glade.cc:240
+#: UI/GTK2/src/mainWindow_glade.cc:213
 msgid "Unindex"
 msgstr "Desindexer"
 
-#: UI/GTK2/src/mainWindow_glade.cc:243
+#: UI/GTK2/src/mainWindow_glade.cc:216
 #: UI/GTK2/src/propertiesDialog_glade.cc:174
 #: UI/GTK2/src/queryDialog_glade.cc:83
 msgid "Properties"
 msgstr "Proprietes"
 
-#: UI/GTK2/src/mainWindow_glade.cc:246
+#: UI/GTK2/src/mainWindow_glade.cc:219
 msgid "_About"
 msgstr "A Propos"
 
-#: UI/GTK2/src/mainWindow_glade.cc:249
+#: UI/GTK2/src/mainWindow_glade.cc:222
 msgid "_Session"
 msgstr "Session"
 
-#: UI/GTK2/src/mainWindow_glade.cc:252
+#: UI/GTK2/src/mainWindow_glade.cc:225
 msgid "_Edit"
 msgstr "Editer"
 
-#: UI/GTK2/src/mainWindow_glade.cc:255
+#: UI/GTK2/src/mainWindow_glade.cc:228
 msgid "_Results"
 msgstr "Resultats"
 
-#: UI/GTK2/src/mainWindow_glade.cc:261
+#: UI/GTK2/src/mainWindow_glade.cc:234
 msgid "_Help"
 msgstr "Aide"
 
-#: UI/GTK2/src/pinot.cpp:55
+#: UI/GTK2/src/pinot.cc:57
 msgid "Couldn't save configuration file"
 msgstr "N'a pas pu sauver la configuration"
 
-#: UI/GTK2/src/pinot.cpp:116 UI/GTK2/src/pinot.cpp:121
+#: UI/GTK2/src/pinot.cc:136 UI/GTK2/src/pinot.cc:141
 msgid "is not valid, please check"
 msgstr "n'est pas valide, veuillez verifier"
 
-#: UI/GTK2/src/pinot.cpp:130
+#: UI/GTK2/src/pinot.cc:150
 msgid "History database"
 msgstr "La base des historiques"
 
-#: UI/GTK2/src/pinot.cpp:131
+#: UI/GTK2/src/pinot.cc:151
 msgid "couldn't be created"
 msgstr "n'a pas pu etre creee"
 
-#: UI/GTK2/src/pinot.cpp:137
+#: UI/GTK2/src/pinot.cc:157
 msgid "Danish"
 msgstr "Danois"
 
-#: UI/GTK2/src/pinot.cpp:138
+#: UI/GTK2/src/pinot.cc:158
 msgid "Dutch"
 msgstr "Hollandais"
 
-#: UI/GTK2/src/pinot.cpp:139
+#: UI/GTK2/src/pinot.cc:159
 msgid "English"
 msgstr "Anglais"
 
-#: UI/GTK2/src/pinot.cpp:140
+#: UI/GTK2/src/pinot.cc:160
 msgid "Finnish"
 msgstr "Finlandais"
 
-#: UI/GTK2/src/pinot.cpp:141
+#: UI/GTK2/src/pinot.cc:161
 msgid "French"
 msgstr "Francais"
 
-#: UI/GTK2/src/pinot.cpp:142
+#: UI/GTK2/src/pinot.cc:162
 msgid "German"
 msgstr "Allemand"
 
-#: UI/GTK2/src/pinot.cpp:143
+#: UI/GTK2/src/pinot.cc:163
 msgid "Italian"
 msgstr "Italien"
 
-#: UI/GTK2/src/pinot.cpp:144
+#: UI/GTK2/src/pinot.cc:164
 msgid "Norwegian"
 msgstr "Norvegien"
 
-#: UI/GTK2/src/pinot.cpp:145
+#: UI/GTK2/src/pinot.cc:165
 msgid "Portuguese"
 msgstr "Portugais"
 
-#: UI/GTK2/src/pinot.cpp:146
+#: UI/GTK2/src/pinot.cc:166
 msgid "Russian"
 msgstr "Russe"
 
-#: UI/GTK2/src/pinot.cpp:147
+#: UI/GTK2/src/pinot.cc:167
 msgid "Spanish"
 msgstr "Espagnol"
 
-#: UI/GTK2/src/pinot.cpp:148
+#: UI/GTK2/src/pinot.cc:168
 msgid "Swedish"
 msgstr "Suedois"
 
@@ -737,10 +739,10 @@
 msgid "Stopped browsing"
 msgstr "Arrete le brouteur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:196 UI/GTK2/src/WorkerThreads.cpp:428
-#: UI/GTK2/src/WorkerThreads.cpp:476 UI/GTK2/src/WorkerThreads.cpp:486
-#: UI/GTK2/src/WorkerThreads.cpp:710 UI/GTK2/src/WorkerThreads.cpp:911
-#: UI/GTK2/src/WorkerThreads.cpp:1042
+#: UI/GTK2/src/WorkerThreads.cpp:196 UI/GTK2/src/WorkerThreads.cpp:433
+#: UI/GTK2/src/WorkerThreads.cpp:481 UI/GTK2/src/WorkerThreads.cpp:491
+#: UI/GTK2/src/WorkerThreads.cpp:715 UI/GTK2/src/WorkerThreads.cpp:916
+#: UI/GTK2/src/WorkerThreads.cpp:1047
 msgid "Index error on"
 msgstr "Erreur d'index sur"
 
@@ -756,78 +758,78 @@
 msgid "Couldn't run query on search engine"
 msgstr "N'a pas pu lancer la recherche sur le moteur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:400 UI/GTK2/src/WorkerThreads.cpp:467
+#: UI/GTK2/src/WorkerThreads.cpp:405 UI/GTK2/src/WorkerThreads.cpp:472
 msgid "Stopped querying index labels"
 msgstr "Arrete la recherche d'etiquettes"
 
-#: UI/GTK2/src/WorkerThreads.cpp:560
+#: UI/GTK2/src/WorkerThreads.cpp:565
 msgid "Stopped retrieval of"
 msgstr "Arrete le telechargement de"
 
-#: UI/GTK2/src/WorkerThreads.cpp:596
+#: UI/GTK2/src/WorkerThreads.cpp:601
 msgid "Couldn't obtain downloader for protocol"
 msgstr "N'a pas pu obtenir un brouteur pour ="
 
-#: UI/GTK2/src/WorkerThreads.cpp:610 UI/GTK2/src/WorkerThreads.cpp:724
+#: UI/GTK2/src/WorkerThreads.cpp:615 UI/GTK2/src/WorkerThreads.cpp:729
 msgid "Couldn't retrieve"
 msgstr "N'a pas pu telecharger"
 
-#: UI/GTK2/src/WorkerThreads.cpp:695
+#: UI/GTK2/src/WorkerThreads.cpp:700
 msgid "Stopped indexing"
 msgstr "Arrete l'indexation"
 
-#: UI/GTK2/src/WorkerThreads.cpp:749
+#: UI/GTK2/src/WorkerThreads.cpp:754
 msgid "Cannot index document type"
 msgstr "Impossible d'indexer de type de documents"
 
-#: UI/GTK2/src/WorkerThreads.cpp:753
+#: UI/GTK2/src/WorkerThreads.cpp:758
 msgid "at"
 msgstr "a"
 
-#: UI/GTK2/src/WorkerThreads.cpp:771
+#: UI/GTK2/src/WorkerThreads.cpp:776
 msgid "Couln't tokenize"
 msgstr "N'a pas pu tokenise"
 
-#: UI/GTK2/src/WorkerThreads.cpp:792
+#: UI/GTK2/src/WorkerThreads.cpp:797
 msgid "Robots META tag forbids indexing"
 msgstr "Le META tag Robots empeche d'indexer"
 
-#: UI/GTK2/src/WorkerThreads.cpp:834
+#: UI/GTK2/src/WorkerThreads.cpp:839
 msgid "Couldn't index"
 msgstr "N'a pas pu indexer"
 
-#: UI/GTK2/src/WorkerThreads.cpp:899
+#: UI/GTK2/src/WorkerThreads.cpp:904
 msgid "Stopped unindexing document(s)"
 msgstr "Arrete d'indexer les document(s)"
 
-#: UI/GTK2/src/WorkerThreads.cpp:919
+#: UI/GTK2/src/WorkerThreads.cpp:924
 msgid "Couldn't unindex document(s)"
 msgstr "N'a pas pu desindexer le(s) document(s)"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1014
+#: UI/GTK2/src/WorkerThreads.cpp:1019
 msgid "Stopped document update for "
 msgstr "Arrete la mise a jour pour "
 
-#: UI/GTK2/src/WorkerThreads.cpp:1051
+#: UI/GTK2/src/WorkerThreads.cpp:1056
 msgid "Couldn't update document"
 msgstr "N'a pas pu mettre a jour le document"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1091
+#: UI/GTK2/src/WorkerThreads.cpp:1096
 msgid "Stopped listening on"
 msgstr "Arrete l'ecoute sur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1189
+#: UI/GTK2/src/WorkerThreads.cpp:1194
 msgid "Couldn't read FIFO at"
 msgstr "N'a pas pu lire la FIFO a"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1229
+#: UI/GTK2/src/WorkerThreads.cpp:1234
 msgid "Stopped monitoring"
 msgstr "Arrete la surveillance"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1247
+#: UI/GTK2/src/WorkerThreads.cpp:1252
 msgid "No monitoring handler"
 msgstr "Pas de moniteur"
 
-#: UI/GTK2/src/WorkerThreads.cpp:1281
+#: UI/GTK2/src/WorkerThreads.cpp:1286
 msgid "Couldn't open FAM connection"
 msgstr "N'a pas pu ouvrir la connection FAM"



From fabricecolin at berlios.de  Fri Dec 30 13:13:01 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 30 Dec 2005 13:13:01 +0100
Subject: [Pinot-svn] r33 - trunk
Message-ID: <200512301213.jBUCD1Ce032385@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-30 13:12:53 +0100 (Fri, 30 Dec 2005)
New Revision: 33

Modified:
   trunk/pinot.spec
Log:
Added StartupNotify to .desktop file.


Modified: trunk/pinot.spec
===================================================================
--- trunk/pinot.spec	2005-12-30 12:12:21 UTC (rev 32)
+++ trunk/pinot.spec	2005-12-30 12:12:53 UTC (rev 33)
@@ -74,6 +74,7 @@
 Name=Pinot Metasearch tool
 Comment=Search the Web and your documents
 Exec=%{_bindir}/pinot
+StartupNotify=true
 Icon=pinot.png
 Terminal=false
 Type=Application



From fabricecolin at berlios.de  Fri Dec 30 14:46:55 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 30 Dec 2005 14:46:55 +0100
Subject: [Pinot-svn] r34 - in trunk: . Index Search po
Message-ID: <200512301346.jBUDkt7X014902@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-30 14:46:55 +0100 (Fri, 30 Dec 2005)
New Revision: 34

Modified:
   trunk/Index/Summarizer.cpp
   trunk/Index/XapianIndex.cpp
   trunk/Search/XapianEngine.cpp
   trunk/Search/XapianEngine.h
   trunk/po/en_GB.po
   trunk/po/fr_FR.po
   trunk/textcat_conf.txt
Log:
Fixed issues with documents and queries language (whether it should in the
current locale or in English).


Modified: trunk/Index/Summarizer.cpp
===================================================================
--- trunk/Index/Summarizer.cpp	2005-12-30 12:12:53 UTC (rev 33)
+++ trunk/Index/Summarizer.cpp	2005-12-30 13:46:55 UTC (rev 34)
@@ -14,6 +14,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include <string.h>
 #include <sys/time.h>
 #include <map>
 #include <iostream>
@@ -39,14 +40,14 @@
 	m_wordsCount(wordsCount),
 	m_dictionaryCode("en")
 {
-	string lang = StringManip::toLowerCase(language);
-
 	// Look up the language code
-	for (unsigned int count = 0; count < Languages::m_count; ++count)
+	for (unsigned int langNum = 0; langNum < Languages::m_count; ++langNum)
 	{
-		if (lang == Languages::m_names[count])
+		if (strncasecmp(language.c_str(), Languages::m_names[langNum],
+			min(language.length(), strlen(Languages::m_names[langNum]))) == 0)
 		{
-			m_dictionaryCode = Languages::m_codes[count];
+			m_dictionaryCode = Languages::m_codes[langNum];
+			break;
 		}
 	}
 }

Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2005-12-30 12:12:53 UTC (rev 33)
+++ trunk/Index/XapianIndex.cpp	2005-12-30 13:46:55 UTC (rev 34)
@@ -24,17 +24,20 @@
 #include <iostream>
 #include <fstream>
 #include <algorithm>
+#include <utility>
 
+#include "Languages.h"
 #include "StringManip.h"
+#include "TimeConverter.h"
 #include "Url.h"
 #include "Summarizer.h"
-#include "TimeConverter.h"
 #include "LanguageDetector.h"
 #include "XapianDatabaseFactory.h"
 #include "XapianIndex.h"
 
 using std::string;
 using std::set;
+using std::min;
 
 // This puts a limit to terms length.
 const unsigned int XapianIndex::m_maxTermLength = 64;
@@ -284,7 +287,6 @@
 			return false;
 		}
 
-		// Obtain a summary
 		const char *pData = pDocument->getData(dataLength);
 		if (pData == NULL)
 		{
@@ -366,10 +368,24 @@
 			string record = doc.get_data();
 			if (record.empty() == false)
 			{
+				string language = StringManip::extractField(record, "language=", "");
+
+				// Get the language name in the current locale
+				for (unsigned int langNum = 0; langNum < Languages::m_count; ++langNum)
+				{
+					if (strncasecmp(language.c_str(), Languages::m_names[langNum],
+						min(language.length(), strlen(Languages::m_names[langNum]))) == 0)
+					{
+						// That's the one !
+						language = Languages::getIntlName(langNum);
+						break;
+					}
+				}
+
 				docInfo = DocumentInfo(StringManip::extractField(record, "caption=", "\n"),
 					StringManip::extractField(record, "url=", "\n"),
 					StringManip::extractField(record, "type=", "\n"),
-					StringManip::extractField(record, "language=", ""));
+					language);
 				docInfo.setTimestamp(StringManip::extractField(record, "timestamp=", "\n"));
 #ifdef DEBUG
 				cout << "XapianIndex::getDocumentInfo: language is "
@@ -547,7 +563,6 @@
 		return false;
 	}
 
-	// Obtain a summary
 	const char *pData = pDocument->getData(dataLength);
 	if (pData == NULL)
 	{

Modified: trunk/Search/XapianEngine.cpp
===================================================================
--- trunk/Search/XapianEngine.cpp	2005-12-30 12:12:53 UTC (rev 33)
+++ trunk/Search/XapianEngine.cpp	2005-12-30 13:46:55 UTC (rev 34)
@@ -20,7 +20,9 @@
 #include <string>
 #include <vector>
 #include <iostream>
+#include <utility>
 
+#include "Languages.h"
 #include "StringManip.h"
 #include "Tokenizer.h"
 #include "Url.h"
@@ -33,8 +35,9 @@
 using std::cout;
 using std::cerr;
 using std::endl;
+using std::min;
 
-static bool extractWords(const string &text, const string &language, vector<string> &wordsList)
+static bool extractWords(const string &text, const string &stemLanguage, vector<string> &wordsList)
 {
 	Xapian::Stem *pStemmer = NULL;
 
@@ -43,9 +46,9 @@
 		return false;
 	}
 
-	if (language.empty() == false)
+	if (stemLanguage.empty() == false)
 	{
-		pStemmer = new Xapian::Stem(StringManip::toLowerCase(language));
+		pStemmer = new Xapian::Stem(StringManip::toLowerCase(stemLanguage));
 	}
 
 	Document doc;
@@ -79,6 +82,23 @@
 	return true;
 }
 
+static string getLanguageNameInEnglish(const string &language)
+{
+	for (unsigned int langNum = 0; langNum < Languages::m_count; ++langNum)
+	{
+		string intlLanguage = Languages::getIntlName(langNum);
+
+		if (strncasecmp(language.c_str(), intlLanguage.c_str(),
+			min(language.length(), intlLanguage.length())) == 0)
+		{
+			// That's the one !
+			return StringManip::toLowerCase(Languages::m_names[langNum]);
+		}
+	}
+
+	return language;
+}
+
 XapianEngine::XapianEngine(const string &database) :
 	SearchEngineInterface()
 {
@@ -183,7 +203,7 @@
 }
 
 void XapianEngine::stackQuery(const QueryProperties &queryProps,
-	stack<Xapian::Query> &queryStack, const string &language, bool followOperators)
+	stack<Xapian::Query> &queryStack, const string &stemLanguage, bool followOperators)
 {
 	Xapian::Query::op queryOp = Xapian::Query::OP_OR;
 	string term;
@@ -193,7 +213,7 @@
 	{
 		vector<string> andTerms;
 
-		if (extractWords(queryProps.getAndWords(), language, andTerms) == true)
+		if (extractWords(queryProps.getAndWords(), stemLanguage, andTerms) == true)
 		{
 #ifdef DEBUG
 			cout << "XapianEngine::stackQuery: OP_AND "  << andTerms.size() << endl;
@@ -211,7 +231,7 @@
 	{
 		vector<string> phraseTerms;
 
-		if (extractWords(queryProps.getPhrase(), language, phraseTerms) == true)
+		if (extractWords(queryProps.getPhrase(), stemLanguage, phraseTerms) == true)
 		{
 #ifdef DEBUG
 			cout << "XapianEngine::stackQuery: OP_PHRASE "  << phraseTerms.size() << endl;
@@ -229,7 +249,7 @@
 	{
 		vector<string> orTerms;
 
-		if (extractWords(queryProps.getAnyWords(), language, orTerms) == true)
+		if (extractWords(queryProps.getAnyWords(), stemLanguage, orTerms) == true)
 		{
 #ifdef DEBUG
 			cout << "XapianEngine::stackQuery: OP_OR "  << orTerms.size() << endl;
@@ -247,7 +267,7 @@
 	{
 		vector<string> notTerms;
 
-		if (extractWords(queryProps.getNotWords(), language, notTerms) == true)
+		if (extractWords(queryProps.getNotWords(), stemLanguage, notTerms) == true)
 		{
 #ifdef DEBUG
 			cout << "XapianEngine::stackQuery: OP_AND_NOT "  << notTerms.size() << endl;
@@ -312,12 +332,16 @@
 	}
 
 	// Get the language filter
-	if (queryProps.getLanguage().empty() == false)
+	string language = queryProps.getLanguage();
+	if (language.empty() == false)
 	{
 		vector<string> languageTerms;
 
 		term = "L";
-		term += StringManip::toLowerCase(queryProps.getLanguage());
+		term += getLanguageNameInEnglish(language);
+#ifdef DEBUG
+		cout << "XapianEngine::stackQuery: filter "  << term << endl;
+#endif
 		languageTerms.push_back(term);
 		if (followOperators == true)
 		{
@@ -351,10 +375,10 @@
 	{
 		vector<string> keywordTerms;
 		keywordTerms.push_back(keyword);
-		Xapian::Query keyworkQuery(Xapian::Query::OP_AND, keywordTerms.begin(), keywordTerms.end());
+		Xapian::Query keywordQuery(Xapian::Query::OP_AND, keywordTerms.begin(), keywordTerms.end());
 
 		// Query the database with the full query
-		return queryDatabase(keyworkQuery);
+		return queryDatabase(keywordQuery);
 	}
 	catch (const Xapian::Error &error)
 	{
@@ -377,7 +401,7 @@
 	try
 	{
 		stack<Xapian::Query> queryStack;
-		string language;
+		string stemLanguage;
 		unsigned int searchStep = 1;
 		bool followOperators = true;
 
@@ -387,7 +411,7 @@
 		// 3. if no results, don't follow operators and don't stem terms
 		// 4. if no results, don't follow operators and stem terms
 		// Steps 2 and 4 depend on a language being defined for the query
-		stackQuery(queryProps, queryStack, language, followOperators);
+		stackQuery(queryProps, queryStack, "", followOperators);
 		while (queryStack.empty() == false)
 		{
 			while (queryStack.size() > 1)
@@ -416,20 +440,20 @@
 					{
 						case 2:
 							followOperators = true;
-							language = queryProps.getLanguage();
-							if (language.empty() == false)
+							stemLanguage = queryProps.getLanguage();
+							if (stemLanguage.empty() == false)
 							{
 								break;
 							}
 							++searchStep;
 						case 3:
 							followOperators = false;
-							language.clear();
+							stemLanguage.clear();
 							break;
 						case 4:
 							followOperators = false;
-							language = queryProps.getLanguage();
-							if (language.empty() == false)
+							stemLanguage = queryProps.getLanguage();
+							if (stemLanguage.empty() == false)
 							{
 								break;
 							}
@@ -446,7 +470,8 @@
 #ifdef DEBUG
 					cout << "XapianEngine::runQuery: trying step " << searchStep << endl;
 #endif
-					stackQuery(queryProps, queryStack, language, followOperators);
+					stackQuery(queryProps, queryStack,
+						getLanguageNameInEnglish(stemLanguage), followOperators);
 					continue;
 				}
 

Modified: trunk/Search/XapianEngine.h
===================================================================
--- trunk/Search/XapianEngine.h	2005-12-30 12:12:53 UTC (rev 33)
+++ trunk/Search/XapianEngine.h	2005-12-30 13:46:55 UTC (rev 34)
@@ -50,7 +50,7 @@
 		bool queryDatabase(Xapian::Query &query);
 
 		void stackQuery(const QueryProperties &queryProps,
-			std::stack<Xapian::Query> &queryStack, const string &language,
+			std::stack<Xapian::Query> &queryStack, const string &stemLanguage,
 			bool followOperators);
 
 	private:

Modified: trunk/po/en_GB.po
===================================================================
--- trunk/po/en_GB.po	2005-12-30 12:12:53 UTC (rev 33)
+++ trunk/po/en_GB.po	2005-12-30 13:46:55 UTC (rev 34)
@@ -17,10 +17,10 @@
 #, fuzzy
 msgid ""
 msgstr ""
-"Project-Id-Version: pinot 0.20\n"
+"Project-Id-Version: pinot 0.35\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2005-12-08 19:20+0800\n"
-"PO-Revision-Date: 2005-12-08 19:20+0800\n"
+"POT-Creation-Date: 2005-12-30 17:20+0800\n"
+"PO-Revision-Date: 2005-12-30 17:20+0800\n"
 "Last-Translator: Fabrice Colin <colinf at chez.com>\n"
 "Language-Team: en_GB <colinf at chez.com>\n"
 "MIME-Version: 1.0\n"

Modified: trunk/po/fr_FR.po
===================================================================
--- trunk/po/fr_FR.po	2005-12-30 12:12:53 UTC (rev 33)
+++ trunk/po/fr_FR.po	2005-12-30 13:46:55 UTC (rev 34)
@@ -17,10 +17,10 @@
 #, fuzzy
 msgid ""
 msgstr ""
-"Project-Id-Version: pinot 0.20\n"
+"Project-Id-Version: pinot 0.35\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2005-12-08 19:20+0800\n"
-"PO-Revision-Date: 2005-12-08 19:20+0800\n"
+"POT-Creation-Date: 2005-12-30 17:20+0800\n"
+"PO-Revision-Date: 2005-12-30 17:20+0800\n"
 "Last-Translator: Fabrice Colin <colinf at chez.com>\n"
 "Language-Team: en_GB <colinf at chez.com>\n"
 "MIME-Version: 1.0\n"
@@ -423,7 +423,7 @@
 
 #: UI/GTK2/src/mainWindow_glade.cc:195 UI/GTK2/src/mainWindow_glade.cc:231
 msgid "_Index"
-msgstr "Indexer"
+msgstr "Index"
 
 #: UI/GTK2/src/mainWindow_glade.cc:198
 msgid "List Contents Of"
@@ -693,7 +693,7 @@
 
 #: UI/GTK2/src/queryDialog_glade.cc:73
 msgid "File name:"
-msgstr "Nom de machine:"
+msgstr "Nom de ficher:"
 
 #: UI/GTK2/src/queryDialog_glade.cc:74
 msgid "Number of results:"
@@ -701,11 +701,11 @@
 
 #: UI/GTK2/src/queryDialog_glade.cc:77
 msgid "Host name:"
-msgstr "Nom de fichier:"
+msgstr "Nom de machine:"
 
 #: UI/GTK2/src/queryDialog_glade.cc:78
 msgid "None of the words:"
-msgstr "Nombre de resultats:"
+msgstr "Aucun des mots:"
 
 #: UI/GTK2/src/queryDialog_glade.cc:84
 msgid "Limit to documents that match"
@@ -717,15 +717,15 @@
 
 #: UI/GTK2/src/queryDialog_glade.cc:88
 msgid "the language:"
-msgstr "aucun des mots"
+msgstr "la langue"
 
 #: UI/GTK2/src/queryDialog_glade.cc:92
 msgid "all the words:"
-msgstr "la langue"
+msgstr "tous les mots"
 
 #: UI/GTK2/src/queryDialog_glade.cc:93
 msgid "the label:"
-msgstr "tous les mots"
+msgstr "l'etiquette"
 
 #: UI/GTK2/src/queryDialog_glade.cc:98
 msgid "Advanced"

Modified: trunk/textcat_conf.txt
===================================================================
--- trunk/textcat_conf.txt	2005-12-30 12:12:53 UTC (rev 33)
+++ trunk/textcat_conf.txt	2005-12-30 13:46:55 UTC (rev 34)
@@ -1,6 +1,7 @@
 #
 # libtextcat 2.2 config file
 # The following languages are supported by Xapian::Stem
+# Languages names MUST be in English
 #
 /usr/share/libtextcat/LM/english.lm                     english
 /usr/share/libtextcat/LM/spanish.lm                     spanish



From fabricecolin at berlios.de  Fri Dec 30 14:47:31 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 30 Dec 2005 14:47:31 +0100
Subject: [Pinot-svn] r35 - trunk
Message-ID: <200512301347.jBUDlV1O014973@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-30 14:47:31 +0100 (Fri, 30 Dec 2005)
New Revision: 35

Modified:
   trunk/TODO
Log:
-4 +2 items.


Modified: trunk/TODO
===================================================================
--- trunk/TODO	2005-12-30 13:46:55 UTC (rev 34)
+++ trunk/TODO	2005-12-30 13:47:31 UTC (rev 35)
@@ -23,7 +23,8 @@
 - Add csourcesearch.net
 - Add http://www.patentcommons.org/commons/patentsearch.php
 - Apply Pinot specific filters (eg "L" for language) on internal indices only
-- Use Xapian's QueryParser, map fields (label, language, title etc...) to prefixes
+- Assuming text is tokenized a la omindex, use Xapian's QueryParser, map fields
+  (label, language, title) to prefixes, etc...
 
 Collect
 - Comply with robot stuff defined at http://www.robotstxt.org/
@@ -32,7 +33,6 @@
 - Make download timeout configurable
 - Investigate replacing neon (and gsoap ?) with libsoup
 - Support for HTML frames
-- Write a tokenizer for RFCs that breaks chapters into individual documents
 - Allow to cache documents that had to be converted ? eg PDF, MS Word
 - Use poppler for the PDF tokenizer
 
@@ -64,7 +64,6 @@
 - Replace Mozilla GTK embed with GTK WebCore or latest gtkhtml, or drop altogether ?
 - Is it possible to build against Firefox instead of the Mozilla suite ?
 - Highlight search terms
-- Fix crash with documents that link to images with https
 
 Mail
 - Find out what kind of locking scheme Mozilla uses (POSIX lock ?) and use that
@@ -77,8 +76,6 @@
     Date: Thu, 25 Aug 2005 11:04:49 +0800
   +0800 is basically same as SGT. At the moment the date is assumed to be GMT !
 - Mail messages with attachements are not indexed
-- Check that labels are removed when a message is unindexed (eg because it's no longer
-  in the mail account)
 
 UI
 - Switching back and forth between grouping modes messes up results rankings : check scores
@@ -94,11 +91,12 @@
 - Replace Combobox objects with ComboboxText's (glademm support required)
 - Replace glademm with libglademm ?
 - Show extract instead of URL in index list
-- At startup, don't switch to the Index tab when listing the documents index
 - Show activity when mail is being indexed
 - Update Last Run after the query has completed
 - Add a Recent Import section that relies on documents timestamps
 - Filter documents by language, similarly to how labels are shown
 - Save query expander and extract field status in config file
 - Enable to save live queries
+- Clean up method names
+- Prefer ustring to string whenever possible
 



From fabricecolin at berlios.de  Fri Dec 30 15:25:22 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 30 Dec 2005 15:25:22 +0100
Subject: [Pinot-svn] r36 - in trunk: Index Search UI/GTK2/src Utils
Message-ID: <200512301425.jBUEPM0i019482@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-30 15:25:21 +0100 (Fri, 30 Dec 2005)
New Revision: 36

Modified:
   trunk/Index/XapianIndex.cpp
   trunk/Search/XapianEngine.cpp
   trunk/UI/GTK2/src/PinotSettings.cpp
   trunk/UI/GTK2/src/pinot.cc
   trunk/Utils/Languages.cpp
   trunk/Utils/Languages.h
Log:
Save language names in English, load in current locale.


Modified: trunk/Index/XapianIndex.cpp
===================================================================
--- trunk/Index/XapianIndex.cpp	2005-12-30 13:47:31 UTC (rev 35)
+++ trunk/Index/XapianIndex.cpp	2005-12-30 14:25:21 UTC (rev 36)
@@ -24,7 +24,6 @@
 #include <iostream>
 #include <fstream>
 #include <algorithm>
-#include <utility>
 
 #include "Languages.h"
 #include "StringManip.h"
@@ -37,7 +36,6 @@
 
 using std::string;
 using std::set;
-using std::min;
 
 // This puts a limit to terms length.
 const unsigned int XapianIndex::m_maxTermLength = 64;
@@ -368,20 +366,8 @@
 			string record = doc.get_data();
 			if (record.empty() == false)
 			{
-				string language = StringManip::extractField(record, "language=", "");
+				string language = Languages::toLocale(StringManip::extractField(record, "language=", ""));
 
-				// Get the language name in the current locale
-				for (unsigned int langNum = 0; langNum < Languages::m_count; ++langNum)
-				{
-					if (strncasecmp(language.c_str(), Languages::m_names[langNum],
-						min(language.length(), strlen(Languages::m_names[langNum]))) == 0)
-					{
-						// That's the one !
-						language = Languages::getIntlName(langNum);
-						break;
-					}
-				}
-
 				docInfo = DocumentInfo(StringManip::extractField(record, "caption=", "\n"),
 					StringManip::extractField(record, "url=", "\n"),
 					StringManip::extractField(record, "type=", "\n"),

Modified: trunk/Search/XapianEngine.cpp
===================================================================
--- trunk/Search/XapianEngine.cpp	2005-12-30 13:47:31 UTC (rev 35)
+++ trunk/Search/XapianEngine.cpp	2005-12-30 14:25:21 UTC (rev 36)
@@ -20,7 +20,6 @@
 #include <string>
 #include <vector>
 #include <iostream>
-#include <utility>
 
 #include "Languages.h"
 #include "StringManip.h"
@@ -35,7 +34,6 @@
 using std::cout;
 using std::cerr;
 using std::endl;
-using std::min;
 
 static bool extractWords(const string &text, const string &stemLanguage, vector<string> &wordsList)
 {
@@ -82,23 +80,6 @@
 	return true;
 }
 
-static string getLanguageNameInEnglish(const string &language)
-{
-	for (unsigned int langNum = 0; langNum < Languages::m_count; ++langNum)
-	{
-		string intlLanguage = Languages::getIntlName(langNum);
-
-		if (strncasecmp(language.c_str(), intlLanguage.c_str(),
-			min(language.length(), intlLanguage.length())) == 0)
-		{
-			// That's the one !
-			return StringManip::toLowerCase(Languages::m_names[langNum]);
-		}
-	}
-
-	return language;
-}
-
 XapianEngine::XapianEngine(const string &database) :
 	SearchEngineInterface()
 {
@@ -338,7 +319,7 @@
 		vector<string> languageTerms;
 
 		term = "L";
-		term += getLanguageNameInEnglish(language);
+		term += StringManip::toLowerCase(Languages::toEnglish(language));
 #ifdef DEBUG
 		cout << "XapianEngine::stackQuery: filter "  << term << endl;
 #endif
@@ -471,7 +452,7 @@
 					cout << "XapianEngine::runQuery: trying step " << searchStep << endl;
 #endif
 					stackQuery(queryProps, queryStack,
-						getLanguageNameInEnglish(stemLanguage), followOperators);
+						Languages::toEnglish(stemLanguage), followOperators);
 					continue;
 				}
 

Modified: trunk/UI/GTK2/src/PinotSettings.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotSettings.cpp	2005-12-30 13:47:31 UTC (rev 35)
+++ trunk/UI/GTK2/src/PinotSettings.cpp	2005-12-30 14:25:21 UTC (rev 36)
@@ -30,6 +30,7 @@
 #include <libxml++/nodes/textnode.h>
 
 #include "config.h"
+#include "Languages.h"
 #include "NLS.h"
 #include "PluginWebEngine.h"
 #include "PinotSettings.h"
@@ -474,7 +475,7 @@
 		}
 		else if (nodeName == "language")
 		{
-			queryProps.setLanguage(nodeContent);
+			queryProps.setLanguage(Languages::toLocale(nodeContent));
 		}
 		else if (nodeName == "hostfilter")
 		{
@@ -796,7 +797,7 @@
 		addChildElement(pElem, "hostfilter", queryIter->second.getHostFilter());
 		addChildElement(pElem, "filefilter", queryIter->second.getFileFilter());
 		addChildElement(pElem, "labelfilter", queryIter->second.getLabelFilter());
-		addChildElement(pElem, "language", queryIter->second.getLanguage());
+		addChildElement(pElem, "language", Languages::toEnglish(queryIter->second.getLanguage()));
 		sprintf(numStr, "%u", queryIter->second.getMaximumResultsCount());
 		addChildElement(pElem, "maxresults", numStr);
 		addChildElement(pElem, "index", (queryIter->second.getIndexResults() ? "ALL" : "NONE"));

Modified: trunk/UI/GTK2/src/pinot.cc
===================================================================
--- trunk/UI/GTK2/src/pinot.cc	2005-12-30 13:47:31 UTC (rev 35)
+++ trunk/UI/GTK2/src/pinot.cc	2005-12-30 14:25:21 UTC (rev 36)
@@ -114,6 +114,20 @@
 	cout.rdbuf(outputFile.rdbuf());
 	cerr.rdbuf(outputFile.rdbuf());
 
+	// Localize language names
+	Languages::setIntlName(0, _("Danish"));
+	Languages::setIntlName(1, _("Dutch"));
+	Languages::setIntlName(2, _("English"));
+	Languages::setIntlName(3, _("Finnish"));
+	Languages::setIntlName(4, _("French"));
+	Languages::setIntlName(5, _("German"));
+	Languages::setIntlName(6, _("Italian"));
+	Languages::setIntlName(7, _("Norwegian"));
+	Languages::setIntlName(8, _("Portuguese"));
+	Languages::setIntlName(9, _("Russian"));
+	Languages::setIntlName(10, _("Spanish"));
+	Languages::setIntlName(11, _("Swedish"));
+
 	// Load the settings
 	settings.load();
 	settings.loadSearchEngines("/usr/share/pinot/engines");
@@ -153,20 +167,6 @@
 
 	atexit(closeAll);
 
-	// Localize language names
-	Languages::setIntlName(0, _("Danish"));
-	Languages::setIntlName(1, _("Dutch"));
-	Languages::setIntlName(2, _("English"));
-	Languages::setIntlName(3, _("Finnish"));
-	Languages::setIntlName(4, _("French"));
-	Languages::setIntlName(5, _("German"));
-	Languages::setIntlName(6, _("Italian"));
-	Languages::setIntlName(7, _("Norwegian"));
-	Languages::setIntlName(8, _("Portuguese"));
-	Languages::setIntlName(9, _("Russian"));
-	Languages::setIntlName(10, _("Spanish"));
-	Languages::setIntlName(11, _("Swedish"));
-
 	// Create and open the main dialog box
 	mainWindow mainBox;
 	m.run(mainBox);

Modified: trunk/Utils/Languages.cpp
===================================================================
--- trunk/Utils/Languages.cpp	2005-12-30 13:47:31 UTC (rev 35)
+++ trunk/Utils/Languages.cpp	2005-12-30 14:25:21 UTC (rev 36)
@@ -14,11 +14,15 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include <string.h>
+#include <utility>
+
 #include "Languages.h"
 
 using std::string;
 using std::map;
 using std::pair;
+using std::min;
 
 unsigned int Languages::m_count = 12;
 
@@ -56,3 +60,41 @@
 
 	return iter->second;
 }
+
+string Languages::toEnglish(const string &language)
+{
+	if (language.empty() == false)
+	{
+		for (unsigned int langNum = 0; langNum < Languages::m_count; ++langNum)
+		{
+			string intlLanguage = Languages::getIntlName(langNum);
+
+			if (strncasecmp(language.c_str(), intlLanguage.c_str(),
+				min(language.length(), intlLanguage.length())) == 0)
+			{
+				return Languages::m_names[langNum];
+			}
+		}
+	}
+
+	return language;
+}
+
+string Languages::toLocale(const string &language)
+{
+	if (language.empty() == false)
+	{
+		// Get the language name in the current locale
+		for (unsigned int langNum = 0; langNum < Languages::m_count; ++langNum)
+		{
+			if (strncasecmp(language.c_str(), Languages::m_names[langNum],
+				min(language.length(), strlen(Languages::m_names[langNum]))) == 0)
+			{
+				// That's the one !
+				return Languages::getIntlName(langNum);
+			}
+		}
+	}
+
+	return language;
+}

Modified: trunk/Utils/Languages.h
===================================================================
--- trunk/Utils/Languages.h	2005-12-30 13:47:31 UTC (rev 35)
+++ trunk/Utils/Languages.h	2005-12-30 14:25:21 UTC (rev 36)
@@ -28,9 +28,15 @@
 		/// Sets the name for the given code.
 		static bool setIntlName(unsigned int num, const std::string &name);
 
-		/// Gets the name for the given code.
+		/// Gets the name of the language at the given position.
 		static std::string getIntlName(unsigned int num);
 
+		/// Returns a language name, in English.
+		static std::string toEnglish(const std::string &language);
+
+		/// Returns a language name, in the current locale.
+		static std::string toLocale(const std::string &language);
+
 		static unsigned int m_count;
 		static char *m_codes[];
 		static char *m_names[];



From fabricecolin at berlios.de  Fri Dec 30 16:16:45 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Fri, 30 Dec 2005 16:16:45 +0100
Subject: [Pinot-svn] r37 - trunk/UI/GTK2/src
Message-ID: <200512301516.jBUFGjMN025281@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-30 16:16:45 +0100 (Fri, 30 Dec 2005)
New Revision: 37

Modified:
   trunk/UI/GTK2/src/importDialog_glade.cc
   trunk/UI/GTK2/src/indexDialog_glade.cc
   trunk/UI/GTK2/src/mainWindow_glade.cc
   trunk/UI/GTK2/src/prefsDialog_glade.cc
   trunk/UI/GTK2/src/propertiesDialog_glade.cc
   trunk/UI/GTK2/src/queryDialog_glade.cc
Log:
Removed unhelpful _("") from glademm-generated source.


Modified: trunk/UI/GTK2/src/importDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/importDialog_glade.cc	2005-12-30 14:25:21 UTC (rev 36)
+++ trunk/UI/GTK2/src/importDialog_glade.cc	2005-12-30 15:16:45 UTC (rev 37)
@@ -107,14 +107,12 @@
    locationEntry->set_visibility(true);
    locationEntry->set_editable(true);
    locationEntry->set_max_length(0);
-   locationEntry->set_text(_(""));
    locationEntry->set_has_frame(true);
    locationEntry->set_activates_default(false);
    titleEntry->set_flags(Gtk::CAN_FOCUS);
    titleEntry->set_visibility(true);
    titleEntry->set_editable(true);
    titleEntry->set_max_length(0);
-   titleEntry->set_text(_(""));
    titleEntry->set_has_frame(true);
    titleEntry->set_activates_default(false);
    locationLabel->set_alignment(0,0.5);

Modified: trunk/UI/GTK2/src/indexDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/indexDialog_glade.cc	2005-12-30 14:25:21 UTC (rev 36)
+++ trunk/UI/GTK2/src/indexDialog_glade.cc	2005-12-30 15:16:45 UTC (rev 37)
@@ -91,7 +91,6 @@
    locationEntry->set_visibility(true);
    locationEntry->set_editable(true);
    locationEntry->set_max_length(0);
-   locationEntry->set_text(_(""));
    locationEntry->set_has_frame(true);
    locationEntry->set_activates_default(false);
    locationButton->set_flags(Gtk::CAN_FOCUS);
@@ -121,7 +120,6 @@
    nameEntry->set_visibility(true);
    nameEntry->set_editable(true);
    nameEntry->set_max_length(0);
-   nameEntry->set_text(_(""));
    nameEntry->set_has_frame(true);
    nameEntry->set_activates_default(false);
    portSpinbutton->set_flags(Gtk::CAN_FOCUS);

Modified: trunk/UI/GTK2/src/mainWindow_glade.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-30 14:25:21 UTC (rev 36)
+++ trunk/UI/GTK2/src/mainWindow_glade.cc	2005-12-30 15:16:45 UTC (rev 37)
@@ -272,7 +272,6 @@
    liveQueryEntry->set_visibility(true);
    liveQueryEntry->set_editable(true);
    liveQueryEntry->set_max_length(0);
-   liveQueryEntry->set_text(_(""));
    liveQueryEntry->set_has_frame(true);
    liveQueryEntry->set_activates_default(false);
    findButton->set_flags(Gtk::CAN_FOCUS);

Modified: trunk/UI/GTK2/src/prefsDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog_glade.cc	2005-12-30 14:25:21 UTC (rev 36)
+++ trunk/UI/GTK2/src/prefsDialog_glade.cc	2005-12-30 15:16:45 UTC (rev 37)
@@ -150,7 +150,6 @@
    apiKeyEntry->set_visibility(true);
    apiKeyEntry->set_editable(true);
    apiKeyEntry->set_max_length(0);
-   apiKeyEntry->set_text(_(""));
    apiKeyEntry->set_has_frame(true);
    apiKeyEntry->set_activates_default(false);
    ignoreRobotsCheckbutton->set_flags(Gtk::CAN_FOCUS);
@@ -161,7 +160,6 @@
    browserEntry->set_visibility(true);
    browserEntry->set_editable(true);
    browserEntry->set_max_length(0);
-   browserEntry->set_text(_(""));
    browserEntry->set_has_frame(true);
    browserEntry->set_activates_default(false);
    browserButton->set_flags(Gtk::CAN_FOCUS);

Modified: trunk/UI/GTK2/src/propertiesDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/propertiesDialog_glade.cc	2005-12-30 14:25:21 UTC (rev 36)
+++ trunk/UI/GTK2/src/propertiesDialog_glade.cc	2005-12-30 15:16:45 UTC (rev 37)
@@ -86,7 +86,6 @@
    titleEntry->set_visibility(true);
    titleEntry->set_editable(true);
    titleEntry->set_max_length(0);
-   titleEntry->set_text(_(""));
    titleEntry->set_has_frame(true);
    titleEntry->set_activates_default(false);
    extractTextview->set_flags(Gtk::CAN_FOCUS);
@@ -127,7 +126,6 @@
    languageEntry->set_visibility(true);
    languageEntry->set_editable(false);
    languageEntry->set_max_length(0);
-   languageEntry->set_text(_(""));
    languageEntry->set_has_frame(true);
    languageEntry->set_activates_default(false);
    typeLabel->set_alignment(0,0.5);
@@ -140,7 +138,6 @@
    typeEntry->set_visibility(true);
    typeEntry->set_editable(false);
    typeEntry->set_max_length(0);
-   typeEntry->set_text(_(""));
    typeEntry->set_has_frame(true);
    typeEntry->set_activates_default(false);
    propertiesTable->set_row_spacings(0);

Modified: trunk/UI/GTK2/src/queryDialog_glade.cc
===================================================================
--- trunk/UI/GTK2/src/queryDialog_glade.cc	2005-12-30 14:25:21 UTC (rev 36)
+++ trunk/UI/GTK2/src/queryDialog_glade.cc	2005-12-30 15:16:45 UTC (rev 37)
@@ -116,7 +116,6 @@
    nameEntry->set_visibility(true);
    nameEntry->set_editable(true);
    nameEntry->set_max_length(0);
-   nameEntry->set_text(_(""));
    nameEntry->set_has_frame(true);
    nameEntry->set_activates_default(false);
    table1->set_row_spacings(0);
@@ -127,21 +126,18 @@
    anyEntry->set_visibility(true);
    anyEntry->set_editable(true);
    anyEntry->set_max_length(0);
-   anyEntry->set_text(_(""));
    anyEntry->set_has_frame(true);
    anyEntry->set_activates_default(false);
    hostNameEntry->set_flags(Gtk::CAN_FOCUS);
    hostNameEntry->set_visibility(true);
    hostNameEntry->set_editable(true);
    hostNameEntry->set_max_length(0);
-   hostNameEntry->set_text(_(""));
    hostNameEntry->set_has_frame(true);
    hostNameEntry->set_activates_default(false);
    fileNameEntry->set_flags(Gtk::CAN_FOCUS);
    fileNameEntry->set_visibility(true);
    fileNameEntry->set_editable(true);
    fileNameEntry->set_max_length(0);
-   fileNameEntry->set_text(_(""));
    fileNameEntry->set_has_frame(true);
    fileNameEntry->set_activates_default(false);
    resultsCountSpinbutton->set_flags(Gtk::CAN_FOCUS);
@@ -187,7 +183,6 @@
    notEntry->set_visibility(true);
    notEntry->set_editable(true);
    notEntry->set_max_length(0);
-   notEntry->set_text(_(""));
    notEntry->set_has_frame(true);
    notEntry->set_activates_default(false);
    tersmTable->set_row_spacings(0);
@@ -221,7 +216,6 @@
    phraseEntry->set_visibility(true);
    phraseEntry->set_editable(true);
    phraseEntry->set_max_length(0);
-   phraseEntry->set_text(_(""));
    phraseEntry->set_has_frame(true);
    phraseEntry->set_activates_default(false);
    phraseLabel->set_alignment(0,0.5);
@@ -240,7 +234,6 @@
    andEntry->set_visibility(true);
    andEntry->set_editable(true);
    andEntry->set_max_length(0);
-   andEntry->set_text(_(""));
    andEntry->set_has_frame(true);
    andEntry->set_activates_default(false);
    andLabel->set_alignment(0,0.5);



From fabricecolin at berlios.de  Sat Dec 31 12:23:02 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 31 Dec 2005 12:23:02 +0100
Subject: [Pinot-svn] r38 - in trunk: Tokenize Utils
Message-ID: <200512311123.jBVBN2CJ027049@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-31 12:23:01 +0100 (Sat, 31 Dec 2005)
New Revision: 38

Modified:
   trunk/Tokenize/HtmlTokenizer.cpp
   trunk/Utils/StringManip.cpp
   trunk/Utils/StringManip.h
Log:
Moved function removeLinkQuotes() to StringManip. Minor fix to META tags
extraction.


Modified: trunk/Tokenize/HtmlTokenizer.cpp
===================================================================
--- trunk/Tokenize/HtmlTokenizer.cpp	2005-12-30 15:16:45 UTC (rev 37)
+++ trunk/Tokenize/HtmlTokenizer.cpp	2005-12-31 11:23:01 UTC (rev 38)
@@ -28,44 +28,6 @@
 
 using namespace std;
 
-/// Removes double and single quotes in links or any other attribute.
-static string removeLinkQuotes(const string &quotedLink)
-{
-	string link;
-
-	if (quotedLink[0] == '"')
-	{
-		string::size_type closingQuotePos = quotedLink.find("\"", 1);
-		if (closingQuotePos != string::npos)
-		{
-			link = quotedLink.substr(1, closingQuotePos - 1);
-		}
-	}
-	else if (quotedLink[0] == '\'')
-	{
-		string::size_type closingQuotePos = quotedLink.find("'", 1);
-		if (closingQuotePos != string::npos)
-		{
-			link = quotedLink.substr(1, closingQuotePos - 1);
-		}
-	}
-	else
-	{
-		// There are no quotes, so just look for the first space, if any
-		string::size_type spacePos = quotedLink.find(" ");
-		if (spacePos != string::npos)
-		{
-			link = quotedLink.substr(0, spacePos);
-		}
-		else
-		{
-			link = quotedLink;
-		}
-	}
-
-	return link;
-}
-
 HtmlTokenizer::HtmlTokenizer(const Document *pDocument, unsigned int linksStartAtPos) :
 	Tokenizer(NULL),
 	m_pHtmlDocument(NULL),
@@ -200,7 +162,7 @@
 			if ((extractMetaTags == true) &&
 				(regexec(&metaRegex, tag.c_str(), nMetaMatches, pMetaMatches, 
 					REG_NOTBOL|REG_NOTEOL) == 0) &&
-				(pLinksMatches[nMetaMatches - 1].rm_so != -1))
+				(pMetaMatches[nMetaMatches - 1].rm_so != -1))
 			{
 				string tmp, metaName, metaContent;
 
@@ -208,13 +170,13 @@
 				tmp = tag.substr(pMetaMatches[1].rm_so,
 					pMetaMatches[1].rm_eo - pMetaMatches[1].rm_so);
 				// Remove quotes
-				metaName = removeLinkQuotes(tmp);
+				metaName = StringManip::removeQuotes(tmp);
 
 				// META tag content
 				tmp = tag.substr(pMetaMatches[2].rm_so,
 					pMetaMatches[2].rm_eo - pMetaMatches[2].rm_so);
 				// Remove quotes
-				metaContent = removeLinkQuotes(tmp);
+				metaContent = StringManip::removeQuotes(tmp);
 #ifdef DEBUG_TOKENIZER
 				cout << "HtmlTokenizer::parseHTML: found META tag " << metaName << ": " << metaContent << endl;
 #endif
@@ -244,7 +206,7 @@
 				}
 
 				// Remove quotes
-				link = removeLinkQuotes(quotedLink);
+				link = StringManip::removeQuotes(quotedLink);
 				linkOpenPos = startPos - 1;
 
 				// Remember to get the name of the link

Modified: trunk/Utils/StringManip.cpp
===================================================================
--- trunk/Utils/StringManip.cpp	2005-12-30 15:16:45 UTC (rev 37)
+++ trunk/Utils/StringManip.cpp	2005-12-31 11:23:01 UTC (rev 38)
@@ -137,6 +137,44 @@
 	return count;	
 }
 
+/// Removes double and single quotes in links or any other attribute.
+string StringManip::removeQuotes(const string &str)
+{
+	string unquotedText;
+
+	if (str[0] == '"')
+	{
+		string::size_type closingQuotePos = str.find("\"", 1);
+		if (closingQuotePos != string::npos)
+		{
+			unquotedText = str.substr(1, closingQuotePos - 1);
+		}
+	}
+	else if (str[0] == '\'')
+	{
+		string::size_type closingQuotePos = str.find("'", 1);
+		if (closingQuotePos != string::npos)
+		{
+			unquotedText = str.substr(1, closingQuotePos - 1);
+		}
+	}
+	else
+	{
+		// There are no quotes, so just look for the first space, if any
+		string::size_type spacePos = str.find(" ");
+		if (spacePos != string::npos)
+		{
+			unquotedText = str.substr(0, spacePos);
+		}
+		else
+		{
+			unquotedText = str;
+		}
+	}
+
+	return unquotedText;
+}
+
 /// Hashes a string.
 string StringManip::hashString(string &str)
 {

Modified: trunk/Utils/StringManip.h
===================================================================
--- trunk/Utils/StringManip.h	2005-12-30 15:16:45 UTC (rev 37)
+++ trunk/Utils/StringManip.h	2005-12-31 11:23:01 UTC (rev 38)
@@ -40,6 +40,9 @@
 		/// Removes characters from a string.
 		static unsigned int removeCharacters(std::string &str, const std::string &characters);
 
+		/// Removes double and single quotes.
+		static std::string removeQuotes(const std::string &str);
+
 		/// Hashes a string.
 		static std::string hashString(std::string &str);
 



From fabricecolin at berlios.de  Sat Dec 31 12:23:59 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 31 Dec 2005 12:23:59 +0100
Subject: [Pinot-svn] r39 - trunk/Utils
Message-ID: <200512311123.jBVBNxfi027135@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-31 12:23:59 +0100 (Sat, 31 Dec 2005)
New Revision: 39

Modified:
   trunk/Utils/HtmlDocument.cpp
   trunk/Utils/HtmlDocument.h
Log:
Attempt to extract title and content type from HTML head.


Modified: trunk/Utils/HtmlDocument.cpp
===================================================================
--- trunk/Utils/HtmlDocument.cpp	2005-12-31 11:23:01 UTC (rev 38)
+++ trunk/Utils/HtmlDocument.cpp	2005-12-31 11:23:59 UTC (rev 39)
@@ -14,12 +14,21 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <regex.h>
 #include <ctype.h>
-#include <stdlib.h>
+#include <iostream>
+#include <utility>
 
 #include "HtmlDocument.h"
+#include "StringManip.h"
 
+using std::cout;
+using std::endl;
 using std::string;
+using std::min;
 
 HtmlDocument::HtmlDocument(const string &title, const string &location,
 	const string &type, const string &language) :
@@ -36,6 +45,71 @@
 {
 }
 
+void HtmlDocument::parseHead(void)
+{
+	char *pBodyStart = strstr(m_pData, "<body");
+	if (pBodyStart == NULL)
+	{
+		pBodyStart = strstr(m_pData, "<BODY");
+	}
+	if (pBodyStart != NULL)
+	{
+		string htmlHead(m_pData, pBodyStart - m_pData);
+		regex_t titleRegex, httpEquivRegex;
+		regmatch_t pTitleMatches[3];
+		regmatch_t pHttpEquivMatches[3];
+		int titleMatches = 3, httpEquivMatches = 3;
+
+		// Look for a title
+		if (regcomp(&titleRegex, "<title([^>]*)>(.*)</title", REG_EXTENDED|REG_ICASE) == 0)
+		{
+			if ((regexec(&titleRegex, htmlHead.c_str(), titleMatches,
+					pTitleMatches, REG_NOTBOL|REG_NOTEOL) == 0) &&
+				(pTitleMatches[titleMatches - 1].rm_so != -1))
+			{
+				string title = htmlHead.substr(pTitleMatches[2].rm_so,
+					pTitleMatches[2].rm_eo - pTitleMatches[2].rm_so);
+
+				if (title.empty() == false)
+				{
+					// Override the title
+					m_title = title;
+				}
+			}
+		}
+		// ...and a Content-Type
+		if (regcomp(&httpEquivRegex, "<meta http-equiv=([^>]*) content=([^>]*)>", REG_EXTENDED|REG_ICASE) == 0)
+		{
+			if ((regexec(&httpEquivRegex, htmlHead.c_str(), httpEquivMatches,
+					pHttpEquivMatches, REG_NOTBOL|REG_NOTEOL) == 0) &&
+				(pHttpEquivMatches[httpEquivMatches - 1].rm_so != -1))
+			{
+				string name = StringManip::removeQuotes(
+					htmlHead.substr(pHttpEquivMatches[1].rm_so,
+					pHttpEquivMatches[1].rm_eo - pHttpEquivMatches[1].rm_so));
+				string content = StringManip::removeQuotes(
+					htmlHead.substr(pHttpEquivMatches[2].rm_so,
+					pHttpEquivMatches[2].rm_eo - pHttpEquivMatches[2].rm_so));
+
+				if ((content.empty() == false) &&
+					(strncasecmp(name.c_str(), "Content-Type",
+						min((int)name.length(), 12)) == 0))
+				{
+					// Override the type
+					m_type = content;
+				}
+			}
+		}
+#ifdef DEBUG
+		cout << "HtmlDocument::parseHead: extracted title " << m_title <<
+			", type " << m_type << endl;
+#endif
+
+		regfree(&titleRegex);
+		regfree(&httpEquivRegex);
+	}
+}
+
 /// Copies the given data in the document.
 bool HtmlDocument::setData(const char *data, unsigned int length)
 {
@@ -66,7 +140,24 @@
 			}
 		}
 		m_dataLength = length;
+
+		parseHead();
+
+		return true;
 	}
 
-	return true;
+	return false;
 }
+
+/// Maps the given file.
+bool HtmlDocument::setDataFromFile(const string &fileName)
+{
+	if (Document::setDataFromFile(fileName) == true)
+	{
+		parseHead();
+
+		return true;
+	}
+
+	return false;
+}

Modified: trunk/Utils/HtmlDocument.h
===================================================================
--- trunk/Utils/HtmlDocument.h	2005-12-31 11:23:01 UTC (rev 38)
+++ trunk/Utils/HtmlDocument.h	2005-12-31 11:23:59 UTC (rev 39)
@@ -32,6 +32,12 @@
 		/// Copies the given data in the document.
 		virtual bool setData(const char *data, unsigned int length);
 
+		/// Maps the given file.
+		virtual bool setDataFromFile(const std::string &fileName);
+
+	protected:
+		void parseHead(void);
+
 };
 	
 #endif // _HTML_DOCUMENT_H



From fabricecolin at berlios.de  Sat Dec 31 12:25:03 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 31 Dec 2005 12:25:03 +0100
Subject: [Pinot-svn] r40 - trunk/Collect
Message-ID: <200512311125.jBVBP36F027262@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-31 12:25:03 +0100 (Sat, 31 Dec 2005)
New Revision: 40

Modified:
   trunk/Collect/FileCollector.cpp
   trunk/Collect/NeonDownloader.cpp
Log:
Return an HtmlDocument object if the type is HTML.


Modified: trunk/Collect/FileCollector.cpp
===================================================================
--- trunk/Collect/FileCollector.cpp	2005-12-31 11:23:59 UTC (rev 39)
+++ trunk/Collect/FileCollector.cpp	2005-12-31 11:25:03 UTC (rev 40)
@@ -17,6 +17,7 @@
 #include <iostream>
 #include <algorithm>
 
+#include "HtmlDocument.h"
 #include "HtmlTokenizer.h"
 #include "MIMEScanner.h"
 #include "Url.h"
@@ -40,6 +41,7 @@
 /// Retrieves the specified document; NULL if error.
 Document *FileCollector::retrieveUrl(const DocumentInfo &docInfo)
 {
+	Document *fileDocument = NULL;
 	Url thisUrl(docInfo.getLocation());
 	string protocol = thisUrl.getProtocol();
 
@@ -57,18 +59,22 @@
 
 	// Determine the file type
 	string fileType = MIMEScanner::scanFile(fileLocation);
-
-	// Use the URL as title
-	Document *fileDocument = new Document(docInfo.getTitle(),
-		docInfo.getLocation(), docInfo.getType(), docInfo.getLanguage());
+	// Is it an HTML type ?
+	if (fileType.find("html") != string::npos)
+	{
+		fileDocument = new HtmlDocument(docInfo.getTitle(),
+			docInfo.getLocation(), fileType, docInfo.getLanguage());
+	}
+	else
+	{
+		fileDocument = new Document(docInfo.getTitle(),
+			docInfo.getLocation(), fileType, docInfo.getLanguage());
+	}
 	if (fileDocument->setDataFromFile(fileLocation) == false)
 	{
 		delete fileDocument;
 		return NULL;
 	}
 
-	unsigned int fileLength = 0;
-	const char *fileContent = fileDocument->getData(fileLength);
-
 	return fileDocument;
 }

Modified: trunk/Collect/NeonDownloader.cpp
===================================================================
--- trunk/Collect/NeonDownloader.cpp	2005-12-31 11:23:59 UTC (rev 39)
+++ trunk/Collect/NeonDownloader.cpp	2005-12-31 11:25:03 UTC (rev 40)
@@ -411,8 +411,8 @@
 	{
 		if (statusCode < 400)
 		{
-			// Is it an html type ?
-			if (g_contentTypeHeaderValue.find("htm") != string::npos)
+			// Is it an HTML type ?
+			if (g_contentTypeHeaderValue.find("html") != string::npos)
 			{
 				urlDocument = new HtmlDocument(docInfo.getTitle(), url,
 					g_contentTypeHeaderValue, docInfo.getLanguage());



From fabricecolin at berlios.de  Sat Dec 31 12:26:01 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 31 Dec 2005 12:26:01 +0100
Subject: [Pinot-svn] r41 - trunk/Search
Message-ID: <200512311126.jBVBQ1Na027364@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-31 12:26:01 +0100 (Sat, 31 Dec 2005)
New Revision: 41

Modified:
   trunk/Search/SearchEngineInterface.cpp
   trunk/Search/SearchEngineInterface.h
   trunk/Search/WebEngine.cpp
Log:
Added getResultsCharset() to help with charset conversions.


Modified: trunk/Search/SearchEngineInterface.cpp
===================================================================
--- trunk/Search/SearchEngineInterface.cpp	2005-12-31 11:25:03 UTC (rev 40)
+++ trunk/Search/SearchEngineInterface.cpp	2005-12-31 11:26:01 UTC (rev 41)
@@ -64,6 +64,12 @@
 	return m_resultsList;
 }
 
+/// Returns the charset for the previous query's results.
+string SearchEngineInterface::getResultsCharset(void) const
+{
+	return m_charset;
+}
+
 void SearchEngineInterface::setHostNameFilter(const string &filter)
 {
 	m_hostFilter = filter;

Modified: trunk/Search/SearchEngineInterface.h
===================================================================
--- trunk/Search/SearchEngineInterface.h	2005-12-31 11:25:03 UTC (rev 40)
+++ trunk/Search/SearchEngineInterface.h	2005-12-31 11:26:01 UTC (rev 41)
@@ -52,6 +52,9 @@
 		/// Returns the results for the previous query.
 		virtual const vector<Result> &getResults(void) const;
 
+		/// Returns the charset for the previous query's results.
+		virtual string getResultsCharset(void) const;
+
 	protected:
 		string m_key;
 		unsigned int m_callsCount;
@@ -60,6 +63,7 @@
 		string m_hostFilter;
 		string m_fileFilter;
 		vector<Result> m_resultsList;
+		string m_charset;
 
 		SearchEngineInterface();
 

Modified: trunk/Search/WebEngine.cpp
===================================================================
--- trunk/Search/WebEngine.cpp	2005-12-31 11:25:03 UTC (rev 40)
+++ trunk/Search/WebEngine.cpp	2005-12-31 11:26:01 UTC (rev 41)
@@ -21,6 +21,7 @@
 #include <algorithm>
 
 #include "HtmlTokenizer.h"
+#include "StringManip.h"
 #include "Url.h"
 #include "DownloaderFactory.h"
 #include "WebEngine.h"
@@ -37,6 +38,8 @@
 
 Document *WebEngine::downloadPage(const DocumentInfo &docInfo)
 {
+	m_charset.clear();
+
 	// Any type of downloader will do...
 	DownloaderInterface *myDownloader = DownloaderFactory::getDownloader("http", "");
 	if (myDownloader == NULL)
@@ -45,6 +48,17 @@
 	}
 
 	Document *urlDoc = myDownloader->retrieveUrl(docInfo);
+	if (urlDoc != NULL)
+	{
+		string contentType = urlDoc->getType();
+
+		// Was a charset specified ?
+		string::size_type pos = contentType.find("charset=");
+		if (pos != string::npos)
+		{
+			m_charset = StringManip::removeQuotes(contentType.substr(pos + 8));
+		}
+	}
 	delete myDownloader;
 
 	return urlDoc;



From fabricecolin at berlios.de  Sat Dec 31 14:11:33 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 31 Dec 2005 14:11:33 +0100
Subject: [Pinot-svn] r42 - trunk/UI/GTK2/src
Message-ID: <200512311311.jBVDBXxX017346@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-31 14:11:29 +0100 (Sat, 31 Dec 2005)
New Revision: 42

Modified:
   trunk/UI/GTK2/src/PinotUtils.cpp
   trunk/UI/GTK2/src/PinotUtils.h
   trunk/UI/GTK2/src/ResultsTree.cpp
   trunk/UI/GTK2/src/ResultsTree.h
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
   trunk/UI/GTK2/src/importDialog.cc
   trunk/UI/GTK2/src/mainWindow.cc
   trunk/UI/GTK2/src/prefsDialog.cc
   trunk/UI/GTK2/src/queryDialog.cc
Log:
Somewhat better charset conversion, especially for results, for which the
charset obtained by the engine or the document is taken into account. Stuff
that's already in UTF-8 is kept that way.


Modified: trunk/UI/GTK2/src/PinotUtils.cpp
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.cpp	2005-12-31 11:26:01 UTC (rev 41)
+++ trunk/UI/GTK2/src/PinotUtils.cpp	2005-12-31 13:11:29 UTC (rev 42)
@@ -138,16 +138,41 @@
 	return treeColumn;
 }
 
-/// Converts to UTF-8, catches conversion errors
-ustring to_utf8(string text, ustring fallback)
+/// Converts to UTF-8.
+ustring to_utf8(const string &text)
 {
+	std::string charset;
+
+	// Get the locale charset
+	get_charset(charset);
+	// Call overload
+	return to_utf8(text, charset);
+}
+
+/// Converts from the given charset to UTF-8.
+ustring to_utf8(const string &text, const string &charset)
+{
+	if ((charset == "UTF-8") ||
+		(charset == "utf-8"))
+	{
+		// No conversion necessary
+		return text;
+	}
+
 	try
 	{
-		return locale_to_utf8(text);
+		if (charset.empty() == false)
+		{
+			return convert_with_fallback(text, "UTF-8", charset);
+		}
+		else
+		{
+			return locale_to_utf8(text);
+		}
 	}
 	catch (ConvertError &ce)
 	{
 	}
 
-	return fallback;
+	return "";
 }

Modified: trunk/UI/GTK2/src/PinotUtils.h
===================================================================
--- trunk/UI/GTK2/src/PinotUtils.h	2005-12-31 11:26:01 UTC (rev 41)
+++ trunk/UI/GTK2/src/PinotUtils.h	2005-12-31 13:11:29 UTC (rev 42)
@@ -40,7 +40,10 @@
 	const Gtk::TreeModelColumnBase& modelColumn,
 	const  Gtk::TreeViewColumn::SlotCellData &renderTextAndIconCell);
 
-/// Converts to UTF-8, catches conversion errors
-Glib::ustring to_utf8(std::string text, Glib::ustring fallback = Glib::ustring(""));
+/// Converts to UTF-8.
+Glib::ustring to_utf8(const std::string &text);
 
+/// Converts from the given charset to UTF-8.
+Glib::ustring to_utf8(const std::string &text, const std::string &charset);
+
 #endif // _PINOTUTILS_HH

Modified: trunk/UI/GTK2/src/ResultsTree.cpp
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-31 11:26:01 UTC (rev 41)
+++ trunk/UI/GTK2/src/ResultsTree.cpp	2005-12-31 13:11:29 UTC (rev 42)
@@ -347,7 +347,7 @@
 			}
 
 			RefPtr<TextBuffer> refBuffer = m_extractTextview->get_buffer();
-			refBuffer->set_text(to_utf8(extract));
+			refBuffer->set_text(extract);
 			// The extract is not editable
 			m_extractTextview->set_editable(false);
 			m_extractTextview->set_cursor_visible(false);
@@ -391,7 +391,7 @@
 // Returns true if something was added to the tree.
 //
 bool ResultsTree::addResults(QueryProperties &queryProps, const string &engineName,
-	const vector<Result> &resultsList, bool groupBySearchEngine)
+	const vector<Result> &resultsList, const string &charset, bool groupBySearchEngine)
 {
 	std::map<string, TreeModel::iterator> updatedGroups;
 	string registeredEngineName = engineName;
@@ -483,17 +483,20 @@
 
 			// Has the result's ranking changed ?
 			float oldestScore = 0;
-			float previousScore = history.hasItem(queryName, registeredEngineName, location, oldestScore);
+			float previousScore = history.hasItem(queryName, registeredEngineName,
+				location, oldestScore);
 			if (previousScore > 0)
 			{
 				// Update this result whatever the current and previous rankings were
-				history.updateItem(queryName, registeredEngineName, location, title, extract, language, currentScore);
+				history.updateItem(queryName, registeredEngineName, location,
+					title, to_utf8(extract, charset).c_str(), language, currentScore);
 				rankDiff = (int)(currentScore - previousScore);
 			}
 			else
 			{
 				// No, this is a new result
-				history.insertItem(queryName, registeredEngineName, location, resultIter->getTitle(), extract, language, currentScore);
+				history.insertItem(queryName, registeredEngineName, location,
+					resultIter->getTitle(), to_utf8(extract, charset).c_str(), language, currentScore);
 				// New results are displayed as such only if the query has already been run on the engine
 				if (isNewQuery == false)
 				{
@@ -503,8 +506,9 @@
 			}
 
 			++count;
-			if (appendResult(title, location, currentScore, language, rankDiff,
-				queryName, engineId, indexId, titleIter, &(*groupIter), true) == true)
+			if (appendResult(to_utf8(title, charset), to_utf8(location, charset),
+				currentScore, language, rankDiff, queryName, engineId, indexId,
+				titleIter, &(*groupIter), true) == true)
 			{
 #ifdef DEBUG
 				cout << "ResultsTree::addResults: added row for result " << count << endl;
@@ -627,7 +631,8 @@
 					if (appendGroup(groupName, newType, groupIter) == true)
 					{
 						// Add result
-						success = appendResult(locale_from_utf8(childRow[m_resultsColumns.m_text]), url,
+						success = appendResult(childRow[m_resultsColumns.m_text],
+							childRow[m_resultsColumns.m_url],
 							(float)atof(locale_from_utf8(childRow[m_resultsColumns.m_score]).c_str()),
 							locale_from_utf8(childRow[m_resultsColumns.m_language]),
 							childRow[m_resultsColumns.m_rankDiff],
@@ -686,7 +691,8 @@
 							if (appendGroup(engineName, newType, groupIter) == true)
 							{
 								// Add result
-								appendResult(locale_from_utf8(childRow[m_resultsColumns.m_text]), url,
+								appendResult(childRow[m_resultsColumns.m_text],
+									childRow[m_resultsColumns.m_url],
 									(float)atof(locale_from_utf8(childRow[m_resultsColumns.m_score]).c_str()),
 									locale_from_utf8(childRow[m_resultsColumns.m_language]),
 									childRow[m_resultsColumns.m_rankDiff],
@@ -958,7 +964,7 @@
 //
 // Adds a new row in the results tree.
 //
-bool ResultsTree::appendResult(const string &text, const string &url,
+bool ResultsTree::appendResult(const ustring &text, const ustring &url,
 	float score, const string &language, int rankDiff,
 	const string &queryName, unsigned int engineId, unsigned int indexId,
 	TreeModel::iterator &newRowIter, const TreeModel::Row *parentRow, bool noDuplicates)
@@ -1007,7 +1013,6 @@
 #endif
 	}
 
-	string strippedText = HtmlTokenizer::stripTags(text);
 	XapianIndex index(m_settings.m_indexLocation);
 	ViewHistory viewHistory(m_settings.m_historyDatabase);
 	bool isIndexed = false;
@@ -1026,8 +1031,7 @@
 	snprintf(scoreStr, 128, "%.f", score);
 
 	TreeModel::Row childRow = *newRowIter;
-	updateRow(childRow, to_utf8(strippedText, "???"),
-		to_utf8(url), scoreStr,
+	updateRow(childRow, text, url, scoreStr,
 		to_utf8(language), to_utf8(queryName), engineId, indexId,
 		ResultsModelColumns::RESULT_TITLE, isIndexed,
 		wasViewed, rankDiff);
@@ -1050,7 +1054,7 @@
 		// No, it isn't: insert a new group in the tree
 		groupIter = m_refStore->append();
 		TreeModel::Row groupRow = *groupIter;
-		updateRow(groupRow, to_utf8(groupName, "???"),
+		updateRow(groupRow, to_utf8(groupName),
 				"", "", "", "", 0, 0, groupType,
 				false, false, false);
 

Modified: trunk/UI/GTK2/src/ResultsTree.h
===================================================================
--- trunk/UI/GTK2/src/ResultsTree.h	2005-12-31 11:26:01 UTC (rev 41)
+++ trunk/UI/GTK2/src/ResultsTree.h	2005-12-31 13:11:29 UTC (rev 42)
@@ -56,7 +56,8 @@
 		  * Returns true if something was added to the tree.
 		  */
 		bool addResults(QueryProperties &queryProps, const std::string &engineName,
-			const std::vector<Result> &resultsList, bool groupBySearchEngine);
+			const std::vector<Result> &resultsList, const std::string &charset,
+			bool groupBySearchEngine);
 
 		/// Groups results.
 		void regroupResults(bool groupBySearchEngine);
@@ -131,7 +132,7 @@
 			Gtk::TreeModel::iterator &groupIter);
 
 		/// Adds a new row in the results tree.
-		bool appendResult(const std::string &text, const std::string &url,
+		bool appendResult(const Glib::ustring &text, const Glib::ustring &url,
 			float score, const std::string &language, int rankDiff,
 			const std::string &queryName, unsigned int engineId, unsigned int indexId,
 			Gtk::TreeModel::iterator &newRowIter,

Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-31 11:26:01 UTC (rev 41)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-31 13:11:29 UTC (rev 42)
@@ -291,8 +291,13 @@
 	return m_queryProps;
 }
 
-const vector<Result> &QueryingThread::getResults(void) const
+const vector<Result> &QueryingThread::getResults(string &charset) const
 {
+	charset = m_resultsCharset;
+#ifdef DEBUG
+	cout << "QueryingThread::getResults: charset is " << charset << endl;
+#endif
+
 	return m_resultsList;
 }
 
@@ -331,9 +336,11 @@
 	{
 		const vector<Result> &resultsList = engine->getResults();
 
-		// Copy the results list
 		m_resultsList.clear();
 		m_resultsList.reserve(resultsList.size());
+		m_resultsCharset = engine->getResultsCharset();
+
+		// Copy the results list
 		for (vector<Result>::const_iterator resultIter = resultsList.begin();
 			resultIter != resultsList.end(); ++resultIter)
 		{
@@ -763,8 +770,7 @@
 		}
 
 		// Use the title we were supplied with ?
-		if ((m_docInfo.getTitle().empty() == false) ||
-			(urlObj.getProtocol() == "file"))
+		if (m_docInfo.getTitle().empty() == false)
 		{
 			m_pDoc->setTitle(m_docInfo.getTitle());
 		}

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2005-12-31 11:26:01 UTC (rev 41)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2005-12-31 13:11:29 UTC (rev 42)
@@ -129,7 +129,7 @@
 
 		QueryProperties getQuery(void) const;
 
-		const std::vector<Result> &getResults(void) const;
+		const std::vector<Result> &getResults(std::string &charset) const;
 
 		virtual bool stop(void);
 
@@ -139,6 +139,7 @@
 		std::string m_engineOption;
 		QueryProperties m_queryProps;
 		std::vector<Result> m_resultsList;
+		std::string m_resultsCharset;
 
 		void do_querying();
 

Modified: trunk/UI/GTK2/src/importDialog.cc
===================================================================
--- trunk/UI/GTK2/src/importDialog.cc	2005-12-31 11:26:01 UTC (rev 41)
+++ trunk/UI/GTK2/src/importDialog.cc	2005-12-31 13:11:29 UTC (rev 42)
@@ -244,7 +244,7 @@
 
 void importDialog::on_selectButton_clicked()
 {
-	ustring fileName = locale_to_utf8(m_directory);
+	ustring fileName = to_utf8(m_directory);
 
 	if (select_file_name(*this, _("Document To Import"), fileName, true, m_importDirectory) == true)
 	{
@@ -257,9 +257,9 @@
 		if (pos != string::npos)
 		{
 			// Update m_directory
-		m_directory = locale_from_utf8(fileName.substr(0, pos + 1));
+			m_directory = locale_from_utf8(fileName.substr(0, pos + 1));
 #ifdef DEBUG
-		cout << "importDialog::on_selectButton_clicked: directory now " << m_directory << endl;
+			cout << "importDialog::on_selectButton_clicked: directory now " << m_directory << endl;
 #endif
 		}
 	}

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-31 11:26:01 UTC (rev 41)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-31 13:11:29 UTC (rev 42)
@@ -818,7 +818,7 @@
 
 		IndexPage *pIndexPage = NULL;
 		IndexTree *pIndexTree = NULL;
-		ustring indexName = locale_to_utf8(pBrowseThread->getIndexName());
+		ustring indexName = to_utf8(pBrowseThread->getIndexName());
 
 		// Find the page for this index
 		pIndexPage = dynamic_cast<IndexPage*>(get_page(indexName, NotebookPageBox::INDEX_PAGE));
@@ -877,7 +877,8 @@
 		QueryProperties queryProps = pQueryThread->getQuery();
 		ustring queryName = to_utf8(queryProps.getName());
 		ustring engineName = to_utf8(pQueryThread->getEngineName());
-		const vector<Result> &resultsList = pQueryThread->getResults();
+		string resultsCharset;
+		const vector<Result> &resultsList = pQueryThread->getResults(resultsCharset);
 
 		status = _("Query");
 		status += " ";
@@ -931,7 +932,8 @@
 		{
 			// Add the results to the tree
 			pResultsTree->addResults(queryProps, engineName,
-				resultsList, searchenginegroup1->get_active());
+				resultsList, resultsCharset,
+				searchenginegroup1->get_active());
 			// Switch to that page
 			m_pNotebook->set_current_page(pageNum);
 		}
@@ -963,7 +965,7 @@
 			delete pThread;
 			return;
 		}
-		ustring indexName = locale_to_utf8(pLabelQueryThread->getIndexName());
+		ustring indexName = to_utf8(pLabelQueryThread->getIndexName());
 
 		IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(indexName, NotebookPageBox::INDEX_PAGE));
 		if (pIndexPage == NULL)
@@ -981,7 +983,7 @@
 		ustring labelName = pIndexPage->getLabelName();
 		if ((pIndexTree->isEmpty() == false) &&
 			(labelName.empty() == false) &&
-			(labelName == locale_to_utf8(pLabelQueryThread->getLabelName())))
+			(labelName == to_utf8(pLabelQueryThread->getLabelName())))
 		{
 			const set<unsigned int> &documentsList = pLabelQueryThread->getDocumentsList();
 			char docsCountStr[64];
@@ -1063,7 +1065,7 @@
 						if (m_pHtmlView->renderData(pData, dataLength, url) == true)
 						{
 							//viewstop1->set_sensitive(true);
-							set_status(locale_to_utf8(url));
+							set_status(to_utf8(url));
 						}
 
 						m_pNotebook->set_current_page(pageNum);
@@ -1122,7 +1124,7 @@
 				// Was the current label applied to that document ?
 				ustring labelName = pIndexPage->getLabelName();
 				if ((labelName.empty() == false) &&
-					(labelName == locale_to_utf8(pIndexThread->getLabelName())))
+					(labelName == to_utf8(pIndexThread->getLabelName())))
 				{
 					labeled = true;
 				}
@@ -1312,7 +1314,7 @@
 	bool hasLabel = false;
 
 	// Find the page for this index
-	pIndexPage = dynamic_cast<IndexPage*>(get_page(locale_to_utf8(indexName), NotebookPageBox::INDEX_PAGE));
+	pIndexPage = dynamic_cast<IndexPage*>(get_page(to_utf8(indexName), NotebookPageBox::INDEX_PAGE));
 	if (pIndexPage == NULL)
 	{
 		// It's probably been closed by the user
@@ -2996,7 +2998,7 @@
 				{
 					//viewstop1->set_sensitive(true);
 				}
-				set_status(locale_to_utf8(m_pHtmlView->getLocation()));
+				set_status(to_utf8(m_pHtmlView->getLocation()));
 			}
 		}
 	}

Modified: trunk/UI/GTK2/src/prefsDialog.cc
===================================================================
--- trunk/UI/GTK2/src/prefsDialog.cc	2005-12-31 11:26:01 UTC (rev 41)
+++ trunk/UI/GTK2/src/prefsDialog.cc	2005-12-31 13:11:29 UTC (rev 42)
@@ -297,8 +297,8 @@
 		TreeModel::iterator iter = m_refMailTree->append();
 		TreeModel::Row row = *iter;
 
-		row[m_mailColumns.m_location] = locale_to_utf8(fileName);
-		row[m_mailColumns.m_type] = locale_to_utf8(mimeType);
+		row[m_mailColumns.m_location] = to_utf8(fileName);
+		row[m_mailColumns.m_type] = to_utf8(mimeType);
 		row[m_mailColumns.m_mTime] = 0;
 		row[m_mailColumns.m_minDate] = 0;
 	}
@@ -360,7 +360,7 @@
 	// Now create a new entry in the labels list
 	TreeModel::iterator iter = m_refLabelsTree->append();
 	TreeModel::Row row = *iter;
-	row[m_labelsColumns.m_name] = locale_to_utf8(_("New Label"));
+	row[m_labelsColumns.m_name] = to_utf8(_("New Label"));
 	// This marks the label as new
 	row[m_labelsColumns.m_enabled] = false;
 	// FIXME: initialize the colour to something meaningful, depending on the current theme perhaps ?
@@ -469,7 +469,7 @@
 		if (select_file_name(*this, _("Mbox File Location"), fileName, true) == true)
 		{
 			row[m_mailColumns.m_location] = fileName;
-			row[m_mailColumns.m_type] = locale_to_utf8(MIMEScanner::scanFile(fileName));
+			row[m_mailColumns.m_type] = to_utf8(MIMEScanner::scanFile(fileName));
 		}
 	}
 }

Modified: trunk/UI/GTK2/src/queryDialog.cc
===================================================================
--- trunk/UI/GTK2/src/queryDialog.cc	2005-12-31 11:26:01 UTC (rev 41)
+++ trunk/UI/GTK2/src/queryDialog.cc	2005-12-31 13:11:29 UTC (rev 42)
@@ -13,6 +13,7 @@
 #include "config.h"
 #include "Languages.h"
 #include "NLS.h"
+#include "PinotUtils.h"
 #include "queryDialog.hh"
 
 using namespace std;
@@ -50,18 +51,18 @@
 	}
 	else
 	{
-		nameEntry->set_text(locale_to_utf8(name));
+		nameEntry->set_text(to_utf8(name));
 	}
 	// Query terms
-	andEntry->set_text(locale_to_utf8(m_properties.getAndWords()));
-	phraseEntry->set_text(locale_to_utf8(m_properties.getPhrase()));
-	anyEntry->set_text(locale_to_utf8(m_properties.getAnyWords()));
-	notEntry->set_text(locale_to_utf8(m_properties.getNotWords()));
+	andEntry->set_text(to_utf8(m_properties.getAndWords()));
+	phraseEntry->set_text(to_utf8(m_properties.getPhrase()));
+	anyEntry->set_text(to_utf8(m_properties.getAnyWords()));
+	notEntry->set_text(to_utf8(m_properties.getNotWords()));
 
 	// Host name
-	hostNameEntry->set_text(locale_to_utf8(m_properties.getHostFilter()));
+	hostNameEntry->set_text(to_utf8(m_properties.getHostFilter()));
 	// File name
-	fileNameEntry->set_text(locale_to_utf8(m_properties.getFileFilter()));
+	fileNameEntry->set_text(to_utf8(m_properties.getFileFilter()));
 	// Maximum number of results
 	resultsCountSpinbutton->set_value((double)m_properties.getMaximumResultsCount());
 	// Index all results
@@ -93,7 +94,7 @@
 
 		iter = m_refLabelNameTree->append();
 		row = *iter;
-		row[m_labelNameColumns.m_name] = locale_to_utf8(labelName);
+		row[m_labelNameColumns.m_name] = to_utf8(labelName);
 		if (labelName == m_properties.getLabelName())
 		{
 			labelNameCombobox->set_active(labelNum);
@@ -101,7 +102,7 @@
 
 		iter = m_refLabelFilterTree->append();
 		row = *iter;
-		row[m_labelFilterColumns.m_name] = locale_to_utf8(labelName);
+		row[m_labelFilterColumns.m_name] = to_utf8(labelName);
 		if (labelName == m_properties.getLabelFilter())
 		{
 			labelFilterCombobox->set_active(labelNum);



From fabricecolin at berlios.de  Sat Dec 31 17:08:45 2005
From: fabricecolin at berlios.de (fabricecolin at BerliOS)
Date: Sat, 31 Dec 2005 17:08:45 +0100
Subject: [Pinot-svn] r43 - trunk/UI/GTK2/src
Message-ID: <200512311608.jBVG8jWo018115@sheep.berlios.de>

Author: fabricecolin
Date: 2005-12-31 17:08:45 +0100 (Sat, 31 Dec 2005)
New Revision: 43

Modified:
   trunk/UI/GTK2/src/WorkerThreads.cpp
   trunk/UI/GTK2/src/WorkerThreads.h
   trunk/UI/GTK2/src/mainWindow.cc
Log:
Simplified IndexThread. Update the details in the tree after a document update.


Modified: trunk/UI/GTK2/src/WorkerThreads.cpp
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-31 13:11:29 UTC (rev 42)
+++ trunk/UI/GTK2/src/WorkerThreads.cpp	2005-12-31 16:08:45 UTC (rev 43)
@@ -651,7 +651,7 @@
 	m_indexLocation = PinotSettings::getInstance().m_indexLocation;
 	// Ignore robots directives on updates
 	m_ignoreRobotsDirectives = true;
-	m_docIdList.insert(docId);
+	m_docId = docId;
 	m_update = true;
 	// Don't trigger signal after the document has been downloaded
 	m_signalAfterDownload = false;
@@ -684,9 +684,9 @@
 	return m_labelName;
 }
 
-const set<unsigned int> &IndexingThread::getDocumentIDs(void) const
+unsigned int IndexingThread::getDocumentID(void) const
 {
-	return m_docIdList;
+	return m_docId;
 }
 
 bool IndexingThread::isNewDocument(void) const
@@ -769,11 +769,19 @@
 			return;
 		}
 
-		// Use the title we were supplied with ?
 		if (m_docInfo.getTitle().empty() == false)
 		{
+			// Use the title we were supplied with
 			m_pDoc->setTitle(m_docInfo.getTitle());
 		}
+		else
+		{
+			// Use the document's
+			m_docInfo.setTitle(m_pDoc->getTitle());
+		}
+#ifdef DEBUG
+		cout << "IndexingThread::do_indexing: title is " << m_pDoc->getTitle() << endl;
+#endif
 
 		// Tokenize this document
 		Tokenizer *pTokens = TokenizerFactory::getTokenizerByType(m_docInfo.getType(), m_pDoc);
@@ -813,18 +821,12 @@
 			index.setStemmingMode(IndexInterface::STORE_BOTH);
 
 			// Update an existing document or add to the index ?
-			if ((m_update == true) &&
-				(m_docIdList.size() == 1))
+			if (m_update == true)
 			{
-				set<unsigned int>::iterator idIter = m_docIdList.begin();
-				if (idIter != m_docIdList.end())
-				{
-					unsigned int docId = *idIter;
-					success = index.updateDocument(docId, *pTokens);
+				success = index.updateDocument(m_docId, *pTokens);
 #ifdef DEBUG
-					cout << "IndexingThread::do_indexing: updated " << docId << endl;
+				cout << "IndexingThread::do_indexing: updated " << m_docId << endl;
 #endif
-				}
 			}
 			else
 			{
@@ -836,7 +838,7 @@
 				success = index.indexDocument(*pTokens, labels, docId);
 				if (success == true)
 				{
-					m_docIdList.insert(docId);
+					m_docId = docId;
 				}
 			}
 

Modified: trunk/UI/GTK2/src/WorkerThreads.h
===================================================================
--- trunk/UI/GTK2/src/WorkerThreads.h	2005-12-31 13:11:29 UTC (rev 42)
+++ trunk/UI/GTK2/src/WorkerThreads.h	2005-12-31 16:08:45 UTC (rev 43)
@@ -253,7 +253,7 @@
 
 		std::string getLabelName(void) const;
 
-		const std::set<unsigned int> &getDocumentIDs(void) const;
+		unsigned int getDocumentID(void) const;
 
 		bool isNewDocument(void) const;
 
@@ -264,7 +264,7 @@
 		std::string m_indexLocation;
 		bool m_ignoreRobotsDirectives;
 		std::string m_labelName;
-		std::set<unsigned int> m_docIdList;
+		unsigned int m_docId;
 		bool m_update;
 
 		void do_indexing();

Modified: trunk/UI/GTK2/src/mainWindow.cc
===================================================================
--- trunk/UI/GTK2/src/mainWindow.cc	2005-12-31 13:11:29 UTC (rev 42)
+++ trunk/UI/GTK2/src/mainWindow.cc	2005-12-31 16:08:45 UTC (rev 43)
@@ -1085,13 +1085,29 @@
 			return;
 		}
 
-		const set<unsigned int> &docIdList = pIndexThread->getDocumentIDs();
+		// Get the document properties
+		unsigned int docId = pIndexThread->getDocumentID();
+		DocumentInfo docInfo = pIndexThread->getDocumentInfo();
 
+		// Is the index still being shown ?
+		IndexTree *pIndexTree = NULL;
+		IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(_("My Documents"), NotebookPageBox::INDEX_PAGE));
+		if (pIndexPage != NULL)
+		{
+			pIndexTree = pIndexPage->getTree();
+		}
+
 		// Did the thread perform an update ?
 		if (pIndexThread->isNewDocument() == false)
 		{
 			// Yes, it did
 			status = _("Updated document");
+
+			if (pIndexTree != NULL)
+			{
+				// Update the index tree
+				pIndexTree->setDocumentTitle(docId, docInfo.getTitle());
+			}
 		}
 		else
 		{
@@ -1114,13 +1130,8 @@
 				m_state.unlock();
 			}
 
-			// Is the index still being shown ?
-			IndexPage *pIndexPage = dynamic_cast<IndexPage*>(get_page(_("My Documents"), NotebookPageBox::INDEX_PAGE));
 			if (pIndexPage != NULL)
 			{
-				IndexTree *pIndexTree = pIndexPage->getTree();
-				XapianIndex index(m_settings.m_indexLocation);
-
 				// Was the current label applied to that document ?
 				ustring labelName = pIndexPage->getLabelName();
 				if ((labelName.empty() == false) &&
@@ -1128,30 +1139,17 @@
 				{
 					labeled = true;
 				}
+			}
 
-				if ((pIndexTree != NULL) &&
-					(index.isGood() == true))
-				{
-					// Update the index tree
-					for (set<unsigned int>::iterator idIter = docIdList.begin();
-						idIter != docIdList.end(); ++idIter)
-					{
-						DocumentInfo docInfo;
-						unsigned int docId = *idIter;
-
-						// Get that document's properties
-						if (index.getDocumentInfo(docId, docInfo) == true)
-						{
-							// Append to the index tree
-							IndexedDocument indexedDoc(docInfo.getTitle(),
-								XapianEngine::buildUrl(m_settings.m_indexLocation, docId),
-								docInfo.getLocation(), docInfo.getType(),
-								docInfo.getLanguage());
-							indexedDoc.setTimestamp(docInfo.getTimestamp());
-							pIndexTree->appendDocument(indexedDoc, labeled);
-						}
-					}
-				}
+			if (pIndexTree != NULL)
+			{
+				// Append to the index tree
+				IndexedDocument indexedDoc(docInfo.getTitle(),
+					XapianEngine::buildUrl(m_settings.m_indexLocation, docId),
+					docInfo.getLocation(), docInfo.getType(),
+					docInfo.getLanguage());
+				indexedDoc.setTimestamp(docInfo.getTimestamp());
+				pIndexTree->appendDocument(indexedDoc, labeled);
 			}
 		}
 



